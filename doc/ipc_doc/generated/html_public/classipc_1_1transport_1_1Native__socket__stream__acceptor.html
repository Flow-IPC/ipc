<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.9.4"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Flow-IPC: ipc::transport::Native_socket_stream_acceptor Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">Flow-IPC<span id="projectnumber">&#160;1.0.2</span>
   </div>
   <div id="projectbrief">Flow-IPC project: Public API.</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.4 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search",'Search','.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespaceipc.html">ipc</a></li><li class="navelem"><a class="el" href="namespaceipc_1_1transport.html">transport</a></li><li class="navelem"><a class="el" href="classipc_1_1transport_1_1Native__socket__stream__acceptor.html">Native_socket_stream_acceptor</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-types">Public Types</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pub-static-attribs">Static Public Attributes</a> &#124;
<a href="#related">Related Functions</a> &#124;
<a href="classipc_1_1transport_1_1Native__socket__stream__acceptor-members.html">List of all members</a>  </div>
  <div class="headertitle"><div class="title">ipc::transport::Native_socket_stream_acceptor Class Reference</div></div>
</div><!--header-->
<div class="contents">

<p>A server object that binds to a <code>Shared_name</code> and listens for incoming <code><a class="el" href="classipc_1_1transport_1_1Native__socket__stream.html" title="Implements both Native_handle_sender and Native_handle_receiver concepts by using a stream-oriented U...">Native_socket_stream</a></code> connect attempts to that name; and yields connected-peer <a class="el" href="classipc_1_1transport_1_1sync__io_1_1Native__socket__stream.html" title="Implements both sync_io::Native_handle_sender and sync_io::Native_handle_receiver concepts by using a...">sync_io::Native_socket_stream</a> objects, one per counterpart opposing <code>*_connect()</code>.  
 <a href="classipc_1_1transport_1_1Native__socket__stream__acceptor.html#details">More...</a></p>

<p><code>#include &lt;native_socket_stream_acceptor.hpp&gt;</code></p>

<p>Inherits flow::log::Log_context, and boost::noncopyable.</p>
<div class="dynheader">
Collaboration diagram for ipc::transport::Native_socket_stream_acceptor:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="classipc_1_1transport_1_1Native__socket__stream__acceptor__coll__graph.svg" width="291" height="203"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe>
</div>
<center><span class="legend">[<a href="graph_legend.html">legend</a>]</span></center></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-types" name="pub-types"></a>
Public Types</h2></td></tr>
<tr class="memitem:a3707eaee28b6bacded15ba4cdab3da48"><td class="memItemLeft" align="right" valign="top"><a id="a3707eaee28b6bacded15ba4cdab3da48" name="a3707eaee28b6bacded15ba4cdab3da48"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>Peer</b> = <a class="el" href="classipc_1_1transport_1_1Native__socket__stream.html#a850af22a95f27d8696b9b5bca15454b5">Native_socket_stream::Sync_io_obj</a></td></tr>
<tr class="memdesc:a3707eaee28b6bacded15ba4cdab3da48"><td class="mdescLeft">&#160;</td><td class="mdescRight">Short-hand for type of target peer-socket objects targeted by <a class="el" href="classipc_1_1transport_1_1Native__socket__stream__acceptor.html#a81426af495ba5a9c832d1ba35fe23ba5" title="Asynchronously awaits for a peer connection to be established and calls on_done_func(),...">async_accept()</a>. <br /></td></tr>
<tr class="separator:a3707eaee28b6bacded15ba4cdab3da48"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac0e1478364d940f243acece27ece5a7c"><td class="memItemLeft" align="right" valign="top"><a id="ac0e1478364d940f243acece27ece5a7c" name="ac0e1478364d940f243acece27ece5a7c"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>Sync_io_obj</b> = <a class="el" href="classipc_1_1transport_1_1sync__io_1_1Native__socket__stream__acceptor.html">sync_io::Native_socket_stream_acceptor</a></td></tr>
<tr class="memdesc:ac0e1478364d940f243acece27ece5a7c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Useful for generic programming, the <code><a class="el" href="namespaceipc_1_1transport_1_1sync__io.html" title="sync_io-pattern counterparts to async-I/O-pattern object types in parent namespace ipc::transport.">sync_io</a></code>-pattern counterpart to <code>*this</code> type. <br /></td></tr>
<tr class="separator:ac0e1478364d940f243acece27ece5a7c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a863aa3fe53c71e3b33814f7caecbb193"><td class="memItemLeft" align="right" valign="top"><a id="a863aa3fe53c71e3b33814f7caecbb193" name="a863aa3fe53c71e3b33814f7caecbb193"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>Async_io_obj</b> = <a class="el" href="classipc_1_1transport_1_1Null__peer.html">Null_peer</a></td></tr>
<tr class="memdesc:a863aa3fe53c71e3b33814f7caecbb193"><td class="mdescLeft">&#160;</td><td class="mdescRight">You may disregard. <br /></td></tr>
<tr class="separator:a863aa3fe53c71e3b33814f7caecbb193"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-methods" name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a77795acb028a95a4804f9b3ef18d99b0"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classipc_1_1transport_1_1Native__socket__stream__acceptor.html#a77795acb028a95a4804f9b3ef18d99b0">Native_socket_stream_acceptor</a> (flow::log::Logger *logger_ptr, const <a class="el" href="namespaceipc_1_1transport.html#a33de1c256addb3964b839dc2dd407d24">Shared_name</a> &amp;<a class="el" href="classipc_1_1transport_1_1Native__socket__stream__acceptor.html#ac5b70ff8230fa49c99ccb6954db71c75">absolute_name</a>, <a class="el" href="namespaceipc.html#aa3192e586cc45d3e7c22463bf2760f89">Error_code</a> *err_code=0)</td></tr>
<tr class="memdesc:a77795acb028a95a4804f9b3ef18d99b0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates the <a class="el" href="classipc_1_1transport_1_1Native__socket__stream__acceptor.html" title="A server object that binds to a Shared_name and listens for incoming Native_socket_stream connect att...">Native_socket_stream_acceptor</a> and immediately begins listening in the background, so that other process(es) can connect to it &ndash; at the specified name &ndash; once the constructor returns successfully.  <a href="classipc_1_1transport_1_1Native__socket__stream__acceptor.html#a77795acb028a95a4804f9b3ef18d99b0">More...</a><br /></td></tr>
<tr class="separator:a77795acb028a95a4804f9b3ef18d99b0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a71e907b904bcc8aff0042ca7efcc783b"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classipc_1_1transport_1_1Native__socket__stream__acceptor.html#a71e907b904bcc8aff0042ca7efcc783b">~Native_socket_stream_acceptor</a> ()</td></tr>
<tr class="memdesc:a71e907b904bcc8aff0042ca7efcc783b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Destroys this acceptor which will stop listening in the background and cancel any pending completion handlers by invoking them ASAP with <a class="el" href="namespaceipc_1_1transport_1_1error.html#adfef15ef4e76cc55d652fbd9c2797297afe29343445a7bf167cc186a44bd2c6ed" title="Async completion handler is being called prematurely, because underlying object is shutting down,...">error::Code::S_OBJECT_SHUTDOWN_ABORTED_COMPLETION_HANDLER</a>.  <a href="classipc_1_1transport_1_1Native__socket__stream__acceptor.html#a71e907b904bcc8aff0042ca7efcc783b">More...</a><br /></td></tr>
<tr class="separator:a71e907b904bcc8aff0042ca7efcc783b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac5b70ff8230fa49c99ccb6954db71c75"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="namespaceipc_1_1transport.html#a33de1c256addb3964b839dc2dd407d24">Shared_name</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classipc_1_1transport_1_1Native__socket__stream__acceptor.html#ac5b70ff8230fa49c99ccb6954db71c75">absolute_name</a> () const</td></tr>
<tr class="memdesc:ac5b70ff8230fa49c99ccb6954db71c75"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the full name/address to which the constructor bound, or attempted to bind, the listening socket.  <a href="classipc_1_1transport_1_1Native__socket__stream__acceptor.html#ac5b70ff8230fa49c99ccb6954db71c75">More...</a><br /></td></tr>
<tr class="separator:ac5b70ff8230fa49c99ccb6954db71c75"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a81426af495ba5a9c832d1ba35fe23ba5"><td class="memTemplParams" colspan="2">template&lt;typename Task_err &gt; </td></tr>
<tr class="memitem:a81426af495ba5a9c832d1ba35fe23ba5"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classipc_1_1transport_1_1Native__socket__stream__acceptor.html#a81426af495ba5a9c832d1ba35fe23ba5">async_accept</a> (<a class="el" href="classipc_1_1transport_1_1Native__socket__stream__acceptor.html#a3707eaee28b6bacded15ba4cdab3da48">Peer</a> *target_peer, Task_err &amp;&amp;on_done_func)</td></tr>
<tr class="memdesc:a81426af495ba5a9c832d1ba35fe23ba5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Asynchronously awaits for a peer connection to be established and calls <code>on_done_func()</code>, once the connection occurs, or an error occurs, in the former case move-assigning a PEER-state <a class="el" href="classipc_1_1transport_1_1Native__socket__stream.html" title="Implements both Native_handle_sender and Native_handle_receiver concepts by using a stream-oriented U...">Native_socket_stream</a> object to the passed-in <a class="el" href="classipc_1_1transport_1_1Native__socket__stream.html" title="Implements both Native_handle_sender and Native_handle_receiver concepts by using a stream-oriented U...">Native_socket_stream</a> <code>*target_peer</code>.  <a href="classipc_1_1transport_1_1Native__socket__stream__acceptor.html#a81426af495ba5a9c832d1ba35fe23ba5">More...</a><br /></td></tr>
<tr class="separator:a81426af495ba5a9c832d1ba35fe23ba5"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-static-attribs" name="pub-static-attribs"></a>
Static Public Attributes</h2></td></tr>
<tr class="memitem:a0de2b6072026584ff1d46538533ed68b"><td class="memItemLeft" align="right" valign="top"><a id="a0de2b6072026584ff1d46538533ed68b" name="a0de2b6072026584ff1d46538533ed68b"></a>
static const <a class="el" href="namespaceipc_1_1transport.html#a33de1c256addb3964b839dc2dd407d24">Shared_name</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>S_RESOURCE_TYPE_ID</b> = Sync_io_obj::S_RESOURCE_TYPE_ID</td></tr>
<tr class="memdesc:a0de2b6072026584ff1d46538533ed68b"><td class="mdescLeft">&#160;</td><td class="mdescRight"><code>Shared_name</code> relative-folder fragment (no separators) identifying this resource type. <br /></td></tr>
<tr class="separator:a0de2b6072026584ff1d46538533ed68b"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="related" name="related"></a>
Related Functions</h2></td></tr>
<tr><td class="ititle" colspan="2"><p >(Note that these are not member functions.) </p>
</td></tr>
<tr class="memitem:a03f0ad84b5d21920a58be5e95f12e69f"><td class="memItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classipc_1_1transport_1_1Native__socket__stream__acceptor.html#a03f0ad84b5d21920a58be5e95f12e69f">operator&lt;&lt;</a> (std::ostream &amp;os, const <a class="el" href="classipc_1_1transport_1_1Native__socket__stream__acceptor.html">Native_socket_stream_acceptor</a> &amp;val)</td></tr>
<tr class="memdesc:a03f0ad84b5d21920a58be5e95f12e69f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Prints string representation of the given <code><a class="el" href="classipc_1_1transport_1_1Native__socket__stream__acceptor.html" title="A server object that binds to a Shared_name and listens for incoming Native_socket_stream connect att...">Native_socket_stream_acceptor</a></code> to the given <code>ostream</code>.  <a href="classipc_1_1transport_1_1Native__socket__stream__acceptor.html#a03f0ad84b5d21920a58be5e95f12e69f">More...</a><br /></td></tr>
<tr class="separator:a03f0ad84b5d21920a58be5e95f12e69f"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p >A server object that binds to a <code>Shared_name</code> and listens for incoming <code><a class="el" href="classipc_1_1transport_1_1Native__socket__stream.html" title="Implements both Native_handle_sender and Native_handle_receiver concepts by using a stream-oriented U...">Native_socket_stream</a></code> connect attempts to that name; and yields connected-peer <a class="el" href="classipc_1_1transport_1_1sync__io_1_1Native__socket__stream.html" title="Implements both sync_io::Native_handle_sender and sync_io::Native_handle_receiver concepts by using a...">sync_io::Native_socket_stream</a> objects, one per counterpart opposing <code>*_connect()</code>. </p>
<dl class="section note"><dt>Note</dt><dd>The method is <a class="el" href="classipc_1_1transport_1_1Native__socket__stream__acceptor.html#a81426af495ba5a9c832d1ba35fe23ba5" title="Asynchronously awaits for a peer connection to be established and calls on_done_func(),...">async_accept()</a>; and it yields a PEER-state <a class="el" href="classipc_1_1transport_1_1sync__io_1_1Native__socket__stream.html" title="Implements both sync_io::Native_handle_sender and sync_io::Native_handle_receiver concepts by using a...">sync_io::Native_socket_stream</a> object. Such an object is called a <code><a class="el" href="namespaceipc_1_1transport_1_1sync__io.html" title="sync_io-pattern counterparts to async-I/O-pattern object types in parent namespace ipc::transport.">sync_io</a></code> <em>core</em>. It is often more convenient to work with an async-I/O-pattern object of type <a class="el" href="classipc_1_1transport_1_1Native__socket__stream.html" title="Implements both Native_handle_sender and Native_handle_receiver concepts by using a stream-oriented U...">Native_socket_stream</a> &ndash; it'll perform work in the background without intervention, etc. To get this simply do: <code><a class="el" href="classipc_1_1transport_1_1Native__socket__stream.html" title="Implements both Native_handle_sender and Native_handle_receiver concepts by using a stream-oriented U...">Native_socket_stream</a> async_x(std::move(sync_x))</code>, where <code>sync_x</code> is the aforementioned PEER-state object of type <code><a class="el" href="classipc_1_1transport_1_1sync__io_1_1Native__socket__stream.html" title="Implements both sync_io::Native_handle_sender and sync_io::Native_handle_receiver concepts by using a...">sync_io::Native_socket_stream</a></code>. (<code>sync_x</code> then becomes as-if-default-constructed again. You can even <a class="el" href="classipc_1_1transport_1_1Native__socket__stream__acceptor.html#a81426af495ba5a9c832d1ba35fe23ba5" title="Asynchronously awaits for a peer connection to be established and calls on_done_func(),...">async_accept()</a> into it again.) </dd>
<dd>
Depending on your context you may also bundle <code>sync_x</code> into <a class="el" href="classipc_1_1transport_1_1Channel.html" title="Peer to a bundle of 1-2 full-duplex pipe(s), one for transmitting unstructured binary blobs; the othe...">Channel</a> <code>sync_c</code> &ndash; then create an async-I/O-pattern <a class="el" href="classipc_1_1transport_1_1Channel.html" title="Peer to a bundle of 1-2 full-duplex pipe(s), one for transmitting unstructured binary blobs; the othe...">Channel</a> via: <code>auto async_c = sync_c.async_io_obj()</code>.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classipc_1_1transport_1_1Native__socket__stream.html" title="Implements both Native_handle_sender and Native_handle_receiver concepts by using a stream-oriented U...">Native_socket_stream</a> doc header. </dd>
<dd>
<a class="el" href="classipc_1_1transport_1_1Native__socket__stream.html#a89d591db714e83dcb55a52738fed1ebb" title="To be invoked in NULL state only, it synchronously and non-blockingly attempts to connect to an oppos...">Native_socket_stream::sync_connect()</a> doc header.</dd></dl>
<p>This object is straightforward to use, and really the only difficulty comes from (1) choosing a <code>Shared_name</code> and (2) the other side knowing that name. Before deciding to use it and how to use it, it is essential to read the "How to use" section of <a class="el" href="classipc_1_1transport_1_1Native__socket__stream.html" title="Implements both Native_handle_sender and Native_handle_receiver concepts by using a stream-oriented U...">Native_socket_stream</a> doc header. It discusses when to use this, versus an easier (name-free) way to yield a connected-peer <a class="el" href="classipc_1_1transport_1_1Native__socket__stream.html" title="Implements both Native_handle_sender and Native_handle_receiver concepts by using a stream-oriented U...">Native_socket_stream</a>. As you'll see, the only difficulty in using the latter is that it does require a <em>one</em>-time use of <a class="el" href="classipc_1_1transport_1_1Native__socket__stream__acceptor.html" title="A server object that binds to a Shared_name and listens for incoming Native_socket_stream connect att...">Native_socket_stream_acceptor</a> after all. However <a class="el" href="namespaceipc_1_1session.html" title="Flow-IPC module providing the broad lifecycle and shared-resource organization – via the session conc...">ipc::session</a> takes care of that internally &ndash; so you would not need to set up a <a class="el" href="classipc_1_1transport_1_1Native__socket__stream__acceptor.html" title="A server object that binds to a Shared_name and listens for incoming Native_socket_stream connect att...">Native_socket_stream_acceptor</a> after all.</p>
<p >So all in all:</p><ul>
<li>If you've got <a class="el" href="namespaceipc_1_1session.html" title="Flow-IPC module providing the broad lifecycle and shared-resource organization – via the session conc...">ipc::session</a> stuff, you don't need <a class="el" href="classipc_1_1transport_1_1Native__socket__stream__acceptor.html" title="A server object that binds to a Shared_name and listens for incoming Native_socket_stream connect att...">Native_socket_stream_acceptor</a>: you can just open a <a class="el" href="classipc_1_1transport_1_1Channel.html" title="Peer to a bundle of 1-2 full-duplex pipe(s), one for transmitting unstructured binary blobs; the othe...">Channel</a> with a native-handles pipe; it'll contain a PEER-state <a class="el" href="classipc_1_1transport_1_1Native__socket__stream.html" title="Implements both Native_handle_sender and Native_handle_receiver concepts by using a stream-oriented U...">Native_socket_stream</a>.</li>
<li>If you are operating outside <a class="el" href="namespaceipc_1_1session.html" title="Flow-IPC module providing the broad lifecycle and shared-resource organization – via the session conc...">ipc::session</a> then this guy here will let you set up a client/server mechanism for <code><a class="el" href="classipc_1_1transport_1_1Native__socket__stream.html" title="Implements both Native_handle_sender and Native_handle_receiver concepts by using a stream-oriented U...">Native_socket_stream</a></code>s.</li>
</ul>
<dl class="todo"><dt><b><a class="el" href="todo.html#_todo000009">Todo:</a></b></dt><dd>At the moment, <em>if</em> one decides to use a <a class="el" href="classipc_1_1transport_1_1Native__socket__stream__acceptor.html" title="A server object that binds to a Shared_name and listens for incoming Native_socket_stream connect att...">Native_socket_stream_acceptor</a> directly &ndash; not really necessary given <a class="el" href="namespaceipc_1_1session.html" title="Flow-IPC module providing the broad lifecycle and shared-resource organization – via the session conc...">ipc::session</a> <code><a class="el" href="classipc_1_1transport_1_1Channel.html" title="Peer to a bundle of 1-2 full-duplex pipe(s), one for transmitting unstructured binary blobs; the othe...">Channel</a></code>-opening capabilities &ndash; the the user must come up with their own naming scheme that avoids name clashes; we could supply an <a class="el" href="namespaceipc_1_1session.html" title="Flow-IPC module providing the broad lifecycle and shared-resource organization – via the session conc...">ipc::session</a>-facilitated system for providing this service instead. I.e., <a class="el" href="namespaceipc_1_1session.html" title="Flow-IPC module providing the broad lifecycle and shared-resource organization – via the session conc...">ipc::session</a> could either expose a facility for generating the <code>Shared_name absolute_name</code> arg to the <a class="el" href="classipc_1_1transport_1_1Native__socket__stream__acceptor.html" title="A server object that binds to a Shared_name and listens for incoming Native_socket_stream connect att...">Native_socket_stream_acceptor</a> ctor (and opposing <a class="el" href="classipc_1_1transport_1_1Native__socket__stream.html#a89d591db714e83dcb55a52738fed1ebb" title="To be invoked in NULL state only, it synchronously and non-blockingly attempts to connect to an oppos...">Native_socket_stream::sync_connect()</a> call). Alternatively it could provide some kind of <a class="el" href="classipc_1_1transport_1_1Native__socket__stream__acceptor.html" title="A server object that binds to a Shared_name and listens for incoming Native_socket_stream connect att...">Native_socket_stream_acceptor</a> factory and corresponding opposing facility. Long story short, within the <a class="el" href="namespaceipc_1_1session.html" title="Flow-IPC module providing the broad lifecycle and shared-resource organization – via the session conc...">ipc::session</a> way of life literally only one acceptor exists, and it is set up (and named) internally to <a class="el" href="namespaceipc_1_1session.html" title="Flow-IPC module providing the broad lifecycle and shared-resource organization – via the session conc...">ipc::session</a>. We could provide a way to facilitate the creation of more acceptors if desired by helping to choose their <code>Shared_name</code>s. (An original "paper" design did specify a naming scheme for this.)</dd></dl>
</div><h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="a77795acb028a95a4804f9b3ef18d99b0" name="a77795acb028a95a4804f9b3ef18d99b0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a77795acb028a95a4804f9b3ef18d99b0">&#9670;&nbsp;</a></span>Native_socket_stream_acceptor()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">ipc::transport::Native_socket_stream_acceptor::Native_socket_stream_acceptor </td>
          <td>(</td>
          <td class="paramtype">flow::log::Logger *&#160;</td>
          <td class="paramname"><em>logger_ptr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespaceipc_1_1transport.html#a33de1c256addb3964b839dc2dd407d24">Shared_name</a> &amp;&#160;</td>
          <td class="paramname"><em>absolute_name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceipc.html#aa3192e586cc45d3e7c22463bf2760f89">Error_code</a> *&#160;</td>
          <td class="paramname"><em>err_code</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">explicit</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Creates the <a class="el" href="classipc_1_1transport_1_1Native__socket__stream__acceptor.html" title="A server object that binds to a Shared_name and listens for incoming Native_socket_stream connect att...">Native_socket_stream_acceptor</a> and immediately begins listening in the background, so that other process(es) can connect to it &ndash; at the specified name &ndash; once the constructor returns successfully. </p>
<p >The operation may fail; see <code>err_code</code> arg for how to detect this (either exception or via code return; your choice). An error will be logged on failure.</p>
<p >On success, opposing processes can attempt <a class="el" href="classipc_1_1transport_1_1Native__socket__stream.html#a89d591db714e83dcb55a52738fed1ebb" title="To be invoked in NULL state only, it synchronously and non-blockingly attempts to connect to an oppos...">Native_socket_stream::sync_connect()</a> (or <a class="el" href="classipc_1_1transport_1_1sync__io_1_1Native__socket__stream.html#a2e22d55369f5bd67a4e0d277b73f2823" title="Identical to Async_io_obj counterpart.">sync_io::Native_socket_stream::sync_connect()</a>) which will quickly succeed yielding an opposing <a class="el" href="classipc_1_1transport_1_1Native__socket__stream__acceptor.html#a3707eaee28b6bacded15ba4cdab3da48" title="Short-hand for type of target peer-socket objects targeted by async_accept().">Peer</a> which will be connected. On this side, <a class="el" href="classipc_1_1transport_1_1Native__socket__stream__acceptor.html#a81426af495ba5a9c832d1ba35fe23ba5" title="Asynchronously awaits for a peer connection to be established and calls on_done_func(),...">async_accept()</a> is used to grab local peer <a class="el" href="classipc_1_1transport_1_1Native__socket__stream__acceptor.html#a3707eaee28b6bacded15ba4cdab3da48" title="Short-hand for type of target peer-socket objects targeted by async_accept().">Peer</a>. The connection need not have an <a class="el" href="classipc_1_1transport_1_1Native__socket__stream__acceptor.html#a81426af495ba5a9c832d1ba35fe23ba5" title="Asynchronously awaits for a peer connection to be established and calls on_done_func(),...">async_accept()</a> pending to complete connection as observed by the opposing process.</p>
<p >Assuming this ctor succeeds, further background operation may detect an unrecoverable error. If this occurs, it will occur exactly once, and it is guaranteed no connections will be accepted subsequently; <code><a class="el" href="classipc_1_1transport_1_1Native__socket__stream__acceptor.html#a81426af495ba5a9c832d1ba35fe23ba5" title="Asynchronously awaits for a peer connection to be established and calls on_done_func(),...">async_accept()</a></code>s beyond that point (once all successfully queued-up connects, if any, are exhausted) will fail with that error.</p>
<p ><code>absolute_name</code> should be considered carefully. It cannot clash with another acceptor in existence, and it might even be a mediocre idea to clash with one that <em>has</em> recently existed. Plus the opposing <a class="el" href="classipc_1_1transport_1_1Native__socket__stream.html" title="Implements both Native_handle_sender and Native_handle_receiver concepts by using a stream-oriented U...">Native_socket_stream</a> (or <a class="el" href="classipc_1_1transport_1_1sync__io_1_1Native__socket__stream.html" title="Implements both sync_io::Native_handle_sender and sync_io::Native_handle_receiver concepts by using a...">sync_io::Native_socket_stream</a>) needs to know <code>absolute_name</code>.</p>
<h3>Rationale/context</h3>
<p >An <a class="el" href="classipc_1_1transport_1_1Native__socket__stream__acceptor.html" title="A server object that binds to a Shared_name and listens for incoming Native_socket_stream connect att...">Native_socket_stream_acceptor</a> is unlikely to be used except by <a class="el" href="namespaceipc_1_1session.html" title="Flow-IPC module providing the broad lifecycle and shared-resource organization – via the session conc...">ipc::session</a>, internally, in any case. Once a session is established, one is ~certain to use <a class="el" href="classipc_1_1transport_1_1Channel.html" title="Peer to a bundle of 1-2 full-duplex pipe(s), one for transmitting unstructured binary blobs; the othe...">ipc::transport::Channel</a> to establish connections, and that intentionally avoids <a class="el" href="classipc_1_1transport_1_1Native__socket__stream__acceptor.html" title="A server object that binds to a Shared_name and listens for incoming Native_socket_stream connect att...">Native_socket_stream_acceptor</a>, because then one need not worry about this thorny naming issue. Nevertheless we provide <a class="el" href="classipc_1_1transport_1_1Native__socket__stream__acceptor.html" title="A server object that binds to a Shared_name and listens for incoming Native_socket_stream connect att...">Native_socket_stream_acceptor</a> as a public API, in case it's generally useful.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">logger_ptr</td><td>Logger to use for subsequently logging. </td></tr>
    <tr><td class="paramname">absolute_name</td><td>The absolute name at which to bind and listen for connections. </td></tr>
    <tr><td class="paramname">err_code</td><td>See <code>flow::Error_code</code> docs for error reporting semantics. <a class="el" href="namespaceipc.html#aa3192e586cc45d3e7c22463bf2760f89" title="Short-hand for flow::Error_code which is very common.">Error_code</a> generated: <code>boost::asio::error::invalid_argument</code> (<a class="el" href="classipc_1_1transport_1_1Native__socket__stream__acceptor.html" title="A server object that binds to a Shared_name and listens for incoming Native_socket_stream connect att...">Native_socket_stream_acceptor</a> failed to initialize specifically: because the given or computed address/name ended up too long to fit into natively-mandated data structures; or because there are invalid characters therein, most likely forward-slash), <code>boost::asio::error::address_in_use</code> (<a class="el" href="classipc_1_1transport_1_1Native__socket__stream__acceptor.html" title="A server object that binds to a Shared_name and listens for incoming Native_socket_stream connect att...">Native_socket_stream_acceptor</a> failed to initialize due to a name clash), possibly other system codes (<a class="el" href="classipc_1_1transport_1_1Native__socket__stream__acceptor.html" title="A server object that binds to a Shared_name and listens for incoming Native_socket_stream connect att...">Native_socket_stream_acceptor</a> failed to initialize for some other reason we could not predict here, but whatever it was was logged). </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a71e907b904bcc8aff0042ca7efcc783b" name="a71e907b904bcc8aff0042ca7efcc783b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a71e907b904bcc8aff0042ca7efcc783b">&#9670;&nbsp;</a></span>~Native_socket_stream_acceptor()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ipc::transport::Native_socket_stream_acceptor::~Native_socket_stream_acceptor </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Destroys this acceptor which will stop listening in the background and cancel any pending completion handlers by invoking them ASAP with <a class="el" href="namespaceipc_1_1transport_1_1error.html#adfef15ef4e76cc55d652fbd9c2797297afe29343445a7bf167cc186a44bd2c6ed" title="Async completion handler is being called prematurely, because underlying object is shutting down,...">error::Code::S_OBJECT_SHUTDOWN_ABORTED_COMPLETION_HANDLER</a>. </p>
<p >You must not call this from directly within a completion handler; else undefined behavior.</p>
<p >Each pending completion handler will be called from an unspecified thread that is not the calling thread. Any associated captured state for that handler will be freed shortly after the handler returns.</p>
<p >We informally but very strongly recommend that your completion handler immediately return if the <code>Error_code</code> passed to it is <a class="el" href="namespaceipc_1_1transport_1_1error.html#adfef15ef4e76cc55d652fbd9c2797297afe29343445a7bf167cc186a44bd2c6ed" title="Async completion handler is being called prematurely, because underlying object is shutting down,...">error::Code::S_OBJECT_SHUTDOWN_ABORTED_COMPLETION_HANDLER</a>. This is similar to what one should do when using boost.asio and receiving the conceptually identical <code>operation_aborted</code> error code to an <code>async_...()</code> completion handler. In both cases, this condition means, "we have decided to shut this thing down,
so the completion handlers are simply being informed of this." </p>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="ac5b70ff8230fa49c99ccb6954db71c75" name="ac5b70ff8230fa49c99ccb6954db71c75"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac5b70ff8230fa49c99ccb6954db71c75">&#9670;&nbsp;</a></span>absolute_name()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="namespaceipc_1_1transport.html#a33de1c256addb3964b839dc2dd407d24">Shared_name</a> &amp; ipc::transport::Native_socket_stream_acceptor::absolute_name </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the full name/address to which the constructor bound, or attempted to bind, the listening socket. </p>
<dl class="section return"><dt>Returns</dt><dd>See above. </dd></dl>

</div>
</div>
<a id="a81426af495ba5a9c832d1ba35fe23ba5" name="a81426af495ba5a9c832d1ba35fe23ba5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a81426af495ba5a9c832d1ba35fe23ba5">&#9670;&nbsp;</a></span>async_accept()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Task_err &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void ipc::transport::Native_socket_stream_acceptor::async_accept </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classipc_1_1transport_1_1Native__socket__stream__acceptor.html#a3707eaee28b6bacded15ba4cdab3da48">Peer</a> *&#160;</td>
          <td class="paramname"><em>target_peer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Task_err &amp;&amp;&#160;</td>
          <td class="paramname"><em>on_done_func</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Asynchronously awaits for a peer connection to be established and calls <code>on_done_func()</code>, once the connection occurs, or an error occurs, in the former case move-assigning a PEER-state <a class="el" href="classipc_1_1transport_1_1Native__socket__stream.html" title="Implements both Native_handle_sender and Native_handle_receiver concepts by using a stream-oriented U...">Native_socket_stream</a> object to the passed-in <a class="el" href="classipc_1_1transport_1_1Native__socket__stream.html" title="Implements both Native_handle_sender and Native_handle_receiver concepts by using a stream-oriented U...">Native_socket_stream</a> <code>*target_peer</code>. </p>
<p ><code>on_done_func(Error_code())</code> is called on success. <code>on_done_func(E)</code>, where <code>E</code> is a non-success error code, is called otherwise. In the latter case <code>*this</code> has met an unrecoverable error and should be shut down via the destructor, as no further <code><a class="el" href="classipc_1_1transport_1_1Native__socket__stream__acceptor.html#a81426af495ba5a9c832d1ba35fe23ba5" title="Asynchronously awaits for a peer connection to be established and calls on_done_func(),...">async_accept()</a></code>s will succeed (they'll quickly yield the same error).</p>
<p >Multiple <a class="el" href="classipc_1_1transport_1_1Native__socket__stream__acceptor.html#a81426af495ba5a9c832d1ba35fe23ba5" title="Asynchronously awaits for a peer connection to be established and calls on_done_func(),...">async_accept()</a> calls can be queued while no connection is pending; they will grab incoming connections in FIFO fashion as they arrive.</p>
<p >The aforementioned <a class="el" href="classipc_1_1transport_1_1Native__socket__stream__acceptor.html#a3707eaee28b6bacded15ba4cdab3da48" title="Short-hand for type of target peer-socket objects targeted by async_accept().">Peer</a> generated and move-assigned to <code>*target_peer</code> on success shall inherit <code>this-&gt;get_logger()</code> as its <code>-&gt;get_logger()</code>; and its sync_op::Native_socket_stream::nickname() shall be something descriptive.</p>
<p ><code>on_done_func()</code> shall be called from some unspecified thread, not the calling thread, but never concurrently with other such completion handlers. Your implementation must be non-blocking. Informally we recommend it place the true on-event logic onto some task loop of your own; so ideally it would consist of essentially a single <code>post(F)</code> statement of some kind. There are certainly reasons to not follow this recommendation, though, in some use cases.</p>
<p ><code>on_done_func()</code> <em>will</em> be called; at the latest when the destructor is invoked (see below).</p>
<p >You may call this from directly within a completion handler. Handlers will still always be called non-concurrently, and a handler will never be called from within a handler (so it is safe, e.g., to bracket your handler with a non-recursive mutex lock).</p>
<p ><a class="el" href="namespaceipc.html#aa3192e586cc45d3e7c22463bf2760f89" title="Short-hand for flow::Error_code which is very common.">Error_code</a> generated and passed to <code>on_done_func()</code>: <a class="el" href="namespaceipc_1_1transport_1_1error.html#adfef15ef4e76cc55d652fbd9c2797297afe29343445a7bf167cc186a44bd2c6ed" title="Async completion handler is being called prematurely, because underlying object is shutting down,...">error::Code::S_OBJECT_SHUTDOWN_ABORTED_COMPLETION_HANDLER</a> (destructor called, canceling all pending ops; spiritually identical to <code>boost::asio::error::operation_aborted</code>), other system codes most likely from <code>boost::asio::error</code> or <code>boost::system::errc</code> (but never would-block), indicating the underlying transport is hosed for that specific reason.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Task_err</td><td>Handler type matching signature of <code>flow::async::Task_asio_err</code>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">target_peer</td><td>Pointer to <a class="el" href="classipc_1_1transport_1_1sync__io_1_1Native__socket__stream.html" title="Implements both sync_io::Native_handle_sender and sync_io::Native_handle_receiver concepts by using a...">sync_io::Native_socket_stream</a> which shall be assigned a PEER-state (connected) as <code>on_done_func()</code> is called. Not touched on error. </td></tr>
    <tr><td class="paramname">on_done_func</td><td>Completion handler. See above. The captured state in this function object shall be freed shortly upon its completed execution from the unspecified thread. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<h2 class="groupheader">Friends And Related Function Documentation</h2>
<a id="a03f0ad84b5d21920a58be5e95f12e69f" name="a03f0ad84b5d21920a58be5e95f12e69f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a03f0ad84b5d21920a58be5e95f12e69f">&#9670;&nbsp;</a></span>operator&lt;&lt;()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::ostream &amp; operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>os</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classipc_1_1transport_1_1Native__socket__stream__acceptor.html">Native_socket_stream_acceptor</a> &amp;&#160;</td>
          <td class="paramname"><em>val</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Prints string representation of the given <code><a class="el" href="classipc_1_1transport_1_1Native__socket__stream__acceptor.html" title="A server object that binds to a Shared_name and listens for incoming Native_socket_stream connect att...">Native_socket_stream_acceptor</a></code> to the given <code>ostream</code>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">os</td><td>Stream to which to write. </td></tr>
    <tr><td class="paramname">val</td><td>Object to serialize. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>os</code>. </dd></dl>

</div>
</div>
<hr/>The documentation for this class was generated from the following files:<ul>
<li>transport/<a class="el" href="native__socket__stream__acceptor_8hpp.html">native_socket_stream_acceptor.hpp</a></li>
<li>transport/<a class="el" href="native__socket__stream__acceptor_8cpp.html">native_socket_stream_acceptor.cpp</a></li>
<li>transport/<a class="el" href="transport__fwd_8hpp.html">transport_fwd.hpp</a></li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Sat Jan 18 2025 02:15:55 for Flow-IPC by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.4
</small></address>
</body>
</html>
