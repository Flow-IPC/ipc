<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.9.4"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Flow-IPC: ipc::transport::sync_io::Native_socket_stream Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">Flow-IPC<span id="projectnumber">&#160;1.0</span>
   </div>
   <div id="projectbrief">Flow-IPC project: Public API.</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.4 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search",'Search','.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespaceipc.html">ipc</a></li><li class="navelem"><a class="el" href="namespaceipc_1_1transport.html">transport</a></li><li class="navelem"><a class="el" href="namespaceipc_1_1transport_1_1sync__io.html">sync_io</a></li><li class="navelem"><a class="el" href="classipc_1_1transport_1_1sync__io_1_1Native__socket__stream.html">Native_socket_stream</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-types">Public Types</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pub-static-attribs">Static Public Attributes</a> &#124;
<a href="#related">Related Functions</a> &#124;
<a href="classipc_1_1transport_1_1sync__io_1_1Native__socket__stream-members.html">List of all members</a>  </div>
  <div class="headertitle"><div class="title">ipc::transport::sync_io::Native_socket_stream Class Reference</div></div>
</div><!--header-->
<div class="contents">

<p>Implements both <a class="el" href="classipc_1_1transport_1_1sync__io_1_1Native__handle__sender.html" title="A documentation-only concept defining the behavior of an object that is the sync_io-pattern counterpa...">sync_io::Native_handle_sender</a> and <a class="el" href="classipc_1_1transport_1_1sync__io_1_1Native__handle__receiver.html" title="A documentation-only concept defining the behavior of an object that is the sync_io-pattern counterpa...">sync_io::Native_handle_receiver</a> concepts by using a stream-oriented Unix domain socket, allowing high-performance but non-zero-copy transmission of discrete messages, each containing a native handle, a binary blob, or both.  
 <a href="classipc_1_1transport_1_1sync__io_1_1Native__socket__stream.html#details">More...</a></p>

<p><code>#include &lt;native_socket_stream.hpp&gt;</code></p>
<div class="dynheader">
Collaboration diagram for ipc::transport::sync_io::Native_socket_stream:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="classipc_1_1transport_1_1sync__io_1_1Native__socket__stream__coll__graph.svg" width="294" height="203"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe>
</div>
<center><span class="legend">[<a href="graph_legend.html">legend</a>]</span></center></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-types" name="pub-types"></a>
Public Types</h2></td></tr>
<tr class="memitem:a24d39cb096987f483f233d9d4ab51ecf"><td class="memItemLeft" align="right" valign="top"><a id="a24d39cb096987f483f233d9d4ab51ecf" name="a24d39cb096987f483f233d9d4ab51ecf"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>Async_io_obj</b> = <a class="el" href="classipc_1_1transport_1_1Native__socket__stream.html">transport::Native_socket_stream</a></td></tr>
<tr class="memdesc:a24d39cb096987f483f233d9d4ab51ecf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Useful for generic programming, the async-I/O-pattern counterpart to <code>*this</code> type. <br /></td></tr>
<tr class="separator:a24d39cb096987f483f233d9d4ab51ecf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a74c58ffad50d8be50a58693626df3610"><td class="memItemLeft" align="right" valign="top"><a id="a74c58ffad50d8be50a58693626df3610" name="a74c58ffad50d8be50a58693626df3610"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>Sync_io_obj</b> = <a class="el" href="classipc_1_1transport_1_1Null__peer.html">Null_peer</a></td></tr>
<tr class="memdesc:a74c58ffad50d8be50a58693626df3610"><td class="mdescLeft">&#160;</td><td class="mdescRight">You may disregard. <br /></td></tr>
<tr class="separator:a74c58ffad50d8be50a58693626df3610"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-methods" name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a3176682a76814cc3f0fe5b79f7665aec"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classipc_1_1transport_1_1sync__io_1_1Native__socket__stream.html#a3176682a76814cc3f0fe5b79f7665aec">Native_socket_stream</a> ()</td></tr>
<tr class="memdesc:a3176682a76814cc3f0fe5b79f7665aec"><td class="mdescLeft">&#160;</td><td class="mdescRight">Default ctor (object is in NULL state).  <a href="classipc_1_1transport_1_1sync__io_1_1Native__socket__stream.html#a3176682a76814cc3f0fe5b79f7665aec">More...</a><br /></td></tr>
<tr class="separator:a3176682a76814cc3f0fe5b79f7665aec"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afcfa1e87af688fea34809949ecbcdad0"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classipc_1_1transport_1_1sync__io_1_1Native__socket__stream.html#afcfa1e87af688fea34809949ecbcdad0">Native_socket_stream</a> (flow::log::Logger *logger_ptr, <a class="el" href="namespaceipc_1_1util.html#ae6ac47812a90d1287c61e0b7de7bc4f5">util::String_view</a> nickname_str)</td></tr>
<tr class="memdesc:afcfa1e87af688fea34809949ecbcdad0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a <a class="el" href="classipc_1_1transport_1_1sync__io_1_1Native__socket__stream.html" title="Implements both sync_io::Native_handle_sender and sync_io::Native_handle_receiver concepts by using a...">Native_socket_stream</a> in NULL (not connected, not connecting) state.  <a href="classipc_1_1transport_1_1sync__io_1_1Native__socket__stream.html#afcfa1e87af688fea34809949ecbcdad0">More...</a><br /></td></tr>
<tr class="separator:afcfa1e87af688fea34809949ecbcdad0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae8294867c6153e62ba9e8b683d3d8594"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classipc_1_1transport_1_1sync__io_1_1Native__socket__stream.html#ae8294867c6153e62ba9e8b683d3d8594">Native_socket_stream</a> (flow::log::Logger *logger_ptr, <a class="el" href="namespaceipc_1_1util.html#ae6ac47812a90d1287c61e0b7de7bc4f5">util::String_view</a> nickname_str, <a class="el" href="namespaceipc_1_1transport.html#a7ee4551983d9df16ec16a3139bac50e8">Native_handle</a> &amp;&amp;native_peer_socket_moved)</td></tr>
<tr class="memdesc:ae8294867c6153e62ba9e8b683d3d8594"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructs the socket-and-meta-blob stream by taking over an already-connected native Unix domain socket handle.  <a href="classipc_1_1transport_1_1sync__io_1_1Native__socket__stream.html#ae8294867c6153e62ba9e8b683d3d8594">More...</a><br /></td></tr>
<tr class="separator:ae8294867c6153e62ba9e8b683d3d8594"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a11a1c1609f5e2be428fb26af868ca9ec"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classipc_1_1transport_1_1sync__io_1_1Native__socket__stream.html#a11a1c1609f5e2be428fb26af868ca9ec">Native_socket_stream</a> (<a class="el" href="classipc_1_1transport_1_1sync__io_1_1Native__socket__stream.html">Native_socket_stream</a> &amp;&amp;src)</td></tr>
<tr class="memdesc:a11a1c1609f5e2be428fb26af868ca9ec"><td class="mdescLeft">&#160;</td><td class="mdescRight">Move-constructs from <code>src</code>; <code>src</code> becomes as-if default-cted (therefore in NULL state).  <a href="classipc_1_1transport_1_1sync__io_1_1Native__socket__stream.html#a11a1c1609f5e2be428fb26af868ca9ec">More...</a><br /></td></tr>
<tr class="separator:a11a1c1609f5e2be428fb26af868ca9ec"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4ddf33dea2a6bb2a50c421642bd7fccd"><td class="memItemLeft" align="right" valign="top"><a id="a4ddf33dea2a6bb2a50c421642bd7fccd" name="a4ddf33dea2a6bb2a50c421642bd7fccd"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>Native_socket_stream</b> (const <a class="el" href="classipc_1_1transport_1_1sync__io_1_1Native__socket__stream.html">Native_socket_stream</a> &amp;)=delete</td></tr>
<tr class="memdesc:a4ddf33dea2a6bb2a50c421642bd7fccd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy construction is disallowed. <br /></td></tr>
<tr class="separator:a4ddf33dea2a6bb2a50c421642bd7fccd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adaea5a18b4e62fa7496ada4a2509b3fe"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classipc_1_1transport_1_1sync__io_1_1Native__socket__stream.html#adaea5a18b4e62fa7496ada4a2509b3fe">~Native_socket_stream</a> ()</td></tr>
<tr class="memdesc:adaea5a18b4e62fa7496ada4a2509b3fe"><td class="mdescLeft">&#160;</td><td class="mdescRight">Implements <a class="el" href="classipc_1_1transport_1_1sync__io_1_1Native__handle__sender.html" title="A documentation-only concept defining the behavior of an object that is the sync_io-pattern counterpa...">Native_handle_sender</a> <em>and</em> <a class="el" href="classipc_1_1transport_1_1sync__io_1_1Native__handle__receiver.html" title="A documentation-only concept defining the behavior of an object that is the sync_io-pattern counterpa...">Native_handle_receiver</a> APIs at the same time, per their concept contracts.  <a href="classipc_1_1transport_1_1sync__io_1_1Native__socket__stream.html#adaea5a18b4e62fa7496ada4a2509b3fe">More...</a><br /></td></tr>
<tr class="separator:adaea5a18b4e62fa7496ada4a2509b3fe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a918cc2c153d278b19a81ca2b1e93e6bd"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classipc_1_1transport_1_1sync__io_1_1Native__socket__stream.html">Native_socket_stream</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classipc_1_1transport_1_1sync__io_1_1Native__socket__stream.html#a918cc2c153d278b19a81ca2b1e93e6bd">operator=</a> (<a class="el" href="classipc_1_1transport_1_1sync__io_1_1Native__socket__stream.html">Native_socket_stream</a> &amp;&amp;src)</td></tr>
<tr class="memdesc:a918cc2c153d278b19a81ca2b1e93e6bd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Move-assigns from <code>src</code>; <code>*this</code> acts as if destructed; <code>src</code> becomes as-if default-cted (therefore in NULL state).  <a href="classipc_1_1transport_1_1sync__io_1_1Native__socket__stream.html#a918cc2c153d278b19a81ca2b1e93e6bd">More...</a><br /></td></tr>
<tr class="separator:a918cc2c153d278b19a81ca2b1e93e6bd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3379e0892316b1185a85629fb8f5a04e"><td class="memItemLeft" align="right" valign="top"><a id="a3379e0892316b1185a85629fb8f5a04e" name="a3379e0892316b1185a85629fb8f5a04e"></a>
<a class="el" href="classipc_1_1transport_1_1sync__io_1_1Native__socket__stream.html">Native_socket_stream</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>operator=</b> (const <a class="el" href="classipc_1_1transport_1_1sync__io_1_1Native__socket__stream.html">Native_socket_stream</a> &amp;)=delete</td></tr>
<tr class="memdesc:a3379e0892316b1185a85629fb8f5a04e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy assignment is disallowed. <br /></td></tr>
<tr class="separator:a3379e0892316b1185a85629fb8f5a04e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac6dc47cc06da9404e02fe83012adb768"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classipc_1_1transport_1_1sync__io_1_1Native__socket__stream.html">Native_socket_stream</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classipc_1_1transport_1_1sync__io_1_1Native__socket__stream.html#ac6dc47cc06da9404e02fe83012adb768">release</a> ()</td></tr>
<tr class="memdesc:ac6dc47cc06da9404e02fe83012adb768"><td class="mdescLeft">&#160;</td><td class="mdescRight">In PEER state only, with no prior send or receive ops, returns an object of this same type (as-if just constructed) operating on <code>*this</code> underlying low-level transport <code>Native_handle</code>; while <code>*this</code> becomes as-if default-cted.  <a href="classipc_1_1transport_1_1sync__io_1_1Native__socket__stream.html#ac6dc47cc06da9404e02fe83012adb768">More...</a><br /></td></tr>
<tr class="separator:ac6dc47cc06da9404e02fe83012adb768"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a80cb628f57f12c19f7ce46d0894c773a"><td class="memItemLeft" align="right" valign="top">const std::string &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classipc_1_1transport_1_1sync__io_1_1Native__socket__stream.html#a80cb628f57f12c19f7ce46d0894c773a">nickname</a> () const</td></tr>
<tr class="memdesc:a80cb628f57f12c19f7ce46d0894c773a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns nickname, a brief string suitable for logging.  <a href="classipc_1_1transport_1_1sync__io_1_1Native__socket__stream.html#a80cb628f57f12c19f7ce46d0894c773a">More...</a><br /></td></tr>
<tr class="separator:a80cb628f57f12c19f7ce46d0894c773a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aac68d14f4ef33505399df4fd04cd4669"><td class="memItemLeft" align="right" valign="top">flow::log::Logger *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classipc_1_1transport_1_1sync__io_1_1Native__socket__stream.html#aac68d14f4ef33505399df4fd04cd4669">get_logger</a> () const</td></tr>
<tr class="memdesc:aac68d14f4ef33505399df4fd04cd4669"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns logger (possibly null).  <a href="classipc_1_1transport_1_1sync__io_1_1Native__socket__stream.html#aac68d14f4ef33505399df4fd04cd4669">More...</a><br /></td></tr>
<tr class="separator:aac68d14f4ef33505399df4fd04cd4669"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af5e6e5ccf19782cb698017e9dcf85b34"><td class="memTemplParams" colspan="2">template&lt;typename Create_ev_wait_hndl_func &gt; </td></tr>
<tr class="memitem:af5e6e5ccf19782cb698017e9dcf85b34"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classipc_1_1transport_1_1sync__io_1_1Native__socket__stream.html#af5e6e5ccf19782cb698017e9dcf85b34">replace_event_wait_handles</a> (const Create_ev_wait_hndl_func &amp;create_ev_wait_hndl_func)</td></tr>
<tr class="memdesc:af5e6e5ccf19782cb698017e9dcf85b34"><td class="mdescLeft">&#160;</td><td class="mdescRight">Implements <a class="el" href="classipc_1_1transport_1_1sync__io_1_1Native__handle__sender.html" title="A documentation-only concept defining the behavior of an object that is the sync_io-pattern counterpa...">Native_handle_sender</a> <em>and</em> <a class="el" href="classipc_1_1transport_1_1sync__io_1_1Native__handle__receiver.html" title="A documentation-only concept defining the behavior of an object that is the sync_io-pattern counterpa...">Native_handle_receiver</a> APIs at the same time, per their concept contracts.  <a href="classipc_1_1transport_1_1sync__io_1_1Native__socket__stream.html#af5e6e5ccf19782cb698017e9dcf85b34">More...</a><br /></td></tr>
<tr class="separator:af5e6e5ccf19782cb698017e9dcf85b34"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a97fa6328b1d77a9ee212e09721fc398e"><td class="memTemplParams" colspan="2">template&lt;typename Event_wait_func_t &gt; </td></tr>
<tr class="memitem:a97fa6328b1d77a9ee212e09721fc398e"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classipc_1_1transport_1_1sync__io_1_1Native__socket__stream.html#a97fa6328b1d77a9ee212e09721fc398e">start_connect_ops</a> (Event_wait_func_t &amp;&amp;ev_wait_func)</td></tr>
<tr class="memdesc:a97fa6328b1d77a9ee212e09721fc398e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets up the <code><a class="el" href="namespaceipc_1_1transport_1_1sync__io.html" title="sync_io-pattern counterparts to async-I/O-pattern object types in parent namespace ipc::transport.">sync_io</a></code>-pattern interaction between <code>*this</code> and the user's event loop; required before <a class="el" href="classipc_1_1transport_1_1sync__io_1_1Native__socket__stream.html#a3fed4817936af7f23d2beb8f75999d8d" title="See Async_io_obj counterpart for the essential semantics; however here according to sync_io pattern t...">async_connect()</a> will work (as opposed to no-op/return <code>false</code>).  <a href="classipc_1_1transport_1_1sync__io_1_1Native__socket__stream.html#a97fa6328b1d77a9ee212e09721fc398e">More...</a><br /></td></tr>
<tr class="separator:a97fa6328b1d77a9ee212e09721fc398e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3fed4817936af7f23d2beb8f75999d8d"><td class="memTemplParams" colspan="2">template&lt;typename Task_err &gt; </td></tr>
<tr class="memitem:a3fed4817936af7f23d2beb8f75999d8d"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classipc_1_1transport_1_1sync__io_1_1Native__socket__stream.html#a3fed4817936af7f23d2beb8f75999d8d">async_connect</a> (const <a class="el" href="namespaceipc_1_1transport.html#a33de1c256addb3964b839dc2dd407d24">Shared_name</a> &amp;absolute_name, <a class="el" href="namespaceipc.html#aa3192e586cc45d3e7c22463bf2760f89">Error_code</a> *sync_err_code, Task_err &amp;&amp;on_done_func)</td></tr>
<tr class="memdesc:a3fed4817936af7f23d2beb8f75999d8d"><td class="mdescLeft">&#160;</td><td class="mdescRight">See <a class="el" href="classipc_1_1transport_1_1sync__io_1_1Native__socket__stream.html#a24d39cb096987f483f233d9d4ab51ecf" title="Useful for generic programming, the async-I/O-pattern counterpart to *this type.">Async_io_obj</a> counterpart for the essential semantics; however here according to <code><a class="el" href="namespaceipc_1_1transport_1_1sync__io.html" title="sync_io-pattern counterparts to async-I/O-pattern object types in parent namespace ipc::transport.">sync_io</a></code> pattern the operation may complete synchronously thus emitting result immediately and ignoring <code>on_done_func</code>.  <a href="classipc_1_1transport_1_1sync__io_1_1Native__socket__stream.html#a3fed4817936af7f23d2beb8f75999d8d">More...</a><br /></td></tr>
<tr class="separator:a3fed4817936af7f23d2beb8f75999d8d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a945fb744696feed25067241ce2b6ca4b"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classipc_1_1transport_1_1sync__io_1_1Native__socket__stream.html#a945fb744696feed25067241ce2b6ca4b">send_meta_blob_max_size</a> () const</td></tr>
<tr class="memdesc:a945fb744696feed25067241ce2b6ca4b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Implements <a class="el" href="classipc_1_1transport_1_1sync__io_1_1Native__handle__sender.html" title="A documentation-only concept defining the behavior of an object that is the sync_io-pattern counterpa...">Native_handle_sender</a> API per contract.  <a href="classipc_1_1transport_1_1sync__io_1_1Native__socket__stream.html#a945fb744696feed25067241ce2b6ca4b">More...</a><br /></td></tr>
<tr class="separator:a945fb744696feed25067241ce2b6ca4b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aabfd97c75d56d3f7a492d95040f4b8ab"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classipc_1_1transport_1_1sync__io_1_1Native__socket__stream.html#aabfd97c75d56d3f7a492d95040f4b8ab">send_blob_max_size</a> () const</td></tr>
<tr class="memdesc:aabfd97c75d56d3f7a492d95040f4b8ab"><td class="mdescLeft">&#160;</td><td class="mdescRight">Implements <a class="el" href="classipc_1_1transport_1_1sync__io_1_1Blob__sender.html" title="A documentation-only concept: what transport::Blob_sender is to transport::Native_handle_sender (name...">Blob_sender</a> API per contract.  <a href="classipc_1_1transport_1_1sync__io_1_1Native__socket__stream.html#aabfd97c75d56d3f7a492d95040f4b8ab">More...</a><br /></td></tr>
<tr class="separator:aabfd97c75d56d3f7a492d95040f4b8ab"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2bd0b6a8badd0b770917bb9df9ad6093"><td class="memTemplParams" colspan="2">template&lt;typename Event_wait_func_t &gt; </td></tr>
<tr class="memitem:a2bd0b6a8badd0b770917bb9df9ad6093"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classipc_1_1transport_1_1sync__io_1_1Native__socket__stream.html#a2bd0b6a8badd0b770917bb9df9ad6093">start_send_native_handle_ops</a> (Event_wait_func_t &amp;&amp;ev_wait_func)</td></tr>
<tr class="memdesc:a2bd0b6a8badd0b770917bb9df9ad6093"><td class="mdescLeft">&#160;</td><td class="mdescRight">Implements <a class="el" href="classipc_1_1transport_1_1sync__io_1_1Native__handle__sender.html" title="A documentation-only concept defining the behavior of an object that is the sync_io-pattern counterpa...">Native_handle_sender</a> API per contract.  <a href="classipc_1_1transport_1_1sync__io_1_1Native__socket__stream.html#a2bd0b6a8badd0b770917bb9df9ad6093">More...</a><br /></td></tr>
<tr class="separator:a2bd0b6a8badd0b770917bb9df9ad6093"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2b1fa31c4d8ac11683472b83efe7956a"><td class="memTemplParams" colspan="2">template&lt;typename Event_wait_func_t &gt; </td></tr>
<tr class="memitem:a2b1fa31c4d8ac11683472b83efe7956a"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classipc_1_1transport_1_1sync__io_1_1Native__socket__stream.html#a2b1fa31c4d8ac11683472b83efe7956a">start_send_blob_ops</a> (Event_wait_func_t &amp;&amp;ev_wait_func)</td></tr>
<tr class="memdesc:a2b1fa31c4d8ac11683472b83efe7956a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Implements <a class="el" href="classipc_1_1transport_1_1sync__io_1_1Blob__sender.html" title="A documentation-only concept: what transport::Blob_sender is to transport::Native_handle_sender (name...">Blob_sender</a> API per contract.  <a href="classipc_1_1transport_1_1sync__io_1_1Native__socket__stream.html#a2b1fa31c4d8ac11683472b83efe7956a">More...</a><br /></td></tr>
<tr class="separator:a2b1fa31c4d8ac11683472b83efe7956a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9805f7625a1272af64295555f9a1a61b"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classipc_1_1transport_1_1sync__io_1_1Native__socket__stream.html#a9805f7625a1272af64295555f9a1a61b">send_native_handle</a> (<a class="el" href="namespaceipc_1_1transport.html#a7ee4551983d9df16ec16a3139bac50e8">Native_handle</a> hndl_or_null, const <a class="el" href="namespaceipc_1_1util.html#ae0be7edba7e30ffa3f8b742af621f2ab">util::Blob_const</a> &amp;meta_blob, <a class="el" href="namespaceipc.html#aa3192e586cc45d3e7c22463bf2760f89">Error_code</a> *err_code=0)</td></tr>
<tr class="memdesc:a9805f7625a1272af64295555f9a1a61b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Implements <a class="el" href="classipc_1_1transport_1_1sync__io_1_1Native__handle__sender.html" title="A documentation-only concept defining the behavior of an object that is the sync_io-pattern counterpa...">Native_handle_sender</a> API per contract.  <a href="classipc_1_1transport_1_1sync__io_1_1Native__socket__stream.html#a9805f7625a1272af64295555f9a1a61b">More...</a><br /></td></tr>
<tr class="separator:a9805f7625a1272af64295555f9a1a61b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2e1474a87ee8f5ec18bf6cc8d6cfe7b2"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classipc_1_1transport_1_1sync__io_1_1Native__socket__stream.html#a2e1474a87ee8f5ec18bf6cc8d6cfe7b2">send_blob</a> (const <a class="el" href="namespaceipc_1_1util.html#ae0be7edba7e30ffa3f8b742af621f2ab">util::Blob_const</a> &amp;blob, <a class="el" href="namespaceipc.html#aa3192e586cc45d3e7c22463bf2760f89">Error_code</a> *err_code=0)</td></tr>
<tr class="memdesc:a2e1474a87ee8f5ec18bf6cc8d6cfe7b2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Implements <a class="el" href="classipc_1_1transport_1_1sync__io_1_1Blob__sender.html" title="A documentation-only concept: what transport::Blob_sender is to transport::Native_handle_sender (name...">Blob_sender</a> API per contract.  <a href="classipc_1_1transport_1_1sync__io_1_1Native__socket__stream.html#a2e1474a87ee8f5ec18bf6cc8d6cfe7b2">More...</a><br /></td></tr>
<tr class="separator:a2e1474a87ee8f5ec18bf6cc8d6cfe7b2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afb680eb576497ac7e05e8294b49da0eb"><td class="memTemplParams" colspan="2">template&lt;typename Task_err &gt; </td></tr>
<tr class="memitem:afb680eb576497ac7e05e8294b49da0eb"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classipc_1_1transport_1_1sync__io_1_1Native__socket__stream.html#afb680eb576497ac7e05e8294b49da0eb">async_end_sending</a> (<a class="el" href="namespaceipc.html#aa3192e586cc45d3e7c22463bf2760f89">Error_code</a> *sync_err_code, Task_err &amp;&amp;on_done_func)</td></tr>
<tr class="memdesc:afb680eb576497ac7e05e8294b49da0eb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Implements <a class="el" href="classipc_1_1transport_1_1sync__io_1_1Native__handle__sender.html" title="A documentation-only concept defining the behavior of an object that is the sync_io-pattern counterpa...">Native_handle_sender</a>, <a class="el" href="classipc_1_1transport_1_1sync__io_1_1Blob__sender.html" title="A documentation-only concept: what transport::Blob_sender is to transport::Native_handle_sender (name...">Blob_sender</a> API per contract.  <a href="classipc_1_1transport_1_1sync__io_1_1Native__socket__stream.html#afb680eb576497ac7e05e8294b49da0eb">More...</a><br /></td></tr>
<tr class="separator:afb680eb576497ac7e05e8294b49da0eb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a69ed821cc3a41b68dd56880d45033a45"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classipc_1_1transport_1_1sync__io_1_1Native__socket__stream.html#a69ed821cc3a41b68dd56880d45033a45">end_sending</a> ()</td></tr>
<tr class="memdesc:a69ed821cc3a41b68dd56880d45033a45"><td class="mdescLeft">&#160;</td><td class="mdescRight">Implements <a class="el" href="classipc_1_1transport_1_1sync__io_1_1Native__handle__sender.html" title="A documentation-only concept defining the behavior of an object that is the sync_io-pattern counterpa...">Native_handle_sender</a>, <a class="el" href="classipc_1_1transport_1_1sync__io_1_1Blob__sender.html" title="A documentation-only concept: what transport::Blob_sender is to transport::Native_handle_sender (name...">Blob_sender</a> API per contract.  <a href="classipc_1_1transport_1_1sync__io_1_1Native__socket__stream.html#a69ed821cc3a41b68dd56880d45033a45">More...</a><br /></td></tr>
<tr class="separator:a69ed821cc3a41b68dd56880d45033a45"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaef9afdeb3800df615a01b22070acad8"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classipc_1_1transport_1_1sync__io_1_1Native__socket__stream.html#aaef9afdeb3800df615a01b22070acad8">auto_ping</a> (<a class="el" href="namespaceipc_1_1util.html#ac66141280c3b7295a86b65209f31cc58">util::Fine_duration</a> period=boost::chrono::seconds(2))</td></tr>
<tr class="memdesc:aaef9afdeb3800df615a01b22070acad8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Implements <a class="el" href="classipc_1_1transport_1_1sync__io_1_1Native__handle__sender.html" title="A documentation-only concept defining the behavior of an object that is the sync_io-pattern counterpa...">Native_handle_sender</a>, <a class="el" href="classipc_1_1transport_1_1sync__io_1_1Blob__sender.html" title="A documentation-only concept: what transport::Blob_sender is to transport::Native_handle_sender (name...">Blob_sender</a> API per contract.  <a href="classipc_1_1transport_1_1sync__io_1_1Native__socket__stream.html#aaef9afdeb3800df615a01b22070acad8">More...</a><br /></td></tr>
<tr class="separator:aaef9afdeb3800df615a01b22070acad8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acc5f3cae4c5ff2facb5795c5013374e6"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classipc_1_1transport_1_1sync__io_1_1Native__socket__stream.html#acc5f3cae4c5ff2facb5795c5013374e6">receive_meta_blob_max_size</a> () const</td></tr>
<tr class="memdesc:acc5f3cae4c5ff2facb5795c5013374e6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Implements <a class="el" href="classipc_1_1transport_1_1sync__io_1_1Native__handle__receiver.html" title="A documentation-only concept defining the behavior of an object that is the sync_io-pattern counterpa...">Native_handle_receiver</a> API per contract.  <a href="classipc_1_1transport_1_1sync__io_1_1Native__socket__stream.html#acc5f3cae4c5ff2facb5795c5013374e6">More...</a><br /></td></tr>
<tr class="separator:acc5f3cae4c5ff2facb5795c5013374e6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa9ca8bbb8148c00f810a516b4fd66608"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classipc_1_1transport_1_1sync__io_1_1Native__socket__stream.html#aa9ca8bbb8148c00f810a516b4fd66608">receive_blob_max_size</a> () const</td></tr>
<tr class="memdesc:aa9ca8bbb8148c00f810a516b4fd66608"><td class="mdescLeft">&#160;</td><td class="mdescRight">Implements <a class="el" href="classipc_1_1transport_1_1sync__io_1_1Blob__receiver.html" title="A documentation-only concept: what transport::Blob_receiver is to transport::Native_handle_receiver (...">Blob_receiver</a> API per contract.  <a href="classipc_1_1transport_1_1sync__io_1_1Native__socket__stream.html#aa9ca8bbb8148c00f810a516b4fd66608">More...</a><br /></td></tr>
<tr class="separator:aa9ca8bbb8148c00f810a516b4fd66608"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac6d65bc2852ad8800cb57a23311fbe7e"><td class="memTemplParams" colspan="2">template&lt;typename Event_wait_func_t &gt; </td></tr>
<tr class="memitem:ac6d65bc2852ad8800cb57a23311fbe7e"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classipc_1_1transport_1_1sync__io_1_1Native__socket__stream.html#ac6d65bc2852ad8800cb57a23311fbe7e">start_receive_native_handle_ops</a> (Event_wait_func_t &amp;&amp;ev_wait_func)</td></tr>
<tr class="memdesc:ac6d65bc2852ad8800cb57a23311fbe7e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Implements <a class="el" href="classipc_1_1transport_1_1sync__io_1_1Native__handle__receiver.html" title="A documentation-only concept defining the behavior of an object that is the sync_io-pattern counterpa...">Native_handle_receiver</a> API per contract.  <a href="classipc_1_1transport_1_1sync__io_1_1Native__socket__stream.html#ac6d65bc2852ad8800cb57a23311fbe7e">More...</a><br /></td></tr>
<tr class="separator:ac6d65bc2852ad8800cb57a23311fbe7e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a931e45a395d0bef15084db3b6b1e9754"><td class="memTemplParams" colspan="2">template&lt;typename Event_wait_func_t &gt; </td></tr>
<tr class="memitem:a931e45a395d0bef15084db3b6b1e9754"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classipc_1_1transport_1_1sync__io_1_1Native__socket__stream.html#a931e45a395d0bef15084db3b6b1e9754">start_receive_blob_ops</a> (Event_wait_func_t &amp;&amp;ev_wait_func)</td></tr>
<tr class="memdesc:a931e45a395d0bef15084db3b6b1e9754"><td class="mdescLeft">&#160;</td><td class="mdescRight">Implements <a class="el" href="classipc_1_1transport_1_1sync__io_1_1Blob__receiver.html" title="A documentation-only concept: what transport::Blob_receiver is to transport::Native_handle_receiver (...">Blob_receiver</a> API per contract.  <a href="classipc_1_1transport_1_1sync__io_1_1Native__socket__stream.html#a931e45a395d0bef15084db3b6b1e9754">More...</a><br /></td></tr>
<tr class="separator:a931e45a395d0bef15084db3b6b1e9754"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a04effad6ce75fc5c8e6cbee5a26b73e8"><td class="memTemplParams" colspan="2">template&lt;typename Task_err_sz &gt; </td></tr>
<tr class="memitem:a04effad6ce75fc5c8e6cbee5a26b73e8"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classipc_1_1transport_1_1sync__io_1_1Native__socket__stream.html#a04effad6ce75fc5c8e6cbee5a26b73e8">async_receive_native_handle</a> (<a class="el" href="namespaceipc_1_1transport.html#a7ee4551983d9df16ec16a3139bac50e8">Native_handle</a> *target_hndl, const <a class="el" href="namespaceipc_1_1util.html#a6cb62ae434900f3a8915b33ec5d61a96">util::Blob_mutable</a> &amp;target_meta_blob, <a class="el" href="namespaceipc.html#aa3192e586cc45d3e7c22463bf2760f89">Error_code</a> *sync_err_code, size_t *sync_sz, Task_err_sz &amp;&amp;on_done_func)</td></tr>
<tr class="memdesc:a04effad6ce75fc5c8e6cbee5a26b73e8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Implements <a class="el" href="classipc_1_1transport_1_1sync__io_1_1Native__handle__receiver.html" title="A documentation-only concept defining the behavior of an object that is the sync_io-pattern counterpa...">Native_handle_receiver</a> API per contract.  <a href="classipc_1_1transport_1_1sync__io_1_1Native__socket__stream.html#a04effad6ce75fc5c8e6cbee5a26b73e8">More...</a><br /></td></tr>
<tr class="separator:a04effad6ce75fc5c8e6cbee5a26b73e8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8b5fc40ddcdda4b7c78672e9b9dc53c2"><td class="memTemplParams" colspan="2">template&lt;typename Task_err_sz &gt; </td></tr>
<tr class="memitem:a8b5fc40ddcdda4b7c78672e9b9dc53c2"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classipc_1_1transport_1_1sync__io_1_1Native__socket__stream.html#a8b5fc40ddcdda4b7c78672e9b9dc53c2">async_receive_blob</a> (const <a class="el" href="namespaceipc_1_1util.html#a6cb62ae434900f3a8915b33ec5d61a96">util::Blob_mutable</a> &amp;target_blob, <a class="el" href="namespaceipc.html#aa3192e586cc45d3e7c22463bf2760f89">Error_code</a> *sync_err_code, size_t *sync_sz, Task_err_sz &amp;&amp;on_done_func)</td></tr>
<tr class="memdesc:a8b5fc40ddcdda4b7c78672e9b9dc53c2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Implements <a class="el" href="classipc_1_1transport_1_1sync__io_1_1Blob__receiver.html" title="A documentation-only concept: what transport::Blob_receiver is to transport::Native_handle_receiver (...">Blob_receiver</a> API per contract.  <a href="classipc_1_1transport_1_1sync__io_1_1Native__socket__stream.html#a8b5fc40ddcdda4b7c78672e9b9dc53c2">More...</a><br /></td></tr>
<tr class="separator:a8b5fc40ddcdda4b7c78672e9b9dc53c2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac645b3e69ee3bfda64c0e9fda62f656a"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classipc_1_1transport_1_1sync__io_1_1Native__socket__stream.html#ac645b3e69ee3bfda64c0e9fda62f656a">idle_timer_run</a> (<a class="el" href="namespaceipc_1_1util.html#ac66141280c3b7295a86b65209f31cc58">util::Fine_duration</a> timeout=boost::chrono::seconds(5))</td></tr>
<tr class="memdesc:ac645b3e69ee3bfda64c0e9fda62f656a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Implements <a class="el" href="classipc_1_1transport_1_1sync__io_1_1Native__handle__receiver.html" title="A documentation-only concept defining the behavior of an object that is the sync_io-pattern counterpa...">Native_handle_receiver</a>, <a class="el" href="classipc_1_1transport_1_1sync__io_1_1Blob__receiver.html" title="A documentation-only concept: what transport::Blob_receiver is to transport::Native_handle_receiver (...">Blob_receiver</a> API per contract.  <a href="classipc_1_1transport_1_1sync__io_1_1Native__socket__stream.html#ac645b3e69ee3bfda64c0e9fda62f656a">More...</a><br /></td></tr>
<tr class="separator:ac645b3e69ee3bfda64c0e9fda62f656a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a16b605c316922325415d60aeb0af3c40"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classipc_1_1util_1_1Process__credentials.html">util::Process_credentials</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classipc_1_1transport_1_1sync__io_1_1Native__socket__stream.html#a16b605c316922325415d60aeb0af3c40">remote_peer_process_credentials</a> (<a class="el" href="namespaceipc.html#aa3192e586cc45d3e7c22463bf2760f89">Error_code</a> *err_code=0) const</td></tr>
<tr class="memdesc:a16b605c316922325415d60aeb0af3c40"><td class="mdescLeft">&#160;</td><td class="mdescRight">OS-reported process credential (PID, etc.) info about the <em>other</em> connected peer's process, at the time that the OS first established (via local-socket-connect or local-socket-connected-pair-generate call) that opposing peer socket.  <a href="classipc_1_1transport_1_1sync__io_1_1Native__socket__stream.html#a16b605c316922325415d60aeb0af3c40">More...</a><br /></td></tr>
<tr class="separator:a16b605c316922325415d60aeb0af3c40"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-static-attribs" name="pub-static-attribs"></a>
Static Public Attributes</h2></td></tr>
<tr class="memitem:a2d6076a9515718eb9f66c88886e482fa"><td class="memItemLeft" align="right" valign="top"><a id="a2d6076a9515718eb9f66c88886e482fa" name="a2d6076a9515718eb9f66c88886e482fa"></a>
static const <a class="el" href="namespaceipc_1_1transport.html#a33de1c256addb3964b839dc2dd407d24">Shared_name</a>&#160;</td><td class="memItemRight" valign="bottom"><b>S_RESOURCE_TYPE_ID</b> = <a class="el" href="classipc_1_1util_1_1Shared__name.html#a48f20b7b54490aa10dc64081d34c55b2">Shared_name::ct</a>(&quot;lclSock&quot;)</td></tr>
<tr class="memdesc:a2d6076a9515718eb9f66c88886e482fa"><td class="mdescLeft">&#160;</td><td class="mdescRight">Implements concept API. <br /></td></tr>
<tr class="separator:a2d6076a9515718eb9f66c88886e482fa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aab8f0844b61c700b3ab6ab50e3389fff"><td class="memItemLeft" align="right" valign="top">static constexpr bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classipc_1_1transport_1_1sync__io_1_1Native__socket__stream.html#aab8f0844b61c700b3ab6ab50e3389fff">S_META_BLOB_UNDERFLOW_ALLOWED</a> = true</td></tr>
<tr class="memdesc:aab8f0844b61c700b3ab6ab50e3389fff"><td class="mdescLeft">&#160;</td><td class="mdescRight">Implements concept API; namely it is <code>true</code>.  <a href="classipc_1_1transport_1_1sync__io_1_1Native__socket__stream.html#aab8f0844b61c700b3ab6ab50e3389fff">More...</a><br /></td></tr>
<tr class="separator:aab8f0844b61c700b3ab6ab50e3389fff"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7034a92ae66759080c035b36ff851e0c"><td class="memItemLeft" align="right" valign="top">static constexpr bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classipc_1_1transport_1_1sync__io_1_1Native__socket__stream.html#a7034a92ae66759080c035b36ff851e0c">S_BLOB_UNDERFLOW_ALLOWED</a> = true</td></tr>
<tr class="memdesc:a7034a92ae66759080c035b36ff851e0c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Implements concept API; namely it is <code>true</code>.  <a href="classipc_1_1transport_1_1sync__io_1_1Native__socket__stream.html#a7034a92ae66759080c035b36ff851e0c">More...</a><br /></td></tr>
<tr class="separator:a7034a92ae66759080c035b36ff851e0c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af2ebc6eabb5f5b4ed5e0264f0fca3db7"><td class="memItemLeft" align="right" valign="top"><a id="af2ebc6eabb5f5b4ed5e0264f0fca3db7" name="af2ebc6eabb5f5b4ed5e0264f0fca3db7"></a>
static constexpr bool&#160;</td><td class="memItemRight" valign="bottom"><b>S_TRANSMIT_NATIVE_HANDLES</b> = true</td></tr>
<tr class="memdesc:af2ebc6eabb5f5b4ed5e0264f0fca3db7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Useful for generic programming: <code>true</code> to indicate a <code>*this</code> has a <a class="el" href="classipc_1_1transport_1_1sync__io_1_1Native__socket__stream.html#a9805f7625a1272af64295555f9a1a61b" title="Implements Native_handle_sender API per contract.">send_native_handle()</a> and an <a class="el" href="classipc_1_1transport_1_1sync__io_1_1Native__socket__stream.html#a04effad6ce75fc5c8e6cbee5a26b73e8" title="Implements Native_handle_receiver API per contract.">async_receive_native_handle()</a>. <br /></td></tr>
<tr class="separator:af2ebc6eabb5f5b4ed5e0264f0fca3db7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a00624e2fc3757012d13e3dc0feb26a21"><td class="memItemLeft" align="right" valign="top">static const size_t &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classipc_1_1transport_1_1sync__io_1_1Native__socket__stream.html#a00624e2fc3757012d13e3dc0feb26a21">S_MAX_META_BLOB_LENGTH</a> = Impl::S_MAX_META_BLOB_LENGTH</td></tr>
<tr class="memdesc:a00624e2fc3757012d13e3dc0feb26a21"><td class="mdescLeft">&#160;</td><td class="mdescRight">The maximum length of a blob that can be sent by this protocol.  <a href="classipc_1_1transport_1_1sync__io_1_1Native__socket__stream.html#a00624e2fc3757012d13e3dc0feb26a21">More...</a><br /></td></tr>
<tr class="separator:a00624e2fc3757012d13e3dc0feb26a21"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="related" name="related"></a>
Related Functions</h2></td></tr>
<tr><td class="ititle" colspan="2"><p >(Note that these are not member functions.) </p>
</td></tr>
<tr class="memitem:ac6108711cc8b33c3b7ef0491ba78e2f6"><td class="memItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classipc_1_1transport_1_1sync__io_1_1Native__socket__stream.html#ac6108711cc8b33c3b7ef0491ba78e2f6">operator&lt;&lt;</a> (std::ostream &amp;os, const <a class="el" href="classipc_1_1transport_1_1sync__io_1_1Native__socket__stream.html">Native_socket_stream</a> &amp;val)</td></tr>
<tr class="memdesc:ac6108711cc8b33c3b7ef0491ba78e2f6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Prints string representation of the given <code><a class="el" href="classipc_1_1transport_1_1sync__io_1_1Native__socket__stream.html" title="Implements both sync_io::Native_handle_sender and sync_io::Native_handle_receiver concepts by using a...">Native_socket_stream</a></code> to the given <code>ostream</code>.  <a href="classipc_1_1transport_1_1sync__io_1_1Native__socket__stream.html#ac6108711cc8b33c3b7ef0491ba78e2f6">More...</a><br /></td></tr>
<tr class="separator:ac6108711cc8b33c3b7ef0491ba78e2f6"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p >Implements both <a class="el" href="classipc_1_1transport_1_1sync__io_1_1Native__handle__sender.html" title="A documentation-only concept defining the behavior of an object that is the sync_io-pattern counterpa...">sync_io::Native_handle_sender</a> and <a class="el" href="classipc_1_1transport_1_1sync__io_1_1Native__handle__receiver.html" title="A documentation-only concept defining the behavior of an object that is the sync_io-pattern counterpa...">sync_io::Native_handle_receiver</a> concepts by using a stream-oriented Unix domain socket, allowing high-performance but non-zero-copy transmission of discrete messages, each containing a native handle, a binary blob, or both. </p>
<p >This is the <code><a class="el" href="namespaceipc_1_1transport_1_1sync__io.html" title="sync_io-pattern counterparts to async-I/O-pattern object types in parent namespace ipc::transport.">sync_io</a></code>-pattern counterpart to <a class="el" href="classipc_1_1transport_1_1Native__socket__stream.html" title="Implements both Native_handle_sender and Native_handle_receiver concepts by using a stream-oriented U...">transport::Native_socket_stream</a> &ndash; and in fact the latter use an instance of the present class as its core.</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classipc_1_1transport_1_1Native__socket__stream.html" title="Implements both Native_handle_sender and Native_handle_receiver concepts by using a stream-oriented U...">transport::Native_socket_stream</a> and <a class="el" href="namespaceipc_1_1util_1_1sync__io.html" title="Contains common code, as well as important explanatory documentation in the following text,...">util::sync_io</a> doc headers. The latter describes the general pattern which we implement here; it also contrasts it with the async-I/O pattern, which the former implements. In general we recommend you use a <a class="el" href="classipc_1_1transport_1_1Native__socket__stream.html" title="Implements both Native_handle_sender and Native_handle_receiver concepts by using a stream-oriented U...">transport::Native_socket_stream</a> rather than a <code>*this</code> &ndash; but you may have particular needs (summarized in <a class="el" href="namespaceipc_1_1util_1_1sync__io.html" title="Contains common code, as well as important explanatory documentation in the following text,...">util::sync_io</a> doc header) that would make you decide otherwise.</dd></dl>
<h3>Quick note on naming</h3>
<p >Notes for <a class="el" href="classipc_1_1transport_1_1Native__socket__stream.html" title="Implements both Native_handle_sender and Native_handle_receiver concepts by using a stream-oriented U...">transport::Native_socket_stream</a> apply.</p>
<h3><a class="el" href="classipc_1_1transport_1_1sync__io_1_1Blob__sender.html" title="A documentation-only concept: what transport::Blob_sender is to transport::Native_handle_sender (name...">sync_io::Blob_sender</a> and <a class="el" href="classipc_1_1transport_1_1sync__io_1_1Blob__receiver.html" title="A documentation-only concept: what transport::Blob_receiver is to transport::Native_handle_receiver (...">sync_io::Blob_receiver</a> concept compatibility</h3>
<p >Notes for <a class="el" href="classipc_1_1transport_1_1Native__socket__stream.html" title="Implements both Native_handle_sender and Native_handle_receiver concepts by using a stream-oriented U...">transport::Native_socket_stream</a> apply analogously.</p>
<h3>Informal comparison to other core transport mechanisms</h3>
<p >Notes for <a class="el" href="classipc_1_1transport_1_1Native__socket__stream.html" title="Implements both Native_handle_sender and Native_handle_receiver concepts by using a stream-oriented U...">transport::Native_socket_stream</a> apply.</p>
<h3>Cleanup</h3>
<p >Notes for <a class="el" href="classipc_1_1transport_1_1Native__socket__stream.html" title="Implements both Native_handle_sender and Native_handle_receiver concepts by using a stream-oriented U...">transport::Native_socket_stream</a> apply.</p>
<h3>How to use</h3>
<p >Notes for <a class="el" href="classipc_1_1transport_1_1Native__socket__stream.html" title="Implements both Native_handle_sender and Native_handle_receiver concepts by using a stream-oriented U...">transport::Native_socket_stream</a> apply. The differences (some of which are quite important) are as follows.</p>
<p >Before using <a class="el" href="classipc_1_1transport_1_1sync__io_1_1Native__socket__stream.html#a3fed4817936af7f23d2beb8f75999d8d" title="See Async_io_obj counterpart for the essential semantics; however here according to sync_io pattern t...">async_connect()</a>, one must set up the "connect" API according to the <code><a class="el" href="namespaceipc_1_1transport_1_1sync__io.html" title="sync_io-pattern counterparts to async-I/O-pattern object types in parent namespace ipc::transport.">sync_io</a></code> pattern. Namely one must use <a class="el" href="classipc_1_1transport_1_1sync__io_1_1Native__socket__stream.html#a97fa6328b1d77a9ee212e09721fc398e" title="Sets up the sync_io-pattern interaction between *this and the user&#39;s event loop; required before asyn...">start_connect_ops()</a> successfully. See its doc header; but generally it is another instance of a <code><a class="el" href="namespaceipc_1_1transport_1_1sync__io.html" title="sync_io-pattern counterparts to async-I/O-pattern object types in parent namespace ipc::transport.">sync_io</a></code> pattern with which one must be familiar before using this class (and <code><a class="el" href="namespaceipc_1_1transport_1_1sync__io.html" title="sync_io-pattern counterparts to async-I/O-pattern object types in parent namespace ipc::transport.">sync_io</a>::</code> senders and receivers generally).</p>
<p >Similarly &ndash; as described by the concepts being implemented &ndash; one must use <code>start_send_*_ops()</code> before the send API (<code>send_*()</code>, <code>*end_sending()</code>, <a class="el" href="classipc_1_1transport_1_1sync__io_1_1Native__socket__stream.html#aaef9afdeb3800df615a01b22070acad8" title="Implements Native_handle_sender, Blob_sender API per contract.">auto_ping()</a>) and/or <code>start_receive_*_ops()</code> before the receive API (<code>async_receive_*()</code>, <a class="el" href="classipc_1_1transport_1_1sync__io_1_1Native__socket__stream.html#ac645b3e69ee3bfda64c0e9fda62f656a" title="Implements Native_handle_receiver, Blob_receiver API per contract.">idle_timer_run()</a>).</p>
<p >Before <code>start_*_ops()</code>, it may be required to call <a class="el" href="classipc_1_1transport_1_1sync__io_1_1Native__socket__stream.html#af5e6e5ccf19782cb698017e9dcf85b34" title="Implements Native_handle_sender and Native_handle_receiver APIs at the same time, per their concept c...">replace_event_wait_handles()</a> (depending on your use case).</p>
<p >Regarding ctors: Naturally the <a class="el" href="classipc_1_1transport_1_1Native__socket__stream.html" title="Implements both Native_handle_sender and Native_handle_receiver concepts by using a stream-oriented U...">transport::Native_socket_stream</a> <code><a class="el" href="namespaceipc_1_1transport_1_1sync__io.html" title="sync_io-pattern counterparts to async-I/O-pattern object types in parent namespace ipc::transport.">sync_io</a></code>-core-adopting ctor does not exist here, as we <em>are</em> a <code><a class="el" href="namespaceipc_1_1transport_1_1sync__io.html" title="sync_io-pattern counterparts to async-I/O-pattern object types in parent namespace ipc::transport.">sync_io</a></code> core. (Or I suppose it's just the move ctor.)</p>
<h2>Thread safety </h2>
<p >Boring stuff out of the way first: It is safe to concurrently act on 2 separate objects of this type. <a class="el" href="classipc_1_1transport_1_1sync__io_1_1Native__socket__stream.html#a80cb628f57f12c19f7ce46d0894c773a" title="Returns nickname, a brief string suitable for logging.">nickname()</a> and <code>ostream&lt;&lt;</code> are always safe to call, and they always yield the same value (modulo across move-assignment).</p>
<p >Now as to invoking operation X concurrently with operation Y on the same <code>*this</code>, where at least X is non-<code>const</code>:</p>
<p >Firstly let us define operation: Unlike with most APIs in the library, operations don't merely comprise methods (or related free functions). Rather, in addition, invoking <a class="el" href="namespaceipc_1_1util_1_1sync__io.html#aa0b9a3cc6bdc7dedbef4f9e06851aa24" title="In sync_io pattern, concrete type storing user-supplied function invoked by pattern-implementing ipc:...">util::sync_io::Event_wait_func</a> <code>(*on_active_ev_func)()</code> &ndash; to inform <code>*this</code> of an active event due to an earlier async-wait requested by <code>*this</code> &ndash; is formally an operation on <code>*this</code>. It can be thought of as a member of its (non-<code>const</code>) API. For the below discussion we shall pretend these methods actually exist, to simplify discussion of these operations:</p><ul>
<li><code>connect_on_active_ev()</code> (<code>on_active_ev_func</code> originating from <a class="el" href="classipc_1_1transport_1_1sync__io_1_1Native__socket__stream.html#a97fa6328b1d77a9ee212e09721fc398e" title="Sets up the sync_io-pattern interaction between *this and the user&#39;s event loop; required before asyn...">start_connect_ops()</a>).<ul>
<li>Recall this may synchronously trigger <a class="el" href="classipc_1_1transport_1_1sync__io_1_1Native__socket__stream.html#a3fed4817936af7f23d2beb8f75999d8d" title="See Async_io_obj counterpart for the essential semantics; however here according to sync_io pattern t...">async_connect()</a>-passed completion handler.</li>
</ul>
</li>
<li><code>send_on_active_ev()</code> (<code>on_active_ev_func</code> originating from <code>start_send_*_ops()</code>).<ul>
<li>Recall this may synchronously trigger <a class="el" href="classipc_1_1transport_1_1sync__io_1_1Native__socket__stream.html#afb680eb576497ac7e05e8294b49da0eb" title="Implements Native_handle_sender, Blob_sender API per contract.">async_end_sending()</a>-passed completion handler.</li>
</ul>
</li>
<li><code>receive_on_active_ev()</code> (<code>on_active_ev_func</code> originating from <code>start_receive_*_ops()</code>).<ul>
<li>Recall this may synchronously trigger <code>async_receive_*()</code>-passed completion handler.</li>
</ul>
</li>
</ul>
<p >Objects of most types simply declare it to be unsafe to invoke (on one <code>*this</code>) non-<code>const</code> operation X concurrently with operation Y (whether X or Y are the same op or differ). <code><a class="el" href="classipc_1_1transport_1_1sync__io_1_1Native__socket__stream.html" title="Implements both sync_io::Native_handle_sender and sync_io::Native_handle_receiver concepts by using a...">Native_socket_stream</a></code>, however, works as follows: By <em>default</em> that is indeed the rule... with the exception of the following specific exceptions, wherein it <em>is</em> <b>intentionally</b> safe.</p>
<h3>In PEER state</h3>
<p >Firstly, let's assume <code>*this</code> is in PEER state, which is achieved either by using the PEER-state ctor form (where a pre-connected <code>Native_handle</code> is subsumed), or else by successfully completing <a class="el" href="classipc_1_1transport_1_1sync__io_1_1Native__socket__stream.html#a3fed4817936af7f23d2beb8f75999d8d" title="See Async_io_obj counterpart for the essential semantics; however here according to sync_io pattern t...">async_connect()</a> &ndash; that is, once it has invoked <code>on_done_func()</code> (the completion handler specified by user). Cool? Cool. We are in PEER state. Then:</p>
<p >Boring ones first: <a class="el" href="classipc_1_1transport_1_1sync__io_1_1Native__socket__stream.html#a3fed4817936af7f23d2beb8f75999d8d" title="See Async_io_obj counterpart for the essential semantics; however here according to sync_io pattern t...">async_connect()</a> simply returns <code>false</code> and is always safe to call (it is meant for NULL state). <code>*_max_size()</code> always return the same respective constant values and are always safe to call.</p>
<p >Much more significantly, we now list two specific categories of operations:</p><ul>
<li>Send-ops:<ul>
<li><code>send_*()</code>, <a class="el" href="classipc_1_1transport_1_1sync__io_1_1Native__socket__stream.html#a69ed821cc3a41b68dd56880d45033a45" title="Implements Native_handle_sender, Blob_sender API per contract.">end_sending()</a>, <a class="el" href="classipc_1_1transport_1_1sync__io_1_1Native__socket__stream.html#afb680eb576497ac7e05e8294b49da0eb" title="Implements Native_handle_sender, Blob_sender API per contract.">async_end_sending()</a>, <a class="el" href="classipc_1_1transport_1_1sync__io_1_1Native__socket__stream.html#aaef9afdeb3800df615a01b22070acad8" title="Implements Native_handle_sender, Blob_sender API per contract.">auto_ping()</a>; and <code>send_on_active_ev()</code> (reminder: not a real method but a real op/see definition above).</li>
</ul>
</li>
<li>Receive-ops:<ul>
<li><code>async_receive_*()</code>, <code><a class="el" href="classipc_1_1transport_1_1sync__io_1_1Native__socket__stream.html#ac645b3e69ee3bfda64c0e9fda62f656a" title="Implements Native_handle_receiver, Blob_receiver API per contract.">idle_timer_run()</a></code>; and <code>receive_on_active_ev()</code> (reminder: not a real method but a real op/see definition above).</li>
</ul>
</li>
</ul>
<p >Now then: It is safe to invoke (even on the same <code>*this</code>) any 1 operation from the "send-ops" list concurrently with any 1 operation from the "receive-ops" list.</p>
<p >Formally that's simply the case.</p>
<p >Informally: it may be highly significant to performance of the user code that this is the case. It means that the two mutually-opposing pipes can operate concurrently, despite the fact they're operating on the same socket. E.g., an upload and download being highly active simultaneously will proceed in parallel on separate processor cores if possible. If your event loop is single-threaded in any case, then this does not matter; but if 2+ threads are involved, then it may well matter quite a bit. (For example: non-<code><a class="el" href="namespaceipc_1_1transport_1_1sync__io.html" title="sync_io-pattern counterparts to async-I/O-pattern object types in parent namespace ipc::transport.">sync_io</a></code> <a class="el" href="classipc_1_1transport_1_1Native__socket__stream.html" title="Implements both Native_handle_sender and Native_handle_receiver concepts by using a stream-oriented U...">transport::Native_socket_stream</a> is internally built on a <a class="el" href="classipc_1_1transport_1_1sync__io_1_1Native__socket__stream.html" title="Implements both sync_io::Native_handle_sender and sync_io::Native_handle_receiver concepts by using a...">sync_io::Native_socket_stream</a>. It starts a thread (internally dubbed thread W) in which to perform significant incoming-direction work, while most &ndash; but not all &ndash; outgoing-direction work is done synchronously from its user's calling thread (dubbed thread U). Therefore it can keep 2 separate mutexes (one for each direction) and lock only 1 when doing in-work (in either thread U/W); and lock the other when doing out-work, in either thread U/W. So if a send can complete synchronously in thread U, while a receive does stuff in the background in thread W, the two may execute concurrently as opposed to serially. Running concurrently would decrease latency latency in sending and/or receipt.)</p>
<h3>In NULL state</h3>
<p >Now let's assume <code>*this</code> is in NULL state; meaning it has been cted using the NULL-state ctor; and either <a class="el" href="classipc_1_1transport_1_1sync__io_1_1Native__socket__stream.html#a3fed4817936af7f23d2beb8f75999d8d" title="See Async_io_obj counterpart for the essential semantics; however here according to sync_io pattern t...">async_connect()</a> has not been invoked at all, or it has but has indicated (via completion handler as explained earlier) failure to connect. Then:</p>
<p >Boring ones first: All the send-ops and receive-ops listed above (with the exception of <code>*_on_active_ev()</code>, which cannot be called at all until PEER state &ndash; you'll have no such function to call) simply return <code>false</code> and are always safe to call (they are meant for PEER state). <code>*_max_size()</code> similarly will all return zero and are always safe to call.</p>
<p >That leaves only <a class="el" href="classipc_1_1transport_1_1sync__io_1_1Native__socket__stream.html#a3fed4817936af7f23d2beb8f75999d8d" title="See Async_io_obj counterpart for the essential semantics; however here according to sync_io pattern t...">async_connect()</a> and <code>connect_on_active_ev()</code> (again, not a real method/see definition above). Formally we don't need to say this, but to be clear: the two may not be called concurrently to each other or themselves. However, to restate: The "boring" ones in the previous paragraph can be called safely, period (they'll just be useless, as they only make sense in PEER state).</p>
<h3>What about CONNECTING state?</h3>
<p >CONNECTING state refers to the no-man's-land between NULL and PEER: You've called <code>async_connect(F)</code>, <code>F()</code> being the completion handler, and <code>F(err_code_or_success)</code> has not yet been invoked to indicate the result.</p>
<p >Formally we need not say anything additional to the text above that outlines the thread-safety rules. For convenience/clarity though: It is not safe to invoke operations (other than <a class="el" href="classipc_1_1transport_1_1sync__io_1_1Native__socket__stream.html#a80cb628f57f12c19f7ce46d0894c773a" title="Returns nickname, a brief string suitable for logging.">nickname()</a> and <code>ostream</code> output) concurrently during CONNECTING state, if one of them is non-<code>const</code>. Moreover, since the only way to know for sure you're not in CONNECTING state at a given moment is to never have called <a class="el" href="classipc_1_1transport_1_1sync__io_1_1Native__socket__stream.html#a3fed4817936af7f23d2beb8f75999d8d" title="See Async_io_obj counterpart for the essential semantics; however here according to sync_io pattern t...">async_connect()</a>, or for it to have triggered the completion handler: Do not do potentially concurrent stuff while an <a class="el" href="classipc_1_1transport_1_1sync__io_1_1Native__socket__stream.html#a3fed4817936af7f23d2beb8f75999d8d" title="See Async_io_obj counterpart for the essential semantics; however here according to sync_io pattern t...">async_connect()</a> is outstanding. It is not safe.</p>
<p >This rule should be easy to follow &ndash; e.g., who would want to try a <a class="el" href="classipc_1_1transport_1_1sync__io_1_1Native__socket__stream.html#a2e1474a87ee8f5ec18bf6cc8d6cfe7b2" title="Implements Blob_sender API per contract.">send_blob()</a> until they're for-sure connected (a/k/a in PEER state)? There is however one trip-up point which may not be quite obvious: the otherwise-innocuous <code>*_max_size()</code> accessors. Don't call them during an oustanding <a class="el" href="classipc_1_1transport_1_1sync__io_1_1Native__socket__stream.html#a3fed4817936af7f23d2beb8f75999d8d" title="See Async_io_obj counterpart for the essential semantics; however here according to sync_io pattern t...">async_connect()</a> (by which, again, we mean one whose completion handler has not yet been invoked); or, if you possibly do, then ensure non-concurrency against <a class="el" href="classipc_1_1transport_1_1sync__io_1_1Native__socket__stream.html#a3fed4817936af7f23d2beb8f75999d8d" title="See Async_io_obj counterpart for the essential semantics; however here according to sync_io pattern t...">async_connect()</a> and <code>connect_on_active_ev()</code>, when state would switch between NULL=&gt;CONNECTING=&gt;NULL/PEER. They'll return 0 in NULL and CONNECTING states versus non-zero real values in PEER state; but during a transition behavior is undefined. While it is possible to use a mutex to guard against this, it may not be worth the trouble.</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classipc_1_1transport_1_1sync__io_1_1Native__handle__sender.html" title="A documentation-only concept defining the behavior of an object that is the sync_io-pattern counterpa...">sync_io::Native_handle_sender</a>: implemented concept. </dd>
<dd>
<a class="el" href="classipc_1_1transport_1_1sync__io_1_1Native__handle__receiver.html" title="A documentation-only concept defining the behavior of an object that is the sync_io-pattern counterpa...">sync_io::Native_handle_receiver</a>: implemented concept. </dd>
<dd>
<a class="el" href="classipc_1_1transport_1_1sync__io_1_1Blob__sender.html" title="A documentation-only concept: what transport::Blob_sender is to transport::Native_handle_sender (name...">sync_io::Blob_sender</a>: alternatively implemented concept. </dd>
<dd>
<a class="el" href="classipc_1_1transport_1_1sync__io_1_1Blob__receiver.html" title="A documentation-only concept: what transport::Blob_receiver is to transport::Native_handle_receiver (...">sync_io::Blob_receiver</a>: alternatively implemented concept. </dd></dl>
</div><h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="a3176682a76814cc3f0fe5b79f7665aec" name="a3176682a76814cc3f0fe5b79f7665aec"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3176682a76814cc3f0fe5b79f7665aec">&#9670;&nbsp;</a></span>Native_socket_stream() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ipc::transport::sync_io::Native_socket_stream::Native_socket_stream </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Default ctor (object is in NULL state). </p>
<p >Notes for <a class="el" href="classipc_1_1transport_1_1Native__socket__stream.html" title="Implements both Native_handle_sender and Native_handle_receiver concepts by using a stream-oriented U...">transport::Native_socket_stream</a> apply.</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classipc_1_1transport_1_1sync__io_1_1Native__handle__sender.html#a935bfba8ac18f395eb920224395cbc8f" title="Default ctor: Creates a peer object in NULL (neither connected nor connecting) state.">Native_handle_sender::Native_handle_sender()</a>: implemented concept. </dd>
<dd>
<a class="el" href="classipc_1_1transport_1_1sync__io_1_1Native__handle__receiver.html#a4d1ef7666fc35e98ced97abdc131a345" title="Default ctor: Creates a peer object in NULL (neither connected nor connecting) state.">Native_handle_receiver::Native_handle_receiver()</a>: implemented concept. </dd>
<dd>
<a class="el" href="classipc_1_1transport_1_1sync__io_1_1Blob__sender.html#ab096af43b37c0fc0169762f59e1a74dd" title="Default ctor: Creates a peer object in NULL (neither connected nor connecting) state.">Blob_sender::Blob_sender()</a>: implemented concept. </dd>
<dd>
<a class="el" href="classipc_1_1transport_1_1sync__io_1_1Blob__receiver.html#a73f2f615f48566e32f7a974e9448f4fc" title="Default ctor: Creates a peer object in NULL (neither connected nor connecting) state.">Blob_receiver::Blob_receiver()</a>: implemented concept. </dd></dl>

</div>
</div>
<a id="afcfa1e87af688fea34809949ecbcdad0" name="afcfa1e87af688fea34809949ecbcdad0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afcfa1e87af688fea34809949ecbcdad0">&#9670;&nbsp;</a></span>Native_socket_stream() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">ipc::transport::sync_io::Native_socket_stream::Native_socket_stream </td>
          <td>(</td>
          <td class="paramtype">flow::log::Logger *&#160;</td>
          <td class="paramname"><em>logger_ptr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceipc_1_1util.html#ae6ac47812a90d1287c61e0b7de7bc4f5">util::String_view</a>&#160;</td>
          <td class="paramname"><em>nickname_str</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">explicit</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Creates a <a class="el" href="classipc_1_1transport_1_1sync__io_1_1Native__socket__stream.html" title="Implements both sync_io::Native_handle_sender and sync_io::Native_handle_receiver concepts by using a...">Native_socket_stream</a> in NULL (not connected, not connecting) state. </p>
<p >Notes for <a class="el" href="classipc_1_1transport_1_1Native__socket__stream.html" title="Implements both Native_handle_sender and Native_handle_receiver concepts by using a stream-oriented U...">transport::Native_socket_stream</a> apply.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">logger_ptr</td><td>See above. </td></tr>
    <tr><td class="paramname">nickname_str</td><td>See above. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ae8294867c6153e62ba9e8b683d3d8594" name="ae8294867c6153e62ba9e8b683d3d8594"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae8294867c6153e62ba9e8b683d3d8594">&#9670;&nbsp;</a></span>Native_socket_stream() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">ipc::transport::sync_io::Native_socket_stream::Native_socket_stream </td>
          <td>(</td>
          <td class="paramtype">flow::log::Logger *&#160;</td>
          <td class="paramname"><em>logger_ptr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceipc_1_1util.html#ae6ac47812a90d1287c61e0b7de7bc4f5">util::String_view</a>&#160;</td>
          <td class="paramname"><em>nickname_str</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceipc_1_1transport.html#a7ee4551983d9df16ec16a3139bac50e8">Native_handle</a> &amp;&amp;&#160;</td>
          <td class="paramname"><em>native_peer_socket_moved</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">explicit</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Constructs the socket-and-meta-blob stream by taking over an already-connected native Unix domain socket handle. </p>
<p >Notes for <a class="el" href="classipc_1_1transport_1_1Native__socket__stream.html" title="Implements both Native_handle_sender and Native_handle_receiver concepts by using a stream-oriented U...">transport::Native_socket_stream</a> apply.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">logger_ptr</td><td>See above. </td></tr>
    <tr><td class="paramname">native_peer_socket_moved</td><td>See above. </td></tr>
    <tr><td class="paramname">nickname_str</td><td>See above. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a11a1c1609f5e2be428fb26af868ca9ec" name="a11a1c1609f5e2be428fb26af868ca9ec"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a11a1c1609f5e2be428fb26af868ca9ec">&#9670;&nbsp;</a></span>Native_socket_stream() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">ipc::transport::sync_io::Native_socket_stream::Native_socket_stream </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classipc_1_1transport_1_1sync__io_1_1Native__socket__stream.html">Native_socket_stream</a> &amp;&amp;&#160;</td>
          <td class="paramname"><em>src</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">default</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Move-constructs from <code>src</code>; <code>src</code> becomes as-if default-cted (therefore in NULL state). </p>
<p >Notes for <a class="el" href="classipc_1_1transport_1_1Native__socket__stream.html" title="Implements both Native_handle_sender and Native_handle_receiver concepts by using a stream-oriented U...">transport::Native_socket_stream</a> apply.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">src</td><td>See above.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classipc_1_1transport_1_1sync__io_1_1Native__handle__sender.html#a935bfba8ac18f395eb920224395cbc8f" title="Default ctor: Creates a peer object in NULL (neither connected nor connecting) state.">Native_handle_sender::Native_handle_sender()</a>: implemented concept. </dd>
<dd>
<a class="el" href="classipc_1_1transport_1_1sync__io_1_1Native__handle__receiver.html#a4d1ef7666fc35e98ced97abdc131a345" title="Default ctor: Creates a peer object in NULL (neither connected nor connecting) state.">Native_handle_receiver::Native_handle_receiver()</a>: implemented concept. </dd>
<dd>
<a class="el" href="classipc_1_1transport_1_1sync__io_1_1Blob__sender.html#ab096af43b37c0fc0169762f59e1a74dd" title="Default ctor: Creates a peer object in NULL (neither connected nor connecting) state.">Blob_sender::Blob_sender()</a>: implemented concept. </dd>
<dd>
<a class="el" href="classipc_1_1transport_1_1sync__io_1_1Blob__receiver.html#a73f2f615f48566e32f7a974e9448f4fc" title="Default ctor: Creates a peer object in NULL (neither connected nor connecting) state.">Blob_receiver::Blob_receiver()</a>: implemented concept. </dd></dl>

</div>
</div>
<a id="adaea5a18b4e62fa7496ada4a2509b3fe" name="adaea5a18b4e62fa7496ada4a2509b3fe"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adaea5a18b4e62fa7496ada4a2509b3fe">&#9670;&nbsp;</a></span>~Native_socket_stream()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">ipc::transport::sync_io::Native_socket_stream::~Native_socket_stream </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">default</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Implements <a class="el" href="classipc_1_1transport_1_1sync__io_1_1Native__handle__sender.html" title="A documentation-only concept defining the behavior of an object that is the sync_io-pattern counterpa...">Native_handle_sender</a> <em>and</em> <a class="el" href="classipc_1_1transport_1_1sync__io_1_1Native__handle__receiver.html" title="A documentation-only concept defining the behavior of an object that is the sync_io-pattern counterpa...">Native_handle_receiver</a> APIs at the same time, per their concept contracts. </p>
<p >(Also implements <a class="el" href="classipc_1_1transport_1_1sync__io_1_1Blob__sender.html" title="A documentation-only concept: what transport::Blob_sender is to transport::Native_handle_sender (name...">Blob_sender</a> <em>and</em> <a class="el" href="classipc_1_1transport_1_1sync__io_1_1Blob__receiver.html" title="A documentation-only concept: what transport::Blob_receiver is to transport::Native_handle_receiver (...">Blob_receiver</a> APIs; they are identical.)</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classipc_1_1transport_1_1sync__io_1_1Native__handle__sender.html#a59dff09b6ab224e32a096c97b629d059" title="Destroys this peer endpoint which will end the conceptual outgoing-direction pipe (in PEER state,...">Native_handle_sender::~Native_handle_sender()</a>: implemented concept. </dd>
<dd>
<a class="el" href="classipc_1_1transport_1_1sync__io_1_1Native__handle__receiver.html#a9b464ca1d564e19340221e9958a5aa45" title="Destroys this peer endpoint which will end the conceptual outgoing-direction pipe (in PEER state,...">Native_handle_receiver::~Native_handle_receiver()</a>: implemented concept. </dd>
<dd>
<a class="el" href="classipc_1_1transport_1_1sync__io_1_1Blob__sender.html#a5b6fd92f1c435e13dcf6df40c76b3ce2" title="Destroys this peer endpoint which will end the conceptual outgoing-direction pipe (in PEER state,...">Blob_sender::~Blob_sender()</a>: alternatively implemented concept. </dd>
<dd>
<a class="el" href="classipc_1_1transport_1_1sync__io_1_1Blob__receiver.html#a53d0a7f08ce20ea8515b57d78c598858" title="Destroys this peer endpoint which will end the conceptual outgoing-direction pipe (in PEER state,...">Blob_receiver::~Blob_receiver()</a>: alternatively implemented concept. </dd></dl>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="a3fed4817936af7f23d2beb8f75999d8d" name="a3fed4817936af7f23d2beb8f75999d8d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3fed4817936af7f23d2beb8f75999d8d">&#9670;&nbsp;</a></span>async_connect()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Task_err &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool ipc::transport::sync_io::Native_socket_stream::async_connect </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespaceipc_1_1transport.html#a33de1c256addb3964b839dc2dd407d24">Shared_name</a> &amp;&#160;</td>
          <td class="paramname"><em>absolute_name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceipc.html#aa3192e586cc45d3e7c22463bf2760f89">Error_code</a> *&#160;</td>
          <td class="paramname"><em>sync_err_code</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Task_err &amp;&amp;&#160;</td>
          <td class="paramname"><em>on_done_func</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>See <a class="el" href="classipc_1_1transport_1_1sync__io_1_1Native__socket__stream.html#a24d39cb096987f483f233d9d4ab51ecf" title="Useful for generic programming, the async-I/O-pattern counterpart to *this type.">Async_io_obj</a> counterpart for the essential semantics; however here according to <code><a class="el" href="namespaceipc_1_1transport_1_1sync__io.html" title="sync_io-pattern counterparts to async-I/O-pattern object types in parent namespace ipc::transport.">sync_io</a></code> pattern the operation may complete synchronously thus emitting result immediately and ignoring <code>on_done_func</code>. </p>
<p >Per <code><a class="el" href="namespaceipc_1_1transport_1_1sync__io.html" title="sync_io-pattern counterparts to async-I/O-pattern object types in parent namespace ipc::transport.">sync_io</a></code> pattern: if internally more work is required asynchronously pending 1+ native handles being in 1+ active-event (readable, writable) state, this method shall later invoke the <code>Event_wait_func</code> registered via <a class="el" href="classipc_1_1transport_1_1sync__io_1_1Native__socket__stream.html#a97fa6328b1d77a9ee212e09721fc398e" title="Sets up the sync_io-pattern interaction between *this and the user&#39;s event loop; required before asyn...">start_connect_ops()</a> by the user of <code>*this</code>; and the error code <a class="el" href="namespaceipc_1_1transport_1_1error.html#adfef15ef4e76cc55d652fbd9c2797297aa667487757f9d6300f6888bac40bcc24" title="A sync_io operation could not immediately complete; it will complete contingent on active async-wait ...">error::Code::S_SYNC_IO_WOULD_BLOCK</a> shall be emitted here synchronously (via <code>*sync_err_code</code> if not null, exception if null &ndash; per standard <code>flow::Error_code</code>-doc-header semantics). Meanwhile the completion handler <code>on_done_func()</code> shall execute once the required async-waits have been satisfied by the <code>*this</code> user, synchronously from inside the <code>(*on_active_ev_func)()</code> call that achieves this state.</p>
<p >If, by contrast, no more work is required &ndash; the operation completed synchronously within this method &ndash; then: success or error <em>other than</em> error::code::S_SYNC_IO_WOULD_BLOB shall be emitted (again per standard semantics) synchronously; and <code>on_done_func()</code> shall not be saved nor ever executed by <code>*this</code>. Thus the result of the operation shall be either output directly synchronously &ndash; if op completed synchronously &ndash; or later via <code>on_done_func()</code> completion handler.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">absolute_name</td><td>See above. </td></tr>
    <tr><td class="paramname">sync_err_code</td><td>See above. </td></tr>
    <tr><td class="paramname">on_done_func</td><td>See above. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>See above. </dd></dl>

</div>
</div>
<a id="afb680eb576497ac7e05e8294b49da0eb" name="afb680eb576497ac7e05e8294b49da0eb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afb680eb576497ac7e05e8294b49da0eb">&#9670;&nbsp;</a></span>async_end_sending()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Task_err &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool ipc::transport::sync_io::Native_socket_stream::async_end_sending </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespaceipc.html#aa3192e586cc45d3e7c22463bf2760f89">Error_code</a> *&#160;</td>
          <td class="paramname"><em>sync_err_code</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Task_err &amp;&amp;&#160;</td>
          <td class="paramname"><em>on_done_func</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Implements <a class="el" href="classipc_1_1transport_1_1sync__io_1_1Native__handle__sender.html" title="A documentation-only concept defining the behavior of an object that is the sync_io-pattern counterpa...">Native_handle_sender</a>, <a class="el" href="classipc_1_1transport_1_1sync__io_1_1Blob__sender.html" title="A documentation-only concept: what transport::Blob_sender is to transport::Native_handle_sender (name...">Blob_sender</a> API per contract. </p>
<p >Reminder: Please peruse "Thread safety" in class doc header.</p>
<p ><a class="el" href="namespaceipc.html#aa3192e586cc45d3e7c22463bf2760f89" title="Short-hand for boost.interprocess namespace.">Error_code</a> generated and passed to <code>on_done_func()</code> or emitted synchronously: See <a class="el" href="classipc_1_1transport_1_1sync__io_1_1Native__socket__stream.html#a24d39cb096987f483f233d9d4ab51ecf" title="Useful for generic programming, the async-I/O-pattern counterpart to *this type.">Async_io_obj</a> counterpart doc header.</p>
<p >Reminder: In rare circumstances, an error emitted there may represent something detected during handling of a preceding <a class="el" href="classipc_1_1transport_1_1sync__io_1_1Native__socket__stream.html#a9805f7625a1272af64295555f9a1a61b" title="Implements Native_handle_sender API per contract.">send_native_handle()</a> or <a class="el" href="classipc_1_1transport_1_1sync__io_1_1Native__socket__stream.html#a2e1474a87ee8f5ec18bf6cc8d6cfe7b2" title="Implements Blob_sender API per contract.">send_blob()</a> call but after it returned.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Task_err</td><td>See above. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">sync_err_code</td><td>See above. Do realize <a class="el" href="namespaceipc_1_1transport_1_1error.html#adfef15ef4e76cc55d652fbd9c2797297aa667487757f9d6300f6888bac40bcc24" title="A sync_io operation could not immediately complete; it will complete contingent on active async-wait ...">error::Code::S_SYNC_IO_WOULD_BLOCK</a> <em>is</em> still an error, so if this pointer is null, then would-block <em>will</em> make this throw. </td></tr>
    <tr><td class="paramname">on_done_func</td><td>See above. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>See above. Reminder: If and only if it returns <code>false</code>, we're in NULL state, or <code>*end_sending()</code> has already been called; and <code>on_done_func()</code> will never be called, nor will an error be emitted.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classipc_1_1transport_1_1sync__io_1_1Native__handle__sender.html#a9b99e18949cf819bfae4e08e44744fc6" title="Equivalent to send_native_handle() but sends a graceful-close message instead of the usual payload; t...">Native_handle_sender::async_end_sending()</a>: implemented concept. </dd>
<dd>
<a class="el" href="classipc_1_1transport_1_1sync__io_1_1Blob__sender.html#a923cff103f564573c90999e545e1f644" title="Equivalent to send_blob() but sends a graceful-close message instead of the usual payload.">Blob_sender::async_end_sending()</a>: alternatively implemented concept. </dd></dl>

</div>
</div>
<a id="a8b5fc40ddcdda4b7c78672e9b9dc53c2" name="a8b5fc40ddcdda4b7c78672e9b9dc53c2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8b5fc40ddcdda4b7c78672e9b9dc53c2">&#9670;&nbsp;</a></span>async_receive_blob()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Task_err_sz &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool ipc::transport::sync_io::Native_socket_stream::async_receive_blob </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespaceipc_1_1util.html#a6cb62ae434900f3a8915b33ec5d61a96">util::Blob_mutable</a> &amp;&#160;</td>
          <td class="paramname"><em>target_blob</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceipc.html#aa3192e586cc45d3e7c22463bf2760f89">Error_code</a> *&#160;</td>
          <td class="paramname"><em>sync_err_code</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t *&#160;</td>
          <td class="paramname"><em>sync_sz</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Task_err_sz &amp;&amp;&#160;</td>
          <td class="paramname"><em>on_done_func</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Implements <a class="el" href="classipc_1_1transport_1_1sync__io_1_1Blob__receiver.html" title="A documentation-only concept: what transport::Blob_receiver is to transport::Native_handle_receiver (...">Blob_receiver</a> API per contract. </p>
<p >Reminder: Please peruse "Thread safety" in class doc header.</p>
<p ><a class="el" href="namespaceipc.html#aa3192e586cc45d3e7c22463bf2760f89" title="Short-hand for boost.interprocess namespace.">Error_code</a> generated and passed to <code>on_done_func()</code> or emitted synchronously: See <code><a class="el" href="classipc_1_1transport_1_1Native__socket__stream.html#ac5572c8165e25f106f18d327c07d1c3f" title="Implements Blob_receiver API per contract.">Async_io_obj::async_receive_blob()</a></code> doc header (but not <code>S_OBJECT_SHUTDOWN_ABORTED_COMPLETION_HANDLER</code>).</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Task_err_sz</td><td>See above. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">target_blob</td><td>See above. </td></tr>
    <tr><td class="paramname">sync_err_code</td><td>See above. Do realize <a class="el" href="namespaceipc_1_1transport_1_1error.html#adfef15ef4e76cc55d652fbd9c2797297aa667487757f9d6300f6888bac40bcc24" title="A sync_io operation could not immediately complete; it will complete contingent on active async-wait ...">error::Code::S_SYNC_IO_WOULD_BLOCK</a> <em>is</em> still an error, so if this pointer is null, then would-block <em>will</em> make this throw. </td></tr>
    <tr><td class="paramname">sync_sz</td><td>See above. </td></tr>
    <tr><td class="paramname">on_done_func</td><td>See above. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>See above.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classipc_1_1transport_1_1sync__io_1_1Blob__receiver.html#af05f5ec0a8fd01b2056c09613a4dfc1e" title="In PEER state: Possibly-asynchronously awaits one discrete message – as sent by the opposing peer – a...">Blob_receiver::async_receive_blob()</a>: implemented concept. </dd></dl>

</div>
</div>
<a id="a04effad6ce75fc5c8e6cbee5a26b73e8" name="a04effad6ce75fc5c8e6cbee5a26b73e8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a04effad6ce75fc5c8e6cbee5a26b73e8">&#9670;&nbsp;</a></span>async_receive_native_handle()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Task_err_sz &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool ipc::transport::sync_io::Native_socket_stream::async_receive_native_handle </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespaceipc_1_1transport.html#a7ee4551983d9df16ec16a3139bac50e8">Native_handle</a> *&#160;</td>
          <td class="paramname"><em>target_hndl</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespaceipc_1_1util.html#a6cb62ae434900f3a8915b33ec5d61a96">util::Blob_mutable</a> &amp;&#160;</td>
          <td class="paramname"><em>target_meta_blob</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceipc.html#aa3192e586cc45d3e7c22463bf2760f89">Error_code</a> *&#160;</td>
          <td class="paramname"><em>sync_err_code</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t *&#160;</td>
          <td class="paramname"><em>sync_sz</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Task_err_sz &amp;&amp;&#160;</td>
          <td class="paramname"><em>on_done_func</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Implements <a class="el" href="classipc_1_1transport_1_1sync__io_1_1Native__handle__receiver.html" title="A documentation-only concept defining the behavior of an object that is the sync_io-pattern counterpa...">Native_handle_receiver</a> API per contract. </p>
<p >Reminder: Please peruse "Thread safety" in class doc header.</p>
<p ><a class="el" href="namespaceipc.html#aa3192e586cc45d3e7c22463bf2760f89" title="Short-hand for boost.interprocess namespace.">Error_code</a> generated and passed to <code>on_done_func()</code> or emitted synchronously: See <code><a class="el" href="classipc_1_1transport_1_1Native__socket__stream.html#a266b52821557f2a4fa8f81058290dee2" title="Implements Native_handle_receiver API per contract.">Async_io_obj::async_receive_native_handle()</a></code> doc header (but not <code>S_OBJECT_SHUTDOWN_ABORTED_COMPLETION_HANDLER</code>).</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Task_err_sz</td><td>See above. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">target_hndl</td><td>See above. </td></tr>
    <tr><td class="paramname">target_meta_blob</td><td>See above. </td></tr>
    <tr><td class="paramname">sync_err_code</td><td>See above. Do realize <a class="el" href="namespaceipc_1_1transport_1_1error.html#adfef15ef4e76cc55d652fbd9c2797297aa667487757f9d6300f6888bac40bcc24" title="A sync_io operation could not immediately complete; it will complete contingent on active async-wait ...">error::Code::S_SYNC_IO_WOULD_BLOCK</a> <em>is</em> still an error, so if this pointer is null, then would-block <em>will</em> make this throw. </td></tr>
    <tr><td class="paramname">sync_sz</td><td>See above. </td></tr>
    <tr><td class="paramname">on_done_func</td><td>See above. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>See above.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classipc_1_1transport_1_1sync__io_1_1Native__handle__receiver.html#a6350bfb7f929a5b60fa4af1b6f7166cf" title="In PEER state: Possibly-asynchronously awaits one discrete message – as sent by the opposing peer via...">Native_handle_receiver::async_receive_native_handle()</a>: implemented concept. </dd></dl>

</div>
</div>
<a id="aaef9afdeb3800df615a01b22070acad8" name="aaef9afdeb3800df615a01b22070acad8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaef9afdeb3800df615a01b22070acad8">&#9670;&nbsp;</a></span>auto_ping()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool ipc::transport::sync_io::Native_socket_stream::auto_ping </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespaceipc_1_1util.html#ac66141280c3b7295a86b65209f31cc58">util::Fine_duration</a>&#160;</td>
          <td class="paramname"><em>period</em> = <code>boost::chrono::seconds(2)</code></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Implements <a class="el" href="classipc_1_1transport_1_1sync__io_1_1Native__handle__sender.html" title="A documentation-only concept defining the behavior of an object that is the sync_io-pattern counterpa...">Native_handle_sender</a>, <a class="el" href="classipc_1_1transport_1_1sync__io_1_1Blob__sender.html" title="A documentation-only concept: what transport::Blob_sender is to transport::Native_handle_sender (name...">Blob_sender</a> API per contract. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">period</td><td>See above. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>See above.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classipc_1_1transport_1_1sync__io_1_1Native__handle__sender.html#a5b90444b333091c3e44d01b8cb07a499" title="In PEER state: Irreversibly enables periodic auto-pinging of opposing receiver with low-level message...">Native_handle_sender::auto_ping()</a>: implemented concept. </dd>
<dd>
<a class="el" href="classipc_1_1transport_1_1sync__io_1_1Blob__sender.html#ab66231120f7e774e9d8dadd6b1d9b2ea" title="In PEER state: Irreversibly enables periodic auto-pinging of opposing receiver with low-level message...">Blob_sender::auto_ping()</a>: alternatively implemented concept. </dd></dl>

</div>
</div>
<a id="a69ed821cc3a41b68dd56880d45033a45" name="a69ed821cc3a41b68dd56880d45033a45"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a69ed821cc3a41b68dd56880d45033a45">&#9670;&nbsp;</a></span>end_sending()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool ipc::transport::sync_io::Native_socket_stream::end_sending </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Implements <a class="el" href="classipc_1_1transport_1_1sync__io_1_1Native__handle__sender.html" title="A documentation-only concept defining the behavior of an object that is the sync_io-pattern counterpa...">Native_handle_sender</a>, <a class="el" href="classipc_1_1transport_1_1sync__io_1_1Blob__sender.html" title="A documentation-only concept: what transport::Blob_sender is to transport::Native_handle_sender (name...">Blob_sender</a> API per contract. </p>
<dl class="section return"><dt>Returns</dt><dd>See above.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classipc_1_1transport_1_1sync__io_1_1Native__handle__sender.html#a8c60142c23bf70bc3722d557ad309d58" title="Equivalent to async_end_sending(&amp;E, F) wherein F() does nothing, and E is some Error_code &quot;sink&quot; igno...">Native_handle_sender::end_sending()</a>: implemented concept. </dd>
<dd>
<a class="el" href="classipc_1_1transport_1_1sync__io_1_1Blob__sender.html#a4fd1a24f1221886230ffc18313eaedce" title="Equivalent to async_end_sending(F) wherein F() does nothing.">Blob_sender::end_sending()</a>: alternatively implemented concept. </dd></dl>

</div>
</div>
<a id="aac68d14f4ef33505399df4fd04cd4669" name="aac68d14f4ef33505399df4fd04cd4669"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aac68d14f4ef33505399df4fd04cd4669">&#9670;&nbsp;</a></span>get_logger()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">flow::log::Logger * ipc::transport::sync_io::Native_socket_stream::get_logger </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns logger (possibly null). </p>
<dl class="section return"><dt>Returns</dt><dd>See above. </dd></dl>

</div>
</div>
<a id="ac645b3e69ee3bfda64c0e9fda62f656a" name="ac645b3e69ee3bfda64c0e9fda62f656a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac645b3e69ee3bfda64c0e9fda62f656a">&#9670;&nbsp;</a></span>idle_timer_run()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool ipc::transport::sync_io::Native_socket_stream::idle_timer_run </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespaceipc_1_1util.html#ac66141280c3b7295a86b65209f31cc58">util::Fine_duration</a>&#160;</td>
          <td class="paramname"><em>timeout</em> = <code>boost::chrono::seconds(5)</code></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Implements <a class="el" href="classipc_1_1transport_1_1sync__io_1_1Native__handle__receiver.html" title="A documentation-only concept defining the behavior of an object that is the sync_io-pattern counterpa...">Native_handle_receiver</a>, <a class="el" href="classipc_1_1transport_1_1sync__io_1_1Blob__receiver.html" title="A documentation-only concept: what transport::Blob_receiver is to transport::Native_handle_receiver (...">Blob_receiver</a> API per contract. </p>
<p >Reminder: Please peruse "Thread safety" in class doc header.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">timeout</td><td>See above. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>See above.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classipc_1_1transport_1_1sync__io_1_1Blob__receiver.html#a6888f84e88c00d28daa579a9b47a2d77" title="In PEER state: Irreversibly enables a conceptual idle timer whose potential side effect is,...">Blob_receiver::idle_timer_run()</a>: implemented concept. </dd>
<dd>
<a class="el" href="classipc_1_1transport_1_1sync__io_1_1Native__handle__receiver.html#a57ec0f2a9c1b8bfbaaf88975433a1354" title="In PEER state: Irreversibly enables a conceptual idle timer whose potential side effect is,...">Native_handle_receiver::idle_timer_run()</a>: alternatively implemented concept. </dd></dl>

</div>
</div>
<a id="a80cb628f57f12c19f7ce46d0894c773a" name="a80cb628f57f12c19f7ce46d0894c773a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a80cb628f57f12c19f7ce46d0894c773a">&#9670;&nbsp;</a></span>nickname()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const std::string &amp; ipc::transport::sync_io::Native_socket_stream::nickname </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns nickname, a brief string suitable for logging. </p>
<p >Notes for <a class="el" href="classipc_1_1transport_1_1Native__socket__stream.html" title="Implements both Native_handle_sender and Native_handle_receiver concepts by using a stream-oriented U...">transport::Native_socket_stream</a> apply.</p>
<dl class="section return"><dt>Returns</dt><dd>See above. </dd></dl>

</div>
</div>
<a id="a918cc2c153d278b19a81ca2b1e93e6bd" name="a918cc2c153d278b19a81ca2b1e93e6bd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a918cc2c153d278b19a81ca2b1e93e6bd">&#9670;&nbsp;</a></span>operator=()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classipc_1_1transport_1_1sync__io_1_1Native__socket__stream.html">Native_socket_stream</a> &amp; ipc::transport::sync_io::Native_socket_stream::operator= </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classipc_1_1transport_1_1sync__io_1_1Native__socket__stream.html">Native_socket_stream</a> &amp;&amp;&#160;</td>
          <td class="paramname"><em>src</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">default</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Move-assigns from <code>src</code>; <code>*this</code> acts as if destructed; <code>src</code> becomes as-if default-cted (therefore in NULL state). </p>
<p >No-op if <code>&amp;src == this</code>.</p>
<p >Notes for <a class="el" href="classipc_1_1transport_1_1Native__socket__stream.html" title="Implements both Native_handle_sender and Native_handle_receiver concepts by using a stream-oriented U...">transport::Native_socket_stream</a> apply.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">src</td><td>See above. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>*this</code>.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classipc_1_1transport_1_1sync__io_1_1Native__handle__sender.html" title="A documentation-only concept defining the behavior of an object that is the sync_io-pattern counterpa...">Native_handle_sender</a> move assignment: implemented concept. </dd>
<dd>
<a class="el" href="classipc_1_1transport_1_1sync__io_1_1Native__handle__receiver.html" title="A documentation-only concept defining the behavior of an object that is the sync_io-pattern counterpa...">Native_handle_receiver</a> move assignment: implemented concept. </dd>
<dd>
<a class="el" href="classipc_1_1transport_1_1sync__io_1_1Blob__sender.html" title="A documentation-only concept: what transport::Blob_sender is to transport::Native_handle_sender (name...">Blob_sender</a> move assignment: implemented concept. </dd>
<dd>
<a class="el" href="classipc_1_1transport_1_1sync__io_1_1Blob__receiver.html" title="A documentation-only concept: what transport::Blob_receiver is to transport::Native_handle_receiver (...">Blob_receiver</a> move assignment: implemented concept. </dd></dl>

</div>
</div>
<a id="aa9ca8bbb8148c00f810a516b4fd66608" name="aa9ca8bbb8148c00f810a516b4fd66608"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa9ca8bbb8148c00f810a516b4fd66608">&#9670;&nbsp;</a></span>receive_blob_max_size()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t ipc::transport::sync_io::Native_socket_stream::receive_blob_max_size </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Implements <a class="el" href="classipc_1_1transport_1_1sync__io_1_1Blob__receiver.html" title="A documentation-only concept: what transport::Blob_receiver is to transport::Native_handle_receiver (...">Blob_receiver</a> API per contract. </p>
<p >Notes for <a class="el" href="classipc_1_1transport_1_1Blob__receiver.html" title="A documentation-only concept defining the behavior of an object capable of reliably/in-order receivin...">transport::Blob_receiver</a> apply.</p>
<dl class="section return"><dt>Returns</dt><dd>See above.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classipc_1_1transport_1_1sync__io_1_1Blob__receiver.html#aa8c46b25839f7660a1c867a25aa3680c" title="All notes from sync_io::Native_handle_receiver::receive_meta_blob_max_size() apply.">Blob_receiver::receive_blob_max_size()</a>: implemented concept. </dd></dl>

</div>
</div>
<a id="acc5f3cae4c5ff2facb5795c5013374e6" name="acc5f3cae4c5ff2facb5795c5013374e6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acc5f3cae4c5ff2facb5795c5013374e6">&#9670;&nbsp;</a></span>receive_meta_blob_max_size()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t ipc::transport::sync_io::Native_socket_stream::receive_meta_blob_max_size </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Implements <a class="el" href="classipc_1_1transport_1_1sync__io_1_1Native__handle__receiver.html" title="A documentation-only concept defining the behavior of an object that is the sync_io-pattern counterpa...">Native_handle_receiver</a> API per contract. </p>
<p >Notes for <a class="el" href="classipc_1_1transport_1_1Native__handle__receiver.html" title="A documentation-only concept defining the behavior of an object capable of reliably/in-order receivin...">transport::Native_handle_receiver</a> apply.</p>
<dl class="section return"><dt>Returns</dt><dd>See above.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classipc_1_1transport_1_1sync__io_1_1Native__handle__receiver.html#a46194b54e9465a5a41d7fedf9d4982ae" title="Mirrors sync_io::Native_handle_sender::send_meta_blob_max_size().">Native_handle_receiver::receive_meta_blob_max_size()</a>: implemented concept. </dd></dl>

</div>
</div>
<a id="ac6dc47cc06da9404e02fe83012adb768" name="ac6dc47cc06da9404e02fe83012adb768"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac6dc47cc06da9404e02fe83012adb768">&#9670;&nbsp;</a></span>release()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classipc_1_1transport_1_1sync__io_1_1Native__socket__stream.html">Native_socket_stream</a> ipc::transport::sync_io::Native_socket_stream::release </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>In PEER state only, with no prior send or receive ops, returns an object of this same type (as-if just constructed) operating on <code>*this</code> underlying low-level transport <code>Native_handle</code>; while <code>*this</code> becomes as-if default-cted. </p>
<p >It is similar to returning <code>Native_socket_stream(std::move(*this))</code>, except that any <a class="el" href="classipc_1_1transport_1_1sync__io_1_1Native__socket__stream.html#af5e6e5ccf19782cb698017e9dcf85b34" title="Implements Native_handle_sender and Native_handle_receiver APIs at the same time, per their concept c...">replace_event_wait_handles()</a> and <code>start_*_ops()</code> &ndash; generally irreversible publicly otherwise &ndash; are as-if undone on the returned object.</p>
<p >Rationale: To be perfectly honest this was originally written in order to allow for async-I/O-pattern <a class="el" href="classipc_1_1transport_1_1Native__socket__stream.html#a559ef620bfc3f46220dc7c3522bed32d" title="In PEER state only, with no prior send or receive ops, returns a sync_io::Native_socket_stream core (...">transport::Native_socket_stream::release()</a> to be writable.</p>
<p >Behavior is undefined if <code>*this</code> is not in PEER state, or if it is, but you've invoked <code>async_receive_*()</code>, <code>send_*()</code>, <code>*end_sending()</code>, <a class="el" href="classipc_1_1transport_1_1sync__io_1_1Native__socket__stream.html#aaef9afdeb3800df615a01b22070acad8" title="Implements Native_handle_sender, Blob_sender API per contract.">auto_ping()</a>, or <a class="el" href="classipc_1_1transport_1_1sync__io_1_1Native__socket__stream.html#ac645b3e69ee3bfda64c0e9fda62f656a" title="Implements Native_handle_receiver, Blob_receiver API per contract.">idle_timer_run()</a> in the past. (<code>start_*_ops()</code> and <a class="el" href="classipc_1_1transport_1_1sync__io_1_1Native__socket__stream.html#af5e6e5ccf19782cb698017e9dcf85b34" title="Implements Native_handle_sender and Native_handle_receiver APIs at the same time, per their concept c...">replace_event_wait_handles()</a> are fine.) Please be careful.</p>
<dl class="section return"><dt>Returns</dt><dd>See above. </dd></dl>

</div>
</div>
<a id="a16b605c316922325415d60aeb0af3c40" name="a16b605c316922325415d60aeb0af3c40"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a16b605c316922325415d60aeb0af3c40">&#9670;&nbsp;</a></span>remote_peer_process_credentials()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classipc_1_1util_1_1Process__credentials.html">util::Process_credentials</a> ipc::transport::sync_io::Native_socket_stream::remote_peer_process_credentials </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespaceipc.html#aa3192e586cc45d3e7c22463bf2760f89">Error_code</a> *&#160;</td>
          <td class="paramname"><em>err_code</em> = <code>0</code></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>OS-reported process credential (PID, etc.) info about the <em>other</em> connected peer's process, at the time that the OS first established (via local-socket-connect or local-socket-connected-pair-generate call) that opposing peer socket. </p>
<p >The value returned, assuming a non-error-emitting execution, shall always be the same for a given <code>*this</code>.</p>
<p >Informally: To avoid (though, formally, not guarantee) <a class="el" href="namespaceipc_1_1transport_1_1error.html#adfef15ef4e76cc55d652fbd9c2797297acb14cace6f75d915cd800113c37721e7" title="Unable to access low-level details: an earlier-reported system error had hosed the underlying transpo...">error::Code::S_LOW_LVL_TRANSPORT_HOSED</a>, it is best to call this immediately upon entry of <code>*this</code> to PEER state and/or before invoking any other APIs.</p>
<p >If invoked outside of PEER state returns <code>Process_credentials()</code> immediately and otherwise does nothing.</p>
<dl class="section return"><dt>Returns</dt><dd>See above; or <code>Peer_credentials()</code> if invoked outside of PEER state or in case of error. The 2 eventualities can be distinguished by checking <code>*err_code</code> truthiness. Better yet only call <a class="el" href="classipc_1_1transport_1_1sync__io_1_1Native__socket__stream.html#a16b605c316922325415d60aeb0af3c40" title="OS-reported process credential (PID, etc.) info about the other connected peer&#39;s process,...">remote_peer_process_credentials()</a> in PEER state, as it is otherwise conceptually meaningless.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">err_code</td><td>See <code>flow::Error_code</code> docs for error reporting semantics. <a class="el" href="namespaceipc.html#aa3192e586cc45d3e7c22463bf2760f89" title="Short-hand for boost.interprocess namespace.">Error_code</a> generated: See <a class="el" href="classipc_1_1transport_1_1sync__io_1_1Native__socket__stream.html#a24d39cb096987f483f233d9d4ab51ecf" title="Useful for generic programming, the async-I/O-pattern counterpart to *this type.">Async_io_obj</a> counterpart doc header. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="af5e6e5ccf19782cb698017e9dcf85b34" name="af5e6e5ccf19782cb698017e9dcf85b34"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af5e6e5ccf19782cb698017e9dcf85b34">&#9670;&nbsp;</a></span>replace_event_wait_handles()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Create_ev_wait_hndl_func &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool ipc::transport::sync_io::Native_socket_stream::replace_event_wait_handles </td>
          <td>(</td>
          <td class="paramtype">const Create_ev_wait_hndl_func &amp;&#160;</td>
          <td class="paramname"><em>create_ev_wait_hndl_func</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Implements <a class="el" href="classipc_1_1transport_1_1sync__io_1_1Native__handle__sender.html" title="A documentation-only concept defining the behavior of an object that is the sync_io-pattern counterpa...">Native_handle_sender</a> <em>and</em> <a class="el" href="classipc_1_1transport_1_1sync__io_1_1Native__handle__receiver.html" title="A documentation-only concept defining the behavior of an object that is the sync_io-pattern counterpa...">Native_handle_receiver</a> APIs at the same time, per their concept contracts. </p>
<p >(Also implements <a class="el" href="classipc_1_1transport_1_1sync__io_1_1Blob__sender.html" title="A documentation-only concept: what transport::Blob_sender is to transport::Native_handle_sender (name...">Blob_sender</a> <em>and</em> <a class="el" href="classipc_1_1transport_1_1sync__io_1_1Blob__receiver.html" title="A documentation-only concept: what transport::Blob_receiver is to transport::Native_handle_receiver (...">Blob_receiver</a> APIs; they are identical.)</p>
<p >In addition (to the reasons documented for the concept(s)) it shall no-op/warn/return <code>false</code>, if <a class="el" href="classipc_1_1transport_1_1sync__io_1_1Native__socket__stream.html#a97fa6328b1d77a9ee212e09721fc398e" title="Sets up the sync_io-pattern interaction between *this and the user&#39;s event loop; required before asyn...">start_connect_ops()</a> has already been called.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">create_ev_wait_hndl_func</td><td>See above. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>See above.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classipc_1_1transport_1_1sync__io_1_1Native__handle__sender.html#abe6227dfa077571d6eed2707532e4360" title="To be (optionally) invoked before any start_*_ops(), supplies a factory for the util::sync_io::Asio_w...">Native_handle_sender::replace_event_wait_handles()</a>: implemented concept. </dd>
<dd>
<a class="el" href="classipc_1_1transport_1_1sync__io_1_1Native__handle__receiver.html#a6b26e7ee8f63e8e80b9cc7010bf208d6" title="Coincides with sync_io::Native_handle_sender concept counterpart.">Native_handle_receiver::replace_event_wait_handles()</a>: implemented concept. </dd>
<dd>
<a class="el" href="classipc_1_1transport_1_1sync__io_1_1Blob__sender.html#a15da7ad5bcf7147e6308d532f1432352" title="Coincides with sync_io::Native_handle_sender concept counterpart.">Blob_sender::replace_event_wait_handles()</a>: alternatively implemented concept. </dd>
<dd>
<a class="el" href="classipc_1_1transport_1_1sync__io_1_1Blob__receiver.html#a349a3fc5bf2b0246f206ea332f8684e0" title="Coincides with sync_io::Native_handle_receiver concept counterpart.">Blob_receiver::replace_event_wait_handles()</a>: alternatively implemented concept. </dd></dl>

</div>
</div>
<a id="a2e1474a87ee8f5ec18bf6cc8d6cfe7b2" name="a2e1474a87ee8f5ec18bf6cc8d6cfe7b2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2e1474a87ee8f5ec18bf6cc8d6cfe7b2">&#9670;&nbsp;</a></span>send_blob()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool ipc::transport::sync_io::Native_socket_stream::send_blob </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespaceipc_1_1util.html#ae0be7edba7e30ffa3f8b742af621f2ab">util::Blob_const</a> &amp;&#160;</td>
          <td class="paramname"><em>blob</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceipc.html#aa3192e586cc45d3e7c22463bf2760f89">Error_code</a> *&#160;</td>
          <td class="paramname"><em>err_code</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Implements <a class="el" href="classipc_1_1transport_1_1sync__io_1_1Blob__sender.html" title="A documentation-only concept: what transport::Blob_sender is to transport::Native_handle_sender (name...">Blob_sender</a> API per contract. </p>
<p >Reminder: Please peruse "Thread safety" in class doc header.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">blob</td><td>See above. </td></tr>
    <tr><td class="paramname">err_code</td><td>See above. Reminder: In rare circumstances, an error emitted here may represent something detected during handling of a <em>preceding</em> <a class="el" href="classipc_1_1transport_1_1sync__io_1_1Native__socket__stream.html#a9805f7625a1272af64295555f9a1a61b" title="Implements Native_handle_sender API per contract.">send_native_handle()</a> call but after it returned. <a class="el" href="namespaceipc.html#aa3192e586cc45d3e7c22463bf2760f89" title="Short-hand for boost.interprocess namespace.">Error_code</a> generated: See <a class="el" href="classipc_1_1transport_1_1sync__io_1_1Native__socket__stream.html#a24d39cb096987f483f233d9d4ab51ecf" title="Useful for generic programming, the async-I/O-pattern counterpart to *this type.">Async_io_obj</a> counterpart doc header. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>See above.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classipc_1_1transport_1_1sync__io_1_1Blob__sender.html#add3aa0b782c02b3e1222b4ee25598ecc" title="In PEER state: Synchronously, non-blockingly sends one discrete message, reliably and in-order,...">Blob_sender::send_blob()</a>: implemented concept. </dd></dl>

</div>
</div>
<a id="aabfd97c75d56d3f7a492d95040f4b8ab" name="aabfd97c75d56d3f7a492d95040f4b8ab"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aabfd97c75d56d3f7a492d95040f4b8ab">&#9670;&nbsp;</a></span>send_blob_max_size()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t ipc::transport::sync_io::Native_socket_stream::send_blob_max_size </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Implements <a class="el" href="classipc_1_1transport_1_1sync__io_1_1Blob__sender.html" title="A documentation-only concept: what transport::Blob_sender is to transport::Native_handle_sender (name...">Blob_sender</a> API per contract. </p>
<p >Notes for <a class="el" href="classipc_1_1transport_1_1Blob__sender.html" title="A documentation-only concept defining the behavior of an object capable of reliably/in-order sending ...">transport::Blob_sender</a> apply.</p>
<dl class="section return"><dt>Returns</dt><dd>See above.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classipc_1_1transport_1_1sync__io_1_1Blob__sender.html#a57611f88b625f095d4a6a0f0e5d9e665" title="All notes from sync_io::Native_handle_sender apply.">Blob_sender::send_blob_max_size()</a>: implemented concept. </dd></dl>

</div>
</div>
<a id="a945fb744696feed25067241ce2b6ca4b" name="a945fb744696feed25067241ce2b6ca4b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a945fb744696feed25067241ce2b6ca4b">&#9670;&nbsp;</a></span>send_meta_blob_max_size()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t ipc::transport::sync_io::Native_socket_stream::send_meta_blob_max_size </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Implements <a class="el" href="classipc_1_1transport_1_1sync__io_1_1Native__handle__sender.html" title="A documentation-only concept defining the behavior of an object that is the sync_io-pattern counterpa...">Native_handle_sender</a> API per contract. </p>
<p >Notes for <a class="el" href="classipc_1_1transport_1_1Native__handle__sender.html" title="A documentation-only concept defining the behavior of an object capable of reliably/in-order sending ...">transport::Native_handle_sender</a> apply.</p>
<dl class="section return"><dt>Returns</dt><dd>See above.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classipc_1_1transport_1_1sync__io_1_1Native__handle__sender.html#afde03d7fb5746e77524229d5881b8d79" title="Same notes as for transport::Native_handle_sender.">Native_handle_sender::send_meta_blob_max_size()</a>: implemented concept. </dd></dl>

</div>
</div>
<a id="a9805f7625a1272af64295555f9a1a61b" name="a9805f7625a1272af64295555f9a1a61b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9805f7625a1272af64295555f9a1a61b">&#9670;&nbsp;</a></span>send_native_handle()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool ipc::transport::sync_io::Native_socket_stream::send_native_handle </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespaceipc_1_1transport.html#a7ee4551983d9df16ec16a3139bac50e8">Native_handle</a>&#160;</td>
          <td class="paramname"><em>hndl_or_null</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespaceipc_1_1util.html#ae0be7edba7e30ffa3f8b742af621f2ab">util::Blob_const</a> &amp;&#160;</td>
          <td class="paramname"><em>meta_blob</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceipc.html#aa3192e586cc45d3e7c22463bf2760f89">Error_code</a> *&#160;</td>
          <td class="paramname"><em>err_code</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Implements <a class="el" href="classipc_1_1transport_1_1sync__io_1_1Native__handle__sender.html" title="A documentation-only concept defining the behavior of an object that is the sync_io-pattern counterpa...">Native_handle_sender</a> API per contract. </p>
<p >Reminder: Please peruse "Thread safety" in class doc header.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">hndl_or_null</td><td>See above. </td></tr>
    <tr><td class="paramname">meta_blob</td><td>See above. </td></tr>
    <tr><td class="paramname">err_code</td><td>See above. Reminder: In rare circumstances, an error emitted here may represent something detected during handling of a <em>preceding</em> <a class="el" href="classipc_1_1transport_1_1sync__io_1_1Native__socket__stream.html#a9805f7625a1272af64295555f9a1a61b" title="Implements Native_handle_sender API per contract.">send_native_handle()</a> call but after it returned. <a class="el" href="namespaceipc.html#aa3192e586cc45d3e7c22463bf2760f89" title="Short-hand for boost.interprocess namespace.">Error_code</a> generated: See <a class="el" href="classipc_1_1transport_1_1sync__io_1_1Native__socket__stream.html#a24d39cb096987f483f233d9d4ab51ecf" title="Useful for generic programming, the async-I/O-pattern counterpart to *this type.">Async_io_obj</a> counterpart doc header. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>See above.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classipc_1_1transport_1_1sync__io_1_1Native__handle__sender.html#a0f8f3fb816c09dd9a992a878892bbffb" title="In PEER state: Synchronously, non-blockingly sends one discrete message, reliably/in-order,...">Native_handle_sender::send_native_handle()</a>: implemented concept. </dd></dl>

</div>
</div>
<a id="a97fa6328b1d77a9ee212e09721fc398e" name="a97fa6328b1d77a9ee212e09721fc398e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a97fa6328b1d77a9ee212e09721fc398e">&#9670;&nbsp;</a></span>start_connect_ops()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Event_wait_func_t &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool ipc::transport::sync_io::Native_socket_stream::start_connect_ops </td>
          <td>(</td>
          <td class="paramtype">Event_wait_func_t &amp;&amp;&#160;</td>
          <td class="paramname"><em>ev_wait_func</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sets up the <code><a class="el" href="namespaceipc_1_1transport_1_1sync__io.html" title="sync_io-pattern counterparts to async-I/O-pattern object types in parent namespace ipc::transport.">sync_io</a></code>-pattern interaction between <code>*this</code> and the user's event loop; required before <a class="el" href="classipc_1_1transport_1_1sync__io_1_1Native__socket__stream.html#a3fed4817936af7f23d2beb8f75999d8d" title="See Async_io_obj counterpart for the essential semantics; however here according to sync_io pattern t...">async_connect()</a> will work (as opposed to no-op/return <code>false</code>). </p>
<p >If in PEER state it is unnecessary and shall no-op and return <code>false</code>.</p>
<p ><code>ev_wait_func()</code> &ndash; with signature matching <a class="el" href="namespaceipc_1_1util_1_1sync__io.html#aa0b9a3cc6bdc7dedbef4f9e06851aa24" title="In sync_io pattern, concrete type storing user-supplied function invoked by pattern-implementing ipc:...">util::sync_io::Event_wait_func</a> &ndash; is a key function memorized by <code>*this</code>. It shall be invoked by <code>*this</code> operations when some op cannot complete synchronously and requires a certain event (readable/writable) to be active on a certain native-handle.</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="namespaceipc_1_1util_1_1sync__io.html#aa0b9a3cc6bdc7dedbef4f9e06851aa24" title="In sync_io pattern, concrete type storing user-supplied function invoked by pattern-implementing ipc:...">util::sync_io::Event_wait_func</a> doc header for useful and complete instructions on how to write an <code>ev_wait_func()</code> properly. Doing so correctly is the crux of using the <code><a class="el" href="namespaceipc_1_1transport_1_1sync__io.html" title="sync_io-pattern counterparts to async-I/O-pattern object types in parent namespace ipc::transport.">sync_io</a></code> pattern.</dd></dl>
<p>This is a standard <code><a class="el" href="namespaceipc_1_1transport_1_1sync__io.html" title="sync_io-pattern counterparts to async-I/O-pattern object types in parent namespace ipc::transport.">sync_io</a></code>-pattern API per <a class="el" href="namespaceipc_1_1util_1_1sync__io.html" title="Contains common code, as well as important explanatory documentation in the following text,...">util::sync_io</a> doc header.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Event_wait_func_t</td><td>Function type matching <a class="el" href="namespaceipc_1_1util_1_1sync__io.html#aa0b9a3cc6bdc7dedbef4f9e06851aa24" title="In sync_io pattern, concrete type storing user-supplied function invoked by pattern-implementing ipc:...">util::sync_io::Event_wait_func</a>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ev_wait_func</td><td>See above. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>false</code> if this has already been invoked; no-op logging aside. <code>true</code> otherwise. </dd></dl>

</div>
</div>
<a id="a931e45a395d0bef15084db3b6b1e9754" name="a931e45a395d0bef15084db3b6b1e9754"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a931e45a395d0bef15084db3b6b1e9754">&#9670;&nbsp;</a></span>start_receive_blob_ops()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Event_wait_func_t &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool ipc::transport::sync_io::Native_socket_stream::start_receive_blob_ops </td>
          <td>(</td>
          <td class="paramtype">Event_wait_func_t &amp;&amp;&#160;</td>
          <td class="paramname"><em>ev_wait_func</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Implements <a class="el" href="classipc_1_1transport_1_1sync__io_1_1Blob__receiver.html" title="A documentation-only concept: what transport::Blob_receiver is to transport::Native_handle_receiver (...">Blob_receiver</a> API per contract. </p>
<p >In this implementation <a class="el" href="classipc_1_1transport_1_1sync__io_1_1Native__socket__stream.html#ac6d65bc2852ad8800cb57a23311fbe7e" title="Implements Native_handle_receiver API per contract.">start_receive_native_handle_ops()</a> and <a class="el" href="classipc_1_1transport_1_1sync__io_1_1Native__socket__stream.html#a931e45a395d0bef15084db3b6b1e9754" title="Implements Blob_receiver API per contract.">start_receive_blob_ops()</a> are interchangeable: calling either one gets the job done, and calling the other subsequently is harmless but would return <code>false</code> and no-op/log WARNING.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Event_wait_func_t</td><td>See above. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ev_wait_func</td><td>See above. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>See above. In addition return <code>false</code>/WARNING/no-op, if <a class="el" href="classipc_1_1transport_1_1sync__io_1_1Native__socket__stream.html#ac6d65bc2852ad8800cb57a23311fbe7e" title="Implements Native_handle_receiver API per contract.">start_receive_native_handle_ops()</a> earlier succeeded.</dd></dl>
<dl class="section see"><dt>See also</dt><dd>Native_handle_receiver::start_receive_blob_ops(): implemented concept. </dd></dl>

</div>
</div>
<a id="ac6d65bc2852ad8800cb57a23311fbe7e" name="ac6d65bc2852ad8800cb57a23311fbe7e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac6d65bc2852ad8800cb57a23311fbe7e">&#9670;&nbsp;</a></span>start_receive_native_handle_ops()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Event_wait_func_t &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool ipc::transport::sync_io::Native_socket_stream::start_receive_native_handle_ops </td>
          <td>(</td>
          <td class="paramtype">Event_wait_func_t &amp;&amp;&#160;</td>
          <td class="paramname"><em>ev_wait_func</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Implements <a class="el" href="classipc_1_1transport_1_1sync__io_1_1Native__handle__receiver.html" title="A documentation-only concept defining the behavior of an object that is the sync_io-pattern counterpa...">Native_handle_receiver</a> API per contract. </p>
<p >See also <a class="el" href="classipc_1_1transport_1_1sync__io_1_1Native__socket__stream.html#a931e45a395d0bef15084db3b6b1e9754" title="Implements Blob_receiver API per contract.">start_receive_blob_ops()</a>.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Event_wait_func_t</td><td>See above. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ev_wait_func</td><td>See above. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>See above. In addition return <code>false</code>/WARNING/no-op, if <a class="el" href="classipc_1_1transport_1_1sync__io_1_1Native__socket__stream.html#a931e45a395d0bef15084db3b6b1e9754" title="Implements Blob_receiver API per contract.">start_receive_blob_ops()</a> earlier succeeded.</dd></dl>
<dl class="section see"><dt>See also</dt><dd>Native_handle_receiver::receive_blob_max_size(): implemented concept. </dd></dl>

</div>
</div>
<a id="a2b1fa31c4d8ac11683472b83efe7956a" name="a2b1fa31c4d8ac11683472b83efe7956a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2b1fa31c4d8ac11683472b83efe7956a">&#9670;&nbsp;</a></span>start_send_blob_ops()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Event_wait_func_t &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool ipc::transport::sync_io::Native_socket_stream::start_send_blob_ops </td>
          <td>(</td>
          <td class="paramtype">Event_wait_func_t &amp;&amp;&#160;</td>
          <td class="paramname"><em>ev_wait_func</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Implements <a class="el" href="classipc_1_1transport_1_1sync__io_1_1Blob__sender.html" title="A documentation-only concept: what transport::Blob_sender is to transport::Native_handle_sender (name...">Blob_sender</a> API per contract. </p>
<p >In this implementation <a class="el" href="classipc_1_1transport_1_1sync__io_1_1Native__socket__stream.html#a2bd0b6a8badd0b770917bb9df9ad6093" title="Implements Native_handle_sender API per contract.">start_send_native_handle_ops()</a> and <a class="el" href="classipc_1_1transport_1_1sync__io_1_1Native__socket__stream.html#a2b1fa31c4d8ac11683472b83efe7956a" title="Implements Blob_sender API per contract.">start_send_blob_ops()</a> are interchangeable: calling either one gets the job done, and calling the other subsequently is harmless but would return <code>false</code> and no-op/log WARNING.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Event_wait_func_t</td><td>See above. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ev_wait_func</td><td>See above. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>See above. In addition return <code>false</code>/WARNING/no-op, if <a class="el" href="classipc_1_1transport_1_1sync__io_1_1Native__socket__stream.html#a2bd0b6a8badd0b770917bb9df9ad6093" title="Implements Native_handle_sender API per contract.">start_send_native_handle_ops()</a> earlier succeeded.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classipc_1_1transport_1_1sync__io_1_1Blob__sender.html#aa7676391885035faa7195c0840ae2009" title="All notes from sync_io::Native_handle_sender::start_send_native_handle_ops() apply.">Blob_sender::start_send_blob_ops()</a>: implemented concept. </dd></dl>

</div>
</div>
<a id="a2bd0b6a8badd0b770917bb9df9ad6093" name="a2bd0b6a8badd0b770917bb9df9ad6093"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2bd0b6a8badd0b770917bb9df9ad6093">&#9670;&nbsp;</a></span>start_send_native_handle_ops()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Event_wait_func_t &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool ipc::transport::sync_io::Native_socket_stream::start_send_native_handle_ops </td>
          <td>(</td>
          <td class="paramtype">Event_wait_func_t &amp;&amp;&#160;</td>
          <td class="paramname"><em>ev_wait_func</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Implements <a class="el" href="classipc_1_1transport_1_1sync__io_1_1Native__handle__sender.html" title="A documentation-only concept defining the behavior of an object that is the sync_io-pattern counterpa...">Native_handle_sender</a> API per contract. </p>
<p >See also <a class="el" href="classipc_1_1transport_1_1sync__io_1_1Native__socket__stream.html#a2b1fa31c4d8ac11683472b83efe7956a" title="Implements Blob_sender API per contract.">start_send_blob_ops()</a>.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Event_wait_func_t</td><td>See above. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ev_wait_func</td><td>See above. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>See above. In addition return <code>false</code>/WARNING/no-op, if <a class="el" href="classipc_1_1transport_1_1sync__io_1_1Native__socket__stream.html#a2b1fa31c4d8ac11683472b83efe7956a" title="Implements Blob_sender API per contract.">start_send_blob_ops()</a> earlier succeeded.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classipc_1_1transport_1_1sync__io_1_1Native__handle__sender.html#a8c34b110850c736c45d88689ab06c27c" title="Sets up the sync_io-pattern interaction between *this and the user&#39;s event loop; required before send...">Native_handle_sender::start_send_native_handle_ops()</a>: implemented concept. </dd></dl>

</div>
</div>
<h2 class="groupheader">Friends And Related Function Documentation</h2>
<a id="ac6108711cc8b33c3b7ef0491ba78e2f6" name="ac6108711cc8b33c3b7ef0491ba78e2f6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac6108711cc8b33c3b7ef0491ba78e2f6">&#9670;&nbsp;</a></span>operator&lt;&lt;()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::ostream &amp; operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>os</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classipc_1_1transport_1_1sync__io_1_1Native__socket__stream.html">Native_socket_stream</a> &amp;&#160;</td>
          <td class="paramname"><em>val</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Prints string representation of the given <code><a class="el" href="classipc_1_1transport_1_1sync__io_1_1Native__socket__stream.html" title="Implements both sync_io::Native_handle_sender and sync_io::Native_handle_receiver concepts by using a...">Native_socket_stream</a></code> to the given <code>ostream</code>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">os</td><td>Stream to which to write. </td></tr>
    <tr><td class="paramname">val</td><td>Object to serialize. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>os</code>. </dd></dl>

</div>
</div>
<h2 class="groupheader">Member Data Documentation</h2>
<a id="a7034a92ae66759080c035b36ff851e0c" name="a7034a92ae66759080c035b36ff851e0c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7034a92ae66759080c035b36ff851e0c">&#9670;&nbsp;</a></span>S_BLOB_UNDERFLOW_ALLOWED</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr bool ipc::transport::sync_io::Native_socket_stream::S_BLOB_UNDERFLOW_ALLOWED = true</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Implements concept API; namely it is <code>true</code>. </p>
<p >Notes for <a class="el" href="classipc_1_1transport_1_1Native__socket__stream.html" title="Implements both Native_handle_sender and Native_handle_receiver concepts by using a stream-oriented U...">transport::Native_socket_stream</a> apply.</p>
<dl class="section see"><dt>See also</dt><dd>Native_handle_receiver::S_BLOB_UNDERFLOW_ALLOWED: implemented concept. Accordingly also see "Blob underflow semantics" in <a class="el" href="classipc_1_1transport_1_1Native__handle__receiver.html" title="A documentation-only concept defining the behavior of an object capable of reliably/in-order receivin...">transport::Native_handle_receiver</a> doc header. </dd></dl>

</div>
</div>
<a id="a00624e2fc3757012d13e3dc0feb26a21" name="a00624e2fc3757012d13e3dc0feb26a21"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a00624e2fc3757012d13e3dc0feb26a21">&#9670;&nbsp;</a></span>S_MAX_META_BLOB_LENGTH</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const size_t &amp; ipc::transport::sync_io::Native_socket_stream::S_MAX_META_BLOB_LENGTH = Impl::S_MAX_META_BLOB_LENGTH</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>The maximum length of a blob that can be sent by this protocol. </p>
<p ><a class="el" href="classipc_1_1transport_1_1sync__io_1_1Native__socket__stream.html#a9805f7625a1272af64295555f9a1a61b" title="Implements Native_handle_sender API per contract.">send_native_handle()</a> shall synchronously emit a particular error, if <code>meta_blob.size()</code> exceeds this. <a class="el" href="classipc_1_1transport_1_1sync__io_1_1Native__socket__stream.html#a2e1474a87ee8f5ec18bf6cc8d6cfe7b2" title="Implements Blob_sender API per contract.">send_blob()</a> shall do similarly for <code>blob</code> arg. The same is accurate of their async-I/O-pattern <a class="el" href="classipc_1_1transport_1_1Native__socket__stream.html" title="Implements both Native_handle_sender and Native_handle_receiver concepts by using a stream-oriented U...">transport::Native_socket_stream</a> counterparts. </p>

</div>
</div>
<a id="aab8f0844b61c700b3ab6ab50e3389fff" name="aab8f0844b61c700b3ab6ab50e3389fff"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aab8f0844b61c700b3ab6ab50e3389fff">&#9670;&nbsp;</a></span>S_META_BLOB_UNDERFLOW_ALLOWED</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr bool ipc::transport::sync_io::Native_socket_stream::S_META_BLOB_UNDERFLOW_ALLOWED = true</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Implements concept API; namely it is <code>true</code>. </p>
<p >Notes for <a class="el" href="classipc_1_1transport_1_1Native__socket__stream.html" title="Implements both Native_handle_sender and Native_handle_receiver concepts by using a stream-oriented U...">transport::Native_socket_stream</a> apply.</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classipc_1_1transport_1_1sync__io_1_1Native__handle__receiver.html#aeb80b0f432a762a5c78ff19c8e32c0b9" title="Same notes as for transport::Native_handle_receiver.">Native_handle_receiver::S_META_BLOB_UNDERFLOW_ALLOWED</a>: implemented concept. Accordingly also see "Blob underflow semantics" in <a class="el" href="classipc_1_1transport_1_1Native__handle__receiver.html" title="A documentation-only concept defining the behavior of an object capable of reliably/in-order receivin...">transport::Native_handle_receiver</a> doc header. </dd></dl>

</div>
</div>
<hr/>The documentation for this class was generated from the following files:<ul>
<li>transport/sync_io/<a class="el" href="sync__io_2native__socket__stream_8hpp.html">native_socket_stream.hpp</a></li>
<li>transport/sync_io/<a class="el" href="sync__io_2native__socket__stream_8cpp.html">native_socket_stream.cpp</a></li>
<li>transport/<a class="el" href="transport__fwd_8hpp.html">transport_fwd.hpp</a></li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Thu Feb 8 2024 21:52:47 for Flow-IPC by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.4
</small></address>
</body>
</html>
