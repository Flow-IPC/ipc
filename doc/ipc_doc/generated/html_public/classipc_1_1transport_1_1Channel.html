<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.9.4"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Flow-IPC: ipc::transport::Channel&lt; Blob_sender, Blob_receiver, Native_handle_sender, Native_handle_receiver &gt; Class Template Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">Flow-IPC<span id="projectnumber">&#160;1.0</span>
   </div>
   <div id="projectbrief">Flow-IPC project: Public API.</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.4 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search",'Search','.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespaceipc.html">ipc</a></li><li class="navelem"><a class="el" href="namespaceipc_1_1transport.html">transport</a></li><li class="navelem"><a class="el" href="classipc_1_1transport_1_1Channel.html">Channel</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-types">Public Types</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pub-static-attribs">Static Public Attributes</a> &#124;
<a href="#related">Related Functions</a> &#124;
<a href="classipc_1_1transport_1_1Channel-members.html">List of all members</a>  </div>
  <div class="headertitle"><div class="title">ipc::transport::Channel&lt; Blob_sender, Blob_receiver, Native_handle_sender, Native_handle_receiver &gt; Class Template Reference</div></div>
</div><!--header-->
<div class="contents">

<p>Peer to a bundle of 1-2 full-duplex pipe(s), one for transmitting unstructured binary blobs; the other for transmitting native handle+blob combos; hence a <a class="el" href="classipc_1_1transport_1_1Blob__sender.html" title="A documentation-only concept defining the behavior of an object capable of reliably/in-order sending ...">Blob_sender</a> + <a class="el" href="classipc_1_1transport_1_1Blob__receiver.html" title="A documentation-only concept defining the behavior of an object capable of reliably/in-order receivin...">Blob_receiver</a>, a <a class="el" href="classipc_1_1transport_1_1Native__handle__sender.html" title="A documentation-only concept defining the behavior of an object capable of reliably/in-order sending ...">Native_handle_sender</a> + <a class="el" href="classipc_1_1transport_1_1Native__handle__receiver.html" title="A documentation-only concept defining the behavior of an object capable of reliably/in-order receivin...">Native_handle_receiver</a>, or both.  
 <a href="classipc_1_1transport_1_1Channel.html#details">More...</a></p>

<p><code>#include &lt;channel.hpp&gt;</code></p>

<p>Inherits flow::log::Log_context.</p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-types" name="pub-types"></a>
Public Types</h2></td></tr>
<tr class="memitem:a82746276cc7379a866b12d529780900f"><td class="memItemLeft" align="right" valign="top"><a id="a82746276cc7379a866b12d529780900f" name="a82746276cc7379a866b12d529780900f"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>Blob_sender_obj</b> = <a class="el" href="classipc_1_1transport_1_1Blob__sender.html">Blob_sender</a></td></tr>
<tr class="memdesc:a82746276cc7379a866b12d529780900f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Alias for <code><a class="el" href="classipc_1_1transport_1_1Blob__sender.html" title="A documentation-only concept defining the behavior of an object capable of reliably/in-order sending ...">Blob_sender</a></code> template parameter. <br /></td></tr>
<tr class="separator:a82746276cc7379a866b12d529780900f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa9a7ec2d2eedfc3b6a1d2edfb05ea6d1"><td class="memItemLeft" align="right" valign="top"><a id="aa9a7ec2d2eedfc3b6a1d2edfb05ea6d1" name="aa9a7ec2d2eedfc3b6a1d2edfb05ea6d1"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>Blob_receiver_obj</b> = <a class="el" href="classipc_1_1transport_1_1Blob__receiver.html">Blob_receiver</a></td></tr>
<tr class="memdesc:aa9a7ec2d2eedfc3b6a1d2edfb05ea6d1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Alias for <code><a class="el" href="classipc_1_1transport_1_1Blob__receiver.html" title="A documentation-only concept defining the behavior of an object capable of reliably/in-order receivin...">Blob_receiver</a></code> template parameter. <br /></td></tr>
<tr class="separator:aa9a7ec2d2eedfc3b6a1d2edfb05ea6d1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afc600491e137c9dc16c202b04885a36a"><td class="memItemLeft" align="right" valign="top"><a id="afc600491e137c9dc16c202b04885a36a" name="afc600491e137c9dc16c202b04885a36a"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>Native_handle_sender_obj</b> = <a class="el" href="classipc_1_1transport_1_1Native__handle__sender.html">Native_handle_sender</a></td></tr>
<tr class="memdesc:afc600491e137c9dc16c202b04885a36a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Alias for <code><a class="el" href="classipc_1_1transport_1_1Native__handle__sender.html" title="A documentation-only concept defining the behavior of an object capable of reliably/in-order sending ...">Native_handle_sender</a></code> template parameter. <br /></td></tr>
<tr class="separator:afc600491e137c9dc16c202b04885a36a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad011bfbcfc226b9a32d97188485d9a22"><td class="memItemLeft" align="right" valign="top"><a id="ad011bfbcfc226b9a32d97188485d9a22" name="ad011bfbcfc226b9a32d97188485d9a22"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>Native_handle_receiver_obj</b> = <a class="el" href="classipc_1_1transport_1_1Native__handle__receiver.html">Native_handle_receiver</a></td></tr>
<tr class="memdesc:ad011bfbcfc226b9a32d97188485d9a22"><td class="mdescLeft">&#160;</td><td class="mdescRight">Alias for <code><a class="el" href="classipc_1_1transport_1_1Native__handle__receiver.html" title="A documentation-only concept defining the behavior of an object capable of reliably/in-order receivin...">Native_handle_receiver</a></code> template parameter. <br /></td></tr>
<tr class="separator:ad011bfbcfc226b9a32d97188485d9a22"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab6f7d14037e228e24a8fbd33b41e1c82"><td class="memItemLeft" align="right" valign="top"><a id="ab6f7d14037e228e24a8fbd33b41e1c82" name="ab6f7d14037e228e24a8fbd33b41e1c82"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>Async_io_obj</b> = <a class="el" href="classipc_1_1transport_1_1Channel.html">Channel</a>&lt; typename Blob_sender_obj::Async_io_obj, typename Blob_receiver_obj::Async_io_obj, typename Native_handle_sender_obj::Async_io_obj, typename Native_handle_receiver_obj::Async_io_obj &gt;</td></tr>
<tr class="memdesc:ab6f7d14037e228e24a8fbd33b41e1c82"><td class="mdescLeft">&#160;</td><td class="mdescRight">Assuming <a class="el" href="classipc_1_1transport_1_1Channel.html#ae5be240d29389d7b728950e85df0704e" title="Useful for generic programming: true &lt;=&gt; each non-Null_peer peer type (Blob_sender_obj,...">S_IS_SYNC_IO_OBJ</a> yields async-I/O counterpart; else yields <code><a class="el" href="classipc_1_1transport_1_1Channel.html" title="Peer to a bundle of 1-2 full-duplex pipe(s), one for transmitting unstructured binary blobs; the othe...">Channel</a>&lt;<a class="el" href="classipc_1_1transport_1_1Null__peer.html" title="Dummy type for use as a template param to Channel when either the blobs pipe or handles pipe is disab...">Null_peer</a>, <a class="el" href="classipc_1_1transport_1_1Null__peer.html" title="Dummy type for use as a template param to Channel when either the blobs pipe or handles pipe is disab...">Null_peer</a>, <a class="el" href="classipc_1_1transport_1_1Null__peer.html" title="Dummy type for use as a template param to Channel when either the blobs pipe or handles pipe is disab...">Null_peer</a>, <a class="el" href="classipc_1_1transport_1_1Null__peer.html" title="Dummy type for use as a template param to Channel when either the blobs pipe or handles pipe is disab...">Null_peer</a>&gt;</code>. <br /></td></tr>
<tr class="separator:ab6f7d14037e228e24a8fbd33b41e1c82"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab620c31d21118f85736b6a503fea9808"><td class="memItemLeft" align="right" valign="top"><a id="ab620c31d21118f85736b6a503fea9808" name="ab620c31d21118f85736b6a503fea9808"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>Sync_io_obj</b> = <a class="el" href="classipc_1_1transport_1_1Channel.html">Channel</a>&lt; typename Blob_sender_obj::Sync_io_obj, typename Blob_receiver_obj::Sync_io_obj, typename Native_handle_sender_obj::Sync_io_obj, typename Native_handle_receiver_obj::Sync_io_obj &gt;</td></tr>
<tr class="memdesc:ab620c31d21118f85736b6a503fea9808"><td class="mdescLeft">&#160;</td><td class="mdescRight">Assuming <a class="el" href="classipc_1_1transport_1_1Channel.html#a9f75b20b07eff47a69c2b1dbe5c85f84" title="It equals the reverse of S_IS_SYNC_IO_OBJ.">S_IS_ASYNC_IO_OBJ</a> yields <code><a class="el" href="namespaceipc_1_1transport_1_1sync__io.html" title="sync_io-pattern counterparts to async-I/O-pattern object types in parent namespace ipc::transport.">sync_io</a></code> counterpart; else yields <code><a class="el" href="classipc_1_1transport_1_1Channel.html" title="Peer to a bundle of 1-2 full-duplex pipe(s), one for transmitting unstructured binary blobs; the othe...">Channel</a>&lt;<a class="el" href="classipc_1_1transport_1_1Null__peer.html" title="Dummy type for use as a template param to Channel when either the blobs pipe or handles pipe is disab...">Null_peer</a>, <a class="el" href="classipc_1_1transport_1_1Null__peer.html" title="Dummy type for use as a template param to Channel when either the blobs pipe or handles pipe is disab...">Null_peer</a>, <a class="el" href="classipc_1_1transport_1_1Null__peer.html" title="Dummy type for use as a template param to Channel when either the blobs pipe or handles pipe is disab...">Null_peer</a>, <a class="el" href="classipc_1_1transport_1_1Null__peer.html" title="Dummy type for use as a template param to Channel when either the blobs pipe or handles pipe is disab...">Null_peer</a>&gt;</code>. <br /></td></tr>
<tr class="separator:ab620c31d21118f85736b6a503fea9808"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-methods" name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:ae7f2b8a45af59c073fa91f74be0439d8"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classipc_1_1transport_1_1Channel.html#ae7f2b8a45af59c073fa91f74be0439d8">Channel</a> ()</td></tr>
<tr class="memdesc:ae7f2b8a45af59c073fa91f74be0439d8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Default ctor (<a class="el" href="classipc_1_1transport_1_1Channel.html" title="Peer to a bundle of 1-2 full-duplex pipe(s), one for transmitting unstructured binary blobs; the othe...">Channel</a> is in ??? state; intended to be move-assigned).  <a href="classipc_1_1transport_1_1Channel.html#ae7f2b8a45af59c073fa91f74be0439d8">More...</a><br /></td></tr>
<tr class="separator:ae7f2b8a45af59c073fa91f74be0439d8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab961f45ec4416bfa010df7b9a6e4f40a"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classipc_1_1transport_1_1Channel.html#ab961f45ec4416bfa010df7b9a6e4f40a">Channel</a> (flow::log::Logger *logger_ptr, <a class="el" href="namespaceipc_1_1util.html#ae6ac47812a90d1287c61e0b7de7bc4f5">util::String_view</a> nickname_str)</td></tr>
<tr class="memdesc:ab961f45ec4416bfa010df7b9a6e4f40a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructs <a class="el" href="classipc_1_1transport_1_1Channel.html" title="Peer to a bundle of 1-2 full-duplex pipe(s), one for transmitting unstructured binary blobs; the othe...">Channel</a> in ??? state with the intention to continue initialization via <a class="el" href="classipc_1_1transport_1_1Channel.html#aa8209a5adde4e5c2b3b1d8779fab0433" title="Completes initialization of the blobs pipe by taking ownership (via move semantics) of an object that...">init_blob_pipe()</a> and/or <a class="el" href="classipc_1_1transport_1_1Channel.html#a0e0e396759dab8c0930594eac3bb03ba" title="Analogous to 1-arg init_blob_pipe() but as applied to the handles pipe.">init_native_handle_pipe()</a> call(s).  <a href="classipc_1_1transport_1_1Channel.html#ab961f45ec4416bfa010df7b9a6e4f40a">More...</a><br /></td></tr>
<tr class="separator:ab961f45ec4416bfa010df7b9a6e4f40a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6fd5dc48222a3cf3eb021fee13c50ea5"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classipc_1_1transport_1_1Channel.html#a6fd5dc48222a3cf3eb021fee13c50ea5">Channel</a> (<a class="el" href="classipc_1_1transport_1_1Channel.html">Channel</a> &amp;&amp;src)</td></tr>
<tr class="memdesc:a6fd5dc48222a3cf3eb021fee13c50ea5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Move-constructs from <code>src</code>; <code>src</code> becomes as-if default-cted (therefore in ??? state).  <a href="classipc_1_1transport_1_1Channel.html#a6fd5dc48222a3cf3eb021fee13c50ea5">More...</a><br /></td></tr>
<tr class="separator:a6fd5dc48222a3cf3eb021fee13c50ea5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a798f520982555961dbd5a6176d8d4f0b"><td class="memItemLeft" align="right" valign="top"><a id="a798f520982555961dbd5a6176d8d4f0b" name="a798f520982555961dbd5a6176d8d4f0b"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>Channel</b> (const <a class="el" href="classipc_1_1transport_1_1Channel.html">Channel</a> &amp;)=delete</td></tr>
<tr class="memdesc:a798f520982555961dbd5a6176d8d4f0b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy construction is disallowed. <br /></td></tr>
<tr class="separator:a798f520982555961dbd5a6176d8d4f0b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a10d97e67296614195f8b14599944dd65"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classipc_1_1transport_1_1Channel.html#a10d97e67296614195f8b14599944dd65">~Channel</a> ()</td></tr>
<tr class="memdesc:a10d97e67296614195f8b14599944dd65"><td class="mdescLeft">&#160;</td><td class="mdescRight">Destructor: synchronously invokes the destructors for each peer object moved-into <code>*this</code> via <a class="el" href="classipc_1_1transport_1_1Channel.html#aa8209a5adde4e5c2b3b1d8779fab0433" title="Completes initialization of the blobs pipe by taking ownership (via move semantics) of an object that...">init_blob_pipe()</a> and/or <a class="el" href="classipc_1_1transport_1_1Channel.html#a0e0e396759dab8c0930594eac3bb03ba" title="Analogous to 1-arg init_blob_pipe() but as applied to the handles pipe.">init_native_handle_pipe()</a>.  <a href="classipc_1_1transport_1_1Channel.html#a10d97e67296614195f8b14599944dd65">More...</a><br /></td></tr>
<tr class="separator:a10d97e67296614195f8b14599944dd65"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a43c79955b3ad0eab347550b4263523ec"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classipc_1_1transport_1_1Channel.html#a43c79955b3ad0eab347550b4263523ec">initialized</a> (bool suppress_log=false) const</td></tr>
<tr class="memdesc:a43c79955b3ad0eab347550b4263523ec"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns <code>true</code> if and only if the required <a class="el" href="classipc_1_1transport_1_1Channel.html#aa8209a5adde4e5c2b3b1d8779fab0433" title="Completes initialization of the blobs pipe by taking ownership (via move semantics) of an object that...">init_blob_pipe()</a> and <a class="el" href="classipc_1_1transport_1_1Channel.html#a0e0e396759dab8c0930594eac3bb03ba" title="Analogous to 1-arg init_blob_pipe() but as applied to the handles pipe.">init_native_handle_pipe()</a> calls have been made, loading exactly the expected peer objects as the template params <a class="el" href="classipc_1_1transport_1_1Channel.html#a82746276cc7379a866b12d529780900f" title="Alias for Blob_sender template parameter.">Blob_sender_obj</a>, <a class="el" href="classipc_1_1transport_1_1Channel.html#aa9a7ec2d2eedfc3b6a1d2edfb05ea6d1" title="Alias for Blob_receiver template parameter.">Blob_receiver_obj</a>, <a class="el" href="classipc_1_1transport_1_1Channel.html#afc600491e137c9dc16c202b04885a36a" title="Alias for Native_handle_sender template parameter.">Native_handle_sender_obj</a>, <a class="el" href="classipc_1_1transport_1_1Channel.html#ad011bfbcfc226b9a32d97188485d9a22" title="Alias for Native_handle_receiver template parameter.">Native_handle_receiver_obj</a> specify.  <a href="classipc_1_1transport_1_1Channel.html#a43c79955b3ad0eab347550b4263523ec">More...</a><br /></td></tr>
<tr class="separator:a43c79955b3ad0eab347550b4263523ec"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8f60506c8b6f4165a04626c524cb4022"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classipc_1_1transport_1_1Channel.html">Channel</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classipc_1_1transport_1_1Channel.html#a8f60506c8b6f4165a04626c524cb4022">operator=</a> (<a class="el" href="classipc_1_1transport_1_1Channel.html">Channel</a> &amp;&amp;src)</td></tr>
<tr class="memdesc:a8f60506c8b6f4165a04626c524cb4022"><td class="mdescLeft">&#160;</td><td class="mdescRight">Move-assigns from <code>src</code>; <code>*this</code> acts as if destructed; <code>src</code> becomes as-if default-cted (therefore in ??? state).  <a href="classipc_1_1transport_1_1Channel.html#a8f60506c8b6f4165a04626c524cb4022">More...</a><br /></td></tr>
<tr class="separator:a8f60506c8b6f4165a04626c524cb4022"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a17af68c92d593c5eb82bbab19156352a"><td class="memItemLeft" align="right" valign="top"><a id="a17af68c92d593c5eb82bbab19156352a" name="a17af68c92d593c5eb82bbab19156352a"></a>
<a class="el" href="classipc_1_1transport_1_1Channel.html">Channel</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>operator=</b> (const <a class="el" href="classipc_1_1transport_1_1Channel.html">Channel</a> &amp;)=delete</td></tr>
<tr class="memdesc:a17af68c92d593c5eb82bbab19156352a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy assignment is disallowed. <br /></td></tr>
<tr class="separator:a17af68c92d593c5eb82bbab19156352a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:add016cbac936d3da6c861755ac88b7a2"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classipc_1_1transport_1_1Channel.html#ab6f7d14037e228e24a8fbd33b41e1c82">Async_io_obj</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classipc_1_1transport_1_1Channel.html#add016cbac936d3da6c861755ac88b7a2">async_io_obj</a> ()</td></tr>
<tr class="memdesc:add016cbac936d3da6c861755ac88b7a2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Converts a <code><a class="el" href="namespaceipc_1_1transport_1_1sync__io.html" title="sync_io-pattern counterparts to async-I/O-pattern object types in parent namespace ipc::transport.">sync_io</a></code>-peer-bearing <code>*this</code> to a returned async-I/O-peer-bearing new <a class="el" href="classipc_1_1transport_1_1Channel.html" title="Peer to a bundle of 1-2 full-duplex pipe(s), one for transmitting unstructured binary blobs; the othe...">Channel</a>, while <code>*this</code> becomes as-if default-cted.  <a href="classipc_1_1transport_1_1Channel.html#add016cbac936d3da6c861755ac88b7a2">More...</a><br /></td></tr>
<tr class="separator:add016cbac936d3da6c861755ac88b7a2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9e1a2db827082d9467bf45ae0bbf64d3"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classipc_1_1transport_1_1Channel.html#a82746276cc7379a866b12d529780900f">Blob_sender_obj</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classipc_1_1transport_1_1Channel.html#a9e1a2db827082d9467bf45ae0bbf64d3">blob_snd</a> () const</td></tr>
<tr class="memdesc:a9e1a2db827082d9467bf45ae0bbf64d3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Pointer to the immutable owned <a class="el" href="classipc_1_1transport_1_1Channel.html#a82746276cc7379a866b12d529780900f" title="Alias for Blob_sender template parameter.">Blob_sender_obj</a>; null if yet initialized.  <a href="classipc_1_1transport_1_1Channel.html#a9e1a2db827082d9467bf45ae0bbf64d3">More...</a><br /></td></tr>
<tr class="separator:a9e1a2db827082d9467bf45ae0bbf64d3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5a34248f5e11a1dd2d5a52e07ae836e7"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classipc_1_1transport_1_1Channel.html#aa9a7ec2d2eedfc3b6a1d2edfb05ea6d1">Blob_receiver_obj</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classipc_1_1transport_1_1Channel.html#a5a34248f5e11a1dd2d5a52e07ae836e7">blob_rcv</a> () const</td></tr>
<tr class="memdesc:a5a34248f5e11a1dd2d5a52e07ae836e7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Pointer to the immutable owned <a class="el" href="classipc_1_1transport_1_1Channel.html#aa9a7ec2d2eedfc3b6a1d2edfb05ea6d1" title="Alias for Blob_receiver template parameter.">Blob_receiver_obj</a>; null if not yet initialized.  <a href="classipc_1_1transport_1_1Channel.html#a5a34248f5e11a1dd2d5a52e07ae836e7">More...</a><br /></td></tr>
<tr class="separator:a5a34248f5e11a1dd2d5a52e07ae836e7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a970d77e3a5ac117d9b60dfddbf0914fe"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classipc_1_1transport_1_1Channel.html#afc600491e137c9dc16c202b04885a36a">Native_handle_sender_obj</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classipc_1_1transport_1_1Channel.html#a970d77e3a5ac117d9b60dfddbf0914fe">hndl_snd</a> () const</td></tr>
<tr class="memdesc:a970d77e3a5ac117d9b60dfddbf0914fe"><td class="mdescLeft">&#160;</td><td class="mdescRight">Pointer to the immutable owned <a class="el" href="classipc_1_1transport_1_1Channel.html#afc600491e137c9dc16c202b04885a36a" title="Alias for Native_handle_sender template parameter.">Native_handle_sender_obj</a>; null if not yet initialized.  <a href="classipc_1_1transport_1_1Channel.html#a970d77e3a5ac117d9b60dfddbf0914fe">More...</a><br /></td></tr>
<tr class="separator:a970d77e3a5ac117d9b60dfddbf0914fe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a387590af263932dbdb24bcac4b399170"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classipc_1_1transport_1_1Channel.html#ad011bfbcfc226b9a32d97188485d9a22">Native_handle_receiver_obj</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classipc_1_1transport_1_1Channel.html#a387590af263932dbdb24bcac4b399170">hndl_rcv</a> () const</td></tr>
<tr class="memdesc:a387590af263932dbdb24bcac4b399170"><td class="mdescLeft">&#160;</td><td class="mdescRight">Pointer to the immutable owned <a class="el" href="classipc_1_1transport_1_1Channel.html#ad011bfbcfc226b9a32d97188485d9a22" title="Alias for Native_handle_receiver template parameter.">Native_handle_receiver_obj</a>; null if not yet initialized.  <a href="classipc_1_1transport_1_1Channel.html#a387590af263932dbdb24bcac4b399170">More...</a><br /></td></tr>
<tr class="separator:a387590af263932dbdb24bcac4b399170"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a647bc9b6f8b9fb0b546cf3879cb5d4c1"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classipc_1_1transport_1_1Channel.html#a82746276cc7379a866b12d529780900f">Blob_sender_obj</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classipc_1_1transport_1_1Channel.html#a647bc9b6f8b9fb0b546cf3879cb5d4c1">blob_snd</a> ()</td></tr>
<tr class="memdesc:a647bc9b6f8b9fb0b546cf3879cb5d4c1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Pointer to the mutable owned <a class="el" href="classipc_1_1transport_1_1Channel.html#a82746276cc7379a866b12d529780900f" title="Alias for Blob_sender template parameter.">Blob_sender_obj</a>; null if yet initialized.  <a href="classipc_1_1transport_1_1Channel.html#a647bc9b6f8b9fb0b546cf3879cb5d4c1">More...</a><br /></td></tr>
<tr class="separator:a647bc9b6f8b9fb0b546cf3879cb5d4c1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a87fd94fa483cabd78059a3d1d094880d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classipc_1_1transport_1_1Channel.html#aa9a7ec2d2eedfc3b6a1d2edfb05ea6d1">Blob_receiver_obj</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classipc_1_1transport_1_1Channel.html#a87fd94fa483cabd78059a3d1d094880d">blob_rcv</a> ()</td></tr>
<tr class="memdesc:a87fd94fa483cabd78059a3d1d094880d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Pointer to the mutable owned <a class="el" href="classipc_1_1transport_1_1Channel.html#aa9a7ec2d2eedfc3b6a1d2edfb05ea6d1" title="Alias for Blob_receiver template parameter.">Blob_receiver_obj</a>; null if not yet initialized.  <a href="classipc_1_1transport_1_1Channel.html#a87fd94fa483cabd78059a3d1d094880d">More...</a><br /></td></tr>
<tr class="separator:a87fd94fa483cabd78059a3d1d094880d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa838026c33e4e422df7cd78d3a426b6a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classipc_1_1transport_1_1Channel.html#afc600491e137c9dc16c202b04885a36a">Native_handle_sender_obj</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classipc_1_1transport_1_1Channel.html#aa838026c33e4e422df7cd78d3a426b6a">hndl_snd</a> ()</td></tr>
<tr class="memdesc:aa838026c33e4e422df7cd78d3a426b6a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Pointer to the mutable owned <a class="el" href="classipc_1_1transport_1_1Channel.html#afc600491e137c9dc16c202b04885a36a" title="Alias for Native_handle_sender template parameter.">Native_handle_sender_obj</a>; null if not yet initialized.  <a href="classipc_1_1transport_1_1Channel.html#aa838026c33e4e422df7cd78d3a426b6a">More...</a><br /></td></tr>
<tr class="separator:aa838026c33e4e422df7cd78d3a426b6a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af4c9cd7b02193fa2e8bf1742ab87111a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classipc_1_1transport_1_1Channel.html#ad011bfbcfc226b9a32d97188485d9a22">Native_handle_receiver_obj</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classipc_1_1transport_1_1Channel.html#af4c9cd7b02193fa2e8bf1742ab87111a">hndl_rcv</a> ()</td></tr>
<tr class="memdesc:af4c9cd7b02193fa2e8bf1742ab87111a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Pointer to the mutable owned <a class="el" href="classipc_1_1transport_1_1Channel.html#ad011bfbcfc226b9a32d97188485d9a22" title="Alias for Native_handle_receiver template parameter.">Native_handle_receiver_obj</a>; null if not yet initialized.  <a href="classipc_1_1transport_1_1Channel.html#af4c9cd7b02193fa2e8bf1742ab87111a">More...</a><br /></td></tr>
<tr class="separator:af4c9cd7b02193fa2e8bf1742ab87111a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa8209a5adde4e5c2b3b1d8779fab0433"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classipc_1_1transport_1_1Channel.html#aa8209a5adde4e5c2b3b1d8779fab0433">init_blob_pipe</a> (<a class="el" href="classipc_1_1transport_1_1Channel.html#a82746276cc7379a866b12d529780900f">Blob_sender_obj</a> &amp;&amp;snd_and_rcv)</td></tr>
<tr class="memdesc:aa8209a5adde4e5c2b3b1d8779fab0433"><td class="mdescLeft">&#160;</td><td class="mdescRight">Completes initialization of the <em>blobs pipe</em> by taking ownership (via move semantics) of an object that is simultaneously the <a class="el" href="classipc_1_1transport_1_1Channel.html#a82746276cc7379a866b12d529780900f" title="Alias for Blob_sender template parameter.">Blob_sender_obj</a> and <a class="el" href="classipc_1_1transport_1_1Channel.html#aa9a7ec2d2eedfc3b6a1d2edfb05ea6d1" title="Alias for Blob_receiver template parameter.">Blob_receiver_obj</a> for our end of the blobs pipe.  <a href="classipc_1_1transport_1_1Channel.html#aa8209a5adde4e5c2b3b1d8779fab0433">More...</a><br /></td></tr>
<tr class="separator:aa8209a5adde4e5c2b3b1d8779fab0433"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abc969fa7785f5acda19a0c08bfeeb7e9"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classipc_1_1transport_1_1Channel.html#abc969fa7785f5acda19a0c08bfeeb7e9">init_blob_pipe</a> (<a class="el" href="classipc_1_1transport_1_1Channel.html#a82746276cc7379a866b12d529780900f">Blob_sender_obj</a> &amp;&amp;snd, <a class="el" href="classipc_1_1transport_1_1Channel.html#aa9a7ec2d2eedfc3b6a1d2edfb05ea6d1">Blob_receiver_obj</a> &amp;&amp;rcv)</td></tr>
<tr class="memdesc:abc969fa7785f5acda19a0c08bfeeb7e9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Completes initialization of the <em>blobs pipe</em> by taking ownership (via move semantics) of separate <a class="el" href="classipc_1_1transport_1_1Channel.html#a82746276cc7379a866b12d529780900f" title="Alias for Blob_sender template parameter.">Blob_sender_obj</a> and <a class="el" href="classipc_1_1transport_1_1Channel.html#aa9a7ec2d2eedfc3b6a1d2edfb05ea6d1" title="Alias for Blob_receiver template parameter.">Blob_receiver_obj</a> objects for our end of the blobs pipe.  <a href="classipc_1_1transport_1_1Channel.html#abc969fa7785f5acda19a0c08bfeeb7e9">More...</a><br /></td></tr>
<tr class="separator:abc969fa7785f5acda19a0c08bfeeb7e9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0e0e396759dab8c0930594eac3bb03ba"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classipc_1_1transport_1_1Channel.html#a0e0e396759dab8c0930594eac3bb03ba">init_native_handle_pipe</a> (<a class="el" href="classipc_1_1transport_1_1Channel.html#afc600491e137c9dc16c202b04885a36a">Native_handle_sender_obj</a> &amp;&amp;snd_and_rcv)</td></tr>
<tr class="memdesc:a0e0e396759dab8c0930594eac3bb03ba"><td class="mdescLeft">&#160;</td><td class="mdescRight">Analogous to 1-arg <a class="el" href="classipc_1_1transport_1_1Channel.html#aa8209a5adde4e5c2b3b1d8779fab0433" title="Completes initialization of the blobs pipe by taking ownership (via move semantics) of an object that...">init_blob_pipe()</a> but as applied to the <em>handles pipe</em>.  <a href="classipc_1_1transport_1_1Channel.html#a0e0e396759dab8c0930594eac3bb03ba">More...</a><br /></td></tr>
<tr class="separator:a0e0e396759dab8c0930594eac3bb03ba"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afa221b9b60aa9de1aa8dfcb0c1cabec1"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classipc_1_1transport_1_1Channel.html#afa221b9b60aa9de1aa8dfcb0c1cabec1">init_native_handle_pipe</a> (<a class="el" href="classipc_1_1transport_1_1Channel.html#afc600491e137c9dc16c202b04885a36a">Native_handle_sender_obj</a> &amp;&amp;snd, <a class="el" href="classipc_1_1transport_1_1Channel.html#ad011bfbcfc226b9a32d97188485d9a22">Native_handle_receiver_obj</a> &amp;&amp;rcv)</td></tr>
<tr class="memdesc:afa221b9b60aa9de1aa8dfcb0c1cabec1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Analogous to 2-arg <a class="el" href="classipc_1_1transport_1_1Channel.html#aa8209a5adde4e5c2b3b1d8779fab0433" title="Completes initialization of the blobs pipe by taking ownership (via move semantics) of an object that...">init_blob_pipe()</a> but as applied to the <em>handles pipe</em>.  <a href="classipc_1_1transport_1_1Channel.html#afa221b9b60aa9de1aa8dfcb0c1cabec1">More...</a><br /></td></tr>
<tr class="separator:afa221b9b60aa9de1aa8dfcb0c1cabec1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab62f46ceaf85baac6820415808c3a2f2"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classipc_1_1transport_1_1Channel.html#ab62f46ceaf85baac6820415808c3a2f2">send_blob_max_size</a> () const</td></tr>
<tr class="memdesc:ab62f46ceaf85baac6820415808c3a2f2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Yields <code><a class="el" href="classipc_1_1transport_1_1Channel.html#a647bc9b6f8b9fb0b546cf3879cb5d4c1" title="Pointer to the mutable owned Blob_sender_obj; null if yet initialized.">blob_snd()</a>-&gt;</code> same method.  <a href="classipc_1_1transport_1_1Channel.html#ab62f46ceaf85baac6820415808c3a2f2">More...</a><br /></td></tr>
<tr class="separator:ab62f46ceaf85baac6820415808c3a2f2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a37e1f03a11d1e1df9148048a8a6bab62"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classipc_1_1transport_1_1Channel.html#a37e1f03a11d1e1df9148048a8a6bab62">send_meta_blob_max_size</a> () const</td></tr>
<tr class="memdesc:a37e1f03a11d1e1df9148048a8a6bab62"><td class="mdescLeft">&#160;</td><td class="mdescRight">Yields <code><a class="el" href="classipc_1_1transport_1_1Channel.html#aa838026c33e4e422df7cd78d3a426b6a" title="Pointer to the mutable owned Native_handle_sender_obj; null if not yet initialized.">hndl_snd()</a>-&gt;</code> same method.  <a href="classipc_1_1transport_1_1Channel.html#a37e1f03a11d1e1df9148048a8a6bab62">More...</a><br /></td></tr>
<tr class="separator:a37e1f03a11d1e1df9148048a8a6bab62"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5e181ca69bd2b38d0e3585a1d9303318"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classipc_1_1transport_1_1Channel.html#a5e181ca69bd2b38d0e3585a1d9303318">receive_blob_max_size</a> () const</td></tr>
<tr class="memdesc:a5e181ca69bd2b38d0e3585a1d9303318"><td class="mdescLeft">&#160;</td><td class="mdescRight">Yields <code><a class="el" href="classipc_1_1transport_1_1Channel.html#a87fd94fa483cabd78059a3d1d094880d" title="Pointer to the mutable owned Blob_receiver_obj; null if not yet initialized.">blob_rcv()</a>-&gt;</code> same method.  <a href="classipc_1_1transport_1_1Channel.html#a5e181ca69bd2b38d0e3585a1d9303318">More...</a><br /></td></tr>
<tr class="separator:a5e181ca69bd2b38d0e3585a1d9303318"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afd9589e9bee2aec1574ab534cf4b3782"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classipc_1_1transport_1_1Channel.html#afd9589e9bee2aec1574ab534cf4b3782">receive_meta_blob_max_size</a> () const</td></tr>
<tr class="memdesc:afd9589e9bee2aec1574ab534cf4b3782"><td class="mdescLeft">&#160;</td><td class="mdescRight">Yields <code><a class="el" href="classipc_1_1transport_1_1Channel.html#af4c9cd7b02193fa2e8bf1742ab87111a" title="Pointer to the mutable owned Native_handle_receiver_obj; null if not yet initialized.">hndl_rcv()</a>-&gt;</code> same method.  <a href="classipc_1_1transport_1_1Channel.html#afd9589e9bee2aec1574ab534cf4b3782">More...</a><br /></td></tr>
<tr class="separator:afd9589e9bee2aec1574ab534cf4b3782"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac6a506269ad02031f434a21eff4ca6ba"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classipc_1_1transport_1_1Channel.html#ac6a506269ad02031f434a21eff4ca6ba">send_blob</a> (const <a class="el" href="namespaceipc_1_1util.html#ae0be7edba7e30ffa3f8b742af621f2ab">util::Blob_const</a> &amp;blob, <a class="el" href="namespaceipc.html#aa3192e586cc45d3e7c22463bf2760f89">Error_code</a> *err_code)</td></tr>
<tr class="memdesc:ac6a506269ad02031f434a21eff4ca6ba"><td class="mdescLeft">&#160;</td><td class="mdescRight">Yields <code><a class="el" href="classipc_1_1transport_1_1Channel.html#a647bc9b6f8b9fb0b546cf3879cb5d4c1" title="Pointer to the mutable owned Blob_sender_obj; null if yet initialized.">blob_snd()</a>-&gt;</code> same method.  <a href="classipc_1_1transport_1_1Channel.html#ac6a506269ad02031f434a21eff4ca6ba">More...</a><br /></td></tr>
<tr class="separator:ac6a506269ad02031f434a21eff4ca6ba"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9bd6a744b8decdc872357fcea33897af"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classipc_1_1transport_1_1Channel.html#a9bd6a744b8decdc872357fcea33897af">send_native_handle</a> (<a class="el" href="namespaceipc_1_1transport.html#a7ee4551983d9df16ec16a3139bac50e8">Native_handle</a> hndl_or_null, const <a class="el" href="namespaceipc_1_1util.html#ae0be7edba7e30ffa3f8b742af621f2ab">util::Blob_const</a> &amp;meta_blob, <a class="el" href="namespaceipc.html#aa3192e586cc45d3e7c22463bf2760f89">Error_code</a> *err_code)</td></tr>
<tr class="memdesc:a9bd6a744b8decdc872357fcea33897af"><td class="mdescLeft">&#160;</td><td class="mdescRight">Yields <code><a class="el" href="classipc_1_1transport_1_1Channel.html#aa838026c33e4e422df7cd78d3a426b6a" title="Pointer to the mutable owned Native_handle_sender_obj; null if not yet initialized.">hndl_snd()</a>-&gt;</code> same method.  <a href="classipc_1_1transport_1_1Channel.html#a9bd6a744b8decdc872357fcea33897af">More...</a><br /></td></tr>
<tr class="separator:a9bd6a744b8decdc872357fcea33897af"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a37fcdfdbefd8ee7e374b0596782ad128"><td class="memTemplParams" colspan="2">template&lt;typename Task_err &gt; </td></tr>
<tr class="memitem:a37fcdfdbefd8ee7e374b0596782ad128"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classipc_1_1transport_1_1Channel.html#a37fcdfdbefd8ee7e374b0596782ad128">async_end_sending</a> (Task_err &amp;&amp;on_done_func)</td></tr>
<tr class="memdesc:a37fcdfdbefd8ee7e374b0596782ad128"><td class="mdescLeft">&#160;</td><td class="mdescRight">Performs <code><a class="el" href="classipc_1_1transport_1_1Channel.html#aa838026c33e4e422df7cd78d3a426b6a" title="Pointer to the mutable owned Native_handle_sender_obj; null if not yet initialized.">hndl_snd()</a>-&gt;</code> and/or <code><a class="el" href="classipc_1_1transport_1_1Channel.html#a647bc9b6f8b9fb0b546cf3879cb5d4c1" title="Pointer to the mutable owned Blob_sender_obj; null if yet initialized.">blob_snd()</a>-&gt;</code> same method, synthesizing completion handlers into one if applicable.  <a href="classipc_1_1transport_1_1Channel.html#a37fcdfdbefd8ee7e374b0596782ad128">More...</a><br /></td></tr>
<tr class="separator:a37fcdfdbefd8ee7e374b0596782ad128"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a53cbf199e2ed09b7afb216c96ab63fb0"><td class="memTemplParams" colspan="2">template&lt;typename Task_err &gt; </td></tr>
<tr class="memitem:a53cbf199e2ed09b7afb216c96ab63fb0"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classipc_1_1transport_1_1Channel.html#a53cbf199e2ed09b7afb216c96ab63fb0">async_end_sending</a> (<a class="el" href="namespaceipc.html#aa3192e586cc45d3e7c22463bf2760f89">Error_code</a> *sync_err_code, Task_err &amp;&amp;on_done_func)</td></tr>
<tr class="memdesc:a53cbf199e2ed09b7afb216c96ab63fb0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Performs <code><a class="el" href="classipc_1_1transport_1_1Channel.html#aa838026c33e4e422df7cd78d3a426b6a" title="Pointer to the mutable owned Native_handle_sender_obj; null if not yet initialized.">hndl_snd()</a>-&gt;</code> and/or <code><a class="el" href="classipc_1_1transport_1_1Channel.html#a647bc9b6f8b9fb0b546cf3879cb5d4c1" title="Pointer to the mutable owned Blob_sender_obj; null if yet initialized.">blob_snd()</a>-&gt;</code> same method, synthesizing completions into one if applicable.  <a href="classipc_1_1transport_1_1Channel.html#a53cbf199e2ed09b7afb216c96ab63fb0">More...</a><br /></td></tr>
<tr class="separator:a53cbf199e2ed09b7afb216c96ab63fb0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a060e37759dc6f0a00d92fc23a0a09f4f"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classipc_1_1transport_1_1Channel.html#a060e37759dc6f0a00d92fc23a0a09f4f">end_sending</a> ()</td></tr>
<tr class="memdesc:a060e37759dc6f0a00d92fc23a0a09f4f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Performs <code><a class="el" href="classipc_1_1transport_1_1Channel.html#aa838026c33e4e422df7cd78d3a426b6a" title="Pointer to the mutable owned Native_handle_sender_obj; null if not yet initialized.">hndl_snd()</a>-&gt;</code> and/or <code><a class="el" href="classipc_1_1transport_1_1Channel.html#a647bc9b6f8b9fb0b546cf3879cb5d4c1" title="Pointer to the mutable owned Blob_sender_obj; null if yet initialized.">blob_snd()</a>-&gt;</code> same method, returning <code>true</code> if all (1-2) invoked methods returned <code>true</code>; <code>false</code> conversely.  <a href="classipc_1_1transport_1_1Channel.html#a060e37759dc6f0a00d92fc23a0a09f4f">More...</a><br /></td></tr>
<tr class="separator:a060e37759dc6f0a00d92fc23a0a09f4f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a290395d720167759bfa1eda1e86bf123"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classipc_1_1transport_1_1Channel.html#a290395d720167759bfa1eda1e86bf123">auto_ping</a> (<a class="el" href="namespaceipc_1_1util.html#ac66141280c3b7295a86b65209f31cc58">util::Fine_duration</a> period=boost::chrono::seconds(2))</td></tr>
<tr class="memdesc:a290395d720167759bfa1eda1e86bf123"><td class="mdescLeft">&#160;</td><td class="mdescRight">Performs <code><a class="el" href="classipc_1_1transport_1_1Channel.html#aa838026c33e4e422df7cd78d3a426b6a" title="Pointer to the mutable owned Native_handle_sender_obj; null if not yet initialized.">hndl_snd()</a>-&gt;</code> and/or <code><a class="el" href="classipc_1_1transport_1_1Channel.html#a647bc9b6f8b9fb0b546cf3879cb5d4c1" title="Pointer to the mutable owned Blob_sender_obj; null if yet initialized.">blob_snd()</a>-&gt;</code> same method, returning <code>true</code> if all (1-2) invoked methods returned <code>true</code>; <code>false</code> conversely.  <a href="classipc_1_1transport_1_1Channel.html#a290395d720167759bfa1eda1e86bf123">More...</a><br /></td></tr>
<tr class="separator:a290395d720167759bfa1eda1e86bf123"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1e6d2b4ec45f629b731fe30f46aeca97"><td class="memTemplParams" colspan="2">template&lt;typename... Args&gt; </td></tr>
<tr class="memitem:a1e6d2b4ec45f629b731fe30f46aeca97"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classipc_1_1transport_1_1Channel.html#a1e6d2b4ec45f629b731fe30f46aeca97">async_receive_blob</a> (Args &amp;&amp;... args)</td></tr>
<tr class="memdesc:a1e6d2b4ec45f629b731fe30f46aeca97"><td class="mdescLeft">&#160;</td><td class="mdescRight">Yields <code><a class="el" href="classipc_1_1transport_1_1Channel.html#a87fd94fa483cabd78059a3d1d094880d" title="Pointer to the mutable owned Blob_receiver_obj; null if not yet initialized.">blob_rcv()</a>-&gt;</code> same method.  <a href="classipc_1_1transport_1_1Channel.html#a1e6d2b4ec45f629b731fe30f46aeca97">More...</a><br /></td></tr>
<tr class="separator:a1e6d2b4ec45f629b731fe30f46aeca97"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a288e61b4e19b9621f4f978fab88bcab0"><td class="memTemplParams" colspan="2">template&lt;typename... Args&gt; </td></tr>
<tr class="memitem:a288e61b4e19b9621f4f978fab88bcab0"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classipc_1_1transport_1_1Channel.html#a288e61b4e19b9621f4f978fab88bcab0">async_receive_native_handle</a> (Args &amp;&amp;... args)</td></tr>
<tr class="memdesc:a288e61b4e19b9621f4f978fab88bcab0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Yields <code><a class="el" href="classipc_1_1transport_1_1Channel.html#af4c9cd7b02193fa2e8bf1742ab87111a" title="Pointer to the mutable owned Native_handle_receiver_obj; null if not yet initialized.">hndl_rcv()</a>-&gt;</code> same method.  <a href="classipc_1_1transport_1_1Channel.html#a288e61b4e19b9621f4f978fab88bcab0">More...</a><br /></td></tr>
<tr class="separator:a288e61b4e19b9621f4f978fab88bcab0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abf25364b49b9fdd3ba4b1541b3a50356"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classipc_1_1transport_1_1Channel.html#abf25364b49b9fdd3ba4b1541b3a50356">idle_timer_run</a> (<a class="el" href="namespaceipc_1_1util.html#ac66141280c3b7295a86b65209f31cc58">util::Fine_duration</a> timeout=boost::chrono::seconds(5))</td></tr>
<tr class="memdesc:abf25364b49b9fdd3ba4b1541b3a50356"><td class="mdescLeft">&#160;</td><td class="mdescRight">Performs <code><a class="el" href="classipc_1_1transport_1_1Channel.html#af4c9cd7b02193fa2e8bf1742ab87111a" title="Pointer to the mutable owned Native_handle_receiver_obj; null if not yet initialized.">hndl_rcv()</a>-&gt;</code> and/or <code><a class="el" href="classipc_1_1transport_1_1Channel.html#a87fd94fa483cabd78059a3d1d094880d" title="Pointer to the mutable owned Blob_receiver_obj; null if not yet initialized.">blob_rcv()</a>-&gt;</code> same method, returning <code>true</code> if all (1-2) invoked methods returned <code>true</code>; <code>false</code> conversely.  <a href="classipc_1_1transport_1_1Channel.html#abf25364b49b9fdd3ba4b1541b3a50356">More...</a><br /></td></tr>
<tr class="separator:abf25364b49b9fdd3ba4b1541b3a50356"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae63c4f7dbe1a1855d46a4b4d7009d5e8"><td class="memTemplParams" colspan="2">template&lt;typename Create_ev_wait_hndl_func &gt; </td></tr>
<tr class="memitem:ae63c4f7dbe1a1855d46a4b4d7009d5e8"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classipc_1_1transport_1_1Channel.html#ae63c4f7dbe1a1855d46a4b4d7009d5e8">replace_event_wait_handles</a> (const Create_ev_wait_hndl_func &amp;create_ev_wait_hndl_func)</td></tr>
<tr class="memdesc:ae63c4f7dbe1a1855d46a4b4d7009d5e8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Executes same method on all unique stored peer objects; returns <code>true</code> if and only if they all did.  <a href="classipc_1_1transport_1_1Channel.html#ae63c4f7dbe1a1855d46a4b4d7009d5e8">More...</a><br /></td></tr>
<tr class="separator:ae63c4f7dbe1a1855d46a4b4d7009d5e8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aabafc3beaf1a57e4767c023d9c4f9f93"><td class="memTemplParams" colspan="2">template&lt;typename Event_wait_func_t &gt; </td></tr>
<tr class="memitem:aabafc3beaf1a57e4767c023d9c4f9f93"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classipc_1_1transport_1_1Channel.html#aabafc3beaf1a57e4767c023d9c4f9f93">start_send_blob_ops</a> (Event_wait_func_t &amp;&amp;ev_wait_func)</td></tr>
<tr class="memdesc:aabafc3beaf1a57e4767c023d9c4f9f93"><td class="mdescLeft">&#160;</td><td class="mdescRight">Yields <code><a class="el" href="classipc_1_1transport_1_1Channel.html#a647bc9b6f8b9fb0b546cf3879cb5d4c1" title="Pointer to the mutable owned Blob_sender_obj; null if yet initialized.">blob_snd()</a>-&gt;</code> same method.  <a href="classipc_1_1transport_1_1Channel.html#aabafc3beaf1a57e4767c023d9c4f9f93">More...</a><br /></td></tr>
<tr class="separator:aabafc3beaf1a57e4767c023d9c4f9f93"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac2413ad0e4178fc321e71b5fe4ca2ce2"><td class="memTemplParams" colspan="2">template&lt;typename Event_wait_func_t &gt; </td></tr>
<tr class="memitem:ac2413ad0e4178fc321e71b5fe4ca2ce2"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classipc_1_1transport_1_1Channel.html#ac2413ad0e4178fc321e71b5fe4ca2ce2">start_send_native_handle_ops</a> (Event_wait_func_t &amp;&amp;ev_wait_func)</td></tr>
<tr class="memdesc:ac2413ad0e4178fc321e71b5fe4ca2ce2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Yields <code><a class="el" href="classipc_1_1transport_1_1Channel.html#aa838026c33e4e422df7cd78d3a426b6a" title="Pointer to the mutable owned Native_handle_sender_obj; null if not yet initialized.">hndl_snd()</a>-&gt;</code> same method.  <a href="classipc_1_1transport_1_1Channel.html#ac2413ad0e4178fc321e71b5fe4ca2ce2">More...</a><br /></td></tr>
<tr class="separator:ac2413ad0e4178fc321e71b5fe4ca2ce2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0b00c99196fbe8c154f14dbf8f0ceb79"><td class="memTemplParams" colspan="2">template&lt;typename Event_wait_func_t &gt; </td></tr>
<tr class="memitem:a0b00c99196fbe8c154f14dbf8f0ceb79"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classipc_1_1transport_1_1Channel.html#a0b00c99196fbe8c154f14dbf8f0ceb79">start_receive_blob_ops</a> (Event_wait_func_t &amp;&amp;ev_wait_func)</td></tr>
<tr class="memdesc:a0b00c99196fbe8c154f14dbf8f0ceb79"><td class="mdescLeft">&#160;</td><td class="mdescRight">Yields <code><a class="el" href="classipc_1_1transport_1_1Channel.html#a87fd94fa483cabd78059a3d1d094880d" title="Pointer to the mutable owned Blob_receiver_obj; null if not yet initialized.">blob_rcv()</a>-&gt;</code> same method.  <a href="classipc_1_1transport_1_1Channel.html#a0b00c99196fbe8c154f14dbf8f0ceb79">More...</a><br /></td></tr>
<tr class="separator:a0b00c99196fbe8c154f14dbf8f0ceb79"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a61f7ffbf72ee0fe46997ae08f9adaeb2"><td class="memTemplParams" colspan="2">template&lt;typename Event_wait_func_t &gt; </td></tr>
<tr class="memitem:a61f7ffbf72ee0fe46997ae08f9adaeb2"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classipc_1_1transport_1_1Channel.html#a61f7ffbf72ee0fe46997ae08f9adaeb2">start_receive_native_handle_ops</a> (Event_wait_func_t &amp;&amp;ev_wait_func)</td></tr>
<tr class="memdesc:a61f7ffbf72ee0fe46997ae08f9adaeb2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Yields <code><a class="el" href="classipc_1_1transport_1_1Channel.html#af4c9cd7b02193fa2e8bf1742ab87111a" title="Pointer to the mutable owned Native_handle_receiver_obj; null if not yet initialized.">hndl_rcv()</a>-&gt;</code> same method.  <a href="classipc_1_1transport_1_1Channel.html#a61f7ffbf72ee0fe46997ae08f9adaeb2">More...</a><br /></td></tr>
<tr class="separator:a61f7ffbf72ee0fe46997ae08f9adaeb2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a212c7e77daa038fc45dc118894e80af0"><td class="memItemLeft" align="right" valign="top">const std::string &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classipc_1_1transport_1_1Channel.html#a212c7e77daa038fc45dc118894e80af0">nickname</a> () const</td></tr>
<tr class="memdesc:a212c7e77daa038fc45dc118894e80af0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns nickname, a brief string suitable for logging.  <a href="classipc_1_1transport_1_1Channel.html#a212c7e77daa038fc45dc118894e80af0">More...</a><br /></td></tr>
<tr class="separator:a212c7e77daa038fc45dc118894e80af0"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-static-attribs" name="pub-static-attribs"></a>
Static Public Attributes</h2></td></tr>
<tr class="memitem:a85184d886cee9b4a0d0e7b67796a238b"><td class="memItemLeft" align="right" valign="top"><a id="a85184d886cee9b4a0d0e7b67796a238b" name="a85184d886cee9b4a0d0e7b67796a238b"></a>
static constexpr bool&#160;</td><td class="memItemRight" valign="bottom"><b>S_HAS_2_PIPES</b></td></tr>
<tr class="memdesc:a85184d886cee9b4a0d0e7b67796a238b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Useful for generic programming: <code>true</code> if and only if types imply both blobs and handles pipes are enabled. <br /></td></tr>
<tr class="separator:a85184d886cee9b4a0d0e7b67796a238b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a634da813ea03c07d8360a738eca002c4"><td class="memItemLeft" align="right" valign="top"><a id="a634da813ea03c07d8360a738eca002c4" name="a634da813ea03c07d8360a738eca002c4"></a>
static constexpr bool&#160;</td><td class="memItemRight" valign="bottom"><b>S_HAS_BLOB_PIPE_ONLY</b></td></tr>
<tr class="memdesc:a634da813ea03c07d8360a738eca002c4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Useful for generic programming: <code>true</code> if and only if types imply only the blobs pipe is enabled. <br /></td></tr>
<tr class="separator:a634da813ea03c07d8360a738eca002c4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a717bffc2086ccf834bc7a1137c1127eb"><td class="memItemLeft" align="right" valign="top"><a id="a717bffc2086ccf834bc7a1137c1127eb" name="a717bffc2086ccf834bc7a1137c1127eb"></a>
static constexpr bool&#160;</td><td class="memItemRight" valign="bottom"><b>S_HAS_NATIVE_HANDLE_PIPE_ONLY</b> = (!<a class="el" href="classipc_1_1transport_1_1Channel.html#a85184d886cee9b4a0d0e7b67796a238b">S_HAS_2_PIPES</a>) &amp;&amp; (!<a class="el" href="classipc_1_1transport_1_1Channel.html#a634da813ea03c07d8360a738eca002c4">S_HAS_BLOB_PIPE_ONLY</a>)</td></tr>
<tr class="memdesc:a717bffc2086ccf834bc7a1137c1127eb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Useful for generic programming: <code>true</code> if and only if types imply only the handles pipe is enabled. <br /></td></tr>
<tr class="separator:a717bffc2086ccf834bc7a1137c1127eb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aafb0767df5f1dfb535c9467ce717f93f"><td class="memItemLeft" align="right" valign="top"><a id="aafb0767df5f1dfb535c9467ce717f93f" name="aafb0767df5f1dfb535c9467ce717f93f"></a>
static constexpr bool&#160;</td><td class="memItemRight" valign="bottom"><b>S_HAS_BLOB_PIPE</b> = <a class="el" href="classipc_1_1transport_1_1Channel.html#a85184d886cee9b4a0d0e7b67796a238b">S_HAS_2_PIPES</a> || <a class="el" href="classipc_1_1transport_1_1Channel.html#a634da813ea03c07d8360a738eca002c4">S_HAS_BLOB_PIPE_ONLY</a></td></tr>
<tr class="memdesc:aafb0767df5f1dfb535c9467ce717f93f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Useful for generic programming: <code>true</code> if and only if types imply <em>at least</em> the blobs pipe is enabled. <br /></td></tr>
<tr class="separator:aafb0767df5f1dfb535c9467ce717f93f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab6decf2691a2cab6c3b5187bad1e368b"><td class="memItemLeft" align="right" valign="top"><a id="ab6decf2691a2cab6c3b5187bad1e368b" name="ab6decf2691a2cab6c3b5187bad1e368b"></a>
static constexpr bool&#160;</td><td class="memItemRight" valign="bottom"><b>S_HAS_NATIVE_HANDLE_PIPE</b> = <a class="el" href="classipc_1_1transport_1_1Channel.html#a85184d886cee9b4a0d0e7b67796a238b">S_HAS_2_PIPES</a> || <a class="el" href="classipc_1_1transport_1_1Channel.html#a717bffc2086ccf834bc7a1137c1127eb">S_HAS_NATIVE_HANDLE_PIPE_ONLY</a></td></tr>
<tr class="memdesc:ab6decf2691a2cab6c3b5187bad1e368b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Useful for generic programming: <code>true</code> if and only if types imply <em>at least</em> the handles pipe is enabled. <br /></td></tr>
<tr class="separator:ab6decf2691a2cab6c3b5187bad1e368b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae5be240d29389d7b728950e85df0704e"><td class="memItemLeft" align="right" valign="top"><a id="ae5be240d29389d7b728950e85df0704e" name="ae5be240d29389d7b728950e85df0704e"></a>
static constexpr bool&#160;</td><td class="memItemRight" valign="bottom"><b>S_IS_SYNC_IO_OBJ</b></td></tr>
<tr class="memdesc:ae5be240d29389d7b728950e85df0704e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Useful for generic programming: <code>true</code> &lt;=&gt; each non-<code><a class="el" href="classipc_1_1transport_1_1Null__peer.html" title="Dummy type for use as a template param to Channel when either the blobs pipe or handles pipe is disab...">Null_peer</a></code> peer type (<a class="el" href="classipc_1_1transport_1_1Channel.html#a82746276cc7379a866b12d529780900f" title="Alias for Blob_sender template parameter.">Blob_sender_obj</a>, <a class="el" href="classipc_1_1transport_1_1Channel.html#aa9a7ec2d2eedfc3b6a1d2edfb05ea6d1" title="Alias for Blob_receiver template parameter.">Blob_receiver_obj</a>, <a class="el" href="classipc_1_1transport_1_1Channel.html#afc600491e137c9dc16c202b04885a36a" title="Alias for Native_handle_sender template parameter.">Native_handle_sender_obj</a>, <a class="el" href="classipc_1_1transport_1_1Channel.html#ad011bfbcfc226b9a32d97188485d9a22" title="Alias for Native_handle_receiver template parameter.">Native_handle_receiver_obj</a>) implements the <code><a class="el" href="namespaceipc_1_1transport_1_1sync__io.html" title="sync_io-pattern counterparts to async-I/O-pattern object types in parent namespace ipc::transport.">sync_io</a></code> pattern (by convention living in namespace <a class="el" href="namespaceipc_1_1transport_1_1sync__io.html" title="sync_io-pattern counterparts to async-I/O-pattern object types in parent namespace ipc::transport.">ipc::transport::sync_io</a>). <br /></td></tr>
<tr class="separator:ae5be240d29389d7b728950e85df0704e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9f75b20b07eff47a69c2b1dbe5c85f84"><td class="memItemLeft" align="right" valign="top">static constexpr bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classipc_1_1transport_1_1Channel.html#a9f75b20b07eff47a69c2b1dbe5c85f84">S_IS_ASYNC_IO_OBJ</a> = !<a class="el" href="classipc_1_1transport_1_1Channel.html#ae5be240d29389d7b728950e85df0704e">S_IS_SYNC_IO_OBJ</a></td></tr>
<tr class="memdesc:a9f75b20b07eff47a69c2b1dbe5c85f84"><td class="mdescLeft">&#160;</td><td class="mdescRight">It equals the reverse of <a class="el" href="classipc_1_1transport_1_1Channel.html#ae5be240d29389d7b728950e85df0704e" title="Useful for generic programming: true &lt;=&gt; each non-Null_peer peer type (Blob_sender_obj,...">S_IS_SYNC_IO_OBJ</a>.  <a href="classipc_1_1transport_1_1Channel.html#a9f75b20b07eff47a69c2b1dbe5c85f84">More...</a><br /></td></tr>
<tr class="separator:a9f75b20b07eff47a69c2b1dbe5c85f84"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="related" name="related"></a>
Related Functions</h2></td></tr>
<tr><td class="ititle" colspan="2"><p >(Note that these are not member functions.) </p>
</td></tr>
<tr class="memitem:a8eff22e594b6fe82f94f13d6a172537f"><td class="memTemplParams" colspan="2">template&lt;typename <a class="el" href="classipc_1_1transport_1_1Blob__sender.html">Blob_sender</a> , typename <a class="el" href="classipc_1_1transport_1_1Blob__receiver.html">Blob_receiver</a> , typename <a class="el" href="classipc_1_1transport_1_1Native__handle__sender.html">Native_handle_sender</a> , typename <a class="el" href="classipc_1_1transport_1_1Native__handle__receiver.html">Native_handle_receiver</a> &gt; </td></tr>
<tr class="memitem:a8eff22e594b6fe82f94f13d6a172537f"><td class="memTemplItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classipc_1_1transport_1_1Channel.html#a8eff22e594b6fe82f94f13d6a172537f">operator&lt;&lt;</a> (std::ostream &amp;os, const <a class="el" href="classipc_1_1transport_1_1Channel.html">Channel</a>&lt; <a class="el" href="classipc_1_1transport_1_1Blob__sender.html">Blob_sender</a>, <a class="el" href="classipc_1_1transport_1_1Blob__receiver.html">Blob_receiver</a>, <a class="el" href="classipc_1_1transport_1_1Native__handle__sender.html">Native_handle_sender</a>, <a class="el" href="classipc_1_1transport_1_1Native__handle__receiver.html">Native_handle_receiver</a> &gt; &amp;val)</td></tr>
<tr class="memdesc:a8eff22e594b6fe82f94f13d6a172537f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Prints string representation of the given <code><a class="el" href="classipc_1_1transport_1_1Channel.html" title="Peer to a bundle of 1-2 full-duplex pipe(s), one for transmitting unstructured binary blobs; the othe...">Channel</a></code> to the given <code>ostream</code>.  <a href="classipc_1_1transport_1_1Channel.html#a8eff22e594b6fe82f94f13d6a172537f">More...</a><br /></td></tr>
<tr class="separator:a8eff22e594b6fe82f94f13d6a172537f"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><div class="compoundTemplParams">template&lt;typename <a class="el" href="classipc_1_1transport_1_1Blob__sender.html">Blob_sender</a>, typename <a class="el" href="classipc_1_1transport_1_1Blob__receiver.html">Blob_receiver</a>, typename <a class="el" href="classipc_1_1transport_1_1Native__handle__sender.html">Native_handle_sender</a>, typename <a class="el" href="classipc_1_1transport_1_1Native__handle__receiver.html">Native_handle_receiver</a>&gt;<br />
class ipc::transport::Channel&lt; Blob_sender, Blob_receiver, Native_handle_sender, Native_handle_receiver &gt;</div><p >Peer to a bundle of 1-2 full-duplex pipe(s), one for transmitting unstructured binary blobs; the other for transmitting native handle+blob combos; hence a <a class="el" href="classipc_1_1transport_1_1Blob__sender.html" title="A documentation-only concept defining the behavior of an object capable of reliably/in-order sending ...">Blob_sender</a> + <a class="el" href="classipc_1_1transport_1_1Blob__receiver.html" title="A documentation-only concept defining the behavior of an object capable of reliably/in-order receivin...">Blob_receiver</a>, a <a class="el" href="classipc_1_1transport_1_1Native__handle__sender.html" title="A documentation-only concept defining the behavior of an object capable of reliably/in-order sending ...">Native_handle_sender</a> + <a class="el" href="classipc_1_1transport_1_1Native__handle__receiver.html" title="A documentation-only concept defining the behavior of an object capable of reliably/in-order receivin...">Native_handle_receiver</a>, or both. </p>
<p >Generally a <a class="el" href="classipc_1_1session_1_1Session.html" title="A documentation-only concept defining the local side of an IPC conversation (session) with another en...">session::Session</a> shall be in charge of opening such <code><a class="el" href="classipc_1_1transport_1_1Channel.html" title="Peer to a bundle of 1-2 full-duplex pipe(s), one for transmitting unstructured binary blobs; the othe...">Channel</a></code>s between processes, while the user will likely wrap each <a class="el" href="classipc_1_1transport_1_1Channel.html" title="Peer to a bundle of 1-2 full-duplex pipe(s), one for transmitting unstructured binary blobs; the othe...">Channel</a> in a <a class="el" href="classipc_1_1transport_1_1struc_1_1Channel.html" title="Owning and wrapping a pre-connected transport::Channel peer (an endpoint of an established channel ov...">struc::Channel</a> in order to exchange structured (schema-based) messages, at times along with native sockets, through those <code><a class="el" href="classipc_1_1transport_1_1Channel.html" title="Peer to a bundle of 1-2 full-duplex pipe(s), one for transmitting unstructured binary blobs; the othe...">Channel</a></code>s. (However this is by no means required. One can use the <code><a class="el" href="classipc_1_1transport_1_1Channel.html" title="Peer to a bundle of 1-2 full-duplex pipe(s), one for transmitting unstructured binary blobs; the othe...">Channel</a></code> &ndash; whether bundling async-I/O peer objects or their <code><a class="el" href="namespaceipc_1_1transport_1_1sync__io.html" title="sync_io-pattern counterparts to async-I/O-pattern object types in parent namespace ipc::transport.">sync_io</a>::</code> counterparts &ndash; directly (in unstructured form) as well.)</p>
<h3>Main use: bundler of peer sender/receiver objects</h3>
<p >This bundling of the local peer objects of 1-2 pipes is the <a class="el" href="classipc_1_1transport_1_1Channel.html" title="Peer to a bundle of 1-2 full-duplex pipe(s), one for transmitting unstructured binary blobs; the othe...">Channel</a> template's core functionality; it is therefore (data-wise &ndash; but code-wise as well) an <em>extremely</em> thin wrapper around the stored 2-4 peer objects. At its core it provides:</p><ul>
<li>construction in ??? state;</li>
<li>accessors for the peer objects (<code><a class="el" href="classipc_1_1transport_1_1Blob__sender.html" title="A documentation-only concept defining the behavior of an object capable of reliably/in-order sending ...">Blob_sender</a></code>/<code><a class="el" href="classipc_1_1transport_1_1Blob__receiver.html" title="A documentation-only concept defining the behavior of an object capable of reliably/in-order receivin...">Blob_receiver</a></code>, which may be the same object or not; or <code><a class="el" href="classipc_1_1transport_1_1Native__handle__sender.html" title="A documentation-only concept defining the behavior of an object capable of reliably/in-order sending ...">Native_handle_sender</a></code>/<code><a class="el" href="classipc_1_1transport_1_1Native__handle__receiver.html" title="A documentation-only concept defining the behavior of an object capable of reliably/in-order receivin...">Native_handle_receiver</a></code>, ditto; or both);</li>
<li>simple API for loading up the objects that shall be returned by those accessors.</li>
</ul>
<dl class="section note"><dt>Note</dt><dd>A key point is that, since we're really just storing 2-4 pointers (+ a nickname and a <code>Logger</code>), there is important freedom as to the pointees' <em>types</em>. The <code><a class="el" href="classipc_1_1transport_1_1Blob__sender.html" title="A documentation-only concept defining the behavior of an object capable of reliably/in-order sending ...">Blob_sender</a></code> can be either <a class="el" href="classipc_1_1transport_1_1Null__peer.html" title="Dummy type for use as a template param to Channel when either the blobs pipe or handles pipe is disab...">Null_peer</a> (i.e., unused), a <a class="el" href="classipc_1_1transport_1_1Blob__sender.html" title="A documentation-only concept defining the behavior of an object capable of reliably/in-order sending ...">transport::Blob_sender</a> (async-I/O pattern), <em>or</em> a <a class="el" href="classipc_1_1transport_1_1sync__io_1_1Blob__sender.html" title="A documentation-only concept: what transport::Blob_sender is to transport::Native_handle_sender (name...">transport::sync_io::Blob_sender</a> (<code><a class="el" href="namespaceipc_1_1transport_1_1sync__io.html" title="sync_io-pattern counterparts to async-I/O-pattern object types in parent namespace ipc::transport.">sync_io</a></code> pattern; see <a class="el" href="namespaceipc_1_1util_1_1sync__io.html" title="Contains common code, as well as important explanatory documentation in the following text,...">util::sync_io</a> doc header for background). (And analogously for each of <code><a class="el" href="classipc_1_1transport_1_1Blob__receiver.html" title="A documentation-only concept defining the behavior of an object capable of reliably/in-order receivin...">Blob_receiver</a></code>, <code><a class="el" href="classipc_1_1transport_1_1Native__handle__sender.html" title="A documentation-only concept defining the behavior of an object capable of reliably/in-order sending ...">Native_handle_sender</a></code>, <code><a class="el" href="classipc_1_1transport_1_1Native__handle__receiver.html" title="A documentation-only concept defining the behavior of an object capable of reliably/in-order receivin...">Native_handle_receiver</a></code>.) So in other words a <code><a class="el" href="classipc_1_1transport_1_1Channel.html" title="Peer to a bundle of 1-2 full-duplex pipe(s), one for transmitting unstructured binary blobs; the othe...">Channel</a></code> can bundle async-I/O peer objects <em>or</em> <code><a class="el" href="namespaceipc_1_1transport_1_1sync__io.html" title="sync_io-pattern counterparts to async-I/O-pattern object types in parent namespace ipc::transport.">sync_io</a></code> peer objects. You may use <a class="el" href="classipc_1_1transport_1_1Channel.html#ae5be240d29389d7b728950e85df0704e" title="Useful for generic programming: true &lt;=&gt; each non-Null_peer peer type (Blob_sender_obj,...">Channel::S_IS_SYNC_IO_OBJ</a> or <a class="el" href="classipc_1_1transport_1_1Channel.html#a9f75b20b07eff47a69c2b1dbe5c85f84" title="It equals the reverse of S_IS_SYNC_IO_OBJ.">Channel::S_IS_ASYNC_IO_OBJ</a> to determine which is the case at compile-time for a given <a class="el" href="classipc_1_1transport_1_1Channel.html" title="Peer to a bundle of 1-2 full-duplex pipe(s), one for transmitting unstructured binary blobs; the othe...">Channel</a> type.</dd></dl>
<p>Accordingly it provides a very useful method: <a class="el" href="classipc_1_1transport_1_1Channel.html#add016cbac936d3da6c861755ac88b7a2" title="Converts a sync_io-peer-bearing *this to a returned async-I/O-peer-bearing new Channel,...">async_io_obj()</a>. If you have a <code><a class="el" href="namespaceipc_1_1transport_1_1sync__io.html" title="sync_io-pattern counterparts to async-I/O-pattern object types in parent namespace ipc::transport.">sync_io</a></code>-pattern-peer-storing <a class="el" href="classipc_1_1transport_1_1Channel.html" title="Peer to a bundle of 1-2 full-duplex pipe(s), one for transmitting unstructured binary blobs; the othe...">Channel</a> <code>x</code> (i.e., <code>"decltype(x)::S_IS_SYNC_IO_OBJ == true"</code>), simply call <code>x.async_io_obj()</code> to create/return an async-I/O version of it. For example, is <code>x</code> was <code><a class="el" href="classipc_1_1transport_1_1Channel.html" title="Peer to a bundle of 1-2 full-duplex pipe(s), one for transmitting unstructured binary blobs; the othe...">Channel</a>&lt;<a class="el" href="classipc_1_1transport_1_1sync__io_1_1Native__socket__stream.html" title="Implements both sync_io::Native_handle_sender and sync_io::Native_handle_receiver concepts by using a...">transport::sync_io::Native_socket_stream</a>, <a class="el" href="classipc_1_1transport_1_1Null__peer.html" title="Dummy type for use as a template param to Channel when either the blobs pipe or handles pipe is disab...">Null_peer</a>, <a class="el" href="classipc_1_1transport_1_1Null__peer.html" title="Dummy type for use as a template param to Channel when either the blobs pipe or handles pipe is disab...">Null_peer</a>, <a class="el" href="classipc_1_1transport_1_1Null__peer.html" title="Dummy type for use as a template param to Channel when either the blobs pipe or handles pipe is disab...">Null_peer</a>&gt;</code> containing a single <a class="el" href="classipc_1_1transport_1_1sync__io_1_1Native__socket__stream.html" title="Implements both sync_io::Native_handle_sender and sync_io::Native_handle_receiver concepts by using a...">sync_io::Native_socket_stream</a> core (acting as a blob-sender and -receiver), then <code>x.async_io_obj()</code> shall return a new channel object with the same structure but with a new <em>async</em>-I/O-pattern (i.e., auto-parallelizing, async-acting) <a class="el" href="classipc_1_1transport_1_1Native__socket__stream.html" title="Implements both Native_handle_sender and Native_handle_receiver concepts by using a stream-oriented U...">transport::Native_socket_stream</a> which was constructed using the <code><a class="el" href="namespaceipc_1_1transport_1_1sync__io.html" title="sync_io-pattern counterparts to async-I/O-pattern object types in parent namespace ipc::transport.">sync_io</a></code>-core-adopting ctor form (per <a class="el" href="classipc_1_1transport_1_1Blob__sender.html" title="A documentation-only concept defining the behavior of an object capable of reliably/in-order sending ...">transport::Blob_sender</a> and <a class="el" href="classipc_1_1transport_1_1Blob__receiver.html" title="A documentation-only concept defining the behavior of an object capable of reliably/in-order receivin...">transport::Blob_receiver</a> concept).</p>
<p >Generally speaking, APIs such as <a class="el" href="namespaceipc_1_1session.html" title="Flow-IPC module providing the broad lifecycle and shared-resource organization – via the session conc...">ipc::session</a> (e.g., <a class="el" href="classipc_1_1session_1_1Session__server.html#a13887cd64912bb5f5675e2817ff8435f" title="Asynchronously awaits for an opposing Client_session to request session establishment and calls on_do...">session::Session_server::async_accept()</a>) and <a class="el" href="namespaceipc_1_1transport.html" title="Flow-IPC module providing transmission of structured messages and/or low-level blobs (and more) betwe...">ipc::transport</a> (e.g., transport::Native_socket_stream::async_accept()) will create and subsume objects in their <code><a class="el" href="namespaceipc_1_1transport_1_1sync__io.html" title="sync_io-pattern counterparts to async-I/O-pattern object types in parent namespace ipc::transport.">sync_io</a></code>-pattern form, sometimes called <em>cores</em>. These are lighter-weight (compared to async-I/O ones) and don't auto-start background threads for example. Yet whenever you want the async-I/O goodies (and you <em>do</em> want them) simply <code>.async_channel()</code> to get yourself that guy from the <code><a class="el" href="namespaceipc_1_1transport_1_1sync__io.html" title="sync_io-pattern counterparts to async-I/O-pattern object types in parent namespace ipc::transport.">sync_io</a></code> <em>core</em>.</p>
<dl class="section note"><dt>Note</dt><dd>Notably <a class="el" href="classipc_1_1transport_1_1struc_1_1Channel.html" title="Owning and wrapping a pre-connected transport::Channel peer (an endpoint of an established channel ov...">struc::Channel</a> (and <a class="el" href="classipc_1_1transport_1_1struc_1_1sync__io_1_1Channel.html" title="sync_io-pattern counterpart to async-I/O-pattern transport::struc::Channel.">struc::sync_io::Channel</a>, should you wish to use one directly) subsumes a <code><a class="el" href="classipc_1_1transport_1_1Channel.html#ae5be240d29389d7b728950e85df0704e" title="Useful for generic programming: true &lt;=&gt; each non-Null_peer peer type (Blob_sender_obj,...">Channel::S_IS_SYNC_IO_OBJ</a> == true</code> unstructured <a class="el" href="classipc_1_1transport_1_1Channel.html" title="Peer to a bundle of 1-2 full-duplex pipe(s), one for transmitting unstructured binary blobs; the othe...">Channel</a> in every constructor form offered.</dd></dl>
<h3>Secondary use: itself a peer object: forwarding to stored peers</h3>
<p >As a nicety, a <a class="el" href="classipc_1_1transport_1_1Channel.html" title="Peer to a bundle of 1-2 full-duplex pipe(s), one for transmitting unstructured binary blobs; the othe...">Channel</a> itself implements the concepts implemented by each of its stored objects, forwarding API calls to it. For example, if it bundles a <a class="el" href="classipc_1_1transport_1_1Blob__sender.html" title="A documentation-only concept defining the behavior of an object capable of reliably/in-order sending ...">Blob_sender</a> and a <a class="el" href="classipc_1_1transport_1_1Native__handle__sender.html" title="A documentation-only concept defining the behavior of an object capable of reliably/in-order sending ...">Native_handle_sender</a>, then it will itself have <a class="el" href="classipc_1_1transport_1_1Channel.html#ac6a506269ad02031f434a21eff4ca6ba" title="Yields blob_snd()-&gt; same method.">send_blob()</a> and <a class="el" href="classipc_1_1transport_1_1Channel.html#a9bd6a744b8decdc872357fcea33897af" title="Yields hndl_snd()-&gt; same method.">send_native_handle()</a>, forwarding to the stored <a class="el" href="classipc_1_1transport_1_1Blob__sender.html" title="A documentation-only concept defining the behavior of an object capable of reliably/in-order sending ...">Blob_sender</a> and <a class="el" href="classipc_1_1transport_1_1Native__handle__sender.html" title="A documentation-only concept defining the behavior of an object capable of reliably/in-order sending ...">Native_handle_sender</a> respectively.</p><ul>
<li>For the main transmission methods, which have almost identical signatures in the <code>transport::</code> and <code><a class="el" href="namespaceipc_1_1transport_1_1sync__io.html" title="sync_io-pattern counterparts to async-I/O-pattern object types in parent namespace ipc::transport.">transport::sync_io</a>::</code> sender/receiver concepts, each method simply forwards to the appropriate stored peer object. Therefore they can be seen as simple syntactic sugar &ndash; it is really just forwarding.<ul>
<li><a class="el" href="classipc_1_1transport_1_1Blob__sender.html" title="A documentation-only concept defining the behavior of an object capable of reliably/in-order sending ...">Blob_sender</a>: <a class="el" href="classipc_1_1transport_1_1Channel.html#ac6a506269ad02031f434a21eff4ca6ba" title="Yields blob_snd()-&gt; same method.">send_blob()</a>, <a class="el" href="classipc_1_1transport_1_1Channel.html#ab62f46ceaf85baac6820415808c3a2f2" title="Yields blob_snd()-&gt; same method.">send_blob_max_size()</a>.</li>
<li><a class="el" href="classipc_1_1transport_1_1Native__handle__sender.html" title="A documentation-only concept defining the behavior of an object capable of reliably/in-order sending ...">Native_handle_sender</a>: <a class="el" href="classipc_1_1transport_1_1Channel.html#a9bd6a744b8decdc872357fcea33897af" title="Yields hndl_snd()-&gt; same method.">send_native_handle()</a>, <a class="el" href="classipc_1_1transport_1_1Channel.html#a37e1f03a11d1e1df9148048a8a6bab62" title="Yields hndl_snd()-&gt; same method.">send_meta_blob_max_size()</a>.</li>
<li><a class="el" href="classipc_1_1transport_1_1Blob__receiver.html" title="A documentation-only concept defining the behavior of an object capable of reliably/in-order receivin...">Blob_receiver</a>: <a class="el" href="classipc_1_1transport_1_1Channel.html#a1e6d2b4ec45f629b731fe30f46aeca97" title="Yields blob_rcv()-&gt; same method.">async_receive_blob()</a>, <a class="el" href="classipc_1_1transport_1_1Channel.html#a5e181ca69bd2b38d0e3585a1d9303318" title="Yields blob_rcv()-&gt; same method.">receive_blob_max_size()</a>.</li>
<li><a class="el" href="classipc_1_1transport_1_1Native__handle__receiver.html" title="A documentation-only concept defining the behavior of an object capable of reliably/in-order receivin...">Native_handle_receiver</a>: <a class="el" href="classipc_1_1transport_1_1Channel.html#a288e61b4e19b9621f4f978fab88bcab0" title="Yields hndl_rcv()-&gt; same method.">async_receive_native_handle()</a>, <a class="el" href="classipc_1_1transport_1_1Channel.html#afd9589e9bee2aec1574ab534cf4b3782" title="Yields hndl_rcv()-&gt; same method.">receive_meta_blob_max_size()</a>.</li>
</ul>
</li>
<li>For the secondary transmission methods, which <em>also</em> coincide among certain concepts within each of those 2 (sync-versus-async) groups, the methods have a combined action for your convenience. Therefore they actually do something you might find algorithmically helpful rather than mere forwarding. Here I would single out <a class="el" href="classipc_1_1transport_1_1Channel.html#a37fcdfdbefd8ee7e374b0596782ad128" title="Performs hndl_snd()-&gt; and/or blob_snd()-&gt; same method, synthesizing completion handlers into one if a...">async_end_sending()</a> specifically.<ul>
<li><a class="el" href="classipc_1_1transport_1_1Blob__sender.html" title="A documentation-only concept defining the behavior of an object capable of reliably/in-order sending ...">Blob_sender</a>, <a class="el" href="classipc_1_1transport_1_1Native__handle__sender.html" title="A documentation-only concept defining the behavior of an object capable of reliably/in-order sending ...">Native_handle_sender</a>:<ul>
<li><a class="el" href="classipc_1_1transport_1_1Channel.html#a290395d720167759bfa1eda1e86bf123" title="Performs hndl_snd()-&gt; and/or blob_snd()-&gt; same method, returning true if all (1-2) invoked methods re...">auto_ping()</a>: Enables auto-pinging with the same frequency on all (1-2) stored out-pipes.</li>
<li><a class="el" href="classipc_1_1transport_1_1Channel.html#a060e37759dc6f0a00d92fc23a0a09f4f" title="Performs hndl_snd()-&gt; and/or blob_snd()-&gt; same method, returning true if all (1-2) invoked methods re...">end_sending()</a>, <a class="el" href="classipc_1_1transport_1_1Channel.html#a37fcdfdbefd8ee7e374b0596782ad128" title="Performs hndl_snd()-&gt; and/or blob_snd()-&gt; same method, synthesizing completion handlers into one if a...">async_end_sending()</a>: Performs that operation on all (1-2) stored out-pipes. <code>async_end_sending(F)</code> invokes completion handler <code>F()</code> only once <em>all</em> (1-2) out-pipes have finished (this may save you code having to worry about it).<ul>
<li>There is an overload for each of <code>S_IS_SYNC_IO_OBJ</code> and <code>S_IS_ASYNC_IO_OBJ</code> <code><a class="el" href="classipc_1_1transport_1_1Channel.html" title="Peer to a bundle of 1-2 full-duplex pipe(s), one for transmitting unstructured binary blobs; the othe...">Channel</a></code> forms</li>
</ul>
</li>
</ul>
</li>
<li><a class="el" href="classipc_1_1transport_1_1Blob__receiver.html" title="A documentation-only concept defining the behavior of an object capable of reliably/in-order receivin...">Blob_receiver</a>, <a class="el" href="classipc_1_1transport_1_1Native__handle__receiver.html" title="A documentation-only concept defining the behavior of an object capable of reliably/in-order receivin...">Native_handle_receiver</a>:<ul>
<li><a class="el" href="classipc_1_1transport_1_1Channel.html#abf25364b49b9fdd3ba4b1541b3a50356" title="Performs hndl_rcv()-&gt; and/or blob_rcv()-&gt; same method, returning true if all (1-2) invoked methods re...">idle_timer_run()</a>: Enables idle-timer with the same idle-timeout on all (1-2) stored in-pipes.</li>
</ul>
</li>
</ul>
</li>
</ul>
<p >In addition the following <code><a class="el" href="namespaceipc_1_1transport_1_1sync__io.html" title="sync_io-pattern counterparts to async-I/O-pattern object types in parent namespace ipc::transport.">transport::sync_io</a>::</code> methods are available as syntactic sugar if and only if <code>S_IS_SYNC_IO_OBJ</code>.</p><ul>
<li>These method names do not coincide among concepts and therefore are simple forwards:<ul>
<li><a class="el" href="classipc_1_1transport_1_1Blob__sender.html" title="A documentation-only concept defining the behavior of an object capable of reliably/in-order sending ...">Blob_sender</a>: <a class="el" href="classipc_1_1transport_1_1Channel.html#aabafc3beaf1a57e4767c023d9c4f9f93" title="Yields blob_snd()-&gt; same method.">start_send_blob_ops()</a>.</li>
<li><a class="el" href="classipc_1_1transport_1_1Native__handle__sender.html" title="A documentation-only concept defining the behavior of an object capable of reliably/in-order sending ...">Native_handle_sender</a>: <a class="el" href="classipc_1_1transport_1_1Channel.html#ac2413ad0e4178fc321e71b5fe4ca2ce2" title="Yields hndl_snd()-&gt; same method.">start_send_native_handle_ops()</a>.</li>
<li><a class="el" href="classipc_1_1transport_1_1Blob__receiver.html" title="A documentation-only concept defining the behavior of an object capable of reliably/in-order receivin...">Blob_receiver</a>: <a class="el" href="classipc_1_1transport_1_1Channel.html#a0b00c99196fbe8c154f14dbf8f0ceb79" title="Yields blob_rcv()-&gt; same method.">start_receive_blob_ops()</a>.</li>
<li><a class="el" href="classipc_1_1transport_1_1Native__handle__receiver.html" title="A documentation-only concept defining the behavior of an object capable of reliably/in-order receivin...">Native_handle_receiver</a>: <a class="el" href="classipc_1_1transport_1_1Channel.html#a61f7ffbf72ee0fe46997ae08f9adaeb2" title="Yields hndl_rcv()-&gt; same method.">start_receive_native_handle_ops()</a>.</li>
</ul>
</li>
<li>This method coincides among all 4 potential concepts: <a class="el" href="classipc_1_1transport_1_1Channel.html#ae63c4f7dbe1a1855d46a4b4d7009d5e8" title="Executes same method on all unique stored peer objects; returns true if and only if they all did.">replace_event_wait_handles()</a>.<ul>
<li>It invokes the stored peer objects' method of the same name.</li>
</ul>
</li>
</ul>
<h3>How to use: type, initialization</h3>
<p >A <a class="el" href="classipc_1_1transport_1_1Channel.html" title="Peer to a bundle of 1-2 full-duplex pipe(s), one for transmitting unstructured binary blobs; the othe...">Channel</a> stores a <code><a class="el" href="classipc_1_1transport_1_1Blob__sender.html" title="A documentation-only concept defining the behavior of an object capable of reliably/in-order sending ...">Blob_sender</a></code> and <code><a class="el" href="classipc_1_1transport_1_1Blob__receiver.html" title="A documentation-only concept defining the behavior of an object capable of reliably/in-order receivin...">Blob_receiver</a></code>; or a <code><a class="el" href="classipc_1_1transport_1_1Native__handle__sender.html" title="A documentation-only concept defining the behavior of an object capable of reliably/in-order sending ...">Native_handle_sender</a></code> and <code><a class="el" href="classipc_1_1transport_1_1Native__handle__receiver.html" title="A documentation-only concept defining the behavior of an object capable of reliably/in-order receivin...">Native_handle_receiver</a></code>; or both.</p>
<p >The latter is termed the <em>handles pipe</em>; the former the <em>blobs pipe</em>. A <a class="el" href="classipc_1_1transport_1_1Channel.html" title="Peer to a bundle of 1-2 full-duplex pipe(s), one for transmitting unstructured binary blobs; the othe...">Channel</a> can be 1 of 2 <a class="el" href="classipc_1_1transport_1_1Channel.html" title="Peer to a bundle of 1-2 full-duplex pipe(s), one for transmitting unstructured binary blobs; the othe...">Channel</a> peers to a pipe bundle containing either the handles pipe, the blobs pipe, or both. This setting is specified during <em>initialization</em> and cannot be changed after that for a given <code>*this</code>. Initialization consists of the following simple steps:</p><ul>
<li>Select the concrete types for <code>Blob_*er</code> and <code>Native_handle_*er</code> at construction time when specifying the concrete <a class="el" href="classipc_1_1transport_1_1Channel.html" title="Peer to a bundle of 1-2 full-duplex pipe(s), one for transmitting unstructured binary blobs; the othe...">Channel</a> type.<ul>
<li>Determine whether the types shall be async-I/O-pattern-implementing (from <a class="el" href="namespaceipc_1_1transport.html" title="Flow-IPC module providing transmission of structured messages and/or low-level blobs (and more) betwe...">ipc::transport</a> directly) or sync-I/O-pattern implementing (from <a class="el" href="namespaceipc_1_1transport_1_1sync__io.html" title="sync_io-pattern counterparts to async-I/O-pattern object types in parent namespace ipc::transport.">transport::sync_io</a>). In the latter case we assume you will mentally add the <code><a class="el" href="namespaceipc_1_1transport_1_1sync__io.html" title="sync_io-pattern counterparts to async-I/O-pattern object types in parent namespace ipc::transport.">sync_io</a>::</code> qualifier below where applicable.<ul>
<li>This shall determine whether <a class="el" href="classipc_1_1transport_1_1Channel.html#a9f75b20b07eff47a69c2b1dbe5c85f84" title="It equals the reverse of S_IS_SYNC_IO_OBJ.">Channel::S_IS_ASYNC_IO_OBJ</a> or <a class="el" href="classipc_1_1transport_1_1Channel.html#ae5be240d29389d7b728950e85df0704e" title="Useful for generic programming: true &lt;=&gt; each non-Null_peer peer type (Blob_sender_obj,...">Channel::S_IS_SYNC_IO_OBJ</a>.</li>
</ul>
</li>
<li>For each pipe you <em>do not</em> want to use, specify <a class="el" href="classipc_1_1transport_1_1Null__peer.html" title="Dummy type for use as a template param to Channel when either the blobs pipe or handles pipe is disab...">Null_peer</a> as the type.</li>
<li>For each pipe you <em>do</em> want to use, specify a class implementing that concept. The other (opposing) peer must specify a matching <a class="el" href="classipc_1_1transport_1_1Channel.html" title="Peer to a bundle of 1-2 full-duplex pipe(s), one for transmitting unstructured binary blobs; the othe...">Channel</a> type.<ul>
<li>As of this writing: <a class="el" href="classipc_1_1transport_1_1Blob__sender.html" title="A documentation-only concept defining the behavior of an object capable of reliably/in-order sending ...">Blob_sender</a> and <a class="el" href="classipc_1_1transport_1_1Blob__receiver.html" title="A documentation-only concept defining the behavior of an object capable of reliably/in-order receivin...">Blob_receiver</a> can be <code><a class="el" href="classipc_1_1transport_1_1Native__socket__stream.html" title="Implements both Native_handle_sender and Native_handle_receiver concepts by using a stream-oriented U...">Native_socket_stream</a></code>; <a class="el" href="classipc_1_1transport_1_1Blob__sender.html" title="A documentation-only concept defining the behavior of an object capable of reliably/in-order sending ...">Blob_sender</a> can also be <code><a class="el" href="classipc_1_1transport_1_1Blob__stream__mq__sender.html" title="Implements Blob_sender concept by using an adopted Persistent_mq_handle MQ handle to an MQ (message q...">Blob_stream_mq_sender</a>&lt;Mq&gt;</code> (or the specific aliases <code>Posix_mq_sender</code>, <code>Bipc_mq_sender</code>); <code><a class="el" href="classipc_1_1transport_1_1Blob__receiver.html" title="A documentation-only concept defining the behavior of an object capable of reliably/in-order receivin...">Blob_receiver</a></code> can be <code><a class="el" href="classipc_1_1transport_1_1Blob__stream__mq__receiver.html" title="Implements Blob_receiver concept by using an adopted Persistent_mq_handle MQ handle to an MQ (message...">Blob_stream_mq_receiver</a>&lt;Mq&gt;</code> (aliases <code>Posix_mq_receiver</code>, <code>Bipc_mq_receiver</code>).</li>
<li>As of this writing: <a class="el" href="classipc_1_1transport_1_1Native__handle__sender.html" title="A documentation-only concept defining the behavior of an object capable of reliably/in-order sending ...">Native_handle_sender</a> and <a class="el" href="classipc_1_1transport_1_1Native__handle__receiver.html" title="A documentation-only concept defining the behavior of an object capable of reliably/in-order receivin...">Native_handle_receiver</a> can be <a class="el" href="classipc_1_1transport_1_1Native__socket__stream.html" title="Implements both Native_handle_sender and Native_handle_receiver concepts by using a stream-oriented U...">Native_socket_stream</a>.</li>
</ul>
</li>
<li>Example: <code><a class="el" href="classipc_1_1transport_1_1Channel.html" title="Peer to a bundle of 1-2 full-duplex pipe(s), one for transmitting unstructured binary blobs; the othe...">Channel</a>&lt;Posix_mq_sender, Posix_mq_receiver, <a class="el" href="classipc_1_1transport_1_1Null__peer.html" title="Dummy type for use as a template param to Channel when either the blobs pipe or handles pipe is disab...">Null_peer</a>, <a class="el" href="classipc_1_1transport_1_1Null__peer.html" title="Dummy type for use as a template param to Channel when either the blobs pipe or handles pipe is disab...">Null_peer</a>&gt;</code>: Blob pipe via 2 unidirectional POSIX MQs; handles pipe disabled.</li>
<li>Example: <code><a class="el" href="classipc_1_1transport_1_1Channel.html" title="Peer to a bundle of 1-2 full-duplex pipe(s), one for transmitting unstructured binary blobs; the othe...">Channel</a>&lt;<a class="el" href="classipc_1_1transport_1_1Null__peer.html" title="Dummy type for use as a template param to Channel when either the blobs pipe or handles pipe is disab...">Null_peer</a>, <a class="el" href="classipc_1_1transport_1_1Null__peer.html" title="Dummy type for use as a template param to Channel when either the blobs pipe or handles pipe is disab...">Null_peer</a>, <a class="el" href="classipc_1_1transport_1_1Native__socket__stream.html" title="Implements both Native_handle_sender and Native_handle_receiver concepts by using a stream-oriented U...">Native_socket_stream</a>, <a class="el" href="classipc_1_1transport_1_1Native__socket__stream.html" title="Implements both Native_handle_sender and Native_handle_receiver concepts by using a stream-oriented U...">Native_socket_stream</a>&gt;</code>: Blob pipe disabled; handles pipe over a Unix domain stream socket connection.</li>
<li>Example: <code><a class="el" href="classipc_1_1transport_1_1Channel.html" title="Peer to a bundle of 1-2 full-duplex pipe(s), one for transmitting unstructured binary blobs; the othe...">Channel</a>&lt;<a class="el" href="classipc_1_1transport_1_1Null__peer.html" title="Dummy type for use as a template param to Channel when either the blobs pipe or handles pipe is disab...">Null_peer</a>, <a class="el" href="classipc_1_1transport_1_1Null__peer.html" title="Dummy type for use as a template param to Channel when either the blobs pipe or handles pipe is disab...">Null_peer</a>, <a class="el" href="classipc_1_1transport_1_1sync__io_1_1Native__socket__stream.html" title="Implements both sync_io::Native_handle_sender and sync_io::Native_handle_receiver concepts by using a...">sync_io::Native_socket_stream</a>, <a class="el" href="classipc_1_1transport_1_1sync__io_1_1Native__socket__stream.html" title="Implements both sync_io::Native_handle_sender and sync_io::Native_handle_receiver concepts by using a...">sync_io::Native_socket_stream</a>&gt;</code>: Same but bundling <code><a class="el" href="namespaceipc_1_1transport_1_1sync__io.html" title="sync_io-pattern counterparts to async-I/O-pattern object types in parent namespace ipc::transport.">sync_io</a></code> cores instead of async-I/O counterparts.</li>
</ul>
</li>
<li>After construction, before any transmission, load the actual concrete peer objects (via move semantics) by calling:<ul>
<li>Exactly one <a class="el" href="classipc_1_1transport_1_1Channel.html#aa8209a5adde4e5c2b3b1d8779fab0433" title="Completes initialization of the blobs pipe by taking ownership (via move semantics) of an object that...">init_blob_pipe()</a> overload, if the blob pipe is enabled. Exactly 0 such calls if disabled.<ul>
<li>The 1-arg overload shall be used when the <a class="el" href="classipc_1_1transport_1_1Blob__sender.html" title="A documentation-only concept defining the behavior of an object capable of reliably/in-order sending ...">Blob_sender</a> and <a class="el" href="classipc_1_1transport_1_1Blob__receiver.html" title="A documentation-only concept defining the behavior of an object capable of reliably/in-order receivin...">Blob_receiver</a> are one object. For example <a class="el" href="classipc_1_1transport_1_1Native__socket__stream.html" title="Implements both Native_handle_sender and Native_handle_receiver concepts by using a stream-oriented U...">Native_socket_stream</a> is such a class/object, because internally the full-duplex pipe involves a single low-level transport.</li>
<li>The 2-arg overload shall be used when they are separate objects. For example <a class="el" href="namespaceipc_1_1transport.html#afa219c8d2f298bfdc011a723d719be51" title="Convenience alias: Blob_sender via unidirectional bipc MQ (message queue).">Bipc_mq_sender</a> and <a class="el" href="namespaceipc_1_1transport.html#a9493e94e810511b8be41958ca941115f" title="Convenience alias: Blob_receiver via unidirectional bipc MQ (message queue).">Bipc_mq_receiver</a> are separate, because internally the full-duplex pipe is composed of 2 opposite-facing unidirectional MQ-based pipes.</li>
</ul>
</li>
<li>Exactly one <a class="el" href="classipc_1_1transport_1_1Channel.html#a0e0e396759dab8c0930594eac3bb03ba" title="Analogous to 1-arg init_blob_pipe() but as applied to the handles pipe.">init_native_handle_pipe()</a> overload, if the handles pipe is enabled. Exactly 0 such calls if disabled. (Analogous.)</li>
</ul>
</li>
<li>(Optional but recommended) Check <a class="el" href="classipc_1_1transport_1_1Channel.html#a43c79955b3ad0eab347550b4263523ec" title="Returns true if and only if the required init_blob_pipe() and init_native_handle_pipe() calls have be...">initialized()</a> and ensure it returns <code>true</code>. Otherwise you've failed to follow the above instructions. This may be reason enough to <code>assert(false)</code> or abort, but it's up to you. In any case it is unwise, at best, to proceed with anything below.</li>
</ul>
<p >After this, initialization is finished. The <a class="el" href="classipc_1_1transport_1_1Channel.html" title="Peer to a bundle of 1-2 full-duplex pipe(s), one for transmitting unstructured binary blobs; the othe...">Channel</a> is in PEER state. One can use these approaches:</p><ul>
<li>Access the peer objects via <a class="el" href="classipc_1_1transport_1_1Channel.html#a647bc9b6f8b9fb0b546cf3879cb5d4c1" title="Pointer to the mutable owned Blob_sender_obj; null if yet initialized.">blob_snd()</a>, <a class="el" href="classipc_1_1transport_1_1Channel.html#a87fd94fa483cabd78059a3d1d094880d" title="Pointer to the mutable owned Blob_receiver_obj; null if not yet initialized.">blob_rcv()</a>, <a class="el" href="classipc_1_1transport_1_1Channel.html#aa838026c33e4e422df7cd78d3a426b6a" title="Pointer to the mutable owned Native_handle_sender_obj; null if not yet initialized.">hndl_snd()</a>, <a class="el" href="classipc_1_1transport_1_1Channel.html#af4c9cd7b02193fa2e8bf1742ab87111a" title="Pointer to the mutable owned Native_handle_receiver_obj; null if not yet initialized.">hndl_rcv()</a> (of which only the ones enabled at compile-time &ndash; not <a class="el" href="classipc_1_1transport_1_1Null__peer.html" title="Dummy type for use as a template param to Channel when either the blobs pipe or handles pipe is disab...">Null_peer</a> in that template-parm slot &ndash; shall compile). Use their APIs as desired.</li>
<li>Use the concept-implementing forwarding API ("Secondary use" above) on <code>*this</code> itself.</li>
</ul>
<p >Informally: one approach to retain sanity might be &ndash; for a given <code>*this</code> &ndash; to use one or the other approach (for a given object), not both.</p>
<h3>Aliases to <a class="el" href="classipc_1_1transport_1_1Channel.html" title="Peer to a bundle of 1-2 full-duplex pipe(s), one for transmitting unstructured binary blobs; the othe...">Channel</a></h3>
<p >To make it much easier to intantiate and initialize a concrete <a class="el" href="classipc_1_1transport_1_1Channel.html" title="Peer to a bundle of 1-2 full-duplex pipe(s), one for transmitting unstructured binary blobs; the othe...">Channel</a>, there are several aliases and glorified aliases (data-free sub-classes). See <a class="el" href="transport__fwd_8hpp.html">transport_fwd.hpp</a> for the aliases and the present channel.hpp for the glorified aliases. For example:</p><ul>
<li><a class="el" href="namespaceipc_1_1transport.html#a8259bc93cc6a52fe192cf56196f32417" title="Convenience alias: Channel peer (Blob_sender, Blob_receiver, Native_handle_sender,...">Posix_mqs_socket_stream_channel</a> (or <a class="el" href="namespaceipc_1_1transport_1_1sync__io.html#ae3271e118e027ead7f3d82f5ee7a8c36" title="Convenience alias: Channel peer (sync_io::Blob_sender, sync_io::Blob_receiver, sync_io::Native_handle...">sync_io::Posix_mqs_socket_stream_channel</a>) is a "full bundle": a POSIX MQ-based full-duplex blobs pipe; a Unix domain socket-based full-duplex handles pipe.</li>
<li><a class="el" href="classipc_1_1transport_1_1Socket__stream__channel.html" title="A Channel with a handles pipe only (no blobs pipe) that uses a Unix domain socket connection as the u...">Socket_stream_channel</a> is a "half-bundle": a Unix domain socket-based handles pipe only (template param <code>SIO</code> determines whether <a class="el" href="classipc_1_1transport_1_1Native__socket__stream.html" title="Implements both Native_handle_sender and Native_handle_receiver concepts by using a stream-oriented U...">Native_socket_stream</a> or <a class="el" href="classipc_1_1transport_1_1sync__io_1_1Native__socket__stream.html" title="Implements both sync_io::Native_handle_sender and sync_io::Native_handle_receiver concepts by using a...">sync_io::Native_socket_stream</a>).</li>
<li><a class="el" href="namespaceipc_1_1transport.html#ab6546444a83490a74031030b7f38c24a" title="Convenience alias: Channel peer (Blob_sender, Blob_receiver) at one end of full-duplex (bidirectional...">Bipc_mqs_channel_of_blobs</a> (or <a class="el" href="namespaceipc_1_1transport_1_1sync__io.html#a0431bcfe44d71e6bc83d3c9d1dc59c3c" title="Convenience alias: Channel peer (sync_io::Blob_sender, sync_io::Blob_receiver) at one end of full-dup...">sync_io::Bipc_mqs_channel_of_blobs</a>) is a "half-bundle": a bipc MQ-based full-duplex blobs pipe only.</li>
</ul>
<p >Generally such convenience types do not require any <a class="el" href="classipc_1_1transport_1_1Channel.html#aa8209a5adde4e5c2b3b1d8779fab0433" title="Completes initialization of the blobs pipe by taking ownership (via move semantics) of an object that...">init_blob_pipe()</a> or <a class="el" href="classipc_1_1transport_1_1Channel.html#a0e0e396759dab8c0930594eac3bb03ba" title="Analogous to 1-arg init_blob_pipe() but as applied to the handles pipe.">init_native_handle_pipe()</a> calls; one supplies what's necessary at construction time, and the ctor makes those needed calls for the user.</p>
<p >This really applies only when creating <code><a class="el" href="classipc_1_1transport_1_1Channel.html" title="Peer to a bundle of 1-2 full-duplex pipe(s), one for transmitting unstructured binary blobs; the othe...">Channel</a></code>s <em>not</em> via <a class="el" href="namespaceipc_1_1session.html" title="Flow-IPC module providing the broad lifecycle and shared-resource organization – via the session conc...">ipc::session</a> &ndash; in its case the exact <code><a class="el" href="classipc_1_1transport_1_1Channel.html" title="Peer to a bundle of 1-2 full-duplex pipe(s), one for transmitting unstructured binary blobs; the othe...">Channel</a></code> type is determined internally to <a class="el" href="namespaceipc_1_1session.html" title="Flow-IPC module providing the broad lifecycle and shared-resource organization – via the session conc...">ipc::session</a>: you can not worry about typing or construction and just use the guy. However someone somewhere does need to actually type and create a <code><a class="el" href="classipc_1_1transport_1_1Channel.html" title="Peer to a bundle of 1-2 full-duplex pipe(s), one for transmitting unstructured binary blobs; the othe...">Channel</a></code>.</p>
<p >Please realize that it is safe and appropriate to <code>static_cast&lt;&gt;</code> between pointers/references of any <a class="el" href="classipc_1_1transport_1_1Channel.html" title="Peer to a bundle of 1-2 full-duplex pipe(s), one for transmitting unstructured binary blobs; the othe...">Channel</a> type to any other <a class="el" href="classipc_1_1transport_1_1Channel.html" title="Peer to a bundle of 1-2 full-duplex pipe(s), one for transmitting unstructured binary blobs; the othe...">Channel</a> type: all that has to be true between a given pair of types <code>C1</code> and <code>C2</code> is: <code>is_same_v&lt;C1::Blob_sender_obj, C2::Blob_sender_obj&gt; == true</code>, repeated for <code>Blob_receiver_obj</code>, <code>Native_handle_sender_obj</code>, <code>Native_handle_receiver_obj</code>.</p>
<h3>??? versus PEER states; pipe interaction</h3>
<p >A <a class="el" href="classipc_1_1transport_1_1Channel.html" title="Peer to a bundle of 1-2 full-duplex pipe(s), one for transmitting unstructured binary blobs; the othe...">Channel</a> contains minimal logic. It's a bundling of pipe peers; and secondarily of concept implementations.</p>
<p >In that secondary role, befitting a <a class="el" href="classipc_1_1transport_1_1Blob__sender.html" title="A documentation-only concept defining the behavior of an object capable of reliably/in-order sending ...">Blob_sender</a>, <a class="el" href="classipc_1_1transport_1_1Blob__receiver.html" title="A documentation-only concept defining the behavior of an object capable of reliably/in-order receivin...">Blob_receiver</a>, and/or <a class="el" href="classipc_1_1transport_1_1Native__handle__sender.html" title="A documentation-only concept defining the behavior of an object capable of reliably/in-order sending ...">Native_handle_sender</a>, <a class="el" href="classipc_1_1transport_1_1Native__handle__receiver.html" title="A documentation-only concept defining the behavior of an object capable of reliably/in-order receivin...">Native_handle_receiver</a>: A <a class="el" href="classipc_1_1transport_1_1Channel.html" title="Peer to a bundle of 1-2 full-duplex pipe(s), one for transmitting unstructured binary blobs; the othe...">Channel</a> <code>*this</code> is in one of 2 states:</p><ul>
<li>During initialization: ??? state.</li>
<li>After initialization: PEER state. The peer objects have been moved-into <code>*this</code>: it can now transmit.</li>
</ul>
<p >As per those concepts: The only way to exit PEER state is to move-from <code>*this</code> which makes it ??? (as-if default-cted) again.</p>
<p >As of this writing, in ??? state methods other than <code>init*()</code> and the basic accessors shall have undefined behavior. In PEER state however they shall all strive to do work (per concepts). There's technically also the no-man's-land wherein one has called some but not all intended <code>init_*_pipe()</code> calls. Behavior is similarly undefined in that no-man's-land.</p>
<p >To restate, indeed a <a class="el" href="classipc_1_1transport_1_1Channel.html" title="Peer to a bundle of 1-2 full-duplex pipe(s), one for transmitting unstructured binary blobs; the othe...">Channel</a> contains minimal logic and mainly bundles 1-2 pipes, supplying at least 1 bidirectional pipe and optionally a way to transmit native handles along one if desired. Mostly its API keeps the pipes (if there are indeed 2) separate: <a class="el" href="classipc_1_1transport_1_1Channel.html#ac6a506269ad02031f434a21eff4ca6ba" title="Yields blob_snd()-&gt; same method.">send_blob()</a> affects one, send_native_socket() affects the other; the calls do not interact; similarly for receiving. What minimal interaction does occur does so in those APIs that have identical signatures in each concept pair Native_handle_sender/Blob_sender, Native_handle_receiveir/Blob_receiver. These interactions are documented in the respective methods' doc headers. For example <code>async_end_sending(F)</code> shall invoke <code>F()</code>, once each pipe's individual <code>*end_sending()</code> has completed; and errors (if any) will be reported in a particular way. Additionally note the following:</p>
<h3>Note on error handling/pipe hosing</h3>
<p >Again <code>*this</code> is just bundling some senders/receivers. To begin with, a sender and receiver for one of the pipes (if there are two; or simply <em>the</em> pipe otherwise) might be the same object, such as with <a class="el" href="classipc_1_1transport_1_1Native__socket__stream.html" title="Implements both Native_handle_sender and Native_handle_receiver concepts by using a stream-oriented U...">Native_socket_stream</a>; or separate ones such as <a class="el" href="classipc_1_1transport_1_1Blob__stream__mq__sender.html" title="Implements Blob_sender concept by using an adopted Persistent_mq_handle MQ handle to an MQ (message q...">Blob_stream_mq_sender</a> and <a class="el" href="classipc_1_1transport_1_1Blob__stream__mq__receiver.html" title="Implements Blob_receiver concept by using an adopted Persistent_mq_handle MQ handle to an MQ (message...">Blob_stream_mq_receiver</a>. Furthermore there might be 2 pipes, one for blobs, the other for sockets. Now: Consider "pipe hosing." A pipe is hosed (permanently) when an error is emitted to the async transmission methods <a class="el" href="classipc_1_1transport_1_1Channel.html#a1e6d2b4ec45f629b731fe30f46aeca97" title="Yields blob_rcv()-&gt; same method.">async_receive_blob()</a>, <a class="el" href="classipc_1_1transport_1_1Channel.html#a288e61b4e19b9621f4f978fab88bcab0" title="Yields hndl_rcv()-&gt; same method.">async_receive_native_handle()</a>, or <code>*end_sending()</code>; or (in most cases) the synchronous ones <a class="el" href="classipc_1_1transport_1_1Channel.html#ac6a506269ad02031f434a21eff4ca6ba" title="Yields blob_snd()-&gt; same method.">send_blob()</a>, <a class="el" href="classipc_1_1transport_1_1Channel.html#a9bd6a744b8decdc872357fcea33897af" title="Yields hndl_snd()-&gt; same method.">send_native_handle()</a>. The question is... <em>which</em> pipe is hosed? The answer: it depends on what is being bundled here and the type of error. If <a class="el" href="classipc_1_1transport_1_1Native__socket__stream.html#a415febd76ee222c81d59d2bcfa9c01bc" title="Implements Blob_sender API per contract.">Native_socket_stream::send_blob()</a> fails (because <a class="el" href="classipc_1_1transport_1_1Channel.html#a82746276cc7379a866b12d529780900f" title="Alias for Blob_sender template parameter.">Blob_sender_obj</a> is <a class="el" href="classipc_1_1transport_1_1Native__socket__stream.html" title="Implements both Native_handle_sender and Native_handle_receiver concepts by using a stream-oriented U...">Native_socket_stream</a>), with system error connection-reset, then both the in-pipe (within the blobs pipe) and out-pipe (ditto) are hosed, because when a Unix domain socket goes down with connection-reset, that means both directions are hosed. If <a class="el" href="classipc_1_1transport_1_1Channel.html#a1e6d2b4ec45f629b731fe30f46aeca97" title="Yields blob_rcv()-&gt; same method.">async_receive_blob()</a> fails with graceful-close <a class="el" href="namespaceipc_1_1transport_1_1error.html#adfef15ef4e76cc55d652fbd9c2797297aad44f87d53255ba573d57086dfeab805" title="Will not receive message: either opposing user sent graceful-close via API.">error::Code::S_RECEIVES_FINISHED_CANNOT_RECEIVE</a>, then only the in-pipe is hosed, while the out-pipe is fine. On the other hand with <a class="el" href="classipc_1_1transport_1_1Blob__stream__mq__sender.html#a1d23a47d08ac7c31aa546ea02bb24c55" title="Implements Blob_sender API per contract.">Blob_stream_mq_sender::send_blob()</a> (because <a class="el" href="classipc_1_1transport_1_1Channel.html#a82746276cc7379a866b12d529780900f" title="Alias for Blob_sender template parameter.">Blob_sender_obj</a> is <a class="el" href="classipc_1_1transport_1_1Blob__stream__mq__sender.html" title="Implements Blob_sender concept by using an adopted Persistent_mq_handle MQ handle to an MQ (message q...">Blob_stream_mq_sender</a>), no matter how it fails, it does not affect the out-pipe which is presumably run through an entirely separate <a class="el" href="classipc_1_1transport_1_1Blob__stream__mq__receiver.html" title="Implements Blob_receiver concept by using an adopted Persistent_mq_handle MQ handle to an MQ (message...">Blob_stream_mq_receiver</a>, operating necessarily over a different underlying MQ. And in either case, if there is also a 2nd bidirectional pipe also bundled, then errors over the first pipe mean nothing to the second.</p>
<p >So, it depends, and in non-trivial ways very much dependent on the concrete types given as template params.</p>
<p >Therefore we make an informal recommendation to the user of any <a class="el" href="classipc_1_1transport_1_1Channel.html" title="Peer to a bundle of 1-2 full-duplex pipe(s), one for transmitting unstructured binary blobs; the othe...">Channel</a> but especially so if programming generically (meaning without awareness of what type that particular <a class="el" href="classipc_1_1transport_1_1Channel.html" title="Peer to a bundle of 1-2 full-duplex pipe(s), one for transmitting unstructured binary blobs; the othe...">Channel</a> is):</p>
<p >If a pipe-hosing error is detected through <em>any</em> <a class="el" href="classipc_1_1transport_1_1Channel.html" title="Peer to a bundle of 1-2 full-duplex pipe(s), one for transmitting unstructured binary blobs; the othe...">Channel</a> API, prefer to subsequently treat the other pipes as hosed (even if it/they may still be capable of operating). Stop using the <a class="el" href="classipc_1_1transport_1_1Channel.html" title="Peer to a bundle of 1-2 full-duplex pipe(s), one for transmitting unstructured binary blobs; the othe...">Channel</a>; consider invoking <code>async_end_sending(F)</code> (or <code><a class="el" href="namespaceipc_1_1transport_1_1sync__io.html" title="sync_io-pattern counterparts to async-I/O-pattern object types in parent namespace ipc::transport.">sync_io</a></code>-pattern form <code>async_end_sending(E, F)</code>); and once <code>F()</code> is executed (or <code><a class="el" href="namespaceipc_1_1transport_1_1sync__io.html" title="sync_io-pattern counterparts to async-I/O-pattern object types in parent namespace ipc::transport.">sync_io</a></code> equivalent; or <code>*end_sending()</code> returns <code>false</code>) then perhaps destroy <code>*this</code>. Do not try to keep using any remaining 1- or 2-directional pipe(s).</p>
<p >Your code will be simpler &ndash; probably without losing much functionality.</p>
<p >A potential exception to this rule of thumb <em>could</em> be <a class="el" href="namespaceipc_1_1transport_1_1error.html#adfef15ef4e76cc55d652fbd9c2797297aad44f87d53255ba573d57086dfeab805" title="Will not receive message: either opposing user sent graceful-close via API.">error::Code::S_RECEIVES_FINISHED_CANNOT_RECEIVE</a>, as it indicates the graceful closing of an in-pipe, while the out-pipe could be fine... but not really; because what about the other bidirectional pipe (if applicable)? That one is fine all-around, both directions; so now what?</p>
<p >Therefore in our opinion it is really best, typically, to look for any 1-direction-pipe-hosing error, and once detected:</p><ol type="1">
<li>End regular use of <code>*this</code> <a class="el" href="classipc_1_1transport_1_1Channel.html" title="Peer to a bundle of 1-2 full-duplex pipe(s), one for transmitting unstructured binary blobs; the othe...">Channel</a>.</li>
<li>(Optional depending on sensitivity of your task/data) Invoke <code><a class="el" href="classipc_1_1transport_1_1Channel.html#a37fcdfdbefd8ee7e374b0596782ad128" title="Performs hndl_snd()-&gt; and/or blob_snd()-&gt; same method, synthesizing completion handlers into one if a...">async_end_sending()</a></code>. If it returns <code>false</code>, or once the completion handler executes (or the <code><a class="el" href="namespaceipc_1_1transport_1_1sync__io.html" title="sync_io-pattern counterparts to async-I/O-pattern object types in parent namespace ipc::transport.">sync_io</a></code> form synchronously succeeds):</li>
<li>Destroy <code>*this</code> <a class="el" href="classipc_1_1transport_1_1Channel.html" title="Peer to a bundle of 1-2 full-duplex pipe(s), one for transmitting unstructured binary blobs; the othe...">Channel</a> (to avoid unnecessary resource use including background threads in the async-I/O-pattern case).</li>
</ol>
<h3>Thread safety</h3>
<p >This flows out of understanding the above explanation wherein it is shown that: Strictly after initialization and excluding the acting-on-the-bundle methods <a class="el" href="classipc_1_1transport_1_1Channel.html#a060e37759dc6f0a00d92fc23a0a09f4f" title="Performs hndl_snd()-&gt; and/or blob_snd()-&gt; same method, returning true if all (1-2) invoked methods re...">end_sending()</a>, <a class="el" href="classipc_1_1transport_1_1Channel.html#a37fcdfdbefd8ee7e374b0596782ad128" title="Performs hndl_snd()-&gt; and/or blob_snd()-&gt; same method, synthesizing completion handlers into one if a...">async_end_sending()</a>, <a class="el" href="classipc_1_1transport_1_1Channel.html#a290395d720167759bfa1eda1e86bf123" title="Performs hndl_snd()-&gt; and/or blob_snd()-&gt; same method, returning true if all (1-2) invoked methods re...">auto_ping()</a>, <a class="el" href="classipc_1_1transport_1_1Channel.html#abf25364b49b9fdd3ba4b1541b3a50356" title="Performs hndl_rcv()-&gt; and/or blob_rcv()-&gt; same method, returning true if all (1-2) invoked methods re...">idle_timer_run()</a>, the rest of the methods &ndash; most notably <code>async_receive_*()</code> and <code>send_*()</code> &ndash; operate on each pipe (if there are 2, not 1) independently. Therefore <a class="el" href="classipc_1_1transport_1_1Channel.html#a1e6d2b4ec45f629b731fe30f46aeca97" title="Yields blob_rcv()-&gt; same method.">async_receive_blob()</a> work occurs on entirely separate data from <a class="el" href="classipc_1_1transport_1_1Channel.html#a288e61b4e19b9621f4f978fab88bcab0" title="Yields hndl_rcv()-&gt; same method.">async_receive_native_handle()</a> work; and similarly <a class="el" href="classipc_1_1transport_1_1Channel.html#ac6a506269ad02031f434a21eff4ca6ba" title="Yields blob_snd()-&gt; same method.">send_blob()</a> versus <a class="el" href="classipc_1_1transport_1_1Channel.html#a9bd6a744b8decdc872357fcea33897af" title="Yields hndl_snd()-&gt; same method.">send_native_handle()</a>. Therefore running such operations concurrently is safe.</p>
<p >Certainly, post-initialization, accessors <code>{blob|hndl}_{snd|rcv}()</code> are safe to invoke concurrently.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname"><a class="el" href="classipc_1_1transport_1_1Blob__sender.html" title="A documentation-only concept defining the behavior of an object capable of reliably/in-order sending ...">Blob_sender</a></td><td>Implements that concept in <code>transport::</code> or <code><a class="el" href="namespaceipc_1_1transport_1_1sync__io.html" title="sync_io-pattern counterparts to async-I/O-pattern object types in parent namespace ipc::transport.">transport::sync_io</a>::</code> if blobs pipe enabled; else <a class="el" href="classipc_1_1transport_1_1Null__peer.html" title="Dummy type for use as a template param to Channel when either the blobs pipe or handles pipe is disab...">Null_peer</a>. If not <a class="el" href="classipc_1_1transport_1_1Null__peer.html" title="Dummy type for use as a template param to Channel when either the blobs pipe or handles pipe is disab...">Null_peer</a>, and another 1 of remaining 3 parameters is not <a class="el" href="classipc_1_1transport_1_1Null__peer.html" title="Dummy type for use as a template param to Channel when either the blobs pipe or handles pipe is disab...">Null_peer</a>, then they must both be in <code>transport::</code> or both in <code><a class="el" href="namespaceipc_1_1transport_1_1sync__io.html" title="sync_io-pattern counterparts to async-I/O-pattern object types in parent namespace ipc::transport.">transport::sync_io</a>::</code>. </td></tr>
    <tr><td class="paramname"><a class="el" href="classipc_1_1transport_1_1Blob__receiver.html" title="A documentation-only concept defining the behavior of an object capable of reliably/in-order receivin...">Blob_receiver</a></td><td>Implements that concept in <code>transport::</code> or <code><a class="el" href="namespaceipc_1_1transport_1_1sync__io.html" title="sync_io-pattern counterparts to async-I/O-pattern object types in parent namespace ipc::transport.">transport::sync_io</a>::</code> if blobs pipe enabled; else <a class="el" href="classipc_1_1transport_1_1Null__peer.html" title="Dummy type for use as a template param to Channel when either the blobs pipe or handles pipe is disab...">Null_peer</a>. If not <a class="el" href="classipc_1_1transport_1_1Null__peer.html" title="Dummy type for use as a template param to Channel when either the blobs pipe or handles pipe is disab...">Null_peer</a>, and another 1 of remaining 3 parameters is not <a class="el" href="classipc_1_1transport_1_1Null__peer.html" title="Dummy type for use as a template param to Channel when either the blobs pipe or handles pipe is disab...">Null_peer</a>, then they must both be in <code>transport::</code> or both in <code><a class="el" href="namespaceipc_1_1transport_1_1sync__io.html" title="sync_io-pattern counterparts to async-I/O-pattern object types in parent namespace ipc::transport.">transport::sync_io</a>::</code>. </td></tr>
    <tr><td class="paramname"><a class="el" href="classipc_1_1transport_1_1Native__handle__sender.html" title="A documentation-only concept defining the behavior of an object capable of reliably/in-order sending ...">Native_handle_sender</a></td><td>Implements that concept in <code>transport::</code> or <code><a class="el" href="namespaceipc_1_1transport_1_1sync__io.html" title="sync_io-pattern counterparts to async-I/O-pattern object types in parent namespace ipc::transport.">transport::sync_io</a>::</code> if handles pipe enabled; else <a class="el" href="classipc_1_1transport_1_1Null__peer.html" title="Dummy type for use as a template param to Channel when either the blobs pipe or handles pipe is disab...">Null_peer</a>. If not <a class="el" href="classipc_1_1transport_1_1Null__peer.html" title="Dummy type for use as a template param to Channel when either the blobs pipe or handles pipe is disab...">Null_peer</a>, and another 1 of remaining 3 parameters is not <a class="el" href="classipc_1_1transport_1_1Null__peer.html" title="Dummy type for use as a template param to Channel when either the blobs pipe or handles pipe is disab...">Null_peer</a>, then they must both be in <code>transport::</code> or both in <code><a class="el" href="namespaceipc_1_1transport_1_1sync__io.html" title="sync_io-pattern counterparts to async-I/O-pattern object types in parent namespace ipc::transport.">transport::sync_io</a>::</code>. </td></tr>
    <tr><td class="paramname"><a class="el" href="classipc_1_1transport_1_1Native__handle__receiver.html" title="A documentation-only concept defining the behavior of an object capable of reliably/in-order receivin...">Native_handle_receiver</a></td><td>Implements that concept in <code>transport::</code> or <code><a class="el" href="namespaceipc_1_1transport_1_1sync__io.html" title="sync_io-pattern counterparts to async-I/O-pattern object types in parent namespace ipc::transport.">transport::sync_io</a>::</code> if handles pipe enabled; else <a class="el" href="classipc_1_1transport_1_1Null__peer.html" title="Dummy type for use as a template param to Channel when either the blobs pipe or handles pipe is disab...">Null_peer</a>. If not <a class="el" href="classipc_1_1transport_1_1Null__peer.html" title="Dummy type for use as a template param to Channel when either the blobs pipe or handles pipe is disab...">Null_peer</a>, and another 1 of remaining 3 parameters is not <a class="el" href="classipc_1_1transport_1_1Null__peer.html" title="Dummy type for use as a template param to Channel when either the blobs pipe or handles pipe is disab...">Null_peer</a>, then they must both be in <code>transport::</code> or both in <code><a class="el" href="namespaceipc_1_1transport_1_1sync__io.html" title="sync_io-pattern counterparts to async-I/O-pattern object types in parent namespace ipc::transport.">transport::sync_io</a>::</code>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classipc_1_1transport_1_1Blob__sender.html" title="A documentation-only concept defining the behavior of an object capable of reliably/in-order sending ...">Blob_sender</a>: possible implemented concept. </dd>
<dd>
<a class="el" href="classipc_1_1transport_1_1sync__io_1_1Blob__sender.html" title="A documentation-only concept: what transport::Blob_sender is to transport::Native_handle_sender (name...">sync_io::Blob_sender</a>: alternative possible implemented concept (not both). </dd>
<dd>
<a class="el" href="classipc_1_1transport_1_1Blob__receiver.html" title="A documentation-only concept defining the behavior of an object capable of reliably/in-order receivin...">Blob_receiver</a>: possible implemented concept. </dd>
<dd>
<a class="el" href="classipc_1_1transport_1_1sync__io_1_1Blob__receiver.html" title="A documentation-only concept: what transport::Blob_receiver is to transport::Native_handle_receiver (...">sync_io::Blob_receiver</a>: alternative possible implemented concept (not both). </dd>
<dd>
<a class="el" href="classipc_1_1transport_1_1Native__handle__sender.html" title="A documentation-only concept defining the behavior of an object capable of reliably/in-order sending ...">Native_handle_sender</a>: possible implemented concept. </dd>
<dd>
<a class="el" href="classipc_1_1transport_1_1sync__io_1_1Native__handle__sender.html" title="A documentation-only concept defining the behavior of an object that is the sync_io-pattern counterpa...">sync_io::Native_handle_sender</a>: alternative possible implemented concept (not both). </dd>
<dd>
<a class="el" href="classipc_1_1transport_1_1Native__handle__receiver.html" title="A documentation-only concept defining the behavior of an object capable of reliably/in-order receivin...">Native_handle_receiver</a>: possible implemented concept. </dd>
<dd>
<a class="el" href="classipc_1_1transport_1_1sync__io_1_1Native__handle__receiver.html" title="A documentation-only concept defining the behavior of an object that is the sync_io-pattern counterpa...">sync_io::Native_handle_receiver</a>: alternative possible implemented concept (not both). </dd></dl>
</div><h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="ae7f2b8a45af59c073fa91f74be0439d8" name="ae7f2b8a45af59c073fa91f74be0439d8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae7f2b8a45af59c073fa91f74be0439d8">&#9670;&nbsp;</a></span>Channel() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename <a class="el" href="classipc_1_1transport_1_1Blob__sender.html">Blob_sender</a> , typename <a class="el" href="classipc_1_1transport_1_1Blob__receiver.html">Blob_receiver</a> , typename <a class="el" href="classipc_1_1transport_1_1Native__handle__sender.html">Native_handle_sender</a> , typename <a class="el" href="classipc_1_1transport_1_1Native__handle__receiver.html">Native_handle_receiver</a> &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classipc_1_1transport_1_1Channel.html">ipc::transport::Channel</a>&lt; <a class="el" href="classipc_1_1transport_1_1Blob__sender.html">Blob_sender</a>, <a class="el" href="classipc_1_1transport_1_1Blob__receiver.html">Blob_receiver</a>, <a class="el" href="classipc_1_1transport_1_1Native__handle__sender.html">Native_handle_sender</a>, <a class="el" href="classipc_1_1transport_1_1Native__handle__receiver.html">Native_handle_receiver</a> &gt;::Channel</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Default ctor (<a class="el" href="classipc_1_1transport_1_1Channel.html" title="Peer to a bundle of 1-2 full-duplex pipe(s), one for transmitting unstructured binary blobs; the othe...">Channel</a> is in ??? state; intended to be move-assigned). </p>
<p >This ctor is informally intended for the following uses:</p><ul>
<li>A moved-from <a class="el" href="classipc_1_1transport_1_1Channel.html" title="Peer to a bundle of 1-2 full-duplex pipe(s), one for transmitting unstructured binary blobs; the othe...">Channel</a> (i.e., the <code>src</code> arg move-ctor and move-assignment operator) becomes as-if defaulted-constructed.</li>
<li>A target <a class="el" href="classipc_1_1transport_1_1Channel.html" title="Peer to a bundle of 1-2 full-duplex pipe(s), one for transmitting unstructured binary blobs; the othe...">Channel</a> for an API that generates PEER-state <a class="el" href="classipc_1_1transport_1_1Channel.html" title="Peer to a bundle of 1-2 full-duplex pipe(s), one for transmitting unstructured binary blobs; the othe...">Channel</a> objects shall typically be default-cted by user before being passed to that API.</li>
</ul>
<p >Therefore it would be unusual (though allowed) to make direct calls such as <a class="el" href="classipc_1_1transport_1_1Channel.html#aa8209a5adde4e5c2b3b1d8779fab0433" title="Completes initialization of the blobs pipe by taking ownership (via move semantics) of an object that...">init_blob_pipe()</a> on a default-cted <a class="el" href="classipc_1_1transport_1_1Channel.html" title="Peer to a bundle of 1-2 full-duplex pipe(s), one for transmitting unstructured binary blobs; the othe...">Channel</a> without first moving a non-default-cted object into it. </p>

</div>
</div>
<a id="ab961f45ec4416bfa010df7b9a6e4f40a" name="ab961f45ec4416bfa010df7b9a6e4f40a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab961f45ec4416bfa010df7b9a6e4f40a">&#9670;&nbsp;</a></span>Channel() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename <a class="el" href="classipc_1_1transport_1_1Blob__sender.html">Blob_sender</a> , typename <a class="el" href="classipc_1_1transport_1_1Blob__receiver.html">Blob_receiver</a> , typename <a class="el" href="classipc_1_1transport_1_1Native__handle__sender.html">Native_handle_sender</a> , typename <a class="el" href="classipc_1_1transport_1_1Native__handle__receiver.html">Native_handle_receiver</a> &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classipc_1_1transport_1_1Channel.html">ipc::transport::Channel</a>&lt; <a class="el" href="classipc_1_1transport_1_1Blob__sender.html">Blob_sender</a>, <a class="el" href="classipc_1_1transport_1_1Blob__receiver.html">Blob_receiver</a>, <a class="el" href="classipc_1_1transport_1_1Native__handle__sender.html">Native_handle_sender</a>, <a class="el" href="classipc_1_1transport_1_1Native__handle__receiver.html">Native_handle_receiver</a> &gt;::Channel </td>
          <td>(</td>
          <td class="paramtype">flow::log::Logger *&#160;</td>
          <td class="paramname"><em>logger_ptr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceipc_1_1util.html#ae6ac47812a90d1287c61e0b7de7bc4f5">util::String_view</a>&#160;</td>
          <td class="paramname"><em>nickname_str</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Constructs <a class="el" href="classipc_1_1transport_1_1Channel.html" title="Peer to a bundle of 1-2 full-duplex pipe(s), one for transmitting unstructured binary blobs; the othe...">Channel</a> in ??? state with the intention to continue initialization via <a class="el" href="classipc_1_1transport_1_1Channel.html#aa8209a5adde4e5c2b3b1d8779fab0433" title="Completes initialization of the blobs pipe by taking ownership (via move semantics) of an object that...">init_blob_pipe()</a> and/or <a class="el" href="classipc_1_1transport_1_1Channel.html#a0e0e396759dab8c0930594eac3bb03ba" title="Analogous to 1-arg init_blob_pipe() but as applied to the handles pipe.">init_native_handle_pipe()</a> call(s). </p>
<p >This ctor is informally intended for the following use:</p><ul>
<li>You create a <a class="el" href="classipc_1_1transport_1_1Channel.html" title="Peer to a bundle of 1-2 full-duplex pipe(s), one for transmitting unstructured binary blobs; the othe...">Channel</a> that is logger-appointed and nicely-nicknamed; then you call <a class="el" href="classipc_1_1transport_1_1Channel.html#aa8209a5adde4e5c2b3b1d8779fab0433" title="Completes initialization of the blobs pipe by taking ownership (via move semantics) of an object that...">init_blob_pipe()</a> and/or <a class="el" href="classipc_1_1transport_1_1Channel.html#a0e0e396759dab8c0930594eac3bb03ba" title="Analogous to 1-arg init_blob_pipe() but as applied to the handles pipe.">init_native_handle_pipe()</a> to move actual transmitting peer objects into <code>*this</code>, moving <code>*this</code> into PEER state. It will retain the logger and nickname throughout.</li>
</ul>
<p >It may be more convenient to use an alias or data-less sub-class which typically comes with specialized ctor forms that remove or reduce the need for laborious <code>init_*_pipe()</code> calls.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">logger_ptr</td><td>Logger to use for subsequently logging. </td></tr>
    <tr><td class="paramname">nickname_str</td><td>Human-readable nickname of the new object, as of this writing for use in <code>operator&lt;&lt;(ostream)</code> and logging only. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a6fd5dc48222a3cf3eb021fee13c50ea5" name="a6fd5dc48222a3cf3eb021fee13c50ea5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6fd5dc48222a3cf3eb021fee13c50ea5">&#9670;&nbsp;</a></span>Channel() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename <a class="el" href="classipc_1_1transport_1_1Blob__sender.html">Blob_sender</a> , typename <a class="el" href="classipc_1_1transport_1_1Blob__receiver.html">Blob_receiver</a> , typename <a class="el" href="classipc_1_1transport_1_1Native__handle__sender.html">Native_handle_sender</a> , typename <a class="el" href="classipc_1_1transport_1_1Native__handle__receiver.html">Native_handle_receiver</a> &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classipc_1_1transport_1_1Channel.html">ipc::transport::Channel</a>&lt; <a class="el" href="classipc_1_1transport_1_1Blob__sender.html">Blob_sender</a>, <a class="el" href="classipc_1_1transport_1_1Blob__receiver.html">Blob_receiver</a>, <a class="el" href="classipc_1_1transport_1_1Native__handle__sender.html">Native_handle_sender</a>, <a class="el" href="classipc_1_1transport_1_1Native__handle__receiver.html">Native_handle_receiver</a> &gt;::Channel </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classipc_1_1transport_1_1Channel.html">Channel</a>&lt; <a class="el" href="classipc_1_1transport_1_1Blob__sender.html">Blob_sender</a>, <a class="el" href="classipc_1_1transport_1_1Blob__receiver.html">Blob_receiver</a>, <a class="el" href="classipc_1_1transport_1_1Native__handle__sender.html">Native_handle_sender</a>, <a class="el" href="classipc_1_1transport_1_1Native__handle__receiver.html">Native_handle_receiver</a> &gt; &amp;&amp;&#160;</td>
          <td class="paramname"><em>src</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">default</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Move-constructs from <code>src</code>; <code>src</code> becomes as-if default-cted (therefore in ??? state). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">src</td><td>See above. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a10d97e67296614195f8b14599944dd65" name="a10d97e67296614195f8b14599944dd65"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a10d97e67296614195f8b14599944dd65">&#9670;&nbsp;</a></span>~Channel()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename <a class="el" href="classipc_1_1transport_1_1Blob__sender.html">Blob_sender</a> , typename <a class="el" href="classipc_1_1transport_1_1Blob__receiver.html">Blob_receiver</a> , typename <a class="el" href="classipc_1_1transport_1_1Native__handle__sender.html">Native_handle_sender</a> , typename <a class="el" href="classipc_1_1transport_1_1Native__handle__receiver.html">Native_handle_receiver</a> &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classipc_1_1transport_1_1Channel.html">ipc::transport::Channel</a>&lt; <a class="el" href="classipc_1_1transport_1_1Blob__sender.html">Blob_sender</a>, <a class="el" href="classipc_1_1transport_1_1Blob__receiver.html">Blob_receiver</a>, <a class="el" href="classipc_1_1transport_1_1Native__handle__sender.html">Native_handle_sender</a>, <a class="el" href="classipc_1_1transport_1_1Native__handle__receiver.html">Native_handle_receiver</a> &gt;::~<a class="el" href="classipc_1_1transport_1_1Channel.html">Channel</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Destructor: synchronously invokes the destructors for each peer object moved-into <code>*this</code> via <a class="el" href="classipc_1_1transport_1_1Channel.html#aa8209a5adde4e5c2b3b1d8779fab0433" title="Completes initialization of the blobs pipe by taking ownership (via move semantics) of an object that...">init_blob_pipe()</a> and/or <a class="el" href="classipc_1_1transport_1_1Channel.html#a0e0e396759dab8c0930594eac3bb03ba" title="Analogous to 1-arg init_blob_pipe() but as applied to the handles pipe.">init_native_handle_pipe()</a>. </p>
<p >All the notes for the N concepts' destructors apply. In PEER state, for async-I/O peer objects, any pending one-off completion handlers will be invoked with <a class="el" href="namespaceipc_1_1transport_1_1error.html#adfef15ef4e76cc55d652fbd9c2797297afe29343445a7bf167cc186a44bd2c6ed" title="Async completion handler is being called prematurely, because underlying object is shutting down,...">error::Code::S_OBJECT_SHUTDOWN_ABORTED_COMPLETION_HANDLER</a> &ndash; and so on. </p>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="a53cbf199e2ed09b7afb216c96ab63fb0" name="a53cbf199e2ed09b7afb216c96ab63fb0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a53cbf199e2ed09b7afb216c96ab63fb0">&#9670;&nbsp;</a></span>async_end_sending() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename <a class="el" href="classipc_1_1transport_1_1Blob__sender.html">Blob_sender</a> , typename <a class="el" href="classipc_1_1transport_1_1Blob__receiver.html">Blob_receiver</a> , typename <a class="el" href="classipc_1_1transport_1_1Native__handle__sender.html">Native_handle_sender</a> , typename <a class="el" href="classipc_1_1transport_1_1Native__handle__receiver.html">Native_handle_receiver</a> &gt; </div>
<div class="memtemplate">
template&lt;typename Task_err &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classipc_1_1transport_1_1Channel.html">ipc::transport::Channel</a>&lt; <a class="el" href="classipc_1_1transport_1_1Blob__sender.html">Blob_sender</a>, <a class="el" href="classipc_1_1transport_1_1Blob__receiver.html">Blob_receiver</a>, <a class="el" href="classipc_1_1transport_1_1Native__handle__sender.html">Native_handle_sender</a>, <a class="el" href="classipc_1_1transport_1_1Native__handle__receiver.html">Native_handle_receiver</a> &gt;::async_end_sending </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespaceipc.html#aa3192e586cc45d3e7c22463bf2760f89">Error_code</a> *&#160;</td>
          <td class="paramname"><em>sync_err_code</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Task_err &amp;&amp;&#160;</td>
          <td class="paramname"><em>on_done_func</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Performs <code><a class="el" href="classipc_1_1transport_1_1Channel.html#aa838026c33e4e422df7cd78d3a426b6a" title="Pointer to the mutable owned Native_handle_sender_obj; null if not yet initialized.">hndl_snd()</a>-&gt;</code> and/or <code><a class="el" href="classipc_1_1transport_1_1Channel.html#a647bc9b6f8b9fb0b546cf3879cb5d4c1" title="Pointer to the mutable owned Blob_sender_obj; null if yet initialized.">blob_snd()</a>-&gt;</code> same method, synthesizing completions into one if applicable. </p>
<p >Invoke only after <a class="el" href="classipc_1_1transport_1_1Channel.html#a43c79955b3ad0eab347550b4263523ec" title="Returns true if and only if the required init_blob_pipe() and init_native_handle_pipe() calls have be...">initialized()</a> is true; else behavior is undefined. That aside:</p><ul>
<li>If not <a class="el" href="classipc_1_1transport_1_1Channel.html#a85184d886cee9b4a0d0e7b67796a238b" title="Useful for generic programming: true if and only if types imply both blobs and handles pipes are enab...">S_HAS_2_PIPES</a>, then simply forwards to the appropriate one method of the enabled pipe.</li>
<li>If <a class="el" href="classipc_1_1transport_1_1Channel.html#a85184d886cee9b4a0d0e7b67796a238b" title="Useful for generic programming: true if and only if types imply both blobs and handles pipes are enab...">S_HAS_2_PIPES</a>:<ul>
<li><code>on_done_func()</code> is invoked (exactly once) if and only if both forwarded methods have completed.<ul>
<li>If 1-2 completions do not occur, it is not invoked.</li>
</ul>
</li>
<li>If that occurs, it is invoked in-place of the 2nd completion handler (chronologically in order of completion).</li>
<li>The <code>Error_code</code> passed to <code>on_done_func()</code> is:<ul>
<li>falsy (success) if and only both completions were successful;</li>
<li>if one failed but not the other, the truthy <code>Error_code</code> from the failed completion;</li>
<li>if both failed, the truthy <code>Error_code</code> from the first failed completion.</li>
</ul>
</li>
</ul>
</li>
</ul>
<p >"Completion" in this case means the first (and only) one to occur for each pipe:</p><ul>
<li>Its individual <code>.<a class="el" href="classipc_1_1transport_1_1Channel.html#a37fcdfdbefd8ee7e374b0596782ad128" title="Performs hndl_snd()-&gt; and/or blob_snd()-&gt; same method, synthesizing completion handlers into one if a...">async_end_sending()</a></code> yielded synchronous (immediate) completion as opposed to <a class="el" href="namespaceipc_1_1transport_1_1error.html#adfef15ef4e76cc55d652fbd9c2797297aa667487757f9d6300f6888bac40bcc24" title="A sync_io operation could not immediately complete; it will complete contingent on active async-wait ...">error::Code::S_SYNC_IO_WOULD_BLOCK</a>. Or:</li>
<li>It returned WOULD_BLOCK, but later (via <code><a class="el" href="namespaceipc_1_1transport_1_1sync__io.html" title="sync_io-pattern counterparts to async-I/O-pattern object types in parent namespace ipc::transport.">sync_io</a></code>-pattern machinery) its completion handler executed.</li>
</ul>
<p >Behavior is undefined (assertion may trip) if there are 2 pipes enabled; and one's <code>.<a class="el" href="classipc_1_1transport_1_1Channel.html#a37fcdfdbefd8ee7e374b0596782ad128" title="Performs hndl_snd()-&gt; and/or blob_snd()-&gt; same method, synthesizing completion handlers into one if a...">async_end_sending()</a></code> returns <code>false</code> (dupe call), while the other <code>true</code>. This will not occur, if you cleanly use the <a class="el" href="classipc_1_1transport_1_1Channel.html" title="Peer to a bundle of 1-2 full-duplex pipe(s), one for transmitting unstructured binary blobs; the othe...">Channel</a> API directly on <code>*this</code> only, as opposed to shenanigans via non-<code>const</code> <a class="el" href="classipc_1_1transport_1_1Channel.html#a647bc9b6f8b9fb0b546cf3879cb5d4c1" title="Pointer to the mutable owned Blob_sender_obj; null if yet initialized.">blob_snd()</a>, <a class="el" href="classipc_1_1transport_1_1Channel.html#a87fd94fa483cabd78059a3d1d094880d" title="Pointer to the mutable owned Blob_receiver_obj; null if not yet initialized.">blob_rcv()</a>, etc.</p>
<p >Compilable only if <a class="el" href="classipc_1_1transport_1_1Channel.html#ae5be240d29389d7b728950e85df0704e" title="Useful for generic programming: true &lt;=&gt; each non-Null_peer peer type (Blob_sender_obj,...">S_IS_SYNC_IO_OBJ</a>.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Task_err</td><td>See concept API. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">sync_err_code</td><td>See concept API. Do realize <a class="el" href="namespaceipc_1_1transport_1_1error.html#adfef15ef4e76cc55d652fbd9c2797297aa667487757f9d6300f6888bac40bcc24" title="A sync_io operation could not immediately complete; it will complete contingent on active async-wait ...">error::Code::S_SYNC_IO_WOULD_BLOCK</a> <em>is</em> still an error, so if this pointer is null, then would-block <em>will</em> make this throw. </td></tr>
    <tr><td class="paramname">on_done_func</td><td>See above. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>If one forwarded invocation: returns what it returned. If two forwarded invocations: returns <code>true</code> if both returned <code>true</code>; <code>false</code> if both returned <code>false</code>; behavior undefined if they returned conflicting values. </dd></dl>

</div>
</div>
<a id="a37fcdfdbefd8ee7e374b0596782ad128" name="a37fcdfdbefd8ee7e374b0596782ad128"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a37fcdfdbefd8ee7e374b0596782ad128">&#9670;&nbsp;</a></span>async_end_sending() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename <a class="el" href="classipc_1_1transport_1_1Blob__sender.html">Blob_sender</a> , typename <a class="el" href="classipc_1_1transport_1_1Blob__receiver.html">Blob_receiver</a> , typename <a class="el" href="classipc_1_1transport_1_1Native__handle__sender.html">Native_handle_sender</a> , typename <a class="el" href="classipc_1_1transport_1_1Native__handle__receiver.html">Native_handle_receiver</a> &gt; </div>
<div class="memtemplate">
template&lt;typename Task_err &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classipc_1_1transport_1_1Channel.html">ipc::transport::Channel</a>&lt; <a class="el" href="classipc_1_1transport_1_1Blob__sender.html">Blob_sender</a>, <a class="el" href="classipc_1_1transport_1_1Blob__receiver.html">Blob_receiver</a>, <a class="el" href="classipc_1_1transport_1_1Native__handle__sender.html">Native_handle_sender</a>, <a class="el" href="classipc_1_1transport_1_1Native__handle__receiver.html">Native_handle_receiver</a> &gt;::async_end_sending </td>
          <td>(</td>
          <td class="paramtype">Task_err &amp;&amp;&#160;</td>
          <td class="paramname"><em>on_done_func</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Performs <code><a class="el" href="classipc_1_1transport_1_1Channel.html#aa838026c33e4e422df7cd78d3a426b6a" title="Pointer to the mutable owned Native_handle_sender_obj; null if not yet initialized.">hndl_snd()</a>-&gt;</code> and/or <code><a class="el" href="classipc_1_1transport_1_1Channel.html#a647bc9b6f8b9fb0b546cf3879cb5d4c1" title="Pointer to the mutable owned Blob_sender_obj; null if yet initialized.">blob_snd()</a>-&gt;</code> same method, synthesizing completion handlers into one if applicable. </p>
<p >Invoke only after <a class="el" href="classipc_1_1transport_1_1Channel.html#a43c79955b3ad0eab347550b4263523ec" title="Returns true if and only if the required init_blob_pipe() and init_native_handle_pipe() calls have be...">initialized()</a> is true; else behavior is undefined. That aside:</p><ul>
<li>If not <a class="el" href="classipc_1_1transport_1_1Channel.html#a85184d886cee9b4a0d0e7b67796a238b" title="Useful for generic programming: true if and only if types imply both blobs and handles pipes are enab...">S_HAS_2_PIPES</a>, then simply forwards to the appropriate one method of the enabled pipe.</li>
<li>If <a class="el" href="classipc_1_1transport_1_1Channel.html#a85184d886cee9b4a0d0e7b67796a238b" title="Useful for generic programming: true if and only if types imply both blobs and handles pipes are enab...">S_HAS_2_PIPES</a>:<ul>
<li><code>on_done_func()</code> is invoked (exactly once) if and only if both forwarded methods have completed.<ul>
<li>If 1-2 completions do not occur, it is not invoked.</li>
</ul>
</li>
<li>If that occurs, it is invoked in-place of the 2nd completion handler (chronologically in order of completion).</li>
<li>The <code>Error_code</code> passed to <code>on_done_func()</code> is:<ul>
<li>falsy (success) if and only both completions were successful;</li>
<li>if one failed but not the other, the truthy <code>Error_code</code> from the failed completion;</li>
<li>if both failed, the truthy <code>Error_code</code> from the first failed completion.</li>
</ul>
</li>
</ul>
</li>
</ul>
<p >Behavior is undefined (assertion may trip) if there are 2 pipes enabled; and one's <code>.<a class="el" href="classipc_1_1transport_1_1Channel.html#a37fcdfdbefd8ee7e374b0596782ad128" title="Performs hndl_snd()-&gt; and/or blob_snd()-&gt; same method, synthesizing completion handlers into one if a...">async_end_sending()</a></code> returns <code>false</code> (dupe call), while the other <code>true</code>. This will not occur, if you cleanly use the <a class="el" href="classipc_1_1transport_1_1Channel.html" title="Peer to a bundle of 1-2 full-duplex pipe(s), one for transmitting unstructured binary blobs; the othe...">Channel</a> API directly on <code>*this</code> only, as opposed to shenanigans via non-<code>const</code> <a class="el" href="classipc_1_1transport_1_1Channel.html#a647bc9b6f8b9fb0b546cf3879cb5d4c1" title="Pointer to the mutable owned Blob_sender_obj; null if yet initialized.">blob_snd()</a>, <a class="el" href="classipc_1_1transport_1_1Channel.html#a87fd94fa483cabd78059a3d1d094880d" title="Pointer to the mutable owned Blob_receiver_obj; null if not yet initialized.">blob_rcv()</a>, etc.</p>
<p >Compilable only if <a class="el" href="classipc_1_1transport_1_1Channel.html#a9f75b20b07eff47a69c2b1dbe5c85f84" title="It equals the reverse of S_IS_SYNC_IO_OBJ.">S_IS_ASYNC_IO_OBJ</a>.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Task_err</td><td>See concept API. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">on_done_func</td><td>See above. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>If one forwarded invocation: returns what it returned. If two forwarded invocations: returns <code>true</code> if both returned <code>true</code>; <code>false</code> if both returned <code>false</code>; behavior undefined if they returned conflicting values. </dd></dl>

</div>
</div>
<a id="add016cbac936d3da6c861755ac88b7a2" name="add016cbac936d3da6c861755ac88b7a2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#add016cbac936d3da6c861755ac88b7a2">&#9670;&nbsp;</a></span>async_io_obj()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename <a class="el" href="classipc_1_1transport_1_1Blob__sender.html">Blob_sender</a> , typename <a class="el" href="classipc_1_1transport_1_1Blob__receiver.html">Blob_receiver</a> , typename <a class="el" href="classipc_1_1transport_1_1Native__handle__sender.html">Native_handle_sender</a> , typename <a class="el" href="classipc_1_1transport_1_1Native__handle__receiver.html">Native_handle_receiver</a> &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classipc_1_1transport_1_1Channel.html">Channel</a>&lt; <a class="el" href="classipc_1_1transport_1_1Blob__sender.html">Blob_sender</a>, <a class="el" href="classipc_1_1transport_1_1Blob__receiver.html">Blob_receiver</a>, <a class="el" href="classipc_1_1transport_1_1Native__handle__sender.html">Native_handle_sender</a>, <a class="el" href="classipc_1_1transport_1_1Native__handle__receiver.html">Native_handle_receiver</a> &gt;<a class="el" href="classipc_1_1transport_1_1Channel.html#ab6f7d14037e228e24a8fbd33b41e1c82">::Async_io_obj</a> <a class="el" href="classipc_1_1transport_1_1Channel.html">ipc::transport::Channel</a>&lt; <a class="el" href="classipc_1_1transport_1_1Blob__sender.html">Blob_sender</a>, <a class="el" href="classipc_1_1transport_1_1Blob__receiver.html">Blob_receiver</a>, <a class="el" href="classipc_1_1transport_1_1Native__handle__sender.html">Native_handle_sender</a>, <a class="el" href="classipc_1_1transport_1_1Native__handle__receiver.html">Native_handle_receiver</a> &gt;::async_io_obj</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Converts a <code><a class="el" href="namespaceipc_1_1transport_1_1sync__io.html" title="sync_io-pattern counterparts to async-I/O-pattern object types in parent namespace ipc::transport.">sync_io</a></code>-peer-bearing <code>*this</code> to a returned async-I/O-peer-bearing new <a class="el" href="classipc_1_1transport_1_1Channel.html" title="Peer to a bundle of 1-2 full-duplex pipe(s), one for transmitting unstructured binary blobs; the othe...">Channel</a>, while <code>*this</code> becomes as-if default-cted. </p>
<p >Compilable only if <a class="el" href="classipc_1_1transport_1_1Channel.html#ae5be240d29389d7b728950e85df0704e" title="Useful for generic programming: true &lt;=&gt; each non-Null_peer peer type (Blob_sender_obj,...">S_IS_SYNC_IO_OBJ</a>, and usable only after <a class="el" href="classipc_1_1transport_1_1Channel.html#a43c79955b3ad0eab347550b4263523ec" title="Returns true if and only if the required init_blob_pipe() and init_native_handle_pipe() calls have be...">initialized()</a>, returns <code><a class="el" href="classipc_1_1transport_1_1Channel.html" title="Peer to a bundle of 1-2 full-duplex pipe(s), one for transmitting unstructured binary blobs; the othe...">Channel</a></code> with <a class="el" href="classipc_1_1transport_1_1Channel.html#a9f75b20b07eff47a69c2b1dbe5c85f84" title="It equals the reverse of S_IS_SYNC_IO_OBJ.">S_IS_ASYNC_IO_OBJ</a>, each peer object of which is created via its respective <code><a class="el" href="namespaceipc_1_1transport_1_1sync__io.html" title="sync_io-pattern counterparts to async-I/O-pattern object types in parent namespace ipc::transport.">sync_io</a></code>-core-adopting ctors. (For example: <code>transport::Blob_sender(transport::sync_io::Blob_sender&amp;&amp;)</code>.)</p>
<p >If not <a class="el" href="classipc_1_1transport_1_1Channel.html#a43c79955b3ad0eab347550b4263523ec" title="Returns true if and only if the required init_blob_pipe() and init_native_handle_pipe() calls have be...">initialized()</a> behavior is undefined (assertion may trip).</p>
<p >Useful, in particular, to make an async-I/O <a class="el" href="classipc_1_1transport_1_1Channel.html" title="Peer to a bundle of 1-2 full-duplex pipe(s), one for transmitting unstructured binary blobs; the othe...">Channel</a> from a <a class="el" href="classipc_1_1transport_1_1Channel.html" title="Peer to a bundle of 1-2 full-duplex pipe(s), one for transmitting unstructured binary blobs; the othe...">Channel</a> obtained from a <a class="el" href="classipc_1_1session_1_1Session.html" title="A documentation-only concept defining the local side of an IPC conversation (session) with another en...">session::Session</a>.</p>
<dl class="section return"><dt>Returns</dt><dd>See above. </dd></dl>

</div>
</div>
<a id="a1e6d2b4ec45f629b731fe30f46aeca97" name="a1e6d2b4ec45f629b731fe30f46aeca97"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1e6d2b4ec45f629b731fe30f46aeca97">&#9670;&nbsp;</a></span>async_receive_blob()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename <a class="el" href="classipc_1_1transport_1_1Blob__sender.html">Blob_sender</a> , typename <a class="el" href="classipc_1_1transport_1_1Blob__receiver.html">Blob_receiver</a> , typename <a class="el" href="classipc_1_1transport_1_1Native__handle__sender.html">Native_handle_sender</a> , typename <a class="el" href="classipc_1_1transport_1_1Native__handle__receiver.html">Native_handle_receiver</a> &gt; </div>
<div class="memtemplate">
template&lt;typename... Args&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classipc_1_1transport_1_1Channel.html">ipc::transport::Channel</a>&lt; <a class="el" href="classipc_1_1transport_1_1Blob__sender.html">Blob_sender</a>, <a class="el" href="classipc_1_1transport_1_1Blob__receiver.html">Blob_receiver</a>, <a class="el" href="classipc_1_1transport_1_1Native__handle__sender.html">Native_handle_sender</a>, <a class="el" href="classipc_1_1transport_1_1Native__handle__receiver.html">Native_handle_receiver</a> &gt;::async_receive_blob </td>
          <td>(</td>
          <td class="paramtype">Args &amp;&amp;...&#160;</td>
          <td class="paramname"><em>args</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Yields <code><a class="el" href="classipc_1_1transport_1_1Channel.html#a87fd94fa483cabd78059a3d1d094880d" title="Pointer to the mutable owned Blob_receiver_obj; null if not yet initialized.">blob_rcv()</a>-&gt;</code> same method. </p>
<p ><a class="el" href="classipc_1_1transport_1_1Blob__receiver.html" title="A documentation-only concept defining the behavior of an object capable of reliably/in-order receivin...">Blob_receiver</a> versus <a class="el" href="classipc_1_1transport_1_1sync__io_1_1Blob__receiver.html" title="A documentation-only concept: what transport::Blob_receiver is to transport::Native_handle_receiver (...">sync_io::Blob_receiver</a> signatures differ slightly; therefore this uses param-pack perfect forwarding.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Args</td><td>See above. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">args</td><td>See concept API. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>See concept API. </dd></dl>

</div>
</div>
<a id="a288e61b4e19b9621f4f978fab88bcab0" name="a288e61b4e19b9621f4f978fab88bcab0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a288e61b4e19b9621f4f978fab88bcab0">&#9670;&nbsp;</a></span>async_receive_native_handle()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename <a class="el" href="classipc_1_1transport_1_1Blob__sender.html">Blob_sender</a> , typename <a class="el" href="classipc_1_1transport_1_1Blob__receiver.html">Blob_receiver</a> , typename <a class="el" href="classipc_1_1transport_1_1Native__handle__sender.html">Native_handle_sender</a> , typename <a class="el" href="classipc_1_1transport_1_1Native__handle__receiver.html">Native_handle_receiver</a> &gt; </div>
<div class="memtemplate">
template&lt;typename... Args&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classipc_1_1transport_1_1Channel.html">ipc::transport::Channel</a>&lt; <a class="el" href="classipc_1_1transport_1_1Blob__sender.html">Blob_sender</a>, <a class="el" href="classipc_1_1transport_1_1Blob__receiver.html">Blob_receiver</a>, <a class="el" href="classipc_1_1transport_1_1Native__handle__sender.html">Native_handle_sender</a>, <a class="el" href="classipc_1_1transport_1_1Native__handle__receiver.html">Native_handle_receiver</a> &gt;::async_receive_native_handle </td>
          <td>(</td>
          <td class="paramtype">Args &amp;&amp;...&#160;</td>
          <td class="paramname"><em>args</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Yields <code><a class="el" href="classipc_1_1transport_1_1Channel.html#af4c9cd7b02193fa2e8bf1742ab87111a" title="Pointer to the mutable owned Native_handle_receiver_obj; null if not yet initialized.">hndl_rcv()</a>-&gt;</code> same method. </p>
<p ><a class="el" href="classipc_1_1transport_1_1Native__handle__receiver.html" title="A documentation-only concept defining the behavior of an object capable of reliably/in-order receivin...">Native_handle_receiver</a> versus <a class="el" href="classipc_1_1transport_1_1sync__io_1_1Native__handle__receiver.html" title="A documentation-only concept defining the behavior of an object that is the sync_io-pattern counterpa...">sync_io::Native_handle_receiver</a> signatures differ slightly; therefore this uses param-pack perfect forwarding.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Args</td><td>See above. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">args</td><td>See concept API. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>See concept API. </dd></dl>

</div>
</div>
<a id="a290395d720167759bfa1eda1e86bf123" name="a290395d720167759bfa1eda1e86bf123"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a290395d720167759bfa1eda1e86bf123">&#9670;&nbsp;</a></span>auto_ping()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename <a class="el" href="classipc_1_1transport_1_1Blob__sender.html">Blob_sender</a> , typename <a class="el" href="classipc_1_1transport_1_1Blob__receiver.html">Blob_receiver</a> , typename <a class="el" href="classipc_1_1transport_1_1Native__handle__sender.html">Native_handle_sender</a> , typename <a class="el" href="classipc_1_1transport_1_1Native__handle__receiver.html">Native_handle_receiver</a> &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classipc_1_1transport_1_1Channel.html">ipc::transport::Channel</a>&lt; <a class="el" href="classipc_1_1transport_1_1Blob__sender.html">Blob_sender</a>, <a class="el" href="classipc_1_1transport_1_1Blob__receiver.html">Blob_receiver</a>, <a class="el" href="classipc_1_1transport_1_1Native__handle__sender.html">Native_handle_sender</a>, <a class="el" href="classipc_1_1transport_1_1Native__handle__receiver.html">Native_handle_receiver</a> &gt;::auto_ping </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespaceipc_1_1util.html#ac66141280c3b7295a86b65209f31cc58">util::Fine_duration</a>&#160;</td>
          <td class="paramname"><em>period</em> = <code>boost::chrono::seconds(2)</code></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Performs <code><a class="el" href="classipc_1_1transport_1_1Channel.html#aa838026c33e4e422df7cd78d3a426b6a" title="Pointer to the mutable owned Native_handle_sender_obj; null if not yet initialized.">hndl_snd()</a>-&gt;</code> and/or <code><a class="el" href="classipc_1_1transport_1_1Channel.html#a647bc9b6f8b9fb0b546cf3879cb5d4c1" title="Pointer to the mutable owned Blob_sender_obj; null if yet initialized.">blob_snd()</a>-&gt;</code> same method, returning <code>true</code> if all (1-2) invoked methods returned <code>true</code>; <code>false</code> conversely. </p>
<p >As with <a class="el" href="classipc_1_1transport_1_1Channel.html#a37fcdfdbefd8ee7e374b0596782ad128" title="Performs hndl_snd()-&gt; and/or blob_snd()-&gt; same method, synthesizing completion handlers into one if a...">async_end_sending()</a> (either overload) behavior is undefined (assertion may trip), if one returned <code>true</code> and the other <code>false</code>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">period</td><td>See concept API. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>See above. </dd></dl>

</div>
</div>
<a id="a87fd94fa483cabd78059a3d1d094880d" name="a87fd94fa483cabd78059a3d1d094880d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a87fd94fa483cabd78059a3d1d094880d">&#9670;&nbsp;</a></span>blob_rcv() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename <a class="el" href="classipc_1_1transport_1_1Blob__sender.html">Blob_sender</a> , typename <a class="el" href="classipc_1_1transport_1_1Blob__receiver.html">Blob_receiver</a> , typename <a class="el" href="classipc_1_1transport_1_1Native__handle__sender.html">Native_handle_sender</a> , typename <a class="el" href="classipc_1_1transport_1_1Native__handle__receiver.html">Native_handle_receiver</a> &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classipc_1_1transport_1_1Channel.html">Channel</a>&lt; <a class="el" href="classipc_1_1transport_1_1Blob__sender.html">Blob_sender</a>, <a class="el" href="classipc_1_1transport_1_1Blob__receiver.html">Blob_receiver</a>, <a class="el" href="classipc_1_1transport_1_1Native__handle__sender.html">Native_handle_sender</a>, <a class="el" href="classipc_1_1transport_1_1Native__handle__receiver.html">Native_handle_receiver</a> &gt;<a class="el" href="classipc_1_1transport_1_1Channel.html#aa9a7ec2d2eedfc3b6a1d2edfb05ea6d1">::Blob_receiver_obj</a> * <a class="el" href="classipc_1_1transport_1_1Channel.html">ipc::transport::Channel</a>&lt; <a class="el" href="classipc_1_1transport_1_1Blob__sender.html">Blob_sender</a>, <a class="el" href="classipc_1_1transport_1_1Blob__receiver.html">Blob_receiver</a>, <a class="el" href="classipc_1_1transport_1_1Native__handle__sender.html">Native_handle_sender</a>, <a class="el" href="classipc_1_1transport_1_1Native__handle__receiver.html">Native_handle_receiver</a> &gt;::blob_rcv</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Pointer to the mutable owned <a class="el" href="classipc_1_1transport_1_1Channel.html#aa9a7ec2d2eedfc3b6a1d2edfb05ea6d1" title="Alias for Blob_receiver template parameter.">Blob_receiver_obj</a>; null if not yet initialized. </p>
<p >Compilable only if <a class="el" href="classipc_1_1transport_1_1Channel.html#aa9a7ec2d2eedfc3b6a1d2edfb05ea6d1" title="Alias for Blob_receiver template parameter.">Blob_receiver_obj</a> is not <a class="el" href="classipc_1_1transport_1_1Null__peer.html" title="Dummy type for use as a template param to Channel when either the blobs pipe or handles pipe is disab...">Null_peer</a> (<a class="el" href="classipc_1_1transport_1_1Channel.html#aafb0767df5f1dfb535c9467ce717f93f" title="Useful for generic programming: true if and only if types imply at least the blobs pipe is enabled.">S_HAS_BLOB_PIPE</a>).</p>
<dl class="section return"><dt>Returns</dt><dd>See above. </dd></dl>

</div>
</div>
<a id="a5a34248f5e11a1dd2d5a52e07ae836e7" name="a5a34248f5e11a1dd2d5a52e07ae836e7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5a34248f5e11a1dd2d5a52e07ae836e7">&#9670;&nbsp;</a></span>blob_rcv() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename <a class="el" href="classipc_1_1transport_1_1Blob__sender.html">Blob_sender</a> , typename <a class="el" href="classipc_1_1transport_1_1Blob__receiver.html">Blob_receiver</a> , typename <a class="el" href="classipc_1_1transport_1_1Native__handle__sender.html">Native_handle_sender</a> , typename <a class="el" href="classipc_1_1transport_1_1Native__handle__receiver.html">Native_handle_receiver</a> &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classipc_1_1transport_1_1Channel.html">Channel</a>&lt; <a class="el" href="classipc_1_1transport_1_1Blob__sender.html">Blob_sender</a>, <a class="el" href="classipc_1_1transport_1_1Blob__receiver.html">Blob_receiver</a>, <a class="el" href="classipc_1_1transport_1_1Native__handle__sender.html">Native_handle_sender</a>, <a class="el" href="classipc_1_1transport_1_1Native__handle__receiver.html">Native_handle_receiver</a> &gt;<a class="el" href="classipc_1_1transport_1_1Channel.html#aa9a7ec2d2eedfc3b6a1d2edfb05ea6d1">::Blob_receiver_obj</a> * <a class="el" href="classipc_1_1transport_1_1Channel.html">ipc::transport::Channel</a>&lt; <a class="el" href="classipc_1_1transport_1_1Blob__sender.html">Blob_sender</a>, <a class="el" href="classipc_1_1transport_1_1Blob__receiver.html">Blob_receiver</a>, <a class="el" href="classipc_1_1transport_1_1Native__handle__sender.html">Native_handle_sender</a>, <a class="el" href="classipc_1_1transport_1_1Native__handle__receiver.html">Native_handle_receiver</a> &gt;::blob_rcv</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Pointer to the immutable owned <a class="el" href="classipc_1_1transport_1_1Channel.html#aa9a7ec2d2eedfc3b6a1d2edfb05ea6d1" title="Alias for Blob_receiver template parameter.">Blob_receiver_obj</a>; null if not yet initialized. </p>
<p >Compilable only if <a class="el" href="classipc_1_1transport_1_1Channel.html#aa9a7ec2d2eedfc3b6a1d2edfb05ea6d1" title="Alias for Blob_receiver template parameter.">Blob_receiver_obj</a> is not <a class="el" href="classipc_1_1transport_1_1Null__peer.html" title="Dummy type for use as a template param to Channel when either the blobs pipe or handles pipe is disab...">Null_peer</a> (<a class="el" href="classipc_1_1transport_1_1Channel.html#aafb0767df5f1dfb535c9467ce717f93f" title="Useful for generic programming: true if and only if types imply at least the blobs pipe is enabled.">S_HAS_BLOB_PIPE</a>).</p>
<dl class="section return"><dt>Returns</dt><dd>See above. </dd></dl>

</div>
</div>
<a id="a647bc9b6f8b9fb0b546cf3879cb5d4c1" name="a647bc9b6f8b9fb0b546cf3879cb5d4c1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a647bc9b6f8b9fb0b546cf3879cb5d4c1">&#9670;&nbsp;</a></span>blob_snd() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename <a class="el" href="classipc_1_1transport_1_1Blob__sender.html">Blob_sender</a> , typename <a class="el" href="classipc_1_1transport_1_1Blob__receiver.html">Blob_receiver</a> , typename <a class="el" href="classipc_1_1transport_1_1Native__handle__sender.html">Native_handle_sender</a> , typename <a class="el" href="classipc_1_1transport_1_1Native__handle__receiver.html">Native_handle_receiver</a> &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classipc_1_1transport_1_1Channel.html">Channel</a>&lt; <a class="el" href="classipc_1_1transport_1_1Blob__sender.html">Blob_sender</a>, <a class="el" href="classipc_1_1transport_1_1Blob__receiver.html">Blob_receiver</a>, <a class="el" href="classipc_1_1transport_1_1Native__handle__sender.html">Native_handle_sender</a>, <a class="el" href="classipc_1_1transport_1_1Native__handle__receiver.html">Native_handle_receiver</a> &gt;<a class="el" href="classipc_1_1transport_1_1Channel.html#a82746276cc7379a866b12d529780900f">::Blob_sender_obj</a> * <a class="el" href="classipc_1_1transport_1_1Channel.html">ipc::transport::Channel</a>&lt; <a class="el" href="classipc_1_1transport_1_1Blob__sender.html">Blob_sender</a>, <a class="el" href="classipc_1_1transport_1_1Blob__receiver.html">Blob_receiver</a>, <a class="el" href="classipc_1_1transport_1_1Native__handle__sender.html">Native_handle_sender</a>, <a class="el" href="classipc_1_1transport_1_1Native__handle__receiver.html">Native_handle_receiver</a> &gt;::blob_snd</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Pointer to the mutable owned <a class="el" href="classipc_1_1transport_1_1Channel.html#a82746276cc7379a866b12d529780900f" title="Alias for Blob_sender template parameter.">Blob_sender_obj</a>; null if yet initialized. </p>
<p >Compilable only if <a class="el" href="classipc_1_1transport_1_1Channel.html#a82746276cc7379a866b12d529780900f" title="Alias for Blob_sender template parameter.">Blob_sender_obj</a> is not <a class="el" href="classipc_1_1transport_1_1Null__peer.html" title="Dummy type for use as a template param to Channel when either the blobs pipe or handles pipe is disab...">Null_peer</a> (<a class="el" href="classipc_1_1transport_1_1Channel.html#aafb0767df5f1dfb535c9467ce717f93f" title="Useful for generic programming: true if and only if types imply at least the blobs pipe is enabled.">S_HAS_BLOB_PIPE</a>).</p>
<dl class="section return"><dt>Returns</dt><dd>See above. </dd></dl>

</div>
</div>
<a id="a9e1a2db827082d9467bf45ae0bbf64d3" name="a9e1a2db827082d9467bf45ae0bbf64d3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9e1a2db827082d9467bf45ae0bbf64d3">&#9670;&nbsp;</a></span>blob_snd() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename <a class="el" href="classipc_1_1transport_1_1Blob__sender.html">Blob_sender</a> , typename <a class="el" href="classipc_1_1transport_1_1Blob__receiver.html">Blob_receiver</a> , typename <a class="el" href="classipc_1_1transport_1_1Native__handle__sender.html">Native_handle_sender</a> , typename <a class="el" href="classipc_1_1transport_1_1Native__handle__receiver.html">Native_handle_receiver</a> &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classipc_1_1transport_1_1Channel.html">Channel</a>&lt; <a class="el" href="classipc_1_1transport_1_1Blob__sender.html">Blob_sender</a>, <a class="el" href="classipc_1_1transport_1_1Blob__receiver.html">Blob_receiver</a>, <a class="el" href="classipc_1_1transport_1_1Native__handle__sender.html">Native_handle_sender</a>, <a class="el" href="classipc_1_1transport_1_1Native__handle__receiver.html">Native_handle_receiver</a> &gt;<a class="el" href="classipc_1_1transport_1_1Channel.html#a82746276cc7379a866b12d529780900f">::Blob_sender_obj</a> * <a class="el" href="classipc_1_1transport_1_1Channel.html">ipc::transport::Channel</a>&lt; <a class="el" href="classipc_1_1transport_1_1Blob__sender.html">Blob_sender</a>, <a class="el" href="classipc_1_1transport_1_1Blob__receiver.html">Blob_receiver</a>, <a class="el" href="classipc_1_1transport_1_1Native__handle__sender.html">Native_handle_sender</a>, <a class="el" href="classipc_1_1transport_1_1Native__handle__receiver.html">Native_handle_receiver</a> &gt;::blob_snd</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Pointer to the immutable owned <a class="el" href="classipc_1_1transport_1_1Channel.html#a82746276cc7379a866b12d529780900f" title="Alias for Blob_sender template parameter.">Blob_sender_obj</a>; null if yet initialized. </p>
<p >Compilable only if <a class="el" href="classipc_1_1transport_1_1Channel.html#a82746276cc7379a866b12d529780900f" title="Alias for Blob_sender template parameter.">Blob_sender_obj</a> is not <a class="el" href="classipc_1_1transport_1_1Null__peer.html" title="Dummy type for use as a template param to Channel when either the blobs pipe or handles pipe is disab...">Null_peer</a> (<a class="el" href="classipc_1_1transport_1_1Channel.html#aafb0767df5f1dfb535c9467ce717f93f" title="Useful for generic programming: true if and only if types imply at least the blobs pipe is enabled.">S_HAS_BLOB_PIPE</a>).</p>
<dl class="section return"><dt>Returns</dt><dd>See above. </dd></dl>

</div>
</div>
<a id="a060e37759dc6f0a00d92fc23a0a09f4f" name="a060e37759dc6f0a00d92fc23a0a09f4f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a060e37759dc6f0a00d92fc23a0a09f4f">&#9670;&nbsp;</a></span>end_sending()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename <a class="el" href="classipc_1_1transport_1_1Blob__sender.html">Blob_sender</a> , typename <a class="el" href="classipc_1_1transport_1_1Blob__receiver.html">Blob_receiver</a> , typename <a class="el" href="classipc_1_1transport_1_1Native__handle__sender.html">Native_handle_sender</a> , typename <a class="el" href="classipc_1_1transport_1_1Native__handle__receiver.html">Native_handle_receiver</a> &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classipc_1_1transport_1_1Channel.html">ipc::transport::Channel</a>&lt; <a class="el" href="classipc_1_1transport_1_1Blob__sender.html">Blob_sender</a>, <a class="el" href="classipc_1_1transport_1_1Blob__receiver.html">Blob_receiver</a>, <a class="el" href="classipc_1_1transport_1_1Native__handle__sender.html">Native_handle_sender</a>, <a class="el" href="classipc_1_1transport_1_1Native__handle__receiver.html">Native_handle_receiver</a> &gt;::end_sending</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Performs <code><a class="el" href="classipc_1_1transport_1_1Channel.html#aa838026c33e4e422df7cd78d3a426b6a" title="Pointer to the mutable owned Native_handle_sender_obj; null if not yet initialized.">hndl_snd()</a>-&gt;</code> and/or <code><a class="el" href="classipc_1_1transport_1_1Channel.html#a647bc9b6f8b9fb0b546cf3879cb5d4c1" title="Pointer to the mutable owned Blob_sender_obj; null if yet initialized.">blob_snd()</a>-&gt;</code> same method, returning <code>true</code> if all (1-2) invoked methods returned <code>true</code>; <code>false</code> conversely. </p>
<p >As with <a class="el" href="classipc_1_1transport_1_1Channel.html#a37fcdfdbefd8ee7e374b0596782ad128" title="Performs hndl_snd()-&gt; and/or blob_snd()-&gt; same method, synthesizing completion handlers into one if a...">async_end_sending()</a> (either overload) behavior is undefined (assertion may trip), if one returned <code>true</code> and the other <code>false</code>.</p>
<dl class="section return"><dt>Returns</dt><dd>See above. </dd></dl>

</div>
</div>
<a id="af4c9cd7b02193fa2e8bf1742ab87111a" name="af4c9cd7b02193fa2e8bf1742ab87111a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af4c9cd7b02193fa2e8bf1742ab87111a">&#9670;&nbsp;</a></span>hndl_rcv() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename <a class="el" href="classipc_1_1transport_1_1Blob__sender.html">Blob_sender</a> , typename <a class="el" href="classipc_1_1transport_1_1Blob__receiver.html">Blob_receiver</a> , typename <a class="el" href="classipc_1_1transport_1_1Native__handle__sender.html">Native_handle_sender</a> , typename <a class="el" href="classipc_1_1transport_1_1Native__handle__receiver.html">Native_handle_receiver</a> &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classipc_1_1transport_1_1Channel.html">Channel</a>&lt; <a class="el" href="classipc_1_1transport_1_1Blob__sender.html">Blob_sender</a>, <a class="el" href="classipc_1_1transport_1_1Blob__receiver.html">Blob_receiver</a>, <a class="el" href="classipc_1_1transport_1_1Native__handle__sender.html">Native_handle_sender</a>, <a class="el" href="classipc_1_1transport_1_1Native__handle__receiver.html">Native_handle_receiver</a> &gt;<a class="el" href="classipc_1_1transport_1_1Channel.html#ad011bfbcfc226b9a32d97188485d9a22">::Native_handle_receiver_obj</a> * <a class="el" href="classipc_1_1transport_1_1Channel.html">ipc::transport::Channel</a>&lt; <a class="el" href="classipc_1_1transport_1_1Blob__sender.html">Blob_sender</a>, <a class="el" href="classipc_1_1transport_1_1Blob__receiver.html">Blob_receiver</a>, <a class="el" href="classipc_1_1transport_1_1Native__handle__sender.html">Native_handle_sender</a>, <a class="el" href="classipc_1_1transport_1_1Native__handle__receiver.html">Native_handle_receiver</a> &gt;::hndl_rcv</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Pointer to the mutable owned <a class="el" href="classipc_1_1transport_1_1Channel.html#ad011bfbcfc226b9a32d97188485d9a22" title="Alias for Native_handle_receiver template parameter.">Native_handle_receiver_obj</a>; null if not yet initialized. </p>
<p >Compilable only if <a class="el" href="classipc_1_1transport_1_1Channel.html#ad011bfbcfc226b9a32d97188485d9a22" title="Alias for Native_handle_receiver template parameter.">Native_handle_receiver_obj</a> is not <a class="el" href="classipc_1_1transport_1_1Null__peer.html" title="Dummy type for use as a template param to Channel when either the blobs pipe or handles pipe is disab...">Null_peer</a> (<a class="el" href="classipc_1_1transport_1_1Channel.html#ab6decf2691a2cab6c3b5187bad1e368b" title="Useful for generic programming: true if and only if types imply at least the handles pipe is enabled.">S_HAS_NATIVE_HANDLE_PIPE</a>).</p>
<dl class="section return"><dt>Returns</dt><dd>See above. </dd></dl>

</div>
</div>
<a id="a387590af263932dbdb24bcac4b399170" name="a387590af263932dbdb24bcac4b399170"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a387590af263932dbdb24bcac4b399170">&#9670;&nbsp;</a></span>hndl_rcv() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename <a class="el" href="classipc_1_1transport_1_1Blob__sender.html">Blob_sender</a> , typename <a class="el" href="classipc_1_1transport_1_1Blob__receiver.html">Blob_receiver</a> , typename <a class="el" href="classipc_1_1transport_1_1Native__handle__sender.html">Native_handle_sender</a> , typename <a class="el" href="classipc_1_1transport_1_1Native__handle__receiver.html">Native_handle_receiver</a> &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classipc_1_1transport_1_1Channel.html">Channel</a>&lt; <a class="el" href="classipc_1_1transport_1_1Blob__sender.html">Blob_sender</a>, <a class="el" href="classipc_1_1transport_1_1Blob__receiver.html">Blob_receiver</a>, <a class="el" href="classipc_1_1transport_1_1Native__handle__sender.html">Native_handle_sender</a>, <a class="el" href="classipc_1_1transport_1_1Native__handle__receiver.html">Native_handle_receiver</a> &gt;<a class="el" href="classipc_1_1transport_1_1Channel.html#ad011bfbcfc226b9a32d97188485d9a22">::Native_handle_receiver_obj</a> * <a class="el" href="classipc_1_1transport_1_1Channel.html">ipc::transport::Channel</a>&lt; <a class="el" href="classipc_1_1transport_1_1Blob__sender.html">Blob_sender</a>, <a class="el" href="classipc_1_1transport_1_1Blob__receiver.html">Blob_receiver</a>, <a class="el" href="classipc_1_1transport_1_1Native__handle__sender.html">Native_handle_sender</a>, <a class="el" href="classipc_1_1transport_1_1Native__handle__receiver.html">Native_handle_receiver</a> &gt;::hndl_rcv</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Pointer to the immutable owned <a class="el" href="classipc_1_1transport_1_1Channel.html#ad011bfbcfc226b9a32d97188485d9a22" title="Alias for Native_handle_receiver template parameter.">Native_handle_receiver_obj</a>; null if not yet initialized. </p>
<p >Compilable only if <a class="el" href="classipc_1_1transport_1_1Channel.html#ad011bfbcfc226b9a32d97188485d9a22" title="Alias for Native_handle_receiver template parameter.">Native_handle_receiver_obj</a> is not <a class="el" href="classipc_1_1transport_1_1Null__peer.html" title="Dummy type for use as a template param to Channel when either the blobs pipe or handles pipe is disab...">Null_peer</a> (<a class="el" href="classipc_1_1transport_1_1Channel.html#ab6decf2691a2cab6c3b5187bad1e368b" title="Useful for generic programming: true if and only if types imply at least the handles pipe is enabled.">S_HAS_NATIVE_HANDLE_PIPE</a>).</p>
<dl class="section return"><dt>Returns</dt><dd>See above. </dd></dl>

</div>
</div>
<a id="aa838026c33e4e422df7cd78d3a426b6a" name="aa838026c33e4e422df7cd78d3a426b6a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa838026c33e4e422df7cd78d3a426b6a">&#9670;&nbsp;</a></span>hndl_snd() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename <a class="el" href="classipc_1_1transport_1_1Blob__sender.html">Blob_sender</a> , typename <a class="el" href="classipc_1_1transport_1_1Blob__receiver.html">Blob_receiver</a> , typename <a class="el" href="classipc_1_1transport_1_1Native__handle__sender.html">Native_handle_sender</a> , typename <a class="el" href="classipc_1_1transport_1_1Native__handle__receiver.html">Native_handle_receiver</a> &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classipc_1_1transport_1_1Channel.html">Channel</a>&lt; <a class="el" href="classipc_1_1transport_1_1Blob__sender.html">Blob_sender</a>, <a class="el" href="classipc_1_1transport_1_1Blob__receiver.html">Blob_receiver</a>, <a class="el" href="classipc_1_1transport_1_1Native__handle__sender.html">Native_handle_sender</a>, <a class="el" href="classipc_1_1transport_1_1Native__handle__receiver.html">Native_handle_receiver</a> &gt;<a class="el" href="classipc_1_1transport_1_1Channel.html#afc600491e137c9dc16c202b04885a36a">::Native_handle_sender_obj</a> * <a class="el" href="classipc_1_1transport_1_1Channel.html">ipc::transport::Channel</a>&lt; <a class="el" href="classipc_1_1transport_1_1Blob__sender.html">Blob_sender</a>, <a class="el" href="classipc_1_1transport_1_1Blob__receiver.html">Blob_receiver</a>, <a class="el" href="classipc_1_1transport_1_1Native__handle__sender.html">Native_handle_sender</a>, <a class="el" href="classipc_1_1transport_1_1Native__handle__receiver.html">Native_handle_receiver</a> &gt;::hndl_snd</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Pointer to the mutable owned <a class="el" href="classipc_1_1transport_1_1Channel.html#afc600491e137c9dc16c202b04885a36a" title="Alias for Native_handle_sender template parameter.">Native_handle_sender_obj</a>; null if not yet initialized. </p>
<p >Compilable only if <a class="el" href="classipc_1_1transport_1_1Channel.html#afc600491e137c9dc16c202b04885a36a" title="Alias for Native_handle_sender template parameter.">Native_handle_sender_obj</a> is not <a class="el" href="classipc_1_1transport_1_1Null__peer.html" title="Dummy type for use as a template param to Channel when either the blobs pipe or handles pipe is disab...">Null_peer</a> (<a class="el" href="classipc_1_1transport_1_1Channel.html#ab6decf2691a2cab6c3b5187bad1e368b" title="Useful for generic programming: true if and only if types imply at least the handles pipe is enabled.">S_HAS_NATIVE_HANDLE_PIPE</a>).</p>
<dl class="section return"><dt>Returns</dt><dd>See above. </dd></dl>

</div>
</div>
<a id="a970d77e3a5ac117d9b60dfddbf0914fe" name="a970d77e3a5ac117d9b60dfddbf0914fe"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a970d77e3a5ac117d9b60dfddbf0914fe">&#9670;&nbsp;</a></span>hndl_snd() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename <a class="el" href="classipc_1_1transport_1_1Blob__sender.html">Blob_sender</a> , typename <a class="el" href="classipc_1_1transport_1_1Blob__receiver.html">Blob_receiver</a> , typename <a class="el" href="classipc_1_1transport_1_1Native__handle__sender.html">Native_handle_sender</a> , typename <a class="el" href="classipc_1_1transport_1_1Native__handle__receiver.html">Native_handle_receiver</a> &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classipc_1_1transport_1_1Channel.html">Channel</a>&lt; <a class="el" href="classipc_1_1transport_1_1Blob__sender.html">Blob_sender</a>, <a class="el" href="classipc_1_1transport_1_1Blob__receiver.html">Blob_receiver</a>, <a class="el" href="classipc_1_1transport_1_1Native__handle__sender.html">Native_handle_sender</a>, <a class="el" href="classipc_1_1transport_1_1Native__handle__receiver.html">Native_handle_receiver</a> &gt;<a class="el" href="classipc_1_1transport_1_1Channel.html#afc600491e137c9dc16c202b04885a36a">::Native_handle_sender_obj</a> * <a class="el" href="classipc_1_1transport_1_1Channel.html">ipc::transport::Channel</a>&lt; <a class="el" href="classipc_1_1transport_1_1Blob__sender.html">Blob_sender</a>, <a class="el" href="classipc_1_1transport_1_1Blob__receiver.html">Blob_receiver</a>, <a class="el" href="classipc_1_1transport_1_1Native__handle__sender.html">Native_handle_sender</a>, <a class="el" href="classipc_1_1transport_1_1Native__handle__receiver.html">Native_handle_receiver</a> &gt;::hndl_snd</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Pointer to the immutable owned <a class="el" href="classipc_1_1transport_1_1Channel.html#afc600491e137c9dc16c202b04885a36a" title="Alias for Native_handle_sender template parameter.">Native_handle_sender_obj</a>; null if not yet initialized. </p>
<p >Compilable only if <a class="el" href="classipc_1_1transport_1_1Channel.html#afc600491e137c9dc16c202b04885a36a" title="Alias for Native_handle_sender template parameter.">Native_handle_sender_obj</a> is not <a class="el" href="classipc_1_1transport_1_1Null__peer.html" title="Dummy type for use as a template param to Channel when either the blobs pipe or handles pipe is disab...">Null_peer</a> (<a class="el" href="classipc_1_1transport_1_1Channel.html#ab6decf2691a2cab6c3b5187bad1e368b" title="Useful for generic programming: true if and only if types imply at least the handles pipe is enabled.">S_HAS_NATIVE_HANDLE_PIPE</a>).</p>
<dl class="section return"><dt>Returns</dt><dd>See above. </dd></dl>

</div>
</div>
<a id="abf25364b49b9fdd3ba4b1541b3a50356" name="abf25364b49b9fdd3ba4b1541b3a50356"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abf25364b49b9fdd3ba4b1541b3a50356">&#9670;&nbsp;</a></span>idle_timer_run()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename <a class="el" href="classipc_1_1transport_1_1Blob__sender.html">Blob_sender</a> , typename <a class="el" href="classipc_1_1transport_1_1Blob__receiver.html">Blob_receiver</a> , typename <a class="el" href="classipc_1_1transport_1_1Native__handle__sender.html">Native_handle_sender</a> , typename <a class="el" href="classipc_1_1transport_1_1Native__handle__receiver.html">Native_handle_receiver</a> &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classipc_1_1transport_1_1Channel.html">ipc::transport::Channel</a>&lt; <a class="el" href="classipc_1_1transport_1_1Blob__sender.html">Blob_sender</a>, <a class="el" href="classipc_1_1transport_1_1Blob__receiver.html">Blob_receiver</a>, <a class="el" href="classipc_1_1transport_1_1Native__handle__sender.html">Native_handle_sender</a>, <a class="el" href="classipc_1_1transport_1_1Native__handle__receiver.html">Native_handle_receiver</a> &gt;::idle_timer_run </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespaceipc_1_1util.html#ac66141280c3b7295a86b65209f31cc58">util::Fine_duration</a>&#160;</td>
          <td class="paramname"><em>timeout</em> = <code>boost::chrono::seconds(5)</code></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Performs <code><a class="el" href="classipc_1_1transport_1_1Channel.html#af4c9cd7b02193fa2e8bf1742ab87111a" title="Pointer to the mutable owned Native_handle_receiver_obj; null if not yet initialized.">hndl_rcv()</a>-&gt;</code> and/or <code><a class="el" href="classipc_1_1transport_1_1Channel.html#a87fd94fa483cabd78059a3d1d094880d" title="Pointer to the mutable owned Blob_receiver_obj; null if not yet initialized.">blob_rcv()</a>-&gt;</code> same method, returning <code>true</code> if all (1-2) invoked methods returned <code>true</code>; <code>false</code> conversely. </p>
<p >As with <a class="el" href="classipc_1_1transport_1_1Channel.html#a37fcdfdbefd8ee7e374b0596782ad128" title="Performs hndl_snd()-&gt; and/or blob_snd()-&gt; same method, synthesizing completion handlers into one if a...">async_end_sending()</a> (either overload) behavior is undefined (assertion may trip), if one returned <code>true</code> and the other <code>false</code>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">timeout</td><td>See above. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>See above. </dd></dl>

</div>
</div>
<a id="abc969fa7785f5acda19a0c08bfeeb7e9" name="abc969fa7785f5acda19a0c08bfeeb7e9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abc969fa7785f5acda19a0c08bfeeb7e9">&#9670;&nbsp;</a></span>init_blob_pipe() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename <a class="el" href="classipc_1_1transport_1_1Blob__sender.html">Blob_sender</a> , typename <a class="el" href="classipc_1_1transport_1_1Blob__receiver.html">Blob_receiver</a> , typename <a class="el" href="classipc_1_1transport_1_1Native__handle__sender.html">Native_handle_sender</a> , typename <a class="el" href="classipc_1_1transport_1_1Native__handle__receiver.html">Native_handle_receiver</a> &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classipc_1_1transport_1_1Channel.html">ipc::transport::Channel</a>&lt; <a class="el" href="classipc_1_1transport_1_1Blob__sender.html">Blob_sender</a>, <a class="el" href="classipc_1_1transport_1_1Blob__receiver.html">Blob_receiver</a>, <a class="el" href="classipc_1_1transport_1_1Native__handle__sender.html">Native_handle_sender</a>, <a class="el" href="classipc_1_1transport_1_1Native__handle__receiver.html">Native_handle_receiver</a> &gt;::init_blob_pipe </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classipc_1_1transport_1_1Channel.html#a82746276cc7379a866b12d529780900f">Blob_sender_obj</a> &amp;&amp;&#160;</td>
          <td class="paramname"><em>snd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classipc_1_1transport_1_1Channel.html#aa9a7ec2d2eedfc3b6a1d2edfb05ea6d1">Blob_receiver_obj</a> &amp;&amp;&#160;</td>
          <td class="paramname"><em>rcv</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Completes initialization of the <em>blobs pipe</em> by taking ownership (via move semantics) of separate <a class="el" href="classipc_1_1transport_1_1Channel.html#a82746276cc7379a866b12d529780900f" title="Alias for Blob_sender template parameter.">Blob_sender_obj</a> and <a class="el" href="classipc_1_1transport_1_1Channel.html#aa9a7ec2d2eedfc3b6a1d2edfb05ea6d1" title="Alias for Blob_receiver template parameter.">Blob_receiver_obj</a> objects for our end of the blobs pipe. </p>
<p >Call this 0 times if blobs pipe disabled (in which case <a class="el" href="classipc_1_1transport_1_1Channel.html#a82746276cc7379a866b12d529780900f" title="Alias for Blob_sender template parameter.">Blob_sender_obj</a> and <a class="el" href="classipc_1_1transport_1_1Channel.html#aa9a7ec2d2eedfc3b6a1d2edfb05ea6d1" title="Alias for Blob_receiver template parameter.">Blob_receiver_obj</a> should both be <a class="el" href="classipc_1_1transport_1_1Null__peer.html" title="Dummy type for use as a template param to Channel when either the blobs pipe or handles pipe is disab...">Null_peer</a>). Call either this or the 1-arg overload exactly 1 time otherwise.</p>
<p >Certain mistaken uses are caught in this method; it no-ops and returns <code>false</code> (failure):</p><ul>
<li>You called this, but <a class="el" href="classipc_1_1transport_1_1Channel.html#a82746276cc7379a866b12d529780900f" title="Alias for Blob_sender template parameter.">Blob_sender_obj</a> is <a class="el" href="classipc_1_1transport_1_1Null__peer.html" title="Dummy type for use as a template param to Channel when either the blobs pipe or handles pipe is disab...">Null_peer</a> and/or <a class="el" href="classipc_1_1transport_1_1Channel.html#aa9a7ec2d2eedfc3b6a1d2edfb05ea6d1" title="Alias for Blob_receiver template parameter.">Blob_receiver_obj</a> is <a class="el" href="classipc_1_1transport_1_1Null__peer.html" title="Dummy type for use as a template param to Channel when either the blobs pipe or handles pipe is disab...">Null_peer</a>.</li>
<li>You called this after already calling an <a class="el" href="classipc_1_1transport_1_1Channel.html#aa8209a5adde4e5c2b3b1d8779fab0433" title="Completes initialization of the blobs pipe by taking ownership (via move semantics) of an object that...">init_blob_pipe()</a> overload successfully before.</li>
</ul>
<p >The remaining mistakes are caught by <a class="el" href="classipc_1_1transport_1_1Channel.html#a43c79955b3ad0eab347550b4263523ec" title="Returns true if and only if the required init_blob_pipe() and init_native_handle_pipe() calls have be...">initialized()</a>, if you choose to call it before any transmission (and you should):</p><ul>
<li>You called this or the overload 0 times (successfully), but <a class="el" href="classipc_1_1transport_1_1Channel.html#a82746276cc7379a866b12d529780900f" title="Alias for Blob_sender template parameter.">Blob_sender_obj</a> is not <a class="el" href="classipc_1_1transport_1_1Null__peer.html" title="Dummy type for use as a template param to Channel when either the blobs pipe or handles pipe is disab...">Null_peer</a>.</li>
</ul>
<p >Pre-condition: <code>snd</code> and <code>rcv</code> are in PEER state. Behavior is undefined otherwise. Post-condition: The <code>*this</code> blobs pipe is in PEER state (transmission can begin).</p>
<p >Informal recommendation: Complete the <em>handles pipe</em> initialization, if enabled, before transmitting anything over the blobs pipe, even though technically it is possible to do so immediately. Use <a class="el" href="classipc_1_1transport_1_1Channel.html#a43c79955b3ad0eab347550b4263523ec" title="Returns true if and only if the required init_blob_pipe() and init_native_handle_pipe() calls have be...">initialized()</a> to double-check.</p>
<dl class="section note"><dt>Note</dt><dd>As a user, it is likely you can/should use an alias type that will take care of calling this for you. See <a class="el" href="classipc_1_1transport_1_1Channel.html" title="Peer to a bundle of 1-2 full-duplex pipe(s), one for transmitting unstructured binary blobs; the othe...">Channel</a> doc header.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">snd</td><td>A <a class="el" href="classipc_1_1transport_1_1Channel.html#a82746276cc7379a866b12d529780900f" title="Alias for Blob_sender template parameter.">Blob_sender_obj</a> in PEER state. </td></tr>
    <tr><td class="paramname">rcv</td><td>A <a class="el" href="classipc_1_1transport_1_1Channel.html#aa9a7ec2d2eedfc3b6a1d2edfb05ea6d1" title="Alias for Blob_receiver template parameter.">Blob_receiver_obj</a> in PEER state. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> on success; <code>false</code> on no-op due to a mistaken use listed above. </dd></dl>

</div>
</div>
<a id="aa8209a5adde4e5c2b3b1d8779fab0433" name="aa8209a5adde4e5c2b3b1d8779fab0433"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa8209a5adde4e5c2b3b1d8779fab0433">&#9670;&nbsp;</a></span>init_blob_pipe() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename <a class="el" href="classipc_1_1transport_1_1Blob__sender.html">Blob_sender</a> , typename <a class="el" href="classipc_1_1transport_1_1Blob__receiver.html">Blob_receiver</a> , typename <a class="el" href="classipc_1_1transport_1_1Native__handle__sender.html">Native_handle_sender</a> , typename <a class="el" href="classipc_1_1transport_1_1Native__handle__receiver.html">Native_handle_receiver</a> &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classipc_1_1transport_1_1Channel.html">ipc::transport::Channel</a>&lt; <a class="el" href="classipc_1_1transport_1_1Blob__sender.html">Blob_sender</a>, <a class="el" href="classipc_1_1transport_1_1Blob__receiver.html">Blob_receiver</a>, <a class="el" href="classipc_1_1transport_1_1Native__handle__sender.html">Native_handle_sender</a>, <a class="el" href="classipc_1_1transport_1_1Native__handle__receiver.html">Native_handle_receiver</a> &gt;::init_blob_pipe </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classipc_1_1transport_1_1Channel.html#a82746276cc7379a866b12d529780900f">Blob_sender_obj</a> &amp;&amp;&#160;</td>
          <td class="paramname"><em>snd_and_rcv</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Completes initialization of the <em>blobs pipe</em> by taking ownership (via move semantics) of an object that is simultaneously the <a class="el" href="classipc_1_1transport_1_1Channel.html#a82746276cc7379a866b12d529780900f" title="Alias for Blob_sender template parameter.">Blob_sender_obj</a> and <a class="el" href="classipc_1_1transport_1_1Channel.html#aa9a7ec2d2eedfc3b6a1d2edfb05ea6d1" title="Alias for Blob_receiver template parameter.">Blob_receiver_obj</a> for our end of the blobs pipe. </p>
<p >Call this 0 times (successfully) if blobs pipe disabled (in which case <a class="el" href="classipc_1_1transport_1_1Channel.html#a82746276cc7379a866b12d529780900f" title="Alias for Blob_sender template parameter.">Blob_sender_obj</a> and <a class="el" href="classipc_1_1transport_1_1Channel.html#aa9a7ec2d2eedfc3b6a1d2edfb05ea6d1" title="Alias for Blob_receiver template parameter.">Blob_receiver_obj</a> should both be <a class="el" href="classipc_1_1transport_1_1Null__peer.html" title="Dummy type for use as a template param to Channel when either the blobs pipe or handles pipe is disab...">Null_peer</a>). Call either this or the 2-arg overload exactly 1 time (successfully) otherwise. If you call this, </p><h1><a class="el" href="classipc_1_1transport_1_1Channel.html#a82746276cc7379a866b12d529780900f" title="Alias for Blob_sender template parameter.">Blob_sender_obj</a> and <a class="el" href="classipc_1_1transport_1_1Channel.html#aa9a7ec2d2eedfc3b6a1d2edfb05ea6d1" title="Alias for Blob_receiver template parameter.">Blob_receiver_obj</a> must be the same type.</h1>
<p >Certain mistaken uses are caught in this method; it no-ops and returns <code>false</code> (failure):</p><ul>
<li>You called this, but <a class="el" href="classipc_1_1transport_1_1Channel.html#a82746276cc7379a866b12d529780900f" title="Alias for Blob_sender template parameter.">Blob_sender_obj</a> is <a class="el" href="classipc_1_1transport_1_1Null__peer.html" title="Dummy type for use as a template param to Channel when either the blobs pipe or handles pipe is disab...">Null_peer</a>.</li>
<li>You called this, but <a class="el" href="classipc_1_1transport_1_1Channel.html#a82746276cc7379a866b12d529780900f" title="Alias for Blob_sender template parameter.">Blob_sender_obj</a> and <a class="el" href="classipc_1_1transport_1_1Channel.html#aa9a7ec2d2eedfc3b6a1d2edfb05ea6d1" title="Alias for Blob_receiver template parameter.">Blob_receiver_obj</a> are not the same type.</li>
<li>You called this after already calling an <a class="el" href="classipc_1_1transport_1_1Channel.html#aa8209a5adde4e5c2b3b1d8779fab0433" title="Completes initialization of the blobs pipe by taking ownership (via move semantics) of an object that...">init_blob_pipe()</a> overload successfully before.</li>
</ul>
<p >The remaining mistakes are caught by <a class="el" href="classipc_1_1transport_1_1Channel.html#a43c79955b3ad0eab347550b4263523ec" title="Returns true if and only if the required init_blob_pipe() and init_native_handle_pipe() calls have be...">initialized()</a>, if you choose to call it before any transmission (and you should):</p><ul>
<li>You called this or the overload 0 times (successfully), but <a class="el" href="classipc_1_1transport_1_1Channel.html#a82746276cc7379a866b12d529780900f" title="Alias for Blob_sender template parameter.">Blob_sender_obj</a> is not <a class="el" href="classipc_1_1transport_1_1Null__peer.html" title="Dummy type for use as a template param to Channel when either the blobs pipe or handles pipe is disab...">Null_peer</a>.</li>
</ul>
<p >Pre-condition: <code>snd_and_rcv</code> is in PEER state. Behavior is undefined otherwise. Post-condition (on success): The <code>*this</code> blobs pipe is in PEER state (transmission can begin).</p>
<p >Informal recommendation: Complete the <em>handles pipe</em> initialization, if enabled, before transmitting anything over the blobs pipe, even though technically it is possible to do so immediately. Use <a class="el" href="classipc_1_1transport_1_1Channel.html#a43c79955b3ad0eab347550b4263523ec" title="Returns true if and only if the required init_blob_pipe() and init_native_handle_pipe() calls have be...">initialized()</a> to double-check.</p>
<dl class="section warning"><dt>Warning</dt><dd>It is an error (as noted above) to call this, unless <a class="el" href="classipc_1_1transport_1_1Channel.html#a82746276cc7379a866b12d529780900f" title="Alias for Blob_sender template parameter.">Blob_sender_obj</a> and <a class="el" href="classipc_1_1transport_1_1Channel.html#aa9a7ec2d2eedfc3b6a1d2edfb05ea6d1" title="Alias for Blob_receiver template parameter.">Blob_receiver_obj</a> are the same type. This will no-op and return <code>false</code>. The only reason it is not undefined behavior (assertion trip) is so that this mistake can be caught without an <code>assert()</code>, if you choose to call <a class="el" href="classipc_1_1transport_1_1Channel.html#a43c79955b3ad0eab347550b4263523ec" title="Returns true if and only if the required init_blob_pipe() and init_native_handle_pipe() calls have be...">initialized()</a> after the init phase yourself.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>As a user, it is likely you can/should use an alias type that will take care of calling this for you. See <a class="el" href="classipc_1_1transport_1_1Channel.html" title="Peer to a bundle of 1-2 full-duplex pipe(s), one for transmitting unstructured binary blobs; the othe...">Channel</a> doc header.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">snd_and_rcv</td><td>A <a class="el" href="classipc_1_1transport_1_1Channel.html#a82746276cc7379a866b12d529780900f" title="Alias for Blob_sender template parameter.">Blob_sender_obj</a> <em>and</em> <a class="el" href="classipc_1_1transport_1_1Channel.html#aa9a7ec2d2eedfc3b6a1d2edfb05ea6d1" title="Alias for Blob_receiver template parameter.">Blob_receiver_obj</a> in PEER state. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> on success; <code>false</code> on no-op due to a mistaken use listed above. </dd></dl>

</div>
</div>
<a id="afa221b9b60aa9de1aa8dfcb0c1cabec1" name="afa221b9b60aa9de1aa8dfcb0c1cabec1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afa221b9b60aa9de1aa8dfcb0c1cabec1">&#9670;&nbsp;</a></span>init_native_handle_pipe() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename <a class="el" href="classipc_1_1transport_1_1Blob__sender.html">Blob_sender</a> , typename <a class="el" href="classipc_1_1transport_1_1Blob__receiver.html">Blob_receiver</a> , typename <a class="el" href="classipc_1_1transport_1_1Native__handle__sender.html">Native_handle_sender</a> , typename <a class="el" href="classipc_1_1transport_1_1Native__handle__receiver.html">Native_handle_receiver</a> &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classipc_1_1transport_1_1Channel.html">ipc::transport::Channel</a>&lt; <a class="el" href="classipc_1_1transport_1_1Blob__sender.html">Blob_sender</a>, <a class="el" href="classipc_1_1transport_1_1Blob__receiver.html">Blob_receiver</a>, <a class="el" href="classipc_1_1transport_1_1Native__handle__sender.html">Native_handle_sender</a>, <a class="el" href="classipc_1_1transport_1_1Native__handle__receiver.html">Native_handle_receiver</a> &gt;::init_native_handle_pipe </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classipc_1_1transport_1_1Channel.html#afc600491e137c9dc16c202b04885a36a">Native_handle_sender_obj</a> &amp;&amp;&#160;</td>
          <td class="paramname"><em>snd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classipc_1_1transport_1_1Channel.html#ad011bfbcfc226b9a32d97188485d9a22">Native_handle_receiver_obj</a> &amp;&amp;&#160;</td>
          <td class="paramname"><em>rcv</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Analogous to 2-arg <a class="el" href="classipc_1_1transport_1_1Channel.html#aa8209a5adde4e5c2b3b1d8779fab0433" title="Completes initialization of the blobs pipe by taking ownership (via move semantics) of an object that...">init_blob_pipe()</a> but as applied to the <em>handles pipe</em>. </p>
<p >All its notes apply by analogy.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">snd</td><td>A <a class="el" href="classipc_1_1transport_1_1Channel.html#afc600491e137c9dc16c202b04885a36a" title="Alias for Native_handle_sender template parameter.">Native_handle_sender_obj</a> in PEER state. </td></tr>
    <tr><td class="paramname">rcv</td><td>A <a class="el" href="classipc_1_1transport_1_1Channel.html#ad011bfbcfc226b9a32d97188485d9a22" title="Alias for Native_handle_receiver template parameter.">Native_handle_receiver_obj</a> in PEER state. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>See <a class="el" href="classipc_1_1transport_1_1Channel.html#aa8209a5adde4e5c2b3b1d8779fab0433" title="Completes initialization of the blobs pipe by taking ownership (via move semantics) of an object that...">init_blob_pipe()</a>. </dd></dl>

</div>
</div>
<a id="a0e0e396759dab8c0930594eac3bb03ba" name="a0e0e396759dab8c0930594eac3bb03ba"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0e0e396759dab8c0930594eac3bb03ba">&#9670;&nbsp;</a></span>init_native_handle_pipe() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename <a class="el" href="classipc_1_1transport_1_1Blob__sender.html">Blob_sender</a> , typename <a class="el" href="classipc_1_1transport_1_1Blob__receiver.html">Blob_receiver</a> , typename <a class="el" href="classipc_1_1transport_1_1Native__handle__sender.html">Native_handle_sender</a> , typename <a class="el" href="classipc_1_1transport_1_1Native__handle__receiver.html">Native_handle_receiver</a> &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classipc_1_1transport_1_1Channel.html">ipc::transport::Channel</a>&lt; <a class="el" href="classipc_1_1transport_1_1Blob__sender.html">Blob_sender</a>, <a class="el" href="classipc_1_1transport_1_1Blob__receiver.html">Blob_receiver</a>, <a class="el" href="classipc_1_1transport_1_1Native__handle__sender.html">Native_handle_sender</a>, <a class="el" href="classipc_1_1transport_1_1Native__handle__receiver.html">Native_handle_receiver</a> &gt;::init_native_handle_pipe </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classipc_1_1transport_1_1Channel.html#afc600491e137c9dc16c202b04885a36a">Native_handle_sender_obj</a> &amp;&amp;&#160;</td>
          <td class="paramname"><em>snd_and_rcv</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Analogous to 1-arg <a class="el" href="classipc_1_1transport_1_1Channel.html#aa8209a5adde4e5c2b3b1d8779fab0433" title="Completes initialization of the blobs pipe by taking ownership (via move semantics) of an object that...">init_blob_pipe()</a> but as applied to the <em>handles pipe</em>. </p>
<p >All its notes apply by analogy.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">snd_and_rcv</td><td>A <a class="el" href="classipc_1_1transport_1_1Channel.html#afc600491e137c9dc16c202b04885a36a" title="Alias for Native_handle_sender template parameter.">Native_handle_sender_obj</a> <em>and</em> <a class="el" href="classipc_1_1transport_1_1Channel.html#ad011bfbcfc226b9a32d97188485d9a22" title="Alias for Native_handle_receiver template parameter.">Native_handle_receiver_obj</a> in PEER state. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>See <a class="el" href="classipc_1_1transport_1_1Channel.html#aa8209a5adde4e5c2b3b1d8779fab0433" title="Completes initialization of the blobs pipe by taking ownership (via move semantics) of an object that...">init_blob_pipe()</a>. </dd></dl>

</div>
</div>
<a id="a43c79955b3ad0eab347550b4263523ec" name="a43c79955b3ad0eab347550b4263523ec"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a43c79955b3ad0eab347550b4263523ec">&#9670;&nbsp;</a></span>initialized()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename <a class="el" href="classipc_1_1transport_1_1Blob__sender.html">Blob_sender</a> , typename <a class="el" href="classipc_1_1transport_1_1Blob__receiver.html">Blob_receiver</a> , typename <a class="el" href="classipc_1_1transport_1_1Native__handle__sender.html">Native_handle_sender</a> , typename <a class="el" href="classipc_1_1transport_1_1Native__handle__receiver.html">Native_handle_receiver</a> &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classipc_1_1transport_1_1Channel.html">ipc::transport::Channel</a>&lt; <a class="el" href="classipc_1_1transport_1_1Blob__sender.html">Blob_sender</a>, <a class="el" href="classipc_1_1transport_1_1Blob__receiver.html">Blob_receiver</a>, <a class="el" href="classipc_1_1transport_1_1Native__handle__sender.html">Native_handle_sender</a>, <a class="el" href="classipc_1_1transport_1_1Native__handle__receiver.html">Native_handle_receiver</a> &gt;::initialized </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>suppress_log</em> = <code>false</code></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns <code>true</code> if and only if the required <a class="el" href="classipc_1_1transport_1_1Channel.html#aa8209a5adde4e5c2b3b1d8779fab0433" title="Completes initialization of the blobs pipe by taking ownership (via move semantics) of an object that...">init_blob_pipe()</a> and <a class="el" href="classipc_1_1transport_1_1Channel.html#a0e0e396759dab8c0930594eac3bb03ba" title="Analogous to 1-arg init_blob_pipe() but as applied to the handles pipe.">init_native_handle_pipe()</a> calls have been made, loading exactly the expected peer objects as the template params <a class="el" href="classipc_1_1transport_1_1Channel.html#a82746276cc7379a866b12d529780900f" title="Alias for Blob_sender template parameter.">Blob_sender_obj</a>, <a class="el" href="classipc_1_1transport_1_1Channel.html#aa9a7ec2d2eedfc3b6a1d2edfb05ea6d1" title="Alias for Blob_receiver template parameter.">Blob_receiver_obj</a>, <a class="el" href="classipc_1_1transport_1_1Channel.html#afc600491e137c9dc16c202b04885a36a" title="Alias for Native_handle_sender template parameter.">Native_handle_sender_obj</a>, <a class="el" href="classipc_1_1transport_1_1Channel.html#ad011bfbcfc226b9a32d97188485d9a22" title="Alias for Native_handle_receiver template parameter.">Native_handle_receiver_obj</a> specify. </p>
<p >This is useful particularly when meta-programming on top of <a class="el" href="classipc_1_1transport_1_1Channel.html" title="Peer to a bundle of 1-2 full-duplex pipe(s), one for transmitting unstructured binary blobs; the othe...">Channel</a>: one can call <a class="el" href="classipc_1_1transport_1_1Channel.html#a43c79955b3ad0eab347550b4263523ec" title="Returns true if and only if the required init_blob_pipe() and init_native_handle_pipe() calls have be...">initialized()</a> before any transmission methods to ensure the proper <code>init_*()</code> calls were made. After that it is safe to meta-program in terms of just the compile-time values <a class="el" href="classipc_1_1transport_1_1Channel.html#a85184d886cee9b4a0d0e7b67796a238b" title="Useful for generic programming: true if and only if types imply both blobs and handles pipes are enab...">S_HAS_2_PIPES</a>, <a class="el" href="classipc_1_1transport_1_1Channel.html#aafb0767df5f1dfb535c9467ce717f93f" title="Useful for generic programming: true if and only if types imply at least the blobs pipe is enabled.">S_HAS_BLOB_PIPE</a>, <a class="el" href="classipc_1_1transport_1_1Channel.html#ab6decf2691a2cab6c3b5187bad1e368b" title="Useful for generic programming: true if and only if types imply at least the handles pipe is enabled.">S_HAS_NATIVE_HANDLE_PIPE</a>, <a class="el" href="classipc_1_1transport_1_1Channel.html#a634da813ea03c07d8360a738eca002c4" title="Useful for generic programming: true if and only if types imply only the blobs pipe is enabled.">S_HAS_BLOB_PIPE_ONLY</a>, <a class="el" href="classipc_1_1transport_1_1Channel.html#a717bffc2086ccf834bc7a1137c1127eb" title="Useful for generic programming: true if and only if types imply only the handles pipe is enabled.">S_HAS_NATIVE_HANDLE_PIPE_ONLY</a>, <a class="el" href="classipc_1_1transport_1_1Channel.html#ae5be240d29389d7b728950e85df0704e" title="Useful for generic programming: true &lt;=&gt; each non-Null_peer peer type (Blob_sender_obj,...">S_IS_SYNC_IO_OBJ</a>, <a class="el" href="classipc_1_1transport_1_1Channel.html#a9f75b20b07eff47a69c2b1dbe5c85f84" title="It equals the reverse of S_IS_SYNC_IO_OBJ.">S_IS_ASYNC_IO_OBJ</a>.</p>
<p >Namely it will check that:</p><ul>
<li><a class="el" href="classipc_1_1transport_1_1Channel.html#aa8209a5adde4e5c2b3b1d8779fab0433" title="Completes initialization of the blobs pipe by taking ownership (via move semantics) of an object that...">init_blob_pipe()</a> was called if and only if <a class="el" href="classipc_1_1transport_1_1Channel.html#a82746276cc7379a866b12d529780900f" title="Alias for Blob_sender template parameter.">Blob_sender_obj</a> is not <a class="el" href="classipc_1_1transport_1_1Null__peer.html" title="Dummy type for use as a template param to Channel when either the blobs pipe or handles pipe is disab...">Null_peer</a>.<ul>
<li>If an overload was indeed called, and its 1-arg was the one, then <a class="el" href="classipc_1_1transport_1_1Channel.html#a82746276cc7379a866b12d529780900f" title="Alias for Blob_sender template parameter.">Blob_sender_obj</a> and <a class="el" href="classipc_1_1transport_1_1Channel.html#aa9a7ec2d2eedfc3b6a1d2edfb05ea6d1" title="Alias for Blob_receiver template parameter.">Blob_receiver_obj</a> were the same type.</li>
</ul>
</li>
<li><a class="el" href="classipc_1_1transport_1_1Channel.html#a0e0e396759dab8c0930594eac3bb03ba" title="Analogous to 1-arg init_blob_pipe() but as applied to the handles pipe.">init_native_handle_pipe()</a> was called if and only if <a class="el" href="classipc_1_1transport_1_1Channel.html#afc600491e137c9dc16c202b04885a36a" title="Alias for Native_handle_sender template parameter.">Native_handle_sender_obj</a> is not <a class="el" href="classipc_1_1transport_1_1Null__peer.html" title="Dummy type for use as a template param to Channel when either the blobs pipe or handles pipe is disab...">Null_peer</a>.<ul>
<li>If an overload was indeed called, and its 1-arg was the one, then <a class="el" href="classipc_1_1transport_1_1Channel.html#afc600491e137c9dc16c202b04885a36a" title="Alias for Native_handle_sender template parameter.">Native_handle_sender_obj</a> and <a class="el" href="classipc_1_1transport_1_1Channel.html#ad011bfbcfc226b9a32d97188485d9a22" title="Alias for Native_handle_receiver template parameter.">Native_handle_receiver_obj</a> were the same type.</li>
</ul>
</li>
</ul>
<p >If this returns <code>false</code>, formally, behavior is undefined, if one attempts transmission. Informally, likely some intended-for-use transmission methods will always return <code>false</code> and no-op; but the best recommendation is: If this returns <code>false</code>, do not use <code>*this</code> for transmission.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">suppress_log</td><td>If and only if <code>true</code>, returning <code>false</code> shall not be explained via logging. This may be useful when one merely wants to check whether <code>*this</code> is in default-cted state without implying that's a terrible thing. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>See above. </dd></dl>

</div>
</div>
<a id="a212c7e77daa038fc45dc118894e80af0" name="a212c7e77daa038fc45dc118894e80af0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a212c7e77daa038fc45dc118894e80af0">&#9670;&nbsp;</a></span>nickname()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename <a class="el" href="classipc_1_1transport_1_1Blob__sender.html">Blob_sender</a> , typename <a class="el" href="classipc_1_1transport_1_1Blob__receiver.html">Blob_receiver</a> , typename <a class="el" href="classipc_1_1transport_1_1Native__handle__sender.html">Native_handle_sender</a> , typename <a class="el" href="classipc_1_1transport_1_1Native__handle__receiver.html">Native_handle_receiver</a> &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">const std::string &amp; <a class="el" href="classipc_1_1transport_1_1Channel.html">ipc::transport::Channel</a>&lt; <a class="el" href="classipc_1_1transport_1_1Blob__sender.html">Blob_sender</a>, <a class="el" href="classipc_1_1transport_1_1Blob__receiver.html">Blob_receiver</a>, <a class="el" href="classipc_1_1transport_1_1Native__handle__sender.html">Native_handle_sender</a>, <a class="el" href="classipc_1_1transport_1_1Native__handle__receiver.html">Native_handle_receiver</a> &gt;::nickname</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns nickname, a brief string suitable for logging. </p>
<p >This is included in the output by the <code>ostream&lt;&lt;</code> operator as well. This method is thread-safe in that it always returns the same value.</p>
<p >If this object is default-cted (or moved-from), this will return a value equal to "".</p>
<dl class="section return"><dt>Returns</dt><dd>See above. </dd></dl>

</div>
</div>
<a id="a8f60506c8b6f4165a04626c524cb4022" name="a8f60506c8b6f4165a04626c524cb4022"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8f60506c8b6f4165a04626c524cb4022">&#9670;&nbsp;</a></span>operator=()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename <a class="el" href="classipc_1_1transport_1_1Blob__sender.html">Blob_sender</a> , typename <a class="el" href="classipc_1_1transport_1_1Blob__receiver.html">Blob_receiver</a> , typename <a class="el" href="classipc_1_1transport_1_1Native__handle__sender.html">Native_handle_sender</a> , typename <a class="el" href="classipc_1_1transport_1_1Native__handle__receiver.html">Native_handle_receiver</a> &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classipc_1_1transport_1_1Channel.html">Channel</a>&lt; <a class="el" href="classipc_1_1transport_1_1Blob__sender.html">Blob_sender</a>, <a class="el" href="classipc_1_1transport_1_1Blob__receiver.html">Blob_receiver</a>, <a class="el" href="classipc_1_1transport_1_1Native__handle__sender.html">Native_handle_sender</a>, <a class="el" href="classipc_1_1transport_1_1Native__handle__receiver.html">Native_handle_receiver</a> &gt; &amp; <a class="el" href="classipc_1_1transport_1_1Channel.html">ipc::transport::Channel</a>&lt; <a class="el" href="classipc_1_1transport_1_1Blob__sender.html">Blob_sender</a>, <a class="el" href="classipc_1_1transport_1_1Blob__receiver.html">Blob_receiver</a>, <a class="el" href="classipc_1_1transport_1_1Native__handle__sender.html">Native_handle_sender</a>, <a class="el" href="classipc_1_1transport_1_1Native__handle__receiver.html">Native_handle_receiver</a> &gt;::operator= </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classipc_1_1transport_1_1Channel.html">Channel</a>&lt; <a class="el" href="classipc_1_1transport_1_1Blob__sender.html">Blob_sender</a>, <a class="el" href="classipc_1_1transport_1_1Blob__receiver.html">Blob_receiver</a>, <a class="el" href="classipc_1_1transport_1_1Native__handle__sender.html">Native_handle_sender</a>, <a class="el" href="classipc_1_1transport_1_1Native__handle__receiver.html">Native_handle_receiver</a> &gt; &amp;&amp;&#160;</td>
          <td class="paramname"><em>src</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">default</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Move-assigns from <code>src</code>; <code>*this</code> acts as if destructed; <code>src</code> becomes as-if default-cted (therefore in ??? state). </p>
<p >No-op if <code>&amp;src == this</code>.</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classipc_1_1transport_1_1Channel.html#a10d97e67296614195f8b14599944dd65" title="Destructor: synchronously invokes the destructors for each peer object moved-into *this via init_blob...">~Channel()</a>.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">src</td><td>See above. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>*this</code>. </dd></dl>

</div>
</div>
<a id="a5e181ca69bd2b38d0e3585a1d9303318" name="a5e181ca69bd2b38d0e3585a1d9303318"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5e181ca69bd2b38d0e3585a1d9303318">&#9670;&nbsp;</a></span>receive_blob_max_size()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename <a class="el" href="classipc_1_1transport_1_1Blob__sender.html">Blob_sender</a> , typename <a class="el" href="classipc_1_1transport_1_1Blob__receiver.html">Blob_receiver</a> , typename <a class="el" href="classipc_1_1transport_1_1Native__handle__sender.html">Native_handle_sender</a> , typename <a class="el" href="classipc_1_1transport_1_1Native__handle__receiver.html">Native_handle_receiver</a> &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">size_t <a class="el" href="classipc_1_1transport_1_1Channel.html">ipc::transport::Channel</a>&lt; <a class="el" href="classipc_1_1transport_1_1Blob__sender.html">Blob_sender</a>, <a class="el" href="classipc_1_1transport_1_1Blob__receiver.html">Blob_receiver</a>, <a class="el" href="classipc_1_1transport_1_1Native__handle__sender.html">Native_handle_sender</a>, <a class="el" href="classipc_1_1transport_1_1Native__handle__receiver.html">Native_handle_receiver</a> &gt;::receive_blob_max_size</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Yields <code><a class="el" href="classipc_1_1transport_1_1Channel.html#a87fd94fa483cabd78059a3d1d094880d" title="Pointer to the mutable owned Blob_receiver_obj; null if not yet initialized.">blob_rcv()</a>-&gt;</code> same method. </p>
<dl class="section return"><dt>Returns</dt><dd>See concept API. </dd></dl>

</div>
</div>
<a id="afd9589e9bee2aec1574ab534cf4b3782" name="afd9589e9bee2aec1574ab534cf4b3782"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afd9589e9bee2aec1574ab534cf4b3782">&#9670;&nbsp;</a></span>receive_meta_blob_max_size()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename <a class="el" href="classipc_1_1transport_1_1Blob__sender.html">Blob_sender</a> , typename <a class="el" href="classipc_1_1transport_1_1Blob__receiver.html">Blob_receiver</a> , typename <a class="el" href="classipc_1_1transport_1_1Native__handle__sender.html">Native_handle_sender</a> , typename <a class="el" href="classipc_1_1transport_1_1Native__handle__receiver.html">Native_handle_receiver</a> &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">size_t <a class="el" href="classipc_1_1transport_1_1Channel.html">ipc::transport::Channel</a>&lt; <a class="el" href="classipc_1_1transport_1_1Blob__sender.html">Blob_sender</a>, <a class="el" href="classipc_1_1transport_1_1Blob__receiver.html">Blob_receiver</a>, <a class="el" href="classipc_1_1transport_1_1Native__handle__sender.html">Native_handle_sender</a>, <a class="el" href="classipc_1_1transport_1_1Native__handle__receiver.html">Native_handle_receiver</a> &gt;::receive_meta_blob_max_size</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Yields <code><a class="el" href="classipc_1_1transport_1_1Channel.html#af4c9cd7b02193fa2e8bf1742ab87111a" title="Pointer to the mutable owned Native_handle_receiver_obj; null if not yet initialized.">hndl_rcv()</a>-&gt;</code> same method. </p>
<dl class="section return"><dt>Returns</dt><dd>See concept API. </dd></dl>

</div>
</div>
<a id="ae63c4f7dbe1a1855d46a4b4d7009d5e8" name="ae63c4f7dbe1a1855d46a4b4d7009d5e8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae63c4f7dbe1a1855d46a4b4d7009d5e8">&#9670;&nbsp;</a></span>replace_event_wait_handles()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename <a class="el" href="classipc_1_1transport_1_1Blob__sender.html">Blob_sender</a> , typename <a class="el" href="classipc_1_1transport_1_1Blob__receiver.html">Blob_receiver</a> , typename <a class="el" href="classipc_1_1transport_1_1Native__handle__sender.html">Native_handle_sender</a> , typename <a class="el" href="classipc_1_1transport_1_1Native__handle__receiver.html">Native_handle_receiver</a> &gt; </div>
<div class="memtemplate">
template&lt;typename Create_ev_wait_hndl_func &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classipc_1_1transport_1_1Channel.html">ipc::transport::Channel</a>&lt; <a class="el" href="classipc_1_1transport_1_1Blob__sender.html">Blob_sender</a>, <a class="el" href="classipc_1_1transport_1_1Blob__receiver.html">Blob_receiver</a>, <a class="el" href="classipc_1_1transport_1_1Native__handle__sender.html">Native_handle_sender</a>, <a class="el" href="classipc_1_1transport_1_1Native__handle__receiver.html">Native_handle_receiver</a> &gt;::replace_event_wait_handles </td>
          <td>(</td>
          <td class="paramtype">const Create_ev_wait_hndl_func &amp;&#160;</td>
          <td class="paramname"><em>create_ev_wait_hndl_func</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Executes same method on all unique stored peer objects; returns <code>true</code> if and only if they all did. </p>
<p >(<a class="el" href="classipc_1_1transport_1_1Channel.html#a43c79955b3ad0eab347550b4263523ec" title="Returns true if and only if the required init_blob_pipe() and init_native_handle_pipe() calls have be...">initialized()</a> must be <code>true</code>; else behavior undefined.)</p>
<p >Compilable only if <a class="el" href="classipc_1_1transport_1_1Channel.html#ae5be240d29389d7b728950e85df0704e" title="Useful for generic programming: true &lt;=&gt; each non-Null_peer peer type (Blob_sender_obj,...">S_IS_SYNC_IO_OBJ</a>.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Create_ev_wait_hndl_func</td><td>See concept API. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">create_ev_wait_hndl_func</td><td>See concept API. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>See above. </dd></dl>

</div>
</div>
<a id="ac6a506269ad02031f434a21eff4ca6ba" name="ac6a506269ad02031f434a21eff4ca6ba"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac6a506269ad02031f434a21eff4ca6ba">&#9670;&nbsp;</a></span>send_blob()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename <a class="el" href="classipc_1_1transport_1_1Blob__sender.html">Blob_sender</a> , typename <a class="el" href="classipc_1_1transport_1_1Blob__receiver.html">Blob_receiver</a> , typename <a class="el" href="classipc_1_1transport_1_1Native__handle__sender.html">Native_handle_sender</a> , typename <a class="el" href="classipc_1_1transport_1_1Native__handle__receiver.html">Native_handle_receiver</a> &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classipc_1_1transport_1_1Channel.html">ipc::transport::Channel</a>&lt; <a class="el" href="classipc_1_1transport_1_1Blob__sender.html">Blob_sender</a>, <a class="el" href="classipc_1_1transport_1_1Blob__receiver.html">Blob_receiver</a>, <a class="el" href="classipc_1_1transport_1_1Native__handle__sender.html">Native_handle_sender</a>, <a class="el" href="classipc_1_1transport_1_1Native__handle__receiver.html">Native_handle_receiver</a> &gt;::send_blob </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespaceipc_1_1util.html#ae0be7edba7e30ffa3f8b742af621f2ab">util::Blob_const</a> &amp;&#160;</td>
          <td class="paramname"><em>blob</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceipc.html#aa3192e586cc45d3e7c22463bf2760f89">Error_code</a> *&#160;</td>
          <td class="paramname"><em>err_code</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Yields <code><a class="el" href="classipc_1_1transport_1_1Channel.html#a647bc9b6f8b9fb0b546cf3879cb5d4c1" title="Pointer to the mutable owned Blob_sender_obj; null if yet initialized.">blob_snd()</a>-&gt;</code> same method. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">blob</td><td>See concept API. </td></tr>
    <tr><td class="paramname">err_code</td><td>See concept API. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>See concept API. </dd></dl>

</div>
</div>
<a id="ab62f46ceaf85baac6820415808c3a2f2" name="ab62f46ceaf85baac6820415808c3a2f2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab62f46ceaf85baac6820415808c3a2f2">&#9670;&nbsp;</a></span>send_blob_max_size()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename <a class="el" href="classipc_1_1transport_1_1Blob__sender.html">Blob_sender</a> , typename <a class="el" href="classipc_1_1transport_1_1Blob__receiver.html">Blob_receiver</a> , typename <a class="el" href="classipc_1_1transport_1_1Native__handle__sender.html">Native_handle_sender</a> , typename <a class="el" href="classipc_1_1transport_1_1Native__handle__receiver.html">Native_handle_receiver</a> &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">size_t <a class="el" href="classipc_1_1transport_1_1Channel.html">ipc::transport::Channel</a>&lt; <a class="el" href="classipc_1_1transport_1_1Blob__sender.html">Blob_sender</a>, <a class="el" href="classipc_1_1transport_1_1Blob__receiver.html">Blob_receiver</a>, <a class="el" href="classipc_1_1transport_1_1Native__handle__sender.html">Native_handle_sender</a>, <a class="el" href="classipc_1_1transport_1_1Native__handle__receiver.html">Native_handle_receiver</a> &gt;::send_blob_max_size</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Yields <code><a class="el" href="classipc_1_1transport_1_1Channel.html#a647bc9b6f8b9fb0b546cf3879cb5d4c1" title="Pointer to the mutable owned Blob_sender_obj; null if yet initialized.">blob_snd()</a>-&gt;</code> same method. </p>
<dl class="section return"><dt>Returns</dt><dd>See concept API. </dd></dl>

</div>
</div>
<a id="a37e1f03a11d1e1df9148048a8a6bab62" name="a37e1f03a11d1e1df9148048a8a6bab62"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a37e1f03a11d1e1df9148048a8a6bab62">&#9670;&nbsp;</a></span>send_meta_blob_max_size()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename <a class="el" href="classipc_1_1transport_1_1Blob__sender.html">Blob_sender</a> , typename <a class="el" href="classipc_1_1transport_1_1Blob__receiver.html">Blob_receiver</a> , typename <a class="el" href="classipc_1_1transport_1_1Native__handle__sender.html">Native_handle_sender</a> , typename <a class="el" href="classipc_1_1transport_1_1Native__handle__receiver.html">Native_handle_receiver</a> &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">size_t <a class="el" href="classipc_1_1transport_1_1Channel.html">ipc::transport::Channel</a>&lt; <a class="el" href="classipc_1_1transport_1_1Blob__sender.html">Blob_sender</a>, <a class="el" href="classipc_1_1transport_1_1Blob__receiver.html">Blob_receiver</a>, <a class="el" href="classipc_1_1transport_1_1Native__handle__sender.html">Native_handle_sender</a>, <a class="el" href="classipc_1_1transport_1_1Native__handle__receiver.html">Native_handle_receiver</a> &gt;::send_meta_blob_max_size</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Yields <code><a class="el" href="classipc_1_1transport_1_1Channel.html#aa838026c33e4e422df7cd78d3a426b6a" title="Pointer to the mutable owned Native_handle_sender_obj; null if not yet initialized.">hndl_snd()</a>-&gt;</code> same method. </p>
<dl class="section return"><dt>Returns</dt><dd>See concept API. </dd></dl>

</div>
</div>
<a id="a9bd6a744b8decdc872357fcea33897af" name="a9bd6a744b8decdc872357fcea33897af"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9bd6a744b8decdc872357fcea33897af">&#9670;&nbsp;</a></span>send_native_handle()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename <a class="el" href="classipc_1_1transport_1_1Blob__sender.html">Blob_sender</a> , typename <a class="el" href="classipc_1_1transport_1_1Blob__receiver.html">Blob_receiver</a> , typename <a class="el" href="classipc_1_1transport_1_1Native__handle__sender.html">Native_handle_sender</a> , typename <a class="el" href="classipc_1_1transport_1_1Native__handle__receiver.html">Native_handle_receiver</a> &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classipc_1_1transport_1_1Channel.html">ipc::transport::Channel</a>&lt; <a class="el" href="classipc_1_1transport_1_1Blob__sender.html">Blob_sender</a>, <a class="el" href="classipc_1_1transport_1_1Blob__receiver.html">Blob_receiver</a>, <a class="el" href="classipc_1_1transport_1_1Native__handle__sender.html">Native_handle_sender</a>, <a class="el" href="classipc_1_1transport_1_1Native__handle__receiver.html">Native_handle_receiver</a> &gt;::send_native_handle </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespaceipc_1_1transport.html#a7ee4551983d9df16ec16a3139bac50e8">Native_handle</a>&#160;</td>
          <td class="paramname"><em>hndl_or_null</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespaceipc_1_1util.html#ae0be7edba7e30ffa3f8b742af621f2ab">util::Blob_const</a> &amp;&#160;</td>
          <td class="paramname"><em>meta_blob</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceipc.html#aa3192e586cc45d3e7c22463bf2760f89">Error_code</a> *&#160;</td>
          <td class="paramname"><em>err_code</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Yields <code><a class="el" href="classipc_1_1transport_1_1Channel.html#aa838026c33e4e422df7cd78d3a426b6a" title="Pointer to the mutable owned Native_handle_sender_obj; null if not yet initialized.">hndl_snd()</a>-&gt;</code> same method. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">hndl_or_null</td><td>See concept API. </td></tr>
    <tr><td class="paramname">meta_blob</td><td>See concept API. </td></tr>
    <tr><td class="paramname">err_code</td><td>See concept API. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>See concept API. </dd></dl>

</div>
</div>
<a id="a0b00c99196fbe8c154f14dbf8f0ceb79" name="a0b00c99196fbe8c154f14dbf8f0ceb79"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0b00c99196fbe8c154f14dbf8f0ceb79">&#9670;&nbsp;</a></span>start_receive_blob_ops()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename <a class="el" href="classipc_1_1transport_1_1Blob__sender.html">Blob_sender</a> , typename <a class="el" href="classipc_1_1transport_1_1Blob__receiver.html">Blob_receiver</a> , typename <a class="el" href="classipc_1_1transport_1_1Native__handle__sender.html">Native_handle_sender</a> , typename <a class="el" href="classipc_1_1transport_1_1Native__handle__receiver.html">Native_handle_receiver</a> &gt; </div>
<div class="memtemplate">
template&lt;typename Event_wait_func_t &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classipc_1_1transport_1_1Channel.html">ipc::transport::Channel</a>&lt; <a class="el" href="classipc_1_1transport_1_1Blob__sender.html">Blob_sender</a>, <a class="el" href="classipc_1_1transport_1_1Blob__receiver.html">Blob_receiver</a>, <a class="el" href="classipc_1_1transport_1_1Native__handle__sender.html">Native_handle_sender</a>, <a class="el" href="classipc_1_1transport_1_1Native__handle__receiver.html">Native_handle_receiver</a> &gt;::start_receive_blob_ops </td>
          <td>(</td>
          <td class="paramtype">Event_wait_func_t &amp;&amp;&#160;</td>
          <td class="paramname"><em>ev_wait_func</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Yields <code><a class="el" href="classipc_1_1transport_1_1Channel.html#a87fd94fa483cabd78059a3d1d094880d" title="Pointer to the mutable owned Blob_receiver_obj; null if not yet initialized.">blob_rcv()</a>-&gt;</code> same method. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Event_wait_func_t</td><td>See concept API. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ev_wait_func</td><td>See concept API. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>See concept API. </dd></dl>

</div>
</div>
<a id="a61f7ffbf72ee0fe46997ae08f9adaeb2" name="a61f7ffbf72ee0fe46997ae08f9adaeb2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a61f7ffbf72ee0fe46997ae08f9adaeb2">&#9670;&nbsp;</a></span>start_receive_native_handle_ops()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename <a class="el" href="classipc_1_1transport_1_1Blob__sender.html">Blob_sender</a> , typename <a class="el" href="classipc_1_1transport_1_1Blob__receiver.html">Blob_receiver</a> , typename <a class="el" href="classipc_1_1transport_1_1Native__handle__sender.html">Native_handle_sender</a> , typename <a class="el" href="classipc_1_1transport_1_1Native__handle__receiver.html">Native_handle_receiver</a> &gt; </div>
<div class="memtemplate">
template&lt;typename Event_wait_func_t &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classipc_1_1transport_1_1Channel.html">ipc::transport::Channel</a>&lt; <a class="el" href="classipc_1_1transport_1_1Blob__sender.html">Blob_sender</a>, <a class="el" href="classipc_1_1transport_1_1Blob__receiver.html">Blob_receiver</a>, <a class="el" href="classipc_1_1transport_1_1Native__handle__sender.html">Native_handle_sender</a>, <a class="el" href="classipc_1_1transport_1_1Native__handle__receiver.html">Native_handle_receiver</a> &gt;::start_receive_native_handle_ops </td>
          <td>(</td>
          <td class="paramtype">Event_wait_func_t &amp;&amp;&#160;</td>
          <td class="paramname"><em>ev_wait_func</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Yields <code><a class="el" href="classipc_1_1transport_1_1Channel.html#af4c9cd7b02193fa2e8bf1742ab87111a" title="Pointer to the mutable owned Native_handle_receiver_obj; null if not yet initialized.">hndl_rcv()</a>-&gt;</code> same method. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Event_wait_func_t</td><td>See concept API. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ev_wait_func</td><td>See concept API. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>See concept API. </dd></dl>

</div>
</div>
<a id="aabafc3beaf1a57e4767c023d9c4f9f93" name="aabafc3beaf1a57e4767c023d9c4f9f93"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aabafc3beaf1a57e4767c023d9c4f9f93">&#9670;&nbsp;</a></span>start_send_blob_ops()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename <a class="el" href="classipc_1_1transport_1_1Blob__sender.html">Blob_sender</a> , typename <a class="el" href="classipc_1_1transport_1_1Blob__receiver.html">Blob_receiver</a> , typename <a class="el" href="classipc_1_1transport_1_1Native__handle__sender.html">Native_handle_sender</a> , typename <a class="el" href="classipc_1_1transport_1_1Native__handle__receiver.html">Native_handle_receiver</a> &gt; </div>
<div class="memtemplate">
template&lt;typename Event_wait_func_t &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classipc_1_1transport_1_1Channel.html">ipc::transport::Channel</a>&lt; <a class="el" href="classipc_1_1transport_1_1Blob__sender.html">Blob_sender</a>, <a class="el" href="classipc_1_1transport_1_1Blob__receiver.html">Blob_receiver</a>, <a class="el" href="classipc_1_1transport_1_1Native__handle__sender.html">Native_handle_sender</a>, <a class="el" href="classipc_1_1transport_1_1Native__handle__receiver.html">Native_handle_receiver</a> &gt;::start_send_blob_ops </td>
          <td>(</td>
          <td class="paramtype">Event_wait_func_t &amp;&amp;&#160;</td>
          <td class="paramname"><em>ev_wait_func</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Yields <code><a class="el" href="classipc_1_1transport_1_1Channel.html#a647bc9b6f8b9fb0b546cf3879cb5d4c1" title="Pointer to the mutable owned Blob_sender_obj; null if yet initialized.">blob_snd()</a>-&gt;</code> same method. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Event_wait_func_t</td><td>See concept API. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ev_wait_func</td><td>See concept API. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>See concept API. </dd></dl>

</div>
</div>
<a id="ac2413ad0e4178fc321e71b5fe4ca2ce2" name="ac2413ad0e4178fc321e71b5fe4ca2ce2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac2413ad0e4178fc321e71b5fe4ca2ce2">&#9670;&nbsp;</a></span>start_send_native_handle_ops()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename <a class="el" href="classipc_1_1transport_1_1Blob__sender.html">Blob_sender</a> , typename <a class="el" href="classipc_1_1transport_1_1Blob__receiver.html">Blob_receiver</a> , typename <a class="el" href="classipc_1_1transport_1_1Native__handle__sender.html">Native_handle_sender</a> , typename <a class="el" href="classipc_1_1transport_1_1Native__handle__receiver.html">Native_handle_receiver</a> &gt; </div>
<div class="memtemplate">
template&lt;typename Event_wait_func_t &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classipc_1_1transport_1_1Channel.html">ipc::transport::Channel</a>&lt; <a class="el" href="classipc_1_1transport_1_1Blob__sender.html">Blob_sender</a>, <a class="el" href="classipc_1_1transport_1_1Blob__receiver.html">Blob_receiver</a>, <a class="el" href="classipc_1_1transport_1_1Native__handle__sender.html">Native_handle_sender</a>, <a class="el" href="classipc_1_1transport_1_1Native__handle__receiver.html">Native_handle_receiver</a> &gt;::start_send_native_handle_ops </td>
          <td>(</td>
          <td class="paramtype">Event_wait_func_t &amp;&amp;&#160;</td>
          <td class="paramname"><em>ev_wait_func</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Yields <code><a class="el" href="classipc_1_1transport_1_1Channel.html#aa838026c33e4e422df7cd78d3a426b6a" title="Pointer to the mutable owned Native_handle_sender_obj; null if not yet initialized.">hndl_snd()</a>-&gt;</code> same method. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Event_wait_func_t</td><td>See concept API. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ev_wait_func</td><td>See concept API. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>See concept API. </dd></dl>

</div>
</div>
<h2 class="groupheader">Friends And Related Function Documentation</h2>
<a id="a8eff22e594b6fe82f94f13d6a172537f" name="a8eff22e594b6fe82f94f13d6a172537f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8eff22e594b6fe82f94f13d6a172537f">&#9670;&nbsp;</a></span>operator&lt;&lt;()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename <a class="el" href="classipc_1_1transport_1_1Blob__sender.html">Blob_sender</a> , typename <a class="el" href="classipc_1_1transport_1_1Blob__receiver.html">Blob_receiver</a> , typename <a class="el" href="classipc_1_1transport_1_1Native__handle__sender.html">Native_handle_sender</a> , typename <a class="el" href="classipc_1_1transport_1_1Native__handle__receiver.html">Native_handle_receiver</a> &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::ostream &amp; operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>os</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classipc_1_1transport_1_1Channel.html">Channel</a>&lt; <a class="el" href="classipc_1_1transport_1_1Blob__sender.html">Blob_sender</a>, <a class="el" href="classipc_1_1transport_1_1Blob__receiver.html">Blob_receiver</a>, <a class="el" href="classipc_1_1transport_1_1Native__handle__sender.html">Native_handle_sender</a>, <a class="el" href="classipc_1_1transport_1_1Native__handle__receiver.html">Native_handle_receiver</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>val</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Prints string representation of the given <code><a class="el" href="classipc_1_1transport_1_1Channel.html" title="Peer to a bundle of 1-2 full-duplex pipe(s), one for transmitting unstructured binary blobs; the othe...">Channel</a></code> to the given <code>ostream</code>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">os</td><td>Stream to which to write. </td></tr>
    <tr><td class="paramname">val</td><td>Object to serialize. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>os</code>. </dd></dl>

</div>
</div>
<h2 class="groupheader">Member Data Documentation</h2>
<a id="a9f75b20b07eff47a69c2b1dbe5c85f84" name="a9f75b20b07eff47a69c2b1dbe5c85f84"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9f75b20b07eff47a69c2b1dbe5c85f84">&#9670;&nbsp;</a></span>S_IS_ASYNC_IO_OBJ</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename <a class="el" href="classipc_1_1transport_1_1Blob__sender.html">Blob_sender</a> , typename <a class="el" href="classipc_1_1transport_1_1Blob__receiver.html">Blob_receiver</a> , typename <a class="el" href="classipc_1_1transport_1_1Native__handle__sender.html">Native_handle_sender</a> , typename <a class="el" href="classipc_1_1transport_1_1Native__handle__receiver.html">Native_handle_receiver</a> &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr bool <a class="el" href="classipc_1_1transport_1_1Channel.html">ipc::transport::Channel</a>&lt; <a class="el" href="classipc_1_1transport_1_1Blob__sender.html">Blob_sender</a>, <a class="el" href="classipc_1_1transport_1_1Blob__receiver.html">Blob_receiver</a>, <a class="el" href="classipc_1_1transport_1_1Native__handle__sender.html">Native_handle_sender</a>, <a class="el" href="classipc_1_1transport_1_1Native__handle__receiver.html">Native_handle_receiver</a> &gt;::S_IS_ASYNC_IO_OBJ = !<a class="el" href="classipc_1_1transport_1_1Channel.html#ae5be240d29389d7b728950e85df0704e">S_IS_SYNC_IO_OBJ</a></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>It equals the reverse of <a class="el" href="classipc_1_1transport_1_1Channel.html#ae5be240d29389d7b728950e85df0704e" title="Useful for generic programming: true &lt;=&gt; each non-Null_peer peer type (Blob_sender_obj,...">S_IS_SYNC_IO_OBJ</a>. </p>
<p >That is all peer types are of the async-I/O pattern variety (by convention living directly in namespace <a class="el" href="namespaceipc_1_1transport.html" title="Flow-IPC module providing transmission of structured messages and/or low-level blobs (and more) betwe...">ipc::transport</a>). </p>

</div>
</div>
<hr/>The documentation for this class was generated from the following files:<ul>
<li>transport/<a class="el" href="ipc__core_2src_2ipc_2transport_2channel_8hpp.html">channel.hpp</a></li>
<li>transport/<a class="el" href="transport__fwd_8hpp.html">transport_fwd.hpp</a></li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Thu Feb 22 2024 02:18:42 for Flow-IPC by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.4
</small></address>
</body>
</html>
