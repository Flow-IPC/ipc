<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.9.4"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Flow-IPC: ipc::transport::struc::sync_io::Channel&lt; Channel_obj, Message_body, Struct_builder_config, Struct_reader_config &gt; Class Template Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">Flow-IPC<span id="projectnumber">&#160;1.0</span>
   </div>
   <div id="projectbrief">Flow-IPC project: Public API.</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.4 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search",'Search','.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespaceipc.html">ipc</a></li><li class="navelem"><a class="el" href="namespaceipc_1_1transport.html">transport</a></li><li class="navelem"><a class="el" href="namespaceipc_1_1transport_1_1struc.html">struc</a></li><li class="navelem"><a class="el" href="namespaceipc_1_1transport_1_1struc_1_1sync__io.html">sync_io</a></li><li class="navelem"><a class="el" href="classipc_1_1transport_1_1struc_1_1sync__io_1_1Channel.html">Channel</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-types">Public Types</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#related">Related Functions</a> &#124;
<a href="classipc_1_1transport_1_1struc_1_1sync__io_1_1Channel-members.html">List of all members</a>  </div>
  <div class="headertitle"><div class="title">ipc::transport::struc::sync_io::Channel&lt; Channel_obj, Message_body, Struct_builder_config, Struct_reader_config &gt; Class Template Reference</div></div>
</div><!--header-->
<div class="contents">

<p><code><a class="el" href="namespaceipc_1_1transport_1_1struc_1_1sync__io.html" title="sync_io-pattern counterparts to async-I/O-pattern object types in parent namespace ipc::transport::st...">sync_io</a></code>-pattern counterpart to async-I/O-pattern <a class="el" href="classipc_1_1transport_1_1struc_1_1Channel.html" title="Owning and wrapping a pre-connected transport::Channel peer (an endpoint of an established channel ov...">transport::struc::Channel</a>.  
 <a href="classipc_1_1transport_1_1struc_1_1sync__io_1_1Channel.html#details">More...</a></p>

<p><code>#include &lt;channel.hpp&gt;</code></p>
<div class="dynheader">
Inheritance diagram for ipc::transport::struc::sync_io::Channel&lt; Channel_obj, Message_body, Struct_builder_config, Struct_reader_config &gt;:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="classipc_1_1transport_1_1struc_1_1sync__io_1_1Channel__inherit__graph.svg" width="194" height="167"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe>
</div>
<center><span class="legend">[<a href="graph_legend.html">legend</a>]</span></center></div>
<div class="dynheader">
Collaboration diagram for ipc::transport::struc::sync_io::Channel&lt; Channel_obj, Message_body, Struct_builder_config, Struct_reader_config &gt;:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="classipc_1_1transport_1_1struc_1_1sync__io_1_1Channel__coll__graph.svg" width="758" height="203"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe>
</div>
<center><span class="legend">[<a href="graph_legend.html">legend</a>]</span></center></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-types" name="pub-types"></a>
Public Types</h2></td></tr>
<tr class="memitem:a6dc83bd6057b7f00a19c5947d6baa7b7"><td class="memItemLeft" align="right" valign="top"><a id="a6dc83bd6057b7f00a19c5947d6baa7b7" name="a6dc83bd6057b7f00a19c5947d6baa7b7"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>Async_io_obj</b> = <a class="el" href="classipc_1_1transport_1_1struc_1_1Channel.html">transport::struc::Channel</a>&lt; Channel_obj, Message_body, Struct_builder_config, Struct_reader_config &gt;</td></tr>
<tr class="memdesc:a6dc83bd6057b7f00a19c5947d6baa7b7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Useful for generic programming, the async-I/O-pattern counterpart to <code>*this</code> type. <br /></td></tr>
<tr class="separator:a6dc83bd6057b7f00a19c5947d6baa7b7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5bb15c142ca501fe5fdfa8068d076e36"><td class="memItemLeft" align="right" valign="top"><a id="a5bb15c142ca501fe5fdfa8068d076e36" name="a5bb15c142ca501fe5fdfa8068d076e36"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>Sync_io_obj</b> = <a class="el" href="classipc_1_1transport_1_1Null__peer.html">Null_peer</a></td></tr>
<tr class="memdesc:a5bb15c142ca501fe5fdfa8068d076e36"><td class="mdescLeft">&#160;</td><td class="mdescRight">You may disregard. <br /></td></tr>
<tr class="separator:a5bb15c142ca501fe5fdfa8068d076e36"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4abac89dbd4d26c79b7915990f751a76"><td class="memItemLeft" align="right" valign="top"><a id="a4abac89dbd4d26c79b7915990f751a76" name="a4abac89dbd4d26c79b7915990f751a76"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>Owned_channel</b> = Channel_obj</td></tr>
<tr class="memdesc:a4abac89dbd4d26c79b7915990f751a76"><td class="mdescLeft">&#160;</td><td class="mdescRight">See <a class="el" href="classipc_1_1transport_1_1struc_1_1sync__io_1_1Channel.html#a6dc83bd6057b7f00a19c5947d6baa7b7" title="Useful for generic programming, the async-I/O-pattern counterpart to *this type.">Async_io_obj</a> counterpart. <br /></td></tr>
<tr class="separator:a4abac89dbd4d26c79b7915990f751a76"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8a59bbc3c6a7191b316b23661d8ba6e3"><td class="memItemLeft" align="right" valign="top"><a id="a8a59bbc3c6a7191b316b23661d8ba6e3" name="a8a59bbc3c6a7191b316b23661d8ba6e3"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>Builder_config</b> = Struct_builder_config</td></tr>
<tr class="memdesc:a8a59bbc3c6a7191b316b23661d8ba6e3"><td class="mdescLeft">&#160;</td><td class="mdescRight">See <a class="el" href="classipc_1_1transport_1_1struc_1_1sync__io_1_1Channel.html#a6dc83bd6057b7f00a19c5947d6baa7b7" title="Useful for generic programming, the async-I/O-pattern counterpart to *this type.">Async_io_obj</a> counterpart. <br /></td></tr>
<tr class="separator:a8a59bbc3c6a7191b316b23661d8ba6e3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a14a7166b2f8c117ce6ddafe943d036fa"><td class="memItemLeft" align="right" valign="top"><a id="a14a7166b2f8c117ce6ddafe943d036fa" name="a14a7166b2f8c117ce6ddafe943d036fa"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>Reader_config</b> = Struct_reader_config</td></tr>
<tr class="memdesc:a14a7166b2f8c117ce6ddafe943d036fa"><td class="mdescLeft">&#160;</td><td class="mdescRight">See <a class="el" href="classipc_1_1transport_1_1struc_1_1sync__io_1_1Channel.html#a6dc83bd6057b7f00a19c5947d6baa7b7" title="Useful for generic programming, the async-I/O-pattern counterpart to *this type.">Async_io_obj</a> counterpart. <br /></td></tr>
<tr class="separator:a14a7166b2f8c117ce6ddafe943d036fa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a34e183c252390f369f121074772c14c4"><td class="memItemLeft" align="right" valign="top"><a id="a34e183c252390f369f121074772c14c4" name="a34e183c252390f369f121074772c14c4"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>Msg_body</b> = Message_body</td></tr>
<tr class="memdesc:a34e183c252390f369f121074772c14c4"><td class="mdescLeft">&#160;</td><td class="mdescRight">See <a class="el" href="classipc_1_1transport_1_1struc_1_1sync__io_1_1Channel.html#a6dc83bd6057b7f00a19c5947d6baa7b7" title="Useful for generic programming, the async-I/O-pattern counterpart to *this type.">Async_io_obj</a> counterpart. <br /></td></tr>
<tr class="separator:a34e183c252390f369f121074772c14c4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1572a1b1cb4a72ea57f7841a5e78759b"><td class="memItemLeft" align="right" valign="top"><a id="a1572a1b1cb4a72ea57f7841a5e78759b" name="a1572a1b1cb4a72ea57f7841a5e78759b"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>Msg_which</b> = typename Message_body::Which</td></tr>
<tr class="memdesc:a1572a1b1cb4a72ea57f7841a5e78759b"><td class="mdescLeft">&#160;</td><td class="mdescRight">See <a class="el" href="classipc_1_1transport_1_1struc_1_1sync__io_1_1Channel.html#a6dc83bd6057b7f00a19c5947d6baa7b7" title="Useful for generic programming, the async-I/O-pattern counterpart to *this type.">Async_io_obj</a> counterpart. <br /></td></tr>
<tr class="separator:a1572a1b1cb4a72ea57f7841a5e78759b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa40c3ec3f45cdfea9360f7f35b9ade3c"><td class="memItemLeft" align="right" valign="top"><a id="aa40c3ec3f45cdfea9360f7f35b9ade3c" name="aa40c3ec3f45cdfea9360f7f35b9ade3c"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>Msg_which_in</b> = <a class="el" href="classipc_1_1transport_1_1struc_1_1sync__io_1_1Channel.html#a1572a1b1cb4a72ea57f7841a5e78759b">Msg_which</a></td></tr>
<tr class="memdesc:aa40c3ec3f45cdfea9360f7f35b9ade3c"><td class="mdescLeft">&#160;</td><td class="mdescRight">See <a class="el" href="classipc_1_1transport_1_1struc_1_1sync__io_1_1Channel.html#a6dc83bd6057b7f00a19c5947d6baa7b7" title="Useful for generic programming, the async-I/O-pattern counterpart to *this type.">Async_io_obj</a> counterpart. <br /></td></tr>
<tr class="separator:aa40c3ec3f45cdfea9360f7f35b9ade3c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7a731cdae5217ed9e867fb80c1fb0fd9"><td class="memItemLeft" align="right" valign="top"><a id="a7a731cdae5217ed9e867fb80c1fb0fd9" name="a7a731cdae5217ed9e867fb80c1fb0fd9"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>Msg_which_out</b> = <a class="el" href="classipc_1_1transport_1_1struc_1_1sync__io_1_1Channel.html#a1572a1b1cb4a72ea57f7841a5e78759b">Msg_which</a></td></tr>
<tr class="memdesc:a7a731cdae5217ed9e867fb80c1fb0fd9"><td class="mdescLeft">&#160;</td><td class="mdescRight">See <a class="el" href="classipc_1_1transport_1_1struc_1_1sync__io_1_1Channel.html#a6dc83bd6057b7f00a19c5947d6baa7b7" title="Useful for generic programming, the async-I/O-pattern counterpart to *this type.">Async_io_obj</a> counterpart. <br /></td></tr>
<tr class="separator:a7a731cdae5217ed9e867fb80c1fb0fd9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a83fb4462a8d4045bdb56b694bf80393c"><td class="memItemLeft" align="right" valign="top"><a id="a83fb4462a8d4045bdb56b694bf80393c" name="a83fb4462a8d4045bdb56b694bf80393c"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>Msg_out</b> = <a class="el" href="classipc_1_1transport_1_1struc_1_1Msg__out.html">struc::Msg_out</a>&lt; <a class="el" href="classipc_1_1transport_1_1struc_1_1sync__io_1_1Channel.html#a34e183c252390f369f121074772c14c4">Msg_body</a>, typename Builder_config::Builder &gt;</td></tr>
<tr class="memdesc:a83fb4462a8d4045bdb56b694bf80393c"><td class="mdescLeft">&#160;</td><td class="mdescRight">See <a class="el" href="classipc_1_1transport_1_1struc_1_1sync__io_1_1Channel.html#a6dc83bd6057b7f00a19c5947d6baa7b7" title="Useful for generic programming, the async-I/O-pattern counterpart to *this type.">Async_io_obj</a> counterpart. <br /></td></tr>
<tr class="separator:a83fb4462a8d4045bdb56b694bf80393c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac3da0ac1306b63c9e38c47b8c31e3cd2"><td class="memItemLeft" align="right" valign="top"><a id="ac3da0ac1306b63c9e38c47b8c31e3cd2" name="ac3da0ac1306b63c9e38c47b8c31e3cd2"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>Msg_in</b> = <a class="el" href="classipc_1_1transport_1_1struc_1_1Msg__in.html">struc::Msg_in</a>&lt; <a class="el" href="classipc_1_1transport_1_1struc_1_1sync__io_1_1Channel.html#a34e183c252390f369f121074772c14c4">Msg_body</a>, <a class="el" href="classipc_1_1transport_1_1struc_1_1sync__io_1_1Channel.html#a14a7166b2f8c117ce6ddafe943d036fa">Reader_config</a> &gt;</td></tr>
<tr class="memdesc:ac3da0ac1306b63c9e38c47b8c31e3cd2"><td class="mdescLeft">&#160;</td><td class="mdescRight">See <a class="el" href="classipc_1_1transport_1_1struc_1_1sync__io_1_1Channel.html#a6dc83bd6057b7f00a19c5947d6baa7b7" title="Useful for generic programming, the async-I/O-pattern counterpart to *this type.">Async_io_obj</a> counterpart. <br /></td></tr>
<tr class="separator:ac3da0ac1306b63c9e38c47b8c31e3cd2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acde2b3866547a30958035203d9d89928"><td class="memItemLeft" align="right" valign="top"><a id="acde2b3866547a30958035203d9d89928" name="acde2b3866547a30958035203d9d89928"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>Msg_in_ptr</b> = boost::shared_ptr&lt; <a class="el" href="classipc_1_1transport_1_1struc_1_1sync__io_1_1Channel.html#ac3da0ac1306b63c9e38c47b8c31e3cd2">Msg_in</a> &gt;</td></tr>
<tr class="memdesc:acde2b3866547a30958035203d9d89928"><td class="mdescLeft">&#160;</td><td class="mdescRight">See <a class="el" href="classipc_1_1transport_1_1struc_1_1sync__io_1_1Channel.html#a6dc83bd6057b7f00a19c5947d6baa7b7" title="Useful for generic programming, the async-I/O-pattern counterpart to *this type.">Async_io_obj</a> counterpart. <br /></td></tr>
<tr class="separator:acde2b3866547a30958035203d9d89928"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4ab778bce8d7e6e84788879fedc62745"><td class="memItemLeft" align="right" valign="top"><a id="a4ab778bce8d7e6e84788879fedc62745" name="a4ab778bce8d7e6e84788879fedc62745"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>Msgs_in</b> = std::vector&lt; <a class="el" href="classipc_1_1transport_1_1struc_1_1sync__io_1_1Channel.html#acde2b3866547a30958035203d9d89928">Msg_in_ptr</a> &gt;</td></tr>
<tr class="memdesc:a4ab778bce8d7e6e84788879fedc62745"><td class="mdescLeft">&#160;</td><td class="mdescRight">List of in-messages used in certain APIs like <a class="el" href="classipc_1_1transport_1_1struc_1_1sync__io_1_1Channel.html#a62f52488ba20dd6c69dfc1abadb2d69f" title="Registers the expectation (some of which may be immediately met) of 0+ notification in-messages whose...">expect_msgs()</a> to synchronously emit cached in-messages. <br /></td></tr>
<tr class="separator:a4ab778bce8d7e6e84788879fedc62745"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9b5d17887c9ad1e37081bf4ae4a70e65"><td class="memItemLeft" align="right" valign="top"><a id="a9b5d17887c9ad1e37081bf4ae4a70e65" name="a9b5d17887c9ad1e37081bf4ae4a70e65"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>msg_id_out_t</b> = <a class="el" href="classipc_1_1transport_1_1struc_1_1Channel__base.html#adcf24fa51747ed83c4b6427fbf44fecf">Channel_base::msg_id_out_t</a></td></tr>
<tr class="memdesc:a9b5d17887c9ad1e37081bf4ae4a70e65"><td class="mdescLeft">&#160;</td><td class="mdescRight">See <a class="el" href="classipc_1_1transport_1_1struc_1_1sync__io_1_1Channel.html#a6dc83bd6057b7f00a19c5947d6baa7b7" title="Useful for generic programming, the async-I/O-pattern counterpart to *this type.">Async_io_obj</a> counterpart. <br /></td></tr>
<tr class="separator:a9b5d17887c9ad1e37081bf4ae4a70e65"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pub_types_classipc_1_1transport_1_1struc_1_1Channel__base"><td colspan="2" onclick="javascript:toggleInherit('pub_types_classipc_1_1transport_1_1struc_1_1Channel__base')"><img src="closed.png" alt="-"/>&#160;Public Types inherited from <a class="el" href="classipc_1_1transport_1_1struc_1_1Channel__base.html">ipc::transport::struc::Channel_base</a></td></tr>
<tr class="memitem:adcf24fa51747ed83c4b6427fbf44fecf inherit pub_types_classipc_1_1transport_1_1struc_1_1Channel__base"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classipc_1_1transport_1_1struc_1_1Channel__base.html#adcf24fa51747ed83c4b6427fbf44fecf">msg_id_out_t</a> = <a class="el" href="namespaceipc_1_1transport_1_1struc.html#af7f35fc7588d97a838274fa25700ead9">msg_id_t</a></td></tr>
<tr class="memdesc:adcf24fa51747ed83c4b6427fbf44fecf inherit pub_types_classipc_1_1transport_1_1struc_1_1Channel__base"><td class="mdescLeft">&#160;</td><td class="mdescRight">Clarifying short-hand for outgoing-message IDs.  <a href="classipc_1_1transport_1_1struc_1_1Channel__base.html#adcf24fa51747ed83c4b6427fbf44fecf">More...</a><br /></td></tr>
<tr class="separator:adcf24fa51747ed83c4b6427fbf44fecf inherit pub_types_classipc_1_1transport_1_1struc_1_1Channel__base"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-methods" name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a9385752ed00263dec5c5080b67ce0960"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classipc_1_1transport_1_1struc_1_1sync__io_1_1Channel.html#a9385752ed00263dec5c5080b67ce0960">Channel</a> (flow::log::Logger *logger_ptr, <a class="el" href="classipc_1_1transport_1_1struc_1_1sync__io_1_1Channel.html#a4abac89dbd4d26c79b7915990f751a76">Owned_channel</a> &amp;&amp;channel, const <a class="el" href="classipc_1_1transport_1_1struc_1_1sync__io_1_1Channel.html#a8a59bbc3c6a7191b316b23661d8ba6e3">Builder_config</a> &amp;<a class="el" href="classipc_1_1transport_1_1struc_1_1sync__io_1_1Channel.html#a48a8fd167c1fe6ae95d8fc80b6a6e67f">struct_builder_config</a>, const typename Builder_config::Builder::Session &amp;<a class="el" href="classipc_1_1transport_1_1struc_1_1sync__io_1_1Channel.html#a43fa0b77781376edd13b742b832572e1">struct_lender_session</a>, const <a class="el" href="classipc_1_1transport_1_1struc_1_1sync__io_1_1Channel.html#a14a7166b2f8c117ce6ddafe943d036fa">Reader_config</a> &amp;<a class="el" href="classipc_1_1transport_1_1struc_1_1sync__io_1_1Channel.html#a7efbfbcce0d4d426b7df9b6d6fd1e373">struct_reader_config</a>, const <a class="el" href="namespaceipc_1_1transport_1_1struc.html#a6751c05fb6582a34c7c47ac470c4a48b">Session_token</a> &amp;session_token_non_nil)</td></tr>
<tr class="memdesc:a9385752ed00263dec5c5080b67ce0960"><td class="mdescLeft">&#160;</td><td class="mdescRight">Non-tag, no-log-in ctor form: Creates structured channel peer with no log-in phase (log-in phase must have occurred in a preceding <a class="el" href="classipc_1_1transport_1_1struc_1_1Channel.html" title="Owning and wrapping a pre-connected transport::Channel peer (an endpoint of an established channel ov...">struc::Channel</a> called <em>session master channel</em>), the session token already known and passed-in to this ctor.  <a href="classipc_1_1transport_1_1struc_1_1sync__io_1_1Channel.html#a9385752ed00263dec5c5080b67ce0960">More...</a><br /></td></tr>
<tr class="separator:a9385752ed00263dec5c5080b67ce0960"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5b863cba6eec77f20236d1e8c8d006a3"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classipc_1_1transport_1_1struc_1_1sync__io_1_1Channel.html#a5b863cba6eec77f20236d1e8c8d006a3">Channel</a> (flow::log::Logger *logger_ptr, <a class="el" href="classipc_1_1transport_1_1struc_1_1sync__io_1_1Channel.html#a4abac89dbd4d26c79b7915990f751a76">Owned_channel</a> &amp;&amp;channel, const <a class="el" href="classipc_1_1transport_1_1struc_1_1sync__io_1_1Channel.html#a8a59bbc3c6a7191b316b23661d8ba6e3">Builder_config</a> &amp;<a class="el" href="classipc_1_1transport_1_1struc_1_1sync__io_1_1Channel.html#a48a8fd167c1fe6ae95d8fc80b6a6e67f">struct_builder_config</a>, const typename Builder_config::Builder::Session &amp;<a class="el" href="classipc_1_1transport_1_1struc_1_1sync__io_1_1Channel.html#a43fa0b77781376edd13b742b832572e1">struct_lender_session</a>, const <a class="el" href="classipc_1_1transport_1_1struc_1_1sync__io_1_1Channel.html#a14a7166b2f8c117ce6ddafe943d036fa">Reader_config</a> &amp;<a class="el" href="classipc_1_1transport_1_1struc_1_1sync__io_1_1Channel.html#a7efbfbcce0d4d426b7df9b6d6fd1e373">struct_reader_config</a>, bool is_server)</td></tr>
<tr class="memdesc:a5b863cba6eec77f20236d1e8c8d006a3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Non-tag, with-log-in ctor form: Creates structured channel peer (endpoint of the <em>session master channel</em>) with a log-in phase, this peer being the <em>server</em> or <em>client</em> depending on the arg <code>is_server</code>.  <a href="classipc_1_1transport_1_1struc_1_1sync__io_1_1Channel.html#a5b863cba6eec77f20236d1e8c8d006a3">More...</a><br /></td></tr>
<tr class="separator:a5b863cba6eec77f20236d1e8c8d006a3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a81c366280bf0f3cd711eba0a9f81698f"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classipc_1_1transport_1_1struc_1_1sync__io_1_1Channel.html#a81c366280bf0f3cd711eba0a9f81698f">Channel</a> (flow::log::Logger *logger_ptr, <a class="el" href="classipc_1_1transport_1_1struc_1_1sync__io_1_1Channel.html#a4abac89dbd4d26c79b7915990f751a76">Owned_channel</a> &amp;&amp;channel, <a class="el" href="structipc_1_1transport_1_1struc_1_1Channel__base_1_1Serialize__via__heap.html">Serialize_via_heap</a> tag, const <a class="el" href="namespaceipc_1_1transport_1_1struc.html#a6751c05fb6582a34c7c47ac470c4a48b">Session_token</a> &amp;session_token_non_nil)</td></tr>
<tr class="memdesc:a81c366280bf0f3cd711eba0a9f81698f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Tag version of non-tag, no-log-in ctor: Serialize_via_heap (bidirectional heap-based, non-zero-copy message serialization).  <a href="classipc_1_1transport_1_1struc_1_1sync__io_1_1Channel.html#a81c366280bf0f3cd711eba0a9f81698f">More...</a><br /></td></tr>
<tr class="separator:a81c366280bf0f3cd711eba0a9f81698f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeb834160e2f34931c50291485d2d7d04"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classipc_1_1transport_1_1struc_1_1sync__io_1_1Channel.html#aeb834160e2f34931c50291485d2d7d04">Channel</a> (flow::log::Logger *logger_ptr, <a class="el" href="classipc_1_1transport_1_1struc_1_1sync__io_1_1Channel.html#a4abac89dbd4d26c79b7915990f751a76">Owned_channel</a> &amp;&amp;channel, <a class="el" href="structipc_1_1transport_1_1struc_1_1Channel__base_1_1Serialize__via__heap.html">Serialize_via_heap</a> tag, bool is_server)</td></tr>
<tr class="memdesc:aeb834160e2f34931c50291485d2d7d04"><td class="mdescLeft">&#160;</td><td class="mdescRight">Tag version of non-tag, with-log-in ctor: Serialize_via_heap (bidirectional heap-based, non-zero-copy message serialization).  <a href="classipc_1_1transport_1_1struc_1_1sync__io_1_1Channel.html#aeb834160e2f34931c50291485d2d7d04">More...</a><br /></td></tr>
<tr class="separator:aeb834160e2f34931c50291485d2d7d04"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a37296f3ac6713bd36d0c7b13d5f78fb7"><td class="memTemplParams" colspan="2">template&lt;typename Session &gt; </td></tr>
<tr class="memitem:a37296f3ac6713bd36d0c7b13d5f78fb7"><td class="memTemplItemLeft" align="right" valign="top">&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classipc_1_1transport_1_1struc_1_1sync__io_1_1Channel.html#a37296f3ac6713bd36d0c7b13d5f78fb7">Channel</a> (flow::log::Logger *logger_ptr, <a class="el" href="classipc_1_1transport_1_1struc_1_1sync__io_1_1Channel.html#a4abac89dbd4d26c79b7915990f751a76">Owned_channel</a> &amp;&amp;channel, <a class="el" href="structipc_1_1transport_1_1struc_1_1Channel__base_1_1Serialize__via__session__shm.html">Serialize_via_session_shm</a> tag, Session *session, const <a class="el" href="namespaceipc_1_1transport_1_1struc.html#a6751c05fb6582a34c7c47ac470c4a48b">Session_token</a> &amp;session_token_explicit=<a class="el" href="namespaceipc_1_1transport_1_1struc.html#ad556d20a2aa2d52b83c7afb73951d47d">NULL_SESSION_TOKEN</a>)</td></tr>
<tr class="memdesc:a37296f3ac6713bd36d0c7b13d5f78fb7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Tag version of non-tag, no-log-in ctor: Serialize_via_session_shm (bidirectional SHM-based provider, zero-copy message serialization, per-session-scope arena).  <a href="classipc_1_1transport_1_1struc_1_1sync__io_1_1Channel.html#a37296f3ac6713bd36d0c7b13d5f78fb7">More...</a><br /></td></tr>
<tr class="separator:a37296f3ac6713bd36d0c7b13d5f78fb7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2ec1232d7b9c59526f7d1a3c62483269"><td class="memTemplParams" colspan="2">template&lt;typename Session &gt; </td></tr>
<tr class="memitem:a2ec1232d7b9c59526f7d1a3c62483269"><td class="memTemplItemLeft" align="right" valign="top">&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classipc_1_1transport_1_1struc_1_1sync__io_1_1Channel.html#a2ec1232d7b9c59526f7d1a3c62483269">Channel</a> (flow::log::Logger *logger_ptr, <a class="el" href="classipc_1_1transport_1_1struc_1_1sync__io_1_1Channel.html#a4abac89dbd4d26c79b7915990f751a76">Owned_channel</a> &amp;&amp;channel, <a class="el" href="structipc_1_1transport_1_1struc_1_1Channel__base_1_1Serialize__via__session__shm.html">Serialize_via_session_shm</a> tag, Session *session, bool is_server)</td></tr>
<tr class="memdesc:a2ec1232d7b9c59526f7d1a3c62483269"><td class="mdescLeft">&#160;</td><td class="mdescRight">Tag version of non-tag, with-log-in ctor: Serialize_via_session_shm (bidirectional SHM-based provider, zero-copy message serialization, per-session-scope arena).  <a href="classipc_1_1transport_1_1struc_1_1sync__io_1_1Channel.html#a2ec1232d7b9c59526f7d1a3c62483269">More...</a><br /></td></tr>
<tr class="separator:a2ec1232d7b9c59526f7d1a3c62483269"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a454d0ced89cda0b092d4f86897400e1c"><td class="memTemplParams" colspan="2">template&lt;typename Session &gt; </td></tr>
<tr class="memitem:a454d0ced89cda0b092d4f86897400e1c"><td class="memTemplItemLeft" align="right" valign="top">&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classipc_1_1transport_1_1struc_1_1sync__io_1_1Channel.html#a454d0ced89cda0b092d4f86897400e1c">Channel</a> (flow::log::Logger *logger_ptr, <a class="el" href="classipc_1_1transport_1_1struc_1_1sync__io_1_1Channel.html#a4abac89dbd4d26c79b7915990f751a76">Owned_channel</a> &amp;&amp;channel, <a class="el" href="structipc_1_1transport_1_1struc_1_1Channel__base_1_1Serialize__via__app__shm.html">Serialize_via_app_shm</a> tag, Session *session, const <a class="el" href="namespaceipc_1_1transport_1_1struc.html#a6751c05fb6582a34c7c47ac470c4a48b">Session_token</a> &amp;session_token_explicit=<a class="el" href="namespaceipc_1_1transport_1_1struc.html#ad556d20a2aa2d52b83c7afb73951d47d">NULL_SESSION_TOKEN</a>)</td></tr>
<tr class="memdesc:a454d0ced89cda0b092d4f86897400e1c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Tag version of non-tag, no-log-in ctor: Serialize_via_app_shm (bidirectional SHM-based provider, zero-copy message serialization, per-app-scope arena).  <a href="classipc_1_1transport_1_1struc_1_1sync__io_1_1Channel.html#a454d0ced89cda0b092d4f86897400e1c">More...</a><br /></td></tr>
<tr class="separator:a454d0ced89cda0b092d4f86897400e1c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac056b37680ded4b3c26dd4c6941a72c6"><td class="memTemplParams" colspan="2">template&lt;typename Session &gt; </td></tr>
<tr class="memitem:ac056b37680ded4b3c26dd4c6941a72c6"><td class="memTemplItemLeft" align="right" valign="top">&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classipc_1_1transport_1_1struc_1_1sync__io_1_1Channel.html#ac056b37680ded4b3c26dd4c6941a72c6">Channel</a> (flow::log::Logger *logger_ptr, <a class="el" href="classipc_1_1transport_1_1struc_1_1sync__io_1_1Channel.html#a4abac89dbd4d26c79b7915990f751a76">Owned_channel</a> &amp;&amp;channel, <a class="el" href="structipc_1_1transport_1_1struc_1_1Channel__base_1_1Serialize__via__app__shm.html">Serialize_via_app_shm</a> tag, Session *session, bool is_server)</td></tr>
<tr class="memdesc:ac056b37680ded4b3c26dd4c6941a72c6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Tag version of non-tag, no-log-in ctor: Serialize_via_app_shm (bidirectional SHM-based provider, zero-copy message serialization, per-app-scope arena).  <a href="classipc_1_1transport_1_1struc_1_1sync__io_1_1Channel.html#ac056b37680ded4b3c26dd4c6941a72c6">More...</a><br /></td></tr>
<tr class="separator:ac056b37680ded4b3c26dd4c6941a72c6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aac7386bca503f1457d93c65e1bfdf71f"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classipc_1_1transport_1_1struc_1_1sync__io_1_1Channel.html#aac7386bca503f1457d93c65e1bfdf71f">~Channel</a> ()</td></tr>
<tr class="memdesc:aac7386bca503f1457d93c65e1bfdf71f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Invokes the destructor on the <a class="el" href="classipc_1_1transport_1_1struc_1_1sync__io_1_1Channel.html#a4abac89dbd4d26c79b7915990f751a76" title="See Async_io_obj counterpart.">Owned_channel</a>.  <a href="classipc_1_1transport_1_1struc_1_1sync__io_1_1Channel.html#aac7386bca503f1457d93c65e1bfdf71f">More...</a><br /></td></tr>
<tr class="separator:aac7386bca503f1457d93c65e1bfdf71f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a543aa806ec21b8550f9f440e59767d52"><td class="memTemplParams" colspan="2">template&lt;typename Create_ev_wait_hndl_func &gt; </td></tr>
<tr class="memitem:a543aa806ec21b8550f9f440e59767d52"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classipc_1_1transport_1_1struc_1_1sync__io_1_1Channel.html#a543aa806ec21b8550f9f440e59767d52">replace_event_wait_handles</a> (const Create_ev_wait_hndl_func &amp;create_ev_wait_hndl_func)</td></tr>
<tr class="memdesc:a543aa806ec21b8550f9f440e59767d52"><td class="mdescLeft">&#160;</td><td class="mdescRight">Analogous to <a class="el" href="classipc_1_1transport_1_1sync__io_1_1Native__handle__sender.html#abe6227dfa077571d6eed2707532e4360" title="To be (optionally) invoked before any start_*_ops(), supplies a factory for the util::sync_io::Asio_w...">transport::sync_io::Native_handle_sender::replace_event_wait_handles()</a>.  <a href="classipc_1_1transport_1_1struc_1_1sync__io_1_1Channel.html#a543aa806ec21b8550f9f440e59767d52">More...</a><br /></td></tr>
<tr class="separator:a543aa806ec21b8550f9f440e59767d52"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6e4f8c4207fcf678b4cfc785707d3dce"><td class="memTemplParams" colspan="2">template&lt;typename Event_wait_func_t &gt; </td></tr>
<tr class="memitem:a6e4f8c4207fcf678b4cfc785707d3dce"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classipc_1_1transport_1_1struc_1_1sync__io_1_1Channel.html#a6e4f8c4207fcf678b4cfc785707d3dce">start_ops</a> (Event_wait_func_t &amp;&amp;ev_wait_func)</td></tr>
<tr class="memdesc:a6e4f8c4207fcf678b4cfc785707d3dce"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets up the <code><a class="el" href="namespaceipc_1_1transport_1_1struc_1_1sync__io.html" title="sync_io-pattern counterparts to async-I/O-pattern object types in parent namespace ipc::transport::st...">sync_io</a></code>-pattern interaction between <code>*this</code> and the user's event loop; required before async_accept() will work (as opposed to no-op/return <code>false</code>).  <a href="classipc_1_1transport_1_1struc_1_1sync__io_1_1Channel.html#a6e4f8c4207fcf678b4cfc785707d3dce">More...</a><br /></td></tr>
<tr class="separator:a6e4f8c4207fcf678b4cfc785707d3dce"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0c00bab2dad604dde176c4190553915c"><td class="memTemplParams" colspan="2">template&lt;typename Task_err &gt; </td></tr>
<tr class="memitem:a0c00bab2dad604dde176c4190553915c"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classipc_1_1transport_1_1struc_1_1sync__io_1_1Channel.html#a0c00bab2dad604dde176c4190553915c">start_and_poll</a> (Task_err &amp;&amp;on_err_func)</td></tr>
<tr class="memdesc:a0c00bab2dad604dde176c4190553915c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Permanently memorizes the incoming-direction on-error handler, thus authorizing the emission of any in-messages (and/or an error) to handlers registered via this call, <code>expect_*()</code>, <a class="el" href="classipc_1_1transport_1_1struc_1_1sync__io_1_1Channel.html#a26dc83067e005be38567199cbedd7f19" title="See Async_io_obj counterpart; though naturally on_rsp_func() is invoked in the sync_io-pattern fashio...">async_request()</a>, <code>set_*unexpected_response_handler()</code>; and <em>synchronously</em> executes any immediately relevant such handlers due to pending in-traffic.  <a href="classipc_1_1transport_1_1struc_1_1sync__io_1_1Channel.html#a0c00bab2dad604dde176c4190553915c">More...</a><br /></td></tr>
<tr class="separator:a0c00bab2dad604dde176c4190553915c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a48a8fd167c1fe6ae95d8fc80b6a6e67f"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classipc_1_1transport_1_1struc_1_1sync__io_1_1Channel.html#a8a59bbc3c6a7191b316b23661d8ba6e3">Builder_config</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classipc_1_1transport_1_1struc_1_1sync__io_1_1Channel.html#a48a8fd167c1fe6ae95d8fc80b6a6e67f">struct_builder_config</a> () const</td></tr>
<tr class="memdesc:a48a8fd167c1fe6ae95d8fc80b6a6e67f"><td class="mdescLeft">&#160;</td><td class="mdescRight">See <a class="el" href="classipc_1_1transport_1_1struc_1_1sync__io_1_1Channel.html#a6dc83bd6057b7f00a19c5947d6baa7b7" title="Useful for generic programming, the async-I/O-pattern counterpart to *this type.">Async_io_obj</a> counterpart.  <a href="classipc_1_1transport_1_1struc_1_1sync__io_1_1Channel.html#a48a8fd167c1fe6ae95d8fc80b6a6e67f">More...</a><br /></td></tr>
<tr class="separator:a48a8fd167c1fe6ae95d8fc80b6a6e67f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a43fa0b77781376edd13b742b832572e1"><td class="memItemLeft" align="right" valign="top">const Builder_config::Builder::Session &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classipc_1_1transport_1_1struc_1_1sync__io_1_1Channel.html#a43fa0b77781376edd13b742b832572e1">struct_lender_session</a> () const</td></tr>
<tr class="memdesc:a43fa0b77781376edd13b742b832572e1"><td class="mdescLeft">&#160;</td><td class="mdescRight">See <a class="el" href="classipc_1_1transport_1_1struc_1_1sync__io_1_1Channel.html#a6dc83bd6057b7f00a19c5947d6baa7b7" title="Useful for generic programming, the async-I/O-pattern counterpart to *this type.">Async_io_obj</a> counterpart.  <a href="classipc_1_1transport_1_1struc_1_1sync__io_1_1Channel.html#a43fa0b77781376edd13b742b832572e1">More...</a><br /></td></tr>
<tr class="separator:a43fa0b77781376edd13b742b832572e1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7efbfbcce0d4d426b7df9b6d6fd1e373"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classipc_1_1transport_1_1struc_1_1sync__io_1_1Channel.html#a14a7166b2f8c117ce6ddafe943d036fa">Reader_config</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classipc_1_1transport_1_1struc_1_1sync__io_1_1Channel.html#a7efbfbcce0d4d426b7df9b6d6fd1e373">struct_reader_config</a> () const</td></tr>
<tr class="memdesc:a7efbfbcce0d4d426b7df9b6d6fd1e373"><td class="mdescLeft">&#160;</td><td class="mdescRight">See <a class="el" href="classipc_1_1transport_1_1struc_1_1sync__io_1_1Channel.html#a6dc83bd6057b7f00a19c5947d6baa7b7" title="Useful for generic programming, the async-I/O-pattern counterpart to *this type.">Async_io_obj</a> counterpart.  <a href="classipc_1_1transport_1_1struc_1_1sync__io_1_1Channel.html#a7efbfbcce0d4d426b7df9b6d6fd1e373">More...</a><br /></td></tr>
<tr class="separator:a7efbfbcce0d4d426b7df9b6d6fd1e373"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a759e1993bc61abb41380219b254ca410"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classipc_1_1transport_1_1struc_1_1sync__io_1_1Channel.html#a4abac89dbd4d26c79b7915990f751a76">Owned_channel</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classipc_1_1transport_1_1struc_1_1sync__io_1_1Channel.html#a759e1993bc61abb41380219b254ca410">owned_channel</a> () const</td></tr>
<tr class="memdesc:a759e1993bc61abb41380219b254ca410"><td class="mdescLeft">&#160;</td><td class="mdescRight">See <a class="el" href="classipc_1_1transport_1_1struc_1_1sync__io_1_1Channel.html#a6dc83bd6057b7f00a19c5947d6baa7b7" title="Useful for generic programming, the async-I/O-pattern counterpart to *this type.">Async_io_obj</a> counterpart.  <a href="classipc_1_1transport_1_1struc_1_1sync__io_1_1Channel.html#a759e1993bc61abb41380219b254ca410">More...</a><br /></td></tr>
<tr class="separator:a759e1993bc61abb41380219b254ca410"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9d97a5900bd517596b763db2d6b27b45"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classipc_1_1transport_1_1struc_1_1sync__io_1_1Channel.html#a4abac89dbd4d26c79b7915990f751a76">Owned_channel</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classipc_1_1transport_1_1struc_1_1sync__io_1_1Channel.html#a9d97a5900bd517596b763db2d6b27b45">owned_channel_mutable</a> ()</td></tr>
<tr class="memdesc:a9d97a5900bd517596b763db2d6b27b45"><td class="mdescLeft">&#160;</td><td class="mdescRight">See <a class="el" href="classipc_1_1transport_1_1struc_1_1sync__io_1_1Channel.html#a6dc83bd6057b7f00a19c5947d6baa7b7" title="Useful for generic programming, the async-I/O-pattern counterpart to *this type.">Async_io_obj</a> counterpart.  <a href="classipc_1_1transport_1_1struc_1_1sync__io_1_1Channel.html#a9d97a5900bd517596b763db2d6b27b45">More...</a><br /></td></tr>
<tr class="separator:a9d97a5900bd517596b763db2d6b27b45"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a021bb07a76c54837619c7a91dbd5de03"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="namespaceipc_1_1transport_1_1struc.html#a6751c05fb6582a34c7c47ac470c4a48b">Session_token</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classipc_1_1transport_1_1struc_1_1sync__io_1_1Channel.html#a021bb07a76c54837619c7a91dbd5de03">session_token</a> () const</td></tr>
<tr class="memdesc:a021bb07a76c54837619c7a91dbd5de03"><td class="mdescLeft">&#160;</td><td class="mdescRight">See <a class="el" href="classipc_1_1transport_1_1struc_1_1sync__io_1_1Channel.html#a6dc83bd6057b7f00a19c5947d6baa7b7" title="Useful for generic programming, the async-I/O-pattern counterpart to *this type.">Async_io_obj</a> counterpart.  <a href="classipc_1_1transport_1_1struc_1_1sync__io_1_1Channel.html#a021bb07a76c54837619c7a91dbd5de03">More...</a><br /></td></tr>
<tr class="separator:a021bb07a76c54837619c7a91dbd5de03"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a426ecae27b4ea5cf7e666e56bad6afe5"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classipc_1_1transport_1_1struc_1_1sync__io_1_1Channel.html#a83fb4462a8d4045bdb56b694bf80393c">Msg_out</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classipc_1_1transport_1_1struc_1_1sync__io_1_1Channel.html#a426ecae27b4ea5cf7e666e56bad6afe5">create_msg</a> (<a class="el" href="namespaceipc_1_1transport.html#a7ee4551983d9df16ec16a3139bac50e8">Native_handle</a> &amp;&amp;hndl_or_null=<a class="el" href="namespaceipc_1_1transport.html#a7ee4551983d9df16ec16a3139bac50e8">Native_handle</a>()) const</td></tr>
<tr class="memdesc:a426ecae27b4ea5cf7e666e56bad6afe5"><td class="mdescLeft">&#160;</td><td class="mdescRight">See <a class="el" href="classipc_1_1transport_1_1struc_1_1sync__io_1_1Channel.html#a6dc83bd6057b7f00a19c5947d6baa7b7" title="Useful for generic programming, the async-I/O-pattern counterpart to *this type.">Async_io_obj</a> counterpart.  <a href="classipc_1_1transport_1_1struc_1_1sync__io_1_1Channel.html#a426ecae27b4ea5cf7e666e56bad6afe5">More...</a><br /></td></tr>
<tr class="separator:a426ecae27b4ea5cf7e666e56bad6afe5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5fc489b9abefe5ab676f6991d6d03f0d"><td class="memTemplParams" colspan="2">template&lt;typename On_msg_handler &gt; </td></tr>
<tr class="memitem:a5fc489b9abefe5ab676f6991d6d03f0d"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classipc_1_1transport_1_1struc_1_1sync__io_1_1Channel.html#a5fc489b9abefe5ab676f6991d6d03f0d">expect_msg</a> (<a class="el" href="classipc_1_1transport_1_1struc_1_1sync__io_1_1Channel.html#aa40c3ec3f45cdfea9360f7f35b9ade3c">Msg_which_in</a> which, <a class="el" href="classipc_1_1transport_1_1struc_1_1sync__io_1_1Channel.html#acde2b3866547a30958035203d9d89928">Msg_in_ptr</a> *qd_msg, On_msg_handler &amp;&amp;on_msg_func)</td></tr>
<tr class="memdesc:a5fc489b9abefe5ab676f6991d6d03f0d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Registers the expectation (which may be immediately met) of up to 1 <em>notification</em> in-message whose <a class="el" href="classipc_1_1transport_1_1struc_1_1sync__io_1_1Channel.html#a1572a1b1cb4a72ea57f7841a5e78759b" title="See Async_io_obj counterpart.">Msg_which</a> equals <code>which</code>.  <a href="classipc_1_1transport_1_1struc_1_1sync__io_1_1Channel.html#a5fc489b9abefe5ab676f6991d6d03f0d">More...</a><br /></td></tr>
<tr class="separator:a5fc489b9abefe5ab676f6991d6d03f0d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a996e06f75024e10987eb9cf62e096eec"><td class="memTemplParams" colspan="2">template&lt;typename On_msg_handler &gt; </td></tr>
<tr class="memitem:a996e06f75024e10987eb9cf62e096eec"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classipc_1_1transport_1_1struc_1_1sync__io_1_1Channel.html#a996e06f75024e10987eb9cf62e096eec">expect_log_in_request</a> (<a class="el" href="classipc_1_1transport_1_1struc_1_1sync__io_1_1Channel.html#aa40c3ec3f45cdfea9360f7f35b9ade3c">Msg_which_in</a> which, <a class="el" href="classipc_1_1transport_1_1struc_1_1sync__io_1_1Channel.html#acde2b3866547a30958035203d9d89928">Msg_in_ptr</a> *qd_msg, On_msg_handler &amp;&amp;on_log_in_req_func)</td></tr>
<tr class="memdesc:a996e06f75024e10987eb9cf62e096eec"><td class="mdescLeft">&#160;</td><td class="mdescRight">In log-in phase as server only: Registers the expectation (which may be immediately met) of up to 1 <em>log-in request</em> in-message whose <a class="el" href="classipc_1_1transport_1_1struc_1_1sync__io_1_1Channel.html#a1572a1b1cb4a72ea57f7841a5e78759b" title="See Async_io_obj counterpart.">Msg_which</a> equals <code>which</code>.  <a href="classipc_1_1transport_1_1struc_1_1sync__io_1_1Channel.html#a996e06f75024e10987eb9cf62e096eec">More...</a><br /></td></tr>
<tr class="separator:a996e06f75024e10987eb9cf62e096eec"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a62f52488ba20dd6c69dfc1abadb2d69f"><td class="memTemplParams" colspan="2">template&lt;typename On_msg_handler &gt; </td></tr>
<tr class="memitem:a62f52488ba20dd6c69dfc1abadb2d69f"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classipc_1_1transport_1_1struc_1_1sync__io_1_1Channel.html#a62f52488ba20dd6c69dfc1abadb2d69f">expect_msgs</a> (<a class="el" href="classipc_1_1transport_1_1struc_1_1sync__io_1_1Channel.html#aa40c3ec3f45cdfea9360f7f35b9ade3c">Msg_which_in</a> which, <a class="el" href="classipc_1_1transport_1_1struc_1_1sync__io_1_1Channel.html#a4ab778bce8d7e6e84788879fedc62745">Msgs_in</a> *qd_msgs, On_msg_handler &amp;&amp;on_msg_func)</td></tr>
<tr class="memdesc:a62f52488ba20dd6c69dfc1abadb2d69f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Registers the expectation (some of which may be immediately met) of 0+ <em>notification</em> in-messages whose <a class="el" href="classipc_1_1transport_1_1struc_1_1sync__io_1_1Channel.html#a1572a1b1cb4a72ea57f7841a5e78759b" title="See Async_io_obj counterpart.">Msg_which</a> equals <code>which</code>.  <a href="classipc_1_1transport_1_1struc_1_1sync__io_1_1Channel.html#a62f52488ba20dd6c69dfc1abadb2d69f">More...</a><br /></td></tr>
<tr class="separator:a62f52488ba20dd6c69dfc1abadb2d69f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac8ba5f1a26a9f3e881b4871b0f6aa990"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classipc_1_1transport_1_1struc_1_1sync__io_1_1Channel.html#ac8ba5f1a26a9f3e881b4871b0f6aa990">undo_expect_msgs</a> (<a class="el" href="classipc_1_1transport_1_1struc_1_1sync__io_1_1Channel.html#aa40c3ec3f45cdfea9360f7f35b9ade3c">Msg_which_in</a> which)</td></tr>
<tr class="memdesc:ac8ba5f1a26a9f3e881b4871b0f6aa990"><td class="mdescLeft">&#160;</td><td class="mdescRight">See <a class="el" href="classipc_1_1transport_1_1struc_1_1sync__io_1_1Channel.html#a6dc83bd6057b7f00a19c5947d6baa7b7" title="Useful for generic programming, the async-I/O-pattern counterpart to *this type.">Async_io_obj</a> counterpart.  <a href="classipc_1_1transport_1_1struc_1_1sync__io_1_1Channel.html#ac8ba5f1a26a9f3e881b4871b0f6aa990">More...</a><br /></td></tr>
<tr class="separator:ac8ba5f1a26a9f3e881b4871b0f6aa990"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0dc388e18b0fc0fa2d8ad0a6953fb039"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classipc_1_1transport_1_1struc_1_1sync__io_1_1Channel.html#a0dc388e18b0fc0fa2d8ad0a6953fb039">send</a> (const <a class="el" href="classipc_1_1transport_1_1struc_1_1sync__io_1_1Channel.html#a83fb4462a8d4045bdb56b694bf80393c">Msg_out</a> &amp;msg, const <a class="el" href="classipc_1_1transport_1_1struc_1_1sync__io_1_1Channel.html#ac3da0ac1306b63c9e38c47b8c31e3cd2">Msg_in</a> *originating_msg_or_null=0, <a class="el" href="namespaceipc.html#aa3192e586cc45d3e7c22463bf2760f89">Error_code</a> *err_code=0)</td></tr>
<tr class="memdesc:a0dc388e18b0fc0fa2d8ad0a6953fb039"><td class="mdescLeft">&#160;</td><td class="mdescRight">See <a class="el" href="classipc_1_1transport_1_1struc_1_1sync__io_1_1Channel.html#a6dc83bd6057b7f00a19c5947d6baa7b7" title="Useful for generic programming, the async-I/O-pattern counterpart to *this type.">Async_io_obj</a> counterpart.  <a href="classipc_1_1transport_1_1struc_1_1sync__io_1_1Channel.html#a0dc388e18b0fc0fa2d8ad0a6953fb039">More...</a><br /></td></tr>
<tr class="separator:a0dc388e18b0fc0fa2d8ad0a6953fb039"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a26dc83067e005be38567199cbedd7f19"><td class="memTemplParams" colspan="2">template&lt;typename On_msg_handler &gt; </td></tr>
<tr class="memitem:a26dc83067e005be38567199cbedd7f19"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classipc_1_1transport_1_1struc_1_1sync__io_1_1Channel.html#a26dc83067e005be38567199cbedd7f19">async_request</a> (const <a class="el" href="classipc_1_1transport_1_1struc_1_1sync__io_1_1Channel.html#a83fb4462a8d4045bdb56b694bf80393c">Msg_out</a> &amp;msg, const <a class="el" href="classipc_1_1transport_1_1struc_1_1sync__io_1_1Channel.html#ac3da0ac1306b63c9e38c47b8c31e3cd2">Msg_in</a> *originating_msg_or_null, <a class="el" href="classipc_1_1transport_1_1struc_1_1Channel__base.html#adcf24fa51747ed83c4b6427fbf44fecf">msg_id_out_t</a> *id_unless_one_off, On_msg_handler &amp;&amp;on_rsp_func, <a class="el" href="namespaceipc.html#aa3192e586cc45d3e7c22463bf2760f89">Error_code</a> *err_code=0)</td></tr>
<tr class="memdesc:a26dc83067e005be38567199cbedd7f19"><td class="mdescLeft">&#160;</td><td class="mdescRight">See <a class="el" href="classipc_1_1transport_1_1struc_1_1sync__io_1_1Channel.html#a6dc83bd6057b7f00a19c5947d6baa7b7" title="Useful for generic programming, the async-I/O-pattern counterpart to *this type.">Async_io_obj</a> counterpart; though naturally <code>on_rsp_func()</code> is invoked in the <code><a class="el" href="namespaceipc_1_1transport_1_1struc_1_1sync__io.html" title="sync_io-pattern counterparts to async-I/O-pattern object types in parent namespace ipc::transport::st...">sync_io</a></code>-pattern fashion.  <a href="classipc_1_1transport_1_1struc_1_1sync__io_1_1Channel.html#a26dc83067e005be38567199cbedd7f19">More...</a><br /></td></tr>
<tr class="separator:a26dc83067e005be38567199cbedd7f19"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5aae7a7f907f56fa07a230eadec2fedf"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classipc_1_1transport_1_1struc_1_1sync__io_1_1Channel.html#a5aae7a7f907f56fa07a230eadec2fedf">undo_expect_responses</a> (<a class="el" href="classipc_1_1transport_1_1struc_1_1Channel__base.html#adcf24fa51747ed83c4b6427fbf44fecf">msg_id_out_t</a> originating_msg_id)</td></tr>
<tr class="memdesc:a5aae7a7f907f56fa07a230eadec2fedf"><td class="mdescLeft">&#160;</td><td class="mdescRight">See <a class="el" href="classipc_1_1transport_1_1struc_1_1sync__io_1_1Channel.html#a6dc83bd6057b7f00a19c5947d6baa7b7" title="Useful for generic programming, the async-I/O-pattern counterpart to *this type.">Async_io_obj</a> counterpart.  <a href="classipc_1_1transport_1_1struc_1_1sync__io_1_1Channel.html#a5aae7a7f907f56fa07a230eadec2fedf">More...</a><br /></td></tr>
<tr class="separator:a5aae7a7f907f56fa07a230eadec2fedf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5c62d2a374a3a98e7fa0aef01bf8a774"><td class="memTemplParams" colspan="2">template&lt;typename On_unexpected_response_handler &gt; </td></tr>
<tr class="memitem:a5c62d2a374a3a98e7fa0aef01bf8a774"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classipc_1_1transport_1_1struc_1_1sync__io_1_1Channel.html#a5c62d2a374a3a98e7fa0aef01bf8a774">set_unexpected_response_handler</a> (On_unexpected_response_handler &amp;&amp;on_func)</td></tr>
<tr class="memdesc:a5c62d2a374a3a98e7fa0aef01bf8a774"><td class="mdescLeft">&#160;</td><td class="mdescRight">See <a class="el" href="classipc_1_1transport_1_1struc_1_1sync__io_1_1Channel.html#a6dc83bd6057b7f00a19c5947d6baa7b7" title="Useful for generic programming, the async-I/O-pattern counterpart to *this type.">Async_io_obj</a> counterpart; though naturally <code>on_func()</code> is invoked in the <code><a class="el" href="namespaceipc_1_1transport_1_1struc_1_1sync__io.html" title="sync_io-pattern counterparts to async-I/O-pattern object types in parent namespace ipc::transport::st...">sync_io</a></code>-pattern fashion.  <a href="classipc_1_1transport_1_1struc_1_1sync__io_1_1Channel.html#a5c62d2a374a3a98e7fa0aef01bf8a774">More...</a><br /></td></tr>
<tr class="separator:a5c62d2a374a3a98e7fa0aef01bf8a774"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1f226e506cc5c04584e11480426b19da"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classipc_1_1transport_1_1struc_1_1sync__io_1_1Channel.html#a1f226e506cc5c04584e11480426b19da">unset_unexpected_response_handler</a> ()</td></tr>
<tr class="memdesc:a1f226e506cc5c04584e11480426b19da"><td class="mdescLeft">&#160;</td><td class="mdescRight">See <a class="el" href="classipc_1_1transport_1_1struc_1_1sync__io_1_1Channel.html#a6dc83bd6057b7f00a19c5947d6baa7b7" title="Useful for generic programming, the async-I/O-pattern counterpart to *this type.">Async_io_obj</a> counterpart.  <a href="classipc_1_1transport_1_1struc_1_1sync__io_1_1Channel.html#a1f226e506cc5c04584e11480426b19da">More...</a><br /></td></tr>
<tr class="separator:a1f226e506cc5c04584e11480426b19da"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3fda370cc97c89a62f77a6fcf639cfd7"><td class="memTemplParams" colspan="2">template&lt;typename On_remote_unexpected_response_handler &gt; </td></tr>
<tr class="memitem:a3fda370cc97c89a62f77a6fcf639cfd7"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classipc_1_1transport_1_1struc_1_1sync__io_1_1Channel.html#a3fda370cc97c89a62f77a6fcf639cfd7">set_remote_unexpected_response_handler</a> (On_remote_unexpected_response_handler &amp;&amp;on_func)</td></tr>
<tr class="memdesc:a3fda370cc97c89a62f77a6fcf639cfd7"><td class="mdescLeft">&#160;</td><td class="mdescRight">See <a class="el" href="classipc_1_1transport_1_1struc_1_1sync__io_1_1Channel.html#a6dc83bd6057b7f00a19c5947d6baa7b7" title="Useful for generic programming, the async-I/O-pattern counterpart to *this type.">Async_io_obj</a> counterpart; though naturally <code>on_func()</code> is invoked in the <code><a class="el" href="namespaceipc_1_1transport_1_1struc_1_1sync__io.html" title="sync_io-pattern counterparts to async-I/O-pattern object types in parent namespace ipc::transport::st...">sync_io</a></code>-pattern fashion.  <a href="classipc_1_1transport_1_1struc_1_1sync__io_1_1Channel.html#a3fda370cc97c89a62f77a6fcf639cfd7">More...</a><br /></td></tr>
<tr class="separator:a3fda370cc97c89a62f77a6fcf639cfd7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a24382a751a2c03e00c5140c89aba2c62"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classipc_1_1transport_1_1struc_1_1sync__io_1_1Channel.html#a24382a751a2c03e00c5140c89aba2c62">unset_remote_unexpected_response_handler</a> ()</td></tr>
<tr class="memdesc:a24382a751a2c03e00c5140c89aba2c62"><td class="mdescLeft">&#160;</td><td class="mdescRight">See <a class="el" href="classipc_1_1transport_1_1struc_1_1sync__io_1_1Channel.html#a6dc83bd6057b7f00a19c5947d6baa7b7" title="Useful for generic programming, the async-I/O-pattern counterpart to *this type.">Async_io_obj</a> counterpart.  <a href="classipc_1_1transport_1_1struc_1_1sync__io_1_1Channel.html#a24382a751a2c03e00c5140c89aba2c62">More...</a><br /></td></tr>
<tr class="separator:a24382a751a2c03e00c5140c89aba2c62"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae4a2a63dc88722d96ee9f3ed68cf7b86"><td class="memTemplParams" colspan="2">template&lt;typename Task_err &gt; </td></tr>
<tr class="memitem:ae4a2a63dc88722d96ee9f3ed68cf7b86"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classipc_1_1transport_1_1struc_1_1sync__io_1_1Channel.html#ae4a2a63dc88722d96ee9f3ed68cf7b86">async_end_sending</a> (<a class="el" href="namespaceipc.html#aa3192e586cc45d3e7c22463bf2760f89">Error_code</a> *sync_err_code, Task_err &amp;&amp;on_done_func)</td></tr>
<tr class="memdesc:ae4a2a63dc88722d96ee9f3ed68cf7b86"><td class="mdescLeft">&#160;</td><td class="mdescRight">See <a class="el" href="classipc_1_1transport_1_1struc_1_1sync__io_1_1Channel.html#a6dc83bd6057b7f00a19c5947d6baa7b7" title="Useful for generic programming, the async-I/O-pattern counterpart to *this type.">Async_io_obj</a> counterpart; except (1) naturally <code>on_done_func()</code> is invoked in the <code><a class="el" href="namespaceipc_1_1transport_1_1struc_1_1sync__io.html" title="sync_io-pattern counterparts to async-I/O-pattern object types in parent namespace ipc::transport::st...">sync_io</a></code>-pattern fashion, and (2) the operation may (and is very likely to) complete synchronously and thus ignore <code>on_done_func</code>.  <a href="classipc_1_1transport_1_1struc_1_1sync__io_1_1Channel.html#ae4a2a63dc88722d96ee9f3ed68cf7b86">More...</a><br /></td></tr>
<tr class="separator:ae4a2a63dc88722d96ee9f3ed68cf7b86"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="related" name="related"></a>
Related Functions</h2></td></tr>
<tr><td class="ititle" colspan="2"><p >(Note that these are not member functions.) </p>
</td></tr>
<tr class="memitem:a0351bb14f40312b30e6cae4927f3373b"><td class="memTemplParams" colspan="2">template&lt;typename Channel_obj , typename Message_body , typename Struct_builder_config , typename Struct_reader_config &gt; </td></tr>
<tr class="memitem:a0351bb14f40312b30e6cae4927f3373b"><td class="memTemplItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classipc_1_1transport_1_1struc_1_1sync__io_1_1Channel.html#a0351bb14f40312b30e6cae4927f3373b">operator&lt;&lt;</a> (std::ostream &amp;os, const <a class="el" href="classipc_1_1transport_1_1struc_1_1sync__io_1_1Channel.html">Channel</a>&lt; Channel_obj, Message_body, Struct_builder_config, Struct_reader_config &gt; &amp;val)</td></tr>
<tr class="memdesc:a0351bb14f40312b30e6cae4927f3373b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Prints string representation of the given <a class="el" href="classipc_1_1transport_1_1struc_1_1sync__io_1_1Channel.html" title="sync_io-pattern counterpart to async-I/O-pattern transport::struc::Channel.">struc::sync_io::Channel</a> to the given <code>ostream</code>.  <a href="classipc_1_1transport_1_1struc_1_1sync__io_1_1Channel.html#a0351bb14f40312b30e6cae4927f3373b">More...</a><br /></td></tr>
<tr class="separator:a0351bb14f40312b30e6cae4927f3373b"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="inherited" name="inherited"></a>
Additional Inherited Members</h2></td></tr>
<tr class="inherit_header pub_static_attribs_classipc_1_1transport_1_1struc_1_1Channel__base"><td colspan="2" onclick="javascript:toggleInherit('pub_static_attribs_classipc_1_1transport_1_1struc_1_1Channel__base')"><img src="closed.png" alt="-"/>&#160;Static Public Attributes inherited from <a class="el" href="classipc_1_1transport_1_1struc_1_1Channel__base.html">ipc::transport::struc::Channel_base</a></td></tr>
<tr class="memitem:ab0eb05b5fb52364c99868a8535aaf26e inherit pub_static_attribs_classipc_1_1transport_1_1struc_1_1Channel__base"><td class="memItemLeft" align="right" valign="top"><a id="ab0eb05b5fb52364c99868a8535aaf26e" name="ab0eb05b5fb52364c99868a8535aaf26e"></a>
static constexpr <a class="el" href="structipc_1_1transport_1_1struc_1_1Channel__base_1_1Serialize__via__heap.html">Serialize_via_heap</a>&#160;</td><td class="memItemRight" valign="bottom"><b>S_SERIALIZE_VIA_HEAP</b> = {}</td></tr>
<tr class="memdesc:ab0eb05b5fb52364c99868a8535aaf26e inherit pub_static_attribs_classipc_1_1transport_1_1struc_1_1Channel__base"><td class="mdescLeft">&#160;</td><td class="mdescRight">The sole value of the tag type <a class="el" href="structipc_1_1transport_1_1struc_1_1Channel__base_1_1Serialize__via__heap.html" title="Tag type for ctor selection: Backing memory for serialization comes from fixed-size segment allocatio...">Serialize_via_heap</a>. <br /></td></tr>
<tr class="separator:ab0eb05b5fb52364c99868a8535aaf26e inherit pub_static_attribs_classipc_1_1transport_1_1struc_1_1Channel__base"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9bdb94c1ba4fac92fbbd0f843e8525ba inherit pub_static_attribs_classipc_1_1transport_1_1struc_1_1Channel__base"><td class="memItemLeft" align="right" valign="top"><a id="a9bdb94c1ba4fac92fbbd0f843e8525ba" name="a9bdb94c1ba4fac92fbbd0f843e8525ba"></a>
static constexpr <a class="el" href="structipc_1_1transport_1_1struc_1_1Channel__base_1_1Serialize__via__session__shm.html">Serialize_via_session_shm</a>&#160;</td><td class="memItemRight" valign="bottom"><b>S_SERIALIZE_VIA_SESSION_SHM</b> = {}</td></tr>
<tr class="memdesc:a9bdb94c1ba4fac92fbbd0f843e8525ba inherit pub_static_attribs_classipc_1_1transport_1_1struc_1_1Channel__base"><td class="mdescLeft">&#160;</td><td class="mdescRight">The sole value of the tag type <a class="el" href="structipc_1_1transport_1_1struc_1_1Channel__base_1_1Serialize__via__session__shm.html" title="Tag type for ctor selection: Backing RAM for serialization comes from a given session::Session&#39;s SHM ...">Serialize_via_session_shm</a>. <br /></td></tr>
<tr class="separator:a9bdb94c1ba4fac92fbbd0f843e8525ba inherit pub_static_attribs_classipc_1_1transport_1_1struc_1_1Channel__base"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af732121649271d1368a2fb637917ce7b inherit pub_static_attribs_classipc_1_1transport_1_1struc_1_1Channel__base"><td class="memItemLeft" align="right" valign="top"><a id="af732121649271d1368a2fb637917ce7b" name="af732121649271d1368a2fb637917ce7b"></a>
static constexpr <a class="el" href="structipc_1_1transport_1_1struc_1_1Channel__base_1_1Serialize__via__app__shm.html">Serialize_via_app_shm</a>&#160;</td><td class="memItemRight" valign="bottom"><b>S_SERIALIZE_VIA_APP_SHM</b> = {}</td></tr>
<tr class="memdesc:af732121649271d1368a2fb637917ce7b inherit pub_static_attribs_classipc_1_1transport_1_1struc_1_1Channel__base"><td class="mdescLeft">&#160;</td><td class="mdescRight">The sole value of the tag type <a class="el" href="structipc_1_1transport_1_1struc_1_1Channel__base_1_1Serialize__via__app__shm.html" title="Similar to Serialize_via_session_shm but assumes per-app-scope SHM-arena (as opposed to per-session-s...">Serialize_via_app_shm</a>. <br /></td></tr>
<tr class="separator:af732121649271d1368a2fb637917ce7b inherit pub_static_attribs_classipc_1_1transport_1_1struc_1_1Channel__base"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><div class="compoundTemplParams">template&lt;typename Channel_obj, typename Message_body, typename Struct_builder_config, typename Struct_reader_config&gt;<br />
class ipc::transport::struc::sync_io::Channel&lt; Channel_obj, Message_body, Struct_builder_config, Struct_reader_config &gt;</div><p ><code><a class="el" href="namespaceipc_1_1transport_1_1struc_1_1sync__io.html" title="sync_io-pattern counterparts to async-I/O-pattern object types in parent namespace ipc::transport::st...">sync_io</a></code>-pattern counterpart to async-I/O-pattern <a class="el" href="classipc_1_1transport_1_1struc_1_1Channel.html" title="Owning and wrapping a pre-connected transport::Channel peer (an endpoint of an established channel ov...">transport::struc::Channel</a>. </p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classipc_1_1transport_1_1struc_1_1Channel.html" title="Owning and wrapping a pre-connected transport::Channel peer (an endpoint of an established channel ov...">transport::struc::Channel</a> and <a class="el" href="namespaceipc_1_1util_1_1sync__io.html" title="Contains common code, as well as important explanatory documentation in the following text,...">util::sync_io</a> doc headers. The latter describes the general pattern which we implement here; it also contrasts it with the async-I/O pattern, which the former implements. In general we recommend you use a <a class="el" href="classipc_1_1transport_1_1struc_1_1Channel.html" title="Owning and wrapping a pre-connected transport::Channel peer (an endpoint of an established channel ov...">transport::struc::Channel</a> rather than a <code>*this</code> &ndash; but you may have particular needs (summarized in <a class="el" href="namespaceipc_1_1util_1_1sync__io.html" title="Contains common code, as well as important explanatory documentation in the following text,...">util::sync_io</a> doc header) that would make you decide otherwise.</dd></dl>
<p>All notes on functionality in <a class="el" href="classipc_1_1transport_1_1struc_1_1Channel.html" title="Owning and wrapping a pre-connected transport::Channel peer (an endpoint of an established channel ov...">transport::struc::Channel</a> (a/k/a alias <a class="el" href="classipc_1_1transport_1_1struc_1_1sync__io_1_1Channel.html#a6dc83bd6057b7f00a19c5947d6baa7b7" title="Useful for generic programming, the async-I/O-pattern counterpart to *this type.">Channel::Async_io_obj</a>) doc header apply to us. The difference, as usual given <code><a class="el" href="namespaceipc_1_1transport_1_1struc_1_1sync__io.html" title="sync_io-pattern counterparts to async-I/O-pattern object types in parent namespace ipc::transport::st...">sync_io</a></code> and async-I/O mutual counterparts, is in how results are reported. Because <a class="el" href="classipc_1_1transport_1_1struc_1_1Channel.html" title="Owning and wrapping a pre-connected transport::Channel peer (an endpoint of an established channel ov...">struc::Channel</a> in general stands apart from the many concept impls of <code><a class="el" href="classipc_1_1transport_1_1Blob__sender.html" title="A documentation-only concept defining the behavior of an object capable of reliably/in-order sending ...">Blob_sender</a></code>, <code><a class="el" href="classipc_1_1transport_1_1Blob__receiver.html" title="A documentation-only concept defining the behavior of an object capable of reliably/in-order receivin...">Blob_receiver</a></code>, etc. &ndash; e.g., <a class="el" href="classipc_1_1transport_1_1Native__socket__stream.html" title="Implements both Native_handle_sender and Native_handle_receiver concepts by using a stream-oriented U...">Native_socket_stream</a> &ndash; it may be helpful to summarize how this <code><a class="el" href="namespaceipc_1_1transport_1_1struc_1_1sync__io.html" title="sync_io-pattern counterparts to async-I/O-pattern object types in parent namespace ipc::transport::st...">sync_io</a></code>-pattern type reports results. The APIs look somewhat different from those core-layer guys owing to the more complex mission statement here versus there.</p>
<ul>
<li><code>expect_*(..., F)</code>: This says you want messages of a certain type, and when one arrives to invoke <code>F(I)</code>, <code>I</code> being the in-message. However, depending on the API 1+ message(s) may already have been cached and are immediately available. These are synchronously emitted via an out-arg; for example <a class="el" href="classipc_1_1transport_1_1struc_1_1sync__io_1_1Channel.html#a62f52488ba20dd6c69dfc1abadb2d69f" title="Registers the expectation (some of which may be immediately met) of 0+ notification in-messages whose...">expect_msgs()</a> takes a list-of-in-messages out-arg. Depending on the API future messages may be relevant and will be emitted via <code>F()</code>.</li>
<li><code>async_request(M, ..., F)</code>: This says you want <code>M</code> sent and expect 1 or 0+ (depending on args) response(s), and when one arrives to invoke <code>F(I)</code>, <code>I</code> being a response. Since it is not possible to have received a response to a not-yet-sent out-message, that is just how it works. There are no synchronous out-args.</li>
<li><code>set_*unexpected_response_handler()</code>: If it's set, and an unexpected-response event occurs, this fires. If not, it doesn't. There are no synchronous out-args.</li>
<li><code>start_and_poll(F)</code>: This begins incoming-direction operation. <code>F()</code> is the on-error handler. It fires up to once per <code>*this</code> to indicate underlying <code>Owned_channel</code> or other channel-hosing error (including receiving graceful-close). An error may synchronously occur right then, plus any <code>expect_*()</code>- and <code><a class="el" href="classipc_1_1transport_1_1struc_1_1sync__io_1_1Channel.html#a26dc83067e005be38567199cbedd7f19" title="See Async_io_obj counterpart; though naturally on_rsp_func() is invoked in the sync_io-pattern fashio...">async_request()</a></code>-triggered in-messages may be synchronously detected. Therefore &ndash; and this is quite rare (singular as of this writing in Flow-IPC):<ul>
<li><code>start_and_poll(F)</code> may <em>synchronously</em> (!) call a number of queued-up (in a sense) handlers including:<ul>
<li><code>expect_*()</code> handlers;</li>
<li><code><a class="el" href="classipc_1_1transport_1_1struc_1_1sync__io_1_1Channel.html#a26dc83067e005be38567199cbedd7f19" title="See Async_io_obj counterpart; though naturally on_rsp_func() is invoked in the sync_io-pattern fashio...">async_request()</a></code> handlers;</li>
<li><code>set_*unexpected_response_handler()</code> handlers;</li>
<li>on-error handler <code>F()</code> itself.</li>
</ul>
</li>
</ul>
</li>
</ul>
<p >Tip: If you'd rather not worry about <code><a class="el" href="classipc_1_1transport_1_1struc_1_1sync__io_1_1Channel.html#a0c00bab2dad604dde176c4190553915c" title="Permanently memorizes the incoming-direction on-error handler, thus authorizing the emission of any i...">start_and_poll()</a></code>-executed handlers &ndash; except on-error handler which might occur regardless &ndash; then avoid calling <code>expect_*()</code>, <a class="el" href="classipc_1_1transport_1_1struc_1_1sync__io_1_1Channel.html#a26dc83067e005be38567199cbedd7f19" title="See Async_io_obj counterpart; though naturally on_rsp_func() is invoked in the sync_io-pattern fashio...">async_request()</a>, <code>set_*()</code> before <a class="el" href="classipc_1_1transport_1_1struc_1_1sync__io_1_1Channel.html#a0c00bab2dad604dde176c4190553915c" title="Permanently memorizes the incoming-direction on-error handler, thus authorizing the emission of any i...">start_and_poll()</a>. (No in-messages are ever dropped, so you won't "miss" something by registering an expectation too late.) That said there's nothing wrong per se with setting those things up before <a class="el" href="classipc_1_1transport_1_1struc_1_1sync__io_1_1Channel.html#a0c00bab2dad604dde176c4190553915c" title="Permanently memorizes the incoming-direction on-error handler, thus authorizing the emission of any i...">start_and_poll()</a> either. Just be ready for the <code>_and_poll</code> part.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Channel_obj</td><td>See <a class="el" href="classipc_1_1transport_1_1struc_1_1sync__io_1_1Channel.html#a6dc83bd6057b7f00a19c5947d6baa7b7" title="Useful for generic programming, the async-I/O-pattern counterpart to *this type.">Async_io_obj</a> doc header. </td></tr>
    <tr><td class="paramname">Message_body</td><td>See <a class="el" href="classipc_1_1transport_1_1struc_1_1sync__io_1_1Channel.html#a6dc83bd6057b7f00a19c5947d6baa7b7" title="Useful for generic programming, the async-I/O-pattern counterpart to *this type.">Async_io_obj</a> doc header. </td></tr>
    <tr><td class="paramname">Struct_builder_config</td><td>See <a class="el" href="classipc_1_1transport_1_1struc_1_1sync__io_1_1Channel.html#a6dc83bd6057b7f00a19c5947d6baa7b7" title="Useful for generic programming, the async-I/O-pattern counterpart to *this type.">Async_io_obj</a> doc header. </td></tr>
    <tr><td class="paramname">Struct_reader_config</td><td>See <a class="el" href="classipc_1_1transport_1_1struc_1_1sync__io_1_1Channel.html#a6dc83bd6057b7f00a19c5947d6baa7b7" title="Useful for generic programming, the async-I/O-pattern counterpart to *this type.">Async_io_obj</a> doc header. </td></tr>
  </table>
  </dd>
</dl>
</div><h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="a9385752ed00263dec5c5080b67ce0960" name="a9385752ed00263dec5c5080b67ce0960"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9385752ed00263dec5c5080b67ce0960">&#9670;&nbsp;</a></span>Channel() <span class="overload">[1/8]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Channel_obj , typename Message_body , typename Struct_builder_config , typename Struct_reader_config &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classipc_1_1transport_1_1struc_1_1sync__io_1_1Channel.html">ipc::transport::struc::sync_io::Channel</a>&lt; Channel_obj, Message_body, Struct_builder_config, Struct_reader_config &gt;::Channel </td>
          <td>(</td>
          <td class="paramtype">flow::log::Logger *&#160;</td>
          <td class="paramname"><em>logger_ptr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classipc_1_1transport_1_1struc_1_1sync__io_1_1Channel.html#a4abac89dbd4d26c79b7915990f751a76">Owned_channel</a> &amp;&amp;&#160;</td>
          <td class="paramname"><em>channel</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classipc_1_1transport_1_1struc_1_1sync__io_1_1Channel.html#a8a59bbc3c6a7191b316b23661d8ba6e3">Builder_config</a> &amp;&#160;</td>
          <td class="paramname"><em>struct_builder_config</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const typename Builder_config::Builder::Session &amp;&#160;</td>
          <td class="paramname"><em>struct_lender_session</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classipc_1_1transport_1_1struc_1_1sync__io_1_1Channel.html#a14a7166b2f8c117ce6ddafe943d036fa">Reader_config</a> &amp;&#160;</td>
          <td class="paramname"><em>struct_reader_config</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespaceipc_1_1transport_1_1struc.html#a6751c05fb6582a34c7c47ac470c4a48b">Session_token</a> &amp;&#160;</td>
          <td class="paramname"><em>session_token_non_nil</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">explicit</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Non-tag, no-log-in ctor form: Creates structured channel peer with no log-in phase (log-in phase must have occurred in a preceding <a class="el" href="classipc_1_1transport_1_1struc_1_1Channel.html" title="Owning and wrapping a pre-connected transport::Channel peer (an endpoint of an established channel ov...">struc::Channel</a> called <em>session master channel</em>), the session token already known and passed-in to this ctor. </p>
<p >Consider also:</p><ul>
<li>A tag-form ctor (usually simpler than manually cting <code>struct_builder_config</code> and <code>struct_reader_config</code>).</li>
<li>With-log-in ctor (usually needed for session master channel only).</li>
</ul>
<dl class="section note"><dt>Note</dt><dd>This ctor form is forwarded-to from <a class="el" href="classipc_1_1transport_1_1struc_1_1sync__io_1_1Channel.html#a6dc83bd6057b7f00a19c5947d6baa7b7" title="Useful for generic programming, the async-I/O-pattern counterpart to *this type.">Async_io_obj</a> ctor. Documentation below applies to both ctors except where noted.</dd></dl>
<p>If <code>*this</code> ctor is for <a class="el" href="classipc_1_1transport_1_1struc_1_1sync__io_1_1Channel.html" title="sync_io-pattern counterpart to async-I/O-pattern transport::struc::Channel.">sync_io::Channel</a>: You'll need to <a class="el" href="classipc_1_1transport_1_1struc_1_1sync__io_1_1Channel.html#a6e4f8c4207fcf678b4cfc785707d3dce" title="Sets up the sync_io-pattern interaction between *this and the user&#39;s event loop; required before asyn...">start_ops()</a> (possibly preceded by <a class="el" href="classipc_1_1transport_1_1struc_1_1sync__io_1_1Channel.html#a543aa806ec21b8550f9f440e59767d52" title="Analogous to transport::sync_io::Native_handle_sender::replace_event_wait_handles().">replace_event_wait_handles()</a>) per <code><a class="el" href="namespaceipc_1_1transport_1_1struc_1_1sync__io.html" title="sync_io-pattern counterparts to async-I/O-pattern object types in parent namespace ipc::transport::st...">sync_io</a></code> pattern. (If <code>*this</code> ctor is for <a class="el" href="classipc_1_1transport_1_1struc_1_1sync__io_1_1Channel.html#a6dc83bd6057b7f00a19c5947d6baa7b7" title="Useful for generic programming, the async-I/O-pattern counterpart to *this type.">Async_io_obj</a>: not applicable.) Then:</p>
<p >You may <a class="el" href="classipc_1_1transport_1_1struc_1_1sync__io_1_1Channel.html#a0dc388e18b0fc0fa2d8ad0a6953fb039" title="See Async_io_obj counterpart.">send()</a> (et al) immediately after this. However no in-messages shall be emitted, regardless of registered expectations such as via <a class="el" href="classipc_1_1transport_1_1struc_1_1sync__io_1_1Channel.html#a5fc489b9abefe5ab676f6991d6d03f0d" title="Registers the expectation (which may be immediately met) of up to 1 notification in-message whose Msg...">expect_msg()</a>, until you invoke <a class="el" href="classipc_1_1transport_1_1struc_1_1sync__io_1_1Channel.html#a0c00bab2dad604dde176c4190553915c" title="Permanently memorizes the incoming-direction on-error handler, thus authorizing the emission of any i...">start_and_poll()</a>. (For <a class="el" href="classipc_1_1transport_1_1struc_1_1sync__io_1_1Channel.html#a6dc83bd6057b7f00a19c5947d6baa7b7" title="Useful for generic programming, the async-I/O-pattern counterpart to *this type.">Async_io_obj</a>: <a class="el" href="classipc_1_1transport_1_1struc_1_1Channel.html#a33b4785c212ad88d8322fcc2f4369351" title="Permanently memorizes the incoming-direction on-error handler, thus authorizing the emission of any i...">transport::struc::Channel::start()</a>.)</p>
<p >Consider, also, <code><a class="el" href="classipc_1_1transport_1_1struc_1_1sync__io_1_1Channel.html#a9d97a5900bd517596b763db2d6b27b45" title="See Async_io_obj counterpart.">owned_channel_mutable()</a>-&gt;auto_ping()</code> and/or <code><a class="el" href="classipc_1_1transport_1_1struc_1_1sync__io_1_1Channel.html#a9d97a5900bd517596b763db2d6b27b45" title="See Async_io_obj counterpart.">owned_channel_mutable()</a>-&gt;idle_timer_run()</code>, if you desire these features to be ambiently enabled. See <a class="el" href="classipc_1_1transport_1_1Channel.html#a290395d720167759bfa1eda1e86bf123" title="Performs hndl_snd()-&gt; and/or blob_snd()-&gt; same method, returning true if all (1-2) invoked methods re...">Channel::auto_ping()</a>, <a class="el" href="classipc_1_1transport_1_1Channel.html#abf25364b49b9fdd3ba4b1541b3a50356" title="Performs hndl_rcv()-&gt; and/or blob_rcv()-&gt; same method, returning true if all (1-2) invoked methods re...">Channel::idle_timer_run()</a> for background.</p>
<h3>How/whether to obtain a <a class="el" href="classipc_1_1transport_1_1struc_1_1sync__io_1_1Channel.html#a8a59bbc3c6a7191b316b23661d8ba6e3" title="See Async_io_obj counterpart.">Builder_config</a> <code>struct_builder_config</code> (and related)</h3>
<p >It is easiest, usually, to use a different ctor form instead; namely use a tagged-ctor version that will set everything up. See <code>Channel_base::Serialize_via_*</code>. Only use the present ctor form:</p><ul>
<li>IF: your serialization strategy of choice is simply not covered by the tagged-ctor versions available (you have a custom builder/reader you want to use for advanced purposes). OR:</li>
<li>IF: you want to use a different serialization strategy in the outgoing direction versus incoming direction: e.g., this side sends only short things &ndash; and you want to use <a class="el" href="classipc_1_1transport_1_1struc_1_1Heap__fixed__builder.html" title="Implements Struct_builder concept by straightforwardly allocating fixed-size segments on-demand in th...">Heap_fixed_builder</a> here and <a class="el" href="classipc_1_1transport_1_1struc_1_1Heap__reader.html" title="Implements Struct_reader concept by straightforwardly interpreting a serialization by Heap_fixed_buil...">Heap_reader</a> there; but the other side sends huge things, so you want SHM-based serialization there and deserialization here. The tag ctors assume symmetry and don't support this.</li>
</ul>
<p >If you've chosen to use this ctor form:</p>
<p >Formally speaking it's simply up to you to construct these args before calling this ctor; see the docs for the particular <a class="el" href="classipc_1_1transport_1_1struc_1_1sync__io_1_1Channel.html#a8a59bbc3c6a7191b316b23661d8ba6e3" title="See Async_io_obj counterpart.">Builder_config</a> class of choice. Informally: if you're constructing the <a class="el" href="classipc_1_1transport_1_1struc_1_1sync__io_1_1Channel.html#a8a59bbc3c6a7191b316b23661d8ba6e3" title="See Async_io_obj counterpart.">Builder_config</a> and/or specifying <code>struct_lender_session</code> (less so <a class="el" href="classipc_1_1transport_1_1struc_1_1sync__io_1_1Channel.html#a14a7166b2f8c117ce6ddafe943d036fa" title="See Async_io_obj counterpart.">Reader_config</a>, but for consistency it too) directly, you're probably not doing the right thing. The following places are available to obtain tese for safety and efficiency (and code maintainability):</p><ul>
<li>From another, compatible, <code><a class="el" href="classipc_1_1transport_1_1struc_1_1sync__io_1_1Channel.html" title="sync_io-pattern counterpart to async-I/O-pattern transport::struc::Channel.">Channel</a></code> via <a class="el" href="classipc_1_1transport_1_1struc_1_1sync__io_1_1Channel.html#a48a8fd167c1fe6ae95d8fc80b6a6e67f" title="See Async_io_obj counterpart.">struct_builder_config()</a>, <a class="el" href="classipc_1_1transport_1_1struc_1_1sync__io_1_1Channel.html#a43fa0b77781376edd13b742b832572e1" title="See Async_io_obj counterpart.">struct_lender_session()</a>, <a class="el" href="classipc_1_1transport_1_1struc_1_1sync__io_1_1Channel.html#a7efbfbcce0d4d426b7df9b6d6fd1e373" title="See Async_io_obj counterpart.">struct_reader_config()</a>.</li>
<li>Heap-backed:<ul>
<li><code>struct_lender_session</code> is always <code>NULL_SESSION</code>. As for the other 2:</li>
<li>If you have the target <a class="el" href="classipc_1_1transport_1_1struc_1_1sync__io_1_1Channel.html#a4abac89dbd4d26c79b7915990f751a76" title="See Async_io_obj counterpart.">Owned_channel</a>: via <code>static</code> heap_fixed_builder_config() and heap_reader_config().</li>
<li>Otherwise: <a class="el" href="classipc_1_1session_1_1Session__mv.html#a107684fdd5d233549c6daac26a81a542" title="Utility that obtains a heap-based (non-zero-copy) Struct_builder::Config, constructed with the most e...">session::Session_mv::heap_fixed_builder_config()</a> (<code>static</code> or non-<code>static</code>), <a class="el" href="classipc_1_1session_1_1Session__mv.html#ab3c69e3f8ccbd70d315bed86d697255d" title="Deserializing counterpart to non-static heap_fixed_builder_config().">session::Session_mv::heap_reader_config()</a> (ditto).</li>
</ul>
</li>
<li>SHM-backed (using SHM-classic as example):<ul>
<li><a class="el" href="classipc_1_1session_1_1shm_1_1classic_1_1Session__mv.html#a85bb0b948b7b54c06557edd3d03d66bd" title="Returns builder config suitable for capnp-serializing out-messages in SHM arena session_shm().">session::shm::classic::Session_mv::session_shm_builder_config()</a> (ditto reader), <a class="el" href="classipc_1_1session_1_1shm_1_1classic_1_1Session__mv.html#a3af67219e611f450402824e5b8b162d6" title="When transmitting items originating in Arena session_shm() via transport::struc::shm::Builder::emit_s...">session::shm::classic::Session_mv::session_shm_lender_session()</a>, <a class="el" href="classipc_1_1session_1_1shm_1_1classic_1_1Session__mv.html#a0fbea0563835e852069cdaab506dd92c" title="Identical to session_shm_builder_config() but backed by SHM arena app_shm() instead of session_shm().">session::shm::classic::Session_mv::app_shm_builder_config()</a> (ditto reader), <a class="el" href="classipc_1_1session_1_1shm_1_1classic_1_1Session__mv.html#a0b7540b33fcedeaba37a3fece1bdec7a" title="When transmitting items originating in Arena app_shm() via transport::struc::shm::Builder::emit_seria...">session::shm::classic::Session_mv::app_shm_lender_session()</a>. Requires a <code>Session</code> object.</li>
<li><a class="el" href="classipc_1_1session_1_1shm_1_1classic_1_1Session__server.html#ad0dafea47293d23e079b6b5c5c6a9cef" title="Returns builder config suitable for capnp-serializing out-messages in SHM arena app_shm() for the sam...">session::shm::classic::Session_server::app_shm_builder_config()</a> (requires <a class="el" href="structipc_1_1session_1_1Client__app.html" title="An App that is used as a client in at least one client-server IPC split.">session::Client_app</a>). Server-only; if a <code>Session</code> is not available or applicable.</li>
</ul>
</li>
</ul>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">logger_ptr</td><td>Logger to use for logging subsequently. </td></tr>
    <tr><td class="paramname">channel</td><td><a class="el" href="classipc_1_1transport_1_1struc_1_1sync__io_1_1Channel.html" title="sync_io-pattern counterpart to async-I/O-pattern transport::struc::Channel.">Channel</a> in PEER state with no prior traffic. All configurations (1 pipe, 2 pipes) are supported. If <code>channel.initialized()</code> is <code>false</code>, behavior is undefined (assertion may trip): suggest sanity-checking this prior to this ctor. Behavior is undefined if it is not in PEER state or has had prior traffic. (Reminder: PEER state does not mean it isn't hosed from error/whatever: This is handled gracefully.) The channel is moved-into <code>*this</code>. </td></tr>
    <tr><td class="paramname">struct_builder_config</td><td>The serialization engine config to use for serializing out-messages. This small object is copied. </td></tr>
    <tr><td class="paramname">struct_lender_session</td><td>See <a class="el" href="classipc_1_1transport_1_1struc_1_1Struct__builder.html#ab90424897efed06ffc6b0884761fb31f" title="Type objects of which specify to emit_serialization() the opposing recipient for which the serializat...">Struct_builder::Session</a> (and/or <a class="el" href="classipc_1_1transport_1_1struc_1_1Struct__builder.html#a89874da2fb8c9f112a1152b0b38d2281" title="Returns the serialization in the form of a sequence of 1+ pointers to Blobs which are guaranteed to r...">Struct_builder::emit_serialization()</a>) concept doc header. This small value (typically a pointer) is copied; or the type may be <a class="el" href="structipc_1_1transport_1_1struc_1_1Null__session.html" title="Value for Struct_builder::Session when no extra information is needed when serializing Struct_builder...">Null_session</a> which is empty; then there is nothing to even copy. </td></tr>
    <tr><td class="paramname">struct_reader_config</td><td>The deserialization engine config to use for deserializing in-messages. This small object is copied. </td></tr>
    <tr><td class="paramname">session_token_non_nil</td><td>The session token to place into all out-messages and for which value to check against all in-messages. If a check fails, the channel is hosed immediately. Behavior undefined if it equals nil (assertion may trip). See class doc header regarding how to obtain the value to pass-in here. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a5b863cba6eec77f20236d1e8c8d006a3" name="a5b863cba6eec77f20236d1e8c8d006a3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5b863cba6eec77f20236d1e8c8d006a3">&#9670;&nbsp;</a></span>Channel() <span class="overload">[2/8]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Channel_obj , typename Message_body , typename Struct_builder_config , typename Struct_reader_config &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classipc_1_1transport_1_1struc_1_1sync__io_1_1Channel.html">ipc::transport::struc::sync_io::Channel</a>&lt; Channel_obj, Message_body, Struct_builder_config, Struct_reader_config &gt;::Channel </td>
          <td>(</td>
          <td class="paramtype">flow::log::Logger *&#160;</td>
          <td class="paramname"><em>logger_ptr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classipc_1_1transport_1_1struc_1_1sync__io_1_1Channel.html#a4abac89dbd4d26c79b7915990f751a76">Owned_channel</a> &amp;&amp;&#160;</td>
          <td class="paramname"><em>channel</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classipc_1_1transport_1_1struc_1_1sync__io_1_1Channel.html#a8a59bbc3c6a7191b316b23661d8ba6e3">Builder_config</a> &amp;&#160;</td>
          <td class="paramname"><em>struct_builder_config</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const typename Builder_config::Builder::Session &amp;&#160;</td>
          <td class="paramname"><em>struct_lender_session</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classipc_1_1transport_1_1struc_1_1sync__io_1_1Channel.html#a14a7166b2f8c117ce6ddafe943d036fa">Reader_config</a> &amp;&#160;</td>
          <td class="paramname"><em>struct_reader_config</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>is_server</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">explicit</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Non-tag, with-log-in ctor form: Creates structured channel peer (endpoint of the <em>session master channel</em>) with a log-in phase, this peer being the <em>server</em> or <em>client</em> depending on the arg <code>is_server</code>. </p>
<p >Consider also:</p><ul>
<li>A tag-form ctor (usually simpler than manually cting <code>struct_builder_config</code> and <code>struct_reader_config</code>).</li>
<li>No-log-in ctor (since present ctor is usually needed for session master channel only).</li>
</ul>
<p >No general user communication can occur until the log-in phase is completed. As such <code>*this</code> would be the <em>session master channel</em> with, presumably, exactly 1 such <code>*this</code> in the entire process at a given time. See <a class="el" href="classipc_1_1transport_1_1struc_1_1sync__io_1_1Channel.html#a6dc83bd6057b7f00a19c5947d6baa7b7" title="Useful for generic programming, the async-I/O-pattern counterpart to *this type.">Async_io_obj</a> class doc header for background.</p>
<dl class="section note"><dt>Note</dt><dd>This ctor form is forwarded-to from <a class="el" href="classipc_1_1transport_1_1struc_1_1sync__io_1_1Channel.html#a6dc83bd6057b7f00a19c5947d6baa7b7" title="Useful for generic programming, the async-I/O-pattern counterpart to *this type.">Async_io_obj</a> ctor. Documentation below applies to both ctors except where noted.</dd></dl>
<p>If <code>*this</code> ctor is for <a class="el" href="classipc_1_1transport_1_1struc_1_1sync__io_1_1Channel.html" title="sync_io-pattern counterpart to async-I/O-pattern transport::struc::Channel.">sync_io::Channel</a>: You'll need to <a class="el" href="classipc_1_1transport_1_1struc_1_1sync__io_1_1Channel.html#a6e4f8c4207fcf678b4cfc785707d3dce" title="Sets up the sync_io-pattern interaction between *this and the user&#39;s event loop; required before asyn...">start_ops()</a> (possibly preceded by <a class="el" href="classipc_1_1transport_1_1struc_1_1sync__io_1_1Channel.html#a543aa806ec21b8550f9f440e59767d52" title="Analogous to transport::sync_io::Native_handle_sender::replace_event_wait_handles().">replace_event_wait_handles()</a>) per <code><a class="el" href="namespaceipc_1_1transport_1_1struc_1_1sync__io.html" title="sync_io-pattern counterparts to async-I/O-pattern object types in parent namespace ipc::transport::st...">sync_io</a></code> pattern. (If <code>*this</code> ctor is for <a class="el" href="classipc_1_1transport_1_1struc_1_1sync__io_1_1Channel.html#a6dc83bd6057b7f00a19c5947d6baa7b7" title="Useful for generic programming, the async-I/O-pattern counterpart to *this type.">Async_io_obj</a>: not applicable.) Then:</p>
<p >You may <a class="el" href="classipc_1_1transport_1_1struc_1_1sync__io_1_1Channel.html#a0dc388e18b0fc0fa2d8ad0a6953fb039" title="See Async_io_obj counterpart.">send()</a> (et al) immediately after this. However no in-messages shall be emitted, regardless of registered expectations such as via <a class="el" href="classipc_1_1transport_1_1struc_1_1sync__io_1_1Channel.html#a5fc489b9abefe5ab676f6991d6d03f0d" title="Registers the expectation (which may be immediately met) of up to 1 notification in-message whose Msg...">expect_msg()</a>, until you invoke <a class="el" href="classipc_1_1transport_1_1struc_1_1sync__io_1_1Channel.html#a0c00bab2dad604dde176c4190553915c" title="Permanently memorizes the incoming-direction on-error handler, thus authorizing the emission of any i...">start_and_poll()</a>. (For <a class="el" href="classipc_1_1transport_1_1struc_1_1sync__io_1_1Channel.html#a6dc83bd6057b7f00a19c5947d6baa7b7" title="Useful for generic programming, the async-I/O-pattern counterpart to *this type.">Async_io_obj</a>: <a class="el" href="classipc_1_1transport_1_1struc_1_1Channel.html#a33b4785c212ad88d8322fcc2f4369351" title="Permanently memorizes the incoming-direction on-error handler, thus authorizing the emission of any i...">transport::struc::Channel::start()</a>.)</p>
<p >Consider, also, <code><a class="el" href="classipc_1_1transport_1_1struc_1_1sync__io_1_1Channel.html#a9d97a5900bd517596b763db2d6b27b45" title="See Async_io_obj counterpart.">owned_channel_mutable()</a>-&gt;auto_ping()</code> and/or <code><a class="el" href="classipc_1_1transport_1_1struc_1_1sync__io_1_1Channel.html#a9d97a5900bd517596b763db2d6b27b45" title="See Async_io_obj counterpart.">owned_channel_mutable()</a>-&gt;idle_timer_run()</code>, if you desire these features to be ambiently enabled. See <a class="el" href="classipc_1_1transport_1_1Channel.html#a290395d720167759bfa1eda1e86bf123" title="Performs hndl_snd()-&gt; and/or blob_snd()-&gt; same method, returning true if all (1-2) invoked methods re...">Channel::auto_ping()</a>, <a class="el" href="classipc_1_1transport_1_1Channel.html#abf25364b49b9fdd3ba4b1541b3a50356" title="Performs hndl_rcv()-&gt; and/or blob_rcv()-&gt; same method, returning true if all (1-2) invoked methods re...">Channel::idle_timer_run()</a> for background.</p>
<h3>As server</h3>
<p >To begin the log-in phase &ndash; and thus start to move to the logged-in phase, in which general traffic can occur &ndash; you must use <a class="el" href="classipc_1_1transport_1_1struc_1_1sync__io_1_1Channel.html#a996e06f75024e10987eb9cf62e096eec" title="In log-in phase as server only: Registers the expectation (which may be immediately met) of up to 1 l...">expect_log_in_request()</a>. <code>*this</code> will proceed to logged-in phase automatically once the log-in request message <code>M</code> arrives, and you then invoke <code>send(X, M)</code>, where <code>X</code> is the log-in response out-message you create/fill-out. To be clear the phase change occurs as the last step in that successful <a class="el" href="classipc_1_1transport_1_1struc_1_1sync__io_1_1Channel.html#a0dc388e18b0fc0fa2d8ad0a6953fb039" title="See Async_io_obj counterpart.">send()</a>.</p>
<h3>As client</h3>
<p >To begin the log-in phase &ndash; and thus start to move to the logged-in phase, in which general traffic can occur &ndash; you must <code>send(X, nullptr, nullptr, F)</code>, where <code>X</code> is the log-in request out-message you create/fill-out, while <code>F()</code> is the handler for the log-in response. <code>*this</code> will proceed to logged-in phase automatically once the response to X arrives; and will then invoke <code>F()</code> for any further validation the user may desire.</p>
<h3>How/whether to obtain a <a class="el" href="classipc_1_1transport_1_1struc_1_1sync__io_1_1Channel.html#a8a59bbc3c6a7191b316b23661d8ba6e3" title="See Async_io_obj counterpart.">Builder_config</a> <code>struct_builder_config</code> (and <a class="el" href="classipc_1_1transport_1_1struc_1_1sync__io_1_1Channel.html#a14a7166b2f8c117ce6ddafe943d036fa" title="See Async_io_obj counterpart.">Reader_config</a> similarly)</h3>
<p >See notes for the other (no-log-in) non-tag ctor overload.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">logger_ptr</td><td>See other ctor overload. </td></tr>
    <tr><td class="paramname">channel</td><td>See other ctor overload. </td></tr>
    <tr><td class="paramname">struct_builder_config</td><td>See other ctor overload. </td></tr>
    <tr><td class="paramname">struct_lender_session</td><td>See other ctor overload. </td></tr>
    <tr><td class="paramname">struct_reader_config</td><td>See other ctor overload. </td></tr>
    <tr><td class="paramname">is_server</td><td>See above. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a81c366280bf0f3cd711eba0a9f81698f" name="a81c366280bf0f3cd711eba0a9f81698f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a81c366280bf0f3cd711eba0a9f81698f">&#9670;&nbsp;</a></span>Channel() <span class="overload">[3/8]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Channel_obj , typename Message_body , typename Struct_builder_config , typename Struct_reader_config &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classipc_1_1transport_1_1struc_1_1sync__io_1_1Channel.html">ipc::transport::struc::sync_io::Channel</a>&lt; Channel_obj, Message_body, Struct_builder_config, Struct_reader_config &gt;::Channel </td>
          <td>(</td>
          <td class="paramtype">flow::log::Logger *&#160;</td>
          <td class="paramname"><em>logger_ptr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classipc_1_1transport_1_1struc_1_1sync__io_1_1Channel.html#a4abac89dbd4d26c79b7915990f751a76">Owned_channel</a> &amp;&amp;&#160;</td>
          <td class="paramname"><em>channel</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structipc_1_1transport_1_1struc_1_1Channel__base_1_1Serialize__via__heap.html">Serialize_via_heap</a>&#160;</td>
          <td class="paramname"><em>tag</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespaceipc_1_1transport_1_1struc.html#a6751c05fb6582a34c7c47ac470c4a48b">Session_token</a> &amp;&#160;</td>
          <td class="paramname"><em>session_token_non_nil</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">explicit</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Tag version of non-tag, no-log-in ctor: Serialize_via_heap (bidirectional heap-based, non-zero-copy message serialization). </p>
<dl class="section see"><dt>See also</dt><dd>Serialize_via_heap doc header for serialization-related background. </dd>
<dd>
non-tag, no-log-in ctor. As directed there, use the present form whenever sufficient, and indeed you want this type of serialization setup. Consider also the other tag forms for other serialization methods which may match your requirements better.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">logger_ptr</td><td>See non-tag ctor form. </td></tr>
    <tr><td class="paramname">channel</td><td>See non-tag ctor form. </td></tr>
    <tr><td class="paramname">tag</td><td>Ctor-selecting tag. </td></tr>
    <tr><td class="paramname">session_token_non_nil</td><td>See non-tag ctor form. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aeb834160e2f34931c50291485d2d7d04" name="aeb834160e2f34931c50291485d2d7d04"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aeb834160e2f34931c50291485d2d7d04">&#9670;&nbsp;</a></span>Channel() <span class="overload">[4/8]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Channel_obj , typename Message_body , typename Struct_builder_config , typename Struct_reader_config &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classipc_1_1transport_1_1struc_1_1sync__io_1_1Channel.html">ipc::transport::struc::sync_io::Channel</a>&lt; Channel_obj, Message_body, Struct_builder_config, Struct_reader_config &gt;::Channel </td>
          <td>(</td>
          <td class="paramtype">flow::log::Logger *&#160;</td>
          <td class="paramname"><em>logger_ptr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classipc_1_1transport_1_1struc_1_1sync__io_1_1Channel.html#a4abac89dbd4d26c79b7915990f751a76">Owned_channel</a> &amp;&amp;&#160;</td>
          <td class="paramname"><em>channel</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structipc_1_1transport_1_1struc_1_1Channel__base_1_1Serialize__via__heap.html">Serialize_via_heap</a>&#160;</td>
          <td class="paramname"><em>tag</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>is_server</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">explicit</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Tag version of non-tag, with-log-in ctor: Serialize_via_heap (bidirectional heap-based, non-zero-copy message serialization). </p>
<dl class="section see"><dt>See also</dt><dd>Serialize_via_heap doc header for serialization-related background. </dd>
<dd>
non-tag, with-log-in ctor. As directed there, use the present form whenever sufficient, and indeed you want this type of serialization setup. Consider also the other tag forms for other serialization methods which may match your requirements better.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">logger_ptr</td><td>See non-tag ctor form. </td></tr>
    <tr><td class="paramname">channel</td><td>See non-tag ctor form. </td></tr>
    <tr><td class="paramname">tag</td><td>Ctor-selecting tag. </td></tr>
    <tr><td class="paramname">is_server</td><td>See non-tag ctor form. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a37296f3ac6713bd36d0c7b13d5f78fb7" name="a37296f3ac6713bd36d0c7b13d5f78fb7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a37296f3ac6713bd36d0c7b13d5f78fb7">&#9670;&nbsp;</a></span>Channel() <span class="overload">[5/8]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Channel_obj , typename Message_body , typename Struct_builder_config , typename Struct_reader_config &gt; </div>
<div class="memtemplate">
template&lt;typename Session &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classipc_1_1transport_1_1struc_1_1sync__io_1_1Channel.html">ipc::transport::struc::sync_io::Channel</a>&lt; Channel_obj, Message_body, Struct_builder_config, Struct_reader_config &gt;::Channel </td>
          <td>(</td>
          <td class="paramtype">flow::log::Logger *&#160;</td>
          <td class="paramname"><em>logger_ptr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classipc_1_1transport_1_1struc_1_1sync__io_1_1Channel.html#a4abac89dbd4d26c79b7915990f751a76">Owned_channel</a> &amp;&amp;&#160;</td>
          <td class="paramname"><em>channel</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structipc_1_1transport_1_1struc_1_1Channel__base_1_1Serialize__via__session__shm.html">Serialize_via_session_shm</a>&#160;</td>
          <td class="paramname"><em>tag</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Session *&#160;</td>
          <td class="paramname"><em>session</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespaceipc_1_1transport_1_1struc.html#a6751c05fb6582a34c7c47ac470c4a48b">Session_token</a> &amp;&#160;</td>
          <td class="paramname"><em>session_token_explicit</em> = <code><a class="el" href="namespaceipc_1_1transport_1_1struc.html#ad556d20a2aa2d52b83c7afb73951d47d">NULL_SESSION_TOKEN</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">explicit</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Tag version of non-tag, no-log-in ctor: Serialize_via_session_shm (bidirectional SHM-based provider, zero-copy message serialization, per-session-scope arena). </p>
<dl class="section see"><dt>See also</dt><dd>Serialize_via_session_shm doc header for serialization-related background. </dd>
<dd>
non-tag, no-log-in ctor. As directed there, use the present form whenever sufficient, and indeed you want this type of serialization setup. Consider also the other tag forms for other serialization methods which may match your requirements better.</dd></dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Session</td><td>One of, at least: <a class="el" href="namespaceipc_1_1session_1_1shm_1_1classic.html#ac6c443a72e0f22710c83bb1e8c229618" title="This is to session::Client_session what shm::classic::Server_session is to session::Server_session.">session::shm::classic::Client_session</a>, <a class="el" href="classipc_1_1session_1_1shm_1_1classic_1_1Server__session.html" title="Identical to session::Server_session in every way, except that it makes available two SHM arenas,...">session::shm::classic::Server_session</a>, <a class="el" href="namespaceipc_1_1session_1_1shm_1_1arena__lend_1_1jemalloc.html#a837b4566cb2a734eb0ba58f285d084fe" title="This is to session::Client_session what shm::arena_lend::jemalloc::Server_session is to session::Serv...">session::shm::arena_lend::jemalloc::Client_session</a>, <a class="el" href="classipc_1_1session_1_1shm_1_1arena__lend_1_1jemalloc_1_1Server__session.html" title="Identical to session::Server_session in every way, except that it makes available two SHM arenas,...">session::shm::arena_lend::jemalloc::Server_session</a>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">logger_ptr</td><td>See non-tag ctor form. </td></tr>
    <tr><td class="paramname">channel</td><td>See non-tag ctor form. </td></tr>
    <tr><td class="paramname">tag</td><td>Ctor-selecting tag. </td></tr>
    <tr><td class="paramname">session</td><td><code>session-&gt;session_shm()</code> shall be used as the backing SHM space. <code>*session</code> must be in PEER state, or behavior is undefined. </td></tr>
    <tr><td class="paramname">session_token_explicit</td><td>See non-tag ctor form. However, for convenience, if you instead supply value equal to <code>NULL_SESSION_TOKEN</code> (i.e., nil) (which is default), then <code>session-&gt;<a class="el" href="classipc_1_1transport_1_1struc_1_1sync__io_1_1Channel.html#a021bb07a76c54837619c7a91dbd5de03" title="See Async_io_obj counterpart.">session_token()</a></code> shall be used. After all... why not? That's probably what you want. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a2ec1232d7b9c59526f7d1a3c62483269" name="a2ec1232d7b9c59526f7d1a3c62483269"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2ec1232d7b9c59526f7d1a3c62483269">&#9670;&nbsp;</a></span>Channel() <span class="overload">[6/8]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Channel_obj , typename Message_body , typename Struct_builder_config , typename Struct_reader_config &gt; </div>
<div class="memtemplate">
template&lt;typename Session &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classipc_1_1transport_1_1struc_1_1sync__io_1_1Channel.html">ipc::transport::struc::sync_io::Channel</a>&lt; Channel_obj, Message_body, Struct_builder_config, Struct_reader_config &gt;::Channel </td>
          <td>(</td>
          <td class="paramtype">flow::log::Logger *&#160;</td>
          <td class="paramname"><em>logger_ptr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classipc_1_1transport_1_1struc_1_1sync__io_1_1Channel.html#a4abac89dbd4d26c79b7915990f751a76">Owned_channel</a> &amp;&amp;&#160;</td>
          <td class="paramname"><em>channel</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structipc_1_1transport_1_1struc_1_1Channel__base_1_1Serialize__via__session__shm.html">Serialize_via_session_shm</a>&#160;</td>
          <td class="paramname"><em>tag</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Session *&#160;</td>
          <td class="paramname"><em>session</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>is_server</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">explicit</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Tag version of non-tag, with-log-in ctor: Serialize_via_session_shm (bidirectional SHM-based provider, zero-copy message serialization, per-session-scope arena). </p>
<dl class="section see"><dt>See also</dt><dd>Serialize_via_session_shm doc header for serialization-related background. </dd>
<dd>
non-tag, no-log-in ctor. As directed there, use the present form whenever sufficient, and indeed you want this type of serialization setup. Consider also the other tag forms for other serialization methods which may match your requirements better.</dd></dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Session</td><td>One of, at least: <a class="el" href="namespaceipc_1_1session_1_1shm_1_1classic.html#ac6c443a72e0f22710c83bb1e8c229618" title="This is to session::Client_session what shm::classic::Server_session is to session::Server_session.">session::shm::classic::Client_session</a>, <a class="el" href="classipc_1_1session_1_1shm_1_1classic_1_1Server__session.html" title="Identical to session::Server_session in every way, except that it makes available two SHM arenas,...">session::shm::classic::Server_session</a>, <a class="el" href="namespaceipc_1_1session_1_1shm_1_1arena__lend_1_1jemalloc.html#a837b4566cb2a734eb0ba58f285d084fe" title="This is to session::Client_session what shm::arena_lend::jemalloc::Server_session is to session::Serv...">session::shm::arena_lend::jemalloc::Client_session</a>, <a class="el" href="classipc_1_1session_1_1shm_1_1arena__lend_1_1jemalloc_1_1Server__session.html" title="Identical to session::Server_session in every way, except that it makes available two SHM arenas,...">session::shm::arena_lend::jemalloc::Server_session</a>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">logger_ptr</td><td>See non-tag ctor form. </td></tr>
    <tr><td class="paramname">channel</td><td>See non-tag ctor form. </td></tr>
    <tr><td class="paramname">tag</td><td>Ctor-selecting tag. </td></tr>
    <tr><td class="paramname">session</td><td><code>session-&gt;session_shm()</code> shall be used as the backing SHM space. <code>*session</code> must be in PEER state, or behavior is undefined. </td></tr>
    <tr><td class="paramname">is_server</td><td>See non-tag ctor form. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a454d0ced89cda0b092d4f86897400e1c" name="a454d0ced89cda0b092d4f86897400e1c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a454d0ced89cda0b092d4f86897400e1c">&#9670;&nbsp;</a></span>Channel() <span class="overload">[7/8]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Channel_obj , typename Message_body , typename Struct_builder_config , typename Struct_reader_config &gt; </div>
<div class="memtemplate">
template&lt;typename Session &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classipc_1_1transport_1_1struc_1_1sync__io_1_1Channel.html">ipc::transport::struc::sync_io::Channel</a>&lt; Channel_obj, Message_body, Struct_builder_config, Struct_reader_config &gt;::Channel </td>
          <td>(</td>
          <td class="paramtype">flow::log::Logger *&#160;</td>
          <td class="paramname"><em>logger_ptr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classipc_1_1transport_1_1struc_1_1sync__io_1_1Channel.html#a4abac89dbd4d26c79b7915990f751a76">Owned_channel</a> &amp;&amp;&#160;</td>
          <td class="paramname"><em>channel</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structipc_1_1transport_1_1struc_1_1Channel__base_1_1Serialize__via__app__shm.html">Serialize_via_app_shm</a>&#160;</td>
          <td class="paramname"><em>tag</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Session *&#160;</td>
          <td class="paramname"><em>session</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespaceipc_1_1transport_1_1struc.html#a6751c05fb6582a34c7c47ac470c4a48b">Session_token</a> &amp;&#160;</td>
          <td class="paramname"><em>session_token_explicit</em> = <code><a class="el" href="namespaceipc_1_1transport_1_1struc.html#ad556d20a2aa2d52b83c7afb73951d47d">NULL_SESSION_TOKEN</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">explicit</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Tag version of non-tag, no-log-in ctor: Serialize_via_app_shm (bidirectional SHM-based provider, zero-copy message serialization, per-app-scope arena). </p>
<dl class="section see"><dt>See also</dt><dd>Serialize_via_app_shm doc header for serialization-related background. </dd>
<dd>
non-tag, no-log-in ctor. As directed there, use the present form whenever sufficient, and indeed you want this type of serialization setup. Consider also the other tag forms for other serialization methods which may match your requirements better.</dd></dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Session</td><td>One of, at least: <a class="el" href="namespaceipc_1_1session_1_1shm_1_1classic.html#ac6c443a72e0f22710c83bb1e8c229618" title="This is to session::Client_session what shm::classic::Server_session is to session::Server_session.">session::shm::classic::Client_session</a>, <a class="el" href="classipc_1_1session_1_1shm_1_1classic_1_1Server__session.html" title="Identical to session::Server_session in every way, except that it makes available two SHM arenas,...">session::shm::classic::Server_session</a>, <a class="el" href="classipc_1_1session_1_1shm_1_1arena__lend_1_1jemalloc_1_1Server__session.html" title="Identical to session::Server_session in every way, except that it makes available two SHM arenas,...">session::shm::arena_lend::jemalloc::Server_session</a> (not <a class="el" href="namespaceipc_1_1session_1_1shm_1_1arena__lend_1_1jemalloc.html#a837b4566cb2a734eb0ba58f285d084fe" title="This is to session::Client_session what shm::arena_lend::jemalloc::Server_session is to session::Serv...">session::shm::arena_lend::jemalloc::Client_session</a> &ndash; will not compile). </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">logger_ptr</td><td>See non-tag ctor form. </td></tr>
    <tr><td class="paramname">channel</td><td>See non-tag ctor form. </td></tr>
    <tr><td class="paramname">tag</td><td>Ctor-selecting tag. </td></tr>
    <tr><td class="paramname">session</td><td><code>session-&gt;app_shm()</code> shall be used as the backing SHM space. <code>*session</code> must be in PEER state, or behavior is undefined. </td></tr>
    <tr><td class="paramname">session_token_explicit</td><td>See <code>session_token_explicit</code> in the Serialize_via_session_shm counterpart to this ctor form. Spoiler alert: probably you'll want to leave this at default. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ac056b37680ded4b3c26dd4c6941a72c6" name="ac056b37680ded4b3c26dd4c6941a72c6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac056b37680ded4b3c26dd4c6941a72c6">&#9670;&nbsp;</a></span>Channel() <span class="overload">[8/8]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Channel_obj , typename Message_body , typename Struct_builder_config , typename Struct_reader_config &gt; </div>
<div class="memtemplate">
template&lt;typename Session &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classipc_1_1transport_1_1struc_1_1sync__io_1_1Channel.html">ipc::transport::struc::sync_io::Channel</a>&lt; Channel_obj, Message_body, Struct_builder_config, Struct_reader_config &gt;::Channel </td>
          <td>(</td>
          <td class="paramtype">flow::log::Logger *&#160;</td>
          <td class="paramname"><em>logger_ptr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classipc_1_1transport_1_1struc_1_1sync__io_1_1Channel.html#a4abac89dbd4d26c79b7915990f751a76">Owned_channel</a> &amp;&amp;&#160;</td>
          <td class="paramname"><em>channel</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structipc_1_1transport_1_1struc_1_1Channel__base_1_1Serialize__via__app__shm.html">Serialize_via_app_shm</a>&#160;</td>
          <td class="paramname"><em>tag</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Session *&#160;</td>
          <td class="paramname"><em>session</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>is_server</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">explicit</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Tag version of non-tag, no-log-in ctor: Serialize_via_app_shm (bidirectional SHM-based provider, zero-copy message serialization, per-app-scope arena). </p>
<dl class="section see"><dt>See also</dt><dd>Serialize_via_app_shm doc header for serialization-related background. </dd>
<dd>
non-tag, no-log-in ctor. As directed there, use the present form whenever sufficient, and indeed you want this type of serialization setup. Consider also the other tag forms for other serialization methods which may match your requirements better.</dd></dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Session</td><td>One of, at least: <a class="el" href="namespaceipc_1_1session_1_1shm_1_1classic.html#ac6c443a72e0f22710c83bb1e8c229618" title="This is to session::Client_session what shm::classic::Server_session is to session::Server_session.">session::shm::classic::Client_session</a>, <a class="el" href="classipc_1_1session_1_1shm_1_1classic_1_1Server__session.html" title="Identical to session::Server_session in every way, except that it makes available two SHM arenas,...">session::shm::classic::Server_session</a>, <a class="el" href="classipc_1_1session_1_1shm_1_1arena__lend_1_1jemalloc_1_1Server__session.html" title="Identical to session::Server_session in every way, except that it makes available two SHM arenas,...">session::shm::arena_lend::jemalloc::Server_session</a> (not ession::shm::arena_lend::jemalloc::Client_session &ndash; will not compile). </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">logger_ptr</td><td>See non-tag ctor form. </td></tr>
    <tr><td class="paramname">channel</td><td>See non-tag ctor form. </td></tr>
    <tr><td class="paramname">tag</td><td>Ctor-selecting tag. </td></tr>
    <tr><td class="paramname">session</td><td><code>session-&gt;app_shm()</code> shall be used as the backing SHM space. <code>*session</code> must be in PEER state, or behavior is undefined. </td></tr>
    <tr><td class="paramname">is_server</td><td>See non-tag ctor form. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aac7386bca503f1457d93c65e1bfdf71f" name="aac7386bca503f1457d93c65e1bfdf71f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aac7386bca503f1457d93c65e1bfdf71f">&#9670;&nbsp;</a></span>~Channel()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Channel_obj , typename Message_body , typename Struct_builder_config , typename Struct_reader_config &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classipc_1_1transport_1_1struc_1_1sync__io_1_1Channel.html">ipc::transport::struc::sync_io::Channel</a>&lt; Channel_obj, Message_body, Struct_builder_config, Struct_reader_config &gt;::~<a class="el" href="classipc_1_1transport_1_1struc_1_1sync__io_1_1Channel.html">Channel</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Invokes the destructor on the <a class="el" href="classipc_1_1transport_1_1struc_1_1sync__io_1_1Channel.html#a4abac89dbd4d26c79b7915990f751a76" title="See Async_io_obj counterpart.">Owned_channel</a>. </p>
<p >Reminder: It is recommended, before invoking this destructor, to:</p><ul>
<li>Call <code>async_end_sending(F)</code>.</li>
<li>Invoke this destructor once <code>F()</code> fires.</li>
</ul>
<p >See discussion in <a class="el" href="classipc_1_1transport_1_1struc_1_1sync__io_1_1Channel.html#ae4a2a63dc88722d96ee9f3ed68cf7b86" title="See Async_io_obj counterpart; except (1) naturally on_done_func() is invoked in the sync_io-pattern f...">async_end_sending()</a> doc header or shorter version in class doc header. </p>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="ae4a2a63dc88722d96ee9f3ed68cf7b86" name="ae4a2a63dc88722d96ee9f3ed68cf7b86"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae4a2a63dc88722d96ee9f3ed68cf7b86">&#9670;&nbsp;</a></span>async_end_sending()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Channel_obj , typename Message_body , typename Struct_builder_config , typename Struct_reader_config &gt; </div>
<div class="memtemplate">
template&lt;typename Task_err &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classipc_1_1transport_1_1struc_1_1sync__io_1_1Channel.html">ipc::transport::struc::sync_io::Channel</a>&lt; Channel_obj, Message_body, Struct_builder_config, Struct_reader_config &gt;::async_end_sending </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespaceipc.html#aa3192e586cc45d3e7c22463bf2760f89">Error_code</a> *&#160;</td>
          <td class="paramname"><em>sync_err_code</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Task_err &amp;&amp;&#160;</td>
          <td class="paramname"><em>on_done_func</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>See <a class="el" href="classipc_1_1transport_1_1struc_1_1sync__io_1_1Channel.html#a6dc83bd6057b7f00a19c5947d6baa7b7" title="Useful for generic programming, the async-I/O-pattern counterpart to *this type.">Async_io_obj</a> counterpart; except (1) naturally <code>on_done_func()</code> is invoked in the <code><a class="el" href="namespaceipc_1_1transport_1_1struc_1_1sync__io.html" title="sync_io-pattern counterparts to async-I/O-pattern object types in parent namespace ipc::transport::st...">sync_io</a></code>-pattern fashion, and (2) the operation may (and is very likely to) complete synchronously and thus ignore <code>on_done_func</code>. </p>
<dl class="section note"><dt>Note</dt><dd>It is highly recommended to read the <a class="el" href="classipc_1_1transport_1_1struc_1_1sync__io_1_1Channel.html#a6dc83bd6057b7f00a19c5947d6baa7b7" title="Useful for generic programming, the async-I/O-pattern counterpart to *this type.">Async_io_obj</a> <a class="el" href="classipc_1_1transport_1_1struc_1_1Channel.html#ab08057edd9832d94ea0e18a17c42200a" title="Operating at the unstructured layer, executes a graceful-close send by forwarding to the async transp...">transport::struc::Channel::async_end_sending()</a> doc header's recommendations on how/when/why to use the method.</dd></dl>
<p>The sync-versus-async-completion dichotomy is exactly forwarded from <a class="el" href="classipc_1_1transport_1_1struc_1_1sync__io_1_1Channel.html#a4abac89dbd4d26c79b7915990f751a76" title="See Async_io_obj counterpart.">Owned_channel</a>, and you can read the details in <a class="el" href="classipc_1_1transport_1_1sync__io_1_1Native__handle__sender.html#a9b99e18949cf819bfae4e08e44744fc6" title="Equivalent to send_native_handle() but sends a graceful-close message instead of the usual payload; t...">sync_io::Native_handle_sender::async_end_sending()</a> doc header.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Task_err</td><td>See above. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">sync_err_code</td><td>See above. </td></tr>
    <tr><td class="paramname">on_done_func</td><td>See above. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>See above. In addition <code>false</code> returned if called before <a class="el" href="classipc_1_1transport_1_1struc_1_1sync__io_1_1Channel.html#a6e4f8c4207fcf678b4cfc785707d3dce" title="Sets up the sync_io-pattern interaction between *this and the user&#39;s event loop; required before asyn...">start_ops()</a>. </dd></dl>

</div>
</div>
<a id="a26dc83067e005be38567199cbedd7f19" name="a26dc83067e005be38567199cbedd7f19"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a26dc83067e005be38567199cbedd7f19">&#9670;&nbsp;</a></span>async_request()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Channel_obj , typename Message_body , typename Struct_builder_config , typename Struct_reader_config &gt; </div>
<div class="memtemplate">
template&lt;typename On_msg_handler &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classipc_1_1transport_1_1struc_1_1sync__io_1_1Channel.html">ipc::transport::struc::sync_io::Channel</a>&lt; Channel_obj, Message_body, Struct_builder_config, Struct_reader_config &gt;::async_request </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classipc_1_1transport_1_1struc_1_1sync__io_1_1Channel.html#a83fb4462a8d4045bdb56b694bf80393c">Msg_out</a> &amp;&#160;</td>
          <td class="paramname"><em>msg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classipc_1_1transport_1_1struc_1_1sync__io_1_1Channel.html#ac3da0ac1306b63c9e38c47b8c31e3cd2">Msg_in</a> *&#160;</td>
          <td class="paramname"><em>originating_msg_or_null</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classipc_1_1transport_1_1struc_1_1Channel__base.html#adcf24fa51747ed83c4b6427fbf44fecf">msg_id_out_t</a> *&#160;</td>
          <td class="paramname"><em>id_unless_one_off</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">On_msg_handler &amp;&amp;&#160;</td>
          <td class="paramname"><em>on_rsp_func</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceipc.html#aa3192e586cc45d3e7c22463bf2760f89">Error_code</a> *&#160;</td>
          <td class="paramname"><em>err_code</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>See <a class="el" href="classipc_1_1transport_1_1struc_1_1sync__io_1_1Channel.html#a6dc83bd6057b7f00a19c5947d6baa7b7" title="Useful for generic programming, the async-I/O-pattern counterpart to *this type.">Async_io_obj</a> counterpart; though naturally <code>on_rsp_func()</code> is invoked in the <code><a class="el" href="namespaceipc_1_1transport_1_1struc_1_1sync__io.html" title="sync_io-pattern counterparts to async-I/O-pattern object types in parent namespace ipc::transport::st...">sync_io</a></code>-pattern fashion. </p>
<p >There is no possibility of the response expectation being immediately (synchronously) met.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">On_msg_handler</td><td>See <a class="el" href="classipc_1_1transport_1_1struc_1_1sync__io_1_1Channel.html#a5fc489b9abefe5ab676f6991d6d03f0d" title="Registers the expectation (which may be immediately met) of up to 1 notification in-message whose Msg...">expect_msg()</a>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">msg</td><td>See above. </td></tr>
    <tr><td class="paramname">originating_msg_or_null</td><td>See above. </td></tr>
    <tr><td class="paramname">id_unless_one_off</td><td>See above. </td></tr>
    <tr><td class="paramname">on_rsp_func</td><td>See above. </td></tr>
    <tr><td class="paramname">err_code</td><td>See above. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>See above. In addition <code>false</code> returned if called before <a class="el" href="classipc_1_1transport_1_1struc_1_1sync__io_1_1Channel.html#a6e4f8c4207fcf678b4cfc785707d3dce" title="Sets up the sync_io-pattern interaction between *this and the user&#39;s event loop; required before asyn...">start_ops()</a>. </dd></dl>

</div>
</div>
<a id="a426ecae27b4ea5cf7e666e56bad6afe5" name="a426ecae27b4ea5cf7e666e56bad6afe5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a426ecae27b4ea5cf7e666e56bad6afe5">&#9670;&nbsp;</a></span>create_msg()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Channel_obj , typename Message_body , typename Struct_builder_config , typename Struct_reader_config &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classipc_1_1transport_1_1struc_1_1sync__io_1_1Channel.html">Channel</a>&lt; Channel_obj, Message_body, Struct_builder_config, Struct_reader_config &gt;<a class="el" href="classipc_1_1transport_1_1struc_1_1sync__io_1_1Channel.html#a83fb4462a8d4045bdb56b694bf80393c">::Msg_out</a> <a class="el" href="classipc_1_1transport_1_1struc_1_1sync__io_1_1Channel.html">ipc::transport::struc::sync_io::Channel</a>&lt; Channel_obj, Message_body, Struct_builder_config, Struct_reader_config &gt;::create_msg </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespaceipc_1_1transport.html#a7ee4551983d9df16ec16a3139bac50e8">Native_handle</a> &amp;&amp;&#160;</td>
          <td class="paramname"><em>hndl_or_null</em> = <code><a class="el" href="namespaceipc_1_1transport.html#a7ee4551983d9df16ec16a3139bac50e8">Native_handle</a>()</code></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>See <a class="el" href="classipc_1_1transport_1_1struc_1_1sync__io_1_1Channel.html#a6dc83bd6057b7f00a19c5947d6baa7b7" title="Useful for generic programming, the async-I/O-pattern counterpart to *this type.">Async_io_obj</a> counterpart. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">hndl_or_null</td><td>See above. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>See above. </dd></dl>

</div>
</div>
<a id="a996e06f75024e10987eb9cf62e096eec" name="a996e06f75024e10987eb9cf62e096eec"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a996e06f75024e10987eb9cf62e096eec">&#9670;&nbsp;</a></span>expect_log_in_request()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Channel_obj , typename Message_body , typename Struct_builder_config , typename Struct_reader_config &gt; </div>
<div class="memtemplate">
template&lt;typename On_msg_handler &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classipc_1_1transport_1_1struc_1_1sync__io_1_1Channel.html">ipc::transport::struc::sync_io::Channel</a>&lt; Channel_obj, Message_body, Struct_builder_config, Struct_reader_config &gt;::expect_log_in_request </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classipc_1_1transport_1_1struc_1_1sync__io_1_1Channel.html#aa40c3ec3f45cdfea9360f7f35b9ade3c">Msg_which_in</a>&#160;</td>
          <td class="paramname"><em>which</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classipc_1_1transport_1_1struc_1_1sync__io_1_1Channel.html#acde2b3866547a30958035203d9d89928">Msg_in_ptr</a> *&#160;</td>
          <td class="paramname"><em>qd_msg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">On_msg_handler &amp;&amp;&#160;</td>
          <td class="paramname"><em>on_log_in_req_func</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>In log-in phase as server only: Registers the expectation (which may be immediately met) of up to 1 <em>log-in request</em> in-message whose <a class="el" href="classipc_1_1transport_1_1struc_1_1sync__io_1_1Channel.html#a1572a1b1cb4a72ea57f7841a5e78759b" title="See Async_io_obj counterpart.">Msg_which</a> equals <code>which</code>. </p>
<p >No-op and return <code>false</code> if <a class="el" href="classipc_1_1transport_1_1struc_1_1sync__io_1_1Channel.html#a996e06f75024e10987eb9cf62e096eec" title="In log-in phase as server only: Registers the expectation (which may be immediately met) of up to 1 l...">expect_log_in_request()</a> has already been invoked, if log-in phase is not active or active in the client role, or if a prior error has hosed the owned <a class="el" href="classipc_1_1transport_1_1struc_1_1sync__io_1_1Channel.html" title="sync_io-pattern counterpart to async-I/O-pattern transport::struc::Channel.">Channel</a>.</p>
<p >The expectation is unregistered upon receipt of the applicable in-message (and firing it with that in-message <a class="el" href="classipc_1_1transport_1_1struc_1_1sync__io_1_1Channel.html#acde2b3866547a30958035203d9d89928" title="See Async_io_obj counterpart.">Msg_in_ptr</a> as arg). In addition:</p>
<p >The 1 expected in-message may already be available synchronously. In that case:</p><ul>
<li><code>*qd_msg</code> shall be loaded with that message; and it is purged from <code>*this</code>. You must handle it as you see fit upon return from this method.</li>
<li>The expectation is immediately unregistered.</li>
<li><code>on_log_in_req_func</code> is ignored (it is not memorized).</li>
</ul>
<p >Therefore <code>on_log_in_req_func()</code> can <em>only</em> execute upon a future <code><a class="el" href="namespaceipc_1_1transport_1_1struc_1_1sync__io.html" title="sync_io-pattern counterparts to async-I/O-pattern object types in parent namespace ipc::transport::st...">sync_io</a></code>-pattern async-wait firing its <code>(*on_active_ev_func)()</code>.</p>
<h3>Tips</h3>
<p >Informally the proper behavior is:</p><ol type="1">
<li>Construct in log-in-as-server phase.</li>
<li>Invoke <a class="el" href="classipc_1_1transport_1_1struc_1_1sync__io_1_1Channel.html#a996e06f75024e10987eb9cf62e096eec" title="In log-in phase as server only: Registers the expectation (which may be immediately met) of up to 1 l...">expect_log_in_request()</a>.</li>
<li>Await <code>on_log_in_req_func(X&amp;&amp;)</code> firing, or immediate delivery of <code>X</code> via <code>*qd_msg</code>, where X is the log-in request.</li>
<li>After <code>on_log_in_req_func(X&amp;&amp;)</code> handler, or immediate delivery pf <code>X</code> via <code>*qd_msg</code>: check X for correctness (such as process identity checks). If it fails checks, destroy <code>*this</code>; else:</li>
<li>Fill out <code>X = this-&gt;<a class="el" href="classipc_1_1transport_1_1struc_1_1sync__io_1_1Channel.html#a426ecae27b4ea5cf7e666e56bad6afe5" title="See Async_io_obj counterpart.">create_msg()</a></code> (the log-in response) as needed via <code>X-&gt;body_root()</code>.</li>
<li><code>send(X)</code>. The latter automatically moves <code>*this</code> to logged-in phase locally: the bulk of the API becomes available.</li>
</ol>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">On_msg_handler</td><td>See <a class="el" href="classipc_1_1transport_1_1struc_1_1sync__io_1_1Channel.html#a5fc489b9abefe5ab676f6991d6d03f0d" title="Registers the expectation (which may be immediately met) of up to 1 notification in-message whose Msg...">expect_msg()</a>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">which</td><td>See <a class="el" href="classipc_1_1transport_1_1struc_1_1sync__io_1_1Channel.html#a5fc489b9abefe5ab676f6991d6d03f0d" title="Registers the expectation (which may be immediately met) of up to 1 notification in-message whose Msg...">expect_msg()</a>. </td></tr>
    <tr><td class="paramname">qd_msg</td><td>See <a class="el" href="classipc_1_1transport_1_1struc_1_1sync__io_1_1Channel.html#a5fc489b9abefe5ab676f6991d6d03f0d" title="Registers the expectation (which may be immediately met) of up to 1 notification in-message whose Msg...">expect_msg()</a>. </td></tr>
    <tr><td class="paramname">on_log_in_req_func</td><td>See above. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> on success; <code>false</code> due to one of the above conditions. </dd></dl>

</div>
</div>
<a id="a5fc489b9abefe5ab676f6991d6d03f0d" name="a5fc489b9abefe5ab676f6991d6d03f0d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5fc489b9abefe5ab676f6991d6d03f0d">&#9670;&nbsp;</a></span>expect_msg()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Channel_obj , typename Message_body , typename Struct_builder_config , typename Struct_reader_config &gt; </div>
<div class="memtemplate">
template&lt;typename On_msg_handler &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classipc_1_1transport_1_1struc_1_1sync__io_1_1Channel.html">ipc::transport::struc::sync_io::Channel</a>&lt; Channel_obj, Message_body, Struct_builder_config, Struct_reader_config &gt;::expect_msg </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classipc_1_1transport_1_1struc_1_1sync__io_1_1Channel.html#aa40c3ec3f45cdfea9360f7f35b9ade3c">Msg_which_in</a>&#160;</td>
          <td class="paramname"><em>which</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classipc_1_1transport_1_1struc_1_1sync__io_1_1Channel.html#acde2b3866547a30958035203d9d89928">Msg_in_ptr</a> *&#160;</td>
          <td class="paramname"><em>qd_msg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">On_msg_handler &amp;&amp;&#160;</td>
          <td class="paramname"><em>on_msg_func</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Registers the expectation (which may be immediately met) of up to 1 <em>notification</em> in-message whose <a class="el" href="classipc_1_1transport_1_1struc_1_1sync__io_1_1Channel.html#a1572a1b1cb4a72ea57f7841a5e78759b" title="See Async_io_obj counterpart.">Msg_which</a> equals <code>which</code>. </p>
<p >No-op and return <code>false</code> if <code>which</code> is already being expected, if log-in phase is not yet completed, or if a prior error has hosed the owned <a class="el" href="classipc_1_1transport_1_1struc_1_1sync__io_1_1Channel.html" title="sync_io-pattern counterpart to async-I/O-pattern transport::struc::Channel.">Channel</a>.</p>
<p >The expectation is unregistered upon receipt of the applicable in-message (and firing it with that in-message <a class="el" href="classipc_1_1transport_1_1struc_1_1sync__io_1_1Channel.html#acde2b3866547a30958035203d9d89928" title="See Async_io_obj counterpart.">Msg_in_ptr</a> as arg). In addition:</p>
<p >The 1 expected in-message may already be available synchronously. In that case:</p><ul>
<li><code>*qd_msg</code> shall be loaded with that message; and it is purged from <code>*this</code>. You must handle it as you see fit upon return from this method.</li>
<li>The expectation is immediately unregistered.</li>
<li><code>on_msg_func</code> is ignored (it is not memorized).</li>
</ul>
<p >Therefore <code>on_msg_func()</code> can <em>only</em> execute upon a future <code><a class="el" href="namespaceipc_1_1transport_1_1struc_1_1sync__io.html" title="sync_io-pattern counterparts to async-I/O-pattern object types in parent namespace ipc::transport::st...">sync_io</a></code>-pattern async-wait firing its <code>(*on_active_ev_func)()</code>.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">On_msg_handler</td><td>Handler type for in-messages; see class doc header for in-message handling signature. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">which</td><td>Top-level <a class="el" href="classipc_1_1transport_1_1struc_1_1sync__io_1_1Channel.html#a34e183c252390f369f121074772c14c4" title="See Async_io_obj counterpart.">Msg_body</a> union <code>which()</code> value to expect. </td></tr>
    <tr><td class="paramname">qd_msg</td><td><code>*qd_msg</code> is set to null if no message is immediately available; else set to that message (see above). </td></tr>
    <tr><td class="paramname">on_msg_func</td><td><code>on_msg_func(M)</code> shall be invoked in the manner explained in class doc header, on receipt of message with <code>which() == which</code>; unless it is immediately available and therefore loaded into <code>*qd_msg</code>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> on success; <code>false</code> due to one of the above conditions. </dd></dl>

</div>
</div>
<a id="a62f52488ba20dd6c69dfc1abadb2d69f" name="a62f52488ba20dd6c69dfc1abadb2d69f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a62f52488ba20dd6c69dfc1abadb2d69f">&#9670;&nbsp;</a></span>expect_msgs()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Channel_obj , typename Message_body , typename Struct_builder_config , typename Struct_reader_config &gt; </div>
<div class="memtemplate">
template&lt;typename On_msg_handler &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classipc_1_1transport_1_1struc_1_1sync__io_1_1Channel.html">ipc::transport::struc::sync_io::Channel</a>&lt; Channel_obj, Message_body, Struct_builder_config, Struct_reader_config &gt;::expect_msgs </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classipc_1_1transport_1_1struc_1_1sync__io_1_1Channel.html#aa40c3ec3f45cdfea9360f7f35b9ade3c">Msg_which_in</a>&#160;</td>
          <td class="paramname"><em>which</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classipc_1_1transport_1_1struc_1_1sync__io_1_1Channel.html#a4ab778bce8d7e6e84788879fedc62745">Msgs_in</a> *&#160;</td>
          <td class="paramname"><em>qd_msgs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">On_msg_handler &amp;&amp;&#160;</td>
          <td class="paramname"><em>on_msg_func</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Registers the expectation (some of which may be immediately met) of 0+ <em>notification</em> in-messages whose <a class="el" href="classipc_1_1transport_1_1struc_1_1sync__io_1_1Channel.html#a1572a1b1cb4a72ea57f7841a5e78759b" title="See Async_io_obj counterpart.">Msg_which</a> equals <code>which</code>. </p>
<p >No-op and return <code>false</code> if <code>which</code> is already being expected, if log-in phase is not yet completed, or if a prior error has hosed the owned <a class="el" href="classipc_1_1transport_1_1struc_1_1sync__io_1_1Channel.html" title="sync_io-pattern counterpart to async-I/O-pattern transport::struc::Channel.">Channel</a>.</p>
<p >The expectation is unregistered upon subsequent <code>undo_expect_msgs(which)</code>.</p>
<p >1+ expected in-messages may already be available synchronously. In that case:</p><ul>
<li><code>*qd_msgs</code> is loaded with those messages; and they are purged from <code>*this</code>. You must handle them as you see fit upon return from this method.</li>
<li>The expectation continues to be registered; <code>on_msg_func()</code> may be invoked in the future.</li>
</ul>
<p >Therefore <code>on_msg_func()</code> can <em>only</em> execute upon a future <code><a class="el" href="namespaceipc_1_1transport_1_1struc_1_1sync__io.html" title="sync_io-pattern counterparts to async-I/O-pattern object types in parent namespace ipc::transport::st...">sync_io</a></code>-pattern async-wait firing its <code>(*on_active_ev_func)()</code>.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">On_msg_handler</td><td>See <a class="el" href="classipc_1_1transport_1_1struc_1_1sync__io_1_1Channel.html#a5fc489b9abefe5ab676f6991d6d03f0d" title="Registers the expectation (which may be immediately met) of up to 1 notification in-message whose Msg...">expect_msg()</a>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">which</td><td>See <a class="el" href="classipc_1_1transport_1_1struc_1_1sync__io_1_1Channel.html#a5fc489b9abefe5ab676f6991d6d03f0d" title="Registers the expectation (which may be immediately met) of up to 1 notification in-message whose Msg...">expect_msg()</a>. </td></tr>
    <tr><td class="paramname">qd_msgs</td><td><code>*qd_msgs</code> is cleared; then filled with any messages (possibly none) immediately available. </td></tr>
    <tr><td class="paramname">on_msg_func</td><td>See above and <a class="el" href="classipc_1_1transport_1_1struc_1_1sync__io_1_1Channel.html#a5fc489b9abefe5ab676f6991d6d03f0d" title="Registers the expectation (which may be immediately met) of up to 1 notification in-message whose Msg...">expect_msg()</a>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>See <a class="el" href="classipc_1_1transport_1_1struc_1_1sync__io_1_1Channel.html#a5fc489b9abefe5ab676f6991d6d03f0d" title="Registers the expectation (which may be immediately met) of up to 1 notification in-message whose Msg...">expect_msg()</a>. </dd></dl>

</div>
</div>
<a id="a759e1993bc61abb41380219b254ca410" name="a759e1993bc61abb41380219b254ca410"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a759e1993bc61abb41380219b254ca410">&#9670;&nbsp;</a></span>owned_channel()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Channel_obj , typename Message_body , typename Struct_builder_config , typename Struct_reader_config &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classipc_1_1transport_1_1struc_1_1sync__io_1_1Channel.html">Channel</a>&lt; Channel_obj, Message_body, Struct_builder_config, Struct_reader_config &gt;<a class="el" href="classipc_1_1transport_1_1struc_1_1sync__io_1_1Channel.html#a4abac89dbd4d26c79b7915990f751a76">::Owned_channel</a> &amp; <a class="el" href="classipc_1_1transport_1_1struc_1_1sync__io_1_1Channel.html">ipc::transport::struc::sync_io::Channel</a>&lt; Channel_obj, Message_body, Struct_builder_config, Struct_reader_config &gt;::owned_channel</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>See <a class="el" href="classipc_1_1transport_1_1struc_1_1sync__io_1_1Channel.html#a6dc83bd6057b7f00a19c5947d6baa7b7" title="Useful for generic programming, the async-I/O-pattern counterpart to *this type.">Async_io_obj</a> counterpart. </p>
<dl class="section return"><dt>Returns</dt><dd>See above. </dd></dl>

</div>
</div>
<a id="a9d97a5900bd517596b763db2d6b27b45" name="a9d97a5900bd517596b763db2d6b27b45"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9d97a5900bd517596b763db2d6b27b45">&#9670;&nbsp;</a></span>owned_channel_mutable()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Channel_obj , typename Message_body , typename Struct_builder_config , typename Struct_reader_config &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classipc_1_1transport_1_1struc_1_1sync__io_1_1Channel.html">Channel</a>&lt; Channel_obj, Message_body, Struct_builder_config, Struct_reader_config &gt;<a class="el" href="classipc_1_1transport_1_1struc_1_1sync__io_1_1Channel.html#a4abac89dbd4d26c79b7915990f751a76">::Owned_channel</a> * <a class="el" href="classipc_1_1transport_1_1struc_1_1sync__io_1_1Channel.html">ipc::transport::struc::sync_io::Channel</a>&lt; Channel_obj, Message_body, Struct_builder_config, Struct_reader_config &gt;::owned_channel_mutable</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>See <a class="el" href="classipc_1_1transport_1_1struc_1_1sync__io_1_1Channel.html#a6dc83bd6057b7f00a19c5947d6baa7b7" title="Useful for generic programming, the async-I/O-pattern counterpart to *this type.">Async_io_obj</a> counterpart. </p>
<p >Reminder: can be useful for <code>-&gt;auto_ping()</code> and <code>-&gt;idle_timer_run()</code>. </p><dl class="section return"><dt>Returns</dt><dd>See above. </dd></dl>

</div>
</div>
<a id="a543aa806ec21b8550f9f440e59767d52" name="a543aa806ec21b8550f9f440e59767d52"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a543aa806ec21b8550f9f440e59767d52">&#9670;&nbsp;</a></span>replace_event_wait_handles()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Channel_obj , typename Message_body , typename Struct_builder_config , typename Struct_reader_config &gt; </div>
<div class="memtemplate">
template&lt;typename Create_ev_wait_hndl_func &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classipc_1_1transport_1_1struc_1_1sync__io_1_1Channel.html">ipc::transport::struc::sync_io::Channel</a>&lt; Channel_obj, Message_body, Struct_builder_config, Struct_reader_config &gt;::replace_event_wait_handles </td>
          <td>(</td>
          <td class="paramtype">const Create_ev_wait_hndl_func &amp;&#160;</td>
          <td class="paramname"><em>create_ev_wait_hndl_func</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Analogous to <a class="el" href="classipc_1_1transport_1_1sync__io_1_1Native__handle__sender.html#abe6227dfa077571d6eed2707532e4360" title="To be (optionally) invoked before any start_*_ops(), supplies a factory for the util::sync_io::Asio_w...">transport::sync_io::Native_handle_sender::replace_event_wait_handles()</a>. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Create_ev_wait_hndl_func</td><td>See above. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">create_ev_wait_hndl_func</td><td>See above. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>See above. </dd></dl>

</div>
</div>
<a id="a0dc388e18b0fc0fa2d8ad0a6953fb039" name="a0dc388e18b0fc0fa2d8ad0a6953fb039"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0dc388e18b0fc0fa2d8ad0a6953fb039">&#9670;&nbsp;</a></span>send()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Channel_obj , typename Message_body , typename Struct_builder_config , typename Struct_reader_config &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classipc_1_1transport_1_1struc_1_1sync__io_1_1Channel.html">ipc::transport::struc::sync_io::Channel</a>&lt; Channel_obj, Message_body, Struct_builder_config, Struct_reader_config &gt;::send </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classipc_1_1transport_1_1struc_1_1sync__io_1_1Channel.html#a83fb4462a8d4045bdb56b694bf80393c">Msg_out</a> &amp;&#160;</td>
          <td class="paramname"><em>msg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classipc_1_1transport_1_1struc_1_1sync__io_1_1Channel.html#ac3da0ac1306b63c9e38c47b8c31e3cd2">Msg_in</a> *&#160;</td>
          <td class="paramname"><em>originating_msg_or_null</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceipc.html#aa3192e586cc45d3e7c22463bf2760f89">Error_code</a> *&#160;</td>
          <td class="paramname"><em>err_code</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>See <a class="el" href="classipc_1_1transport_1_1struc_1_1sync__io_1_1Channel.html#a6dc83bd6057b7f00a19c5947d6baa7b7" title="Useful for generic programming, the async-I/O-pattern counterpart to *this type.">Async_io_obj</a> counterpart. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">msg</td><td>See above. </td></tr>
    <tr><td class="paramname">originating_msg_or_null</td><td>See above. </td></tr>
    <tr><td class="paramname">err_code</td><td>See above. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>See above. In addition <code>false</code> returned if called before <a class="el" href="classipc_1_1transport_1_1struc_1_1sync__io_1_1Channel.html#a6e4f8c4207fcf678b4cfc785707d3dce" title="Sets up the sync_io-pattern interaction between *this and the user&#39;s event loop; required before asyn...">start_ops()</a>. </dd></dl>

</div>
</div>
<a id="a021bb07a76c54837619c7a91dbd5de03" name="a021bb07a76c54837619c7a91dbd5de03"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a021bb07a76c54837619c7a91dbd5de03">&#9670;&nbsp;</a></span>session_token()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Channel_obj , typename Message_body , typename Struct_builder_config , typename Struct_reader_config &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="namespaceipc_1_1transport_1_1struc.html#a6751c05fb6582a34c7c47ac470c4a48b">Session_token</a> &amp; <a class="el" href="classipc_1_1transport_1_1struc_1_1sync__io_1_1Channel.html">ipc::transport::struc::sync_io::Channel</a>&lt; Channel_obj, Message_body, Struct_builder_config, Struct_reader_config &gt;::session_token</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>See <a class="el" href="classipc_1_1transport_1_1struc_1_1sync__io_1_1Channel.html#a6dc83bd6057b7f00a19c5947d6baa7b7" title="Useful for generic programming, the async-I/O-pattern counterpart to *this type.">Async_io_obj</a> counterpart. </p>
<dl class="section return"><dt>Returns</dt><dd>See above. </dd></dl>

</div>
</div>
<a id="a3fda370cc97c89a62f77a6fcf639cfd7" name="a3fda370cc97c89a62f77a6fcf639cfd7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3fda370cc97c89a62f77a6fcf639cfd7">&#9670;&nbsp;</a></span>set_remote_unexpected_response_handler()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Channel_obj , typename Message_body , typename Struct_builder_config , typename Struct_reader_config &gt; </div>
<div class="memtemplate">
template&lt;typename On_remote_unexpected_response_handler &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classipc_1_1transport_1_1struc_1_1sync__io_1_1Channel.html">ipc::transport::struc::sync_io::Channel</a>&lt; Channel_obj, Message_body, Struct_builder_config, Struct_reader_config &gt;::set_remote_unexpected_response_handler </td>
          <td>(</td>
          <td class="paramtype">On_remote_unexpected_response_handler &amp;&amp;&#160;</td>
          <td class="paramname"><em>on_func</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>See <a class="el" href="classipc_1_1transport_1_1struc_1_1sync__io_1_1Channel.html#a6dc83bd6057b7f00a19c5947d6baa7b7" title="Useful for generic programming, the async-I/O-pattern counterpart to *this type.">Async_io_obj</a> counterpart; though naturally <code>on_func()</code> is invoked in the <code><a class="el" href="namespaceipc_1_1transport_1_1struc_1_1sync__io.html" title="sync_io-pattern counterparts to async-I/O-pattern object types in parent namespace ipc::transport::st...">sync_io</a></code>-pattern fashion. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">On_remote_unexpected_response_handler</td><td>See above. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">on_func</td><td>See above. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>See above. </dd></dl>

</div>
</div>
<a id="a5c62d2a374a3a98e7fa0aef01bf8a774" name="a5c62d2a374a3a98e7fa0aef01bf8a774"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5c62d2a374a3a98e7fa0aef01bf8a774">&#9670;&nbsp;</a></span>set_unexpected_response_handler()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Channel_obj , typename Message_body , typename Struct_builder_config , typename Struct_reader_config &gt; </div>
<div class="memtemplate">
template&lt;typename On_unexpected_response_handler &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classipc_1_1transport_1_1struc_1_1sync__io_1_1Channel.html">ipc::transport::struc::sync_io::Channel</a>&lt; Channel_obj, Message_body, Struct_builder_config, Struct_reader_config &gt;::set_unexpected_response_handler </td>
          <td>(</td>
          <td class="paramtype">On_unexpected_response_handler &amp;&amp;&#160;</td>
          <td class="paramname"><em>on_func</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>See <a class="el" href="classipc_1_1transport_1_1struc_1_1sync__io_1_1Channel.html#a6dc83bd6057b7f00a19c5947d6baa7b7" title="Useful for generic programming, the async-I/O-pattern counterpart to *this type.">Async_io_obj</a> counterpart; though naturally <code>on_func()</code> is invoked in the <code><a class="el" href="namespaceipc_1_1transport_1_1struc_1_1sync__io.html" title="sync_io-pattern counterparts to async-I/O-pattern object types in parent namespace ipc::transport::st...">sync_io</a></code>-pattern fashion. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">On_unexpected_response_handler</td><td>See above. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">on_func</td><td>See above. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>See above. </dd></dl>

</div>
</div>
<a id="a0c00bab2dad604dde176c4190553915c" name="a0c00bab2dad604dde176c4190553915c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0c00bab2dad604dde176c4190553915c">&#9670;&nbsp;</a></span>start_and_poll()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Channel_obj , typename Message_body , typename Struct_builder_config , typename Struct_reader_config &gt; </div>
<div class="memtemplate">
template&lt;typename Task_err &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classipc_1_1transport_1_1struc_1_1sync__io_1_1Channel.html">ipc::transport::struc::sync_io::Channel</a>&lt; Channel_obj, Message_body, Struct_builder_config, Struct_reader_config &gt;::start_and_poll </td>
          <td>(</td>
          <td class="paramtype">Task_err &amp;&amp;&#160;</td>
          <td class="paramname"><em>on_err_func</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Permanently memorizes the incoming-direction on-error handler, thus authorizing the emission of any in-messages (and/or an error) to handlers registered via this call, <code>expect_*()</code>, <a class="el" href="classipc_1_1transport_1_1struc_1_1sync__io_1_1Channel.html#a26dc83067e005be38567199cbedd7f19" title="See Async_io_obj counterpart; though naturally on_rsp_func() is invoked in the sync_io-pattern fashio...">async_request()</a>, <code>set_*unexpected_response_handler()</code>; and <em>synchronously</em> executes any immediately relevant such handlers due to pending in-traffic. </p>
<p >To be clear: the caller must be ready for 0+ (potentially many) handlers to be synchronously invoked by this call. Even <code>on_err_func()</code> itself may be executed. That said, recursive-mayhem is unlikely to be a concern, since <a class="el" href="classipc_1_1transport_1_1struc_1_1sync__io_1_1Channel.html#a0c00bab2dad604dde176c4190553915c" title="Permanently memorizes the incoming-direction on-error handler, thus authorizing the emission of any i...">start_and_poll()</a> itself is a one-time operation for a given <code>*this</code>.</p>
<p >Until this is invoked, any incoming lower-level traffic is nevertheless saved in this process's or opposing process's user RAM to be emitted as required by, and after, <a class="el" href="classipc_1_1transport_1_1struc_1_1sync__io_1_1Channel.html#a0c00bab2dad604dde176c4190553915c" title="Permanently memorizes the incoming-direction on-error handler, thus authorizing the emission of any i...">start_and_poll()</a>. Therefore there is no need to worry about in-traffic disappearing without a trace due to <a class="el" href="classipc_1_1transport_1_1struc_1_1sync__io_1_1Channel.html#a0c00bab2dad604dde176c4190553915c" title="Permanently memorizes the incoming-direction on-error handler, thus authorizing the emission of any i...">start_and_poll()</a> being invoked too late.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Task_err</td><td>Handler type matching signature of <code>flow::async::Task_asio_err</code>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">on_err_func</td><td>The permanent on-channel-hosed error handler. See class doc header for discussion of error semantics. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> on success; <code>false</code> if <a class="el" href="classipc_1_1transport_1_1struc_1_1sync__io_1_1Channel.html#a6e4f8c4207fcf678b4cfc785707d3dce" title="Sets up the sync_io-pattern interaction between *this and the user&#39;s event loop; required before asyn...">start_ops()</a> not yet called, or if already <code><a class="el" href="classipc_1_1transport_1_1struc_1_1sync__io_1_1Channel.html#a0c00bab2dad604dde176c4190553915c" title="Permanently memorizes the incoming-direction on-error handler, thus authorizing the emission of any i...">start_and_poll()</a></code>ed, or if a prior error outgoing-direction error has hosed the owned <a class="el" href="classipc_1_1transport_1_1struc_1_1sync__io_1_1Channel.html" title="sync_io-pattern counterpart to async-I/O-pattern transport::struc::Channel.">Channel</a> (then no-op). </dd></dl>

</div>
</div>
<a id="a6e4f8c4207fcf678b4cfc785707d3dce" name="a6e4f8c4207fcf678b4cfc785707d3dce"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6e4f8c4207fcf678b4cfc785707d3dce">&#9670;&nbsp;</a></span>start_ops()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Channel_obj , typename Message_body , typename Struct_builder_config , typename Struct_reader_config &gt; </div>
<div class="memtemplate">
template&lt;typename Event_wait_func_t &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classipc_1_1transport_1_1struc_1_1sync__io_1_1Channel.html">ipc::transport::struc::sync_io::Channel</a>&lt; Channel_obj, Message_body, Struct_builder_config, Struct_reader_config &gt;::start_ops </td>
          <td>(</td>
          <td class="paramtype">Event_wait_func_t &amp;&amp;&#160;</td>
          <td class="paramname"><em>ev_wait_func</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sets up the <code><a class="el" href="namespaceipc_1_1transport_1_1struc_1_1sync__io.html" title="sync_io-pattern counterparts to async-I/O-pattern object types in parent namespace ipc::transport::st...">sync_io</a></code>-pattern interaction between <code>*this</code> and the user's event loop; required before async_accept() will work (as opposed to no-op/return <code>false</code>). </p>
<p ><code>ev_wait_func()</code> &ndash; with signature matching <a class="el" href="namespaceipc_1_1util_1_1sync__io.html#aa0b9a3cc6bdc7dedbef4f9e06851aa24" title="In sync_io pattern, concrete type storing user-supplied function invoked by pattern-implementing ipc:...">util::sync_io::Event_wait_func</a> &ndash; is a key function memorized by <code>*this</code>. It shall be invoked by <code>*this</code> operations when some op cannot complete synchronously and requires a certain event (readable/writable) to be active on a certain native-handle.</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="namespaceipc_1_1util_1_1sync__io.html#aa0b9a3cc6bdc7dedbef4f9e06851aa24" title="In sync_io pattern, concrete type storing user-supplied function invoked by pattern-implementing ipc:...">util::sync_io::Event_wait_func</a> doc header for useful and complete instructions on how to write an <code>ev_wait_func()</code> properly. Doing so correctly is the crux of using the <code><a class="el" href="namespaceipc_1_1transport_1_1struc_1_1sync__io.html" title="sync_io-pattern counterparts to async-I/O-pattern object types in parent namespace ipc::transport::st...">sync_io</a></code> pattern.</dd></dl>
<p>This is a standard <code><a class="el" href="namespaceipc_1_1transport_1_1struc_1_1sync__io.html" title="sync_io-pattern counterparts to async-I/O-pattern object types in parent namespace ipc::transport::st...">sync_io</a></code>-pattern API per <a class="el" href="namespaceipc_1_1util_1_1sync__io.html" title="Contains common code, as well as important explanatory documentation in the following text,...">util::sync_io</a> doc header.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Event_wait_func_t</td><td>Function type matching <a class="el" href="namespaceipc_1_1util_1_1sync__io.html#aa0b9a3cc6bdc7dedbef4f9e06851aa24" title="In sync_io pattern, concrete type storing user-supplied function invoked by pattern-implementing ipc:...">util::sync_io::Event_wait_func</a>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ev_wait_func</td><td>See above. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>false</code> if this has already been invoked; no-op logging aside. <code>true</code> otherwise. </dd></dl>

</div>
</div>
<a id="a48a8fd167c1fe6ae95d8fc80b6a6e67f" name="a48a8fd167c1fe6ae95d8fc80b6a6e67f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a48a8fd167c1fe6ae95d8fc80b6a6e67f">&#9670;&nbsp;</a></span>struct_builder_config()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Channel_obj , typename Message_body , typename Struct_builder_config , typename Struct_reader_config &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classipc_1_1transport_1_1struc_1_1sync__io_1_1Channel.html">Channel</a>&lt; Channel_obj, Message_body, Struct_builder_config, Struct_reader_config &gt;<a class="el" href="classipc_1_1transport_1_1struc_1_1sync__io_1_1Channel.html#a8a59bbc3c6a7191b316b23661d8ba6e3">::Builder_config</a> &amp; <a class="el" href="classipc_1_1transport_1_1struc_1_1sync__io_1_1Channel.html">ipc::transport::struc::sync_io::Channel</a>&lt; Channel_obj, Message_body, Struct_builder_config, Struct_reader_config &gt;::struct_builder_config</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>See <a class="el" href="classipc_1_1transport_1_1struc_1_1sync__io_1_1Channel.html#a6dc83bd6057b7f00a19c5947d6baa7b7" title="Useful for generic programming, the async-I/O-pattern counterpart to *this type.">Async_io_obj</a> counterpart. </p>
<dl class="section return"><dt>Returns</dt><dd>See above. </dd></dl>

</div>
</div>
<a id="a43fa0b77781376edd13b742b832572e1" name="a43fa0b77781376edd13b742b832572e1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a43fa0b77781376edd13b742b832572e1">&#9670;&nbsp;</a></span>struct_lender_session()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Channel_obj , typename Message_body , typename Struct_builder_config , typename Struct_reader_config &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classipc_1_1transport_1_1struc_1_1sync__io_1_1Channel.html">Channel</a>&lt; Channel_obj, Message_body, Struct_builder_config, Struct_reader_config &gt;::Builder_config::Builder::Session &amp; <a class="el" href="classipc_1_1transport_1_1struc_1_1sync__io_1_1Channel.html">ipc::transport::struc::sync_io::Channel</a>&lt; Channel_obj, Message_body, Struct_builder_config, Struct_reader_config &gt;::struct_lender_session</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>See <a class="el" href="classipc_1_1transport_1_1struc_1_1sync__io_1_1Channel.html#a6dc83bd6057b7f00a19c5947d6baa7b7" title="Useful for generic programming, the async-I/O-pattern counterpart to *this type.">Async_io_obj</a> counterpart. </p>
<dl class="section return"><dt>Returns</dt><dd>See above. </dd></dl>

</div>
</div>
<a id="a7efbfbcce0d4d426b7df9b6d6fd1e373" name="a7efbfbcce0d4d426b7df9b6d6fd1e373"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7efbfbcce0d4d426b7df9b6d6fd1e373">&#9670;&nbsp;</a></span>struct_reader_config()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Channel_obj , typename Message_body , typename Struct_builder_config , typename Struct_reader_config &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classipc_1_1transport_1_1struc_1_1sync__io_1_1Channel.html">Channel</a>&lt; Channel_obj, Message_body, Struct_builder_config, Struct_reader_config &gt;<a class="el" href="classipc_1_1transport_1_1struc_1_1sync__io_1_1Channel.html#a14a7166b2f8c117ce6ddafe943d036fa">::Reader_config</a> &amp; <a class="el" href="classipc_1_1transport_1_1struc_1_1sync__io_1_1Channel.html">ipc::transport::struc::sync_io::Channel</a>&lt; Channel_obj, Message_body, Struct_builder_config, Struct_reader_config &gt;::struct_reader_config</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>See <a class="el" href="classipc_1_1transport_1_1struc_1_1sync__io_1_1Channel.html#a6dc83bd6057b7f00a19c5947d6baa7b7" title="Useful for generic programming, the async-I/O-pattern counterpart to *this type.">Async_io_obj</a> counterpart. </p>
<dl class="section return"><dt>Returns</dt><dd>See above. </dd></dl>

</div>
</div>
<a id="ac8ba5f1a26a9f3e881b4871b0f6aa990" name="ac8ba5f1a26a9f3e881b4871b0f6aa990"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac8ba5f1a26a9f3e881b4871b0f6aa990">&#9670;&nbsp;</a></span>undo_expect_msgs()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Channel_obj , typename Message_body , typename Struct_builder_config , typename Struct_reader_config &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classipc_1_1transport_1_1struc_1_1sync__io_1_1Channel.html">ipc::transport::struc::sync_io::Channel</a>&lt; Channel_obj, Message_body, Struct_builder_config, Struct_reader_config &gt;::undo_expect_msgs </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classipc_1_1transport_1_1struc_1_1sync__io_1_1Channel.html#aa40c3ec3f45cdfea9360f7f35b9ade3c">Msg_which_in</a>&#160;</td>
          <td class="paramname"><em>which</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>See <a class="el" href="classipc_1_1transport_1_1struc_1_1sync__io_1_1Channel.html#a6dc83bd6057b7f00a19c5947d6baa7b7" title="Useful for generic programming, the async-I/O-pattern counterpart to *this type.">Async_io_obj</a> counterpart. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">which</td><td>See above. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>See above. </dd></dl>

</div>
</div>
<a id="a5aae7a7f907f56fa07a230eadec2fedf" name="a5aae7a7f907f56fa07a230eadec2fedf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5aae7a7f907f56fa07a230eadec2fedf">&#9670;&nbsp;</a></span>undo_expect_responses()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Channel_obj , typename Message_body , typename Struct_builder_config , typename Struct_reader_config &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classipc_1_1transport_1_1struc_1_1sync__io_1_1Channel.html">ipc::transport::struc::sync_io::Channel</a>&lt; Channel_obj, Message_body, Struct_builder_config, Struct_reader_config &gt;::undo_expect_responses </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classipc_1_1transport_1_1struc_1_1Channel__base.html#adcf24fa51747ed83c4b6427fbf44fecf">msg_id_out_t</a>&#160;</td>
          <td class="paramname"><em>originating_msg_id</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>See <a class="el" href="classipc_1_1transport_1_1struc_1_1sync__io_1_1Channel.html#a6dc83bd6057b7f00a19c5947d6baa7b7" title="Useful for generic programming, the async-I/O-pattern counterpart to *this type.">Async_io_obj</a> counterpart. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">originating_msg_id</td><td>See above. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>See above. </dd></dl>

</div>
</div>
<a id="a24382a751a2c03e00c5140c89aba2c62" name="a24382a751a2c03e00c5140c89aba2c62"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a24382a751a2c03e00c5140c89aba2c62">&#9670;&nbsp;</a></span>unset_remote_unexpected_response_handler()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Channel_obj , typename Message_body , typename Struct_builder_config , typename Struct_reader_config &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classipc_1_1transport_1_1struc_1_1sync__io_1_1Channel.html">ipc::transport::struc::sync_io::Channel</a>&lt; Channel_obj, Message_body, Struct_builder_config, Struct_reader_config &gt;::unset_remote_unexpected_response_handler</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>See <a class="el" href="classipc_1_1transport_1_1struc_1_1sync__io_1_1Channel.html#a6dc83bd6057b7f00a19c5947d6baa7b7" title="Useful for generic programming, the async-I/O-pattern counterpart to *this type.">Async_io_obj</a> counterpart. </p>
<dl class="section return"><dt>Returns</dt><dd>See above. </dd></dl>

</div>
</div>
<a id="a1f226e506cc5c04584e11480426b19da" name="a1f226e506cc5c04584e11480426b19da"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1f226e506cc5c04584e11480426b19da">&#9670;&nbsp;</a></span>unset_unexpected_response_handler()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Channel_obj , typename Message_body , typename Struct_builder_config , typename Struct_reader_config &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classipc_1_1transport_1_1struc_1_1sync__io_1_1Channel.html">ipc::transport::struc::sync_io::Channel</a>&lt; Channel_obj, Message_body, Struct_builder_config, Struct_reader_config &gt;::unset_unexpected_response_handler</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>See <a class="el" href="classipc_1_1transport_1_1struc_1_1sync__io_1_1Channel.html#a6dc83bd6057b7f00a19c5947d6baa7b7" title="Useful for generic programming, the async-I/O-pattern counterpart to *this type.">Async_io_obj</a> counterpart. </p>
<dl class="section return"><dt>Returns</dt><dd>See above. </dd></dl>

</div>
</div>
<h2 class="groupheader">Friends And Related Function Documentation</h2>
<a id="a0351bb14f40312b30e6cae4927f3373b" name="a0351bb14f40312b30e6cae4927f3373b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0351bb14f40312b30e6cae4927f3373b">&#9670;&nbsp;</a></span>operator&lt;&lt;()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Channel_obj , typename Message_body , typename Struct_builder_config , typename Struct_reader_config &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::ostream &amp; operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>os</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classipc_1_1transport_1_1struc_1_1sync__io_1_1Channel.html">Channel</a>&lt; Channel_obj, Message_body, Struct_builder_config, Struct_reader_config &gt; &amp;&#160;</td>
          <td class="paramname"><em>val</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Prints string representation of the given <a class="el" href="classipc_1_1transport_1_1struc_1_1sync__io_1_1Channel.html" title="sync_io-pattern counterpart to async-I/O-pattern transport::struc::Channel.">struc::sync_io::Channel</a> to the given <code>ostream</code>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">os</td><td>Stream to which to write. </td></tr>
    <tr><td class="paramname">val</td><td>Object to serialize. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>os</code>. </dd></dl>

</div>
</div>
<hr/>The documentation for this class was generated from the following files:<ul>
<li>transport/struc/<a class="el" href="struc__fwd_8hpp.html">struc_fwd.hpp</a></li>
<li>transport/struc/sync_io/<a class="el" href="ipc__transport__structured_2src_2ipc_2transport_2struc_2sync__io_2channel_8hpp.html">channel.hpp</a></li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Wed Jan 17 2024 06:19:42 for Flow-IPC by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.4
</small></address>
</body>
</html>
