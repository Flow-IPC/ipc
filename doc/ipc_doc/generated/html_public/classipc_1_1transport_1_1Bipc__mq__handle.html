<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.9.4"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Flow-IPC: ipc::transport::Bipc_mq_handle Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">Flow-IPC<span id="projectnumber">&#160;1.0.2</span>
   </div>
   <div id="projectbrief">Flow-IPC project: Public API.</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.4 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search",'Search','.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespaceipc.html">ipc</a></li><li class="navelem"><a class="el" href="namespaceipc_1_1transport.html">transport</a></li><li class="navelem"><a class="el" href="classipc_1_1transport_1_1Bipc__mq__handle.html">Bipc_mq_handle</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pub-static-methods">Static Public Member Functions</a> &#124;
<a href="#pub-static-attribs">Static Public Attributes</a> &#124;
<a href="#related">Related Functions</a> &#124;
<a href="classipc_1_1transport_1_1Bipc__mq__handle-members.html">List of all members</a>  </div>
  <div class="headertitle"><div class="title">ipc::transport::Bipc_mq_handle Class Reference</div></div>
</div><!--header-->
<div class="contents">

<p>Implements the <a class="el" href="classipc_1_1transport_1_1Persistent__mq__handle.html" title="A documentation-only concept defining the behavior of an object representing a light-weight handle to...">Persistent_mq_handle</a> concept by thinly wrapping <code>bipc::message_queue</code>, which is boost.interprocess's persistent message queue API.  
 <a href="classipc_1_1transport_1_1Bipc__mq__handle.html#details">More...</a></p>

<p><code>#include &lt;bipc_mq_handle.hpp&gt;</code></p>

<p>Inherits flow::log::Log_context.</p>
<div class="dynheader">
Collaboration diagram for ipc::transport::Bipc_mq_handle:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="classipc_1_1transport_1_1Bipc__mq__handle__coll__graph.svg" width="284" height="203"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe>
</div>
<center><span class="legend">[<a href="graph_legend.html">legend</a>]</span></center></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-methods" name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a0022f89e50cc522971cac3eb12025924"><td class="memItemLeft" align="right" valign="top"><a id="a0022f89e50cc522971cac3eb12025924" name="a0022f89e50cc522971cac3eb12025924"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>Bipc_mq_handle</b> ()</td></tr>
<tr class="memdesc:a0022f89e50cc522971cac3eb12025924"><td class="mdescLeft">&#160;</td><td class="mdescRight">Implements <a class="el" href="classipc_1_1transport_1_1Persistent__mq__handle.html" title="A documentation-only concept defining the behavior of an object representing a light-weight handle to...">Persistent_mq_handle</a> API: Construct null handle. <br /></td></tr>
<tr class="separator:a0022f89e50cc522971cac3eb12025924"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a11941ad5d1a6d0cef286a69ed99bb2d0"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classipc_1_1transport_1_1Bipc__mq__handle.html#a11941ad5d1a6d0cef286a69ed99bb2d0">Bipc_mq_handle</a> (flow::log::Logger *logger_ptr, const <a class="el" href="namespaceipc_1_1transport.html#a33de1c256addb3964b839dc2dd407d24">Shared_name</a> &amp;<a class="el" href="classipc_1_1transport_1_1Bipc__mq__handle.html#a7263ed9ec4f8ed534c0f7907b7accde9">absolute_name</a>, <a class="el" href="namespaceipc_1_1util.html#a9d84c2bab504e6de32b20c77ca9723a2">util::Create_only</a> mode_tag, size_t max_n_msg, size_t max_msg_sz, const <a class="el" href="namespaceipc_1_1util.html#a1b398ae730d1e6040687cb2397115152">util::Permissions</a> &amp;perms=<a class="el" href="namespaceipc_1_1util.html#a1b398ae730d1e6040687cb2397115152">util::Permissions</a>(), <a class="el" href="namespaceipc.html#aa3192e586cc45d3e7c22463bf2760f89">Error_code</a> *err_code=0)</td></tr>
<tr class="memdesc:a11941ad5d1a6d0cef286a69ed99bb2d0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Implements <a class="el" href="classipc_1_1transport_1_1Persistent__mq__handle.html" title="A documentation-only concept defining the behavior of an object representing a light-weight handle to...">Persistent_mq_handle</a> API: Construct handle to non-existing named MQ, creating it first.  <a href="classipc_1_1transport_1_1Bipc__mq__handle.html#a11941ad5d1a6d0cef286a69ed99bb2d0">More...</a><br /></td></tr>
<tr class="separator:a11941ad5d1a6d0cef286a69ed99bb2d0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8fc57150cd7b7223b5f75b187bc7406f"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classipc_1_1transport_1_1Bipc__mq__handle.html#a8fc57150cd7b7223b5f75b187bc7406f">Bipc_mq_handle</a> (flow::log::Logger *logger_ptr, const <a class="el" href="namespaceipc_1_1transport.html#a33de1c256addb3964b839dc2dd407d24">Shared_name</a> &amp;<a class="el" href="classipc_1_1transport_1_1Bipc__mq__handle.html#a7263ed9ec4f8ed534c0f7907b7accde9">absolute_name</a>, <a class="el" href="namespaceipc_1_1util.html#a9571de958538d7a4a8649bbfecfac0b9">util::Open_or_create</a> mode_tag, size_t max_n_msg_on_create, size_t max_msg_sz_on_create, const <a class="el" href="namespaceipc_1_1util.html#a1b398ae730d1e6040687cb2397115152">util::Permissions</a> &amp;perms_on_create=<a class="el" href="namespaceipc_1_1util.html#a1b398ae730d1e6040687cb2397115152">util::Permissions</a>(), <a class="el" href="namespaceipc.html#aa3192e586cc45d3e7c22463bf2760f89">Error_code</a> *err_code=0)</td></tr>
<tr class="memdesc:a8fc57150cd7b7223b5f75b187bc7406f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Implements <a class="el" href="classipc_1_1transport_1_1Persistent__mq__handle.html" title="A documentation-only concept defining the behavior of an object representing a light-weight handle to...">Persistent_mq_handle</a> API: Construct handle to existing named MQ, or else if it does not exist creates it first and opens it (atomically).  <a href="classipc_1_1transport_1_1Bipc__mq__handle.html#a8fc57150cd7b7223b5f75b187bc7406f">More...</a><br /></td></tr>
<tr class="separator:a8fc57150cd7b7223b5f75b187bc7406f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a65748d60779863c62808478340bfb142"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classipc_1_1transport_1_1Bipc__mq__handle.html#a65748d60779863c62808478340bfb142">Bipc_mq_handle</a> (flow::log::Logger *logger_ptr, const <a class="el" href="namespaceipc_1_1transport.html#a33de1c256addb3964b839dc2dd407d24">Shared_name</a> &amp;<a class="el" href="classipc_1_1transport_1_1Bipc__mq__handle.html#a7263ed9ec4f8ed534c0f7907b7accde9">absolute_name</a>, <a class="el" href="namespaceipc_1_1util.html#a3e03491b5b2b5fac26551a220946d6e5">util::Open_only</a> mode_tag, <a class="el" href="namespaceipc.html#aa3192e586cc45d3e7c22463bf2760f89">Error_code</a> *err_code=0)</td></tr>
<tr class="memdesc:a65748d60779863c62808478340bfb142"><td class="mdescLeft">&#160;</td><td class="mdescRight">Implements <a class="el" href="classipc_1_1transport_1_1Persistent__mq__handle.html" title="A documentation-only concept defining the behavior of an object representing a light-weight handle to...">Persistent_mq_handle</a> API: Construct handle to existing named MQ.  <a href="classipc_1_1transport_1_1Bipc__mq__handle.html#a65748d60779863c62808478340bfb142">More...</a><br /></td></tr>
<tr class="separator:a65748d60779863c62808478340bfb142"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9734d457200dbaa9234539f666060403"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classipc_1_1transport_1_1Bipc__mq__handle.html#a9734d457200dbaa9234539f666060403">Bipc_mq_handle</a> (<a class="el" href="classipc_1_1transport_1_1Bipc__mq__handle.html">Bipc_mq_handle</a> &amp;&amp;src)</td></tr>
<tr class="memdesc:a9734d457200dbaa9234539f666060403"><td class="mdescLeft">&#160;</td><td class="mdescRight">Implements <a class="el" href="classipc_1_1transport_1_1Persistent__mq__handle.html" title="A documentation-only concept defining the behavior of an object representing a light-weight handle to...">Persistent_mq_handle</a> API: Constructs handle from the source handle while making the latter as-if default-cted.  <a href="classipc_1_1transport_1_1Bipc__mq__handle.html#a9734d457200dbaa9234539f666060403">More...</a><br /></td></tr>
<tr class="separator:a9734d457200dbaa9234539f666060403"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a33a6dd5bd00f47d79ee42a2ff5d99ddc"><td class="memItemLeft" align="right" valign="top"><a id="a33a6dd5bd00f47d79ee42a2ff5d99ddc" name="a33a6dd5bd00f47d79ee42a2ff5d99ddc"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>Bipc_mq_handle</b> (const <a class="el" href="classipc_1_1transport_1_1Bipc__mq__handle.html">Bipc_mq_handle</a> &amp;)=delete</td></tr>
<tr class="memdesc:a33a6dd5bd00f47d79ee42a2ff5d99ddc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copying of handles is prohibited, per <a class="el" href="classipc_1_1transport_1_1Persistent__mq__handle.html" title="A documentation-only concept defining the behavior of an object representing a light-weight handle to...">Persistent_mq_handle</a> concept. <br /></td></tr>
<tr class="separator:a33a6dd5bd00f47d79ee42a2ff5d99ddc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abe6cb3e8131f26c250c4b623d3fa2afe"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classipc_1_1transport_1_1Bipc__mq__handle.html#abe6cb3e8131f26c250c4b623d3fa2afe">~Bipc_mq_handle</a> ()</td></tr>
<tr class="memdesc:abe6cb3e8131f26c250c4b623d3fa2afe"><td class="mdescLeft">&#160;</td><td class="mdescRight">Implements <a class="el" href="classipc_1_1transport_1_1Persistent__mq__handle.html" title="A documentation-only concept defining the behavior of an object representing a light-weight handle to...">Persistent_mq_handle</a> API: Destroys this handle (or no-op if no handle was successfully constructed, or if it's a moved-from or default-cted handle).  <a href="classipc_1_1transport_1_1Bipc__mq__handle.html#abe6cb3e8131f26c250c4b623d3fa2afe">More...</a><br /></td></tr>
<tr class="separator:abe6cb3e8131f26c250c4b623d3fa2afe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1a94d32b8a1bc93d19b19a0da35cd062"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classipc_1_1transport_1_1Bipc__mq__handle.html">Bipc_mq_handle</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classipc_1_1transport_1_1Bipc__mq__handle.html#a1a94d32b8a1bc93d19b19a0da35cd062">operator=</a> (<a class="el" href="classipc_1_1transport_1_1Bipc__mq__handle.html">Bipc_mq_handle</a> &amp;&amp;src)</td></tr>
<tr class="memdesc:a1a94d32b8a1bc93d19b19a0da35cd062"><td class="mdescLeft">&#160;</td><td class="mdescRight">Implements <a class="el" href="classipc_1_1transport_1_1Persistent__mq__handle.html" title="A documentation-only concept defining the behavior of an object representing a light-weight handle to...">Persistent_mq_handle</a> API: Replaces handle with the source handle while making the latter invalid as-if default-cted.  <a href="classipc_1_1transport_1_1Bipc__mq__handle.html#a1a94d32b8a1bc93d19b19a0da35cd062">More...</a><br /></td></tr>
<tr class="separator:a1a94d32b8a1bc93d19b19a0da35cd062"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a28a66f0f9ca7cf288e0a6e1d960068c8"><td class="memItemLeft" align="right" valign="top"><a id="a28a66f0f9ca7cf288e0a6e1d960068c8" name="a28a66f0f9ca7cf288e0a6e1d960068c8"></a>
<a class="el" href="classipc_1_1transport_1_1Bipc__mq__handle.html">Bipc_mq_handle</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>operator=</b> (const <a class="el" href="classipc_1_1transport_1_1Bipc__mq__handle.html">Bipc_mq_handle</a> &amp;)=delete</td></tr>
<tr class="memdesc:a28a66f0f9ca7cf288e0a6e1d960068c8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copying of handles is prohibited, per <a class="el" href="classipc_1_1transport_1_1Persistent__mq__handle.html" title="A documentation-only concept defining the behavior of an object representing a light-weight handle to...">Persistent_mq_handle</a> concept. <br /></td></tr>
<tr class="separator:a28a66f0f9ca7cf288e0a6e1d960068c8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4c3406cf8759017342ed295fcc833704"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classipc_1_1transport_1_1Bipc__mq__handle.html#a4c3406cf8759017342ed295fcc833704">try_send</a> (const <a class="el" href="namespaceipc_1_1util.html#ae0be7edba7e30ffa3f8b742af621f2ab">util::Blob_const</a> &amp;blob, <a class="el" href="namespaceipc.html#aa3192e586cc45d3e7c22463bf2760f89">Error_code</a> *err_code=0)</td></tr>
<tr class="memdesc:a4c3406cf8759017342ed295fcc833704"><td class="mdescLeft">&#160;</td><td class="mdescRight">Implements <a class="el" href="classipc_1_1transport_1_1Persistent__mq__handle.html" title="A documentation-only concept defining the behavior of an object representing a light-weight handle to...">Persistent_mq_handle</a> API: Non-blocking send: pushes copy of message to queue and returns <code>true</code>; if queue is full then no-op and returns <code>false</code>.  <a href="classipc_1_1transport_1_1Bipc__mq__handle.html#a4c3406cf8759017342ed295fcc833704">More...</a><br /></td></tr>
<tr class="separator:a4c3406cf8759017342ed295fcc833704"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a45e952a67d6568f6ef4834a3523a2ca4"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classipc_1_1transport_1_1Bipc__mq__handle.html#a45e952a67d6568f6ef4834a3523a2ca4">send</a> (const <a class="el" href="namespaceipc_1_1util.html#ae0be7edba7e30ffa3f8b742af621f2ab">util::Blob_const</a> &amp;blob, <a class="el" href="namespaceipc.html#aa3192e586cc45d3e7c22463bf2760f89">Error_code</a> *err_code=0)</td></tr>
<tr class="memdesc:a45e952a67d6568f6ef4834a3523a2ca4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Implements <a class="el" href="classipc_1_1transport_1_1Persistent__mq__handle.html" title="A documentation-only concept defining the behavior of an object representing a light-weight handle to...">Persistent_mq_handle</a> API: Blocking send: pushes copy of message to queue; if queue is full blocks until it is not.  <a href="classipc_1_1transport_1_1Bipc__mq__handle.html#a45e952a67d6568f6ef4834a3523a2ca4">More...</a><br /></td></tr>
<tr class="separator:a45e952a67d6568f6ef4834a3523a2ca4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8e486336f1dfffa1c397b725b95b175b"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classipc_1_1transport_1_1Bipc__mq__handle.html#a8e486336f1dfffa1c397b725b95b175b">timed_send</a> (const <a class="el" href="namespaceipc_1_1util.html#ae0be7edba7e30ffa3f8b742af621f2ab">util::Blob_const</a> &amp;blob, <a class="el" href="namespaceipc_1_1util.html#ac66141280c3b7295a86b65209f31cc58">util::Fine_duration</a> timeout_from_now, <a class="el" href="namespaceipc.html#aa3192e586cc45d3e7c22463bf2760f89">Error_code</a> *err_code=0)</td></tr>
<tr class="memdesc:a8e486336f1dfffa1c397b725b95b175b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Implements <a class="el" href="classipc_1_1transport_1_1Persistent__mq__handle.html" title="A documentation-only concept defining the behavior of an object representing a light-weight handle to...">Persistent_mq_handle</a> API: Blocking timed send: pushes copy of message to queue; if queue is full blocks until it is not, or the specified time passes, whichever happens first.  <a href="classipc_1_1transport_1_1Bipc__mq__handle.html#a8e486336f1dfffa1c397b725b95b175b">More...</a><br /></td></tr>
<tr class="separator:a8e486336f1dfffa1c397b725b95b175b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afa693699d1678040f6d22efbfaf657fe"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classipc_1_1transport_1_1Bipc__mq__handle.html#afa693699d1678040f6d22efbfaf657fe">is_sendable</a> (<a class="el" href="namespaceipc.html#aa3192e586cc45d3e7c22463bf2760f89">Error_code</a> *err_code=0)</td></tr>
<tr class="memdesc:afa693699d1678040f6d22efbfaf657fe"><td class="mdescLeft">&#160;</td><td class="mdescRight">Implements <a class="el" href="classipc_1_1transport_1_1Persistent__mq__handle.html" title="A documentation-only concept defining the behavior of an object representing a light-weight handle to...">Persistent_mq_handle</a> API: Like <a class="el" href="classipc_1_1transport_1_1Bipc__mq__handle.html#a4c3406cf8759017342ed295fcc833704" title="Implements Persistent_mq_handle API: Non-blocking send: pushes copy of message to queue and returns t...">try_send()</a> but without the actual pushing of a message.  <a href="classipc_1_1transport_1_1Bipc__mq__handle.html#afa693699d1678040f6d22efbfaf657fe">More...</a><br /></td></tr>
<tr class="separator:afa693699d1678040f6d22efbfaf657fe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad81eec3af613f32444785f8b5426ec50"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classipc_1_1transport_1_1Bipc__mq__handle.html#ad81eec3af613f32444785f8b5426ec50">wait_sendable</a> (<a class="el" href="namespaceipc.html#aa3192e586cc45d3e7c22463bf2760f89">Error_code</a> *err_code=0)</td></tr>
<tr class="memdesc:ad81eec3af613f32444785f8b5426ec50"><td class="mdescLeft">&#160;</td><td class="mdescRight">Implements <a class="el" href="classipc_1_1transport_1_1Persistent__mq__handle.html" title="A documentation-only concept defining the behavior of an object representing a light-weight handle to...">Persistent_mq_handle</a> API: Like <a class="el" href="classipc_1_1transport_1_1Bipc__mq__handle.html#a45e952a67d6568f6ef4834a3523a2ca4" title="Implements Persistent_mq_handle API: Blocking send: pushes copy of message to queue; if queue is full...">send()</a> but without the actual pushing of a message.  <a href="classipc_1_1transport_1_1Bipc__mq__handle.html#ad81eec3af613f32444785f8b5426ec50">More...</a><br /></td></tr>
<tr class="separator:ad81eec3af613f32444785f8b5426ec50"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a164168adee0d188da11db8f17442dbef"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classipc_1_1transport_1_1Bipc__mq__handle.html#a164168adee0d188da11db8f17442dbef">timed_wait_sendable</a> (<a class="el" href="namespaceipc_1_1util.html#ac66141280c3b7295a86b65209f31cc58">util::Fine_duration</a> timeout_from_now, <a class="el" href="namespaceipc.html#aa3192e586cc45d3e7c22463bf2760f89">Error_code</a> *err_code=0)</td></tr>
<tr class="memdesc:a164168adee0d188da11db8f17442dbef"><td class="mdescLeft">&#160;</td><td class="mdescRight">Implements <a class="el" href="classipc_1_1transport_1_1Persistent__mq__handle.html" title="A documentation-only concept defining the behavior of an object representing a light-weight handle to...">Persistent_mq_handle</a> API: Like <a class="el" href="classipc_1_1transport_1_1Bipc__mq__handle.html#a8e486336f1dfffa1c397b725b95b175b" title="Implements Persistent_mq_handle API: Blocking timed send: pushes copy of message to queue; if queue i...">timed_send()</a> but without the actual pushing of a message.  <a href="classipc_1_1transport_1_1Bipc__mq__handle.html#a164168adee0d188da11db8f17442dbef">More...</a><br /></td></tr>
<tr class="separator:a164168adee0d188da11db8f17442dbef"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7a974f3cfbb095f0b67e773f4f2fb1a9"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classipc_1_1transport_1_1Bipc__mq__handle.html#a7a974f3cfbb095f0b67e773f4f2fb1a9">try_receive</a> (<a class="el" href="namespaceipc_1_1util.html#a6cb62ae434900f3a8915b33ec5d61a96">util::Blob_mutable</a> *blob, <a class="el" href="namespaceipc.html#aa3192e586cc45d3e7c22463bf2760f89">Error_code</a> *err_code=0)</td></tr>
<tr class="memdesc:a7a974f3cfbb095f0b67e773f4f2fb1a9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Implements <a class="el" href="classipc_1_1transport_1_1Persistent__mq__handle.html" title="A documentation-only concept defining the behavior of an object representing a light-weight handle to...">Persistent_mq_handle</a> API: Non-blocking receive: pops copy of message from queue into buffer and returns <code>true</code>; if queue is empty then no-op and returns <code>false</code>.  <a href="classipc_1_1transport_1_1Bipc__mq__handle.html#a7a974f3cfbb095f0b67e773f4f2fb1a9">More...</a><br /></td></tr>
<tr class="separator:a7a974f3cfbb095f0b67e773f4f2fb1a9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9d1aaf82f6396f4d975a77a70433698d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classipc_1_1transport_1_1Bipc__mq__handle.html#a9d1aaf82f6396f4d975a77a70433698d">receive</a> (<a class="el" href="namespaceipc_1_1util.html#a6cb62ae434900f3a8915b33ec5d61a96">util::Blob_mutable</a> *blob, <a class="el" href="namespaceipc.html#aa3192e586cc45d3e7c22463bf2760f89">Error_code</a> *err_code=0)</td></tr>
<tr class="memdesc:a9d1aaf82f6396f4d975a77a70433698d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Implements <a class="el" href="classipc_1_1transport_1_1Persistent__mq__handle.html" title="A documentation-only concept defining the behavior of an object representing a light-weight handle to...">Persistent_mq_handle</a> API: Blocking receive: pops copy of message from queue into buffer; if queue is empty blocks until it is not.  <a href="classipc_1_1transport_1_1Bipc__mq__handle.html#a9d1aaf82f6396f4d975a77a70433698d">More...</a><br /></td></tr>
<tr class="separator:a9d1aaf82f6396f4d975a77a70433698d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a67be05bc1749981e0863d18681d006ac"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classipc_1_1transport_1_1Bipc__mq__handle.html#a67be05bc1749981e0863d18681d006ac">timed_receive</a> (<a class="el" href="namespaceipc_1_1util.html#a6cb62ae434900f3a8915b33ec5d61a96">util::Blob_mutable</a> *blob, <a class="el" href="namespaceipc_1_1util.html#ac66141280c3b7295a86b65209f31cc58">util::Fine_duration</a> timeout_from_now, <a class="el" href="namespaceipc.html#aa3192e586cc45d3e7c22463bf2760f89">Error_code</a> *err_code=0)</td></tr>
<tr class="memdesc:a67be05bc1749981e0863d18681d006ac"><td class="mdescLeft">&#160;</td><td class="mdescRight">Implements <a class="el" href="classipc_1_1transport_1_1Persistent__mq__handle.html" title="A documentation-only concept defining the behavior of an object representing a light-weight handle to...">Persistent_mq_handle</a> API: Blocking timed receive: pops copy of message from queue into buffer; if queue is empty blocks until it is not, or the specified time passes, whichever happens first.  <a href="classipc_1_1transport_1_1Bipc__mq__handle.html#a67be05bc1749981e0863d18681d006ac">More...</a><br /></td></tr>
<tr class="separator:a67be05bc1749981e0863d18681d006ac"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adade0e6deab4db302be7343d27568e8a"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classipc_1_1transport_1_1Bipc__mq__handle.html#adade0e6deab4db302be7343d27568e8a">is_receivable</a> (<a class="el" href="namespaceipc.html#aa3192e586cc45d3e7c22463bf2760f89">Error_code</a> *err_code=0)</td></tr>
<tr class="memdesc:adade0e6deab4db302be7343d27568e8a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Implements <a class="el" href="classipc_1_1transport_1_1Persistent__mq__handle.html" title="A documentation-only concept defining the behavior of an object representing a light-weight handle to...">Persistent_mq_handle</a> API: Like <a class="el" href="classipc_1_1transport_1_1Bipc__mq__handle.html#a7a974f3cfbb095f0b67e773f4f2fb1a9" title="Implements Persistent_mq_handle API: Non-blocking receive: pops copy of message from queue into buffe...">try_receive()</a> but without the actual popping of a message.  <a href="classipc_1_1transport_1_1Bipc__mq__handle.html#adade0e6deab4db302be7343d27568e8a">More...</a><br /></td></tr>
<tr class="separator:adade0e6deab4db302be7343d27568e8a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7e2d79b92673be3ddba30c6d57020125"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classipc_1_1transport_1_1Bipc__mq__handle.html#a7e2d79b92673be3ddba30c6d57020125">wait_receivable</a> (<a class="el" href="namespaceipc.html#aa3192e586cc45d3e7c22463bf2760f89">Error_code</a> *err_code=0)</td></tr>
<tr class="memdesc:a7e2d79b92673be3ddba30c6d57020125"><td class="mdescLeft">&#160;</td><td class="mdescRight">Implements <a class="el" href="classipc_1_1transport_1_1Persistent__mq__handle.html" title="A documentation-only concept defining the behavior of an object representing a light-weight handle to...">Persistent_mq_handle</a> API: Like <a class="el" href="classipc_1_1transport_1_1Bipc__mq__handle.html#a9d1aaf82f6396f4d975a77a70433698d" title="Implements Persistent_mq_handle API: Blocking receive: pops copy of message from queue into buffer; i...">receive()</a> but without the actual popping of a message.  <a href="classipc_1_1transport_1_1Bipc__mq__handle.html#a7e2d79b92673be3ddba30c6d57020125">More...</a><br /></td></tr>
<tr class="separator:a7e2d79b92673be3ddba30c6d57020125"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5d2035b92c80a1b2e27b9e238107f1b1"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classipc_1_1transport_1_1Bipc__mq__handle.html#a5d2035b92c80a1b2e27b9e238107f1b1">timed_wait_receivable</a> (<a class="el" href="namespaceipc_1_1util.html#ac66141280c3b7295a86b65209f31cc58">util::Fine_duration</a> timeout_from_now, <a class="el" href="namespaceipc.html#aa3192e586cc45d3e7c22463bf2760f89">Error_code</a> *err_code=0)</td></tr>
<tr class="memdesc:a5d2035b92c80a1b2e27b9e238107f1b1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Implements <a class="el" href="classipc_1_1transport_1_1Persistent__mq__handle.html" title="A documentation-only concept defining the behavior of an object representing a light-weight handle to...">Persistent_mq_handle</a> API: Like <a class="el" href="classipc_1_1transport_1_1Bipc__mq__handle.html#a67be05bc1749981e0863d18681d006ac" title="Implements Persistent_mq_handle API: Blocking timed receive: pops copy of message from queue into buf...">timed_receive()</a> but without the actual popping of a message.  <a href="classipc_1_1transport_1_1Bipc__mq__handle.html#a5d2035b92c80a1b2e27b9e238107f1b1">More...</a><br /></td></tr>
<tr class="separator:a5d2035b92c80a1b2e27b9e238107f1b1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a40a750e20cb4696cdb7dc6cdddc78b1a"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classipc_1_1transport_1_1Bipc__mq__handle.html#a40a750e20cb4696cdb7dc6cdddc78b1a">interrupt_sends</a> ()</td></tr>
<tr class="memdesc:a40a750e20cb4696cdb7dc6cdddc78b1a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Implements <a class="el" href="classipc_1_1transport_1_1Persistent__mq__handle.html" title="A documentation-only concept defining the behavior of an object representing a light-weight handle to...">Persistent_mq_handle</a> API: Turn on preemptive/concurrent interruption of blocking-sends and sendable-waits/polls.  <a href="classipc_1_1transport_1_1Bipc__mq__handle.html#a40a750e20cb4696cdb7dc6cdddc78b1a">More...</a><br /></td></tr>
<tr class="separator:a40a750e20cb4696cdb7dc6cdddc78b1a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7993a816c819b51af70d5ab775d41f8f"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classipc_1_1transport_1_1Bipc__mq__handle.html#a7993a816c819b51af70d5ab775d41f8f">allow_sends</a> ()</td></tr>
<tr class="memdesc:a7993a816c819b51af70d5ab775d41f8f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Implements <a class="el" href="classipc_1_1transport_1_1Persistent__mq__handle.html" title="A documentation-only concept defining the behavior of an object representing a light-weight handle to...">Persistent_mq_handle</a> API: Turn off preemptive/concurrent interruption of blocking-sends and sendable-waits/polls.  <a href="classipc_1_1transport_1_1Bipc__mq__handle.html#a7993a816c819b51af70d5ab775d41f8f">More...</a><br /></td></tr>
<tr class="separator:a7993a816c819b51af70d5ab775d41f8f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a84db01ec0b3dadaa7368df4fad8f8529"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classipc_1_1transport_1_1Bipc__mq__handle.html#a84db01ec0b3dadaa7368df4fad8f8529">interrupt_receives</a> ()</td></tr>
<tr class="memdesc:a84db01ec0b3dadaa7368df4fad8f8529"><td class="mdescLeft">&#160;</td><td class="mdescRight">Implements <a class="el" href="classipc_1_1transport_1_1Persistent__mq__handle.html" title="A documentation-only concept defining the behavior of an object representing a light-weight handle to...">Persistent_mq_handle</a> API: Turn on preemptive/concurrent interruption of blocking-receives and receivable-waits/polls.  <a href="classipc_1_1transport_1_1Bipc__mq__handle.html#a84db01ec0b3dadaa7368df4fad8f8529">More...</a><br /></td></tr>
<tr class="separator:a84db01ec0b3dadaa7368df4fad8f8529"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a02e3582a466ed25128d35d3c767259cf"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classipc_1_1transport_1_1Bipc__mq__handle.html#a02e3582a466ed25128d35d3c767259cf">allow_receives</a> ()</td></tr>
<tr class="memdesc:a02e3582a466ed25128d35d3c767259cf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Implements <a class="el" href="classipc_1_1transport_1_1Persistent__mq__handle.html" title="A documentation-only concept defining the behavior of an object representing a light-weight handle to...">Persistent_mq_handle</a> API: Turn off preemptive/concurrent interruption of blocking-receives and receivable-waits/polls.  <a href="classipc_1_1transport_1_1Bipc__mq__handle.html#a02e3582a466ed25128d35d3c767259cf">More...</a><br /></td></tr>
<tr class="separator:a02e3582a466ed25128d35d3c767259cf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7263ed9ec4f8ed534c0f7907b7accde9"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="namespaceipc_1_1transport.html#a33de1c256addb3964b839dc2dd407d24">Shared_name</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classipc_1_1transport_1_1Bipc__mq__handle.html#a7263ed9ec4f8ed534c0f7907b7accde9">absolute_name</a> () const</td></tr>
<tr class="memdesc:a7263ed9ec4f8ed534c0f7907b7accde9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Implements <a class="el" href="classipc_1_1transport_1_1Persistent__mq__handle.html" title="A documentation-only concept defining the behavior of an object representing a light-weight handle to...">Persistent_mq_handle</a> API: Returns name equal to <code>absolute_name</code> passed to ctor.  <a href="classipc_1_1transport_1_1Bipc__mq__handle.html#a7263ed9ec4f8ed534c0f7907b7accde9">More...</a><br /></td></tr>
<tr class="separator:a7263ed9ec4f8ed534c0f7907b7accde9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad8ef88d8e0a59b770c9d15d008b52a4b"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classipc_1_1transport_1_1Bipc__mq__handle.html#ad8ef88d8e0a59b770c9d15d008b52a4b">max_msg_size</a> () const</td></tr>
<tr class="memdesc:ad8ef88d8e0a59b770c9d15d008b52a4b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Implements <a class="el" href="classipc_1_1transport_1_1Persistent__mq__handle.html" title="A documentation-only concept defining the behavior of an object representing a light-weight handle to...">Persistent_mq_handle</a> API: Returns the max message size of the underlying queue.  <a href="classipc_1_1transport_1_1Bipc__mq__handle.html#ad8ef88d8e0a59b770c9d15d008b52a4b">More...</a><br /></td></tr>
<tr class="separator:ad8ef88d8e0a59b770c9d15d008b52a4b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9f3318676f5e687f791088484d1bbef8"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classipc_1_1transport_1_1Bipc__mq__handle.html#a9f3318676f5e687f791088484d1bbef8">max_n_msgs</a> () const</td></tr>
<tr class="memdesc:a9f3318676f5e687f791088484d1bbef8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Implements <a class="el" href="classipc_1_1transport_1_1Persistent__mq__handle.html" title="A documentation-only concept defining the behavior of an object representing a light-weight handle to...">Persistent_mq_handle</a> API: Returns the max message count of the underlying queue.  <a href="classipc_1_1transport_1_1Bipc__mq__handle.html#a9f3318676f5e687f791088484d1bbef8">More...</a><br /></td></tr>
<tr class="separator:a9f3318676f5e687f791088484d1bbef8"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-static-methods" name="pub-static-methods"></a>
Static Public Member Functions</h2></td></tr>
<tr class="memitem:a982a83871b89211f073dfafa49bb4c27"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classipc_1_1transport_1_1Bipc__mq__handle.html#a982a83871b89211f073dfafa49bb4c27">remove_persistent</a> (flow::log::Logger *logger_ptr, const <a class="el" href="namespaceipc_1_1transport.html#a33de1c256addb3964b839dc2dd407d24">Shared_name</a> &amp;<a class="el" href="classipc_1_1transport_1_1Bipc__mq__handle.html#a7263ed9ec4f8ed534c0f7907b7accde9">absolute_name</a>, <a class="el" href="namespaceipc.html#aa3192e586cc45d3e7c22463bf2760f89">Error_code</a> *err_code=0)</td></tr>
<tr class="memdesc:a982a83871b89211f073dfafa49bb4c27"><td class="mdescLeft">&#160;</td><td class="mdescRight">Implements <a class="el" href="classipc_1_1transport_1_1Persistent__mq__handle.html" title="A documentation-only concept defining the behavior of an object representing a light-weight handle to...">Persistent_mq_handle</a> API: Removes the named persistent MQ.  <a href="classipc_1_1transport_1_1Bipc__mq__handle.html#a982a83871b89211f073dfafa49bb4c27">More...</a><br /></td></tr>
<tr class="separator:a982a83871b89211f073dfafa49bb4c27"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3d6fa3398edb4db10a933f9731924255"><td class="memTemplParams" colspan="2">template&lt;typename Handle_name_func &gt; </td></tr>
<tr class="memitem:a3d6fa3398edb4db10a933f9731924255"><td class="memTemplItemLeft" align="right" valign="top">static void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classipc_1_1transport_1_1Bipc__mq__handle.html#a3d6fa3398edb4db10a933f9731924255">for_each_persistent</a> (const Handle_name_func &amp;handle_name_func)</td></tr>
<tr class="memdesc:a3d6fa3398edb4db10a933f9731924255"><td class="mdescLeft">&#160;</td><td class="mdescRight">Implements <a class="el" href="classipc_1_1transport_1_1Persistent__mq__handle.html" title="A documentation-only concept defining the behavior of an object representing a light-weight handle to...">Persistent_mq_handle</a> API.  <a href="classipc_1_1transport_1_1Bipc__mq__handle.html#a3d6fa3398edb4db10a933f9731924255">More...</a><br /></td></tr>
<tr class="separator:a3d6fa3398edb4db10a933f9731924255"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-static-attribs" name="pub-static-attribs"></a>
Static Public Attributes</h2></td></tr>
<tr class="memitem:a76ef929399fb9a7b4cec9ebb4d2ad6f0"><td class="memItemLeft" align="right" valign="top"><a id="a76ef929399fb9a7b4cec9ebb4d2ad6f0" name="a76ef929399fb9a7b4cec9ebb4d2ad6f0"></a>
static const <a class="el" href="namespaceipc_1_1transport.html#a33de1c256addb3964b839dc2dd407d24">Shared_name</a>&#160;</td><td class="memItemRight" valign="bottom"><b>S_RESOURCE_TYPE_ID</b> = <a class="el" href="classipc_1_1util_1_1Shared__name.html#a48f20b7b54490aa10dc64081d34c55b2">Shared_name::ct</a>(&quot;bipcQ&quot;)</td></tr>
<tr class="memdesc:a76ef929399fb9a7b4cec9ebb4d2ad6f0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Implements concept API. <br /></td></tr>
<tr class="separator:a76ef929399fb9a7b4cec9ebb4d2ad6f0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7507ac097eb580a44622429c69af2f1d"><td class="memItemLeft" align="right" valign="top"><a id="a7507ac097eb580a44622429c69af2f1d" name="a7507ac097eb580a44622429c69af2f1d"></a>
static constexpr bool&#160;</td><td class="memItemRight" valign="bottom"><b>S_HAS_NATIVE_HANDLE</b> = false</td></tr>
<tr class="memdesc:a7507ac097eb580a44622429c69af2f1d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Implements concept API. <br /></td></tr>
<tr class="separator:a7507ac097eb580a44622429c69af2f1d"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="related" name="related"></a>
Related Functions</h2></td></tr>
<tr><td class="ititle" colspan="2"><p >(Note that these are not member functions.) </p>
</td></tr>
<tr class="memitem:a61c80019823537694f925275dccb4f3f"><td class="memItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classipc_1_1transport_1_1Bipc__mq__handle.html#a61c80019823537694f925275dccb4f3f">operator&lt;&lt;</a> (std::ostream &amp;os, const <a class="el" href="classipc_1_1transport_1_1Bipc__mq__handle.html">Bipc_mq_handle</a> &amp;val)</td></tr>
<tr class="memdesc:a61c80019823537694f925275dccb4f3f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Prints string representation of the given <a class="el" href="classipc_1_1transport_1_1Bipc__mq__handle.html" title="Implements the Persistent_mq_handle concept by thinly wrapping bipc::message_queue,...">Bipc_mq_handle</a> to the given <code>ostream</code>.  <a href="classipc_1_1transport_1_1Bipc__mq__handle.html#a61c80019823537694f925275dccb4f3f">More...</a><br /></td></tr>
<tr class="separator:a61c80019823537694f925275dccb4f3f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af0610dff5efd418a8ff393f0ad9dd5c2"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classipc_1_1transport_1_1Bipc__mq__handle.html#af0610dff5efd418a8ff393f0ad9dd5c2">swap</a> (<a class="el" href="classipc_1_1transport_1_1Bipc__mq__handle.html">Bipc_mq_handle</a> &amp;val1, <a class="el" href="classipc_1_1transport_1_1Bipc__mq__handle.html">Bipc_mq_handle</a> &amp;val2)</td></tr>
<tr class="memdesc:af0610dff5efd418a8ff393f0ad9dd5c2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Implements <a class="el" href="classipc_1_1transport_1_1Persistent__mq__handle.html" title="A documentation-only concept defining the behavior of an object representing a light-weight handle to...">Persistent_mq_handle</a> related concept: Swaps two objects.  <a href="classipc_1_1transport_1_1Bipc__mq__handle.html#af0610dff5efd418a8ff393f0ad9dd5c2">More...</a><br /></td></tr>
<tr class="separator:af0610dff5efd418a8ff393f0ad9dd5c2"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p >Implements the <a class="el" href="classipc_1_1transport_1_1Persistent__mq__handle.html" title="A documentation-only concept defining the behavior of an object representing a light-weight handle to...">Persistent_mq_handle</a> concept by thinly wrapping <code>bipc::message_queue</code>, which is boost.interprocess's persistent message queue API. </p>
<p >Internally <code>bipc::message_queue</code> maintains a boost.interprocess (classic) SHM pool which itself is a portable wrapper around a standard POSIX shared memory object.</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classipc_1_1transport_1_1Persistent__mq__handle.html" title="A documentation-only concept defining the behavior of an object representing a light-weight handle to...">Persistent_mq_handle</a>: implemented concept. Its doc header provides plenty of background for the present concrete class, since essentially that concept was inspired by <code>bipc::message_queue</code> in the first place. Therefore there is essentially no added documentation needed here.</dd></dl>
<p>Reminder: This is available publicly in case it is useful; but it is more likely one would use a Blob_stream which provides a far more convenient boost.asio-like async-capable API. It uses class(es) like this one in its impl. </p>
</div><h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="a11941ad5d1a6d0cef286a69ed99bb2d0" name="a11941ad5d1a6d0cef286a69ed99bb2d0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a11941ad5d1a6d0cef286a69ed99bb2d0">&#9670;&nbsp;</a></span>Bipc_mq_handle() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">ipc::transport::Bipc_mq_handle::Bipc_mq_handle </td>
          <td>(</td>
          <td class="paramtype">flow::log::Logger *&#160;</td>
          <td class="paramname"><em>logger_ptr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespaceipc_1_1transport.html#a33de1c256addb3964b839dc2dd407d24">Shared_name</a> &amp;&#160;</td>
          <td class="paramname"><em>absolute_name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceipc_1_1util.html#a9d84c2bab504e6de32b20c77ca9723a2">util::Create_only</a>&#160;</td>
          <td class="paramname"><em>mode_tag</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>max_n_msg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>max_msg_sz</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespaceipc_1_1util.html#a1b398ae730d1e6040687cb2397115152">util::Permissions</a> &amp;&#160;</td>
          <td class="paramname"><em>perms</em> = <code><a class="el" href="namespaceipc_1_1util.html#a1b398ae730d1e6040687cb2397115152">util::Permissions</a>()</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceipc.html#aa3192e586cc45d3e7c22463bf2760f89">Error_code</a> *&#160;</td>
          <td class="paramname"><em>err_code</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">explicit</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Implements <a class="el" href="classipc_1_1transport_1_1Persistent__mq__handle.html" title="A documentation-only concept defining the behavior of an object representing a light-weight handle to...">Persistent_mq_handle</a> API: Construct handle to non-existing named MQ, creating it first. </p>
<p >If it already exists, it is an error.</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classipc_1_1transport_1_1Persistent__mq__handle.html#a22abfaa801a9e2f974a8cd179544d19a" title="Construct null handle, suitable only for being subsequently moved-to or destroyed.">Persistent_mq_handle::Persistent_mq_handle()</a>: implemented concept.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">logger_ptr</td><td>See above. </td></tr>
    <tr><td class="paramname">absolute_name</td><td>See above. </td></tr>
    <tr><td class="paramname">mode_tag</td><td>See above. </td></tr>
    <tr><td class="paramname">perms</td><td>See above. Reminder: Suggest the use of <a class="el" href="namespaceipc_1_1util.html#abda2ce5bcdbc26ca63d667b87818439c" title="Maps general Permissions_level specifier to low-level Permissions value, when the underlying resource...">util::shared_resource_permissions()</a> to translate from one of a small handful of levels of access; these apply almost always in practice. </td></tr>
    <tr><td class="paramname">max_n_msg</td><td>See above. </td></tr>
    <tr><td class="paramname">max_msg_sz</td><td>See above. </td></tr>
    <tr><td class="paramname">err_code</td><td>See above. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a8fc57150cd7b7223b5f75b187bc7406f" name="a8fc57150cd7b7223b5f75b187bc7406f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8fc57150cd7b7223b5f75b187bc7406f">&#9670;&nbsp;</a></span>Bipc_mq_handle() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">ipc::transport::Bipc_mq_handle::Bipc_mq_handle </td>
          <td>(</td>
          <td class="paramtype">flow::log::Logger *&#160;</td>
          <td class="paramname"><em>logger_ptr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespaceipc_1_1transport.html#a33de1c256addb3964b839dc2dd407d24">Shared_name</a> &amp;&#160;</td>
          <td class="paramname"><em>absolute_name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceipc_1_1util.html#a9571de958538d7a4a8649bbfecfac0b9">util::Open_or_create</a>&#160;</td>
          <td class="paramname"><em>mode_tag</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>max_n_msg_on_create</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>max_msg_sz_on_create</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespaceipc_1_1util.html#a1b398ae730d1e6040687cb2397115152">util::Permissions</a> &amp;&#160;</td>
          <td class="paramname"><em>perms_on_create</em> = <code><a class="el" href="namespaceipc_1_1util.html#a1b398ae730d1e6040687cb2397115152">util::Permissions</a>()</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceipc.html#aa3192e586cc45d3e7c22463bf2760f89">Error_code</a> *&#160;</td>
          <td class="paramname"><em>err_code</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">explicit</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Implements <a class="el" href="classipc_1_1transport_1_1Persistent__mq__handle.html" title="A documentation-only concept defining the behavior of an object representing a light-weight handle to...">Persistent_mq_handle</a> API: Construct handle to existing named MQ, or else if it does not exist creates it first and opens it (atomically). </p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classipc_1_1transport_1_1Persistent__mq__handle.html#a22abfaa801a9e2f974a8cd179544d19a" title="Construct null handle, suitable only for being subsequently moved-to or destroyed.">Persistent_mq_handle::Persistent_mq_handle()</a>: implemented concept.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">logger_ptr</td><td>See above. </td></tr>
    <tr><td class="paramname">absolute_name</td><td>See above. </td></tr>
    <tr><td class="paramname">mode_tag</td><td>See above. </td></tr>
    <tr><td class="paramname">perms_on_create</td><td>See above. Reminder: Suggest the use of <a class="el" href="namespaceipc_1_1util.html#abda2ce5bcdbc26ca63d667b87818439c" title="Maps general Permissions_level specifier to low-level Permissions value, when the underlying resource...">util::shared_resource_permissions()</a> to translate from one of a small handful of levels of access; these apply almost always in practice. </td></tr>
    <tr><td class="paramname">max_n_msg_on_create</td><td>See above. </td></tr>
    <tr><td class="paramname">max_msg_sz_on_create</td><td>See above. </td></tr>
    <tr><td class="paramname">err_code</td><td>See above. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a65748d60779863c62808478340bfb142" name="a65748d60779863c62808478340bfb142"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a65748d60779863c62808478340bfb142">&#9670;&nbsp;</a></span>Bipc_mq_handle() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">ipc::transport::Bipc_mq_handle::Bipc_mq_handle </td>
          <td>(</td>
          <td class="paramtype">flow::log::Logger *&#160;</td>
          <td class="paramname"><em>logger_ptr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespaceipc_1_1transport.html#a33de1c256addb3964b839dc2dd407d24">Shared_name</a> &amp;&#160;</td>
          <td class="paramname"><em>absolute_name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceipc_1_1util.html#a3e03491b5b2b5fac26551a220946d6e5">util::Open_only</a>&#160;</td>
          <td class="paramname"><em>mode_tag</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceipc.html#aa3192e586cc45d3e7c22463bf2760f89">Error_code</a> *&#160;</td>
          <td class="paramname"><em>err_code</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">explicit</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Implements <a class="el" href="classipc_1_1transport_1_1Persistent__mq__handle.html" title="A documentation-only concept defining the behavior of an object representing a light-weight handle to...">Persistent_mq_handle</a> API: Construct handle to existing named MQ. </p>
<p >If it does not exist, it is an error.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">logger_ptr</td><td>See above. </td></tr>
    <tr><td class="paramname">absolute_name</td><td>See above. </td></tr>
    <tr><td class="paramname">mode_tag</td><td>See above. </td></tr>
    <tr><td class="paramname">err_code</td><td>See above. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a9734d457200dbaa9234539f666060403" name="a9734d457200dbaa9234539f666060403"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9734d457200dbaa9234539f666060403">&#9670;&nbsp;</a></span>Bipc_mq_handle() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">ipc::transport::Bipc_mq_handle::Bipc_mq_handle </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classipc_1_1transport_1_1Bipc__mq__handle.html">Bipc_mq_handle</a> &amp;&amp;&#160;</td>
          <td class="paramname"><em>src</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">default</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Implements <a class="el" href="classipc_1_1transport_1_1Persistent__mq__handle.html" title="A documentation-only concept defining the behavior of an object representing a light-weight handle to...">Persistent_mq_handle</a> API: Constructs handle from the source handle while making the latter as-if default-cted. </p>
<p >Reminder, informally: This is a light-weight op.</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classipc_1_1transport_1_1Persistent__mq__handle.html#a22abfaa801a9e2f974a8cd179544d19a" title="Construct null handle, suitable only for being subsequently moved-to or destroyed.">Persistent_mq_handle::Persistent_mq_handle()</a>: implemented concept.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">src</td><td>See above. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="abe6cb3e8131f26c250c4b623d3fa2afe" name="abe6cb3e8131f26c250c4b623d3fa2afe"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abe6cb3e8131f26c250c4b623d3fa2afe">&#9670;&nbsp;</a></span>~Bipc_mq_handle()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ipc::transport::Bipc_mq_handle::~Bipc_mq_handle </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Implements <a class="el" href="classipc_1_1transport_1_1Persistent__mq__handle.html" title="A documentation-only concept defining the behavior of an object representing a light-weight handle to...">Persistent_mq_handle</a> API: Destroys this handle (or no-op if no handle was successfully constructed, or if it's a moved-from or default-cted handle). </p>
<p >Reminder: The underlying MQ (if any) is <em>not</em> destroyed and can be attached-to by another handle.</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classipc_1_1transport_1_1Persistent__mq__handle.html#a1fbb936f8f80fedcb1227794ef0a451b" title="Destroys this handle (or no-op if no handle was successfully constructed, or if it&#39;s a moved-from or ...">Persistent_mq_handle::~Persistent_mq_handle()</a>: implemented concept. </dd></dl>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="a7263ed9ec4f8ed534c0f7907b7accde9" name="a7263ed9ec4f8ed534c0f7907b7accde9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7263ed9ec4f8ed534c0f7907b7accde9">&#9670;&nbsp;</a></span>absolute_name()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="namespaceipc_1_1transport.html#a33de1c256addb3964b839dc2dd407d24">Shared_name</a> &amp; ipc::transport::Bipc_mq_handle::absolute_name </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Implements <a class="el" href="classipc_1_1transport_1_1Persistent__mq__handle.html" title="A documentation-only concept defining the behavior of an object representing a light-weight handle to...">Persistent_mq_handle</a> API: Returns name equal to <code>absolute_name</code> passed to ctor. </p>
<dl class="section return"><dt>Returns</dt><dd>See above. </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classipc_1_1transport_1_1Persistent__mq__handle.html#a5ef74ca74a9d985710af974fd6518940" title="Returns name equal to absolute_name passed to ctor.">Persistent_mq_handle::absolute_name()</a>: implemented concept. </dd></dl>

</div>
</div>
<a id="a02e3582a466ed25128d35d3c767259cf" name="a02e3582a466ed25128d35d3c767259cf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a02e3582a466ed25128d35d3c767259cf">&#9670;&nbsp;</a></span>allow_receives()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool ipc::transport::Bipc_mq_handle::allow_receives </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Implements <a class="el" href="classipc_1_1transport_1_1Persistent__mq__handle.html" title="A documentation-only concept defining the behavior of an object representing a light-weight handle to...">Persistent_mq_handle</a> API: Turn off preemptive/concurrent interruption of blocking-receives and receivable-waits/polls. </p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classipc_1_1transport_1_1Persistent__mq__handle.html#aaedc972e2ce207875a3e7262f9064b65" title="Disables mode enabled by interrupt_receives().">Persistent_mq_handle::allow_receives()</a>: implemented concept.</dd></dl>
<h3>INFO+ logging</h3>
<p >WARNING on duplicate use, INFO otherwise.</p>
<dl class="section return"><dt>Returns</dt><dd>See above. </dd></dl>

</div>
</div>
<a id="a7993a816c819b51af70d5ab775d41f8f" name="a7993a816c819b51af70d5ab775d41f8f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7993a816c819b51af70d5ab775d41f8f">&#9670;&nbsp;</a></span>allow_sends()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool ipc::transport::Bipc_mq_handle::allow_sends </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Implements <a class="el" href="classipc_1_1transport_1_1Persistent__mq__handle.html" title="A documentation-only concept defining the behavior of an object representing a light-weight handle to...">Persistent_mq_handle</a> API: Turn off preemptive/concurrent interruption of blocking-sends and sendable-waits/polls. </p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classipc_1_1transport_1_1Persistent__mq__handle.html#af43b22d89c5a228c2a72c321c2e24545" title="Disables mode enabled by interrupt_sends().">Persistent_mq_handle::allow_sends()</a>: implemented concept.</dd></dl>
<h3>INFO+ logging</h3>
<p >WARNING on duplicate use, INFO otherwise.</p>
<dl class="section return"><dt>Returns</dt><dd>See above. </dd></dl>

</div>
</div>
<a id="a3d6fa3398edb4db10a933f9731924255" name="a3d6fa3398edb4db10a933f9731924255"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3d6fa3398edb4db10a933f9731924255">&#9670;&nbsp;</a></span>for_each_persistent()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Handle_name_func &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void ipc::transport::Bipc_mq_handle::for_each_persistent </td>
          <td>(</td>
          <td class="paramtype">const Handle_name_func &amp;&#160;</td>
          <td class="paramname"><em>handle_name_func</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Implements <a class="el" href="classipc_1_1transport_1_1Persistent__mq__handle.html" title="A documentation-only concept defining the behavior of an object representing a light-weight handle to...">Persistent_mq_handle</a> API. </p>
<p >Impl note for exposition: we use the fact that, e.g., in Linux the POSIX MQ devices are listed in flat fashion in /dev/mqueue.</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classipc_1_1transport_1_1Persistent__mq__handle.html#ac14dd419cdbc97b6630900268f8b7dd2" title="Lists all named persistent MQs currently persisting, invoking the given handler synchronously on each...">Persistent_mq_handle::for_each_persistent()</a>: implemented concept.</dd></dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Handle_name_func</td><td>See above. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">handle_name_func</td><td>See above. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a84db01ec0b3dadaa7368df4fad8f8529" name="a84db01ec0b3dadaa7368df4fad8f8529"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a84db01ec0b3dadaa7368df4fad8f8529">&#9670;&nbsp;</a></span>interrupt_receives()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool ipc::transport::Bipc_mq_handle::interrupt_receives </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Implements <a class="el" href="classipc_1_1transport_1_1Persistent__mq__handle.html" title="A documentation-only concept defining the behavior of an object representing a light-weight handle to...">Persistent_mq_handle</a> API: Turn on preemptive/concurrent interruption of blocking-receives and receivable-waits/polls. </p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classipc_1_1transport_1_1Persistent__mq__handle.html#a206333d3eb619588d17812f8f49013a2" title="Enables receives-interrupted mode: is_receivable() (future calls), receive() (future or concurrent ca...">Persistent_mq_handle::interrupt_receives()</a>: implemented concept.</dd></dl>
<h3>INFO+ logging</h3>
<p >WARNING on duplicate use, INFO otherwise.</p>
<dl class="section return"><dt>Returns</dt><dd>See above. </dd></dl>

</div>
</div>
<a id="a40a750e20cb4696cdb7dc6cdddc78b1a" name="a40a750e20cb4696cdb7dc6cdddc78b1a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a40a750e20cb4696cdb7dc6cdddc78b1a">&#9670;&nbsp;</a></span>interrupt_sends()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool ipc::transport::Bipc_mq_handle::interrupt_sends </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Implements <a class="el" href="classipc_1_1transport_1_1Persistent__mq__handle.html" title="A documentation-only concept defining the behavior of an object representing a light-weight handle to...">Persistent_mq_handle</a> API: Turn on preemptive/concurrent interruption of blocking-sends and sendable-waits/polls. </p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classipc_1_1transport_1_1Persistent__mq__handle.html#af7a883553df39b16047b49942bd734c0" title="Enables sends-interrupted mode: is_sendable() (future calls), send() (future or concurrent calls),...">Persistent_mq_handle::interrupt_sends()</a>: implemented concept.</dd></dl>
<h3>INFO+ logging</h3>
<p >WARNING on duplicate use, INFO otherwise.</p>
<dl class="section return"><dt>Returns</dt><dd>See above. </dd></dl>

</div>
</div>
<a id="adade0e6deab4db302be7343d27568e8a" name="adade0e6deab4db302be7343d27568e8a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adade0e6deab4db302be7343d27568e8a">&#9670;&nbsp;</a></span>is_receivable()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool ipc::transport::Bipc_mq_handle::is_receivable </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespaceipc.html#aa3192e586cc45d3e7c22463bf2760f89">Error_code</a> *&#160;</td>
          <td class="paramname"><em>err_code</em> = <code>0</code></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Implements <a class="el" href="classipc_1_1transport_1_1Persistent__mq__handle.html" title="A documentation-only concept defining the behavior of an object representing a light-weight handle to...">Persistent_mq_handle</a> API: Like <a class="el" href="classipc_1_1transport_1_1Bipc__mq__handle.html#a7a974f3cfbb095f0b67e773f4f2fb1a9" title="Implements Persistent_mq_handle API: Non-blocking receive: pops copy of message from queue into buffe...">try_receive()</a> but without the actual popping of a message. </p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classipc_1_1transport_1_1Persistent__mq__handle.html#acdf4279219020020b1d8b3ff8a80cbe2" title="Equivalent to try_receive() except stops short of reading anything, with true result indicating that ...">Persistent_mq_handle::is_receivable()</a>: implemented concept.</dd></dl>
<h3>INFO+ logging</h3>
<p >WARNING on error. (You may use the <code>flow::log::Config::this_thread_verbosity_override_auto()</code> to temporarily, in that thread only, disable/reduce logging. This is quite easy and performant.)</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">err_code</td><td>See above. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>See above. </dd></dl>

</div>
</div>
<a id="afa693699d1678040f6d22efbfaf657fe" name="afa693699d1678040f6d22efbfaf657fe"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afa693699d1678040f6d22efbfaf657fe">&#9670;&nbsp;</a></span>is_sendable()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool ipc::transport::Bipc_mq_handle::is_sendable </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespaceipc.html#aa3192e586cc45d3e7c22463bf2760f89">Error_code</a> *&#160;</td>
          <td class="paramname"><em>err_code</em> = <code>0</code></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Implements <a class="el" href="classipc_1_1transport_1_1Persistent__mq__handle.html" title="A documentation-only concept defining the behavior of an object representing a light-weight handle to...">Persistent_mq_handle</a> API: Like <a class="el" href="classipc_1_1transport_1_1Bipc__mq__handle.html#a4c3406cf8759017342ed295fcc833704" title="Implements Persistent_mq_handle API: Non-blocking send: pushes copy of message to queue and returns t...">try_send()</a> but without the actual pushing of a message. </p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classipc_1_1transport_1_1Persistent__mq__handle.html#ab95e3d32a7ad3fa3630ba54442d8f2ee" title="Equivalent to try_send() except stops short of writing anything, with true result indicating that try...">Persistent_mq_handle::is_sendable()</a>: implemented concept.</dd></dl>
<h3>INFO+ logging</h3>
<p >WARNING on error. (You may use the <code>flow::log::Config::this_thread_verbosity_override_auto()</code> to temporarily, in that thread only, disable/reduce logging. This is quite easy and performant.)</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">err_code</td><td>See above. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>See above. </dd></dl>

</div>
</div>
<a id="ad8ef88d8e0a59b770c9d15d008b52a4b" name="ad8ef88d8e0a59b770c9d15d008b52a4b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad8ef88d8e0a59b770c9d15d008b52a4b">&#9670;&nbsp;</a></span>max_msg_size()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t ipc::transport::Bipc_mq_handle::max_msg_size </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Implements <a class="el" href="classipc_1_1transport_1_1Persistent__mq__handle.html" title="A documentation-only concept defining the behavior of an object representing a light-weight handle to...">Persistent_mq_handle</a> API: Returns the max message size of the underlying queue. </p>
<p >Reminder: This is not required to match was was passed to <code>Create_only</code> or <code>Open_or_create</code> ctor.</p>
<dl class="section return"><dt>Returns</dt><dd>See above. </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classipc_1_1transport_1_1Persistent__mq__handle.html#ae2efe92707c53c46bc70b84f96bda217" title="Returns the max message size of the underlying queue.">Persistent_mq_handle::max_msg_size()</a>: implemented concept. </dd></dl>

</div>
</div>
<a id="a9f3318676f5e687f791088484d1bbef8" name="a9f3318676f5e687f791088484d1bbef8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9f3318676f5e687f791088484d1bbef8">&#9670;&nbsp;</a></span>max_n_msgs()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t ipc::transport::Bipc_mq_handle::max_n_msgs </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Implements <a class="el" href="classipc_1_1transport_1_1Persistent__mq__handle.html" title="A documentation-only concept defining the behavior of an object representing a light-weight handle to...">Persistent_mq_handle</a> API: Returns the max message count of the underlying queue. </p>
<p >Reminder: This is not required to match was was passed to <code>Create_only</code> or <code>Open_or_create</code> ctor.</p>
<dl class="section return"><dt>Returns</dt><dd>See above. </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classipc_1_1transport_1_1Persistent__mq__handle.html#a22575a5750d322ccf87a923a3d662756" title="Returns the max message count of the underlying queue.">Persistent_mq_handle::max_n_msgs()</a>: implemented concept. </dd></dl>

</div>
</div>
<a id="a1a94d32b8a1bc93d19b19a0da35cd062" name="a1a94d32b8a1bc93d19b19a0da35cd062"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1a94d32b8a1bc93d19b19a0da35cd062">&#9670;&nbsp;</a></span>operator=()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classipc_1_1transport_1_1Bipc__mq__handle.html">Bipc_mq_handle</a> &amp; ipc::transport::Bipc_mq_handle::operator= </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classipc_1_1transport_1_1Bipc__mq__handle.html">Bipc_mq_handle</a> &amp;&amp;&#160;</td>
          <td class="paramname"><em>src</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">default</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Implements <a class="el" href="classipc_1_1transport_1_1Persistent__mq__handle.html" title="A documentation-only concept defining the behavior of an object representing a light-weight handle to...">Persistent_mq_handle</a> API: Replaces handle with the source handle while making the latter invalid as-if default-cted. </p>
<p >Reminder, informally: this is a light-weight op.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">src</td><td>See above. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>*this</code>. </dd></dl>

</div>
</div>
<a id="a9d1aaf82f6396f4d975a77a70433698d" name="a9d1aaf82f6396f4d975a77a70433698d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9d1aaf82f6396f4d975a77a70433698d">&#9670;&nbsp;</a></span>receive()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ipc::transport::Bipc_mq_handle::receive </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespaceipc_1_1util.html#a6cb62ae434900f3a8915b33ec5d61a96">util::Blob_mutable</a> *&#160;</td>
          <td class="paramname"><em>blob</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceipc.html#aa3192e586cc45d3e7c22463bf2760f89">Error_code</a> *&#160;</td>
          <td class="paramname"><em>err_code</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Implements <a class="el" href="classipc_1_1transport_1_1Persistent__mq__handle.html" title="A documentation-only concept defining the behavior of an object representing a light-weight handle to...">Persistent_mq_handle</a> API: Blocking receive: pops copy of message from queue into buffer; if queue is empty blocks until it is not. </p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classipc_1_1transport_1_1Persistent__mq__handle.html#ae1e6822d16d30dc57c95e3e051e5f8a8" title="Blocking receive: pops copy of message from queue into buffer; if queue is empty blocks until it is n...">Persistent_mq_handle::receive()</a>: implemented concept.</dd></dl>
<h3>INFO+ logging</h3>
<p >WARNING on error. (You may use the <code>flow::log::Config::this_thread_verbosity_override_auto()</code> to temporarily, in that thread only, disable/reduce logging. This is quite easy and performant.)</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">blob</td><td>See above. </td></tr>
    <tr><td class="paramname">err_code</td><td>See above. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a982a83871b89211f073dfafa49bb4c27" name="a982a83871b89211f073dfafa49bb4c27"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a982a83871b89211f073dfafa49bb4c27">&#9670;&nbsp;</a></span>remove_persistent()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void ipc::transport::Bipc_mq_handle::remove_persistent </td>
          <td>(</td>
          <td class="paramtype">flow::log::Logger *&#160;</td>
          <td class="paramname"><em>logger_ptr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespaceipc_1_1transport.html#a33de1c256addb3964b839dc2dd407d24">Shared_name</a> &amp;&#160;</td>
          <td class="paramname"><em>absolute_name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceipc.html#aa3192e586cc45d3e7c22463bf2760f89">Error_code</a> *&#160;</td>
          <td class="paramname"><em>err_code</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Implements <a class="el" href="classipc_1_1transport_1_1Persistent__mq__handle.html" title="A documentation-only concept defining the behavior of an object representing a light-weight handle to...">Persistent_mq_handle</a> API: Removes the named persistent MQ. </p>
<p >Reminder: name is removed immediately (if present &ndash; otherwise error), but underlying MQ continues to exist until all system-wide handles to it are closed.</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classipc_1_1transport_1_1Persistent__mq__handle.html#a2e8b8102fdbacc064d4759533a725f51" title="Removes the named persistent MQ.">Persistent_mq_handle::remove_persistent()</a>: implemented concept.</dd>
<dd>
Reminder: see also <code>util::remove_each_persistent_*()</code>.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">logger_ptr</td><td>See above. </td></tr>
    <tr><td class="paramname">absolute_name</td><td>See above. </td></tr>
    <tr><td class="paramname">err_code</td><td>See above. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a45e952a67d6568f6ef4834a3523a2ca4" name="a45e952a67d6568f6ef4834a3523a2ca4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a45e952a67d6568f6ef4834a3523a2ca4">&#9670;&nbsp;</a></span>send()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ipc::transport::Bipc_mq_handle::send </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespaceipc_1_1util.html#ae0be7edba7e30ffa3f8b742af621f2ab">util::Blob_const</a> &amp;&#160;</td>
          <td class="paramname"><em>blob</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceipc.html#aa3192e586cc45d3e7c22463bf2760f89">Error_code</a> *&#160;</td>
          <td class="paramname"><em>err_code</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Implements <a class="el" href="classipc_1_1transport_1_1Persistent__mq__handle.html" title="A documentation-only concept defining the behavior of an object representing a light-weight handle to...">Persistent_mq_handle</a> API: Blocking send: pushes copy of message to queue; if queue is full blocks until it is not. </p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classipc_1_1transport_1_1Persistent__mq__handle.html#a9d54e47b729eec9f72dee869326bfa8f" title="Blocking send: pushes copy of message to queue; if queue is full blocks until it is not.">Persistent_mq_handle::send()</a>: implemented concept.</dd></dl>
<h3>INFO+ logging</h3>
<p >WARNING on error. (You may use the <code>flow::log::Config::this_thread_verbosity_override_auto()</code> to temporarily, in that thread only, disable/reduce logging. This is quite easy and performant.)</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">blob</td><td>See above. </td></tr>
    <tr><td class="paramname">err_code</td><td>See above. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a67be05bc1749981e0863d18681d006ac" name="a67be05bc1749981e0863d18681d006ac"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a67be05bc1749981e0863d18681d006ac">&#9670;&nbsp;</a></span>timed_receive()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool ipc::transport::Bipc_mq_handle::timed_receive </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespaceipc_1_1util.html#a6cb62ae434900f3a8915b33ec5d61a96">util::Blob_mutable</a> *&#160;</td>
          <td class="paramname"><em>blob</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceipc_1_1util.html#ac66141280c3b7295a86b65209f31cc58">util::Fine_duration</a>&#160;</td>
          <td class="paramname"><em>timeout_from_now</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceipc.html#aa3192e586cc45d3e7c22463bf2760f89">Error_code</a> *&#160;</td>
          <td class="paramname"><em>err_code</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Implements <a class="el" href="classipc_1_1transport_1_1Persistent__mq__handle.html" title="A documentation-only concept defining the behavior of an object representing a light-weight handle to...">Persistent_mq_handle</a> API: Blocking timed receive: pops copy of message from queue into buffer; if queue is empty blocks until it is not, or the specified time passes, whichever happens first. </p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classipc_1_1transport_1_1Persistent__mq__handle.html#af547b6f1b1e51a7d6f6fbafc14c95f9d" title="Blocking timed receive: pops copy of message from queue into buffer; if queue is empty blocks until i...">Persistent_mq_handle::timed_receive()</a>: implemented concept.</dd></dl>
<h3>INFO+ logging</h3>
<p >WARNING on error or timed out. (You may use the <code>flow::log::Config::this_thread_verbosity_override_auto()</code> to temporarily, in that thread only, disable/reduce logging. This is quite easy and performant.)</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">blob</td><td>See above. </td></tr>
    <tr><td class="paramname">timeout_from_now</td><td>See above. </td></tr>
    <tr><td class="paramname">err_code</td><td>See above. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>See above. </dd></dl>

</div>
</div>
<a id="a8e486336f1dfffa1c397b725b95b175b" name="a8e486336f1dfffa1c397b725b95b175b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8e486336f1dfffa1c397b725b95b175b">&#9670;&nbsp;</a></span>timed_send()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool ipc::transport::Bipc_mq_handle::timed_send </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespaceipc_1_1util.html#ae0be7edba7e30ffa3f8b742af621f2ab">util::Blob_const</a> &amp;&#160;</td>
          <td class="paramname"><em>blob</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceipc_1_1util.html#ac66141280c3b7295a86b65209f31cc58">util::Fine_duration</a>&#160;</td>
          <td class="paramname"><em>timeout_from_now</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceipc.html#aa3192e586cc45d3e7c22463bf2760f89">Error_code</a> *&#160;</td>
          <td class="paramname"><em>err_code</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Implements <a class="el" href="classipc_1_1transport_1_1Persistent__mq__handle.html" title="A documentation-only concept defining the behavior of an object representing a light-weight handle to...">Persistent_mq_handle</a> API: Blocking timed send: pushes copy of message to queue; if queue is full blocks until it is not, or the specified time passes, whichever happens first. </p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classipc_1_1transport_1_1Persistent__mq__handle.html#ab4cba10b83df79acf76c64b0deb7f624" title="Blocking timed send: pushes copy of message to queue; if queue is full blocks until it is not,...">Persistent_mq_handle::timed_send()</a>: implemented concept.</dd></dl>
<h3>INFO+ logging</h3>
<p >WARNING on error. (You may use the <code>flow::log::Config::this_thread_verbosity_override_auto()</code> to temporarily, in that thread only, disable/reduce logging. This is quite easy and performant.)</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">blob</td><td>See above. </td></tr>
    <tr><td class="paramname">timeout_from_now</td><td>See above. </td></tr>
    <tr><td class="paramname">err_code</td><td>See above. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>See above. </dd></dl>

</div>
</div>
<a id="a5d2035b92c80a1b2e27b9e238107f1b1" name="a5d2035b92c80a1b2e27b9e238107f1b1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5d2035b92c80a1b2e27b9e238107f1b1">&#9670;&nbsp;</a></span>timed_wait_receivable()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool ipc::transport::Bipc_mq_handle::timed_wait_receivable </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespaceipc_1_1util.html#ac66141280c3b7295a86b65209f31cc58">util::Fine_duration</a>&#160;</td>
          <td class="paramname"><em>timeout_from_now</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceipc.html#aa3192e586cc45d3e7c22463bf2760f89">Error_code</a> *&#160;</td>
          <td class="paramname"><em>err_code</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Implements <a class="el" href="classipc_1_1transport_1_1Persistent__mq__handle.html" title="A documentation-only concept defining the behavior of an object representing a light-weight handle to...">Persistent_mq_handle</a> API: Like <a class="el" href="classipc_1_1transport_1_1Bipc__mq__handle.html#a67be05bc1749981e0863d18681d006ac" title="Implements Persistent_mq_handle API: Blocking timed receive: pops copy of message from queue into buf...">timed_receive()</a> but without the actual popping of a message. </p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classipc_1_1transport_1_1Persistent__mq__handle.html#ac4f13853e38ade577faabbf9ef0af74f" title="Equivalent to timed_receive() except stops short of reading anything, with true result indicating tha...">Persistent_mq_handle::timed_wait_receivable()</a>: implemented concept.</dd></dl>
<h3>INFO+ logging</h3>
<p >WARNING on error or timed out. (You may use the <code>flow::log::Config::this_thread_verbosity_override_auto()</code> to temporarily, in that thread only, disable/reduce logging. This is quite easy and performant.)</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">timeout_from_now</td><td>See above. </td></tr>
    <tr><td class="paramname">err_code</td><td>See above. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>See above. </dd></dl>

</div>
</div>
<a id="a164168adee0d188da11db8f17442dbef" name="a164168adee0d188da11db8f17442dbef"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a164168adee0d188da11db8f17442dbef">&#9670;&nbsp;</a></span>timed_wait_sendable()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool ipc::transport::Bipc_mq_handle::timed_wait_sendable </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespaceipc_1_1util.html#ac66141280c3b7295a86b65209f31cc58">util::Fine_duration</a>&#160;</td>
          <td class="paramname"><em>timeout_from_now</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceipc.html#aa3192e586cc45d3e7c22463bf2760f89">Error_code</a> *&#160;</td>
          <td class="paramname"><em>err_code</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Implements <a class="el" href="classipc_1_1transport_1_1Persistent__mq__handle.html" title="A documentation-only concept defining the behavior of an object representing a light-weight handle to...">Persistent_mq_handle</a> API: Like <a class="el" href="classipc_1_1transport_1_1Bipc__mq__handle.html#a8e486336f1dfffa1c397b725b95b175b" title="Implements Persistent_mq_handle API: Blocking timed send: pushes copy of message to queue; if queue i...">timed_send()</a> but without the actual pushing of a message. </p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classipc_1_1transport_1_1Persistent__mq__handle.html#aadfffb71ff2fec6508174fdf4b08327e" title="Equivalent to timed_send() except stops short of writing anything, with true result indicating that t...">Persistent_mq_handle::timed_wait_sendable()</a>: implemented concept.</dd></dl>
<h3>INFO+ logging</h3>
<p >WARNING on error. (You may use the <code>flow::log::Config::this_thread_verbosity_override_auto()</code> to temporarily, in that thread only, disable/reduce logging. This is quite easy and performant.)</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">timeout_from_now</td><td>See above. </td></tr>
    <tr><td class="paramname">err_code</td><td>See above. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>See above. </dd></dl>

</div>
</div>
<a id="a7a974f3cfbb095f0b67e773f4f2fb1a9" name="a7a974f3cfbb095f0b67e773f4f2fb1a9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7a974f3cfbb095f0b67e773f4f2fb1a9">&#9670;&nbsp;</a></span>try_receive()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool ipc::transport::Bipc_mq_handle::try_receive </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespaceipc_1_1util.html#a6cb62ae434900f3a8915b33ec5d61a96">util::Blob_mutable</a> *&#160;</td>
          <td class="paramname"><em>blob</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceipc.html#aa3192e586cc45d3e7c22463bf2760f89">Error_code</a> *&#160;</td>
          <td class="paramname"><em>err_code</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Implements <a class="el" href="classipc_1_1transport_1_1Persistent__mq__handle.html" title="A documentation-only concept defining the behavior of an object representing a light-weight handle to...">Persistent_mq_handle</a> API: Non-blocking receive: pops copy of message from queue into buffer and returns <code>true</code>; if queue is empty then no-op and returns <code>false</code>. </p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classipc_1_1transport_1_1Persistent__mq__handle.html#a84f802c77b0ce93d59e7ac78839f14cc" title="Non-blocking receive: pops copy of message from queue into buffer and returns true; if queue is empty...">Persistent_mq_handle::try_receive()</a>: implemented concept.</dd></dl>
<h3>INFO+ logging</h3>
<p >WARNING on error. (You may use the <code>flow::log::Config::this_thread_verbosity_override_auto()</code> to temporarily, in that thread only, disable/reduce logging. This is quite easy and performant.)</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">blob</td><td>See above. </td></tr>
    <tr><td class="paramname">err_code</td><td>See above. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>See above. </dd></dl>

</div>
</div>
<a id="a4c3406cf8759017342ed295fcc833704" name="a4c3406cf8759017342ed295fcc833704"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4c3406cf8759017342ed295fcc833704">&#9670;&nbsp;</a></span>try_send()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool ipc::transport::Bipc_mq_handle::try_send </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespaceipc_1_1util.html#ae0be7edba7e30ffa3f8b742af621f2ab">util::Blob_const</a> &amp;&#160;</td>
          <td class="paramname"><em>blob</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceipc.html#aa3192e586cc45d3e7c22463bf2760f89">Error_code</a> *&#160;</td>
          <td class="paramname"><em>err_code</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Implements <a class="el" href="classipc_1_1transport_1_1Persistent__mq__handle.html" title="A documentation-only concept defining the behavior of an object representing a light-weight handle to...">Persistent_mq_handle</a> API: Non-blocking send: pushes copy of message to queue and returns <code>true</code>; if queue is full then no-op and returns <code>false</code>. </p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classipc_1_1transport_1_1Persistent__mq__handle.html#ad9d38e0e16931dd96738d53b787533a1" title="Non-blocking send: pushes copy of message to queue and returns true; if queue is full then no-op and ...">Persistent_mq_handle::try_send()</a>: implemented concept.</dd></dl>
<h3>INFO+ logging</h3>
<p >WARNING on error. (You may use the <code>flow::log::Config::this_thread_verbosity_override_auto()</code> to temporarily, in that thread only, disable/reduce logging. This is quite easy and performant.)</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">blob</td><td>See above. </td></tr>
    <tr><td class="paramname">err_code</td><td>See above. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>See above. </dd></dl>

</div>
</div>
<a id="a7e2d79b92673be3ddba30c6d57020125" name="a7e2d79b92673be3ddba30c6d57020125"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7e2d79b92673be3ddba30c6d57020125">&#9670;&nbsp;</a></span>wait_receivable()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ipc::transport::Bipc_mq_handle::wait_receivable </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespaceipc.html#aa3192e586cc45d3e7c22463bf2760f89">Error_code</a> *&#160;</td>
          <td class="paramname"><em>err_code</em> = <code>0</code></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Implements <a class="el" href="classipc_1_1transport_1_1Persistent__mq__handle.html" title="A documentation-only concept defining the behavior of an object representing a light-weight handle to...">Persistent_mq_handle</a> API: Like <a class="el" href="classipc_1_1transport_1_1Bipc__mq__handle.html#a9d1aaf82f6396f4d975a77a70433698d" title="Implements Persistent_mq_handle API: Blocking receive: pops copy of message from queue into buffer; i...">receive()</a> but without the actual popping of a message. </p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classipc_1_1transport_1_1Persistent__mq__handle.html#a7029f9601aa268022bd8cf7970c512c8" title="Equivalent to receive() except stops short of reading anything, with non-error return indicating that...">Persistent_mq_handle::wait_receivable()</a>: implemented concept.</dd></dl>
<h3>INFO+ logging</h3>
<p >WARNING on error. (You may use the <code>flow::log::Config::this_thread_verbosity_override_auto()</code> to temporarily, in that thread only, disable/reduce logging. This is quite easy and performant.)</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">err_code</td><td>See above. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ad81eec3af613f32444785f8b5426ec50" name="ad81eec3af613f32444785f8b5426ec50"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad81eec3af613f32444785f8b5426ec50">&#9670;&nbsp;</a></span>wait_sendable()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ipc::transport::Bipc_mq_handle::wait_sendable </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespaceipc.html#aa3192e586cc45d3e7c22463bf2760f89">Error_code</a> *&#160;</td>
          <td class="paramname"><em>err_code</em> = <code>0</code></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Implements <a class="el" href="classipc_1_1transport_1_1Persistent__mq__handle.html" title="A documentation-only concept defining the behavior of an object representing a light-weight handle to...">Persistent_mq_handle</a> API: Like <a class="el" href="classipc_1_1transport_1_1Bipc__mq__handle.html#a45e952a67d6568f6ef4834a3523a2ca4" title="Implements Persistent_mq_handle API: Blocking send: pushes copy of message to queue; if queue is full...">send()</a> but without the actual pushing of a message. </p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classipc_1_1transport_1_1Persistent__mq__handle.html#a230060aa545bfe11eb263211c84514f1" title="Equivalent to send() except stops short of writing anything, with non-error return indicating that tr...">Persistent_mq_handle::wait_sendable()</a>: implemented concept.</dd></dl>
<h3>INFO+ logging</h3>
<p >WARNING on error. (You may use the <code>flow::log::Config::this_thread_verbosity_override_auto()</code> to temporarily, in that thread only, disable/reduce logging. This is quite easy and performant.)</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">err_code</td><td>See above. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<h2 class="groupheader">Friends And Related Function Documentation</h2>
<a id="a61c80019823537694f925275dccb4f3f" name="a61c80019823537694f925275dccb4f3f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a61c80019823537694f925275dccb4f3f">&#9670;&nbsp;</a></span>operator&lt;&lt;()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::ostream &amp; operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>os</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classipc_1_1transport_1_1Bipc__mq__handle.html">Bipc_mq_handle</a> &amp;&#160;</td>
          <td class="paramname"><em>val</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Prints string representation of the given <a class="el" href="classipc_1_1transport_1_1Bipc__mq__handle.html" title="Implements the Persistent_mq_handle concept by thinly wrapping bipc::message_queue,...">Bipc_mq_handle</a> to the given <code>ostream</code>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">os</td><td>Stream to which to write. </td></tr>
    <tr><td class="paramname">val</td><td>Object to serialize. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>os</code>. </dd></dl>

</div>
</div>
<a id="af0610dff5efd418a8ff393f0ad9dd5c2" name="af0610dff5efd418a8ff393f0ad9dd5c2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af0610dff5efd418a8ff393f0ad9dd5c2">&#9670;&nbsp;</a></span>swap()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void swap </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classipc_1_1transport_1_1Bipc__mq__handle.html">Bipc_mq_handle</a> &amp;&#160;</td>
          <td class="paramname"><em>val1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classipc_1_1transport_1_1Bipc__mq__handle.html">Bipc_mq_handle</a> &amp;&#160;</td>
          <td class="paramname"><em>val2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Implements <a class="el" href="classipc_1_1transport_1_1Persistent__mq__handle.html" title="A documentation-only concept defining the behavior of an object representing a light-weight handle to...">Persistent_mq_handle</a> related concept: Swaps two objects. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">val1</td><td>Object. </td></tr>
    <tr><td class="paramname">val2</td><td>Object. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<hr/>The documentation for this class was generated from the following files:<ul>
<li>transport/<a class="el" href="bipc__mq__handle_8hpp.html">bipc_mq_handle.hpp</a></li>
<li>transport/<a class="el" href="bipc__mq__handle_8cpp.html">bipc_mq_handle.cpp</a></li>
<li>transport/<a class="el" href="transport__fwd_8hpp.html">transport_fwd.hpp</a></li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Mon Apr 22 2024 23:55:44 for Flow-IPC by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.4
</small></address>
</body>
</html>
