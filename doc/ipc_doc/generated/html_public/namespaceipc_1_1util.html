<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.9.4"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Flow-IPC: ipc::util Namespace Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">Flow-IPC<span id="projectnumber">&#160;1.0</span>
   </div>
   <div id="projectbrief">Flow-IPC project: Public API.</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.4 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search",'Search','.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespaceipc.html">ipc</a></li><li class="navelem"><a class="el" href="namespaceipc_1_1util.html">util</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#namespaces">Namespaces</a> &#124;
<a href="#nested-classes">Classes</a> &#124;
<a href="#typedef-members">Typedefs</a> &#124;
<a href="#enum-members">Enumerations</a> &#124;
<a href="#func-members">Functions</a> &#124;
<a href="#var-members">Variables</a>  </div>
  <div class="headertitle"><div class="title">ipc::util Namespace Reference</div></div>
</div><!--header-->
<div class="contents">

<p>Flow-IPC module containing miscellaneous general-use facilities that ubiquitously used by ~all Flow-IPC modules and/or do not fit into any other Flow-IPC module.  
<a href="namespaceipc_1_1util.html#details">More...</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="namespaces" name="namespaces"></a>
Namespaces</h2></td></tr>
<tr class="memitem:namespaceipc_1_1util_1_1sync__io"><td class="memItemLeft" align="right" valign="top">namespace &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceipc_1_1util_1_1sync__io.html">sync_io</a></td></tr>
<tr class="memdesc:namespaceipc_1_1util_1_1sync__io"><td class="mdescLeft">&#160;</td><td class="mdescRight">Contains common code, as well as important explanatory documentation in the following text, for the <code><a class="el" href="namespaceipc_1_1util_1_1sync__io.html" title="Contains common code, as well as important explanatory documentation in the following text,...">sync_io</a></code> pattern used in <a class="el" href="namespaceipc_1_1transport.html" title="Flow-IPC module providing transmission of structured messages and/or low-level blobs (and more) betwe...">ipc::transport</a> and <a class="el" href="namespaceipc_1_1session.html" title="Flow-IPC module providing the broad lifecycle and shared-resource organization â€“ via the session conc...">ipc::session</a> to provide fine-tuned control over integrating asynchronous Flow-IPC activities into the user's event loop. <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="nested-classes" name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classipc_1_1util_1_1Default__init__allocator.html">Default_init_allocator</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Allocator adaptor (useful for, e.g., <code>vector</code> that skips zero-filling) that turns a value-initialization <code>T()</code> into a default-initialization for those types, namely PoDs, for which default-initialization is a no-op.  <a href="classipc_1_1util_1_1Default__init__allocator.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structipc_1_1util_1_1Native__handle.html">Native_handle</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A monolayer-thin wrapper around a native handle, a/k/a descriptor a/k/a FD.  <a href="structipc_1_1util_1_1Native__handle.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classipc_1_1util_1_1Process__credentials.html">Process_credentials</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A process's credentials (PID, UID, GID as of this writing).  <a href="classipc_1_1util_1_1Process__credentials.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classipc_1_1util_1_1Shared__name.html">Shared_name</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">String-wrapping abstraction representing a name uniquely distinguishing a kernel-persistent entity from all others in the system, or a fragment of such a name.  <a href="classipc_1_1util_1_1Shared__name.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classipc_1_1util_1_1Use__counted__object.html">Use_counted_object</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Simple counter that manually tracks utilization. It is not thread-safe.  <a href="classipc_1_1util_1_1Use__counted__object.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="typedef-members" name="typedef-members"></a>
Typedefs</h2></td></tr>
<tr class="memitem:ae6ac47812a90d1287c61e0b7de7bc4f5"><td class="memItemLeft" align="right" valign="top"><a id="ae6ac47812a90d1287c61e0b7de7bc4f5" name="ae6ac47812a90d1287c61e0b7de7bc4f5"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>String_view</b> = flow::util::String_view</td></tr>
<tr class="memdesc:ae6ac47812a90d1287c61e0b7de7bc4f5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Short-hand for Flow's <code>String_view</code>. <br /></td></tr>
<tr class="separator:ae6ac47812a90d1287c61e0b7de7bc4f5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac66141280c3b7295a86b65209f31cc58"><td class="memItemLeft" align="right" valign="top"><a id="ac66141280c3b7295a86b65209f31cc58" name="ac66141280c3b7295a86b65209f31cc58"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>Fine_duration</b> = flow::Fine_duration</td></tr>
<tr class="memdesc:ac66141280c3b7295a86b65209f31cc58"><td class="mdescLeft">&#160;</td><td class="mdescRight">Short-hand for Flow's <code>Fine_duration</code>. <br /></td></tr>
<tr class="separator:ac66141280c3b7295a86b65209f31cc58"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa3808edfc4d59bce4b9800d6a60026d3"><td class="memItemLeft" align="right" valign="top"><a id="aa3808edfc4d59bce4b9800d6a60026d3" name="aa3808edfc4d59bce4b9800d6a60026d3"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>Fine_time_pt</b> = flow::Fine_time_pt</td></tr>
<tr class="memdesc:aa3808edfc4d59bce4b9800d6a60026d3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Short-hand for Flow's <code>Fine_time_pt</code>. <br /></td></tr>
<tr class="separator:aa3808edfc4d59bce4b9800d6a60026d3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a31e67d3a017477a04b313927e2f2c733"><td class="memItemLeft" align="right" valign="top"><a id="a31e67d3a017477a04b313927e2f2c733" name="a31e67d3a017477a04b313927e2f2c733"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>Task</b> = flow::async::Task</td></tr>
<tr class="memdesc:a31e67d3a017477a04b313927e2f2c733"><td class="mdescLeft">&#160;</td><td class="mdescRight">Short-hand for polymorphic function (a-la <code>std::function&lt;&gt;</code>) that takes no arguments and returns nothing. <br /></td></tr>
<tr class="separator:a31e67d3a017477a04b313927e2f2c733"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae0be7edba7e30ffa3f8b742af621f2ab"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceipc_1_1util.html#ae0be7edba7e30ffa3f8b742af621f2ab">Blob_const</a> = boost::asio::const_buffer</td></tr>
<tr class="memdesc:ae0be7edba7e30ffa3f8b742af621f2ab"><td class="mdescLeft">&#160;</td><td class="mdescRight">Short-hand for an immutable blob somewhere in memory, stored as exactly a <code>void const *</code> and a <code>size_t</code>.  <a href="namespaceipc_1_1util.html#ae0be7edba7e30ffa3f8b742af621f2ab">More...</a><br /></td></tr>
<tr class="separator:ae0be7edba7e30ffa3f8b742af621f2ab"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6cb62ae434900f3a8915b33ec5d61a96"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceipc_1_1util.html#a6cb62ae434900f3a8915b33ec5d61a96">Blob_mutable</a> = boost::asio::mutable_buffer</td></tr>
<tr class="memdesc:a6cb62ae434900f3a8915b33ec5d61a96"><td class="mdescLeft">&#160;</td><td class="mdescRight">Short-hand for an mutable blob somewhere in memory, stored as exactly a <code>void*</code> and a <code>size_t</code>.  <a href="namespaceipc_1_1util.html#a6cb62ae434900f3a8915b33ec5d61a96">More...</a><br /></td></tr>
<tr class="separator:a6cb62ae434900f3a8915b33ec5d61a96"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0c44028a45451ebf21f6af8e806b2682"><td class="memItemLeft" align="right" valign="top"><a id="a0c44028a45451ebf21f6af8e806b2682" name="a0c44028a45451ebf21f6af8e806b2682"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>process_id_t</b> = ::pid_t</td></tr>
<tr class="memdesc:a0c44028a45451ebf21f6af8e806b2682"><td class="mdescLeft">&#160;</td><td class="mdescRight">Syntactic-sugary type for POSIX process ID (integer). <br /></td></tr>
<tr class="separator:a0c44028a45451ebf21f6af8e806b2682"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6435c1b48ec8684c24ca406d1d17208e"><td class="memItemLeft" align="right" valign="top"><a id="a6435c1b48ec8684c24ca406d1d17208e" name="a6435c1b48ec8684c24ca406d1d17208e"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>user_id_t</b> = ::uid_t</td></tr>
<tr class="memdesc:a6435c1b48ec8684c24ca406d1d17208e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Syntactic-sugary type for POSIX user ID (integer). <br /></td></tr>
<tr class="separator:a6435c1b48ec8684c24ca406d1d17208e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3f7d069ce0d23f73153da2e2559dc3d3"><td class="memItemLeft" align="right" valign="top"><a id="a3f7d069ce0d23f73153da2e2559dc3d3" name="a3f7d069ce0d23f73153da2e2559dc3d3"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>group_id_t</b> = ::gid_t</td></tr>
<tr class="memdesc:a3f7d069ce0d23f73153da2e2559dc3d3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Syntactic-sugary type for POSIX group ID (integer). <br /></td></tr>
<tr class="separator:a3f7d069ce0d23f73153da2e2559dc3d3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9571de958538d7a4a8649bbfecfac0b9"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceipc_1_1util.html#a9571de958538d7a4a8649bbfecfac0b9">Open_or_create</a> = bipc::open_or_create_t</td></tr>
<tr class="memdesc:a9571de958538d7a4a8649bbfecfac0b9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Tag type indicating an atomic open-if-exists-else-create operation.  <a href="namespaceipc_1_1util.html#a9571de958538d7a4a8649bbfecfac0b9">More...</a><br /></td></tr>
<tr class="separator:a9571de958538d7a4a8649bbfecfac0b9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3e03491b5b2b5fac26551a220946d6e5"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceipc_1_1util.html#a3e03491b5b2b5fac26551a220946d6e5">Open_only</a> = bipc::open_only_t</td></tr>
<tr class="memdesc:a3e03491b5b2b5fac26551a220946d6e5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Tag type indicating an ideally-atomic open-if-exists-else-fail operation.  <a href="namespaceipc_1_1util.html#a3e03491b5b2b5fac26551a220946d6e5">More...</a><br /></td></tr>
<tr class="separator:a3e03491b5b2b5fac26551a220946d6e5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9d84c2bab504e6de32b20c77ca9723a2"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceipc_1_1util.html#a9d84c2bab504e6de32b20c77ca9723a2">Create_only</a> = bipc::create_only_t</td></tr>
<tr class="memdesc:a9d84c2bab504e6de32b20c77ca9723a2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Tag type indicating a create-unless-exists-else-fail operation.  <a href="namespaceipc_1_1util.html#a9d84c2bab504e6de32b20c77ca9723a2">More...</a><br /></td></tr>
<tr class="separator:a9d84c2bab504e6de32b20c77ca9723a2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1b398ae730d1e6040687cb2397115152"><td class="memItemLeft" align="right" valign="top"><a id="a1b398ae730d1e6040687cb2397115152" name="a1b398ae730d1e6040687cb2397115152"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>Permissions</b> = bipc::permissions</td></tr>
<tr class="memdesc:a1b398ae730d1e6040687cb2397115152"><td class="mdescLeft">&#160;</td><td class="mdescRight">Short-hand for Unix (POSIX) permissions class. <br /></td></tr>
<tr class="separator:a1b398ae730d1e6040687cb2397115152"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="enum-members" name="enum-members"></a>
Enumerations</h2></td></tr>
<tr class="memitem:a2ec0bfdddb41a1ef0403e4bb8967705d"><td class="memItemLeft" align="right" valign="top">enum class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceipc_1_1util.html#a2ec0bfdddb41a1ef0403e4bb8967705d">Permissions_level</a> : size_t { <br />
&#160;&#160;<a class="el" href="namespaceipc_1_1util.html#a2ec0bfdddb41a1ef0403e4bb8967705dac43e9194d6c0e9803ecabbf3cb4c97fa">S_NO_ACCESS</a>
, <a class="el" href="namespaceipc_1_1util.html#a2ec0bfdddb41a1ef0403e4bb8967705daa3e1d310128f18fe2f903bf3cba8849a">S_USER_ACCESS</a>
, <a class="el" href="namespaceipc_1_1util.html#a2ec0bfdddb41a1ef0403e4bb8967705daa5508fa6037b9c0926cf7eb20af97a6d">S_GROUP_ACCESS</a>
, <a class="el" href="namespaceipc_1_1util.html#a2ec0bfdddb41a1ef0403e4bb8967705da25bf1cdee66ff5f73914fd5b0ee996e9">S_UNRESTRICTED</a>
, <br />
&#160;&#160;<a class="el" href="namespaceipc_1_1util.html#a2ec0bfdddb41a1ef0403e4bb8967705da6fba12db09e5bebfaa04f6372c41c2cf">S_END_SENTINEL</a>
<br />
 }</td></tr>
<tr class="memdesc:a2ec0bfdddb41a1ef0403e4bb8967705d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Simple specifier of desired access permissions, usually but not necessarily translated into a <code>Permissions</code> value (though even then different value in different contexts).  <a href="namespaceipc_1_1util.html#a2ec0bfdddb41a1ef0403e4bb8967705d">More...</a><br /></td></tr>
<tr class="separator:a2ec0bfdddb41a1ef0403e4bb8967705d"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="func-members" name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:a28030c32e9c66f5c2862cbc6998885c7"><td class="memItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceipc_1_1util.html#a28030c32e9c66f5c2862cbc6998885c7">operator&lt;&lt;</a> (std::ostream &amp;os, const <a class="el" href="structipc_1_1util_1_1Native__handle.html">Native_handle</a> &amp;val)</td></tr>
<tr class="memdesc:a28030c32e9c66f5c2862cbc6998885c7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Prints string representation of the given <a class="el" href="structipc_1_1util_1_1Native__handle.html" title="A monolayer-thin wrapper around a native handle, a/k/a descriptor a/k/a FD.">Native_handle</a> to the given <code>ostream</code>.  <a href="namespaceipc_1_1util.html#a28030c32e9c66f5c2862cbc6998885c7">More...</a><br /></td></tr>
<tr class="separator:a28030c32e9c66f5c2862cbc6998885c7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae4b4126f841ef060cdae15998e48691c"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceipc_1_1util.html#ae4b4126f841ef060cdae15998e48691c">operator==</a> (<a class="el" href="structipc_1_1util_1_1Native__handle.html">Native_handle</a> val1, <a class="el" href="structipc_1_1util_1_1Native__handle.html">Native_handle</a> val2)</td></tr>
<tr class="memdesc:ae4b4126f841ef060cdae15998e48691c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns <code>true</code> if and only if the two <a class="el" href="structipc_1_1util_1_1Native__handle.html" title="A monolayer-thin wrapper around a native handle, a/k/a descriptor a/k/a FD.">Native_handle</a> objects are the same underlying handle.  <a href="namespaceipc_1_1util.html#ae4b4126f841ef060cdae15998e48691c">More...</a><br /></td></tr>
<tr class="separator:ae4b4126f841ef060cdae15998e48691c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aacbd7ee43d4912a8790a228dc7cf682d"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceipc_1_1util.html#aacbd7ee43d4912a8790a228dc7cf682d">operator!=</a> (<a class="el" href="structipc_1_1util_1_1Native__handle.html">Native_handle</a> val1, <a class="el" href="structipc_1_1util_1_1Native__handle.html">Native_handle</a> val2)</td></tr>
<tr class="memdesc:aacbd7ee43d4912a8790a228dc7cf682d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Negation of similar <code>==</code>.  <a href="namespaceipc_1_1util.html#aacbd7ee43d4912a8790a228dc7cf682d">More...</a><br /></td></tr>
<tr class="separator:aacbd7ee43d4912a8790a228dc7cf682d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad3883df3081441d71a9a989073264b04"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceipc_1_1util.html#ad3883df3081441d71a9a989073264b04">hash_value</a> (<a class="el" href="structipc_1_1util_1_1Native__handle.html">Native_handle</a> val)</td></tr>
<tr class="memdesc:ad3883df3081441d71a9a989073264b04"><td class="mdescLeft">&#160;</td><td class="mdescRight">Hasher of <a class="el" href="structipc_1_1util_1_1Native__handle.html" title="A monolayer-thin wrapper around a native handle, a/k/a descriptor a/k/a FD.">Native_handle</a> for boost.unordered et al.  <a href="namespaceipc_1_1util.html#ad3883df3081441d71a9a989073264b04">More...</a><br /></td></tr>
<tr class="separator:ad3883df3081441d71a9a989073264b04"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6ff4b35d8fbbe2eb6266f3a7b0f07c49"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceipc_1_1util.html#a6ff4b35d8fbbe2eb6266f3a7b0f07c49">operator&lt;</a> (<a class="el" href="structipc_1_1util_1_1Native__handle.html">Native_handle</a> val1, <a class="el" href="structipc_1_1util_1_1Native__handle.html">Native_handle</a> val2)</td></tr>
<tr class="memdesc:a6ff4b35d8fbbe2eb6266f3a7b0f07c49"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a less-than comparison of two <a class="el" href="structipc_1_1util_1_1Native__handle.html" title="A monolayer-thin wrapper around a native handle, a/k/a descriptor a/k/a FD.">Native_handle</a> objects, with the usual total ordering guarantees.  <a href="namespaceipc_1_1util.html#a6ff4b35d8fbbe2eb6266f3a7b0f07c49">More...</a><br /></td></tr>
<tr class="separator:a6ff4b35d8fbbe2eb6266f3a7b0f07c49"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4ccdab04a79159f82d7ade8136a2eeb2"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceipc_1_1util.html#a4ccdab04a79159f82d7ade8136a2eeb2">operator==</a> (const <a class="el" href="classipc_1_1util_1_1Process__credentials.html">Process_credentials</a> &amp;val1, const <a class="el" href="classipc_1_1util_1_1Process__credentials.html">Process_credentials</a> &amp;val2)</td></tr>
<tr class="memdesc:a4ccdab04a79159f82d7ade8136a2eeb2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks for by-value equality between two <a class="el" href="classipc_1_1util_1_1Process__credentials.html" title="A process&#39;s credentials (PID, UID, GID as of this writing).">Process_credentials</a> objects.  <a href="namespaceipc_1_1util.html#a4ccdab04a79159f82d7ade8136a2eeb2">More...</a><br /></td></tr>
<tr class="separator:a4ccdab04a79159f82d7ade8136a2eeb2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaf94b5903f4e0aa2f2699867dd8971ef"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceipc_1_1util.html#aaf94b5903f4e0aa2f2699867dd8971ef">operator!=</a> (const <a class="el" href="classipc_1_1util_1_1Process__credentials.html">Process_credentials</a> &amp;val1, const <a class="el" href="classipc_1_1util_1_1Process__credentials.html">Process_credentials</a> &amp;val2)</td></tr>
<tr class="memdesc:aaf94b5903f4e0aa2f2699867dd8971ef"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks for by-value inequality between two <a class="el" href="classipc_1_1util_1_1Process__credentials.html" title="A process&#39;s credentials (PID, UID, GID as of this writing).">Process_credentials</a> objects.  <a href="namespaceipc_1_1util.html#aaf94b5903f4e0aa2f2699867dd8971ef">More...</a><br /></td></tr>
<tr class="separator:aaf94b5903f4e0aa2f2699867dd8971ef"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9da92514406dc1fc61f5a561c9b5aee9"><td class="memItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceipc_1_1util.html#a9da92514406dc1fc61f5a561c9b5aee9">operator&lt;&lt;</a> (std::ostream &amp;os, const <a class="el" href="classipc_1_1util_1_1Process__credentials.html">Process_credentials</a> &amp;val)</td></tr>
<tr class="memdesc:a9da92514406dc1fc61f5a561c9b5aee9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Prints string representation of the given <a class="el" href="classipc_1_1util_1_1Process__credentials.html" title="A process&#39;s credentials (PID, UID, GID as of this writing).">util::Process_credentials</a> to the given <code>ostream</code>.  <a href="namespaceipc_1_1util.html#a9da92514406dc1fc61f5a561c9b5aee9">More...</a><br /></td></tr>
<tr class="separator:a9da92514406dc1fc61f5a561c9b5aee9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af61b02fd66b67aeed5a803ca47e52973"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classipc_1_1util_1_1Shared__name.html">Shared_name</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceipc_1_1util.html#af61b02fd66b67aeed5a803ca47e52973">operator+</a> (const <a class="el" href="classipc_1_1util_1_1Shared__name.html">Shared_name</a> &amp;src1, const char *raw_src2)</td></tr>
<tr class="memdesc:af61b02fd66b67aeed5a803ca47e52973"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns new object equal to <code>Shared_name(src1) += raw_src2</code>.  <a href="namespaceipc_1_1util.html#af61b02fd66b67aeed5a803ca47e52973">More...</a><br /></td></tr>
<tr class="separator:af61b02fd66b67aeed5a803ca47e52973"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a096c71dede7bd5528215ac01a380a189"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classipc_1_1util_1_1Shared__name.html">Shared_name</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceipc_1_1util.html#a096c71dede7bd5528215ac01a380a189">operator+</a> (const char *raw_src1, const <a class="el" href="classipc_1_1util_1_1Shared__name.html">Shared_name</a> &amp;src2)</td></tr>
<tr class="memdesc:a096c71dede7bd5528215ac01a380a189"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns new object equal to <code>Shared_name(src2)</code> with <code>raw_src1</code> pre-pended to it.  <a href="namespaceipc_1_1util.html#a096c71dede7bd5528215ac01a380a189">More...</a><br /></td></tr>
<tr class="separator:a096c71dede7bd5528215ac01a380a189"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a54dc5077333284fda9e8d2df8b0e9b91"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classipc_1_1util_1_1Shared__name.html">Shared_name</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceipc_1_1util.html#a54dc5077333284fda9e8d2df8b0e9b91">operator+</a> (const <a class="el" href="classipc_1_1util_1_1Shared__name.html">Shared_name</a> &amp;src1, const <a class="el" href="classipc_1_1util_1_1Shared__name.html">Shared_name</a> &amp;src2)</td></tr>
<tr class="memdesc:a54dc5077333284fda9e8d2df8b0e9b91"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns new object equal to <code>Shared_name(src1) += src2</code>.  <a href="namespaceipc_1_1util.html#a54dc5077333284fda9e8d2df8b0e9b91">More...</a><br /></td></tr>
<tr class="separator:a54dc5077333284fda9e8d2df8b0e9b91"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa61c6b31c5c4e241c97f06a4d38c76c4"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classipc_1_1util_1_1Shared__name.html">Shared_name</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceipc_1_1util.html#aa61c6b31c5c4e241c97f06a4d38c76c4">operator/</a> (const <a class="el" href="classipc_1_1util_1_1Shared__name.html">Shared_name</a> &amp;src1, const char *raw_src2)</td></tr>
<tr class="memdesc:aa61c6b31c5c4e241c97f06a4d38c76c4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns new object equal to <code>Shared_name(src1) /= raw_src2</code>.  <a href="namespaceipc_1_1util.html#aa61c6b31c5c4e241c97f06a4d38c76c4">More...</a><br /></td></tr>
<tr class="separator:aa61c6b31c5c4e241c97f06a4d38c76c4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7f2bead5935309c2f760645fe46ddd71"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classipc_1_1util_1_1Shared__name.html">Shared_name</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceipc_1_1util.html#a7f2bead5935309c2f760645fe46ddd71">operator/</a> (const char *raw_src1, const <a class="el" href="classipc_1_1util_1_1Shared__name.html">Shared_name</a> &amp;src2)</td></tr>
<tr class="memdesc:a7f2bead5935309c2f760645fe46ddd71"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns new object equal to <code>Shared_name(raw_src1) /= src2</code>.  <a href="namespaceipc_1_1util.html#a7f2bead5935309c2f760645fe46ddd71">More...</a><br /></td></tr>
<tr class="separator:a7f2bead5935309c2f760645fe46ddd71"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a15ea67c1855a678f7e948b24ccf2c1cd"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classipc_1_1util_1_1Shared__name.html">Shared_name</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceipc_1_1util.html#a15ea67c1855a678f7e948b24ccf2c1cd">operator/</a> (const <a class="el" href="classipc_1_1util_1_1Shared__name.html">Shared_name</a> &amp;src1, const <a class="el" href="classipc_1_1util_1_1Shared__name.html">Shared_name</a> &amp;src2)</td></tr>
<tr class="memdesc:a15ea67c1855a678f7e948b24ccf2c1cd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns new object equal to <code>Shared_name(src1) /= src2</code>.  <a href="namespaceipc_1_1util.html#a15ea67c1855a678f7e948b24ccf2c1cd">More...</a><br /></td></tr>
<tr class="separator:a15ea67c1855a678f7e948b24ccf2c1cd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af7728c93fdf29479bbb2482e02f05cbf"><td class="memItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceipc_1_1util.html#af7728c93fdf29479bbb2482e02f05cbf">operator&lt;&lt;</a> (std::ostream &amp;os, const <a class="el" href="classipc_1_1util_1_1Shared__name.html">Shared_name</a> &amp;val)</td></tr>
<tr class="memdesc:af7728c93fdf29479bbb2482e02f05cbf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Prints embellished string representation of the given <a class="el" href="classipc_1_1util_1_1Shared__name.html" title="String-wrapping abstraction representing a name uniquely distinguishing a kernel-persistent entity fr...">Shared_name</a> to the given <code>ostream</code>.  <a href="namespaceipc_1_1util.html#af7728c93fdf29479bbb2482e02f05cbf">More...</a><br /></td></tr>
<tr class="separator:af7728c93fdf29479bbb2482e02f05cbf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adfd8805e0d37556102cad7b191fee9a3"><td class="memItemLeft" align="right" valign="top">std::istream &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceipc_1_1util.html#adfd8805e0d37556102cad7b191fee9a3">operator&gt;&gt;</a> (std::istream &amp;is, <a class="el" href="classipc_1_1util_1_1Shared__name.html">Shared_name</a> &amp;val)</td></tr>
<tr class="memdesc:adfd8805e0d37556102cad7b191fee9a3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reads <a class="el" href="classipc_1_1util_1_1Shared__name.html" title="String-wrapping abstraction representing a name uniquely distinguishing a kernel-persistent entity fr...">Shared_name</a> from the given <code>istream</code>; equivalent to reading <code>string</code> into <a class="el" href="classipc_1_1util_1_1Shared__name.html#ae89e1e061f87ffe0288514e254837595" title="Returns (sans copying) ref to immutable entire wrapped name string, suitable to pass into sys calls w...">Shared_name::str()</a>.  <a href="namespaceipc_1_1util.html#adfd8805e0d37556102cad7b191fee9a3">More...</a><br /></td></tr>
<tr class="separator:adfd8805e0d37556102cad7b191fee9a3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adad98b6935e58bdc92dfcf57bf60345e"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceipc_1_1util.html#adad98b6935e58bdc92dfcf57bf60345e">operator==</a> (const <a class="el" href="classipc_1_1util_1_1Shared__name.html">Shared_name</a> &amp;val1, const <a class="el" href="classipc_1_1util_1_1Shared__name.html">Shared_name</a> &amp;val2)</td></tr>
<tr class="memdesc:adad98b6935e58bdc92dfcf57bf60345e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns <code>true</code> if and only if <code>val1.str() == val2.str()</code>.  <a href="namespaceipc_1_1util.html#adad98b6935e58bdc92dfcf57bf60345e">More...</a><br /></td></tr>
<tr class="separator:adad98b6935e58bdc92dfcf57bf60345e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aec185fc5e2e88206d1366de8ce42f732"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceipc_1_1util.html#aec185fc5e2e88206d1366de8ce42f732">operator!=</a> (const <a class="el" href="classipc_1_1util_1_1Shared__name.html">Shared_name</a> &amp;val1, const <a class="el" href="classipc_1_1util_1_1Shared__name.html">Shared_name</a> &amp;val2)</td></tr>
<tr class="memdesc:aec185fc5e2e88206d1366de8ce42f732"><td class="mdescLeft">&#160;</td><td class="mdescRight">Negation of similar <code>==</code>.  <a href="namespaceipc_1_1util.html#aec185fc5e2e88206d1366de8ce42f732">More...</a><br /></td></tr>
<tr class="separator:aec185fc5e2e88206d1366de8ce42f732"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5023285f7dd8a117686f0ee986e685cb"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceipc_1_1util.html#a5023285f7dd8a117686f0ee986e685cb">operator==</a> (const <a class="el" href="classipc_1_1util_1_1Shared__name.html">Shared_name</a> &amp;val1, <a class="el" href="namespaceipc_1_1util.html#ae6ac47812a90d1287c61e0b7de7bc4f5">util::String_view</a> val2)</td></tr>
<tr class="memdesc:a5023285f7dd8a117686f0ee986e685cb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns <code>true</code> if and only if <code>val1.str() == string(val2)</code>.  <a href="namespaceipc_1_1util.html#a5023285f7dd8a117686f0ee986e685cb">More...</a><br /></td></tr>
<tr class="separator:a5023285f7dd8a117686f0ee986e685cb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0d9b586ec40d9dc3bc14915ef6d24cb7"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceipc_1_1util.html#a0d9b586ec40d9dc3bc14915ef6d24cb7">operator!=</a> (const <a class="el" href="classipc_1_1util_1_1Shared__name.html">Shared_name</a> &amp;val1, <a class="el" href="namespaceipc_1_1util.html#ae6ac47812a90d1287c61e0b7de7bc4f5">util::String_view</a> val2)</td></tr>
<tr class="memdesc:a0d9b586ec40d9dc3bc14915ef6d24cb7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Negation of similar <code>==</code>.  <a href="namespaceipc_1_1util.html#a0d9b586ec40d9dc3bc14915ef6d24cb7">More...</a><br /></td></tr>
<tr class="separator:a0d9b586ec40d9dc3bc14915ef6d24cb7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a97a7c8e6330909a1371134a7bdcea788"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceipc_1_1util.html#a97a7c8e6330909a1371134a7bdcea788">operator==</a> (<a class="el" href="namespaceipc_1_1util.html#ae6ac47812a90d1287c61e0b7de7bc4f5">util::String_view</a> val1, const <a class="el" href="classipc_1_1util_1_1Shared__name.html">Shared_name</a> &amp;val2)</td></tr>
<tr class="memdesc:a97a7c8e6330909a1371134a7bdcea788"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns <code>true</code> if and only if <code>string(val1) == val2.str()</code>.  <a href="namespaceipc_1_1util.html#a97a7c8e6330909a1371134a7bdcea788">More...</a><br /></td></tr>
<tr class="separator:a97a7c8e6330909a1371134a7bdcea788"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a988ac1702279bd2b958464cd8ee7e81f"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceipc_1_1util.html#a988ac1702279bd2b958464cd8ee7e81f">operator!=</a> (<a class="el" href="namespaceipc_1_1util.html#ae6ac47812a90d1287c61e0b7de7bc4f5">util::String_view</a> val1, const <a class="el" href="classipc_1_1util_1_1Shared__name.html">Shared_name</a> &amp;val2)</td></tr>
<tr class="memdesc:a988ac1702279bd2b958464cd8ee7e81f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Negation of similar <code>==</code>.  <a href="namespaceipc_1_1util.html#a988ac1702279bd2b958464cd8ee7e81f">More...</a><br /></td></tr>
<tr class="separator:a988ac1702279bd2b958464cd8ee7e81f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aea456ff91117633e731804a894aa94da"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceipc_1_1util.html#aea456ff91117633e731804a894aa94da">operator&lt;</a> (const <a class="el" href="classipc_1_1util_1_1Shared__name.html">Shared_name</a> &amp;val1, const <a class="el" href="classipc_1_1util_1_1Shared__name.html">Shared_name</a> &amp;val2)</td></tr>
<tr class="memdesc:aea456ff91117633e731804a894aa94da"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns <code>true</code> if and only if <code>val1.str() &lt; val2.str()</code>.  <a href="namespaceipc_1_1util.html#aea456ff91117633e731804a894aa94da">More...</a><br /></td></tr>
<tr class="separator:aea456ff91117633e731804a894aa94da"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aba4ae811264cbb7e664ce126b591cbc7"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceipc_1_1util.html#aba4ae811264cbb7e664ce126b591cbc7">hash_value</a> (const <a class="el" href="classipc_1_1util_1_1Shared__name.html">Shared_name</a> &amp;val)</td></tr>
<tr class="memdesc:aba4ae811264cbb7e664ce126b591cbc7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Hasher of <a class="el" href="classipc_1_1util_1_1Shared__name.html" title="String-wrapping abstraction representing a name uniquely distinguishing a kernel-persistent entity fr...">Shared_name</a> for boost.unordered et al.  <a href="namespaceipc_1_1util.html#aba4ae811264cbb7e664ce126b591cbc7">More...</a><br /></td></tr>
<tr class="separator:aba4ae811264cbb7e664ce126b591cbc7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9ea22a64cfbc6de66181c278ff5f6975"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceipc_1_1util.html#a9ea22a64cfbc6de66181c278ff5f6975">swap</a> (<a class="el" href="classipc_1_1util_1_1Shared__name.html">Shared_name</a> &amp;val1, <a class="el" href="classipc_1_1util_1_1Shared__name.html">Shared_name</a> &amp;val2)</td></tr>
<tr class="memdesc:a9ea22a64cfbc6de66181c278ff5f6975"><td class="mdescLeft">&#160;</td><td class="mdescRight">Swaps two objects.  <a href="namespaceipc_1_1util.html#a9ea22a64cfbc6de66181c278ff5f6975">More...</a><br /></td></tr>
<tr class="separator:a9ea22a64cfbc6de66181c278ff5f6975"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a52b2ba03d5ace7389991bb5d31b9fa59"><td class="memTemplParams" colspan="2">template&lt;typename Source &gt; </td></tr>
<tr class="memitem:a52b2ba03d5ace7389991bb5d31b9fa59"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classipc_1_1util_1_1Shared__name.html">Shared_name</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceipc_1_1util.html#a52b2ba03d5ace7389991bb5d31b9fa59">operator+</a> (const <a class="el" href="classipc_1_1util_1_1Shared__name.html">Shared_name</a> &amp;src1, const Source &amp;raw_src2)</td></tr>
<tr class="memdesc:a52b2ba03d5ace7389991bb5d31b9fa59"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns new object equal to <code>Shared_name(src1) += raw_src2</code>.  <a href="namespaceipc_1_1util.html#a52b2ba03d5ace7389991bb5d31b9fa59">More...</a><br /></td></tr>
<tr class="separator:a52b2ba03d5ace7389991bb5d31b9fa59"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1f1a40877cc08b287f8f3c7e7f663782"><td class="memTemplParams" colspan="2">template&lt;typename Source &gt; </td></tr>
<tr class="memitem:a1f1a40877cc08b287f8f3c7e7f663782"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classipc_1_1util_1_1Shared__name.html">Shared_name</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceipc_1_1util.html#a1f1a40877cc08b287f8f3c7e7f663782">operator+</a> (const Source &amp;raw_src1, const <a class="el" href="classipc_1_1util_1_1Shared__name.html">Shared_name</a> &amp;src2)</td></tr>
<tr class="memdesc:a1f1a40877cc08b287f8f3c7e7f663782"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns new object equal to <code>Shared_name(src2)</code> with <code>raw_src1</code> pre-pended to it.  <a href="namespaceipc_1_1util.html#a1f1a40877cc08b287f8f3c7e7f663782">More...</a><br /></td></tr>
<tr class="separator:a1f1a40877cc08b287f8f3c7e7f663782"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a910207a2da57b61cee4a22899e239dc2"><td class="memTemplParams" colspan="2">template&lt;typename Source &gt; </td></tr>
<tr class="memitem:a910207a2da57b61cee4a22899e239dc2"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classipc_1_1util_1_1Shared__name.html">Shared_name</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceipc_1_1util.html#a910207a2da57b61cee4a22899e239dc2">operator/</a> (const <a class="el" href="classipc_1_1util_1_1Shared__name.html">Shared_name</a> &amp;src1, const Source &amp;raw_src2)</td></tr>
<tr class="memdesc:a910207a2da57b61cee4a22899e239dc2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns new object equal to <code>Shared_name(src1) /= raw_src2</code>.  <a href="namespaceipc_1_1util.html#a910207a2da57b61cee4a22899e239dc2">More...</a><br /></td></tr>
<tr class="separator:a910207a2da57b61cee4a22899e239dc2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a462b81d34ba23c968f63d9805fa74538"><td class="memTemplParams" colspan="2">template&lt;typename Source &gt; </td></tr>
<tr class="memitem:a462b81d34ba23c968f63d9805fa74538"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classipc_1_1util_1_1Shared__name.html">Shared_name</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceipc_1_1util.html#a462b81d34ba23c968f63d9805fa74538">operator/</a> (const Source &amp;raw_src1, const <a class="el" href="classipc_1_1util_1_1Shared__name.html">Shared_name</a> &amp;src2)</td></tr>
<tr class="memdesc:a462b81d34ba23c968f63d9805fa74538"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns new object equal to <code>Shared_name(raw_src1) /= src2</code>.  <a href="namespaceipc_1_1util.html#a462b81d34ba23c968f63d9805fa74538">More...</a><br /></td></tr>
<tr class="separator:a462b81d34ba23c968f63d9805fa74538"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a150051ee7e308ba7c9269b2d1e2c6c37"><td class="memTemplParams" colspan="2">template&lt;typename Persistent_object , typename Filter_func &gt; </td></tr>
<tr class="memitem:a150051ee7e308ba7c9269b2d1e2c6c37"><td class="memTemplItemLeft" align="right" valign="top">unsigned int&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceipc_1_1util.html#a150051ee7e308ba7c9269b2d1e2c6c37">remove_each_persistent_if</a> (flow::log::Logger *logger_ptr, const Filter_func &amp;filter_func)</td></tr>
<tr class="memdesc:a150051ee7e308ba7c9269b2d1e2c6c37"><td class="mdescLeft">&#160;</td><td class="mdescRight">Utility that invokes <code>Persistent_object::for_each_persistent(name_prefix_or_empty)</code> and synchronously invokes <code>Persistent_object::remove_persistent()</code> on each resulting item that passes the given filter, where <code>Persistent_object</code> is a type that handles objects &ndash; such as SHM pools or POSIX MQs &ndash; with kernel-persistent semantics.  <a href="namespaceipc_1_1util.html#a150051ee7e308ba7c9269b2d1e2c6c37">More...</a><br /></td></tr>
<tr class="separator:a150051ee7e308ba7c9269b2d1e2c6c37"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad6be904bf1b0fe6659a11dec0fabbf6b"><td class="memTemplParams" colspan="2">template&lt;typename Persistent_object &gt; </td></tr>
<tr class="memitem:ad6be904bf1b0fe6659a11dec0fabbf6b"><td class="memTemplItemLeft" align="right" valign="top">unsigned int&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceipc_1_1util.html#ad6be904bf1b0fe6659a11dec0fabbf6b">remove_each_persistent_with_name_prefix</a> (flow::log::Logger *logger_ptr, const <a class="el" href="classipc_1_1util_1_1Shared__name.html">Shared_name</a> &amp;name_prefix_or_empty)</td></tr>
<tr class="memdesc:ad6be904bf1b0fe6659a11dec0fabbf6b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Utility that invokes <a class="el" href="namespaceipc_1_1util.html#a150051ee7e308ba7c9269b2d1e2c6c37" title="Utility that invokes Persistent_object::for_each_persistent(name_prefix_or_empty) and synchronously i...">remove_each_persistent_if()</a> with the filter that returns <code>true</code> (yes, remove) if and only if the item's name optionally matches a given <a class="el" href="classipc_1_1util_1_1Shared__name.html" title="String-wrapping abstraction representing a name uniquely distinguishing a kernel-persistent entity fr...">Shared_name</a> prefix.  <a href="namespaceipc_1_1util.html#ad6be904bf1b0fe6659a11dec0fabbf6b">More...</a><br /></td></tr>
<tr class="separator:ad6be904bf1b0fe6659a11dec0fabbf6b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abda2ce5bcdbc26ca63d667b87818439c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespaceipc_1_1util.html#a1b398ae730d1e6040687cb2397115152">Permissions</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceipc_1_1util.html#abda2ce5bcdbc26ca63d667b87818439c">shared_resource_permissions</a> (<a class="el" href="namespaceipc_1_1util.html#a2ec0bfdddb41a1ef0403e4bb8967705d">Permissions_level</a> permissions_lvl)</td></tr>
<tr class="memdesc:abda2ce5bcdbc26ca63d667b87818439c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Maps general Permissions_level specifier to low-level <a class="el" href="namespaceipc_1_1util.html#a1b398ae730d1e6040687cb2397115152" title="Short-hand for Unix (POSIX) permissions class.">Permissions</a> value, when the underlying resource is in the file-system and is either accessible (read-write in terms of file system) or inaccessible.  <a href="namespaceipc_1_1util.html#abda2ce5bcdbc26ca63d667b87818439c">More...</a><br /></td></tr>
<tr class="separator:abda2ce5bcdbc26ca63d667b87818439c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abbba79fcaee378f433e7ce3093e5c435"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceipc_1_1util.html#abbba79fcaee378f433e7ce3093e5c435">set_resource_permissions</a> (flow::log::Logger *logger_ptr, const fs::path &amp;path, const <a class="el" href="namespaceipc_1_1util.html#a1b398ae730d1e6040687cb2397115152">Permissions</a> &amp;perms, <a class="el" href="namespaceipc.html#aa3192e586cc45d3e7c22463bf2760f89">Error_code</a> *err_code=0)</td></tr>
<tr class="memdesc:abbba79fcaee378f433e7ce3093e5c435"><td class="mdescLeft">&#160;</td><td class="mdescRight">Utility that sets the permissions of the given resource (at the supplied file system path) to specified POSIX value.  <a href="namespaceipc_1_1util.html#abbba79fcaee378f433e7ce3093e5c435">More...</a><br /></td></tr>
<tr class="separator:abbba79fcaee378f433e7ce3093e5c435"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af8b2f5a0cd9fe9db4511c9a3e685b6ae"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceipc_1_1util.html#af8b2f5a0cd9fe9db4511c9a3e685b6ae">set_resource_permissions</a> (flow::log::Logger *logger_ptr, <a class="el" href="structipc_1_1util_1_1Native__handle.html">Native_handle</a> handle, const <a class="el" href="namespaceipc_1_1util.html#a1b398ae730d1e6040687cb2397115152">Permissions</a> &amp;perms, <a class="el" href="namespaceipc.html#aa3192e586cc45d3e7c22463bf2760f89">Error_code</a> *err_code=0)</td></tr>
<tr class="memdesc:af8b2f5a0cd9fe9db4511c9a3e685b6ae"><td class="mdescLeft">&#160;</td><td class="mdescRight">Identical to the other <a class="el" href="namespaceipc_1_1util.html#abbba79fcaee378f433e7ce3093e5c435" title="Utility that sets the permissions of the given resource (at the supplied file system path) to specifi...">set_resource_permissions()</a> overload but operates on a pre-opened <a class="el" href="structipc_1_1util_1_1Native__handle.html" title="A monolayer-thin wrapper around a native handle, a/k/a descriptor a/k/a FD.">Native_handle</a> (a/k/a handle, socket, file descriptor) to the resource in question.  <a href="namespaceipc_1_1util.html#af8b2f5a0cd9fe9db4511c9a3e685b6ae">More...</a><br /></td></tr>
<tr class="separator:af8b2f5a0cd9fe9db4511c9a3e685b6ae"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a924cd56daf7eeaa0b07edb352367f9ec"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceipc_1_1util.html#a924cd56daf7eeaa0b07edb352367f9ec">process_running</a> (<a class="el" href="namespaceipc_1_1util.html#a0c44028a45451ebf21f6af8e806b2682">process_id_t</a> process_id)</td></tr>
<tr class="memdesc:a924cd56daf7eeaa0b07edb352367f9ec"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns <code>true</code> if and only if the given process (by PID) is reported as running by the OS.  <a href="namespaceipc_1_1util.html#a924cd56daf7eeaa0b07edb352367f9ec">More...</a><br /></td></tr>
<tr class="separator:a924cd56daf7eeaa0b07edb352367f9ec"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2bb38cee29dacbe56de5182221b45941"><td class="memItemLeft" align="right" valign="top">const uint8_t *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceipc_1_1util.html#a2bb38cee29dacbe56de5182221b45941">blob_data</a> (const <a class="el" href="namespaceipc_1_1util.html#ae0be7edba7e30ffa3f8b742af621f2ab">Blob_const</a> &amp;blob)</td></tr>
<tr class="memdesc:a2bb38cee29dacbe56de5182221b45941"><td class="mdescLeft">&#160;</td><td class="mdescRight">Syntactic-sugary helper that returns pointer to first byte in an immutable buffer, as <code>const uint8_t*</code>.  <a href="namespaceipc_1_1util.html#a2bb38cee29dacbe56de5182221b45941">More...</a><br /></td></tr>
<tr class="separator:a2bb38cee29dacbe56de5182221b45941"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af38a66554a822a470667967c56083e3b"><td class="memItemLeft" align="right" valign="top">uint8_t *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceipc_1_1util.html#af38a66554a822a470667967c56083e3b">blob_data</a> (const <a class="el" href="namespaceipc_1_1util.html#a6cb62ae434900f3a8915b33ec5d61a96">Blob_mutable</a> &amp;blob)</td></tr>
<tr class="memdesc:af38a66554a822a470667967c56083e3b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Syntactic-sugary helper that returns pointer to first byte in a mutable buffer, as <code>uint8_t*</code>.  <a href="namespaceipc_1_1util.html#af38a66554a822a470667967c56083e3b">More...</a><br /></td></tr>
<tr class="separator:af38a66554a822a470667967c56083e3b"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="var-members" name="var-members"></a>
Variables</h2></td></tr>
<tr class="memitem:a5664539b3d75d6d10cdfebf6eac5382d"><td class="memItemLeft" align="right" valign="top"><a id="a5664539b3d75d6d10cdfebf6eac5382d" name="a5664539b3d75d6d10cdfebf6eac5382d"></a>
const <a class="el" href="namespaceipc_1_1util.html#a9571de958538d7a4a8649bbfecfac0b9">Open_or_create</a>&#160;</td><td class="memItemRight" valign="bottom"><b>OPEN_OR_CREATE</b></td></tr>
<tr class="memdesc:a5664539b3d75d6d10cdfebf6eac5382d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Tag value indicating an open-if-exists-else-create operation. <br /></td></tr>
<tr class="separator:a5664539b3d75d6d10cdfebf6eac5382d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6a3a6ec85242d073df96978c63464078"><td class="memItemLeft" align="right" valign="top"><a id="a6a3a6ec85242d073df96978c63464078" name="a6a3a6ec85242d073df96978c63464078"></a>
const <a class="el" href="namespaceipc_1_1util.html#a3e03491b5b2b5fac26551a220946d6e5">Open_only</a>&#160;</td><td class="memItemRight" valign="bottom"><b>OPEN_ONLY</b></td></tr>
<tr class="memdesc:a6a3a6ec85242d073df96978c63464078"><td class="mdescLeft">&#160;</td><td class="mdescRight">Tag value indicating an atomic open-if-exists-else-fail operation. <br /></td></tr>
<tr class="separator:a6a3a6ec85242d073df96978c63464078"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad1ca1cab79a35e1eb1c47037a0973cd8"><td class="memItemLeft" align="right" valign="top"><a id="ad1ca1cab79a35e1eb1c47037a0973cd8" name="ad1ca1cab79a35e1eb1c47037a0973cd8"></a>
const <a class="el" href="namespaceipc_1_1util.html#a9d84c2bab504e6de32b20c77ca9723a2">Create_only</a>&#160;</td><td class="memItemRight" valign="bottom"><b>CREATE_ONLY</b></td></tr>
<tr class="memdesc:ad1ca1cab79a35e1eb1c47037a0973cd8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Tag value indicating an atomic create-unless-exists-else-fail operation. <br /></td></tr>
<tr class="separator:ad1ca1cab79a35e1eb1c47037a0973cd8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aca6ca223759ca3e11d5834a323454afa"><td class="memItemLeft" align="right" valign="top"><a id="aca6ca223759ca3e11d5834a323454afa" name="aca6ca223759ca3e11d5834a323454afa"></a>
const std::string&#160;</td><td class="memItemRight" valign="bottom"><b>EMPTY_STRING</b></td></tr>
<tr class="memdesc:aca6ca223759ca3e11d5834a323454afa"><td class="mdescLeft">&#160;</td><td class="mdescRight">A (default-cted) string. May be useful for functions returning <code>const std::string&amp;</code>. <br /></td></tr>
<tr class="separator:aca6ca223759ca3e11d5834a323454afa"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p >Flow-IPC module containing miscellaneous general-use facilities that ubiquitously used by ~all Flow-IPC modules and/or do not fit into any other Flow-IPC module. </p>
<p >Each symbol therein is typically used by at least 1 other Flow-IPC module; but all public symbols (except ones under a detail/ subdirectory) are intended for use by Flow-IPC user as well. Some particulars to note:</p>
<p ><a class="el" href="classipc_1_1util_1_1Shared__name.html" title="String-wrapping abstraction representing a name uniquely distinguishing a kernel-persistent entity fr...">ipc::util::Shared_name</a> is a universally used shared-resource name class, conceptually similar to <code>boost::filesystem::path</code>. It is used in <a class="el" href="namespaceipc_1_1transport.html" title="Flow-IPC module providing transmission of structured messages and/or low-level blobs (and more) betwe...">ipc::transport</a> APIs &ndash; namely to name endpoints when establishing channels, and more &ndash; but also in other Flow-IPC modules. For example <code><a class="el" href="classipc_1_1util_1_1Shared__name.html" title="String-wrapping abstraction representing a name uniquely distinguishing a kernel-persistent entity fr...">Shared_name</a></code> is used to name certain SHM entities in <a class="el" href="namespaceipc_1_1shm.html" title="Modules for SHared Memory (SHM) support.">ipc::shm</a> and in <a class="el" href="namespaceipc_1_1session.html" title="Flow-IPC module providing the broad lifecycle and shared-resource organization â€“ via the session conc...">ipc::session</a> when connecting to conversation partner process(es).</p>
<p ><a class="el" href="structipc_1_1util_1_1Native__handle.html" title="A monolayer-thin wrapper around a native handle, a/k/a descriptor a/k/a FD.">ipc::util::Native_handle</a> is a commonly used native-handle (FD in POSIX parlance) wrapper (so thin it doesn't add a single bit on top of the actul FD). These are ~always passed around by value (copied), as they are very small in practice.</p>
<p >There are of course various other things; just check them out as they are referenced, or just look around. Note there are free functions providing various niceties; and more types including classes and scoped <code>enum</code>s. </p>
</div><h2 class="groupheader">Typedef Documentation</h2>
<a id="ae0be7edba7e30ffa3f8b742af621f2ab" name="ae0be7edba7e30ffa3f8b742af621f2ab"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae0be7edba7e30ffa3f8b742af621f2ab">&#9670;&nbsp;</a></span>Blob_const</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespaceipc_1_1util.html#ae0be7edba7e30ffa3f8b742af621f2ab">ipc::util::Blob_const</a> = typedef boost::asio::const_buffer</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Short-hand for an immutable blob somewhere in memory, stored as exactly a <code>void const *</code> and a <code>size_t</code>. </p>
<h3>How to use</h3>
<p >We provide this alias as a stylistic short-hand, as it better suits various interfaces especially in <a class="el" href="namespaceipc_1_1transport.html" title="Flow-IPC module providing transmission of structured messages and/or low-level blobs (and more) betwe...">ipc::transport</a>. Nevertheless it's not meant to more than that; it's an attempt to abstract it away.</p>
<p >That is to say, to work with these (create them, access them, etc.), do use the highly convenient boost.asio buffer APIs which are well documented in boost.asio's docs. </p>

</div>
</div>
<a id="a6cb62ae434900f3a8915b33ec5d61a96" name="a6cb62ae434900f3a8915b33ec5d61a96"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6cb62ae434900f3a8915b33ec5d61a96">&#9670;&nbsp;</a></span>Blob_mutable</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespaceipc_1_1util.html#a6cb62ae434900f3a8915b33ec5d61a96">ipc::util::Blob_mutable</a> = typedef boost::asio::mutable_buffer</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Short-hand for an mutable blob somewhere in memory, stored as exactly a <code>void*</code> and a <code>size_t</code>. </p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="namespaceipc_1_1util.html#ae0be7edba7e30ffa3f8b742af621f2ab" title="Short-hand for an immutable blob somewhere in memory, stored as exactly a void const * and a size_t.">ipc::util::Blob_const</a>; usability notes in that doc header apply similarly here. </dd></dl>

</div>
</div>
<a id="a9d84c2bab504e6de32b20c77ca9723a2" name="a9d84c2bab504e6de32b20c77ca9723a2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9d84c2bab504e6de32b20c77ca9723a2">&#9670;&nbsp;</a></span>Create_only</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespaceipc_1_1util.html#a9d84c2bab504e6de32b20c77ca9723a2">ipc::util::Create_only</a> = typedef bipc::create_only_t</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Tag type indicating a create-unless-exists-else-fail operation. </p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="namespaceipc_1_1util.html#ad1ca1cab79a35e1eb1c47037a0973cd8" title="Tag value indicating an atomic create-unless-exists-else-fail operation.">CREATE_ONLY</a>. </dd></dl>

</div>
</div>
<a id="a3e03491b5b2b5fac26551a220946d6e5" name="a3e03491b5b2b5fac26551a220946d6e5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3e03491b5b2b5fac26551a220946d6e5">&#9670;&nbsp;</a></span>Open_only</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespaceipc_1_1util.html#a3e03491b5b2b5fac26551a220946d6e5">ipc::util::Open_only</a> = typedef bipc::open_only_t</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Tag type indicating an ideally-atomic open-if-exists-else-fail operation. </p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="namespaceipc_1_1util.html#a6a3a6ec85242d073df96978c63464078" title="Tag value indicating an atomic open-if-exists-else-fail operation.">OPEN_ONLY</a>. </dd></dl>

</div>
</div>
<a id="a9571de958538d7a4a8649bbfecfac0b9" name="a9571de958538d7a4a8649bbfecfac0b9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9571de958538d7a4a8649bbfecfac0b9">&#9670;&nbsp;</a></span>Open_or_create</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespaceipc_1_1util.html#a9571de958538d7a4a8649bbfecfac0b9">ipc::util::Open_or_create</a> = typedef bipc::open_or_create_t</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Tag type indicating an atomic open-if-exists-else-create operation. </p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="namespaceipc_1_1util.html#a5664539b3d75d6d10cdfebf6eac5382d" title="Tag value indicating an open-if-exists-else-create operation.">OPEN_OR_CREATE</a>. </dd></dl>

</div>
</div>
<h2 class="groupheader">Enumeration Type Documentation</h2>
<a id="a2ec0bfdddb41a1ef0403e4bb8967705d" name="a2ec0bfdddb41a1ef0403e4bb8967705d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2ec0bfdddb41a1ef0403e4bb8967705d">&#9670;&nbsp;</a></span>Permissions_level</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">enum class <a class="el" href="namespaceipc_1_1util.html#a2ec0bfdddb41a1ef0403e4bb8967705d">ipc::util::Permissions_level</a> : size_t</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">strong</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Simple specifier of desired access permissions, usually but not necessarily translated into a <code>Permissions</code> value (though even then different value in different contexts). </p>
<p >May be used to map, say, from a Permissions_level to a <a class="el" href="namespaceipc_1_1util.html#a1b398ae730d1e6040687cb2397115152" title="Short-hand for Unix (POSIX) permissions class.">Permissions</a> value in an <code>array&lt;Permissions, size_t(Permissions_level::S_END_SENTINEL)&gt;</code>.</p>
<p >While, unlike <a class="el" href="namespaceipc_1_1util.html#a1b398ae730d1e6040687cb2397115152" title="Short-hand for Unix (POSIX) permissions class.">Permissions</a>, this <code>enum</code> intends not be overtly based on a POSIX RWXRWXRWC model, it does still assume the 3 user groupings are "user themselves," "user's group," and "everyone." The 1st and 3rd are likely universal, but the 2nd may not apply to all OS &ndash; through probably all POSIX/Unix ones &ndash; and even for something like Linux there could be different groupings such as ones based on OS ACL. As of this writing it's fine, as this is a POSIX-targeted library at least (in fact, Linux, as of this writing, but that could change to include, say, MacOS/BSD). </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="a2ec0bfdddb41a1ef0403e4bb8967705dac43e9194d6c0e9803ecabbf3cb4c97fa" name="a2ec0bfdddb41a1ef0403e4bb8967705dac43e9194d6c0e9803ecabbf3cb4c97fa"></a>S_NO_ACCESS&#160;</td><td class="fielddoc"><p >Forbids all access, even by the creator's user. Most likely this would be useful for testing or debugging. </p>
</td></tr>
<tr><td class="fieldname"><a id="a2ec0bfdddb41a1ef0403e4bb8967705daa3e1d310128f18fe2f903bf3cba8849a" name="a2ec0bfdddb41a1ef0403e4bb8967705daa3e1d310128f18fe2f903bf3cba8849a"></a>S_USER_ACCESS&#160;</td><td class="fielddoc"><p >Allows access by resource-owning user (in POSIX/Unix identified by UID) and no one else. </p>
</td></tr>
<tr><td class="fieldname"><a id="a2ec0bfdddb41a1ef0403e4bb8967705daa5508fa6037b9c0926cf7eb20af97a6d" name="a2ec0bfdddb41a1ef0403e4bb8967705daa5508fa6037b9c0926cf7eb20af97a6d"></a>S_GROUP_ACCESS&#160;</td><td class="fielddoc"><p >Allows access by resource-owning user's containing group(s) (in POSIX/Unix identified by GID) and no one else. </p>
<p >This implies, as well, at least as much access as <code>S_USER_ACCESS</code>. </p>
</td></tr>
<tr><td class="fieldname"><a id="a2ec0bfdddb41a1ef0403e4bb8967705da25bf1cdee66ff5f73914fd5b0ee996e9" name="a2ec0bfdddb41a1ef0403e4bb8967705da25bf1cdee66ff5f73914fd5b0ee996e9"></a>S_UNRESTRICTED&#160;</td><td class="fielddoc"><p >Allows access by all. Implies, as well, at least as much access as <code>S_GROUP_ACCESS</code> and thus <code>S_USER_ACCESS</code>. </p>
</td></tr>
<tr><td class="fieldname"><a id="a2ec0bfdddb41a1ef0403e4bb8967705da6fba12db09e5bebfaa04f6372c41c2cf" name="a2ec0bfdddb41a1ef0403e4bb8967705da6fba12db09e5bebfaa04f6372c41c2cf"></a>S_END_SENTINEL&#160;</td><td class="fielddoc"><p >Sentinel: not a valid value. May be used to, e.g., size an <code>array&lt;&gt;</code> mapping from Permissions_level. </p>
</td></tr>
</table>

</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a id="a2bb38cee29dacbe56de5182221b45941" name="a2bb38cee29dacbe56de5182221b45941"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2bb38cee29dacbe56de5182221b45941">&#9670;&nbsp;</a></span>blob_data() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const uint8_t * ipc::util::blob_data </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespaceipc_1_1util.html#ae0be7edba7e30ffa3f8b742af621f2ab">Blob_const</a> &amp;&#160;</td>
          <td class="paramname"><em>blob</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Syntactic-sugary helper that returns pointer to first byte in an immutable buffer, as <code>const uint8_t*</code>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">blob</td><td>The buffer. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>See above. </dd></dl>

</div>
</div>
<a id="af38a66554a822a470667967c56083e3b" name="af38a66554a822a470667967c56083e3b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af38a66554a822a470667967c56083e3b">&#9670;&nbsp;</a></span>blob_data() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint8_t * ipc::util::blob_data </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespaceipc_1_1util.html#a6cb62ae434900f3a8915b33ec5d61a96">Blob_mutable</a> &amp;&#160;</td>
          <td class="paramname"><em>blob</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Syntactic-sugary helper that returns pointer to first byte in a mutable buffer, as <code>uint8_t*</code>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">blob</td><td>The buffer. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>See above. </dd></dl>

</div>
</div>
<a id="aba4ae811264cbb7e664ce126b591cbc7" name="aba4ae811264cbb7e664ce126b591cbc7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aba4ae811264cbb7e664ce126b591cbc7">&#9670;&nbsp;</a></span>hash_value() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t hash_value </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classipc_1_1util_1_1Shared__name.html">Shared_name</a> &amp;&#160;</td>
          <td class="paramname"><em>val</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Hasher of <a class="el" href="classipc_1_1util_1_1Shared__name.html" title="String-wrapping abstraction representing a name uniquely distinguishing a kernel-persistent entity fr...">Shared_name</a> for boost.unordered et al. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">val</td><td>Object to hash. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>See above. </dd></dl>

</div>
</div>
<a id="ad3883df3081441d71a9a989073264b04" name="ad3883df3081441d71a9a989073264b04"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad3883df3081441d71a9a989073264b04">&#9670;&nbsp;</a></span>hash_value() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t hash_value </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structipc_1_1util_1_1Native__handle.html">Native_handle</a>&#160;</td>
          <td class="paramname"><em>val</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Hasher of <a class="el" href="structipc_1_1util_1_1Native__handle.html" title="A monolayer-thin wrapper around a native handle, a/k/a descriptor a/k/a FD.">Native_handle</a> for boost.unordered et al. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">val</td><td>Object to hash. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>See above. </dd></dl>

</div>
</div>
<a id="aaf94b5903f4e0aa2f2699867dd8971ef" name="aaf94b5903f4e0aa2f2699867dd8971ef"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaf94b5903f4e0aa2f2699867dd8971ef">&#9670;&nbsp;</a></span>operator!=() <span class="overload">[1/5]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool operator!= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classipc_1_1util_1_1Process__credentials.html">Process_credentials</a> &amp;&#160;</td>
          <td class="paramname"><em>val1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classipc_1_1util_1_1Process__credentials.html">Process_credentials</a> &amp;&#160;</td>
          <td class="paramname"><em>val2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Checks for by-value inequality between two <a class="el" href="classipc_1_1util_1_1Process__credentials.html" title="A process&#39;s credentials (PID, UID, GID as of this writing).">Process_credentials</a> objects. </p>
<p >process_invoked_as() does not participate in this and is not invoked.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">val1</td><td>Value to compare. </td></tr>
    <tr><td class="paramname">val2</td><td>Value to compare. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Whether at least one accessor compares unequal. </dd></dl>

</div>
</div>
<a id="aec185fc5e2e88206d1366de8ce42f732" name="aec185fc5e2e88206d1366de8ce42f732"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aec185fc5e2e88206d1366de8ce42f732">&#9670;&nbsp;</a></span>operator!=() <span class="overload">[2/5]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool ipc::util::operator!= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classipc_1_1util_1_1Shared__name.html">Shared_name</a> &amp;&#160;</td>
          <td class="paramname"><em>val1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classipc_1_1util_1_1Shared__name.html">Shared_name</a> &amp;&#160;</td>
          <td class="paramname"><em>val2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Negation of similar <code>==</code>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">val1</td><td>See <code>==</code>. </td></tr>
    <tr><td class="paramname">val2</td><td>See <code>==</code>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>See above. </dd></dl>

</div>
</div>
<a id="a0d9b586ec40d9dc3bc14915ef6d24cb7" name="a0d9b586ec40d9dc3bc14915ef6d24cb7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0d9b586ec40d9dc3bc14915ef6d24cb7">&#9670;&nbsp;</a></span>operator!=() <span class="overload">[3/5]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool ipc::util::operator!= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classipc_1_1util_1_1Shared__name.html">Shared_name</a> &amp;&#160;</td>
          <td class="paramname"><em>val1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceipc_1_1util.html#ae6ac47812a90d1287c61e0b7de7bc4f5">util::String_view</a>&#160;</td>
          <td class="paramname"><em>val2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Negation of similar <code>==</code>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">val1</td><td>See <code>==</code>. </td></tr>
    <tr><td class="paramname">val2</td><td>See <code>==</code>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>See above. </dd></dl>

</div>
</div>
<a id="aacbd7ee43d4912a8790a228dc7cf682d" name="aacbd7ee43d4912a8790a228dc7cf682d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aacbd7ee43d4912a8790a228dc7cf682d">&#9670;&nbsp;</a></span>operator!=() <span class="overload">[4/5]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool operator!= </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structipc_1_1util_1_1Native__handle.html">Native_handle</a>&#160;</td>
          <td class="paramname"><em>val1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structipc_1_1util_1_1Native__handle.html">Native_handle</a>&#160;</td>
          <td class="paramname"><em>val2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Negation of similar <code>==</code>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">val1</td><td>Object. </td></tr>
    <tr><td class="paramname">val2</td><td>Object. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>See above. </dd></dl>

</div>
</div>
<a id="a988ac1702279bd2b958464cd8ee7e81f" name="a988ac1702279bd2b958464cd8ee7e81f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a988ac1702279bd2b958464cd8ee7e81f">&#9670;&nbsp;</a></span>operator!=() <span class="overload">[5/5]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool ipc::util::operator!= </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespaceipc_1_1util.html#ae6ac47812a90d1287c61e0b7de7bc4f5">util::String_view</a>&#160;</td>
          <td class="paramname"><em>val1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classipc_1_1util_1_1Shared__name.html">Shared_name</a> &amp;&#160;</td>
          <td class="paramname"><em>val2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Negation of similar <code>==</code>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">val1</td><td>See <code>==</code>. </td></tr>
    <tr><td class="paramname">val2</td><td>See <code>==</code>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>See above. </dd></dl>

</div>
</div>
<a id="a096c71dede7bd5528215ac01a380a189" name="a096c71dede7bd5528215ac01a380a189"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a096c71dede7bd5528215ac01a380a189">&#9670;&nbsp;</a></span>operator+() <span class="overload">[1/5]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classipc_1_1util_1_1Shared__name.html">Shared_name</a> operator+ </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>raw_src1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classipc_1_1util_1_1Shared__name.html">Shared_name</a> &amp;&#160;</td>
          <td class="paramname"><em>src2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns new object equal to <code>Shared_name(src2)</code> with <code>raw_src1</code> pre-pended to it. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">raw_src1</td><td>String to precede the appended <code>src2</code>. </td></tr>
    <tr><td class="paramname">src2</td><td>Object to append. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>See above. </dd></dl>

</div>
</div>
<a id="af61b02fd66b67aeed5a803ca47e52973" name="af61b02fd66b67aeed5a803ca47e52973"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af61b02fd66b67aeed5a803ca47e52973">&#9670;&nbsp;</a></span>operator+() <span class="overload">[2/5]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classipc_1_1util_1_1Shared__name.html">Shared_name</a> operator+ </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classipc_1_1util_1_1Shared__name.html">Shared_name</a> &amp;&#160;</td>
          <td class="paramname"><em>src1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>raw_src2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns new object equal to <code>Shared_name(src1) += raw_src2</code>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">src1</td><td>Object to precede the appended <code>raw_src2</code>. </td></tr>
    <tr><td class="paramname">raw_src2</td><td>String to append. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>See above. </dd></dl>

</div>
</div>
<a id="a54dc5077333284fda9e8d2df8b0e9b91" name="a54dc5077333284fda9e8d2df8b0e9b91"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a54dc5077333284fda9e8d2df8b0e9b91">&#9670;&nbsp;</a></span>operator+() <span class="overload">[3/5]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classipc_1_1util_1_1Shared__name.html">Shared_name</a> operator+ </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classipc_1_1util_1_1Shared__name.html">Shared_name</a> &amp;&#160;</td>
          <td class="paramname"><em>src1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classipc_1_1util_1_1Shared__name.html">Shared_name</a> &amp;&#160;</td>
          <td class="paramname"><em>src2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns new object equal to <code>Shared_name(src1) += src2</code>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">src1</td><td>Object to precede the appended <code>src2</code>. </td></tr>
    <tr><td class="paramname">src2</td><td>Object to append. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>See above. </dd></dl>

</div>
</div>
<a id="a52b2ba03d5ace7389991bb5d31b9fa59" name="a52b2ba03d5ace7389991bb5d31b9fa59"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a52b2ba03d5ace7389991bb5d31b9fa59">&#9670;&nbsp;</a></span>operator+() <span class="overload">[4/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Source &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classipc_1_1util_1_1Shared__name.html">Shared_name</a> operator+ </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classipc_1_1util_1_1Shared__name.html">Shared_name</a> &amp;&#160;</td>
          <td class="paramname"><em>src1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Source &amp;&#160;</td>
          <td class="paramname"><em>raw_src2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns new object equal to <code>Shared_name(src1) += raw_src2</code>. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Source</td><td>See <a class="el" href="classipc_1_1util_1_1Shared__name.html#a1bcac1c10e01ba11dcc437b3c32bbe6c" title="Appends the given other Shared_name.">Shared_name::operator+=()</a> similar overload. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">src1</td><td>Object to precede the appended <code>raw_src2</code>. </td></tr>
    <tr><td class="paramname">raw_src2</td><td>String to append. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>See above. </dd></dl>

</div>
</div>
<a id="a1f1a40877cc08b287f8f3c7e7f663782" name="a1f1a40877cc08b287f8f3c7e7f663782"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1f1a40877cc08b287f8f3c7e7f663782">&#9670;&nbsp;</a></span>operator+() <span class="overload">[5/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Source &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classipc_1_1util_1_1Shared__name.html">Shared_name</a> operator+ </td>
          <td>(</td>
          <td class="paramtype">const Source &amp;&#160;</td>
          <td class="paramname"><em>raw_src1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classipc_1_1util_1_1Shared__name.html">Shared_name</a> &amp;&#160;</td>
          <td class="paramname"><em>src2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns new object equal to <code>Shared_name(src2)</code> with <code>raw_src1</code> pre-pended to it. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Source</td><td>See <a class="el" href="classipc_1_1util_1_1Shared__name.html#a1bcac1c10e01ba11dcc437b3c32bbe6c" title="Appends the given other Shared_name.">Shared_name::operator+=()</a> similar overload. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">raw_src1</td><td>String to precede the appended <code>src2</code>. </td></tr>
    <tr><td class="paramname">src2</td><td>Object to append. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>See above. </dd></dl>

</div>
</div>
<a id="a7f2bead5935309c2f760645fe46ddd71" name="a7f2bead5935309c2f760645fe46ddd71"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7f2bead5935309c2f760645fe46ddd71">&#9670;&nbsp;</a></span>operator/() <span class="overload">[1/5]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classipc_1_1util_1_1Shared__name.html">Shared_name</a> operator/ </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>raw_src1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classipc_1_1util_1_1Shared__name.html">Shared_name</a> &amp;&#160;</td>
          <td class="paramname"><em>src2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns new object equal to <code>Shared_name(raw_src1) /= src2</code>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">raw_src1</td><td>String to precede the appended separator and <code>src2</code>. </td></tr>
    <tr><td class="paramname">src2</td><td>Object to append after separator. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>See above. </dd></dl>

</div>
</div>
<a id="aa61c6b31c5c4e241c97f06a4d38c76c4" name="aa61c6b31c5c4e241c97f06a4d38c76c4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa61c6b31c5c4e241c97f06a4d38c76c4">&#9670;&nbsp;</a></span>operator/() <span class="overload">[2/5]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classipc_1_1util_1_1Shared__name.html">Shared_name</a> operator/ </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classipc_1_1util_1_1Shared__name.html">Shared_name</a> &amp;&#160;</td>
          <td class="paramname"><em>src1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>raw_src2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns new object equal to <code>Shared_name(src1) /= raw_src2</code>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">src1</td><td>Object to precede the appended separator and <code>raw_src2</code>. </td></tr>
    <tr><td class="paramname">raw_src2</td><td>String to append after separator. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>See above. </dd></dl>

</div>
</div>
<a id="a15ea67c1855a678f7e948b24ccf2c1cd" name="a15ea67c1855a678f7e948b24ccf2c1cd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a15ea67c1855a678f7e948b24ccf2c1cd">&#9670;&nbsp;</a></span>operator/() <span class="overload">[3/5]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classipc_1_1util_1_1Shared__name.html">Shared_name</a> operator/ </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classipc_1_1util_1_1Shared__name.html">Shared_name</a> &amp;&#160;</td>
          <td class="paramname"><em>src1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classipc_1_1util_1_1Shared__name.html">Shared_name</a> &amp;&#160;</td>
          <td class="paramname"><em>src2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns new object equal to <code>Shared_name(src1) /= src2</code>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">src1</td><td>Object to precede the appended separator and <code>src2</code>. </td></tr>
    <tr><td class="paramname">src2</td><td>Object to append after separator. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>See above. </dd></dl>

</div>
</div>
<a id="a910207a2da57b61cee4a22899e239dc2" name="a910207a2da57b61cee4a22899e239dc2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a910207a2da57b61cee4a22899e239dc2">&#9670;&nbsp;</a></span>operator/() <span class="overload">[4/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Source &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classipc_1_1util_1_1Shared__name.html">Shared_name</a> operator/ </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classipc_1_1util_1_1Shared__name.html">Shared_name</a> &amp;&#160;</td>
          <td class="paramname"><em>src1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Source &amp;&#160;</td>
          <td class="paramname"><em>raw_src2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns new object equal to <code>Shared_name(src1) /= raw_src2</code>. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Source</td><td>See <a class="el" href="classipc_1_1util_1_1Shared__name.html#a956fdac1bb4cfab414b30091bec43f70" title="Appends a folder separator followed by the given other Shared_name.">Shared_name::operator/=()</a> similar overload. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">src1</td><td>Object to precede the appended separator and <code>raw_src2</code>. </td></tr>
    <tr><td class="paramname">raw_src2</td><td>String to append after separator. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>See above. </dd></dl>

</div>
</div>
<a id="a462b81d34ba23c968f63d9805fa74538" name="a462b81d34ba23c968f63d9805fa74538"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a462b81d34ba23c968f63d9805fa74538">&#9670;&nbsp;</a></span>operator/() <span class="overload">[5/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Source &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classipc_1_1util_1_1Shared__name.html">Shared_name</a> operator/ </td>
          <td>(</td>
          <td class="paramtype">const Source &amp;&#160;</td>
          <td class="paramname"><em>raw_src1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classipc_1_1util_1_1Shared__name.html">Shared_name</a> &amp;&#160;</td>
          <td class="paramname"><em>src2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns new object equal to <code>Shared_name(raw_src1) /= src2</code>. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Source</td><td>See <a class="el" href="classipc_1_1util_1_1Shared__name.html#a956fdac1bb4cfab414b30091bec43f70" title="Appends a folder separator followed by the given other Shared_name.">Shared_name::operator/=()</a> similar overload. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">raw_src1</td><td>String to precede the appended separator and <code>src2</code>. </td></tr>
    <tr><td class="paramname">src2</td><td>Object to append after separator. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>See above. </dd></dl>

</div>
</div>
<a id="aea456ff91117633e731804a894aa94da" name="aea456ff91117633e731804a894aa94da"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aea456ff91117633e731804a894aa94da">&#9670;&nbsp;</a></span>operator&lt;() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool ipc::util::operator&lt; </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classipc_1_1util_1_1Shared__name.html">Shared_name</a> &amp;&#160;</td>
          <td class="paramname"><em>val1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classipc_1_1util_1_1Shared__name.html">Shared_name</a> &amp;&#160;</td>
          <td class="paramname"><em>val2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns <code>true</code> if and only if <code>val1.str() &lt; val2.str()</code>. </p>
<p >Enables use of <a class="el" href="classipc_1_1util_1_1Shared__name.html" title="String-wrapping abstraction representing a name uniquely distinguishing a kernel-persistent entity fr...">Shared_name</a> in an <code>std::map</code> without jumping through any special hoops.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">val1</td><td>Object to compare. </td></tr>
    <tr><td class="paramname">val2</td><td>Object to compare. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>See above. </dd></dl>

</div>
</div>
<a id="a6ff4b35d8fbbe2eb6266f3a7b0f07c49" name="a6ff4b35d8fbbe2eb6266f3a7b0f07c49"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6ff4b35d8fbbe2eb6266f3a7b0f07c49">&#9670;&nbsp;</a></span>operator&lt;() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool operator&lt; </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structipc_1_1util_1_1Native__handle.html">Native_handle</a>&#160;</td>
          <td class="paramname"><em>val1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structipc_1_1util_1_1Native__handle.html">Native_handle</a>&#160;</td>
          <td class="paramname"><em>val2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns a less-than comparison of two <a class="el" href="structipc_1_1util_1_1Native__handle.html" title="A monolayer-thin wrapper around a native handle, a/k/a descriptor a/k/a FD.">Native_handle</a> objects, with the usual total ordering guarantees. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">val1</td><td>Left-hand side object. </td></tr>
    <tr><td class="paramname">val2</td><td>Right-hand side object. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Whether left side is considered strictly less-than right side. </dd></dl>

</div>
</div>
<a id="a28030c32e9c66f5c2862cbc6998885c7" name="a28030c32e9c66f5c2862cbc6998885c7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a28030c32e9c66f5c2862cbc6998885c7">&#9670;&nbsp;</a></span>operator&lt;&lt;() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::ostream &amp; operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>os</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structipc_1_1util_1_1Native__handle.html">Native_handle</a> &amp;&#160;</td>
          <td class="paramname"><em>val</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Prints string representation of the given <a class="el" href="structipc_1_1util_1_1Native__handle.html" title="A monolayer-thin wrapper around a native handle, a/k/a descriptor a/k/a FD.">Native_handle</a> to the given <code>ostream</code>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">os</td><td>Stream to which to write. </td></tr>
    <tr><td class="paramname">val</td><td>Object to serialize. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>os</code>. </dd></dl>

</div>
</div>
<a id="a9da92514406dc1fc61f5a561c9b5aee9" name="a9da92514406dc1fc61f5a561c9b5aee9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9da92514406dc1fc61f5a561c9b5aee9">&#9670;&nbsp;</a></span>operator&lt;&lt;() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::ostream &amp; operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>os</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classipc_1_1util_1_1Process__credentials.html">Process_credentials</a> &amp;&#160;</td>
          <td class="paramname"><em>val</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Prints string representation of the given <a class="el" href="classipc_1_1util_1_1Process__credentials.html" title="A process&#39;s credentials (PID, UID, GID as of this writing).">util::Process_credentials</a> to the given <code>ostream</code>. </p>
<p >process_invoked_as() does not participate in this and is not invoked; you may query that information if desired manually; just remember <code>val.process_id()</code> must be live at the time for it to work.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">os</td><td>Stream to which to write. </td></tr>
    <tr><td class="paramname">val</td><td>Object to serialize. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>os</code>. </dd></dl>

</div>
</div>
<a id="af7728c93fdf29479bbb2482e02f05cbf" name="af7728c93fdf29479bbb2482e02f05cbf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af7728c93fdf29479bbb2482e02f05cbf">&#9670;&nbsp;</a></span>operator&lt;&lt;() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::ostream &amp; operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>os</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classipc_1_1util_1_1Shared__name.html">Shared_name</a> &amp;&#160;</td>
          <td class="paramname"><em>val</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Prints embellished string representation of the given <a class="el" href="classipc_1_1util_1_1Shared__name.html" title="String-wrapping abstraction representing a name uniquely distinguishing a kernel-persistent entity fr...">Shared_name</a> to the given <code>ostream</code>. </p>
<dl class="section warning"><dt>Warning</dt><dd>This is <em>not</em> equivalent to writing <a class="el" href="classipc_1_1util_1_1Shared__name.html#ae89e1e061f87ffe0288514e254837595" title="Returns (sans copying) ref to immutable entire wrapped name string, suitable to pass into sys calls w...">Shared_name::str()</a>; as of this writing it includes not just <code>str()</code> but also the number of characters in it as a decimal and a separator, for convenience in test/debug, to visually detect names approaching certain length limits. If you wish to output <code>val.str()</code>, then output... well... <code>val.str()</code>.</dd></dl>
<dl class="todo"><dt><b><a class="el" href="todo.html#_todo000013">Todo:</a></b></dt><dd>Does <a class="el" href="classipc_1_1util_1_1Shared__name.html" title="String-wrapping abstraction representing a name uniquely distinguishing a kernel-persistent entity fr...">Shared_name</a> <code>operator&gt;&gt;</code> and <code>operator&lt;&lt;</code> being asymmetrical get one into trouble when using <a class="el" href="classipc_1_1util_1_1Shared__name.html" title="String-wrapping abstraction representing a name uniquely distinguishing a kernel-persistent entity fr...">Shared_name</a> with boost.program_options (or <code>flow::cfg</code> which is built on top of it)? Look into it. It may be necessary to make <code>operator&lt;&lt;</code> equal to that of <code>ostream &lt;&lt; string</code> after all; though the added niceties of the current <code>&lt;&lt;</code> semantics may still at least be available via some explicit accessor.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">os</td><td>Stream to which to write. </td></tr>
    <tr><td class="paramname">val</td><td>Object to serialize. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>os</code>. </dd></dl>

</div>
</div>
<a id="a4ccdab04a79159f82d7ade8136a2eeb2" name="a4ccdab04a79159f82d7ade8136a2eeb2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4ccdab04a79159f82d7ade8136a2eeb2">&#9670;&nbsp;</a></span>operator==() <span class="overload">[1/5]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool operator== </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classipc_1_1util_1_1Process__credentials.html">Process_credentials</a> &amp;&#160;</td>
          <td class="paramname"><em>val1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classipc_1_1util_1_1Process__credentials.html">Process_credentials</a> &amp;&#160;</td>
          <td class="paramname"><em>val2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Checks for by-value equality between two <a class="el" href="classipc_1_1util_1_1Process__credentials.html" title="A process&#39;s credentials (PID, UID, GID as of this writing).">Process_credentials</a> objects. </p>
<p >process_invoked_as() does not participate in this and is not invoked.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">val1</td><td>Value to compare. </td></tr>
    <tr><td class="paramname">val2</td><td>Value to compare. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Whether the accessors all compare equal. </dd></dl>

</div>
</div>
<a id="adad98b6935e58bdc92dfcf57bf60345e" name="adad98b6935e58bdc92dfcf57bf60345e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adad98b6935e58bdc92dfcf57bf60345e">&#9670;&nbsp;</a></span>operator==() <span class="overload">[2/5]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool ipc::util::operator== </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classipc_1_1util_1_1Shared__name.html">Shared_name</a> &amp;&#160;</td>
          <td class="paramname"><em>val1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classipc_1_1util_1_1Shared__name.html">Shared_name</a> &amp;&#160;</td>
          <td class="paramname"><em>val2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns <code>true</code> if and only if <code>val1.str() == val2.str()</code>. </p>
<p >Caution: this does not execute normalize() or anything like that.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">val1</td><td>Object to compare. </td></tr>
    <tr><td class="paramname">val2</td><td>Object to compare. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>See above. </dd></dl>

</div>
</div>
<a id="a5023285f7dd8a117686f0ee986e685cb" name="a5023285f7dd8a117686f0ee986e685cb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5023285f7dd8a117686f0ee986e685cb">&#9670;&nbsp;</a></span>operator==() <span class="overload">[3/5]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool ipc::util::operator== </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classipc_1_1util_1_1Shared__name.html">Shared_name</a> &amp;&#160;</td>
          <td class="paramname"><em>val1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceipc_1_1util.html#ae6ac47812a90d1287c61e0b7de7bc4f5">util::String_view</a>&#160;</td>
          <td class="paramname"><em>val2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns <code>true</code> if and only if <code>val1.str() == string(val2)</code>. </p>
<p >Caution: this does not execute normalize() or anything like that.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">val1</td><td>Object to compare. </td></tr>
    <tr><td class="paramname">val2</td><td>String to compare. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>See above. </dd></dl>

</div>
</div>
<a id="ae4b4126f841ef060cdae15998e48691c" name="ae4b4126f841ef060cdae15998e48691c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae4b4126f841ef060cdae15998e48691c">&#9670;&nbsp;</a></span>operator==() <span class="overload">[4/5]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool operator== </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structipc_1_1util_1_1Native__handle.html">Native_handle</a>&#160;</td>
          <td class="paramname"><em>val1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structipc_1_1util_1_1Native__handle.html">Native_handle</a>&#160;</td>
          <td class="paramname"><em>val2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns <code>true</code> if and only if the two <a class="el" href="structipc_1_1util_1_1Native__handle.html" title="A monolayer-thin wrapper around a native handle, a/k/a descriptor a/k/a FD.">Native_handle</a> objects are the same underlying handle. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">val1</td><td>Object. </td></tr>
    <tr><td class="paramname">val2</td><td>Object. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>See above. </dd></dl>

</div>
</div>
<a id="a97a7c8e6330909a1371134a7bdcea788" name="a97a7c8e6330909a1371134a7bdcea788"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a97a7c8e6330909a1371134a7bdcea788">&#9670;&nbsp;</a></span>operator==() <span class="overload">[5/5]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool ipc::util::operator== </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespaceipc_1_1util.html#ae6ac47812a90d1287c61e0b7de7bc4f5">util::String_view</a>&#160;</td>
          <td class="paramname"><em>val1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classipc_1_1util_1_1Shared__name.html">Shared_name</a> &amp;&#160;</td>
          <td class="paramname"><em>val2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns <code>true</code> if and only if <code>string(val1) == val2.str()</code>. </p>
<p >Caution: this does not execute normalize() or anything like that.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">val1</td><td>String to compare. </td></tr>
    <tr><td class="paramname">val2</td><td>Object to compare. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>See above. </dd></dl>

</div>
</div>
<a id="adfd8805e0d37556102cad7b191fee9a3" name="adfd8805e0d37556102cad7b191fee9a3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adfd8805e0d37556102cad7b191fee9a3">&#9670;&nbsp;</a></span>operator&gt;&gt;()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::istream &amp; operator&gt;&gt; </td>
          <td>(</td>
          <td class="paramtype">std::istream &amp;&#160;</td>
          <td class="paramname"><em>is</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classipc_1_1util_1_1Shared__name.html">Shared_name</a> &amp;&#160;</td>
          <td class="paramname"><em>val</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Reads <a class="el" href="classipc_1_1util_1_1Shared__name.html" title="String-wrapping abstraction representing a name uniquely distinguishing a kernel-persistent entity fr...">Shared_name</a> from the given <code>istream</code>; equivalent to reading <code>string</code> into <a class="el" href="classipc_1_1util_1_1Shared__name.html#ae89e1e061f87ffe0288514e254837595" title="Returns (sans copying) ref to immutable entire wrapped name string, suitable to pass into sys calls w...">Shared_name::str()</a>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">is</td><td>Stream to read. </td></tr>
    <tr><td class="paramname">val</td><td>Object to which to deserialize. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>is</code>. </dd></dl>

</div>
</div>
<a id="a924cd56daf7eeaa0b07edb352367f9ec" name="a924cd56daf7eeaa0b07edb352367f9ec"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a924cd56daf7eeaa0b07edb352367f9ec">&#9670;&nbsp;</a></span>process_running()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool ipc::util::process_running </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespaceipc_1_1util.html#a0c44028a45451ebf21f6af8e806b2682">process_id_t</a>&#160;</td>
          <td class="paramname"><em>process_id</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns <code>true</code> if and only if the given process (by PID) is reported as running by the OS. </p>
<p >Caution: It may be running, but it may be a zombie; and/or it may be running now but dead shortly after this function returns. Use defensively.</p>
<p >Implementation: It invokes POSIX <code>kill()</code> with the fake zero signal; this indicates the process <em>can</em> be signaled and therefore exists.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">process_id</td><td>The process ID of the process in question. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>See above. </dd></dl>

</div>
</div>
<a id="a150051ee7e308ba7c9269b2d1e2c6c37" name="a150051ee7e308ba7c9269b2d1e2c6c37"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a150051ee7e308ba7c9269b2d1e2c6c37">&#9670;&nbsp;</a></span>remove_each_persistent_if()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Persistent_object , typename Filter_func &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">unsigned int ipc::util::remove_each_persistent_if </td>
          <td>(</td>
          <td class="paramtype">flow::log::Logger *&#160;</td>
          <td class="paramname"><em>logger_ptr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Filter_func &amp;&#160;</td>
          <td class="paramname"><em>filter_func</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Utility that invokes <code>Persistent_object::for_each_persistent(name_prefix_or_empty)</code> and synchronously invokes <code>Persistent_object::remove_persistent()</code> on each resulting item that passes the given filter, where <code>Persistent_object</code> is a type that handles objects &ndash; such as SHM pools or POSIX MQs &ndash; with kernel-persistent semantics. </p>
<p >The number of items removed (without any error) is returned. The nature of any error(s) encountered by individual <code>remove_persistent()</code> calls is ignored (not returned in any way) except for logging.</p>
<p >This "forgiving" error emission behavior is sufficient in many cases. If you require finer control over this please use <code>Persistent_object::for_each_persistent()</code> and <code>Persistent_object::remove_persistent()</code> plus your own handling of the failure thereof in your custom <code>handle_name_func()</code>.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Persistent_object</td><td>See above. It must have <code>static</code> methods <code>for_each_persistent()</code> and <code>remove_persistent()</code> with semantics identical to, e.g., <a class="el" href="classipc_1_1shm_1_1classic_1_1Pool__arena.html" title="A SHM-classic interface around a single SHM pool with allocation-algorithm services by boost....">shm::classic::Pool_arena</a> versions of these methods. As of this writing this includes: <a class="el" href="classipc_1_1shm_1_1classic_1_1Pool__arena.html" title="A SHM-classic interface around a single SHM pool with allocation-algorithm services by boost....">shm::classic::Pool_arena</a>, <a class="el" href="classipc_1_1transport_1_1Persistent__mq__handle.html" title="A documentation-only concept defining the behavior of an object representing a light-weight handle to...">transport::Persistent_mq_handle</a> (concept), <a class="el" href="classipc_1_1transport_1_1Posix__mq__handle.html" title="Implements the Persistent_mq_handle concept by wrapping the POSIX message queue API (see man mq_overv...">transport::Posix_mq_handle</a>, <a class="el" href="classipc_1_1transport_1_1Bipc__mq__handle.html" title="Implements the Persistent_mq_handle concept by thinly wrapping bipc::message_queue,...">transport::Bipc_mq_handle</a> (its impls). </td></tr>
    <tr><td class="paramname">Filter_func</td><td>Function object with signature <code>bool F(const Shared_name&amp;)</code>, which should return <code>true</code> to delete, <code>false</code> to skip. For example it might simply check that <code>name</code> starts with a certain prefix (<a class="el" href="namespaceipc_1_1util.html#ad6be904bf1b0fe6659a11dec0fabbf6b" title="Utility that invokes remove_each_persistent_if() with the filter that returns true (yes,...">remove_each_persistent_with_name_prefix()</a> uses this), or it might check whether the creating process &ndash; whose PID might be encoded in <code>name</code> by some convention (e.g., see <a class="el" href="namespaceipc_1_1session.html" title="Flow-IPC module providing the broad lifecycle and shared-resource organization â€“ via the session conc...">ipc::session</a>) &ndash; is alive (<a class="el" href="namespaceipc_1_1util.html#a924cd56daf7eeaa0b07edb352367f9ec" title="Returns true if and only if the given process (by PID) is reported as running by the OS.">util::process_running()</a>). </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">logger_ptr</td><td>Logger to use for subsequently logging. </td></tr>
    <tr><td class="paramname">filter_func</td><td>See <code>Filter_func</code> above. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The number of successful <code>Persistent_object::remove_persistent()</code> calls invoked (might be zero). </dd></dl>

</div>
</div>
<a id="ad6be904bf1b0fe6659a11dec0fabbf6b" name="ad6be904bf1b0fe6659a11dec0fabbf6b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad6be904bf1b0fe6659a11dec0fabbf6b">&#9670;&nbsp;</a></span>remove_each_persistent_with_name_prefix()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Persistent_object &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">unsigned int ipc::util::remove_each_persistent_with_name_prefix </td>
          <td>(</td>
          <td class="paramtype">flow::log::Logger *&#160;</td>
          <td class="paramname"><em>logger_ptr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classipc_1_1util_1_1Shared__name.html">Shared_name</a> &amp;&#160;</td>
          <td class="paramname"><em>name_prefix_or_empty</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Utility that invokes <a class="el" href="namespaceipc_1_1util.html#a150051ee7e308ba7c9269b2d1e2c6c37" title="Utility that invokes Persistent_object::for_each_persistent(name_prefix_or_empty) and synchronously i...">remove_each_persistent_if()</a> with the filter that returns <code>true</code> (yes, remove) if and only if the item's name optionally matches a given <a class="el" href="classipc_1_1util_1_1Shared__name.html" title="String-wrapping abstraction representing a name uniquely distinguishing a kernel-persistent entity fr...">Shared_name</a> prefix. </p>
<p >(Optional in that supplying an <code>.empty()</code> prefix deletes all items.)</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Persistent_object</td><td>See <a class="el" href="namespaceipc_1_1util.html#a150051ee7e308ba7c9269b2d1e2c6c37" title="Utility that invokes Persistent_object::for_each_persistent(name_prefix_or_empty) and synchronously i...">remove_each_persistent_if()</a>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">logger_ptr</td><td>See <a class="el" href="namespaceipc_1_1util.html#a150051ee7e308ba7c9269b2d1e2c6c37" title="Utility that invokes Persistent_object::for_each_persistent(name_prefix_or_empty) and synchronously i...">remove_each_persistent_if()</a>. </td></tr>
    <tr><td class="paramname">name_prefix_or_empty</td><td>An object is removed only if its name starts with this value. This filter is skipped if the value is <code>.empty()</code>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>See <a class="el" href="namespaceipc_1_1util.html#a150051ee7e308ba7c9269b2d1e2c6c37" title="Utility that invokes Persistent_object::for_each_persistent(name_prefix_or_empty) and synchronously i...">remove_each_persistent_if()</a>. </dd></dl>

</div>
</div>
<a id="abbba79fcaee378f433e7ce3093e5c435" name="abbba79fcaee378f433e7ce3093e5c435"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abbba79fcaee378f433e7ce3093e5c435">&#9670;&nbsp;</a></span>set_resource_permissions() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ipc::util::set_resource_permissions </td>
          <td>(</td>
          <td class="paramtype">flow::log::Logger *&#160;</td>
          <td class="paramname"><em>logger_ptr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const fs::path &amp;&#160;</td>
          <td class="paramname"><em>path</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespaceipc_1_1util.html#a1b398ae730d1e6040687cb2397115152">Permissions</a> &amp;&#160;</td>
          <td class="paramname"><em>perms</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceipc.html#aa3192e586cc45d3e7c22463bf2760f89">Error_code</a> *&#160;</td>
          <td class="paramname"><em>err_code</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Utility that sets the permissions of the given resource (at the supplied file system path) to specified POSIX value. </p>
<p >If the resource cannot be accessed (not found, permissions...) that system Error_code shall be emitted.</p>
<h3>Rationale</h3>
<p >It may seem unnecessary, particularly given that it sometimes (in our internal code, but I mention it publicly for exposition purposes) placed right after the creation of the resource (file, SHM pool, POSIX MQ, shared mutex, etc.) &ndash; where the same <code>perms</code> is supplied to the creation-API, whichever is applicable. The reason is that those APIs tend to make the corresponding OS call (e.g., <code>open()</code>) which is bound by the "process umask" in POSIX/Linux; so for example if it's set to the typical 022 (octal), then it's impossible to make the resource group- or all-writable, regardless of <code>perms</code>. <a class="el" href="namespaceipc_1_1util.html#abbba79fcaee378f433e7ce3093e5c435" title="Utility that sets the permissions of the given resource (at the supplied file system path) to specifi...">set_resource_permissions()</a> uses a technique that bypasses the umask thing. Note that it does not make any calls to change the umask to accomplish this.</p>
<p >Note 1: Sometimes there is not even the creation-API argument for <code>perms</code>; in which case the rationale is even more straightforward.</p>
<p >Note 2: Sometimes there <em>is</em> that API... and (namely in Boost.ipc at least) they actually took care to do this (what we do here) themselves (via <code>fchmod()</code> and such)... so we don't need to; in fact I (ygoldfel) treated it as valuable confirmation of the correctness of this maneuver.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">logger_ptr</td><td>Logger to use for logging (WARNING, on error only). Caller can themselves log further info if desired. </td></tr>
    <tr><td class="paramname">path</td><td>Path to resource. Symlinks are followed, and the target is the resource in question (not the symlink). </td></tr>
    <tr><td class="paramname">perms</td><td>See other overload. </td></tr>
    <tr><td class="paramname">err_code</td><td>See <code>flow::Error_code</code> docs for error reporting semantics. <a class="el" href="namespaceipc.html#aa3192e586cc45d3e7c22463bf2760f89" title="Short-hand for boost.interprocess namespace.">Error_code</a> generated: see other overload; note that in addition file-not-found and the like are possible errors (in fact arguably the likeliest). </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="af8b2f5a0cd9fe9db4511c9a3e685b6ae" name="af8b2f5a0cd9fe9db4511c9a3e685b6ae"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af8b2f5a0cd9fe9db4511c9a3e685b6ae">&#9670;&nbsp;</a></span>set_resource_permissions() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ipc::util::set_resource_permissions </td>
          <td>(</td>
          <td class="paramtype">flow::log::Logger *&#160;</td>
          <td class="paramname"><em>logger_ptr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structipc_1_1util_1_1Native__handle.html">Native_handle</a>&#160;</td>
          <td class="paramname"><em>handle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespaceipc_1_1util.html#a1b398ae730d1e6040687cb2397115152">Permissions</a> &amp;&#160;</td>
          <td class="paramname"><em>perms</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceipc.html#aa3192e586cc45d3e7c22463bf2760f89">Error_code</a> *&#160;</td>
          <td class="paramname"><em>err_code</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Identical to the other <a class="el" href="namespaceipc_1_1util.html#abbba79fcaee378f433e7ce3093e5c435" title="Utility that sets the permissions of the given resource (at the supplied file system path) to specifi...">set_resource_permissions()</a> overload but operates on a pre-opened <a class="el" href="structipc_1_1util_1_1Native__handle.html" title="A monolayer-thin wrapper around a native handle, a/k/a descriptor a/k/a FD.">Native_handle</a> (a/k/a handle, socket, file descriptor) to the resource in question. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">logger_ptr</td><td>See other overload. </td></tr>
    <tr><td class="paramname">handle</td><td>See above. <code>handle.null() == true</code> causes undefined behavior (assertion may trip). Closed/invalid/etc. handle will yield civilized Error_code emission. </td></tr>
    <tr><td class="paramname">perms</td><td>See other overload. </td></tr>
    <tr><td class="paramname">err_code</td><td>See <code>flow::Error_code</code> docs for error reporting semantics. <a class="el" href="namespaceipc.html#aa3192e586cc45d3e7c22463bf2760f89" title="Short-hand for boost.interprocess namespace.">Error_code</a> generated: system error codes if permissions cannot be set (invalid descriptor, un-opened descriptor, etc.). </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="abda2ce5bcdbc26ca63d667b87818439c" name="abda2ce5bcdbc26ca63d667b87818439c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abda2ce5bcdbc26ca63d667b87818439c">&#9670;&nbsp;</a></span>shared_resource_permissions()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespaceipc_1_1util.html#a1b398ae730d1e6040687cb2397115152">Permissions</a> ipc::util::shared_resource_permissions </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespaceipc_1_1util.html#a2ec0bfdddb41a1ef0403e4bb8967705d">Permissions_level</a>&#160;</td>
          <td class="paramname"><em>permissions_lvl</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Maps general Permissions_level specifier to low-level <a class="el" href="namespaceipc_1_1util.html#a1b398ae730d1e6040687cb2397115152" title="Short-hand for Unix (POSIX) permissions class.">Permissions</a> value, when the underlying resource is in the file-system and is either accessible (read-write in terms of file system) or inaccessible. </p>
<p >Examples of such resources are SHM pools (e.g., <a class="el" href="classipc_1_1shm_1_1classic_1_1Pool__arena.html" title="A SHM-classic interface around a single SHM pool with allocation-algorithm services by boost....">shm::classic::Pool_arena</a>), bipc MQs (<a class="el" href="classipc_1_1transport_1_1Bipc__mq__handle.html" title="Implements the Persistent_mq_handle concept by thinly wrapping bipc::message_queue,...">transport::Bipc_mq_handle</a>), POSIX MQs (<a class="el" href="classipc_1_1transport_1_1Posix__mq__handle.html" title="Implements the Persistent_mq_handle concept by wrapping the POSIX message queue API (see man mq_overv...">transport::Posix_mq_handle</a>).</p>
<p >Please do not confuse this setting with the read-only/read-write dichotomy potentially specified each time such a resource is opened for access (as is the case for SHM pools): the present mapping applies to a persistent protection in the file system, not at runtime at the code writer's discretion. The present permissions check is performed at opening time; the runtime writability check each time a datum is written into the resource.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">permissions_lvl</td><td>The value to translate. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The result. </dd></dl>

</div>
</div>
<a id="a9ea22a64cfbc6de66181c278ff5f6975" name="a9ea22a64cfbc6de66181c278ff5f6975"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9ea22a64cfbc6de66181c278ff5f6975">&#9670;&nbsp;</a></span>swap()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void swap </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classipc_1_1util_1_1Shared__name.html">Shared_name</a> &amp;&#160;</td>
          <td class="paramname"><em>val1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classipc_1_1util_1_1Shared__name.html">Shared_name</a> &amp;&#160;</td>
          <td class="paramname"><em>val2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Swaps two objects. </p>
<p >Constant-time. Suitable for standard ADL-swap pattern <code>using std::swap; swap(val1, val2);</code>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">val1</td><td>Object. </td></tr>
    <tr><td class="paramname">val2</td><td>Object. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Wed Jan 17 2024 23:43:10 for Flow-IPC by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.4
</small></address>
</body>
</html>
