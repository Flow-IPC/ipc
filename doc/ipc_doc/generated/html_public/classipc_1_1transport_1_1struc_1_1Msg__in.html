<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.9.4"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Flow-IPC: ipc::transport::struc::Msg_in&lt; Message_body, Struct_reader_config &gt; Class Template Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">Flow-IPC<span id="projectnumber">&#160;1.0</span>
   </div>
   <div id="projectbrief">Flow-IPC project: Public API.</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.4 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search",'Search','.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespaceipc.html">ipc</a></li><li class="navelem"><a class="el" href="namespaceipc_1_1transport.html">transport</a></li><li class="navelem"><a class="el" href="namespaceipc_1_1transport_1_1struc.html">struc</a></li><li class="navelem"><a class="el" href="classipc_1_1transport_1_1struc_1_1Msg__in.html">Msg_in</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-types">Public Types</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pro-types">Protected Types</a> &#124;
<a href="#pro-methods">Protected Member Functions</a> &#124;
<a href="#related">Related Functions</a> &#124;
<a href="classipc_1_1transport_1_1struc_1_1Msg__in-members.html">List of all members</a>  </div>
  <div class="headertitle"><div class="title">ipc::transport::struc::Msg_in&lt; Message_body, Struct_reader_config &gt; Class Template Reference</div></div>
</div><!--header-->
<div class="contents">

<p>A structured in-message <em>instance</em> suitable as received and emittable (to user) by <a class="el" href="classipc_1_1transport_1_1struc_1_1Channel.html" title="Owning and wrapping a pre-connected transport::Channel peer (an endpoint of an established channel ov...">struc::Channel</a>.  
 <a href="classipc_1_1transport_1_1struc_1_1Msg__in.html#details">More...</a></p>

<p><code>#include &lt;msg.hpp&gt;</code></p>

<p>Inherits boost::noncopyable.</p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-types" name="pub-types"></a>
Public Types</h2></td></tr>
<tr class="memitem:aa408e309fcb402c061d969742874ca6c"><td class="memItemLeft" align="right" valign="top"><a id="aa408e309fcb402c061d969742874ca6c" name="aa408e309fcb402c061d969742874ca6c"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>Body</b> = Message_body</td></tr>
<tr class="memdesc:aa408e309fcb402c061d969742874ca6c"><td class="mdescLeft">&#160;</td><td class="mdescRight">See <a class="el" href="classipc_1_1transport_1_1struc_1_1Channel.html#a27a273ed7e1aca34b721fea22c869a41" title="Short-hand for the Message_body template param, this is the capnp message schema transmissible over *...">struc::Channel::Msg_body</a>. <br /></td></tr>
<tr class="separator:aa408e309fcb402c061d969742874ca6c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6e21b165a0673138db44d86584dd5059"><td class="memItemLeft" align="right" valign="top"><a id="a6e21b165a0673138db44d86584dd5059" name="a6e21b165a0673138db44d86584dd5059"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>Body_reader</b> = typename Body::Reader</td></tr>
<tr class="memdesc:a6e21b165a0673138db44d86584dd5059"><td class="mdescLeft">&#160;</td><td class="mdescRight">Short-hand for capnp-generated read-only-accessing <code>Reader</code> nested class of <a class="el" href="classipc_1_1transport_1_1struc_1_1Msg__in.html#aa408e309fcb402c061d969742874ca6c" title="See struc::Channel::Msg_body.">Body</a>. See <a class="el" href="classipc_1_1transport_1_1struc_1_1Msg__in.html#a56fa38feb9c907ae3f0f1a6ff16dd32f" title="Methods.">body_root()</a>. <br /></td></tr>
<tr class="separator:a6e21b165a0673138db44d86584dd5059"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af8c335ada1b33fcc732047283e60177b"><td class="memItemLeft" align="right" valign="top"><a id="af8c335ada1b33fcc732047283e60177b" name="af8c335ada1b33fcc732047283e60177b"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>Reader_config</b> = Struct_reader_config</td></tr>
<tr class="memdesc:af8c335ada1b33fcc732047283e60177b"><td class="mdescLeft">&#160;</td><td class="mdescRight">See <a class="el" href="classipc_1_1transport_1_1struc_1_1Channel.html#ad3ff78f00b7f230562d713ec6cf8499c" title="Short-hand for the reader engine type.">struc::Channel::Reader_config</a>. <br /></td></tr>
<tr class="separator:af8c335ada1b33fcc732047283e60177b"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-methods" name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a234708ed176f270f6372536ba3571b9a"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classipc_1_1transport_1_1struc_1_1Msg__in.html#a234708ed176f270f6372536ba3571b9a">~Msg_in</a> ()</td></tr>
<tr class="memdesc:a234708ed176f270f6372536ba3571b9a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns resources, potentially including potentially significant RAM resources, taken before emitting to the user.  <a href="classipc_1_1transport_1_1struc_1_1Msg__in.html#a234708ed176f270f6372536ba3571b9a">More...</a><br /></td></tr>
<tr class="separator:a234708ed176f270f6372536ba3571b9a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a56fa38feb9c907ae3f0f1a6ff16dd32f"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classipc_1_1transport_1_1struc_1_1Msg__in.html#a6e21b165a0673138db44d86584dd5059">Body_reader</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classipc_1_1transport_1_1struc_1_1Msg__in.html#a56fa38feb9c907ae3f0f1a6ff16dd32f">body_root</a> () const</td></tr>
<tr class="memdesc:a56fa38feb9c907ae3f0f1a6ff16dd32f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Methods.  <a href="classipc_1_1transport_1_1struc_1_1Msg__in.html#a56fa38feb9c907ae3f0f1a6ff16dd32f">More...</a><br /></td></tr>
<tr class="separator:a56fa38feb9c907ae3f0f1a6ff16dd32f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aba0b83c9d8a7e8f782202406ca387e2c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespaceipc_1_1transport.html#a7ee4551983d9df16ec16a3139bac50e8">Native_handle</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classipc_1_1transport_1_1struc_1_1Msg__in.html#aba0b83c9d8a7e8f782202406ca387e2c">native_handle_or_null</a> () const</td></tr>
<tr class="memdesc:aba0b83c9d8a7e8f782202406ca387e2c"><td class="mdescLeft">&#160;</td><td class="mdescRight">The <a class="el" href="namespaceipc_1_1transport.html#a7ee4551983d9df16ec16a3139bac50e8" title="Convenience alias for the commonly used type util::Native_handle.">Native_handle</a> &ndash; potentially null meaning none &ndash; embedded in this message.  <a href="classipc_1_1transport_1_1struc_1_1Msg__in.html#aba0b83c9d8a7e8f782202406ca387e2c">More...</a><br /></td></tr>
<tr class="separator:aba0b83c9d8a7e8f782202406ca387e2c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4783bd852b1dcba1542e0cfe37205e9e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classipc_1_1transport_1_1struc_1_1Msg__in.html#a4783bd852b1dcba1542e0cfe37205e9e">to_ostream</a> (std::ostream *os) const</td></tr>
<tr class="memdesc:a4783bd852b1dcba1542e0cfe37205e9e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Prints string representation to the given <code>ostream</code>.  <a href="classipc_1_1transport_1_1struc_1_1Msg__in.html#a4783bd852b1dcba1542e0cfe37205e9e">More...</a><br /></td></tr>
<tr class="separator:a4783bd852b1dcba1542e0cfe37205e9e"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pro-types" name="pro-types"></a>
Protected Types</h2></td></tr>
<tr class="memitem:afdc86a45b50e9869329b11a1e576b172"><td class="memItemLeft" align="right" valign="top"><a id="afdc86a45b50e9869329b11a1e576b172" name="afdc86a45b50e9869329b11a1e576b172"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>Internal_msg_body_reader</b> = typename schema::detail::StructuredMessage::InternalMessageBody::Reader</td></tr>
<tr class="memdesc:afdc86a45b50e9869329b11a1e576b172"><td class="mdescLeft">&#160;</td><td class="mdescRight"><code>Reader</code> counterpart to Msg_mdt_out::Internal_msg_body_builder. <br /></td></tr>
<tr class="separator:afdc86a45b50e9869329b11a1e576b172"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aad2c43c92a286ab7d186d810631a1701"><td class="memItemLeft" align="right" valign="top"><a id="aad2c43c92a286ab7d186d810631a1701" name="aad2c43c92a286ab7d186d810631a1701"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>Mdt</b> = schema::detail::StructuredMessage</td></tr>
<tr class="memdesc:aad2c43c92a286ab7d186d810631a1701"><td class="mdescLeft">&#160;</td><td class="mdescRight">Same as <code>Msg_mdt_out::Body</code>. <br /></td></tr>
<tr class="separator:aad2c43c92a286ab7d186d810631a1701"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a99df8a99bc2ed106d6a03f807e6e5966"><td class="memItemLeft" align="right" valign="top"><a id="a99df8a99bc2ed106d6a03f807e6e5966" name="a99df8a99bc2ed106d6a03f807e6e5966"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>Mdt_reader</b> = typename Mdt::Reader</td></tr>
<tr class="memdesc:a99df8a99bc2ed106d6a03f807e6e5966"><td class="mdescLeft">&#160;</td><td class="mdescRight">Same as <code>Msg_mdt_out::Body_builder</code> but the <code>Reader</code> instead. <br /></td></tr>
<tr class="separator:a99df8a99bc2ed106d6a03f807e6e5966"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pro-methods" name="pro-methods"></a>
Protected Member Functions</h2></td></tr>
<tr class="memitem:ae3e6be294fbff87979a407a9e971da8a"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classipc_1_1transport_1_1struc_1_1Msg__in.html#ae3e6be294fbff87979a407a9e971da8a">Msg_in</a> (const <a class="el" href="classipc_1_1transport_1_1struc_1_1Msg__in.html#af8c335ada1b33fcc732047283e60177b">Reader_config</a> &amp;struct_reader_config)</td></tr>
<tr class="memdesc:ae3e6be294fbff87979a407a9e971da8a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructs a not-ready-for-public-consumption in-message which awaits serialization-storing segments to be added via <a class="el" href="classipc_1_1transport_1_1struc_1_1Msg__in.html#a3a1a75d7d7b108d46efa1892dd2571b7" title="Prior to deserialization_*() obtains a memory area max_sz bytes long into which the user may write-to...">add_serialization_segment()</a> and then finalized with <a class="el" href="classipc_1_1transport_1_1struc_1_1Msg__in.html#acd387ce27214601a70a0e1c6025075f1" title="To be invoked after exactly one successful add_serialization_segment() call (and that Blob being fill...">deserialize_mdt()</a> and possibly <a class="el" href="classipc_1_1transport_1_1struc_1_1Msg__in.html#acc5514d773db8edb0d8d0c3d52743a6a" title="To be invoked after deserialize_mdt() == N, and add_serialization_segment() was called N times (with ...">deserialize_body()</a>.  <a href="classipc_1_1transport_1_1struc_1_1Msg__in.html#ae3e6be294fbff87979a407a9e971da8a">More...</a><br /></td></tr>
<tr class="separator:ae3e6be294fbff87979a407a9e971da8a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac4f7c03e1080913f949b9b24b776dc6a"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classipc_1_1transport_1_1struc_1_1Msg__in.html#ac4f7c03e1080913f949b9b24b776dc6a">store_native_handle_or_null</a> (<a class="el" href="namespaceipc_1_1transport.html#a7ee4551983d9df16ec16a3139bac50e8">Native_handle</a> &amp;&amp;<a class="el" href="classipc_1_1transport_1_1struc_1_1Msg__in.html#aba0b83c9d8a7e8f782202406ca387e2c">native_handle_or_null</a>)</td></tr>
<tr class="memdesc:ac4f7c03e1080913f949b9b24b776dc6a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Store the <a class="el" href="namespaceipc_1_1transport.html#a7ee4551983d9df16ec16a3139bac50e8" title="Convenience alias for the commonly used type util::Native_handle.">Native_handle</a> (potentially <code>.null()</code>, meaning none) in this in-message.  <a href="classipc_1_1transport_1_1struc_1_1Msg__in.html#ac4f7c03e1080913f949b9b24b776dc6a">More...</a><br /></td></tr>
<tr class="separator:ac4f7c03e1080913f949b9b24b776dc6a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3a1a75d7d7b108d46efa1892dd2571b7"><td class="memItemLeft" align="right" valign="top">flow::util::Blob *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classipc_1_1transport_1_1struc_1_1Msg__in.html#a3a1a75d7d7b108d46efa1892dd2571b7">add_serialization_segment</a> (size_t max_sz)</td></tr>
<tr class="memdesc:a3a1a75d7d7b108d46efa1892dd2571b7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Prior to <code>deserialization_*()</code> obtains a memory area <code>max_sz</code> bytes long into which the user may write-to until the next <a class="el" href="classipc_1_1transport_1_1struc_1_1Msg__in.html#a3a1a75d7d7b108d46efa1892dd2571b7" title="Prior to deserialization_*() obtains a memory area max_sz bytes long into which the user may write-to...">add_serialization_segment()</a>, <code>deserialization_*()</code>, or dtor call (whichever happens first); returns a pointer to that area as described by the pointed-to <code>Blob</code>'s [<code>begin()</code>, <code>end()</code>) range.  <a href="classipc_1_1transport_1_1struc_1_1Msg__in.html#a3a1a75d7d7b108d46efa1892dd2571b7">More...</a><br /></td></tr>
<tr class="separator:a3a1a75d7d7b108d46efa1892dd2571b7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acd387ce27214601a70a0e1c6025075f1"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classipc_1_1transport_1_1struc_1_1Msg__in.html#acd387ce27214601a70a0e1c6025075f1">deserialize_mdt</a> (flow::log::Logger *logger_ptr, <a class="el" href="namespaceipc.html#aa3192e586cc45d3e7c22463bf2760f89">Error_code</a> *err_code)</td></tr>
<tr class="memdesc:acd387ce27214601a70a0e1c6025075f1"><td class="mdescLeft">&#160;</td><td class="mdescRight">To be invoked after exactly one successful <a class="el" href="classipc_1_1transport_1_1struc_1_1Msg__in.html#a3a1a75d7d7b108d46efa1892dd2571b7" title="Prior to deserialization_*() obtains a memory area max_sz bytes long into which the user may write-to...">add_serialization_segment()</a> call (and that <code>Blob</code> being filled-out and <code>.resize()</code>d): finalizes the deserialization of everything except the potential user-message body.  <a href="classipc_1_1transport_1_1struc_1_1Msg__in.html#acd387ce27214601a70a0e1c6025075f1">More...</a><br /></td></tr>
<tr class="separator:acd387ce27214601a70a0e1c6025075f1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acc5514d773db8edb0d8d0c3d52743a6a"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classipc_1_1transport_1_1struc_1_1Msg__in.html#acc5514d773db8edb0d8d0c3d52743a6a">deserialize_body</a> (<a class="el" href="namespaceipc.html#aa3192e586cc45d3e7c22463bf2760f89">Error_code</a> *err_code)</td></tr>
<tr class="memdesc:acc5514d773db8edb0d8d0c3d52743a6a"><td class="mdescLeft">&#160;</td><td class="mdescRight">To be invoked after <code><a class="el" href="classipc_1_1transport_1_1struc_1_1Msg__in.html#acd387ce27214601a70a0e1c6025075f1" title="To be invoked after exactly one successful add_serialization_segment() call (and that Blob being fill...">deserialize_mdt()</a> == N</code>, and <a class="el" href="classipc_1_1transport_1_1struc_1_1Msg__in.html#a3a1a75d7d7b108d46efa1892dd2571b7" title="Prior to deserialization_*() obtains a memory area max_sz bytes long into which the user may write-to...">add_serialization_segment()</a> was called N times (with all N <code>Blob</code>s filled-out and <code>.resize()</code>d): finalizes the deserialization of the user-message body.  <a href="classipc_1_1transport_1_1struc_1_1Msg__in.html#acc5514d773db8edb0d8d0c3d52743a6a">More...</a><br /></td></tr>
<tr class="separator:acc5514d773db8edb0d8d0c3d52743a6a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad42fc6c023dae0f6bf66ffb3a3437fa4"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespaceipc_1_1transport_1_1struc.html#af7f35fc7588d97a838274fa25700ead9">msg_id_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classipc_1_1transport_1_1struc_1_1Msg__in.html#ad42fc6c023dae0f6bf66ffb3a3437fa4">id_or_none</a> () const</td></tr>
<tr class="memdesc:ad42fc6c023dae0f6bf66ffb3a3437fa4"><td class="mdescLeft">&#160;</td><td class="mdescRight">To be called only after <a class="el" href="classipc_1_1transport_1_1struc_1_1Msg__in.html#acd387ce27214601a70a0e1c6025075f1" title="To be invoked after exactly one successful add_serialization_segment() call (and that Blob being fill...">deserialize_mdt()</a>, returns the message ID of this in-message; 0 means it's an internal message (<a class="el" href="classipc_1_1transport_1_1struc_1_1Msg__in.html#a880fb3eb4b037c9a06d0a683feed660f" title="To be called only after deserialize_mdt(), similar to body_root() but for the internal-message root.">internal_msg_body_root()</a> applies), else it's a user message (body() applies).  <a href="classipc_1_1transport_1_1struc_1_1Msg__in.html#ad42fc6c023dae0f6bf66ffb3a3437fa4">More...</a><br /></td></tr>
<tr class="separator:ad42fc6c023dae0f6bf66ffb3a3437fa4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac14e45f1df2ade79bfe525a97d65469c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespaceipc_1_1transport_1_1struc.html#af7f35fc7588d97a838274fa25700ead9">msg_id_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classipc_1_1transport_1_1struc_1_1Msg__in.html#ac14e45f1df2ade79bfe525a97d65469c">originating_msg_id_or_none</a> () const</td></tr>
<tr class="memdesc:ac14e45f1df2ade79bfe525a97d65469c"><td class="mdescLeft">&#160;</td><td class="mdescRight">To be called only after <a class="el" href="classipc_1_1transport_1_1struc_1_1Msg__in.html#acd387ce27214601a70a0e1c6025075f1" title="To be invoked after exactly one successful add_serialization_segment() call (and that Blob being fill...">deserialize_mdt()</a>, returns the message ID of the out-message to which this in-message claims to be responding; or 0 if it is not a response.  <a href="classipc_1_1transport_1_1struc_1_1Msg__in.html#ac14e45f1df2ade79bfe525a97d65469c">More...</a><br /></td></tr>
<tr class="separator:ac14e45f1df2ade79bfe525a97d65469c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a880fb3eb4b037c9a06d0a683feed660f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classipc_1_1transport_1_1struc_1_1Msg__in.html#afdc86a45b50e9869329b11a1e576b172">Internal_msg_body_reader</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classipc_1_1transport_1_1struc_1_1Msg__in.html#a880fb3eb4b037c9a06d0a683feed660f">internal_msg_body_root</a> () const</td></tr>
<tr class="memdesc:a880fb3eb4b037c9a06d0a683feed660f"><td class="mdescLeft">&#160;</td><td class="mdescRight">To be called only after <a class="el" href="classipc_1_1transport_1_1struc_1_1Msg__in.html#acd387ce27214601a70a0e1c6025075f1" title="To be invoked after exactly one successful add_serialization_segment() call (and that Blob being fill...">deserialize_mdt()</a>, similar to <a class="el" href="classipc_1_1transport_1_1struc_1_1Msg__in.html#a56fa38feb9c907ae3f0f1a6ff16dd32f" title="Methods.">body_root()</a> but for the internal-message root.  <a href="classipc_1_1transport_1_1struc_1_1Msg__in.html#a880fb3eb4b037c9a06d0a683feed660f">More...</a><br /></td></tr>
<tr class="separator:a880fb3eb4b037c9a06d0a683feed660f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9bb1f48ee2a73c081cacf6c69df5a1be"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="namespaceipc_1_1transport_1_1struc.html#a6751c05fb6582a34c7c47ac470c4a48b">Session_token</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classipc_1_1transport_1_1struc_1_1Msg__in.html#a9bb1f48ee2a73c081cacf6c69df5a1be">session_token</a> () const</td></tr>
<tr class="memdesc:a9bb1f48ee2a73c081cacf6c69df5a1be"><td class="mdescLeft">&#160;</td><td class="mdescRight">To be called only after <a class="el" href="classipc_1_1transport_1_1struc_1_1Msg__in.html#acd387ce27214601a70a0e1c6025075f1" title="To be invoked after exactly one successful add_serialization_segment() call (and that Blob being fill...">deserialize_mdt()</a>, returns session token tagging this in-message.  <a href="classipc_1_1transport_1_1struc_1_1Msg__in.html#a9bb1f48ee2a73c081cacf6c69df5a1be">More...</a><br /></td></tr>
<tr class="separator:a9bb1f48ee2a73c081cacf6c69df5a1be"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a529a341e65bfb13b5a4caad131a37b0f"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classipc_1_1transport_1_1struc_1_1Msg__in.html#a99df8a99bc2ed106d6a03f807e6e5966">Mdt_reader</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classipc_1_1transport_1_1struc_1_1Msg__in.html#a529a341e65bfb13b5a4caad131a37b0f">mdt_root</a> () const</td></tr>
<tr class="memdesc:a529a341e65bfb13b5a4caad131a37b0f"><td class="mdescLeft">&#160;</td><td class="mdescRight">The <a class="el" href="classipc_1_1transport_1_1struc_1_1Msg__in.html#aad2c43c92a286ab7d186d810631a1701" title="Same as Msg_mdt_out::Body.">Mdt</a> root capnp-generated accessor object.  <a href="classipc_1_1transport_1_1struc_1_1Msg__in.html#a529a341e65bfb13b5a4caad131a37b0f">More...</a><br /></td></tr>
<tr class="separator:a529a341e65bfb13b5a4caad131a37b0f"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="related" name="related"></a>
Related Functions</h2></td></tr>
<tr><td class="ititle" colspan="2"><p >(Note that these are not member functions.) </p>
</td></tr>
<tr class="memitem:aad52996a4d66f74e21e4f2e74c93c763"><td class="memTemplParams" colspan="2">template&lt;typename Message_body , typename Struct_reader_config &gt; </td></tr>
<tr class="memitem:aad52996a4d66f74e21e4f2e74c93c763"><td class="memTemplItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classipc_1_1transport_1_1struc_1_1Msg__in.html#aad52996a4d66f74e21e4f2e74c93c763">operator&lt;&lt;</a> (std::ostream &amp;os, const <a class="el" href="classipc_1_1transport_1_1struc_1_1Msg__in.html">Msg_in</a>&lt; Message_body, Struct_reader_config &gt; &amp;val)</td></tr>
<tr class="memdesc:aad52996a4d66f74e21e4f2e74c93c763"><td class="mdescLeft">&#160;</td><td class="mdescRight">Prints string representation of the given <code><a class="el" href="classipc_1_1transport_1_1struc_1_1Msg__in.html" title="A structured in-message instance suitable as received and emittable (to user) by struc::Channel.">Msg_in</a></code> to the given <code>ostream</code>.  <a href="classipc_1_1transport_1_1struc_1_1Msg__in.html#aad52996a4d66f74e21e4f2e74c93c763">More...</a><br /></td></tr>
<tr class="separator:aad52996a4d66f74e21e4f2e74c93c763"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><div class="compoundTemplParams">template&lt;typename Message_body, typename Struct_reader_config&gt;<br />
class ipc::transport::struc::Msg_in&lt; Message_body, Struct_reader_config &gt;</div><p >A structured in-message <em>instance</em> suitable as received and emittable (to user) by <a class="el" href="classipc_1_1transport_1_1struc_1_1Channel.html" title="Owning and wrapping a pre-connected transport::Channel peer (an endpoint of an established channel ov...">struc::Channel</a>. </p>
<p >Publicly these are never constructed but emitted into <code><a class="el" href="classipc_1_1transport_1_1struc_1_1Channel.html" title="Owning and wrapping a pre-connected transport::Channel peer (an endpoint of an established channel ov...">Channel</a></code>-passed handlers, wrapped into <code>shared_ptr</code> <a class="el" href="classipc_1_1transport_1_1struc_1_1Channel.html#ae1f4b316eaeb7ed520a84d9e21e21063" title="A ref-counted handle to Msg_in.">struc::Channel::Msg_in_ptr</a>. These handlers include <a class="el" href="classipc_1_1transport_1_1struc_1_1Channel.html#a160a8d49624f15a2596ee7b0244584b0" title="Registers the expectation of up to 1 notification in-message whose Msg_which equals which.">struc::Channel::expect_msg()</a>, <a class="el" href="classipc_1_1transport_1_1struc_1_1Channel.html#a3376b821b129ca3847484a178e080c67" title="Registers the expectation of 0+ notification in-messages whose Msg_which equals which.">struc::Channel::expect_msgs()</a>, and <a class="el" href="classipc_1_1transport_1_1struc_1_1Channel.html#a97506bcb695f22e7ca6b480bae5b2346" title="Identical to send() sends the out-message not as a notification but as a request, registering the exp...">struc::Channel::async_request()</a> and <a class="el" href="classipc_1_1transport_1_1struc_1_1Channel.html#aa41aee3c76035f43833078e625e6ef78" title="Equivalent to the other sync_request() overload but with no timeout; meaning it shall exit only once ...">struc::Channel::sync_request()</a>. Once available to the user, one accesses the in-place (zero-copy) capnp serialization via <a class="el" href="classipc_1_1transport_1_1struc_1_1Msg__in.html#a56fa38feb9c907ae3f0f1a6ff16dd32f" title="Methods.">body_root()</a>, via which one can access the message's read-only contents.</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classipc_1_1transport_1_1struc_1_1Msg__out.html" title="A structured out-message suitable to be sent via struc::Channel::send().">Msg_out</a> </dd>
<dd>
"Lifecycle of an out-message" section of <a class="el" href="classipc_1_1transport_1_1struc_1_1Channel.html" title="Owning and wrapping a pre-connected transport::Channel peer (an endpoint of an established channel ov...">struc::Channel</a> class doc header for useful context. Note that for each <a class="el" href="classipc_1_1transport_1_1struc_1_1Msg__out.html" title="A structured out-message suitable to be sent via struc::Channel::send().">Msg_out</a>, there will exist 0+ <code><a class="el" href="classipc_1_1transport_1_1struc_1_1Msg__in.html" title="A structured in-message instance suitable as received and emittable (to user) by struc::Channel.">Msg_in</a></code>s, one per successful <code>send()</code> paired with emission to user via aformentioned handlers. The latter represent each instance of the original message being received; the former represents the original message. Hence <a class="el" href="classipc_1_1transport_1_1struc_1_1Msg__in.html" title="A structured in-message instance suitable as received and emittable (to user) by struc::Channel.">Msg_in</a> access is read-only (<code>Reader</code> access only); <a class="el" href="classipc_1_1transport_1_1struc_1_1Msg__out.html" title="A structured out-message suitable to be sent via struc::Channel::send().">Msg_out</a> access is read/write (<code>Builder</code> access).</dd></dl>
<h3>Resource use (RAM)</h3>
<p >If <a class="el" href="classipc_1_1transport_1_1struc_1_1Msg__in.html#af8c335ada1b33fcc732047283e60177b" title="See struc::Channel::Reader_config.">Reader_config</a> is non-SHM-based, then a <code>*this</code> is analogous to a <a class="el" href="classipc_1_1transport_1_1struc_1_1Msg__out.html" title="A structured out-message suitable to be sent via struc::Channel::send().">Msg_out</a>; the RAM used is released once <code>*this</code> is destroyed. If it <em>is</em> SHM-based, then the cross-process ref-count scheme explained in <a class="el" href="classipc_1_1transport_1_1struc_1_1Msg__out.html" title="A structured out-message suitable to be sent via struc::Channel::send().">Msg_out</a> doc header is in force.</p>
<h3>Resource use: the <a class="el" href="namespaceipc_1_1transport.html#a7ee4551983d9df16ec16a3139bac50e8" title="Convenience alias for the commonly used type util::Native_handle.">Native_handle</a> (if any)</h3>
<p >Firstly see similarly named section in <a class="el" href="classipc_1_1transport_1_1struc_1_1Msg__out.html" title="A structured out-message suitable to be sent via struc::Channel::send().">Msg_out</a> doc header. In particular note that the <code>*this</code>-stored descriptor is not the same descriptor as the one in the out-message object; rather it's a descriptor in a different process referring to the the same description, with an OS/kernel-held ref-count.</p>
<p >Even if <code>*this</code> stores a non-null <a class="el" href="namespaceipc_1_1transport.html#a7ee4551983d9df16ec16a3139bac50e8" title="Convenience alias for the commonly used type util::Native_handle.">Native_handle</a>, it will never return it to the OS on your behalf. You may do so if and when desired. This is different from <a class="el" href="classipc_1_1transport_1_1struc_1_1Msg__out.html" title="A structured out-message suitable to be sent via struc::Channel::send().">Msg_out</a> which "owns" its copy and will return it to the OS at destruction.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Message_body</td><td>See <a class="el" href="classipc_1_1transport_1_1struc_1_1Msg__in.html" title="A structured in-message instance suitable as received and emittable (to user) by struc::Channel.">Msg_in</a>: this is the counterpart. </td></tr>
    <tr><td class="paramname">Struct_reader_config</td><td>See <a class="el" href="classipc_1_1transport_1_1struc_1_1Msg__out.html" title="A structured out-message suitable to be sent via struc::Channel::send().">Msg_out</a>: this is the counterpart. </td></tr>
  </table>
  </dd>
</dl>
</div><h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="a234708ed176f270f6372536ba3571b9a" name="a234708ed176f270f6372536ba3571b9a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a234708ed176f270f6372536ba3571b9a">&#9670;&nbsp;</a></span>~Msg_in()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Message_body , typename Struct_reader_config &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classipc_1_1transport_1_1struc_1_1Msg__in.html">ipc::transport::struc::Msg_in</a>&lt; Message_body, Struct_reader_config &gt;::~<a class="el" href="classipc_1_1transport_1_1struc_1_1Msg__in.html">Msg_in</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">default</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns resources, potentially including potentially significant RAM resources, taken before emitting to the user. </p>
<p ><a class="el" href="classipc_1_1transport_1_1struc_1_1Msg__in.html#aba0b83c9d8a7e8f782202406ca387e2c" title="The Native_handle – potentially null meaning none – embedded in this message.">native_handle_or_null()</a>, even if not <code>.null()</code>, is not returned to the OS.</p>
<p >See class doc header for discussion. </p>

</div>
</div>
<a id="ae3e6be294fbff87979a407a9e971da8a" name="ae3e6be294fbff87979a407a9e971da8a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae3e6be294fbff87979a407a9e971da8a">&#9670;&nbsp;</a></span>Msg_in()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Message_body , typename Struct_reader_config &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classipc_1_1transport_1_1struc_1_1Msg__in.html">ipc::transport::struc::Msg_in</a>&lt; Message_body, Struct_reader_config &gt;::Msg_in </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classipc_1_1transport_1_1struc_1_1Msg__in.html#af8c335ada1b33fcc732047283e60177b">Reader_config</a> &amp;&#160;</td>
          <td class="paramname"><em>struct_reader_config</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">explicit</span><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Constructs a not-ready-for-public-consumption in-message which awaits serialization-storing segments to be added via <a class="el" href="classipc_1_1transport_1_1struc_1_1Msg__in.html#a3a1a75d7d7b108d46efa1892dd2571b7" title="Prior to deserialization_*() obtains a memory area max_sz bytes long into which the user may write-to...">add_serialization_segment()</a> and then finalized with <a class="el" href="classipc_1_1transport_1_1struc_1_1Msg__in.html#acd387ce27214601a70a0e1c6025075f1" title="To be invoked after exactly one successful add_serialization_segment() call (and that Blob being fill...">deserialize_mdt()</a> and possibly <a class="el" href="classipc_1_1transport_1_1struc_1_1Msg__in.html#acc5514d773db8edb0d8d0c3d52743a6a" title="To be invoked after deserialize_mdt() == N, and add_serialization_segment() was called N times (with ...">deserialize_body()</a>. </p>
<p >After the latter 1-2: <a class="el" href="classipc_1_1transport_1_1struc_1_1Msg__in.html#a56fa38feb9c907ae3f0f1a6ff16dd32f" title="Methods.">body_root()</a> or <a class="el" href="classipc_1_1transport_1_1struc_1_1Msg__in.html#a880fb3eb4b037c9a06d0a683feed660f" title="To be called only after deserialize_mdt(), similar to body_root() but for the internal-message root.">internal_msg_body_root()</a> can be used to access the deserialized data; as can <a class="el" href="classipc_1_1transport_1_1struc_1_1Msg__in.html#ad42fc6c023dae0f6bf66ffb3a3437fa4" title="To be called only after deserialize_mdt(), returns the message ID of this in-message; 0 means it&#39;s an...">id_or_none()</a> and similar accessors.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">struct_reader_config</td><td>See <a class="el" href="classipc_1_1transport_1_1struc_1_1Channel.html" title="Owning and wrapping a pre-connected transport::Channel peer (an endpoint of an established channel ov...">struc::Channel</a> ctors. This is copied, memorized. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="a3a1a75d7d7b108d46efa1892dd2571b7" name="a3a1a75d7d7b108d46efa1892dd2571b7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3a1a75d7d7b108d46efa1892dd2571b7">&#9670;&nbsp;</a></span>add_serialization_segment()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Message_body , typename Struct_reader_config &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">flow::util::Blob * <a class="el" href="classipc_1_1transport_1_1struc_1_1Msg__in.html">ipc::transport::struc::Msg_in</a>&lt; Message_body, Struct_reader_config &gt;::add_serialization_segment </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>max_sz</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Prior to <code>deserialization_*()</code> obtains a memory area <code>max_sz</code> bytes long into which the user may write-to until the next <a class="el" href="classipc_1_1transport_1_1struc_1_1Msg__in.html#a3a1a75d7d7b108d46efa1892dd2571b7" title="Prior to deserialization_*() obtains a memory area max_sz bytes long into which the user may write-to...">add_serialization_segment()</a>, <code>deserialization_*()</code>, or dtor call (whichever happens first); returns a pointer to that area as described by the pointed-to <code>Blob</code>'s [<code>begin()</code>, <code>end()</code>) range. </p>
<p >If the reader impl decides <code>max_sz</code> bytes are not available, returns null. <code>*this</code> shall not be used subsequent to such an eventuality.</p>
<p >This essentially forwards to the appropriate <a class="el" href="classipc_1_1transport_1_1struc_1_1Struct__reader.html#ae450aff09cc9d71b75b382d59a9cfc23" title="Prior to deserialization() obtains a memory area max_sz bytes long into which the user may write-to u...">Struct_reader::add_serialization_segment()</a>; hence the same requirements, including w/r/t alignment and subsequent storing-into and modification of returned <code>Blob</code>, apply as described in that doc header. That said:</p><ul>
<li>The first <a class="el" href="classipc_1_1transport_1_1struc_1_1Msg__in.html#a3a1a75d7d7b108d46efa1892dd2571b7" title="Prior to deserialization_*() obtains a memory area max_sz bytes long into which the user may write-to...">add_serialization_segment()</a> call must be the <em>sole</em> segment of the metadata message (corresponding to Msg_mdt_out). After the returned <code>Blob</code> is filled-out and <code>.resize()</code>d, you must invoke <a class="el" href="classipc_1_1transport_1_1struc_1_1Msg__in.html#acd387ce27214601a70a0e1c6025075f1" title="To be invoked after exactly one successful add_serialization_segment() call (and that Blob being fill...">deserialize_mdt()</a> which shall return the number of additional <a class="el" href="classipc_1_1transport_1_1struc_1_1Msg__in.html#a3a1a75d7d7b108d46efa1892dd2571b7" title="Prior to deserialization_*() obtains a memory area max_sz bytes long into which the user may write-to...">add_serialization_segment()</a> calls to make. If that number is 0 (&lt;=&gt; <a class="el" href="classipc_1_1transport_1_1struc_1_1Msg__in.html#ad42fc6c023dae0f6bf66ffb3a3437fa4" title="To be called only after deserialize_mdt(), returns the message ID of this in-message; 0 means it&#39;s an...">id_or_none()</a> is 0 &lt;=&gt; there is an internal message in the Msg_mdt_out), then there shall be no further <a class="el" href="classipc_1_1transport_1_1struc_1_1Msg__in.html#a3a1a75d7d7b108d46efa1892dd2571b7" title="Prior to deserialization_*() obtains a memory area max_sz bytes long into which the user may write-to...">add_serialization_segment()</a> calls; <a class="el" href="classipc_1_1transport_1_1struc_1_1Msg__in.html#a880fb3eb4b037c9a06d0a683feed660f" title="To be called only after deserialize_mdt(), similar to body_root() but for the internal-message root.">internal_msg_body_root()</a> can be used. Otherwise:</li>
<li>The following <a class="el" href="classipc_1_1transport_1_1struc_1_1Msg__in.html#a3a1a75d7d7b108d46efa1892dd2571b7" title="Prior to deserialization_*() obtains a memory area max_sz bytes long into which the user may write-to...">add_serialization_segment()</a> calls (the 2nd, 3rd, ...) ones shall be, in order, comprised by the user-message serialization (corresponding to <code><a class="el" href="classipc_1_1transport_1_1struc_1_1Msg__out.html" title="A structured out-message suitable to be sent via struc::Channel::send().">Msg_out</a>&lt;Message_body&gt;</code>). After each call fill-out and <code>.resize()</code> the returned <code>Blob</code>. After the last call call <a class="el" href="classipc_1_1transport_1_1struc_1_1Msg__in.html#acc5514d773db8edb0d8d0c3d52743a6a" title="To be invoked after deserialize_mdt() == N, and add_serialization_segment() was called N times (with ...">deserialize_body()</a>; then <a class="el" href="classipc_1_1transport_1_1struc_1_1Msg__in.html#a56fa38feb9c907ae3f0f1a6ff16dd32f" title="Methods.">body_root()</a> can be used.</li>
</ul>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">max_sz</td><td>See <a class="el" href="classipc_1_1transport_1_1struc_1_1Struct__reader.html#ae450aff09cc9d71b75b382d59a9cfc23" title="Prior to deserialization() obtains a memory area max_sz bytes long into which the user may write-to u...">Struct_reader::add_serialization_segment()</a>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>See <a class="el" href="classipc_1_1transport_1_1struc_1_1Struct__reader.html#ae450aff09cc9d71b75b382d59a9cfc23" title="Prior to deserialization() obtains a memory area max_sz bytes long into which the user may write-to u...">Struct_reader::add_serialization_segment()</a>. </dd></dl>

</div>
</div>
<a id="a56fa38feb9c907ae3f0f1a6ff16dd32f" name="a56fa38feb9c907ae3f0f1a6ff16dd32f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a56fa38feb9c907ae3f0f1a6ff16dd32f">&#9670;&nbsp;</a></span>body_root()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Message_body , typename Struct_reader_config &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classipc_1_1transport_1_1struc_1_1Msg__in.html">Msg_in</a>&lt; Message_body, Struct_reader_config &gt;<a class="el" href="classipc_1_1transport_1_1struc_1_1Msg__in.html#a6e21b165a0673138db44d86584dd5059">::Body_reader</a> &amp; <a class="el" href="classipc_1_1transport_1_1struc_1_1Msg__in.html">ipc::transport::struc::Msg_in</a>&lt; Message_body, Struct_reader_config &gt;::body_root</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Methods. </p>
<p >The <a class="el" href="classipc_1_1transport_1_1struc_1_1Msg__in.html#aa408e309fcb402c061d969742874ca6c" title="See struc::Channel::Msg_body.">Body</a> root capnp-generated accessor object. E.g.: <code>this-&gt;<a class="el" href="classipc_1_1transport_1_1struc_1_1Msg__in.html#a56fa38feb9c907ae3f0f1a6ff16dd32f" title="Methods.">body_root()</a>.getSomeStruct().setSomeField()</code> will access the capnp-<code>struct</code>-typed root field <code>someStruct</code> and pluck out the value <code>someField</code> &ndash; presumably an integer &ndash; within it. The ref returned shall always be to the same address until <code>*this</code> is destroyed.</p>
<p ><a class="el" href="classipc_1_1transport_1_1struc_1_1Msg__in.html#a6e21b165a0673138db44d86584dd5059" title="Short-hand for capnp-generated read-only-accessing Reader nested class of Body. See body_root().">Body_reader</a> is light-weight, so you may make a copy and then access via that, if desired. However whether <code><a class="el" href="classipc_1_1transport_1_1struc_1_1Msg__in.html#a56fa38feb9c907ae3f0f1a6ff16dd32f" title="Methods.">body_root()</a></code> itself or such a copy, such a <code>Reader</code> object may not be accessed after <code>*this</code> is destroyed.</p>
<p >Informally we recommend against value-copying <a class="el" href="classipc_1_1transport_1_1struc_1_1Msg__in.html#a56fa38feb9c907ae3f0f1a6ff16dd32f" title="Methods.">body_root()</a>: Light-weight or not, it's a copy, and copying a pointer/cref is cheaper; and it may not live past <code>*this</code> anyway; and <a class="el" href="classipc_1_1transport_1_1struc_1_1Msg__in.html#a56fa38feb9c907ae3f0f1a6ff16dd32f" title="Methods.">body_root()</a> always returns the same address. So just store the cref (or pointer-to-<code>const</code> with the same addr).</p>
<h3>Quick capnp tips</h3>
<p >You should really read all of capnp docs at its web site. They are very useful and well written and not overly formal despite being quite comprehensive. That said a couple of gotchas/tips:</p><ul>
<li>On a <code>Reader</code>, <code>.getX()</code> is lightning-fast, like accessing <code>struct</code> members directly &ndash; but only when <code>X</code> is of a scalar type. Compount types, where <code>.getX()</code> returns not a native type but another <code>Reader</code>, need to perform some pointer checking and are slower. Therefore, if you plan to <code>.getX()</code> and then <code>.getA()</code> and <code>.getB()</code> (and similar) on that <code>X</code>, you should save the result (<code>auto x = ....getX();</code>); then access via the saved result (<code>a = x.getA(...); b = x.getB(...)</code>).</li>
</ul>
<p >To pretty-print (with indent/newlines) you can use: <code>capnp::prettyPrint(M.body_root()).flatten().cStr()</code>.</p>
<dl class="section return"><dt>Returns</dt><dd>See above. </dd></dl>

</div>
</div>
<a id="acc5514d773db8edb0d8d0c3d52743a6a" name="acc5514d773db8edb0d8d0c3d52743a6a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acc5514d773db8edb0d8d0c3d52743a6a">&#9670;&nbsp;</a></span>deserialize_body()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Message_body , typename Struct_reader_config &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classipc_1_1transport_1_1struc_1_1Msg__in.html">ipc::transport::struc::Msg_in</a>&lt; Message_body, Struct_reader_config &gt;::deserialize_body </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespaceipc.html#aa3192e586cc45d3e7c22463bf2760f89">Error_code</a> *&#160;</td>
          <td class="paramname"><em>err_code</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>To be invoked after <code><a class="el" href="classipc_1_1transport_1_1struc_1_1Msg__in.html#acd387ce27214601a70a0e1c6025075f1" title="To be invoked after exactly one successful add_serialization_segment() call (and that Blob being fill...">deserialize_mdt()</a> == N</code>, and <a class="el" href="classipc_1_1transport_1_1struc_1_1Msg__in.html#a3a1a75d7d7b108d46efa1892dd2571b7" title="Prior to deserialization_*() obtains a memory area max_sz bytes long into which the user may write-to...">add_serialization_segment()</a> was called N times (with all N <code>Blob</code>s filled-out and <code>.resize()</code>d): finalizes the deserialization of the user-message body. </p>
<p >This must be called strictly before any calls to <a class="el" href="classipc_1_1transport_1_1struc_1_1Msg__in.html#a56fa38feb9c907ae3f0f1a6ff16dd32f" title="Methods.">body_root()</a>.</p>
<p >If called before a post-deserialize_mdt() <a class="el" href="classipc_1_1transport_1_1struc_1_1Msg__in.html#a3a1a75d7d7b108d46efa1892dd2571b7" title="Prior to deserialization_*() obtains a memory area max_sz bytes long into which the user may write-to...">add_serialization_segment()</a>, behavior is undefined (assertion may trip).</p>
<p >If called more than once, behavior is undefined (assertion may trip).</p>
<p >If it fails (emits truthy <a class="el" href="namespaceipc.html#aa3192e586cc45d3e7c22463bf2760f89" title="Short-hand for flow::Error_code which is very common.">Error_code</a>), it is pointless to use <code>*this</code>. Recommend destruction.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">err_code</td><td>See <a class="el" href="classipc_1_1transport_1_1struc_1_1Msg__in.html#acd387ce27214601a70a0e1c6025075f1" title="To be invoked after exactly one successful add_serialization_segment() call (and that Blob being fill...">deserialize_mdt()</a>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="acd387ce27214601a70a0e1c6025075f1" name="acd387ce27214601a70a0e1c6025075f1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acd387ce27214601a70a0e1c6025075f1">&#9670;&nbsp;</a></span>deserialize_mdt()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Message_body , typename Struct_reader_config &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_t <a class="el" href="classipc_1_1transport_1_1struc_1_1Msg__in.html">ipc::transport::struc::Msg_in</a>&lt; Message_body, Struct_reader_config &gt;::deserialize_mdt </td>
          <td>(</td>
          <td class="paramtype">flow::log::Logger *&#160;</td>
          <td class="paramname"><em>logger_ptr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceipc.html#aa3192e586cc45d3e7c22463bf2760f89">Error_code</a> *&#160;</td>
          <td class="paramname"><em>err_code</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>To be invoked after exactly one successful <a class="el" href="classipc_1_1transport_1_1struc_1_1Msg__in.html#a3a1a75d7d7b108d46efa1892dd2571b7" title="Prior to deserialization_*() obtains a memory area max_sz bytes long into which the user may write-to...">add_serialization_segment()</a> call (and that <code>Blob</code> being filled-out and <code>.resize()</code>d): finalizes the deserialization of everything except the potential user-message body. </p>
<p >This must be called strictly before any calls to <a class="el" href="classipc_1_1transport_1_1struc_1_1Msg__in.html#a880fb3eb4b037c9a06d0a683feed660f" title="To be called only after deserialize_mdt(), similar to body_root() but for the internal-message root.">internal_msg_body_root()</a>, <a class="el" href="classipc_1_1transport_1_1struc_1_1Msg__in.html#ad42fc6c023dae0f6bf66ffb3a3437fa4" title="To be called only after deserialize_mdt(), returns the message ID of this in-message; 0 means it&#39;s an...">id_or_none()</a>, <a class="el" href="classipc_1_1transport_1_1struc_1_1Msg__in.html#ac14e45f1df2ade79bfe525a97d65469c" title="To be called only after deserialize_mdt(), returns the message ID of the out-message to which this in...">originating_msg_id_or_none()</a>, or <a class="el" href="classipc_1_1transport_1_1struc_1_1Msg__in.html#a9bb1f48ee2a73c081cacf6c69df5a1be" title="To be called only after deserialize_mdt(), returns session token tagging this in-message.">session_token()</a>; and any subsequent <a class="el" href="classipc_1_1transport_1_1struc_1_1Msg__in.html#a3a1a75d7d7b108d46efa1892dd2571b7" title="Prior to deserialization_*() obtains a memory area max_sz bytes long into which the user may write-to...">add_serialization_segment()</a> calls (if any).</p>
<p >The value this returns (sans error) dictates the exact # of further <a class="el" href="classipc_1_1transport_1_1struc_1_1Msg__in.html#a3a1a75d7d7b108d46efa1892dd2571b7" title="Prior to deserialization_*() obtains a memory area max_sz bytes long into which the user may write-to...">add_serialization_segment()</a> calls to make.</p><ul>
<li>If 0: You may use the accessor API immediately. <a class="el" href="classipc_1_1transport_1_1struc_1_1Msg__in.html#a880fb3eb4b037c9a06d0a683feed660f" title="To be called only after deserialize_mdt(), similar to body_root() but for the internal-message root.">internal_msg_body_root()</a> is OK; <code><a class="el" href="classipc_1_1transport_1_1struc_1_1Msg__in.html#ad42fc6c023dae0f6bf66ffb3a3437fa4" title="To be called only after deserialize_mdt(), returns the message ID of this in-message; 0 means it&#39;s an...">id_or_none()</a> == 0</code>; <a class="el" href="classipc_1_1transport_1_1struc_1_1Msg__in.html#a56fa38feb9c907ae3f0f1a6ff16dd32f" title="Methods.">body_root()</a> may not be used.</li>
<li>Else: You may use the accessor API immediately. <code><a class="el" href="classipc_1_1transport_1_1struc_1_1Msg__in.html#ad42fc6c023dae0f6bf66ffb3a3437fa4" title="To be called only after deserialize_mdt(), returns the message ID of this in-message; 0 means it&#39;s an...">id_or_none()</a> != 0</code>; <a class="el" href="classipc_1_1transport_1_1struc_1_1Msg__in.html#a880fb3eb4b037c9a06d0a683feed660f" title="To be called only after deserialize_mdt(), similar to body_root() but for the internal-message root.">internal_msg_body_root()</a> may not be used; <a class="el" href="classipc_1_1transport_1_1struc_1_1Msg__in.html#a56fa38feb9c907ae3f0f1a6ff16dd32f" title="Methods.">body_root()</a> may not be used <em>yet</em> until successful <a class="el" href="classipc_1_1transport_1_1struc_1_1Msg__in.html#acc5514d773db8edb0d8d0c3d52743a6a" title="To be invoked after deserialize_mdt() == N, and add_serialization_segment() was called N times (with ...">deserialize_body()</a>.</li>
</ul>
<p >If called before <a class="el" href="classipc_1_1transport_1_1struc_1_1Msg__in.html#a3a1a75d7d7b108d46efa1892dd2571b7" title="Prior to deserialization_*() obtains a memory area max_sz bytes long into which the user may write-to...">add_serialization_segment()</a>, behavior is undefined (assertion may trip).</p>
<p >If called more than once, behavior is undefined (assertion may trip).</p>
<p >If it fails (emits truthy <a class="el" href="namespaceipc.html#aa3192e586cc45d3e7c22463bf2760f89" title="Short-hand for flow::Error_code which is very common.">Error_code</a>), it is pointless to use <code>*this</code>. Recommend destruction.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">logger_ptr</td><td>Logger to use for logging within this method. </td></tr>
    <tr><td class="paramname">err_code</td><td>Caution: Unlike user-facing methods, this does not throw (except capnp-generated exceptions); and <code>err_code</code> may not be null. Other than that: <a class="el" href="namespaceipc.html#aa3192e586cc45d3e7c22463bf2760f89" title="Short-hand for flow::Error_code which is very common.">Error_code</a> generated: falsy on success, else: <a class="el" href="namespaceipc_1_1transport_1_1struc_1_1error.html#a990b9ff850cf9aaf354efdd07d86a71da26ab25e100104aeb567d90f794313e3b" title="Structured channel: received structured message with invalid internally-set/used fields.">error::Code::S_STRUCT_CHANNEL_INTERNAL_PROTOCOL_MISUSED_SCHEMA</a> (opposing <a class="el" href="classipc_1_1transport_1_1struc_1_1Msg__out.html" title="A structured out-message suitable to be sent via struc::Channel::send().">Msg_out</a> code filled out the fields in an unexpected way), anything emitted by <a class="el" href="classipc_1_1transport_1_1struc_1_1Struct__reader.html#a95576f8cd8ad45a720276bd074cea4f2" title="After all serialization segments have been acquired in RAM via add_serialization_segment() and finali...">Struct_reader::deserialization()</a>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>See above. </dd></dl>

</div>
</div>
<a id="ad42fc6c023dae0f6bf66ffb3a3437fa4" name="ad42fc6c023dae0f6bf66ffb3a3437fa4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad42fc6c023dae0f6bf66ffb3a3437fa4">&#9670;&nbsp;</a></span>id_or_none()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Message_body , typename Struct_reader_config &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespaceipc_1_1transport_1_1struc.html#af7f35fc7588d97a838274fa25700ead9">msg_id_t</a> <a class="el" href="classipc_1_1transport_1_1struc_1_1Msg__in.html">ipc::transport::struc::Msg_in</a>&lt; Message_body, Struct_reader_config &gt;::id_or_none</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>To be called only after <a class="el" href="classipc_1_1transport_1_1struc_1_1Msg__in.html#acd387ce27214601a70a0e1c6025075f1" title="To be invoked after exactly one successful add_serialization_segment() call (and that Blob being fill...">deserialize_mdt()</a>, returns the message ID of this in-message; 0 means it's an internal message (<a class="el" href="classipc_1_1transport_1_1struc_1_1Msg__in.html#a880fb3eb4b037c9a06d0a683feed660f" title="To be called only after deserialize_mdt(), similar to body_root() but for the internal-message root.">internal_msg_body_root()</a> applies), else it's a user message (body() applies). </p>
<dl class="section return"><dt>Returns</dt><dd>See above. </dd></dl>

</div>
</div>
<a id="a880fb3eb4b037c9a06d0a683feed660f" name="a880fb3eb4b037c9a06d0a683feed660f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a880fb3eb4b037c9a06d0a683feed660f">&#9670;&nbsp;</a></span>internal_msg_body_root()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Message_body , typename Struct_reader_config &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classipc_1_1transport_1_1struc_1_1Msg__in.html">Msg_in</a>&lt; Message_body, Struct_reader_config &gt;<a class="el" href="classipc_1_1transport_1_1struc_1_1Msg__in.html#afdc86a45b50e9869329b11a1e576b172">::Internal_msg_body_reader</a> <a class="el" href="classipc_1_1transport_1_1struc_1_1Msg__in.html">ipc::transport::struc::Msg_in</a>&lt; Message_body, Struct_reader_config &gt;::internal_msg_body_root</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>To be called only after <a class="el" href="classipc_1_1transport_1_1struc_1_1Msg__in.html#acd387ce27214601a70a0e1c6025075f1" title="To be invoked after exactly one successful add_serialization_segment() call (and that Blob being fill...">deserialize_mdt()</a>, similar to <a class="el" href="classipc_1_1transport_1_1struc_1_1Msg__in.html#a56fa38feb9c907ae3f0f1a6ff16dd32f" title="Methods.">body_root()</a> but for the internal-message root. </p>
<p >See <a class="el" href="classipc_1_1transport_1_1struc_1_1Msg__in.html#afdc86a45b50e9869329b11a1e576b172" title="Reader counterpart to Msg_mdt_out::Internal_msg_body_builder.">Internal_msg_body_reader</a> doc header.</p>
<dl class="section return"><dt>Returns</dt><dd>See above. </dd></dl>

</div>
</div>
<a id="a529a341e65bfb13b5a4caad131a37b0f" name="a529a341e65bfb13b5a4caad131a37b0f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a529a341e65bfb13b5a4caad131a37b0f">&#9670;&nbsp;</a></span>mdt_root()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Message_body , typename Struct_reader_config &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classipc_1_1transport_1_1struc_1_1Msg__in.html">Msg_in</a>&lt; Message_body, Struct_reader_config &gt;<a class="el" href="classipc_1_1transport_1_1struc_1_1Msg__in.html#a99df8a99bc2ed106d6a03f807e6e5966">::Mdt_reader</a> &amp; <a class="el" href="classipc_1_1transport_1_1struc_1_1Msg__in.html">ipc::transport::struc::Msg_in</a>&lt; Message_body, Struct_reader_config &gt;::mdt_root</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>The <a class="el" href="classipc_1_1transport_1_1struc_1_1Msg__in.html#aad2c43c92a286ab7d186d810631a1701" title="Same as Msg_mdt_out::Body.">Mdt</a> root capnp-generated accessor object. </p>
<p >May be useful for, say, pretty-printing it to log (e.g.: <code>capnp::prettyPrint(M.mdt_root()).flatten().cStr()</code>). We do not recommend its use for other purposes; stylistically it is better to access items via individual accessors like <a class="el" href="classipc_1_1transport_1_1struc_1_1Msg__in.html#a9bb1f48ee2a73c081cacf6c69df5a1be" title="To be called only after deserialize_mdt(), returns session token tagging this in-message.">session_token()</a> or <a class="el" href="classipc_1_1transport_1_1struc_1_1Msg__in.html#a880fb3eb4b037c9a06d0a683feed660f" title="To be called only after deserialize_mdt(), similar to body_root() but for the internal-message root.">internal_msg_body_root()</a>.</p>
<dl class="section return"><dt>Returns</dt><dd>See above. </dd></dl>

</div>
</div>
<a id="aba0b83c9d8a7e8f782202406ca387e2c" name="aba0b83c9d8a7e8f782202406ca387e2c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aba0b83c9d8a7e8f782202406ca387e2c">&#9670;&nbsp;</a></span>native_handle_or_null()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Message_body , typename Struct_reader_config &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespaceipc_1_1transport.html#a7ee4551983d9df16ec16a3139bac50e8">Native_handle</a> <a class="el" href="classipc_1_1transport_1_1struc_1_1Msg__in.html">ipc::transport::struc::Msg_in</a>&lt; Message_body, Struct_reader_config &gt;::native_handle_or_null</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The <a class="el" href="namespaceipc_1_1transport.html#a7ee4551983d9df16ec16a3139bac50e8" title="Convenience alias for the commonly used type util::Native_handle.">Native_handle</a> &ndash; potentially null meaning none &ndash; embedded in this message. </p>
<dl class="section return"><dt>Returns</dt><dd>See above. </dd></dl>

</div>
</div>
<a id="ac14e45f1df2ade79bfe525a97d65469c" name="ac14e45f1df2ade79bfe525a97d65469c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac14e45f1df2ade79bfe525a97d65469c">&#9670;&nbsp;</a></span>originating_msg_id_or_none()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Message_body , typename Struct_reader_config &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespaceipc_1_1transport_1_1struc.html#af7f35fc7588d97a838274fa25700ead9">msg_id_t</a> <a class="el" href="classipc_1_1transport_1_1struc_1_1Msg__in.html">ipc::transport::struc::Msg_in</a>&lt; Message_body, Struct_reader_config &gt;::originating_msg_id_or_none</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>To be called only after <a class="el" href="classipc_1_1transport_1_1struc_1_1Msg__in.html#acd387ce27214601a70a0e1c6025075f1" title="To be invoked after exactly one successful add_serialization_segment() call (and that Blob being fill...">deserialize_mdt()</a>, returns the message ID of the out-message to which this in-message claims to be responding; or 0 if it is not a response. </p>
<dl class="section return"><dt>Returns</dt><dd>See above. </dd></dl>

</div>
</div>
<a id="a9bb1f48ee2a73c081cacf6c69df5a1be" name="a9bb1f48ee2a73c081cacf6c69df5a1be"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9bb1f48ee2a73c081cacf6c69df5a1be">&#9670;&nbsp;</a></span>session_token()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Message_body , typename Struct_reader_config &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="namespaceipc_1_1transport_1_1struc.html#a6751c05fb6582a34c7c47ac470c4a48b">Session_token</a> &amp; <a class="el" href="classipc_1_1transport_1_1struc_1_1Msg__in.html">ipc::transport::struc::Msg_in</a>&lt; Message_body, Struct_reader_config &gt;::session_token</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>To be called only after <a class="el" href="classipc_1_1transport_1_1struc_1_1Msg__in.html#acd387ce27214601a70a0e1c6025075f1" title="To be invoked after exactly one successful add_serialization_segment() call (and that Blob being fill...">deserialize_mdt()</a>, returns session token tagging this in-message. </p>
<dl class="section return"><dt>Returns</dt><dd>See above. </dd></dl>

</div>
</div>
<a id="ac4f7c03e1080913f949b9b24b776dc6a" name="ac4f7c03e1080913f949b9b24b776dc6a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac4f7c03e1080913f949b9b24b776dc6a">&#9670;&nbsp;</a></span>store_native_handle_or_null()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Message_body , typename Struct_reader_config &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classipc_1_1transport_1_1struc_1_1Msg__in.html">ipc::transport::struc::Msg_in</a>&lt; Message_body, Struct_reader_config &gt;::store_native_handle_or_null </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespaceipc_1_1transport.html#a7ee4551983d9df16ec16a3139bac50e8">Native_handle</a> &amp;&amp;&#160;</td>
          <td class="paramname"><em>native_handle_or_null</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Store the <a class="el" href="namespaceipc_1_1transport.html#a7ee4551983d9df16ec16a3139bac50e8" title="Convenience alias for the commonly used type util::Native_handle.">Native_handle</a> (potentially <code>.null()</code>, meaning none) in this in-message. </p>
<p >Call this at most once; or behavior undefined (assertion may trip).</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">native_handle_or_null</td><td>The <a class="el" href="namespaceipc_1_1transport.html#a7ee4551983d9df16ec16a3139bac50e8" title="Convenience alias for the commonly used type util::Native_handle.">Native_handle</a> (<code>.null() == true</code> if none) to move into <code>*this</code>. Made <code>.null() == true</code> upon return. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a4783bd852b1dcba1542e0cfe37205e9e" name="a4783bd852b1dcba1542e0cfe37205e9e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4783bd852b1dcba1542e0cfe37205e9e">&#9670;&nbsp;</a></span>to_ostream()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Message_body , typename Struct_reader_config &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classipc_1_1transport_1_1struc_1_1Msg__in.html">ipc::transport::struc::Msg_in</a>&lt; Message_body, Struct_reader_config &gt;::to_ostream </td>
          <td>(</td>
          <td class="paramtype">std::ostream *&#160;</td>
          <td class="paramname"><em>os</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Prints string representation to the given <code>ostream</code>. </p>
<p >This representation lacks newlines/indentation; includes a (potentially truncated) pretty-printed representation of <code><a class="el" href="classipc_1_1transport_1_1struc_1_1Msg__in.html#a56fa38feb9c907ae3f0f1a6ff16dd32f" title="Methods.">body_root()</a></code> contents; and includes <a class="el" href="classipc_1_1transport_1_1struc_1_1Msg__in.html#aba0b83c9d8a7e8f782202406ca387e2c" title="The Native_handle – potentially null meaning none – embedded in this message.">native_handle_or_null()</a>.</p>
<p >Caution: This could be an operation expensive in processor cycles and, temporarily, RAM; and thus should be used judiciously. To help drive your decision-making: This method, internally,</p><ol type="1">
<li>uses capnp <code>kj::str(this-&gt;body_root)</code> to generate a <em>full</em> pretty-print of <a class="el" href="classipc_1_1transport_1_1struc_1_1Msg__in.html#a56fa38feb9c907ae3f0f1a6ff16dd32f" title="Methods.">body_root()</a> contents;</li>
<li>truncates the result of the latter, as needed for a reasonably short output, and prints the result;</li>
<li>adds <a class="el" href="classipc_1_1transport_1_1struc_1_1Msg__in.html#aba0b83c9d8a7e8f782202406ca387e2c" title="The Native_handle – potentially null meaning none – embedded in this message.">native_handle_or_null()</a> and possibly a few other small information items.</li>
</ol>
<p >Because there is no reasonably-available way to stop generating the pretty-print in step 1 upon reaching a certain number of characters, the operation may take a while, if many non-default bytes have been mutated-in; and before truncation the resulting string may take significant RAM accordingly.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">os</td><td>Stream to which to write. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<h2 class="groupheader">Friends And Related Function Documentation</h2>
<a id="aad52996a4d66f74e21e4f2e74c93c763" name="aad52996a4d66f74e21e4f2e74c93c763"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aad52996a4d66f74e21e4f2e74c93c763">&#9670;&nbsp;</a></span>operator&lt;&lt;()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Message_body , typename Struct_reader_config &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::ostream &amp; operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>os</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classipc_1_1transport_1_1struc_1_1Msg__in.html">Msg_in</a>&lt; Message_body, Struct_reader_config &gt; &amp;&#160;</td>
          <td class="paramname"><em>val</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Prints string representation of the given <code><a class="el" href="classipc_1_1transport_1_1struc_1_1Msg__in.html" title="A structured in-message instance suitable as received and emittable (to user) by struc::Channel.">Msg_in</a></code> to the given <code>ostream</code>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">os</td><td>Stream to which to write. </td></tr>
    <tr><td class="paramname">val</td><td>Object to serialize. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>os</code>. </dd></dl>

</div>
</div>
<hr/>The documentation for this class was generated from the following files:<ul>
<li>transport/struc/<a class="el" href="msg_8hpp.html">msg.hpp</a></li>
<li>transport/struc/<a class="el" href="struc__fwd_8hpp.html">struc_fwd.hpp</a></li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Thu Feb 15 2024 03:43:05 for Flow-IPC by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.4
</small></address>
</body>
</html>
