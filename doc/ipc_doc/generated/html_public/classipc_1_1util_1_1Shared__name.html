<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.9.4"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Flow-IPC: ipc::util::Shared_name Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">Flow-IPC<span id="projectnumber">&#160;1.0.2</span>
   </div>
   <div id="projectbrief">Flow-IPC project: Public API.</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.4 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search",'Search','.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespaceipc.html">ipc</a></li><li class="navelem"><a class="el" href="namespaceipc_1_1util.html">util</a></li><li class="navelem"><a class="el" href="classipc_1_1util_1_1Shared__name.html">Shared_name</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pub-static-methods">Static Public Member Functions</a> &#124;
<a href="#pub-static-attribs">Static Public Attributes</a> &#124;
<a href="#related">Related Functions</a> &#124;
<a href="classipc_1_1util_1_1Shared__name-members.html">List of all members</a>  </div>
  <div class="headertitle"><div class="title">ipc::util::Shared_name Class Reference</div></div>
</div><!--header-->
<div class="contents">

<p>String-wrapping abstraction representing a name uniquely distinguishing a kernel-persistent entity from all others in the system, or a fragment of such a name.  
 <a href="classipc_1_1util_1_1Shared__name.html#details">More...</a></p>

<p><code>#include &lt;shared_name.hpp&gt;</code></p>
<div class="dynheader">
Collaboration diagram for ipc::util::Shared_name:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="classipc_1_1util_1_1Shared__name__coll__graph.svg" width="284" height="107"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe>
</div>
<center><span class="legend">[<a href="graph_legend.html">legend</a>]</span></center></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-methods" name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a1f9b706d587b49ad84b555817c001fc8"><td class="memItemLeft" align="right" valign="top"><a id="a1f9b706d587b49ad84b555817c001fc8" name="a1f9b706d587b49ad84b555817c001fc8"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>Shared_name</b> ()</td></tr>
<tr class="memdesc:a1f9b706d587b49ad84b555817c001fc8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructs <a class="el" href="classipc_1_1util_1_1Shared__name.html#a861ea6c9ad6672e83bab5c7747b66f7b" title="Returns true if and only if str().empty() == true.">empty()</a> name. <br /></td></tr>
<tr class="separator:a1f9b706d587b49ad84b555817c001fc8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1e9cad5a94d78e1180a9e77877009873"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classipc_1_1util_1_1Shared__name.html#a1e9cad5a94d78e1180a9e77877009873">Shared_name</a> (const <a class="el" href="classipc_1_1util_1_1Shared__name.html">Shared_name</a> &amp;src)</td></tr>
<tr class="memdesc:a1e9cad5a94d78e1180a9e77877009873"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy-constructs from an existing <a class="el" href="classipc_1_1util_1_1Shared__name.html" title="String-wrapping abstraction representing a name uniquely distinguishing a kernel-persistent entity fr...">Shared_name</a>.  <a href="classipc_1_1util_1_1Shared__name.html#a1e9cad5a94d78e1180a9e77877009873">More...</a><br /></td></tr>
<tr class="separator:a1e9cad5a94d78e1180a9e77877009873"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a79995ab36be778bb2a56eeba80a7abed"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classipc_1_1util_1_1Shared__name.html#a79995ab36be778bb2a56eeba80a7abed">Shared_name</a> (<a class="el" href="classipc_1_1util_1_1Shared__name.html">Shared_name</a> &amp;&amp;src_moved)</td></tr>
<tr class="memdesc:a79995ab36be778bb2a56eeba80a7abed"><td class="mdescLeft">&#160;</td><td class="mdescRight">Move-constructs from an existing <a class="el" href="classipc_1_1util_1_1Shared__name.html" title="String-wrapping abstraction representing a name uniquely distinguishing a kernel-persistent entity fr...">Shared_name</a>, which is made <a class="el" href="classipc_1_1util_1_1Shared__name.html#a861ea6c9ad6672e83bab5c7747b66f7b" title="Returns true if and only if str().empty() == true.">empty()</a> if not already so.  <a href="classipc_1_1util_1_1Shared__name.html#a79995ab36be778bb2a56eeba80a7abed">More...</a><br /></td></tr>
<tr class="separator:a79995ab36be778bb2a56eeba80a7abed"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a766b98e1a87f4035b6869c78f331c69a"><td class="memTemplParams" colspan="2">template&lt;typename Input_it &gt; </td></tr>
<tr class="memitem:a766b98e1a87f4035b6869c78f331c69a"><td class="memTemplItemLeft" align="right" valign="top">&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classipc_1_1util_1_1Shared__name.html#a766b98e1a87f4035b6869c78f331c69a">Shared_name</a> (Input_it begin, Input_it end)</td></tr>
<tr class="memdesc:a766b98e1a87f4035b6869c78f331c69a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy-constructs from a <code>char</code> range given as a pair of random-iterators; in particular <code>const char*</code>s work.  <a href="classipc_1_1util_1_1Shared__name.html#a766b98e1a87f4035b6869c78f331c69a">More...</a><br /></td></tr>
<tr class="separator:a766b98e1a87f4035b6869c78f331c69a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abd312f9eaf6f07adaba115aaab05b539"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classipc_1_1util_1_1Shared__name.html">Shared_name</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classipc_1_1util_1_1Shared__name.html#abd312f9eaf6f07adaba115aaab05b539">operator=</a> (const <a class="el" href="classipc_1_1util_1_1Shared__name.html">Shared_name</a> &amp;src)</td></tr>
<tr class="memdesc:abd312f9eaf6f07adaba115aaab05b539"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy-assigns from an existing <a class="el" href="classipc_1_1util_1_1Shared__name.html" title="String-wrapping abstraction representing a name uniquely distinguishing a kernel-persistent entity fr...">Shared_name</a>.  <a href="classipc_1_1util_1_1Shared__name.html#abd312f9eaf6f07adaba115aaab05b539">More...</a><br /></td></tr>
<tr class="separator:abd312f9eaf6f07adaba115aaab05b539"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1511bd84d701dd866029d0f4c8869516"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classipc_1_1util_1_1Shared__name.html">Shared_name</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classipc_1_1util_1_1Shared__name.html#a1511bd84d701dd866029d0f4c8869516">operator=</a> (<a class="el" href="classipc_1_1util_1_1Shared__name.html">Shared_name</a> &amp;&amp;src_moved)</td></tr>
<tr class="memdesc:a1511bd84d701dd866029d0f4c8869516"><td class="mdescLeft">&#160;</td><td class="mdescRight">Move-assigns from an existing <a class="el" href="classipc_1_1util_1_1Shared__name.html" title="String-wrapping abstraction representing a name uniquely distinguishing a kernel-persistent entity fr...">Shared_name</a>.  <a href="classipc_1_1util_1_1Shared__name.html#a1511bd84d701dd866029d0f4c8869516">More...</a><br /></td></tr>
<tr class="separator:a1511bd84d701dd866029d0f4c8869516"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae89e1e061f87ffe0288514e254837595"><td class="memItemLeft" align="right" valign="top">const std::string &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classipc_1_1util_1_1Shared__name.html#ae89e1e061f87ffe0288514e254837595">str</a> () const</td></tr>
<tr class="memdesc:ae89e1e061f87ffe0288514e254837595"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns (sans copying) ref to immutable entire wrapped name string, suitable to pass into sys calls when naming supported shared resources assuming <code><a class="el" href="classipc_1_1util_1_1Shared__name.html#ab1934f80515fdbc3e2a59ccda32fff9a" title="Returns true if and only if the first character is S_SEPARATOR.">absolute()</a> == true</code>.  <a href="classipc_1_1util_1_1Shared__name.html#ae89e1e061f87ffe0288514e254837595">More...</a><br /></td></tr>
<tr class="separator:ae89e1e061f87ffe0288514e254837595"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0bccc73c9c5b4f3b784a1e57cdc5c910"><td class="memItemLeft" align="right" valign="top">const char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classipc_1_1util_1_1Shared__name.html#a0bccc73c9c5b4f3b784a1e57cdc5c910">native_str</a> () const</td></tr>
<tr class="memdesc:a0bccc73c9c5b4f3b784a1e57cdc5c910"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns (sans copying) pointer to NUL-terminated wrapped name string, suitable to pass into sys calls when naming supported shared resources assuming <code><a class="el" href="classipc_1_1util_1_1Shared__name.html#ab1934f80515fdbc3e2a59ccda32fff9a" title="Returns true if and only if the first character is S_SEPARATOR.">absolute()</a> == true</code>.  <a href="classipc_1_1util_1_1Shared__name.html#a0bccc73c9c5b4f3b784a1e57cdc5c910">More...</a><br /></td></tr>
<tr class="separator:a0bccc73c9c5b4f3b784a1e57cdc5c910"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af34db2934e116f8a4fdd403fd04695af"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classipc_1_1util_1_1Shared__name.html#af34db2934e116f8a4fdd403fd04695af">size</a> () const</td></tr>
<tr class="memdesc:af34db2934e116f8a4fdd403fd04695af"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns <code><a class="el" href="classipc_1_1util_1_1Shared__name.html#ae89e1e061f87ffe0288514e254837595" title="Returns (sans copying) ref to immutable entire wrapped name string, suitable to pass into sys calls w...">str()</a>.<a class="el" href="classipc_1_1util_1_1Shared__name.html#af34db2934e116f8a4fdd403fd04695af" title="Returns str().size().">size()</a></code>.  <a href="classipc_1_1util_1_1Shared__name.html#af34db2934e116f8a4fdd403fd04695af">More...</a><br /></td></tr>
<tr class="separator:af34db2934e116f8a4fdd403fd04695af"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a861ea6c9ad6672e83bab5c7747b66f7b"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classipc_1_1util_1_1Shared__name.html#a861ea6c9ad6672e83bab5c7747b66f7b">empty</a> () const</td></tr>
<tr class="memdesc:a861ea6c9ad6672e83bab5c7747b66f7b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns <code>true</code> if and only if <code><a class="el" href="classipc_1_1util_1_1Shared__name.html#ae89e1e061f87ffe0288514e254837595" title="Returns (sans copying) ref to immutable entire wrapped name string, suitable to pass into sys calls w...">str()</a>.<a class="el" href="classipc_1_1util_1_1Shared__name.html#a861ea6c9ad6672e83bab5c7747b66f7b" title="Returns true if and only if str().empty() == true.">empty()</a> == true</code>.  <a href="classipc_1_1util_1_1Shared__name.html#a861ea6c9ad6672e83bab5c7747b66f7b">More...</a><br /></td></tr>
<tr class="separator:a861ea6c9ad6672e83bab5c7747b66f7b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a774e872b51100b728e0780b39f563ed9"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classipc_1_1util_1_1Shared__name.html#a774e872b51100b728e0780b39f563ed9">has_trailing_separator</a> () const</td></tr>
<tr class="memdesc:a774e872b51100b728e0780b39f563ed9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns <code>true</code> if and only if <code>!this-&gt;<a class="el" href="classipc_1_1util_1_1Shared__name.html#a861ea6c9ad6672e83bab5c7747b66f7b" title="Returns true if and only if str().empty() == true.">empty()</a></code>, and <a class="el" href="classipc_1_1util_1_1Shared__name.html#ae89e1e061f87ffe0288514e254837595" title="Returns (sans copying) ref to immutable entire wrapped name string, suitable to pass into sys calls w...">str()</a> ends with the <a class="el" href="classipc_1_1util_1_1Shared__name.html#a5c0910497c5ec484d3e42dfb0ccad48d" title="Character we use, by convention, to separate conceptual folders within str().">S_SEPARATOR</a> character.  <a href="classipc_1_1util_1_1Shared__name.html#a774e872b51100b728e0780b39f563ed9">More...</a><br /></td></tr>
<tr class="separator:a774e872b51100b728e0780b39f563ed9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab1934f80515fdbc3e2a59ccda32fff9a"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classipc_1_1util_1_1Shared__name.html#ab1934f80515fdbc3e2a59ccda32fff9a">absolute</a> () const</td></tr>
<tr class="memdesc:ab1934f80515fdbc3e2a59ccda32fff9a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns <code>true</code> if and only if the first character is <a class="el" href="classipc_1_1util_1_1Shared__name.html#a5c0910497c5ec484d3e42dfb0ccad48d" title="Character we use, by convention, to separate conceptual folders within str().">S_SEPARATOR</a>.  <a href="classipc_1_1util_1_1Shared__name.html#ab1934f80515fdbc3e2a59ccda32fff9a">More...</a><br /></td></tr>
<tr class="separator:ab1934f80515fdbc3e2a59ccda32fff9a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8328c9a6bc2739145087515ee8e677d8"><td class="memItemLeft" align="right" valign="top"><a id="a8328c9a6bc2739145087515ee8e677d8" name="a8328c9a6bc2739145087515ee8e677d8"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>clear</b> ()</td></tr>
<tr class="memdesc:a8328c9a6bc2739145087515ee8e677d8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Makes it so <code><a class="el" href="classipc_1_1util_1_1Shared__name.html#a861ea6c9ad6672e83bab5c7747b66f7b" title="Returns true if and only if str().empty() == true.">empty()</a> == true</code>. <br /></td></tr>
<tr class="separator:a8328c9a6bc2739145087515ee8e677d8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a03d90faae35392c8bbdd22f056755ba9"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classipc_1_1util_1_1Shared__name.html#a03d90faae35392c8bbdd22f056755ba9">sanitized</a> () const</td></tr>
<tr class="memdesc:a03d90faae35392c8bbdd22f056755ba9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns <code>true</code> if and only if the contained name/fragment is <em>sanitized</em> according to length, legal characters, and similar.  <a href="classipc_1_1util_1_1Shared__name.html#a03d90faae35392c8bbdd22f056755ba9">More...</a><br /></td></tr>
<tr class="separator:a03d90faae35392c8bbdd22f056755ba9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:add4ed045e03f786427a236a5dfa5a1b0"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classipc_1_1util_1_1Shared__name.html#add4ed045e03f786427a236a5dfa5a1b0">sanitize</a> ()</td></tr>
<tr class="memdesc:add4ed045e03f786427a236a5dfa5a1b0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Best-effort attempt to turn <a class="el" href="classipc_1_1util_1_1Shared__name.html#a03d90faae35392c8bbdd22f056755ba9" title="Returns true if and only if the contained name/fragment is sanitized according to length,...">sanitized()</a> from <code>false</code> to <code>true</code>, unless it is already <code>true</code>; returns the final value of <a class="el" href="classipc_1_1util_1_1Shared__name.html#a03d90faae35392c8bbdd22f056755ba9" title="Returns true if and only if the contained name/fragment is sanitized according to length,...">sanitized()</a> indicating whether it was successful.  <a href="classipc_1_1util_1_1Shared__name.html#add4ed045e03f786427a236a5dfa5a1b0">More...</a><br /></td></tr>
<tr class="separator:add4ed045e03f786427a236a5dfa5a1b0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a956fdac1bb4cfab414b30091bec43f70"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classipc_1_1util_1_1Shared__name.html">Shared_name</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classipc_1_1util_1_1Shared__name.html#a956fdac1bb4cfab414b30091bec43f70">operator/=</a> (const <a class="el" href="classipc_1_1util_1_1Shared__name.html">Shared_name</a> &amp;src_to_append)</td></tr>
<tr class="memdesc:a956fdac1bb4cfab414b30091bec43f70"><td class="mdescLeft">&#160;</td><td class="mdescRight">Appends a folder separator followed by the given other <a class="el" href="classipc_1_1util_1_1Shared__name.html" title="String-wrapping abstraction representing a name uniquely distinguishing a kernel-persistent entity fr...">Shared_name</a>.  <a href="classipc_1_1util_1_1Shared__name.html#a956fdac1bb4cfab414b30091bec43f70">More...</a><br /></td></tr>
<tr class="separator:a956fdac1bb4cfab414b30091bec43f70"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a762bda2d73b31c9427c05c7c1a7abbcb"><td class="memTemplParams" colspan="2">template&lt;typename Source &gt; </td></tr>
<tr class="memitem:a762bda2d73b31c9427c05c7c1a7abbcb"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classipc_1_1util_1_1Shared__name.html">Shared_name</a> &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classipc_1_1util_1_1Shared__name.html#a762bda2d73b31c9427c05c7c1a7abbcb">operator/=</a> (const Source &amp;raw_name_to_append)</td></tr>
<tr class="memdesc:a762bda2d73b31c9427c05c7c1a7abbcb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Simply appends a folder separator followed by <code>raw_name_to_append</code> to the current value of <a class="el" href="classipc_1_1util_1_1Shared__name.html#ae89e1e061f87ffe0288514e254837595" title="Returns (sans copying) ref to immutable entire wrapped name string, suitable to pass into sys calls w...">str()</a>.  <a href="classipc_1_1util_1_1Shared__name.html#a762bda2d73b31c9427c05c7c1a7abbcb">More...</a><br /></td></tr>
<tr class="separator:a762bda2d73b31c9427c05c7c1a7abbcb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a99c77008fb2c507e32e05272812c4782"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classipc_1_1util_1_1Shared__name.html">Shared_name</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classipc_1_1util_1_1Shared__name.html#a99c77008fb2c507e32e05272812c4782">operator/=</a> (const char *raw_name_to_append)</td></tr>
<tr class="memdesc:a99c77008fb2c507e32e05272812c4782"><td class="mdescLeft">&#160;</td><td class="mdescRight">Similar to the overload that takes <code>const Source&amp;</code>, but takes NUL-terminated string instead.  <a href="classipc_1_1util_1_1Shared__name.html#a99c77008fb2c507e32e05272812c4782">More...</a><br /></td></tr>
<tr class="separator:a99c77008fb2c507e32e05272812c4782"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1bcac1c10e01ba11dcc437b3c32bbe6c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classipc_1_1util_1_1Shared__name.html">Shared_name</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classipc_1_1util_1_1Shared__name.html#a1bcac1c10e01ba11dcc437b3c32bbe6c">operator+=</a> (const <a class="el" href="classipc_1_1util_1_1Shared__name.html">Shared_name</a> &amp;src_to_append)</td></tr>
<tr class="memdesc:a1bcac1c10e01ba11dcc437b3c32bbe6c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Appends the given other <a class="el" href="classipc_1_1util_1_1Shared__name.html" title="String-wrapping abstraction representing a name uniquely distinguishing a kernel-persistent entity fr...">Shared_name</a>.  <a href="classipc_1_1util_1_1Shared__name.html#a1bcac1c10e01ba11dcc437b3c32bbe6c">More...</a><br /></td></tr>
<tr class="separator:a1bcac1c10e01ba11dcc437b3c32bbe6c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae168cc42213bf7972d17bbbc1e16f2a2"><td class="memTemplParams" colspan="2">template&lt;typename Source &gt; </td></tr>
<tr class="memitem:ae168cc42213bf7972d17bbbc1e16f2a2"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classipc_1_1util_1_1Shared__name.html">Shared_name</a> &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classipc_1_1util_1_1Shared__name.html#ae168cc42213bf7972d17bbbc1e16f2a2">operator+=</a> (const Source &amp;raw_name_to_append)</td></tr>
<tr class="memdesc:ae168cc42213bf7972d17bbbc1e16f2a2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Simply appends <code>raw_name_to_append</code> to the current value of <a class="el" href="classipc_1_1util_1_1Shared__name.html#ae89e1e061f87ffe0288514e254837595" title="Returns (sans copying) ref to immutable entire wrapped name string, suitable to pass into sys calls w...">str()</a>.  <a href="classipc_1_1util_1_1Shared__name.html#ae168cc42213bf7972d17bbbc1e16f2a2">More...</a><br /></td></tr>
<tr class="separator:ae168cc42213bf7972d17bbbc1e16f2a2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6f3d1055ef0e6d166a9f4532758d36de"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classipc_1_1util_1_1Shared__name.html">Shared_name</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classipc_1_1util_1_1Shared__name.html#a6f3d1055ef0e6d166a9f4532758d36de">operator+=</a> (const char *raw_name_to_append)</td></tr>
<tr class="memdesc:a6f3d1055ef0e6d166a9f4532758d36de"><td class="mdescLeft">&#160;</td><td class="mdescRight">Similar to the overload that takes <code>const Source&amp;</code>, but takes NUL-terminated string instead.  <a href="classipc_1_1util_1_1Shared__name.html#a6f3d1055ef0e6d166a9f4532758d36de">More...</a><br /></td></tr>
<tr class="separator:a6f3d1055ef0e6d166a9f4532758d36de"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-static-methods" name="pub-static-methods"></a>
Static Public Member Functions</h2></td></tr>
<tr class="memitem:a48f20b7b54490aa10dc64081d34c55b2"><td class="memTemplParams" colspan="2">template&lt;typename Source &gt; </td></tr>
<tr class="memitem:a48f20b7b54490aa10dc64081d34c55b2"><td class="memTemplItemLeft" align="right" valign="top">static <a class="el" href="classipc_1_1util_1_1Shared__name.html">Shared_name</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classipc_1_1util_1_1Shared__name.html#a48f20b7b54490aa10dc64081d34c55b2">ct</a> (const Source &amp;src)</td></tr>
<tr class="memdesc:a48f20b7b54490aa10dc64081d34c55b2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy-constructs from a <code>char</code>-sequence container (including <code>string</code>, <a class="el" href="namespaceipc_1_1util.html#ae6ac47812a90d1287c61e0b7de7bc4f5" title="Short-hand for Flow&#39;s String_view.">util::String_view</a>, <code>vector&lt;char&gt;</code>).  <a href="classipc_1_1util_1_1Shared__name.html#a48f20b7b54490aa10dc64081d34c55b2">More...</a><br /></td></tr>
<tr class="separator:a48f20b7b54490aa10dc64081d34c55b2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a66f531c6fa407739fa81b12034351874"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classipc_1_1util_1_1Shared__name.html">Shared_name</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classipc_1_1util_1_1Shared__name.html#a66f531c6fa407739fa81b12034351874">ct</a> (const char *src)</td></tr>
<tr class="memdesc:a66f531c6fa407739fa81b12034351874"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy-constructs from a NUL-terminated <code>const char*</code> string.  <a href="classipc_1_1util_1_1Shared__name.html#a66f531c6fa407739fa81b12034351874">More...</a><br /></td></tr>
<tr class="separator:a66f531c6fa407739fa81b12034351874"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a925d30aa9b3391651303de04f82d4949"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classipc_1_1util_1_1Shared__name.html">Shared_name</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classipc_1_1util_1_1Shared__name.html#a925d30aa9b3391651303de04f82d4949">ct</a> (std::string &amp;&amp;src_moved)</td></tr>
<tr class="memdesc:a925d30aa9b3391651303de04f82d4949"><td class="mdescLeft">&#160;</td><td class="mdescRight">Destructively move-constructs from an <code>std::string</code>, emptying that source object.  <a href="classipc_1_1util_1_1Shared__name.html#a925d30aa9b3391651303de04f82d4949">More...</a><br /></td></tr>
<tr class="separator:a925d30aa9b3391651303de04f82d4949"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-static-attribs" name="pub-static-attribs"></a>
Static Public Attributes</h2></td></tr>
<tr class="memitem:a5bbfb4d3b378cf7b9a1bcaf5d6c5a067"><td class="memItemLeft" align="right" valign="top"><a id="a5bbfb4d3b378cf7b9a1bcaf5d6c5a067" name="a5bbfb4d3b378cf7b9a1bcaf5d6c5a067"></a>
static const <a class="el" href="classipc_1_1util_1_1Shared__name.html">Shared_name</a>&#160;</td><td class="memItemRight" valign="bottom"><b>S_EMPTY</b></td></tr>
<tr class="memdesc:a5bbfb4d3b378cf7b9a1bcaf5d6c5a067"><td class="mdescLeft">&#160;</td><td class="mdescRight">A (default-cted) <a class="el" href="classipc_1_1util_1_1Shared__name.html" title="String-wrapping abstraction representing a name uniquely distinguishing a kernel-persistent entity fr...">Shared_name</a>. May be useful for functions returning <code>const <a class="el" href="classipc_1_1util_1_1Shared__name.html" title="String-wrapping abstraction representing a name uniquely distinguishing a kernel-persistent entity fr...">Shared_name</a>&amp;</code>. <br /></td></tr>
<tr class="separator:a5bbfb4d3b378cf7b9a1bcaf5d6c5a067"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afc9b87fc69d42df3107bf4a27ea66c7c"><td class="memItemLeft" align="right" valign="top">static const size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classipc_1_1util_1_1Shared__name.html#afc9b87fc69d42df3107bf4a27ea66c7c">S_MAX_LENGTH</a> = 75</td></tr>
<tr class="memdesc:afc9b87fc69d42df3107bf4a27ea66c7c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Max value of <a class="el" href="classipc_1_1util_1_1Shared__name.html#af34db2934e116f8a4fdd403fd04695af" title="Returns str().size().">size()</a> such that, if <a class="el" href="classipc_1_1util_1_1Shared__name.html#ae89e1e061f87ffe0288514e254837595" title="Returns (sans copying) ref to immutable entire wrapped name string, suitable to pass into sys calls w...">str()</a> used to name a supported shared resource, sys call safely won't barf.  <a href="classipc_1_1util_1_1Shared__name.html#afc9b87fc69d42df3107bf4a27ea66c7c">More...</a><br /></td></tr>
<tr class="separator:afc9b87fc69d42df3107bf4a27ea66c7c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5c0910497c5ec484d3e42dfb0ccad48d"><td class="memItemLeft" align="right" valign="top"><a id="a5c0910497c5ec484d3e42dfb0ccad48d" name="a5c0910497c5ec484d3e42dfb0ccad48d"></a>
static const char&#160;</td><td class="memItemRight" valign="bottom"><b>S_SEPARATOR</b> = '_'</td></tr>
<tr class="memdesc:a5c0910497c5ec484d3e42dfb0ccad48d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Character we use, by convention, to separate conceptual folders within <a class="el" href="classipc_1_1util_1_1Shared__name.html#ae89e1e061f87ffe0288514e254837595" title="Returns (sans copying) ref to immutable entire wrapped name string, suitable to pass into sys calls w...">str()</a>. <br /></td></tr>
<tr class="separator:a5c0910497c5ec484d3e42dfb0ccad48d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af08b45aa719d4f5dced595cca39ab2c8"><td class="memItemLeft" align="right" valign="top"><a id="af08b45aa719d4f5dced595cca39ab2c8" name="af08b45aa719d4f5dced595cca39ab2c8"></a>
static const <a class="el" href="classipc_1_1util_1_1Shared__name.html">Shared_name</a>&#160;</td><td class="memItemRight" valign="bottom"><b>S_ROOT_MAGIC</b> = <a class="el" href="classipc_1_1util_1_1Shared__name.html#a48f20b7b54490aa10dc64081d34c55b2">Shared_name::ct</a>(&quot;libipc&quot;)</td></tr>
<tr class="memdesc:af08b45aa719d4f5dced595cca39ab2c8"><td class="mdescLeft">&#160;</td><td class="mdescRight">A <a class="el" href="classipc_1_1util_1_1Shared__name.html" title="String-wrapping abstraction representing a name uniquely distinguishing a kernel-persistent entity fr...">Shared_name</a> fragment, with no <a class="el" href="classipc_1_1util_1_1Shared__name.html#a5c0910497c5ec484d3e42dfb0ccad48d" title="Character we use, by convention, to separate conceptual folders within str().">S_SEPARATOR</a> characters inside, to be used in any <a class="el" href="classipc_1_1util_1_1Shared__name.html" title="String-wrapping abstraction representing a name uniquely distinguishing a kernel-persistent entity fr...">Shared_name</a> maintained by <a class="el" href="namespaceipc.html" title="Catch-all namespace for the Flow-IPC project: A library/API in modern C++17 providing high-performanc...">ipc</a> itself as the leading path component. <br /></td></tr>
<tr class="separator:af08b45aa719d4f5dced595cca39ab2c8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a43205a00865429c1bef6c7896816bf5c"><td class="memItemLeft" align="right" valign="top">static const <a class="el" href="classipc_1_1util_1_1Shared__name.html">Shared_name</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classipc_1_1util_1_1Shared__name.html#a43205a00865429c1bef6c7896816bf5c">S_SENTINEL</a> = <a class="el" href="classipc_1_1util_1_1Shared__name.html#a48f20b7b54490aa10dc64081d34c55b2">Shared_name::ct</a>(&quot;0&quot;)</td></tr>
<tr class="memdesc:a43205a00865429c1bef6c7896816bf5c"><td class="mdescLeft">&#160;</td><td class="mdescRight">A <a class="el" href="classipc_1_1util_1_1Shared__name.html" title="String-wrapping abstraction representing a name uniquely distinguishing a kernel-persistent entity fr...">Shared_name</a> fragment, with no <a class="el" href="classipc_1_1util_1_1Shared__name.html#a5c0910497c5ec484d3e42dfb0ccad48d" title="Character we use, by convention, to separate conceptual folders within str().">S_SEPARATOR</a> characters inside, that represents a path component that shall be different from any other generated string at the same path depth in the same context; and represents a sentinel.  <a href="classipc_1_1util_1_1Shared__name.html#a43205a00865429c1bef6c7896816bf5c">More...</a><br /></td></tr>
<tr class="separator:a43205a00865429c1bef6c7896816bf5c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaa78ddb3efa5abe4fa80058dedbef68c"><td class="memItemLeft" align="right" valign="top">static const <a class="el" href="classipc_1_1util_1_1Shared__name.html">Shared_name</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classipc_1_1util_1_1Shared__name.html#aaa78ddb3efa5abe4fa80058dedbef68c">S_1ST_OR_ONLY</a> = <a class="el" href="classipc_1_1util_1_1Shared__name.html#a48f20b7b54490aa10dc64081d34c55b2">Shared_name::ct</a>(&quot;1&quot;)</td></tr>
<tr class="memdesc:aaa78ddb3efa5abe4fa80058dedbef68c"><td class="mdescLeft">&#160;</td><td class="mdescRight">A <a class="el" href="classipc_1_1util_1_1Shared__name.html" title="String-wrapping abstraction representing a name uniquely distinguishing a kernel-persistent entity fr...">Shared_name</a> fragment, with no <a class="el" href="classipc_1_1util_1_1Shared__name.html#a5c0910497c5ec484d3e42dfb0ccad48d" title="Character we use, by convention, to separate conceptual folders within str().">S_SEPARATOR</a> characters inside, that represents a path component that (1) is not <a class="el" href="classipc_1_1util_1_1Shared__name.html#a43205a00865429c1bef6c7896816bf5c" title="A Shared_name fragment, with no S_SEPARATOR characters inside, that represents a path component that ...">S_SENTINEL</a> and (2) is suggested as the <em>first</em> or <em>only</em> unique ID of items at the same depth in the same context.  <a href="classipc_1_1util_1_1Shared__name.html#aaa78ddb3efa5abe4fa80058dedbef68c">More...</a><br /></td></tr>
<tr class="separator:aaa78ddb3efa5abe4fa80058dedbef68c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4c294e23753eb706b4c297d99d24cd48"><td class="memItemLeft" align="right" valign="top"><a id="a4c294e23753eb706b4c297d99d24cd48" name="a4c294e23753eb706b4c297d99d24cd48"></a>
static const <a class="el" href="classipc_1_1util_1_1Shared__name.html">Shared_name</a>&#160;</td><td class="memItemRight" valign="bottom"><b>S_RESOURCE_TYPE_ID_SHM</b> = <a class="el" href="classipc_1_1util_1_1Shared__name.html#a48f20b7b54490aa10dc64081d34c55b2">Shared_name::ct</a>(&quot;shm&quot;)</td></tr>
<tr class="memdesc:a4c294e23753eb706b4c297d99d24cd48"><td class="mdescLeft">&#160;</td><td class="mdescRight">Relative-folder fragment (no separators) identifying the resource type for: SHM pools. <br /></td></tr>
<tr class="separator:a4c294e23753eb706b4c297d99d24cd48"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a50cb5d2ad8f8b4391e1885e7b8f63890"><td class="memItemLeft" align="right" valign="top"><a id="a50cb5d2ad8f8b4391e1885e7b8f63890" name="a50cb5d2ad8f8b4391e1885e7b8f63890"></a>
static const <a class="el" href="classipc_1_1util_1_1Shared__name.html">Shared_name</a>&#160;</td><td class="memItemRight" valign="bottom"><b>S_RESOURCE_TYPE_ID_MUTEX</b> = <a class="el" href="classipc_1_1util_1_1Shared__name.html#a48f20b7b54490aa10dc64081d34c55b2">Shared_name::ct</a>(&quot;mtx&quot;)</td></tr>
<tr class="memdesc:a50cb5d2ad8f8b4391e1885e7b8f63890"><td class="mdescLeft">&#160;</td><td class="mdescRight">Relative-folder fragment (no separators) identifying the resource type for: boost.interprocess named mutex. <br /></td></tr>
<tr class="separator:a50cb5d2ad8f8b4391e1885e7b8f63890"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="related" name="related"></a>
Related Functions</h2></td></tr>
<tr><td class="ititle" colspan="2"><p >(Note that these are not member functions.) </p>
</td></tr>
<tr class="memitem:a15ea67c1855a678f7e948b24ccf2c1cd"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classipc_1_1util_1_1Shared__name.html">Shared_name</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classipc_1_1util_1_1Shared__name.html#a15ea67c1855a678f7e948b24ccf2c1cd">operator/</a> (const <a class="el" href="classipc_1_1util_1_1Shared__name.html">Shared_name</a> &amp;src1, const <a class="el" href="classipc_1_1util_1_1Shared__name.html">Shared_name</a> &amp;src2)</td></tr>
<tr class="memdesc:a15ea67c1855a678f7e948b24ccf2c1cd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns new object equal to <code>Shared_name(src1) /= src2</code>.  <a href="classipc_1_1util_1_1Shared__name.html#a15ea67c1855a678f7e948b24ccf2c1cd">More...</a><br /></td></tr>
<tr class="separator:a15ea67c1855a678f7e948b24ccf2c1cd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a910207a2da57b61cee4a22899e239dc2"><td class="memTemplParams" colspan="2">template&lt;typename Source &gt; </td></tr>
<tr class="memitem:a910207a2da57b61cee4a22899e239dc2"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classipc_1_1util_1_1Shared__name.html">Shared_name</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classipc_1_1util_1_1Shared__name.html#a910207a2da57b61cee4a22899e239dc2">operator/</a> (const <a class="el" href="classipc_1_1util_1_1Shared__name.html">Shared_name</a> &amp;src1, const Source &amp;raw_src2)</td></tr>
<tr class="memdesc:a910207a2da57b61cee4a22899e239dc2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns new object equal to <code>Shared_name(src1) /= raw_src2</code>.  <a href="classipc_1_1util_1_1Shared__name.html#a910207a2da57b61cee4a22899e239dc2">More...</a><br /></td></tr>
<tr class="separator:a910207a2da57b61cee4a22899e239dc2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa61c6b31c5c4e241c97f06a4d38c76c4"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classipc_1_1util_1_1Shared__name.html">Shared_name</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classipc_1_1util_1_1Shared__name.html#aa61c6b31c5c4e241c97f06a4d38c76c4">operator/</a> (const <a class="el" href="classipc_1_1util_1_1Shared__name.html">Shared_name</a> &amp;src1, const char *raw_src2)</td></tr>
<tr class="memdesc:aa61c6b31c5c4e241c97f06a4d38c76c4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns new object equal to <code>Shared_name(src1) /= raw_src2</code>.  <a href="classipc_1_1util_1_1Shared__name.html#aa61c6b31c5c4e241c97f06a4d38c76c4">More...</a><br /></td></tr>
<tr class="separator:aa61c6b31c5c4e241c97f06a4d38c76c4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a462b81d34ba23c968f63d9805fa74538"><td class="memTemplParams" colspan="2">template&lt;typename Source &gt; </td></tr>
<tr class="memitem:a462b81d34ba23c968f63d9805fa74538"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classipc_1_1util_1_1Shared__name.html">Shared_name</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classipc_1_1util_1_1Shared__name.html#a462b81d34ba23c968f63d9805fa74538">operator/</a> (const Source &amp;raw_src1, const <a class="el" href="classipc_1_1util_1_1Shared__name.html">Shared_name</a> &amp;src2)</td></tr>
<tr class="memdesc:a462b81d34ba23c968f63d9805fa74538"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns new object equal to <code>Shared_name(raw_src1) /= src2</code>.  <a href="classipc_1_1util_1_1Shared__name.html#a462b81d34ba23c968f63d9805fa74538">More...</a><br /></td></tr>
<tr class="separator:a462b81d34ba23c968f63d9805fa74538"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7f2bead5935309c2f760645fe46ddd71"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classipc_1_1util_1_1Shared__name.html">Shared_name</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classipc_1_1util_1_1Shared__name.html#a7f2bead5935309c2f760645fe46ddd71">operator/</a> (const char *raw_src1, const <a class="el" href="classipc_1_1util_1_1Shared__name.html">Shared_name</a> &amp;src2)</td></tr>
<tr class="memdesc:a7f2bead5935309c2f760645fe46ddd71"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns new object equal to <code>Shared_name(raw_src1) /= src2</code>.  <a href="classipc_1_1util_1_1Shared__name.html#a7f2bead5935309c2f760645fe46ddd71">More...</a><br /></td></tr>
<tr class="separator:a7f2bead5935309c2f760645fe46ddd71"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a54dc5077333284fda9e8d2df8b0e9b91"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classipc_1_1util_1_1Shared__name.html">Shared_name</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classipc_1_1util_1_1Shared__name.html#a54dc5077333284fda9e8d2df8b0e9b91">operator+</a> (const <a class="el" href="classipc_1_1util_1_1Shared__name.html">Shared_name</a> &amp;src1, const <a class="el" href="classipc_1_1util_1_1Shared__name.html">Shared_name</a> &amp;src2)</td></tr>
<tr class="memdesc:a54dc5077333284fda9e8d2df8b0e9b91"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns new object equal to <code>Shared_name(src1) += src2</code>.  <a href="classipc_1_1util_1_1Shared__name.html#a54dc5077333284fda9e8d2df8b0e9b91">More...</a><br /></td></tr>
<tr class="separator:a54dc5077333284fda9e8d2df8b0e9b91"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a52b2ba03d5ace7389991bb5d31b9fa59"><td class="memTemplParams" colspan="2">template&lt;typename Source &gt; </td></tr>
<tr class="memitem:a52b2ba03d5ace7389991bb5d31b9fa59"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classipc_1_1util_1_1Shared__name.html">Shared_name</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classipc_1_1util_1_1Shared__name.html#a52b2ba03d5ace7389991bb5d31b9fa59">operator+</a> (const <a class="el" href="classipc_1_1util_1_1Shared__name.html">Shared_name</a> &amp;src1, const Source &amp;raw_src2)</td></tr>
<tr class="memdesc:a52b2ba03d5ace7389991bb5d31b9fa59"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns new object equal to <code>Shared_name(src1) += raw_src2</code>.  <a href="classipc_1_1util_1_1Shared__name.html#a52b2ba03d5ace7389991bb5d31b9fa59">More...</a><br /></td></tr>
<tr class="separator:a52b2ba03d5ace7389991bb5d31b9fa59"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af61b02fd66b67aeed5a803ca47e52973"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classipc_1_1util_1_1Shared__name.html">Shared_name</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classipc_1_1util_1_1Shared__name.html#af61b02fd66b67aeed5a803ca47e52973">operator+</a> (const <a class="el" href="classipc_1_1util_1_1Shared__name.html">Shared_name</a> &amp;src1, const char *raw_src2)</td></tr>
<tr class="memdesc:af61b02fd66b67aeed5a803ca47e52973"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns new object equal to <code>Shared_name(src1) += raw_src2</code>.  <a href="classipc_1_1util_1_1Shared__name.html#af61b02fd66b67aeed5a803ca47e52973">More...</a><br /></td></tr>
<tr class="separator:af61b02fd66b67aeed5a803ca47e52973"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1f1a40877cc08b287f8f3c7e7f663782"><td class="memTemplParams" colspan="2">template&lt;typename Source &gt; </td></tr>
<tr class="memitem:a1f1a40877cc08b287f8f3c7e7f663782"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classipc_1_1util_1_1Shared__name.html">Shared_name</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classipc_1_1util_1_1Shared__name.html#a1f1a40877cc08b287f8f3c7e7f663782">operator+</a> (const Source &amp;raw_src1, const <a class="el" href="classipc_1_1util_1_1Shared__name.html">Shared_name</a> &amp;src2)</td></tr>
<tr class="memdesc:a1f1a40877cc08b287f8f3c7e7f663782"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns new object equal to <code>Shared_name(src2)</code> with <code>raw_src1</code> pre-pended to it.  <a href="classipc_1_1util_1_1Shared__name.html#a1f1a40877cc08b287f8f3c7e7f663782">More...</a><br /></td></tr>
<tr class="separator:a1f1a40877cc08b287f8f3c7e7f663782"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a096c71dede7bd5528215ac01a380a189"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classipc_1_1util_1_1Shared__name.html">Shared_name</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classipc_1_1util_1_1Shared__name.html#a096c71dede7bd5528215ac01a380a189">operator+</a> (const char *raw_src1, const <a class="el" href="classipc_1_1util_1_1Shared__name.html">Shared_name</a> &amp;src2)</td></tr>
<tr class="memdesc:a096c71dede7bd5528215ac01a380a189"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns new object equal to <code>Shared_name(src2)</code> with <code>raw_src1</code> pre-pended to it.  <a href="classipc_1_1util_1_1Shared__name.html#a096c71dede7bd5528215ac01a380a189">More...</a><br /></td></tr>
<tr class="separator:a096c71dede7bd5528215ac01a380a189"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af7728c93fdf29479bbb2482e02f05cbf"><td class="memItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classipc_1_1util_1_1Shared__name.html#af7728c93fdf29479bbb2482e02f05cbf">operator&lt;&lt;</a> (std::ostream &amp;os, const <a class="el" href="classipc_1_1util_1_1Shared__name.html">Shared_name</a> &amp;val)</td></tr>
<tr class="memdesc:af7728c93fdf29479bbb2482e02f05cbf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Prints embellished string representation of the given <a class="el" href="classipc_1_1util_1_1Shared__name.html" title="String-wrapping abstraction representing a name uniquely distinguishing a kernel-persistent entity fr...">Shared_name</a> to the given <code>ostream</code>.  <a href="classipc_1_1util_1_1Shared__name.html#af7728c93fdf29479bbb2482e02f05cbf">More...</a><br /></td></tr>
<tr class="separator:af7728c93fdf29479bbb2482e02f05cbf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adfd8805e0d37556102cad7b191fee9a3"><td class="memItemLeft" align="right" valign="top">std::istream &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classipc_1_1util_1_1Shared__name.html#adfd8805e0d37556102cad7b191fee9a3">operator&gt;&gt;</a> (std::istream &amp;is, <a class="el" href="classipc_1_1util_1_1Shared__name.html">Shared_name</a> &amp;val)</td></tr>
<tr class="memdesc:adfd8805e0d37556102cad7b191fee9a3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reads <a class="el" href="classipc_1_1util_1_1Shared__name.html" title="String-wrapping abstraction representing a name uniquely distinguishing a kernel-persistent entity fr...">Shared_name</a> from the given <code>istream</code>; equivalent to reading <code>string</code> into <a class="el" href="classipc_1_1util_1_1Shared__name.html#ae89e1e061f87ffe0288514e254837595" title="Returns (sans copying) ref to immutable entire wrapped name string, suitable to pass into sys calls w...">Shared_name::str()</a>.  <a href="classipc_1_1util_1_1Shared__name.html#adfd8805e0d37556102cad7b191fee9a3">More...</a><br /></td></tr>
<tr class="separator:adfd8805e0d37556102cad7b191fee9a3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aba4ae811264cbb7e664ce126b591cbc7"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classipc_1_1util_1_1Shared__name.html#aba4ae811264cbb7e664ce126b591cbc7">hash_value</a> (const <a class="el" href="classipc_1_1util_1_1Shared__name.html">Shared_name</a> &amp;val)</td></tr>
<tr class="memdesc:aba4ae811264cbb7e664ce126b591cbc7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Hasher of <a class="el" href="classipc_1_1util_1_1Shared__name.html" title="String-wrapping abstraction representing a name uniquely distinguishing a kernel-persistent entity fr...">Shared_name</a> for boost.unordered et al.  <a href="classipc_1_1util_1_1Shared__name.html#aba4ae811264cbb7e664ce126b591cbc7">More...</a><br /></td></tr>
<tr class="separator:aba4ae811264cbb7e664ce126b591cbc7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9ea22a64cfbc6de66181c278ff5f6975"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classipc_1_1util_1_1Shared__name.html#a9ea22a64cfbc6de66181c278ff5f6975">swap</a> (<a class="el" href="classipc_1_1util_1_1Shared__name.html">Shared_name</a> &amp;val1, <a class="el" href="classipc_1_1util_1_1Shared__name.html">Shared_name</a> &amp;val2)</td></tr>
<tr class="memdesc:a9ea22a64cfbc6de66181c278ff5f6975"><td class="mdescLeft">&#160;</td><td class="mdescRight">Swaps two objects.  <a href="classipc_1_1util_1_1Shared__name.html#a9ea22a64cfbc6de66181c278ff5f6975">More...</a><br /></td></tr>
<tr class="separator:a9ea22a64cfbc6de66181c278ff5f6975"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p >String-wrapping abstraction representing a name uniquely distinguishing a kernel-persistent entity from all others in the system, or a fragment of such a name. </p>
<p >Conceptually it relates to <code>std::string</code> similarly to how <code>filesystem::path</code> does.</p>
<p >This is a very simple class in terms of what logic it actually adds: it encapsulates an <code>std::string</code> and allows for, basically, string operations like concatenation, with some syntactic sugar added for a simple <em>folder</em> convention. However, the design <em>context</em> (namely, how shared resources are named and why) is less trivial, and this doc header is a good place to get into those topics as well. Hence, we first cover practical aspects, with the architectural context referenced only as needed. Then, below that, there's an architecture discussion about naming in general.</p>
<h3>Construction/assignment from and conversion to strings/similar</h3>
<p >Interanally it stores an <code>std::string</code>.</p>
<p >Conversion: That <code>string</code> is accessible by <code>const&amp;</code> via <a class="el" href="classipc_1_1util_1_1Shared__name.html#ae89e1e061f87ffe0288514e254837595" title="Returns (sans copying) ref to immutable entire wrapped name string, suitable to pass into sys calls w...">str()</a> and similarly the NUL-terminated <a class="el" href="classipc_1_1util_1_1Shared__name.html#a0bccc73c9c5b4f3b784a1e57cdc5c910" title="Returns (sans copying) pointer to NUL-terminated wrapped name string, suitable to pass into sys calls...">native_str()</a>. Also there is an <code>ostream&lt;&lt;</code> printer; do note it does not simply print <a class="el" href="classipc_1_1util_1_1Shared__name.html#ae89e1e061f87ffe0288514e254837595" title="Returns (sans copying) ref to immutable entire wrapped name string, suitable to pass into sys calls w...">str()</a> but rather a beautified version. (<code>ostream&gt;&gt;</code> input is also provided but is identical to <code>ostream &gt;&gt; string</code>.)</p>
<p >Construction/assignment: It comes with standard default/copy/move ctors and assignment. There is also a constructor that takes two iterators-to-<code>char</code> (including 2 <code>const char*</code>). However, construction from <code>string</code> (including destuctive move-construction), <a class="el" href="namespaceipc_1_1util.html#ae6ac47812a90d1287c61e0b7de7bc4f5" title="Short-hand for Flow&#39;s String_view.">util::String_view</a>, NUL-terminated <code>const char*</code>, <code>vector&lt;char&gt;</code> (etc.) is available exclusively in the form of <code>static</code> quasi-ctors <a class="el" href="classipc_1_1util_1_1Shared__name.html#a48f20b7b54490aa10dc64081d34c55b2" title="Copy-constructs from a char-sequence container (including string, util::String_view,...">ct()</a>. Lastly: To assign please use move ctor: <code>existing_sh_name = Shared_name::ct(src)</code>.</p>
<p >Rationale: C++ ADL semantics cause a ton of super-annoying problems &ndash; especially inside <a class="el" href="namespaceipc_1_1transport.html" title="Flow-IPC module providing transmission of structured messages and/or low-level blobs (and more) betwe...">ipc::transport</a> namespace itself &ndash; where compilers will auto-convert, e.g., a <code>string</code> to <code><a class="el" href="classipc_1_1util_1_1Shared__name.html" title="String-wrapping abstraction representing a name uniquely distinguishing a kernel-persistent entity fr...">Shared_name</a></code> without being asked to do so at all. For example, one sees <code>operator &lt;&lt; string</code> output the <code>string</code> in "beautified" form, because a <code><a class="el" href="classipc_1_1util_1_1Shared__name.html" title="String-wrapping abstraction representing a name uniquely distinguishing a kernel-persistent entity fr...">Shared_name</a></code> is constructed implicitly and then printed via its <code>&lt;&lt;</code>. I (ygoldfel), then, took a cue from boost.asio's IP address classes which use <code>static</code> quasi-ctors to avoid any such issues. (The alternative was to fine-tune the ctor set a-la <code>filesystem::path</code>, with conversion traits and all kinds of craziness.)</p>
<h3>Practical <a class="el" href="classipc_1_1util_1_1Shared__name.html" title="String-wrapping abstraction representing a name uniquely distinguishing a kernel-persistent entity fr...">Shared_name</a> matters</h3>
<p >A <em>shared resource</em> in this context is some entity (such as a SHM-mapped addressable area; or a POSIX message queue) that can be <em>opened</em> for further access by potentially 2+ processes simultaneously. When opening (at least), the shared resource is referred to &ndash; in the associated opening sys call or similar &ndash; by a string name, and the name works equally from those 2+ processes. <a class="el" href="classipc_1_1util_1_1Shared__name.html" title="String-wrapping abstraction representing a name uniquely distinguishing a kernel-persistent entity fr...">Shared_name</a> stores such a string. It is also suitable for <em>fragments</em> of these names, including prefixes, suffixes, or middle parts. Therefore &ndash; much like <code>boost::filesystem::path</code> is basically a string wrapper &ndash; <a class="el" href="classipc_1_1util_1_1Shared__name.html" title="String-wrapping abstraction representing a name uniquely distinguishing a kernel-persistent entity fr...">Shared_name</a> is just a string wrapper. In fact the <code>std::string</code> it stores is accessible through <a class="el" href="classipc_1_1util_1_1Shared__name.html#ae89e1e061f87ffe0288514e254837595" title="Returns (sans copying) ref to immutable entire wrapped name string, suitable to pass into sys calls w...">str()</a> by reference.</p>
<p >All standard string-like operations (generally, the <code>+=</code>, <code>/=</code>, <code>+</code>, and <code>/</code> operations) are equally performant and not <em>any</em> smarter than the corresponding string concatenation ops (the <code>/</code> variants just add a separator character). The same holds for all operations, except see the next section. In particular, all characters are allowed in any position, and there is no max length enforced. Hence, the user may assume max possible performance and zero restrictions, with the exception of:</p>
<h3>Conventions understood/enforced by <a class="el" href="classipc_1_1util_1_1Shared__name.html" title="String-wrapping abstraction representing a name uniquely distinguishing a kernel-persistent entity fr...">Shared_name</a></h3>
<p >As noted, generally the class allows everything and does nothing smart that <code>std::string</code> wouldn't do. This is for flexibility and performance and is inspired by <code>boost::filesystem::path</code>. However, there is <em>optional</em> support for some simple conventions. First let's discuss those conventions:</p>
<p >In Flow-IPC, <a class="el" href="classipc_1_1util_1_1Shared__name.html" title="String-wrapping abstraction representing a name uniquely distinguishing a kernel-persistent entity fr...">Shared_name</a> is to be used for all shared resource <em>types</em> needed. (These are not enumerated here.) Different resource types might have different rules for (1) characters allowed; and (2) max length allowed; so that if this is violated, a creation/opening sys call (or similar) will fail with an error. Therefore, the following <em>conventions</em> are understood and represent the <em>union</em> of known system restrictions, so that <a class="el" href="classipc_1_1util_1_1Shared__name.html#a03d90faae35392c8bbdd22f056755ba9" title="Returns true if and only if the contained name/fragment is sanitized according to length,...">sanitized()</a> names will work for <em>all</em> known resource types. Also, some conventions are for human usability. In total, these conventions are understood:</p><ul>
<li>Only certain characters are allowed. Namely, only alphanumerics [A-Za-z0-9] are allowed as of this writing.</li>
<li>There is a <em>folder</em> convention: We anticipate a file tree-like organization of various items; hence a folder separator character, <a class="el" href="classipc_1_1util_1_1Shared__name.html#a5c0910497c5ec484d3e42dfb0ccad48d" title="Character we use, by convention, to separate conceptual folders within str().">S_SEPARATOR</a>, is allowed also.<ul>
<li>A complete, usable (in a sys call or similar) name is to start with one leading <a class="el" href="classipc_1_1util_1_1Shared__name.html#a5c0910497c5ec484d3e42dfb0ccad48d" title="Character we use, by convention, to separate conceptual folders within str().">S_SEPARATOR</a>.</li>
<li>We anticipate no empty "folder" names; and therefore no sequences of 2+ adjacent <a class="el" href="classipc_1_1util_1_1Shared__name.html#a5c0910497c5ec484d3e42dfb0ccad48d" title="Character we use, by convention, to separate conceptual folders within str().">S_SEPARATOR</a> chars.</li>
</ul>
</li>
<li>Names shall not exceed a certain max length. <a class="el" href="classipc_1_1util_1_1Shared__name.html#afc9b87fc69d42df3107bf4a27ea66c7c" title="Max value of size() such that, if str() used to name a supported shared resource, sys call safely won...">S_MAX_LENGTH</a> is chosen to be low enough to work for all supported resource types.</li>
</ul>
<p >How does <a class="el" href="classipc_1_1util_1_1Shared__name.html" title="String-wrapping abstraction representing a name uniquely distinguishing a kernel-persistent entity fr...">Shared_name</a> actually <em>use</em> the knowledge of these conventions? To reiterate: normally, it does not care. The only parts of its API that <em>do</em> care are as follows:</p><ul>
<li><a class="el" href="classipc_1_1util_1_1Shared__name.html#ab1934f80515fdbc3e2a59ccda32fff9a" title="Returns true if and only if the first character is S_SEPARATOR.">absolute()</a> will return <code>true</code> if and only if the first char is <a class="el" href="classipc_1_1util_1_1Shared__name.html#a5c0910497c5ec484d3e42dfb0ccad48d" title="Character we use, by convention, to separate conceptual folders within str().">S_SEPARATOR</a>. By convention, you should not pass <a class="el" href="classipc_1_1util_1_1Shared__name.html#ae89e1e061f87ffe0288514e254837595" title="Returns (sans copying) ref to immutable entire wrapped name string, suitable to pass into sys calls w...">str()</a> to a sys call/similar, unless <code><a class="el" href="classipc_1_1util_1_1Shared__name.html#ab1934f80515fdbc3e2a59ccda32fff9a" title="Returns true if and only if the first character is S_SEPARATOR.">absolute()</a> == true</code>.</li>
<li><a class="el" href="classipc_1_1util_1_1Shared__name.html#a03d90faae35392c8bbdd22f056755ba9" title="Returns true if and only if the contained name/fragment is sanitized according to length,...">sanitized()</a> will return <code>true</code> if and only if <a class="el" href="classipc_1_1util_1_1Shared__name.html#ae89e1e061f87ffe0288514e254837595" title="Returns (sans copying) ref to immutable entire wrapped name string, suitable to pass into sys calls w...">str()</a> is a valid name or name fragment (no illegal characters; does not exceed <a class="el" href="classipc_1_1util_1_1Shared__name.html#afc9b87fc69d42df3107bf4a27ea66c7c" title="Max value of size() such that, if str() used to name a supported shared resource, sys call safely won...">S_MAX_LENGTH</a>; no multi-separator sequences).</li>
<li><a class="el" href="classipc_1_1util_1_1Shared__name.html#add4ed045e03f786427a236a5dfa5a1b0" title="Best-effort attempt to turn sanitized() from false to true, unless it is already true; returns the fi...">sanitize()</a> will attempt to non-destructively modify (if needed) name in such a way as to make <a class="el" href="classipc_1_1util_1_1Shared__name.html#a03d90faae35392c8bbdd22f056755ba9" title="Returns true if and only if the contained name/fragment is sanitized according to length,...">sanitized()</a> return <code>true</code>. You should call them only when you specifically need some conventions checked or enforced. Otherwise <a class="el" href="classipc_1_1util_1_1Shared__name.html" title="String-wrapping abstraction representing a name uniquely distinguishing a kernel-persistent entity fr...">Shared_name</a> ops will be as dumb/fast as possible.</li>
</ul>
<dl class="section note"><dt>Note</dt><dd>The Flow-IPC library <em>user</em> is unlikely to directly pass a <a class="el" href="classipc_1_1util_1_1Shared__name.html" title="String-wrapping abstraction representing a name uniquely distinguishing a kernel-persistent entity fr...">Shared_name</a> into a sys call or similar. Probably Flow-IPC internals will do it for the user. Therefore, the likeliest pattern for the user to encounter in public Flow-IPC APIs is: When initially naming some <code>transport</code> object, a constructor or factory will take a <em>relative</em> (<code><a class="el" href="classipc_1_1util_1_1Shared__name.html#ab1934f80515fdbc3e2a59ccda32fff9a" title="Returns true if and only if the first character is S_SEPARATOR.">absolute()</a> == false</code>) <a class="el" href="classipc_1_1util_1_1Shared__name.html" title="String-wrapping abstraction representing a name uniquely distinguishing a kernel-persistent entity fr...">Shared_name</a> prepared by the user. Within that relative fragment, the user is to use the folder conventions above (via <code>/=</code> or <code>/</code> operators perhaps) if needed. Inside Flow-IPC, the impl can then construct an absolute name by internally pre-pending stuff to the user-constructed fragment. If you have ensured the name is <a class="el" href="classipc_1_1util_1_1Shared__name.html#a03d90faae35392c8bbdd22f056755ba9" title="Returns true if and only if the contained name/fragment is sanitized according to length,...">sanitized()</a>, then it will not fail on account of a bad name. If you have <em>not</em>, then it may still not fail: <a class="el" href="classipc_1_1util_1_1Shared__name.html#a03d90faae35392c8bbdd22f056755ba9" title="Returns true if and only if the contained name/fragment is sanitized according to length,...">sanitized()</a> is a conservative criterion and may be too stringent for some resource types and OS calls. It is up to <em>you</em> to either ensure <a class="el" href="classipc_1_1util_1_1Shared__name.html#a03d90faae35392c8bbdd22f056755ba9" title="Returns true if and only if the contained name/fragment is sanitized according to length,...">sanitized()</a> or otherwise worry about the possibility of a bad name (illegal characters, excessive length).</dd></dl>
<h3>Thread safety</h3>
<p ><a class="el" href="classipc_1_1util_1_1Shared__name.html" title="String-wrapping abstraction representing a name uniquely distinguishing a kernel-persistent entity fr...">Shared_name</a> has the same safety under concurrency as <code>std::string</code> (i.e., if you intend on writing while reading/writing same <code>*this</code> concurrently, synchronized access is necessary to avoid corruption and other standard thread safety violations). </p>
</div><h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="a1e9cad5a94d78e1180a9e77877009873" name="a1e9cad5a94d78e1180a9e77877009873"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1e9cad5a94d78e1180a9e77877009873">&#9670;&nbsp;</a></span>Shared_name() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">ipc::util::Shared_name::Shared_name </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classipc_1_1util_1_1Shared__name.html">Shared_name</a> &amp;&#160;</td>
          <td class="paramname"><em>src</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">default</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Copy-constructs from an existing <a class="el" href="classipc_1_1util_1_1Shared__name.html" title="String-wrapping abstraction representing a name uniquely distinguishing a kernel-persistent entity fr...">Shared_name</a>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">src</td><td>Source object. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a79995ab36be778bb2a56eeba80a7abed" name="a79995ab36be778bb2a56eeba80a7abed"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a79995ab36be778bb2a56eeba80a7abed">&#9670;&nbsp;</a></span>Shared_name() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">ipc::util::Shared_name::Shared_name </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classipc_1_1util_1_1Shared__name.html">Shared_name</a> &amp;&amp;&#160;</td>
          <td class="paramname"><em>src_moved</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">default</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Move-constructs from an existing <a class="el" href="classipc_1_1util_1_1Shared__name.html" title="String-wrapping abstraction representing a name uniquely distinguishing a kernel-persistent entity fr...">Shared_name</a>, which is made <a class="el" href="classipc_1_1util_1_1Shared__name.html#a861ea6c9ad6672e83bab5c7747b66f7b" title="Returns true if and only if str().empty() == true.">empty()</a> if not already so. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">src_moved</td><td>Source object, which is potentially modified. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a766b98e1a87f4035b6869c78f331c69a" name="a766b98e1a87f4035b6869c78f331c69a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a766b98e1a87f4035b6869c78f331c69a">&#9670;&nbsp;</a></span>Shared_name() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Input_it &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">ipc::util::Shared_name::Shared_name </td>
          <td>(</td>
          <td class="paramtype">Input_it&#160;</td>
          <td class="paramname"><em>begin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Input_it&#160;</td>
          <td class="paramname"><em>end</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">explicit</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Copy-constructs from a <code>char</code> range given as a pair of random-iterators; in particular <code>const char*</code>s work. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Input_it</td><td>An STL-compliant random iterator type. In particular <code>const char*</code> works. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">begin</td><td>Start of range to copy. </td></tr>
    <tr><td class="paramname">end</td><td>One past last element in range to copy (<code>begin</code> to copy nothing). </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="ab1934f80515fdbc3e2a59ccda32fff9a" name="ab1934f80515fdbc3e2a59ccda32fff9a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab1934f80515fdbc3e2a59ccda32fff9a">&#9670;&nbsp;</a></span>absolute()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool ipc::util::Shared_name::absolute </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns <code>true</code> if and only if the first character is <a class="el" href="classipc_1_1util_1_1Shared__name.html#a5c0910497c5ec484d3e42dfb0ccad48d" title="Character we use, by convention, to separate conceptual folders within str().">S_SEPARATOR</a>. </p>
<p >By Flow-IPC convention, any name actually passed to a sys call in order to name a shared resource has <code><a class="el" href="classipc_1_1util_1_1Shared__name.html#ab1934f80515fdbc3e2a59ccda32fff9a" title="Returns true if and only if the first character is S_SEPARATOR.">absolute()</a> == true</code>. Note, however, that <a class="el" href="classipc_1_1util_1_1Shared__name.html#ab1934f80515fdbc3e2a59ccda32fff9a" title="Returns true if and only if the first character is S_SEPARATOR.">absolute()</a> being <code>true</code> does not necessarily mean <a class="el" href="classipc_1_1util_1_1Shared__name.html#ae89e1e061f87ffe0288514e254837595" title="Returns (sans copying) ref to immutable entire wrapped name string, suitable to pass into sys calls w...">str()</a> is the full name of a resource: it may well still be a fragment (a prefix) of some eventual name passed to a sys call. To obtain the full name one would append more stuff.</p>
<dl class="section return"><dt>Returns</dt><dd>See above. </dd></dl>

</div>
</div>
<a id="a66f531c6fa407739fa81b12034351874" name="a66f531c6fa407739fa81b12034351874"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a66f531c6fa407739fa81b12034351874">&#9670;&nbsp;</a></span>ct() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classipc_1_1util_1_1Shared__name.html">Shared_name</a> ipc::util::Shared_name::ct </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>src</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Copy-constructs from a NUL-terminated <code>const char*</code> string. </p>
<h3>Rationale</h3>
<p >See class doc header for rationale as-to why this is a <code>static</code> ctor as opposed to a regular ctor.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Source</td><td>See above. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">src</td><td>String to copy. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The new object. </dd></dl>

</div>
</div>
<a id="a48f20b7b54490aa10dc64081d34c55b2" name="a48f20b7b54490aa10dc64081d34c55b2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a48f20b7b54490aa10dc64081d34c55b2">&#9670;&nbsp;</a></span>ct() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Source &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classipc_1_1util_1_1Shared__name.html">Shared_name</a> ipc::util::Shared_name::ct </td>
          <td>(</td>
          <td class="paramtype">const Source &amp;&#160;</td>
          <td class="paramname"><em>src</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Copy-constructs from a <code>char</code>-sequence container (including <code>string</code>, <a class="el" href="namespaceipc_1_1util.html#ae6ac47812a90d1287c61e0b7de7bc4f5" title="Short-hand for Flow&#39;s String_view.">util::String_view</a>, <code>vector&lt;char&gt;</code>). </p>
<p >This overload shall be used on a non-<code>&amp;&amp;</code> arg if <code><a class="el" href="classipc_1_1util_1_1Shared__name.html#a66f531c6fa407739fa81b12034351874" title="Copy-constructs from a NUL-terminated const char* string.">ct(const char*)</a></code> does not apply.</p>
<p >Specifically the returned object's internal <code>std::string</code> is constructed as: <code>std::string s(raw_name)</code>. As a result, whatever most-performant available single-arg ctor <code>basic_string</code> makes available is forwarded-to. (E.g., C++17 has a <code>String_view_like</code> ctor which is overload-resolved-to only when it most makes sense.)</p>
<h3>Rationale</h3>
<p >See class doc header for rationale as-to why this is a <code>static</code> ctor as opposed to a regular ctor.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Source</td><td>See above. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">src</td><td>String to copy. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The new object. </dd></dl>

</div>
</div>
<a id="a925d30aa9b3391651303de04f82d4949" name="a925d30aa9b3391651303de04f82d4949"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a925d30aa9b3391651303de04f82d4949">&#9670;&nbsp;</a></span>ct() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classipc_1_1util_1_1Shared__name.html">Shared_name</a> ipc::util::Shared_name::ct </td>
          <td>(</td>
          <td class="paramtype">std::string &amp;&amp;&#160;</td>
          <td class="paramname"><em>src_moved</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Destructively move-constructs from an <code>std::string</code>, emptying that source object. </p>
<h3>Rationale</h3>
<p >See class doc header for rationale as-to why this is a <code>static</code> ctor as opposed to a regular ctor.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">src_moved</td><td>String to move (make-<code>.<a class="el" href="classipc_1_1util_1_1Shared__name.html#a861ea6c9ad6672e83bab5c7747b66f7b" title="Returns true if and only if str().empty() == true.">empty()</a></code>). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The new object. </dd></dl>

</div>
</div>
<a id="a861ea6c9ad6672e83bab5c7747b66f7b" name="a861ea6c9ad6672e83bab5c7747b66f7b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a861ea6c9ad6672e83bab5c7747b66f7b">&#9670;&nbsp;</a></span>empty()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool ipc::util::Shared_name::empty </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns <code>true</code> if and only if <code><a class="el" href="classipc_1_1util_1_1Shared__name.html#ae89e1e061f87ffe0288514e254837595" title="Returns (sans copying) ref to immutable entire wrapped name string, suitable to pass into sys calls w...">str()</a>.<a class="el" href="classipc_1_1util_1_1Shared__name.html#a861ea6c9ad6672e83bab5c7747b66f7b" title="Returns true if and only if str().empty() == true.">empty()</a> == true</code>. </p>
<dl class="section return"><dt>Returns</dt><dd>See above. </dd></dl>

</div>
</div>
<a id="a774e872b51100b728e0780b39f563ed9" name="a774e872b51100b728e0780b39f563ed9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a774e872b51100b728e0780b39f563ed9">&#9670;&nbsp;</a></span>has_trailing_separator()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool ipc::util::Shared_name::has_trailing_separator </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns <code>true</code> if and only if <code>!this-&gt;<a class="el" href="classipc_1_1util_1_1Shared__name.html#a861ea6c9ad6672e83bab5c7747b66f7b" title="Returns true if and only if str().empty() == true.">empty()</a></code>, and <a class="el" href="classipc_1_1util_1_1Shared__name.html#ae89e1e061f87ffe0288514e254837595" title="Returns (sans copying) ref to immutable entire wrapped name string, suitable to pass into sys calls w...">str()</a> ends with the <a class="el" href="classipc_1_1util_1_1Shared__name.html#a5c0910497c5ec484d3e42dfb0ccad48d" title="Character we use, by convention, to separate conceptual folders within str().">S_SEPARATOR</a> character. </p>
<dl class="section return"><dt>Returns</dt><dd>See above. </dd></dl>

</div>
</div>
<a id="a0bccc73c9c5b4f3b784a1e57cdc5c910" name="a0bccc73c9c5b4f3b784a1e57cdc5c910"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0bccc73c9c5b4f3b784a1e57cdc5c910">&#9670;&nbsp;</a></span>native_str()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const char * ipc::util::Shared_name::native_str </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns (sans copying) pointer to NUL-terminated wrapped name string, suitable to pass into sys calls when naming supported shared resources assuming <code><a class="el" href="classipc_1_1util_1_1Shared__name.html#ab1934f80515fdbc3e2a59ccda32fff9a" title="Returns true if and only if the first character is S_SEPARATOR.">absolute()</a> == true</code>. </p>
<p >If you require an <code>std::string</code> (such as for some fancy boost.interprocess call) See also <a class="el" href="classipc_1_1util_1_1Shared__name.html#ae89e1e061f87ffe0288514e254837595" title="Returns (sans copying) ref to immutable entire wrapped name string, suitable to pass into sys calls w...">str()</a>.</p>
<h3>Why isn't it named <code>c_str()</code>?</h3>
<p >It was, but <code>capnp::StringPtr</code> (and similar/derived classes such as <code>capnp::Text::Reader</code>) has a "clever" <code>operator T()</code> conversion operator that is enabled for all <code>T</code> that have <code>.c_str()</code>; and its implementation relies on being able to symmetrically construct <code>T(const char*)</code> &ndash; like <code>std::string</code>. We intentionally lack that. Hence renamed this away from <code>.c_str()</code>. This may appear like kow-towing to capnp's quirks, but actually conceivably that's a pattern people use, so let's not break it.</p>
<dl class="section return"><dt>Returns</dt><dd>See above. </dd></dl>

</div>
</div>
<a id="a6f3d1055ef0e6d166a9f4532758d36de" name="a6f3d1055ef0e6d166a9f4532758d36de"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6f3d1055ef0e6d166a9f4532758d36de">&#9670;&nbsp;</a></span>operator+=() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classipc_1_1util_1_1Shared__name.html">Shared_name</a> &amp; ipc::util::Shared_name::operator+= </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>raw_name_to_append</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Similar to the overload that takes <code>const Source&amp;</code>, but takes NUL-terminated string instead. </p>
<p >See that doc header.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">raw_name_to_append</td><td>Thing to append. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>*this</code>. </dd></dl>

</div>
</div>
<a id="a1bcac1c10e01ba11dcc437b3c32bbe6c" name="a1bcac1c10e01ba11dcc437b3c32bbe6c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1bcac1c10e01ba11dcc437b3c32bbe6c">&#9670;&nbsp;</a></span>operator+=() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classipc_1_1util_1_1Shared__name.html">Shared_name</a> &amp; ipc::util::Shared_name::operator+= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classipc_1_1util_1_1Shared__name.html">Shared_name</a> &amp;&#160;</td>
          <td class="paramname"><em>src_to_append</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Appends the given other <a class="el" href="classipc_1_1util_1_1Shared__name.html" title="String-wrapping abstraction representing a name uniquely distinguishing a kernel-persistent entity fr...">Shared_name</a>. </p>
<p >Functionally equivalent to <code>return *this += src_to_append.str());</code>. If there's any reason to suspect the resulting name might be too long, execute <a class="el" href="classipc_1_1util_1_1Shared__name.html#add4ed045e03f786427a236a5dfa5a1b0" title="Best-effort attempt to turn sanitized() from false to true, unless it is already true; returns the fi...">sanitize()</a> afterwards and ensure that returns <code>true</code>.</p>
<p >It is stylistically (and possibly for performance) better to use <code>/=</code> rather than manually appending a separator and then <code>src_to_append</code> (with this <code>+=</code>).</p>
<p >See Rationale(s) for <a class="el" href="classipc_1_1util_1_1Shared__name.html#a956fdac1bb4cfab414b30091bec43f70" title="Appends a folder separator followed by the given other Shared_name.">operator/=()</a>, as they apply here.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">src_to_append</td><td>Thing to append. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>*this</code>. </dd></dl>

</div>
</div>
<a id="ae168cc42213bf7972d17bbbc1e16f2a2" name="ae168cc42213bf7972d17bbbc1e16f2a2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae168cc42213bf7972d17bbbc1e16f2a2">&#9670;&nbsp;</a></span>operator+=() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Source &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classipc_1_1util_1_1Shared__name.html">Shared_name</a> &amp; ipc::util::Shared_name::operator+= </td>
          <td>(</td>
          <td class="paramtype">const Source &amp;&#160;</td>
          <td class="paramname"><em>raw_name_to_append</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Simply appends <code>raw_name_to_append</code> to the current value of <a class="el" href="classipc_1_1util_1_1Shared__name.html#ae89e1e061f87ffe0288514e254837595" title="Returns (sans copying) ref to immutable entire wrapped name string, suitable to pass into sys calls w...">str()</a>. </p>
<p >Specifically the internal <code>std::string</code> is modified as: <code>s += raw_name_to_append</code>. As a result, whatever most-performant available (single-arg by definition) <code>operator+=</code> that <code>basic_string</code> makes available is forwarded-to. (E.g., C++17 has a <code>String_view_like</code> appender which is overload-resolved-to only when it most makes sense.)</p>
<p >If there's any reason to suspect the resulting name might be too long, execute <a class="el" href="classipc_1_1util_1_1Shared__name.html#add4ed045e03f786427a236a5dfa5a1b0" title="Best-effort attempt to turn sanitized() from false to true, unless it is already true; returns the fi...">sanitize()</a> afterwards and ensure that returns <code>true</code>.</p>
<p >It is stylistically (and possibly for performance) better to use <code>/=</code> rather than manually appending a separator and then <code>src_to_append</code> (with this <code>+=</code>).</p>
<p >See Rationale(s) for <a class="el" href="classipc_1_1util_1_1Shared__name.html#a956fdac1bb4cfab414b30091bec43f70" title="Appends a folder separator followed by the given other Shared_name.">operator/=()</a>, as they apply here.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Source</td><td>See above. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">raw_name_to_append</td><td>Thing to append. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>*this</code>. </dd></dl>

</div>
</div>
<a id="a99c77008fb2c507e32e05272812c4782" name="a99c77008fb2c507e32e05272812c4782"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a99c77008fb2c507e32e05272812c4782">&#9670;&nbsp;</a></span>operator/=() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classipc_1_1util_1_1Shared__name.html">Shared_name</a> &amp; ipc::util::Shared_name::operator/= </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>raw_name_to_append</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Similar to the overload that takes <code>const Source&amp;</code>, but takes NUL-terminated string instead. </p>
<p >See that doc header.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">raw_name_to_append</td><td>Thing to append after appending separator. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>*this</code>. </dd></dl>

</div>
</div>
<a id="a956fdac1bb4cfab414b30091bec43f70" name="a956fdac1bb4cfab414b30091bec43f70"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a956fdac1bb4cfab414b30091bec43f70">&#9670;&nbsp;</a></span>operator/=() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classipc_1_1util_1_1Shared__name.html">Shared_name</a> &amp; ipc::util::Shared_name::operator/= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classipc_1_1util_1_1Shared__name.html">Shared_name</a> &amp;&#160;</td>
          <td class="paramname"><em>src_to_append</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Appends a folder separator followed by the given other <a class="el" href="classipc_1_1util_1_1Shared__name.html" title="String-wrapping abstraction representing a name uniquely distinguishing a kernel-persistent entity fr...">Shared_name</a>. </p>
<p >Functionally equivalent to <code>return *this += (string(1, S_SEPARATOR) + src_to_append.str());</code>. If there's any reason to suspect <code>this-&gt;<a class="el" href="classipc_1_1util_1_1Shared__name.html#ae89e1e061f87ffe0288514e254837595" title="Returns (sans copying) ref to immutable entire wrapped name string, suitable to pass into sys calls w...">str()</a></code> already ends in <a class="el" href="classipc_1_1util_1_1Shared__name.html#a5c0910497c5ec484d3e42dfb0ccad48d" title="Character we use, by convention, to separate conceptual folders within str().">S_SEPARATOR</a>, and/or that the resulting name might be too long, execute <a class="el" href="classipc_1_1util_1_1Shared__name.html#add4ed045e03f786427a236a5dfa5a1b0" title="Best-effort attempt to turn sanitized() from false to true, unless it is already true; returns the fi...">sanitize()</a> afterwards and ensure that returns <code>true</code>.</p>
<p >It is stylistically (and possibly for performance) better to use this rather than manually appending a separator and then <code>src_to_append</code> (with <code>+=</code>).</p>
<h3>Rationale for not doing something smarter like avoiding a double-separator due to concatenation</h3>
<p >Basically we want things to be as fast as possible by default; and that is to make it as close to trivial string concatenation as possible. If more paranoia is required, we want the user to intentionally use <a class="el" href="classipc_1_1util_1_1Shared__name.html#add4ed045e03f786427a236a5dfa5a1b0" title="Best-effort attempt to turn sanitized() from false to true, unless it is already true; returns the fi...">sanitize()</a> or <a class="el" href="classipc_1_1util_1_1Shared__name.html#a03d90faae35392c8bbdd22f056755ba9" title="Returns true if and only if the contained name/fragment is sanitized according to length,...">sanitized()</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">src_to_append</td><td>Thing to append after appending separator. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>*this</code>. </dd></dl>

</div>
</div>
<a id="a762bda2d73b31c9427c05c7c1a7abbcb" name="a762bda2d73b31c9427c05c7c1a7abbcb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a762bda2d73b31c9427c05c7c1a7abbcb">&#9670;&nbsp;</a></span>operator/=() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Source &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classipc_1_1util_1_1Shared__name.html">Shared_name</a> &amp; ipc::util::Shared_name::operator/= </td>
          <td>(</td>
          <td class="paramtype">const Source &amp;&#160;</td>
          <td class="paramname"><em>raw_name_to_append</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Simply appends a folder separator followed by <code>raw_name_to_append</code> to the current value of <a class="el" href="classipc_1_1util_1_1Shared__name.html#ae89e1e061f87ffe0288514e254837595" title="Returns (sans copying) ref to immutable entire wrapped name string, suitable to pass into sys calls w...">str()</a>. </p>
<p >Specifically the internal <code>std::string</code> is modified as: <code>s += S_SEPARATOR; s += raw_name_to_append</code>. As a result, whatever most-performant available (single-arg by definition) <code>operator+=</code> that <code>basic_string</code> makes available is forwarded-to for the 2nd <code>+=</code>. (E.g., C++17 has a <code>String_view_like</code> appender which is overload-resolved-to only when it most makes sense.)</p>
<p >If there's any reason to suspect <code>this-&gt;<a class="el" href="classipc_1_1util_1_1Shared__name.html#ae89e1e061f87ffe0288514e254837595" title="Returns (sans copying) ref to immutable entire wrapped name string, suitable to pass into sys calls w...">str()</a></code> already ends in <a class="el" href="classipc_1_1util_1_1Shared__name.html#a5c0910497c5ec484d3e42dfb0ccad48d" title="Character we use, by convention, to separate conceptual folders within str().">S_SEPARATOR</a>, and/or that the resulting name might be too long, execute <a class="el" href="classipc_1_1util_1_1Shared__name.html#add4ed045e03f786427a236a5dfa5a1b0" title="Best-effort attempt to turn sanitized() from false to true, unless it is already true; returns the fi...">sanitize()</a> afterwards and ensure that returns <code>true</code>.</p>
<p >It is stylistically (and possibly for performance) better to use this rather than manually appending a separator and then <code>src_to_append</code> (with <code>+=</code>).</p>
<p >See Rationale(s) for the other <a class="el" href="classipc_1_1util_1_1Shared__name.html#a956fdac1bb4cfab414b30091bec43f70" title="Appends a folder separator followed by the given other Shared_name.">operator/=()</a>, as they apply here.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Source</td><td>See above. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">raw_name_to_append</td><td>Thing to append after appending separator. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>*this</code>. </dd></dl>

</div>
</div>
<a id="abd312f9eaf6f07adaba115aaab05b539" name="abd312f9eaf6f07adaba115aaab05b539"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abd312f9eaf6f07adaba115aaab05b539">&#9670;&nbsp;</a></span>operator=() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classipc_1_1util_1_1Shared__name.html">Shared_name</a> &amp; ipc::util::Shared_name::operator= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classipc_1_1util_1_1Shared__name.html">Shared_name</a> &amp;&#160;</td>
          <td class="paramname"><em>src</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">default</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Copy-assigns from an existing <a class="el" href="classipc_1_1util_1_1Shared__name.html" title="String-wrapping abstraction representing a name uniquely distinguishing a kernel-persistent entity fr...">Shared_name</a>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">src</td><td>Source object. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>*this</code>. </dd></dl>

</div>
</div>
<a id="a1511bd84d701dd866029d0f4c8869516" name="a1511bd84d701dd866029d0f4c8869516"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1511bd84d701dd866029d0f4c8869516">&#9670;&nbsp;</a></span>operator=() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classipc_1_1util_1_1Shared__name.html">Shared_name</a> &amp; ipc::util::Shared_name::operator= </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classipc_1_1util_1_1Shared__name.html">Shared_name</a> &amp;&amp;&#160;</td>
          <td class="paramname"><em>src_moved</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">default</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Move-assigns from an existing <a class="el" href="classipc_1_1util_1_1Shared__name.html" title="String-wrapping abstraction representing a name uniquely distinguishing a kernel-persistent entity fr...">Shared_name</a>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">src_moved</td><td>Source object, which is potentially modified. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>*this</code>. </dd></dl>

</div>
</div>
<a id="add4ed045e03f786427a236a5dfa5a1b0" name="add4ed045e03f786427a236a5dfa5a1b0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#add4ed045e03f786427a236a5dfa5a1b0">&#9670;&nbsp;</a></span>sanitize()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool ipc::util::Shared_name::sanitize </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Best-effort attempt to turn <a class="el" href="classipc_1_1util_1_1Shared__name.html#a03d90faae35392c8bbdd22f056755ba9" title="Returns true if and only if the contained name/fragment is sanitized according to length,...">sanitized()</a> from <code>false</code> to <code>true</code>, unless it is already <code>true</code>; returns the final value of <a class="el" href="classipc_1_1util_1_1Shared__name.html#a03d90faae35392c8bbdd22f056755ba9" title="Returns true if and only if the contained name/fragment is sanitized according to length,...">sanitized()</a> indicating whether it was successful. </p>
<p >If <code>false</code> returned, then the final value of <a class="el" href="classipc_1_1util_1_1Shared__name.html#ae89e1e061f87ffe0288514e254837595" title="Returns (sans copying) ref to immutable entire wrapped name string, suitable to pass into sys calls w...">str()</a> will equal the initial value.</p>
<p >This utility should be used very judiciously and with full knowledge of what it actually does. It should <em>not</em> be used "just in case" or "prophylactically" but only with full knowledge of where the current value of <a class="el" href="classipc_1_1util_1_1Shared__name.html#ae89e1e061f87ffe0288514e254837595" title="Returns (sans copying) ref to immutable entire wrapped name string, suitable to pass into sys calls w...">str()</a> might originate. For example, it might come from some user input. Another example involves, perhaps, concatenating two path fragments in such a way as to potentially yield a double-<a class="el" href="classipc_1_1util_1_1Shared__name.html#a5c0910497c5ec484d3e42dfb0ccad48d" title="Character we use, by convention, to separate conceptual folders within str().">S_SEPARATOR</a> situation: <a class="el" href="classipc_1_1util_1_1Shared__name.html#add4ed045e03f786427a236a5dfa5a1b0" title="Best-effort attempt to turn sanitized() from false to true, unless it is already true; returns the fi...">sanitize()</a> after this would get collapse the separators into just 1 separator. Yet another example is simply that if one combines two paths which don't exceed <a class="el" href="classipc_1_1util_1_1Shared__name.html#afc9b87fc69d42df3107bf4a27ea66c7c" title="Max value of size() such that, if str() used to name a supported shared resource, sys call safely won...">S_MAX_LENGTH</a>, but the result might exceed it: running <a class="el" href="classipc_1_1util_1_1Shared__name.html#add4ed045e03f786427a236a5dfa5a1b0" title="Best-effort attempt to turn sanitized() from false to true, unless it is already true; returns the fi...">sanitize()</a> and ensuring it returns <code>true</code> guaranteed one didn't accidentally exceed <a class="el" href="classipc_1_1util_1_1Shared__name.html#afc9b87fc69d42df3107bf4a27ea66c7c" title="Max value of size() such that, if str() used to name a supported shared resource, sys call safely won...">S_MAX_LENGTH</a>.</p>
<p >In other words, use it when you want it to do what it, in fact, does. And that is:</p><ul>
<li>Any '/' (forward-slash) character, as a special case, is transformed into <a class="el" href="classipc_1_1util_1_1Shared__name.html#a5c0910497c5ec484d3e42dfb0ccad48d" title="Character we use, by convention, to separate conceptual folders within str().">S_SEPARATOR</a>.</li>
<li>After any character replacements above: Any sequence of 2 or more <a class="el" href="classipc_1_1util_1_1Shared__name.html#a5c0910497c5ec484d3e42dfb0ccad48d" title="Character we use, by convention, to separate conceptual folders within str().">S_SEPARATOR</a> characters is collapsed into one <a class="el" href="classipc_1_1util_1_1Shared__name.html#a5c0910497c5ec484d3e42dfb0ccad48d" title="Character we use, by convention, to separate conceptual folders within str().">S_SEPARATOR</a>.</li>
</ul>
<p >Things it does <em>not</em> do, except the above:</p><ul>
<li>No legal or illegal character is changed (except '/' and separator collapsing).</li>
<li>It doesn't truncate to try to bring length to <a class="el" href="classipc_1_1util_1_1Shared__name.html#afc9b87fc69d42df3107bf4a27ea66c7c" title="Max value of size() such that, if str() used to name a supported shared resource, sys call safely won...">S_MAX_LENGTH</a> or less.</li>
</ul>
<p >However, the method's return value is still significant, in that if it is "still" <code>false</code>, then you know you have a real problem &ndash; yet if it's <code>true</code>, then it didn't do anything destructive to make it so.</p>
<p >Note, again, that the above replacements are "undone" if <code>false</code> is returned. In other words, the function won't sanitize "halfway."</p>
<h3>Performance</h3>
<p >There is at most one linear scan through <a class="el" href="classipc_1_1util_1_1Shared__name.html#ae89e1e061f87ffe0288514e254837595" title="Returns (sans copying) ref to immutable entire wrapped name string, suitable to pass into sys calls w...">str()</a>. In addition, though only if actual sanitizing (by changing <a class="el" href="classipc_1_1util_1_1Shared__name.html#ae89e1e061f87ffe0288514e254837595" title="Returns (sans copying) ref to immutable entire wrapped name string, suitable to pass into sys calls w...">str()</a>) might be necessary: an allocation, copy of <a class="el" href="classipc_1_1util_1_1Shared__name.html#ae89e1e061f87ffe0288514e254837595" title="Returns (sans copying) ref to immutable entire wrapped name string, suitable to pass into sys calls w...">str()</a>, and deallocation may be performed. Overall, it is linear-time regardless, plus those potential alloc/dealloc ops.</p>
<dl class="section return"><dt>Returns</dt><dd>What <a class="el" href="classipc_1_1util_1_1Shared__name.html#a03d90faae35392c8bbdd22f056755ba9" title="Returns true if and only if the contained name/fragment is sanitized according to length,...">sanitized()</a> would return just before returning from the present function. </dd></dl>

</div>
</div>
<a id="a03d90faae35392c8bbdd22f056755ba9" name="a03d90faae35392c8bbdd22f056755ba9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a03d90faae35392c8bbdd22f056755ba9">&#9670;&nbsp;</a></span>sanitized()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool ipc::util::Shared_name::sanitized </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns <code>true</code> if and only if the contained name/fragment is <em>sanitized</em> according to length, legal characters, and similar. </p>
<p >More precisely, a sanitized <code>*this</code> satisfies all of the following:</p><ul>
<li>There are no illegal characters. (E.g., in particular, some characters would not be accepted when naming a SHM object in Linux.)<ul>
<li>In particular, only <a class="el" href="classipc_1_1util_1_1Shared__name.html#a5c0910497c5ec484d3e42dfb0ccad48d" title="Character we use, by convention, to separate conceptual folders within str().">S_SEPARATOR</a> is used as a folder separator.</li>
</ul>
</li>
<li>There is no more than 1 instance of <a class="el" href="classipc_1_1util_1_1Shared__name.html#a5c0910497c5ec484d3e42dfb0ccad48d" title="Character we use, by convention, to separate conceptual folders within str().">S_SEPARATOR</a> character in a row.</li>
<li><a class="el" href="classipc_1_1util_1_1Shared__name.html#af34db2934e116f8a4fdd403fd04695af" title="Returns str().size().">size()</a> does not exceed <a class="el" href="classipc_1_1util_1_1Shared__name.html#afc9b87fc69d42df3107bf4a27ea66c7c" title="Max value of size() such that, if str() used to name a supported shared resource, sys call safely won...">S_MAX_LENGTH</a>.</li>
</ul>
<h3>Performance</h3>
<p >It is linear-time, with at most one scan through <a class="el" href="classipc_1_1util_1_1Shared__name.html#ae89e1e061f87ffe0288514e254837595" title="Returns (sans copying) ref to immutable entire wrapped name string, suitable to pass into sys calls w...">str()</a>.</p>
<dl class="section return"><dt>Returns</dt><dd>See above. </dd></dl>

</div>
</div>
<a id="af34db2934e116f8a4fdd403fd04695af" name="af34db2934e116f8a4fdd403fd04695af"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af34db2934e116f8a4fdd403fd04695af">&#9670;&nbsp;</a></span>size()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t ipc::util::Shared_name::size </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns <code><a class="el" href="classipc_1_1util_1_1Shared__name.html#ae89e1e061f87ffe0288514e254837595" title="Returns (sans copying) ref to immutable entire wrapped name string, suitable to pass into sys calls w...">str()</a>.<a class="el" href="classipc_1_1util_1_1Shared__name.html#af34db2934e116f8a4fdd403fd04695af" title="Returns str().size().">size()</a></code>. </p>
<dl class="section return"><dt>Returns</dt><dd>See above. </dd></dl>

</div>
</div>
<a id="ae89e1e061f87ffe0288514e254837595" name="ae89e1e061f87ffe0288514e254837595"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae89e1e061f87ffe0288514e254837595">&#9670;&nbsp;</a></span>str()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const std::string &amp; ipc::util::Shared_name::str </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns (sans copying) ref to immutable entire wrapped name string, suitable to pass into sys calls when naming supported shared resources assuming <code><a class="el" href="classipc_1_1util_1_1Shared__name.html#ab1934f80515fdbc3e2a59ccda32fff9a" title="Returns true if and only if the first character is S_SEPARATOR.">absolute()</a> == true</code>. </p>
<p >If you require a NUL-terminated string (such as for a native call), use <a class="el" href="classipc_1_1util_1_1Shared__name.html#a0bccc73c9c5b4f3b784a1e57cdc5c910" title="Returns (sans copying) pointer to NUL-terminated wrapped name string, suitable to pass into sys calls...">native_str()</a>.</p>
<dl class="section note"><dt>Note</dt><dd>Returning a <a class="el" href="namespaceipc_1_1util.html#ae6ac47812a90d1287c61e0b7de7bc4f5" title="Short-hand for Flow&#39;s String_view.">util::String_view</a> seemed pointless, as one can always be constructed easily by the caller, and in any case &ndash; for the time being at least &ndash; some/many APIs that take non-C-strings will take <code>std::string</code> as opposed to a <a class="el" href="namespaceipc_1_1util.html#ae6ac47812a90d1287c61e0b7de7bc4f5" title="Short-hand for Flow&#39;s String_view.">util::String_view</a>.</dd></dl>
<dl class="section return"><dt>Returns</dt><dd>See above. </dd></dl>

</div>
</div>
<h2 class="groupheader">Friends And Related Function Documentation</h2>
<a id="aba4ae811264cbb7e664ce126b591cbc7" name="aba4ae811264cbb7e664ce126b591cbc7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aba4ae811264cbb7e664ce126b591cbc7">&#9670;&nbsp;</a></span>hash_value()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_t hash_value </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classipc_1_1util_1_1Shared__name.html">Shared_name</a> &amp;&#160;</td>
          <td class="paramname"><em>val</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Hasher of <a class="el" href="classipc_1_1util_1_1Shared__name.html" title="String-wrapping abstraction representing a name uniquely distinguishing a kernel-persistent entity fr...">Shared_name</a> for boost.unordered et al. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">val</td><td>Object to hash. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>See above. </dd></dl>

</div>
</div>
<a id="a096c71dede7bd5528215ac01a380a189" name="a096c71dede7bd5528215ac01a380a189"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a096c71dede7bd5528215ac01a380a189">&#9670;&nbsp;</a></span>operator+() <span class="overload">[1/5]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classipc_1_1util_1_1Shared__name.html">Shared_name</a> operator+ </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>raw_src1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classipc_1_1util_1_1Shared__name.html">Shared_name</a> &amp;&#160;</td>
          <td class="paramname"><em>src2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns new object equal to <code>Shared_name(src2)</code> with <code>raw_src1</code> pre-pended to it. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">raw_src1</td><td>String to precede the appended <code>src2</code>. </td></tr>
    <tr><td class="paramname">src2</td><td>Object to append. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>See above. </dd></dl>

</div>
</div>
<a id="af61b02fd66b67aeed5a803ca47e52973" name="af61b02fd66b67aeed5a803ca47e52973"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af61b02fd66b67aeed5a803ca47e52973">&#9670;&nbsp;</a></span>operator+() <span class="overload">[2/5]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classipc_1_1util_1_1Shared__name.html">Shared_name</a> operator+ </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classipc_1_1util_1_1Shared__name.html">Shared_name</a> &amp;&#160;</td>
          <td class="paramname"><em>src1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>raw_src2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns new object equal to <code>Shared_name(src1) += raw_src2</code>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">src1</td><td>Object to precede the appended <code>raw_src2</code>. </td></tr>
    <tr><td class="paramname">raw_src2</td><td>String to append. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>See above. </dd></dl>

</div>
</div>
<a id="a54dc5077333284fda9e8d2df8b0e9b91" name="a54dc5077333284fda9e8d2df8b0e9b91"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a54dc5077333284fda9e8d2df8b0e9b91">&#9670;&nbsp;</a></span>operator+() <span class="overload">[3/5]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classipc_1_1util_1_1Shared__name.html">Shared_name</a> operator+ </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classipc_1_1util_1_1Shared__name.html">Shared_name</a> &amp;&#160;</td>
          <td class="paramname"><em>src1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classipc_1_1util_1_1Shared__name.html">Shared_name</a> &amp;&#160;</td>
          <td class="paramname"><em>src2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns new object equal to <code>Shared_name(src1) += src2</code>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">src1</td><td>Object to precede the appended <code>src2</code>. </td></tr>
    <tr><td class="paramname">src2</td><td>Object to append. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>See above. </dd></dl>

</div>
</div>
<a id="a52b2ba03d5ace7389991bb5d31b9fa59" name="a52b2ba03d5ace7389991bb5d31b9fa59"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a52b2ba03d5ace7389991bb5d31b9fa59">&#9670;&nbsp;</a></span>operator+() <span class="overload">[4/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Source &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classipc_1_1util_1_1Shared__name.html">Shared_name</a> operator+ </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classipc_1_1util_1_1Shared__name.html">Shared_name</a> &amp;&#160;</td>
          <td class="paramname"><em>src1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Source &amp;&#160;</td>
          <td class="paramname"><em>raw_src2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns new object equal to <code>Shared_name(src1) += raw_src2</code>. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Source</td><td>See <a class="el" href="classipc_1_1util_1_1Shared__name.html#a1bcac1c10e01ba11dcc437b3c32bbe6c" title="Appends the given other Shared_name.">Shared_name::operator+=()</a> similar overload. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">src1</td><td>Object to precede the appended <code>raw_src2</code>. </td></tr>
    <tr><td class="paramname">raw_src2</td><td>String to append. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>See above. </dd></dl>

</div>
</div>
<a id="a1f1a40877cc08b287f8f3c7e7f663782" name="a1f1a40877cc08b287f8f3c7e7f663782"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1f1a40877cc08b287f8f3c7e7f663782">&#9670;&nbsp;</a></span>operator+() <span class="overload">[5/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Source &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classipc_1_1util_1_1Shared__name.html">Shared_name</a> operator+ </td>
          <td>(</td>
          <td class="paramtype">const Source &amp;&#160;</td>
          <td class="paramname"><em>raw_src1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classipc_1_1util_1_1Shared__name.html">Shared_name</a> &amp;&#160;</td>
          <td class="paramname"><em>src2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns new object equal to <code>Shared_name(src2)</code> with <code>raw_src1</code> pre-pended to it. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Source</td><td>See <a class="el" href="classipc_1_1util_1_1Shared__name.html#a1bcac1c10e01ba11dcc437b3c32bbe6c" title="Appends the given other Shared_name.">Shared_name::operator+=()</a> similar overload. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">raw_src1</td><td>String to precede the appended <code>src2</code>. </td></tr>
    <tr><td class="paramname">src2</td><td>Object to append. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>See above. </dd></dl>

</div>
</div>
<a id="a7f2bead5935309c2f760645fe46ddd71" name="a7f2bead5935309c2f760645fe46ddd71"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7f2bead5935309c2f760645fe46ddd71">&#9670;&nbsp;</a></span>operator/() <span class="overload">[1/5]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classipc_1_1util_1_1Shared__name.html">Shared_name</a> operator/ </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>raw_src1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classipc_1_1util_1_1Shared__name.html">Shared_name</a> &amp;&#160;</td>
          <td class="paramname"><em>src2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns new object equal to <code>Shared_name(raw_src1) /= src2</code>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">raw_src1</td><td>String to precede the appended separator and <code>src2</code>. </td></tr>
    <tr><td class="paramname">src2</td><td>Object to append after separator. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>See above. </dd></dl>

</div>
</div>
<a id="aa61c6b31c5c4e241c97f06a4d38c76c4" name="aa61c6b31c5c4e241c97f06a4d38c76c4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa61c6b31c5c4e241c97f06a4d38c76c4">&#9670;&nbsp;</a></span>operator/() <span class="overload">[2/5]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classipc_1_1util_1_1Shared__name.html">Shared_name</a> operator/ </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classipc_1_1util_1_1Shared__name.html">Shared_name</a> &amp;&#160;</td>
          <td class="paramname"><em>src1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>raw_src2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns new object equal to <code>Shared_name(src1) /= raw_src2</code>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">src1</td><td>Object to precede the appended separator and <code>raw_src2</code>. </td></tr>
    <tr><td class="paramname">raw_src2</td><td>String to append after separator. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>See above. </dd></dl>

</div>
</div>
<a id="a15ea67c1855a678f7e948b24ccf2c1cd" name="a15ea67c1855a678f7e948b24ccf2c1cd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a15ea67c1855a678f7e948b24ccf2c1cd">&#9670;&nbsp;</a></span>operator/() <span class="overload">[3/5]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classipc_1_1util_1_1Shared__name.html">Shared_name</a> operator/ </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classipc_1_1util_1_1Shared__name.html">Shared_name</a> &amp;&#160;</td>
          <td class="paramname"><em>src1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classipc_1_1util_1_1Shared__name.html">Shared_name</a> &amp;&#160;</td>
          <td class="paramname"><em>src2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns new object equal to <code>Shared_name(src1) /= src2</code>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">src1</td><td>Object to precede the appended separator and <code>src2</code>. </td></tr>
    <tr><td class="paramname">src2</td><td>Object to append after separator. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>See above. </dd></dl>

</div>
</div>
<a id="a910207a2da57b61cee4a22899e239dc2" name="a910207a2da57b61cee4a22899e239dc2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a910207a2da57b61cee4a22899e239dc2">&#9670;&nbsp;</a></span>operator/() <span class="overload">[4/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Source &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classipc_1_1util_1_1Shared__name.html">Shared_name</a> operator/ </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classipc_1_1util_1_1Shared__name.html">Shared_name</a> &amp;&#160;</td>
          <td class="paramname"><em>src1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Source &amp;&#160;</td>
          <td class="paramname"><em>raw_src2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns new object equal to <code>Shared_name(src1) /= raw_src2</code>. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Source</td><td>See <a class="el" href="classipc_1_1util_1_1Shared__name.html#a956fdac1bb4cfab414b30091bec43f70" title="Appends a folder separator followed by the given other Shared_name.">Shared_name::operator/=()</a> similar overload. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">src1</td><td>Object to precede the appended separator and <code>raw_src2</code>. </td></tr>
    <tr><td class="paramname">raw_src2</td><td>String to append after separator. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>See above. </dd></dl>

</div>
</div>
<a id="a462b81d34ba23c968f63d9805fa74538" name="a462b81d34ba23c968f63d9805fa74538"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a462b81d34ba23c968f63d9805fa74538">&#9670;&nbsp;</a></span>operator/() <span class="overload">[5/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Source &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classipc_1_1util_1_1Shared__name.html">Shared_name</a> operator/ </td>
          <td>(</td>
          <td class="paramtype">const Source &amp;&#160;</td>
          <td class="paramname"><em>raw_src1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classipc_1_1util_1_1Shared__name.html">Shared_name</a> &amp;&#160;</td>
          <td class="paramname"><em>src2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns new object equal to <code>Shared_name(raw_src1) /= src2</code>. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Source</td><td>See <a class="el" href="classipc_1_1util_1_1Shared__name.html#a956fdac1bb4cfab414b30091bec43f70" title="Appends a folder separator followed by the given other Shared_name.">Shared_name::operator/=()</a> similar overload. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">raw_src1</td><td>String to precede the appended separator and <code>src2</code>. </td></tr>
    <tr><td class="paramname">src2</td><td>Object to append after separator. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>See above. </dd></dl>

</div>
</div>
<a id="af7728c93fdf29479bbb2482e02f05cbf" name="af7728c93fdf29479bbb2482e02f05cbf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af7728c93fdf29479bbb2482e02f05cbf">&#9670;&nbsp;</a></span>operator&lt;&lt;()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::ostream &amp; operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>os</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classipc_1_1util_1_1Shared__name.html">Shared_name</a> &amp;&#160;</td>
          <td class="paramname"><em>val</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Prints embellished string representation of the given <a class="el" href="classipc_1_1util_1_1Shared__name.html" title="String-wrapping abstraction representing a name uniquely distinguishing a kernel-persistent entity fr...">Shared_name</a> to the given <code>ostream</code>. </p>
<dl class="section warning"><dt>Warning</dt><dd>This is <em>not</em> equivalent to writing <a class="el" href="classipc_1_1util_1_1Shared__name.html#ae89e1e061f87ffe0288514e254837595" title="Returns (sans copying) ref to immutable entire wrapped name string, suitable to pass into sys calls w...">Shared_name::str()</a>; as of this writing it includes not just <code><a class="el" href="classipc_1_1util_1_1Shared__name.html#ae89e1e061f87ffe0288514e254837595" title="Returns (sans copying) ref to immutable entire wrapped name string, suitable to pass into sys calls w...">str()</a></code> but also the number of characters in it as a decimal and a separator, for convenience in test/debug, to visually detect names approaching certain length limits. If you wish to output <code>val.str()</code>, then output... well... <code>val.str()</code>.</dd></dl>
<dl class="todo"><dt><b><a class="el" href="todo.html#_todo000014">Todo:</a></b></dt><dd>Does <a class="el" href="classipc_1_1util_1_1Shared__name.html" title="String-wrapping abstraction representing a name uniquely distinguishing a kernel-persistent entity fr...">Shared_name</a> <code>operator&gt;&gt;</code> and <code>operator&lt;&lt;</code> being asymmetrical get one into trouble when using <a class="el" href="classipc_1_1util_1_1Shared__name.html" title="String-wrapping abstraction representing a name uniquely distinguishing a kernel-persistent entity fr...">Shared_name</a> with boost.program_options (or <code>flow::cfg</code> which is built on top of it)? Look into it. It may be necessary to make <code>operator&lt;&lt;</code> equal to that of <code>ostream &lt;&lt; string</code> after all; though the added niceties of the current <code>&lt;&lt;</code> semantics may still at least be available via some explicit accessor.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">os</td><td>Stream to which to write. </td></tr>
    <tr><td class="paramname">val</td><td>Object to serialize. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>os</code>. </dd></dl>

</div>
</div>
<a id="adfd8805e0d37556102cad7b191fee9a3" name="adfd8805e0d37556102cad7b191fee9a3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adfd8805e0d37556102cad7b191fee9a3">&#9670;&nbsp;</a></span>operator&gt;&gt;()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::istream &amp; operator&gt;&gt; </td>
          <td>(</td>
          <td class="paramtype">std::istream &amp;&#160;</td>
          <td class="paramname"><em>is</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classipc_1_1util_1_1Shared__name.html">Shared_name</a> &amp;&#160;</td>
          <td class="paramname"><em>val</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Reads <a class="el" href="classipc_1_1util_1_1Shared__name.html" title="String-wrapping abstraction representing a name uniquely distinguishing a kernel-persistent entity fr...">Shared_name</a> from the given <code>istream</code>; equivalent to reading <code>string</code> into <a class="el" href="classipc_1_1util_1_1Shared__name.html#ae89e1e061f87ffe0288514e254837595" title="Returns (sans copying) ref to immutable entire wrapped name string, suitable to pass into sys calls w...">Shared_name::str()</a>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">is</td><td>Stream to read. </td></tr>
    <tr><td class="paramname">val</td><td>Object to which to deserialize. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>is</code>. </dd></dl>

</div>
</div>
<a id="a9ea22a64cfbc6de66181c278ff5f6975" name="a9ea22a64cfbc6de66181c278ff5f6975"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9ea22a64cfbc6de66181c278ff5f6975">&#9670;&nbsp;</a></span>swap()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void swap </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classipc_1_1util_1_1Shared__name.html">Shared_name</a> &amp;&#160;</td>
          <td class="paramname"><em>val1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classipc_1_1util_1_1Shared__name.html">Shared_name</a> &amp;&#160;</td>
          <td class="paramname"><em>val2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Swaps two objects. </p>
<p >Constant-time. Suitable for standard ADL-swap pattern <code>using std::swap; swap(val1, val2);</code>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">val1</td><td>Object. </td></tr>
    <tr><td class="paramname">val2</td><td>Object. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<h2 class="groupheader">Member Data Documentation</h2>
<a id="aaa78ddb3efa5abe4fa80058dedbef68c" name="aaa78ddb3efa5abe4fa80058dedbef68c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaa78ddb3efa5abe4fa80058dedbef68c">&#9670;&nbsp;</a></span>S_1ST_OR_ONLY</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classipc_1_1util_1_1Shared__name.html">Shared_name</a> ipc::util::Shared_name::S_1ST_OR_ONLY = <a class="el" href="classipc_1_1util_1_1Shared__name.html#a48f20b7b54490aa10dc64081d34c55b2">Shared_name::ct</a>(&quot;1&quot;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>A <a class="el" href="classipc_1_1util_1_1Shared__name.html" title="String-wrapping abstraction representing a name uniquely distinguishing a kernel-persistent entity fr...">Shared_name</a> fragment, with no <a class="el" href="classipc_1_1util_1_1Shared__name.html#a5c0910497c5ec484d3e42dfb0ccad48d" title="Character we use, by convention, to separate conceptual folders within str().">S_SEPARATOR</a> characters inside, that represents a path component that (1) is not <a class="el" href="classipc_1_1util_1_1Shared__name.html#a43205a00865429c1bef6c7896816bf5c" title="A Shared_name fragment, with no S_SEPARATOR characters inside, that represents a path component that ...">S_SENTINEL</a> and (2) is suggested as the <em>first</em> or <em>only</em> unique ID of items at the same depth in the same context. </p>
<p >In actual fact it equals <code>1</code>; and typically (though not necessarily &ndash; other conventions may exist) generated strings shall be <code>1</code>, <code>2</code>, ..., of which the former is <a class="el" href="classipc_1_1util_1_1Shared__name.html#aaa78ddb3efa5abe4fa80058dedbef68c" title="A Shared_name fragment, with no S_SEPARATOR characters inside, that represents a path component that ...">S_1ST_OR_ONLY</a>.</p>
<p >So if <a class="el" href="classipc_1_1util_1_1Shared__name.html#a43205a00865429c1bef6c7896816bf5c" title="A Shared_name fragment, with no S_SEPARATOR characters inside, that represents a path component that ...">S_SENTINEL</a> means "not a thing" or "special thing to be treated not like a normal thing", then <a class="el" href="classipc_1_1util_1_1Shared__name.html#aaa78ddb3efa5abe4fa80058dedbef68c" title="A Shared_name fragment, with no S_SEPARATOR characters inside, that represents a path component that ...">S_1ST_OR_ONLY</a> means "a normal thing, of which there may be only one, and this is the first one
so created."</p>
<h3>Suggested use pattern</h3>
<p >This is most useful when, at this path level, you currently only have reason to have one object. Then you can name it <a class="el" href="classipc_1_1util_1_1Shared__name.html#aaa78ddb3efa5abe4fa80058dedbef68c" title="A Shared_name fragment, with no S_SEPARATOR characters inside, that represents a path component that ...">S_1ST_OR_ONLY</a> without relying on a magic string <code>1</code>. However, if in the future there is reason to add more objects at the same level, then remove the use of <code>S_1ST_OR_ONLY</code> and instead use a <code>uint</code> or <code>atomic&lt;uint&gt;</code> data member that starts at simply the numeric <code>1</code>, <code>++</code>ing it each time a new object is added (and converting it via <code>Shared_name::ct(std::to_string(x))</code> to string). The first object will have the same name as before, compatibly, while subsequent ones will be efficiently named uniquely.</p>
<p >Is this cheesy and reliant on the fact that this constant is, in fact, a string conversion of the number one? Yes, but the above pattern works and is reasonably efficient. I (ygoldfel) considered making this a super-general API that keeps generating unique IDs, but it just seemed like overkill given the simplicity of the task. Converting back from <a class="el" href="classipc_1_1util_1_1Shared__name.html" title="String-wrapping abstraction representing a name uniquely distinguishing a kernel-persistent entity fr...">Shared_name</a>, generating a new <code>++</code>ed one, then converting back &ndash; while providing a simple-enough API to ensure atomicity &ndash; seemed inferior to just letting people maintain a compatible <code>atomic&lt;uint&gt;</code>, when and if desired, and using <a class="el" href="classipc_1_1util_1_1Shared__name.html#aaa78ddb3efa5abe4fa80058dedbef68c" title="A Shared_name fragment, with no S_SEPARATOR characters inside, that represents a path component that ...">S_1ST_OR_ONLY</a> until then. </p>

</div>
</div>
<a id="afc9b87fc69d42df3107bf4a27ea66c7c" name="afc9b87fc69d42df3107bf4a27ea66c7c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afc9b87fc69d42df3107bf4a27ea66c7c">&#9670;&nbsp;</a></span>S_MAX_LENGTH</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const size_t ipc::util::Shared_name::S_MAX_LENGTH = 75</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Max value of <a class="el" href="classipc_1_1util_1_1Shared__name.html#af34db2934e116f8a4fdd403fd04695af" title="Returns str().size().">size()</a> such that, if <a class="el" href="classipc_1_1util_1_1Shared__name.html#ae89e1e061f87ffe0288514e254837595" title="Returns (sans copying) ref to immutable entire wrapped name string, suitable to pass into sys calls w...">str()</a> used to name a supported shared resource, sys call safely won't barf. </p>
<dl class="todo"><dt><b><a class="el" href="todo.html#_todo000012">Todo:</a></b></dt><dd><a class="el" href="classipc_1_1util_1_1Shared__name.html#afc9b87fc69d42df3107bf4a27ea66c7c" title="Max value of size() such that, if str() used to name a supported shared resource, sys call safely won...">Shared_name::S_MAX_LENGTH</a> currently applies to all shared resource types, but it'd be a useful feature to have different limits depending on OS/whatever limitations for particular resources types such as SHM object names versus queue names versus whatever.</dd></dl>

</div>
</div>
<a id="a43205a00865429c1bef6c7896816bf5c" name="a43205a00865429c1bef6c7896816bf5c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a43205a00865429c1bef6c7896816bf5c">&#9670;&nbsp;</a></span>S_SENTINEL</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classipc_1_1util_1_1Shared__name.html">Shared_name</a> ipc::util::Shared_name::S_SENTINEL = <a class="el" href="classipc_1_1util_1_1Shared__name.html#a48f20b7b54490aa10dc64081d34c55b2">Shared_name::ct</a>(&quot;0&quot;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>A <a class="el" href="classipc_1_1util_1_1Shared__name.html" title="String-wrapping abstraction representing a name uniquely distinguishing a kernel-persistent entity fr...">Shared_name</a> fragment, with no <a class="el" href="classipc_1_1util_1_1Shared__name.html#a5c0910497c5ec484d3e42dfb0ccad48d" title="Character we use, by convention, to separate conceptual folders within str().">S_SEPARATOR</a> characters inside, that represents a path component that shall be different from any other generated string at the same path depth in the same context; and represents a sentinel. </p>
<p >In actual fact it equals <code>0</code>; and typically (though not necessarily &ndash; other conventions may exist) generated strings shall be <code>1</code>, <code>2</code>, ..., of which the former is <a class="el" href="classipc_1_1util_1_1Shared__name.html#aaa78ddb3efa5abe4fa80058dedbef68c" title="A Shared_name fragment, with no S_SEPARATOR characters inside, that represents a path component that ...">S_1ST_OR_ONLY</a>. </p>

</div>
</div>
<hr/>The documentation for this class was generated from the following files:<ul>
<li>util/<a class="el" href="shared__name_8hpp.html">shared_name.hpp</a></li>
<li>util/<a class="el" href="shared__name_8cpp.html">shared_name.cpp</a></li>
<li>util/<a class="el" href="shared__name__fwd_8hpp.html">shared_name_fwd.hpp</a></li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Tue Apr 30 2024 23:39:16 for Flow-IPC by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.4
</small></address>
</body>
</html>
