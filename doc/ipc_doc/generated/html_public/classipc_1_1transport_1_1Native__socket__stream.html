<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.9.4"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Flow-IPC: ipc::transport::Native_socket_stream Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">Flow-IPC<span id="projectnumber">&#160;1.0.0</span>
   </div>
   <div id="projectbrief">Flow-IPC project: Public API.</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.4 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search",'Search','.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespaceipc.html">ipc</a></li><li class="navelem"><a class="el" href="namespaceipc_1_1transport.html">transport</a></li><li class="navelem"><a class="el" href="classipc_1_1transport_1_1Native__socket__stream.html">Native_socket_stream</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-types">Public Types</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pub-static-attribs">Static Public Attributes</a> &#124;
<a href="#related">Related Functions</a> &#124;
<a href="classipc_1_1transport_1_1Native__socket__stream-members.html">List of all members</a>  </div>
  <div class="headertitle"><div class="title">ipc::transport::Native_socket_stream Class Reference</div></div>
</div><!--header-->
<div class="contents">

<p>Implements both <a class="el" href="classipc_1_1transport_1_1Native__handle__sender.html" title="A documentation-only concept defining the behavior of an object capable of reliably/in-order sending ...">Native_handle_sender</a> and <a class="el" href="classipc_1_1transport_1_1Native__handle__receiver.html" title="A documentation-only concept defining the behavior of an object capable of reliably/in-order receivin...">Native_handle_receiver</a> concepts by using a stream-oriented Unix domain socket, allowing high-performance but non-zero-copy transmission of discrete messages, each containing a native handle, a binary blob, or both.  
 <a href="classipc_1_1transport_1_1Native__socket__stream.html#details">More...</a></p>

<p><code>#include &lt;native_socket_stream.hpp&gt;</code></p>
<div class="dynheader">
Collaboration diagram for ipc::transport::Native_socket_stream:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="classipc_1_1transport_1_1Native__socket__stream__coll__graph.svg" width="284" height="203"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe>
</div>
<center><span class="legend">[<a href="graph_legend.html">legend</a>]</span></center></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-types" name="pub-types"></a>
Public Types</h2></td></tr>
<tr class="memitem:a850af22a95f27d8696b9b5bca15454b5"><td class="memItemLeft" align="right" valign="top"><a id="a850af22a95f27d8696b9b5bca15454b5" name="a850af22a95f27d8696b9b5bca15454b5"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>Sync_io_obj</b> = <a class="el" href="classipc_1_1transport_1_1sync__io_1_1Native__socket__stream.html">sync_io::Native_socket_stream</a></td></tr>
<tr class="memdesc:a850af22a95f27d8696b9b5bca15454b5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Useful for generic programming, the <code><a class="el" href="namespaceipc_1_1transport_1_1sync__io.html" title="sync_io-pattern counterparts to async-I/O-pattern object types in parent namespace ipc::transport.">sync_io</a></code>-pattern counterpart to <code>*this</code> type. <br /></td></tr>
<tr class="separator:a850af22a95f27d8696b9b5bca15454b5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5401e1f0e8cd4a6cc8c31373da5df982"><td class="memItemLeft" align="right" valign="top"><a id="a5401e1f0e8cd4a6cc8c31373da5df982" name="a5401e1f0e8cd4a6cc8c31373da5df982"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>Async_io_obj</b> = <a class="el" href="classipc_1_1transport_1_1Null__peer.html">Null_peer</a></td></tr>
<tr class="memdesc:a5401e1f0e8cd4a6cc8c31373da5df982"><td class="mdescLeft">&#160;</td><td class="mdescRight">You may disregard. <br /></td></tr>
<tr class="separator:a5401e1f0e8cd4a6cc8c31373da5df982"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-methods" name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:aae823547a7ad0b9fdc691eb40c94d7da"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classipc_1_1transport_1_1Native__socket__stream.html#aae823547a7ad0b9fdc691eb40c94d7da">Native_socket_stream</a> ()</td></tr>
<tr class="memdesc:aae823547a7ad0b9fdc691eb40c94d7da"><td class="mdescLeft">&#160;</td><td class="mdescRight">Default ctor (object is in NULL state).  <a href="classipc_1_1transport_1_1Native__socket__stream.html#aae823547a7ad0b9fdc691eb40c94d7da">More...</a><br /></td></tr>
<tr class="separator:aae823547a7ad0b9fdc691eb40c94d7da"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a99129e374920713cfd10314f0bd21d5e"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classipc_1_1transport_1_1Native__socket__stream.html#a99129e374920713cfd10314f0bd21d5e">Native_socket_stream</a> (flow::log::Logger *logger_ptr, <a class="el" href="namespaceipc_1_1util.html#ae6ac47812a90d1287c61e0b7de7bc4f5">util::String_view</a> nickname_str)</td></tr>
<tr class="memdesc:a99129e374920713cfd10314f0bd21d5e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a <a class="el" href="classipc_1_1transport_1_1Native__socket__stream.html" title="Implements both Native_handle_sender and Native_handle_receiver concepts by using a stream-oriented U...">Native_socket_stream</a> in NULL (not connected, not connecting) state.  <a href="classipc_1_1transport_1_1Native__socket__stream.html#a99129e374920713cfd10314f0bd21d5e">More...</a><br /></td></tr>
<tr class="separator:a99129e374920713cfd10314f0bd21d5e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1b8f0515fb970631092b12b5862d2542"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classipc_1_1transport_1_1Native__socket__stream.html#a1b8f0515fb970631092b12b5862d2542">Native_socket_stream</a> (flow::log::Logger *logger_ptr, <a class="el" href="namespaceipc_1_1util.html#ae6ac47812a90d1287c61e0b7de7bc4f5">util::String_view</a> nickname_str, <a class="el" href="namespaceipc_1_1transport.html#a7ee4551983d9df16ec16a3139bac50e8">Native_handle</a> &amp;&amp;native_peer_socket_moved)</td></tr>
<tr class="memdesc:a1b8f0515fb970631092b12b5862d2542"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructs the socket-and-meta-blob stream by taking over an already-connected native Unix domain socket handle.  <a href="classipc_1_1transport_1_1Native__socket__stream.html#a1b8f0515fb970631092b12b5862d2542">More...</a><br /></td></tr>
<tr class="separator:a1b8f0515fb970631092b12b5862d2542"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6e3cd290da856e2f486dd1536afdea2d"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classipc_1_1transport_1_1Native__socket__stream.html#a6e3cd290da856e2f486dd1536afdea2d">Native_socket_stream</a> (<a class="el" href="classipc_1_1transport_1_1Native__socket__stream.html#a850af22a95f27d8696b9b5bca15454b5">Sync_io_obj</a> &amp;&amp;sync_io_core_in_peer_state_moved)</td></tr>
<tr class="memdesc:a6e3cd290da856e2f486dd1536afdea2d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Implements <a class="el" href="classipc_1_1transport_1_1Native__handle__sender.html" title="A documentation-only concept defining the behavior of an object capable of reliably/in-order sending ...">Native_handle_sender</a> <em>and</em> <a class="el" href="classipc_1_1transport_1_1Native__handle__receiver.html" title="A documentation-only concept defining the behavior of an object capable of reliably/in-order receivin...">Native_handle_receiver</a> APIs at the same time, per their concept contracts.  <a href="classipc_1_1transport_1_1Native__socket__stream.html#a6e3cd290da856e2f486dd1536afdea2d">More...</a><br /></td></tr>
<tr class="separator:a6e3cd290da856e2f486dd1536afdea2d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a433d09587c6d854e59c12d4f483516fb"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classipc_1_1transport_1_1Native__socket__stream.html#a433d09587c6d854e59c12d4f483516fb">Native_socket_stream</a> (<a class="el" href="classipc_1_1transport_1_1Native__socket__stream.html">Native_socket_stream</a> &amp;&amp;src)</td></tr>
<tr class="memdesc:a433d09587c6d854e59c12d4f483516fb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Move-constructs from <code>src</code>; <code>src</code> becomes as-if default-cted (therefore in NULL state).  <a href="classipc_1_1transport_1_1Native__socket__stream.html#a433d09587c6d854e59c12d4f483516fb">More...</a><br /></td></tr>
<tr class="separator:a433d09587c6d854e59c12d4f483516fb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a11409650b45a575743371169226aaf7c"><td class="memItemLeft" align="right" valign="top"><a id="a11409650b45a575743371169226aaf7c" name="a11409650b45a575743371169226aaf7c"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>Native_socket_stream</b> (const <a class="el" href="classipc_1_1transport_1_1Native__socket__stream.html">Native_socket_stream</a> &amp;)=delete</td></tr>
<tr class="memdesc:a11409650b45a575743371169226aaf7c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy construction is disallowed. <br /></td></tr>
<tr class="separator:a11409650b45a575743371169226aaf7c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1ff9e6811c0d662a6a960602be5926e0"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classipc_1_1transport_1_1Native__socket__stream.html#a1ff9e6811c0d662a6a960602be5926e0">~Native_socket_stream</a> ()</td></tr>
<tr class="memdesc:a1ff9e6811c0d662a6a960602be5926e0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Implements <a class="el" href="classipc_1_1transport_1_1Native__handle__sender.html" title="A documentation-only concept defining the behavior of an object capable of reliably/in-order sending ...">Native_handle_sender</a> <em>and</em> <a class="el" href="classipc_1_1transport_1_1Native__handle__receiver.html" title="A documentation-only concept defining the behavior of an object capable of reliably/in-order receivin...">Native_handle_receiver</a> APIs at the same time, per their concept contracts.  <a href="classipc_1_1transport_1_1Native__socket__stream.html#a1ff9e6811c0d662a6a960602be5926e0">More...</a><br /></td></tr>
<tr class="separator:a1ff9e6811c0d662a6a960602be5926e0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a559ef620bfc3f46220dc7c3522bed32d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classipc_1_1transport_1_1Native__socket__stream.html#a850af22a95f27d8696b9b5bca15454b5">Sync_io_obj</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classipc_1_1transport_1_1Native__socket__stream.html#a559ef620bfc3f46220dc7c3522bed32d">release</a> ()</td></tr>
<tr class="memdesc:a559ef620bfc3f46220dc7c3522bed32d"><td class="mdescLeft">&#160;</td><td class="mdescRight">In PEER state only, with no prior send or receive ops, returns a <a class="el" href="classipc_1_1transport_1_1sync__io_1_1Native__socket__stream.html" title="Implements both sync_io::Native_handle_sender and sync_io::Native_handle_receiver concepts by using a...">sync_io::Native_socket_stream</a> core (as-if just constructed) operating on <code>*this</code> underlying low-level transport <code>Native_handle</code>; while <code>*this</code> becomes as-if default-cted.  <a href="classipc_1_1transport_1_1Native__socket__stream.html#a559ef620bfc3f46220dc7c3522bed32d">More...</a><br /></td></tr>
<tr class="separator:a559ef620bfc3f46220dc7c3522bed32d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afa23616d048eef3649bd20a2385af4c5"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classipc_1_1transport_1_1Native__socket__stream.html">Native_socket_stream</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classipc_1_1transport_1_1Native__socket__stream.html#afa23616d048eef3649bd20a2385af4c5">operator=</a> (<a class="el" href="classipc_1_1transport_1_1Native__socket__stream.html">Native_socket_stream</a> &amp;&amp;src)</td></tr>
<tr class="memdesc:afa23616d048eef3649bd20a2385af4c5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Move-assigns from <code>src</code>; <code>*this</code> acts as if destructed; <code>src</code> becomes as-if default-cted (therefore in NULL state).  <a href="classipc_1_1transport_1_1Native__socket__stream.html#afa23616d048eef3649bd20a2385af4c5">More...</a><br /></td></tr>
<tr class="separator:afa23616d048eef3649bd20a2385af4c5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a11715d6bc6844d1189ff694344bc343a"><td class="memItemLeft" align="right" valign="top"><a id="a11715d6bc6844d1189ff694344bc343a" name="a11715d6bc6844d1189ff694344bc343a"></a>
<a class="el" href="classipc_1_1transport_1_1Native__socket__stream.html">Native_socket_stream</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>operator=</b> (const <a class="el" href="classipc_1_1transport_1_1Native__socket__stream.html">Native_socket_stream</a> &amp;)=delete</td></tr>
<tr class="memdesc:a11715d6bc6844d1189ff694344bc343a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy assignment is disallowed. <br /></td></tr>
<tr class="separator:a11715d6bc6844d1189ff694344bc343a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a25d9c0e12a03a3b68f7f266c23466f71"><td class="memItemLeft" align="right" valign="top">const std::string &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classipc_1_1transport_1_1Native__socket__stream.html#a25d9c0e12a03a3b68f7f266c23466f71">nickname</a> () const</td></tr>
<tr class="memdesc:a25d9c0e12a03a3b68f7f266c23466f71"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns nickname, a brief string suitable for logging.  <a href="classipc_1_1transport_1_1Native__socket__stream.html#a25d9c0e12a03a3b68f7f266c23466f71">More...</a><br /></td></tr>
<tr class="separator:a25d9c0e12a03a3b68f7f266c23466f71"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3614a9677c1a203090b97ac935093390"><td class="memTemplParams" colspan="2">template&lt;typename Task_err &gt; </td></tr>
<tr class="memitem:a3614a9677c1a203090b97ac935093390"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classipc_1_1transport_1_1Native__socket__stream.html#a3614a9677c1a203090b97ac935093390">async_connect</a> (const <a class="el" href="namespaceipc_1_1transport.html#a33de1c256addb3964b839dc2dd407d24">Shared_name</a> &amp;absolute_name, Task_err &amp;&amp;on_done_func)</td></tr>
<tr class="memdesc:a3614a9677c1a203090b97ac935093390"><td class="mdescLeft">&#160;</td><td class="mdescRight">To be invoked in NULL state only, it asynchronously attempts to connect to an opposing <a class="el" href="classipc_1_1transport_1_1Native__socket__stream__acceptor.html" title="A server object that binds to a Shared_name and listens for incoming Native_socket_stream::*_connect(...">Native_socket_stream_acceptor</a> or <a class="el" href="classipc_1_1transport_1_1sync__io_1_1Native__socket__stream__acceptor.html" title="sync_io-pattern counterpart to async-I/O-pattern transport::Native_socket_stream_acceptor.">sync_io::Native_socket_stream_acceptor</a> listening at the given absolute Shared_name; and on success invokes the given completion handler with a falsy value indicating <code>*this</code> has entered PEER state.  <a href="classipc_1_1transport_1_1Native__socket__stream.html#a3614a9677c1a203090b97ac935093390">More...</a><br /></td></tr>
<tr class="separator:a3614a9677c1a203090b97ac935093390"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a844b8245c9341da8006f979c6b005893"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classipc_1_1transport_1_1Native__socket__stream.html#a844b8245c9341da8006f979c6b005893">send_meta_blob_max_size</a> () const</td></tr>
<tr class="memdesc:a844b8245c9341da8006f979c6b005893"><td class="mdescLeft">&#160;</td><td class="mdescRight">Implements <a class="el" href="classipc_1_1transport_1_1Native__handle__sender.html" title="A documentation-only concept defining the behavior of an object capable of reliably/in-order sending ...">Native_handle_sender</a> API per contract.  <a href="classipc_1_1transport_1_1Native__socket__stream.html#a844b8245c9341da8006f979c6b005893">More...</a><br /></td></tr>
<tr class="separator:a844b8245c9341da8006f979c6b005893"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a127a462a4aaf6e5cf1e42bdd33f51693"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classipc_1_1transport_1_1Native__socket__stream.html#a127a462a4aaf6e5cf1e42bdd33f51693">send_blob_max_size</a> () const</td></tr>
<tr class="memdesc:a127a462a4aaf6e5cf1e42bdd33f51693"><td class="mdescLeft">&#160;</td><td class="mdescRight">Implements <a class="el" href="classipc_1_1transport_1_1Blob__sender.html" title="A documentation-only concept defining the behavior of an object capable of reliably/in-order sending ...">Blob_sender</a> API per contract.  <a href="classipc_1_1transport_1_1Native__socket__stream.html#a127a462a4aaf6e5cf1e42bdd33f51693">More...</a><br /></td></tr>
<tr class="separator:a127a462a4aaf6e5cf1e42bdd33f51693"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a555df6a81654160285ea35b545cfd23d"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classipc_1_1transport_1_1Native__socket__stream.html#a555df6a81654160285ea35b545cfd23d">send_native_handle</a> (<a class="el" href="namespaceipc_1_1transport.html#a7ee4551983d9df16ec16a3139bac50e8">Native_handle</a> hndl_or_null, const <a class="el" href="namespaceipc_1_1util.html#ae0be7edba7e30ffa3f8b742af621f2ab">util::Blob_const</a> &amp;meta_blob, <a class="el" href="namespaceipc.html#aa3192e586cc45d3e7c22463bf2760f89">Error_code</a> *err_code=0)</td></tr>
<tr class="memdesc:a555df6a81654160285ea35b545cfd23d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Implements <a class="el" href="classipc_1_1transport_1_1Native__handle__sender.html" title="A documentation-only concept defining the behavior of an object capable of reliably/in-order sending ...">Native_handle_sender</a> API per contract.  <a href="classipc_1_1transport_1_1Native__socket__stream.html#a555df6a81654160285ea35b545cfd23d">More...</a><br /></td></tr>
<tr class="separator:a555df6a81654160285ea35b545cfd23d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a415febd76ee222c81d59d2bcfa9c01bc"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classipc_1_1transport_1_1Native__socket__stream.html#a415febd76ee222c81d59d2bcfa9c01bc">send_blob</a> (const <a class="el" href="namespaceipc_1_1util.html#ae0be7edba7e30ffa3f8b742af621f2ab">util::Blob_const</a> &amp;blob, <a class="el" href="namespaceipc.html#aa3192e586cc45d3e7c22463bf2760f89">Error_code</a> *err_code=0)</td></tr>
<tr class="memdesc:a415febd76ee222c81d59d2bcfa9c01bc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Implements <a class="el" href="classipc_1_1transport_1_1Blob__sender.html" title="A documentation-only concept defining the behavior of an object capable of reliably/in-order sending ...">Blob_sender</a> API per contract.  <a href="classipc_1_1transport_1_1Native__socket__stream.html#a415febd76ee222c81d59d2bcfa9c01bc">More...</a><br /></td></tr>
<tr class="separator:a415febd76ee222c81d59d2bcfa9c01bc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac3cd00ddd2e0502677630320708277a3"><td class="memTemplParams" colspan="2">template&lt;typename Task_err &gt; </td></tr>
<tr class="memitem:ac3cd00ddd2e0502677630320708277a3"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classipc_1_1transport_1_1Native__socket__stream.html#ac3cd00ddd2e0502677630320708277a3">async_end_sending</a> (Task_err &amp;&amp;on_done_func)</td></tr>
<tr class="memdesc:ac3cd00ddd2e0502677630320708277a3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Implements <a class="el" href="classipc_1_1transport_1_1Native__handle__sender.html" title="A documentation-only concept defining the behavior of an object capable of reliably/in-order sending ...">Native_handle_sender</a>, <a class="el" href="classipc_1_1transport_1_1Blob__sender.html" title="A documentation-only concept defining the behavior of an object capable of reliably/in-order sending ...">Blob_sender</a> API per contract.  <a href="classipc_1_1transport_1_1Native__socket__stream.html#ac3cd00ddd2e0502677630320708277a3">More...</a><br /></td></tr>
<tr class="separator:ac3cd00ddd2e0502677630320708277a3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ace134e4a6e4918212f256b60c3ed77e4"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classipc_1_1transport_1_1Native__socket__stream.html#ace134e4a6e4918212f256b60c3ed77e4">end_sending</a> ()</td></tr>
<tr class="memdesc:ace134e4a6e4918212f256b60c3ed77e4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Implements <a class="el" href="classipc_1_1transport_1_1Native__handle__sender.html" title="A documentation-only concept defining the behavior of an object capable of reliably/in-order sending ...">Native_handle_sender</a>, <a class="el" href="classipc_1_1transport_1_1Blob__sender.html" title="A documentation-only concept defining the behavior of an object capable of reliably/in-order sending ...">Blob_sender</a> API per contract.  <a href="classipc_1_1transport_1_1Native__socket__stream.html#ace134e4a6e4918212f256b60c3ed77e4">More...</a><br /></td></tr>
<tr class="separator:ace134e4a6e4918212f256b60c3ed77e4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa5e699d5eead4220bf8b5604f629a970"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classipc_1_1transport_1_1Native__socket__stream.html#aa5e699d5eead4220bf8b5604f629a970">auto_ping</a> (<a class="el" href="namespaceipc_1_1util.html#ac66141280c3b7295a86b65209f31cc58">util::Fine_duration</a> period=boost::chrono::seconds(2))</td></tr>
<tr class="memdesc:aa5e699d5eead4220bf8b5604f629a970"><td class="mdescLeft">&#160;</td><td class="mdescRight">Implements <a class="el" href="classipc_1_1transport_1_1Native__handle__sender.html" title="A documentation-only concept defining the behavior of an object capable of reliably/in-order sending ...">Native_handle_sender</a>, <a class="el" href="classipc_1_1transport_1_1Blob__sender.html" title="A documentation-only concept defining the behavior of an object capable of reliably/in-order sending ...">Blob_sender</a> API per contract.  <a href="classipc_1_1transport_1_1Native__socket__stream.html#aa5e699d5eead4220bf8b5604f629a970">More...</a><br /></td></tr>
<tr class="separator:aa5e699d5eead4220bf8b5604f629a970"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac7659af6812efca67c410af286f0cb34"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classipc_1_1transport_1_1Native__socket__stream.html#ac7659af6812efca67c410af286f0cb34">receive_meta_blob_max_size</a> () const</td></tr>
<tr class="memdesc:ac7659af6812efca67c410af286f0cb34"><td class="mdescLeft">&#160;</td><td class="mdescRight">Implements <a class="el" href="classipc_1_1transport_1_1Native__handle__receiver.html" title="A documentation-only concept defining the behavior of an object capable of reliably/in-order receivin...">Native_handle_receiver</a> API per contract.  <a href="classipc_1_1transport_1_1Native__socket__stream.html#ac7659af6812efca67c410af286f0cb34">More...</a><br /></td></tr>
<tr class="separator:ac7659af6812efca67c410af286f0cb34"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adb667160fd0ab3951d93d219d7bdc3be"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classipc_1_1transport_1_1Native__socket__stream.html#adb667160fd0ab3951d93d219d7bdc3be">receive_blob_max_size</a> () const</td></tr>
<tr class="memdesc:adb667160fd0ab3951d93d219d7bdc3be"><td class="mdescLeft">&#160;</td><td class="mdescRight">Implements <a class="el" href="classipc_1_1transport_1_1Blob__receiver.html" title="A documentation-only concept defining the behavior of an object capable of reliably/in-order receivin...">Blob_receiver</a> API per contract.  <a href="classipc_1_1transport_1_1Native__socket__stream.html#adb667160fd0ab3951d93d219d7bdc3be">More...</a><br /></td></tr>
<tr class="separator:adb667160fd0ab3951d93d219d7bdc3be"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a266b52821557f2a4fa8f81058290dee2"><td class="memTemplParams" colspan="2">template&lt;typename Task_err_sz &gt; </td></tr>
<tr class="memitem:a266b52821557f2a4fa8f81058290dee2"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classipc_1_1transport_1_1Native__socket__stream.html#a266b52821557f2a4fa8f81058290dee2">async_receive_native_handle</a> (<a class="el" href="namespaceipc_1_1transport.html#a7ee4551983d9df16ec16a3139bac50e8">Native_handle</a> *target_hndl, const <a class="el" href="namespaceipc_1_1util.html#a6cb62ae434900f3a8915b33ec5d61a96">util::Blob_mutable</a> &amp;target_meta_blob, Task_err_sz &amp;&amp;on_done_func)</td></tr>
<tr class="memdesc:a266b52821557f2a4fa8f81058290dee2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Implements <a class="el" href="classipc_1_1transport_1_1Native__handle__receiver.html" title="A documentation-only concept defining the behavior of an object capable of reliably/in-order receivin...">Native_handle_receiver</a> API per contract.  <a href="classipc_1_1transport_1_1Native__socket__stream.html#a266b52821557f2a4fa8f81058290dee2">More...</a><br /></td></tr>
<tr class="separator:a266b52821557f2a4fa8f81058290dee2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac5572c8165e25f106f18d327c07d1c3f"><td class="memTemplParams" colspan="2">template&lt;typename Task_err_sz &gt; </td></tr>
<tr class="memitem:ac5572c8165e25f106f18d327c07d1c3f"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classipc_1_1transport_1_1Native__socket__stream.html#ac5572c8165e25f106f18d327c07d1c3f">async_receive_blob</a> (const <a class="el" href="namespaceipc_1_1util.html#a6cb62ae434900f3a8915b33ec5d61a96">util::Blob_mutable</a> &amp;target_blob, Task_err_sz &amp;&amp;on_done_func)</td></tr>
<tr class="memdesc:ac5572c8165e25f106f18d327c07d1c3f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Implements <a class="el" href="classipc_1_1transport_1_1Blob__receiver.html" title="A documentation-only concept defining the behavior of an object capable of reliably/in-order receivin...">Blob_receiver</a> API per contract.  <a href="classipc_1_1transport_1_1Native__socket__stream.html#ac5572c8165e25f106f18d327c07d1c3f">More...</a><br /></td></tr>
<tr class="separator:ac5572c8165e25f106f18d327c07d1c3f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1b4ce3ddee39f21e752ec9114ac17bbd"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classipc_1_1transport_1_1Native__socket__stream.html#a1b4ce3ddee39f21e752ec9114ac17bbd">idle_timer_run</a> (<a class="el" href="namespaceipc_1_1util.html#ac66141280c3b7295a86b65209f31cc58">util::Fine_duration</a> timeout=boost::chrono::seconds(5))</td></tr>
<tr class="memdesc:a1b4ce3ddee39f21e752ec9114ac17bbd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Implements <a class="el" href="classipc_1_1transport_1_1Native__handle__receiver.html" title="A documentation-only concept defining the behavior of an object capable of reliably/in-order receivin...">Native_handle_receiver</a>, <a class="el" href="classipc_1_1transport_1_1Blob__receiver.html" title="A documentation-only concept defining the behavior of an object capable of reliably/in-order receivin...">Blob_receiver</a> API per contract.  <a href="classipc_1_1transport_1_1Native__socket__stream.html#a1b4ce3ddee39f21e752ec9114ac17bbd">More...</a><br /></td></tr>
<tr class="separator:a1b4ce3ddee39f21e752ec9114ac17bbd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af63671c0e30d39d3460331c4dd3742b2"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classipc_1_1util_1_1Process__credentials.html">util::Process_credentials</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classipc_1_1transport_1_1Native__socket__stream.html#af63671c0e30d39d3460331c4dd3742b2">remote_peer_process_credentials</a> (<a class="el" href="namespaceipc.html#aa3192e586cc45d3e7c22463bf2760f89">Error_code</a> *err_code=0) const</td></tr>
<tr class="memdesc:af63671c0e30d39d3460331c4dd3742b2"><td class="mdescLeft">&#160;</td><td class="mdescRight">OS-reported process credential (PID, etc.) info about the <em>other</em> connected peer's process, at the time that the OS first established (via local-socket-connect or local-socket-connected-pair-generate call) that opposing peer socket.  <a href="classipc_1_1transport_1_1Native__socket__stream.html#af63671c0e30d39d3460331c4dd3742b2">More...</a><br /></td></tr>
<tr class="separator:af63671c0e30d39d3460331c4dd3742b2"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-static-attribs" name="pub-static-attribs"></a>
Static Public Attributes</h2></td></tr>
<tr class="memitem:a6271d2cc490f82197990c70be5d8747e"><td class="memItemLeft" align="right" valign="top"><a id="a6271d2cc490f82197990c70be5d8747e" name="a6271d2cc490f82197990c70be5d8747e"></a>
static const <a class="el" href="namespaceipc_1_1transport.html#a33de1c256addb3964b839dc2dd407d24">Shared_name</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>S_RESOURCE_TYPE_ID</b> = Sync_io_obj::S_RESOURCE_TYPE_ID</td></tr>
<tr class="memdesc:a6271d2cc490f82197990c70be5d8747e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Implements concept API. <br /></td></tr>
<tr class="separator:a6271d2cc490f82197990c70be5d8747e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a859615800ba1e0546c8e5cb8a6796e41"><td class="memItemLeft" align="right" valign="top">static constexpr bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classipc_1_1transport_1_1Native__socket__stream.html#a859615800ba1e0546c8e5cb8a6796e41">S_META_BLOB_UNDERFLOW_ALLOWED</a> = true</td></tr>
<tr class="memdesc:a859615800ba1e0546c8e5cb8a6796e41"><td class="mdescLeft">&#160;</td><td class="mdescRight">Implements concept API; namely it is <code>true</code>: <a class="el" href="classipc_1_1transport_1_1Native__socket__stream.html#a266b52821557f2a4fa8f81058290dee2" title="Implements Native_handle_receiver API per contract.">async_receive_native_handle()</a> with smaller-than-<code><a class="el" href="classipc_1_1transport_1_1Native__socket__stream.html#ac7659af6812efca67c410af286f0cb34" title="Implements Native_handle_receiver API per contract.">receive_meta_blob_max_size()</a></code> size shall <em>not</em> lead to <a class="el" href="namespaceipc_1_1transport_1_1error.html#adfef15ef4e76cc55d652fbd9c2797297ac416e988563e44bf15fc6a81743eef53" title="User called an API with 1 or more arguments against the API spec.">error::Code::S_INVALID_ARGUMENT</a>; hence <a class="el" href="namespaceipc_1_1transport_1_1error.html#adfef15ef4e76cc55d652fbd9c2797297adde24987f30a92b953297207ce935210" title="User protocol-code mismatch: local user-provided storage cannot fit entire message received from oppo...">error::Code::S_MESSAGE_SIZE_EXCEEDS_USER_STORAGE</a> is possible.  <a href="classipc_1_1transport_1_1Native__socket__stream.html#a859615800ba1e0546c8e5cb8a6796e41">More...</a><br /></td></tr>
<tr class="separator:a859615800ba1e0546c8e5cb8a6796e41"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a59d4ec9f05762a8bc2db4b752d4fd5f4"><td class="memItemLeft" align="right" valign="top">static constexpr bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classipc_1_1transport_1_1Native__socket__stream.html#a59d4ec9f05762a8bc2db4b752d4fd5f4">S_BLOB_UNDERFLOW_ALLOWED</a> = true</td></tr>
<tr class="memdesc:a59d4ec9f05762a8bc2db4b752d4fd5f4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Implements concept API; namely it is <code>true</code>: <a class="el" href="classipc_1_1transport_1_1Native__socket__stream.html#ac5572c8165e25f106f18d327c07d1c3f" title="Implements Blob_receiver API per contract.">async_receive_blob()</a> with smaller-than-<code><a class="el" href="classipc_1_1transport_1_1Native__socket__stream.html#adb667160fd0ab3951d93d219d7bdc3be" title="Implements Blob_receiver API per contract.">receive_blob_max_size()</a></code> size shall <em>not</em> lead to <a class="el" href="namespaceipc_1_1transport_1_1error.html#adfef15ef4e76cc55d652fbd9c2797297ac416e988563e44bf15fc6a81743eef53" title="User called an API with 1 or more arguments against the API spec.">error::Code::S_INVALID_ARGUMENT</a>; hence <a class="el" href="namespaceipc_1_1transport_1_1error.html#adfef15ef4e76cc55d652fbd9c2797297adde24987f30a92b953297207ce935210" title="User protocol-code mismatch: local user-provided storage cannot fit entire message received from oppo...">error::Code::S_MESSAGE_SIZE_EXCEEDS_USER_STORAGE</a> is possible.  <a href="classipc_1_1transport_1_1Native__socket__stream.html#a59d4ec9f05762a8bc2db4b752d4fd5f4">More...</a><br /></td></tr>
<tr class="separator:a59d4ec9f05762a8bc2db4b752d4fd5f4"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="related" name="related"></a>
Related Functions</h2></td></tr>
<tr><td class="ititle" colspan="2"><p >(Note that these are not member functions.) </p>
</td></tr>
<tr class="memitem:ac6108711cc8b33c3b7ef0491ba78e2f6"><td class="memItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classipc_1_1transport_1_1Native__socket__stream.html#ac6108711cc8b33c3b7ef0491ba78e2f6">operator&lt;&lt;</a> (std::ostream &amp;os, const <a class="el" href="classipc_1_1transport_1_1Native__socket__stream.html">Native_socket_stream</a> &amp;val)</td></tr>
<tr class="memdesc:ac6108711cc8b33c3b7ef0491ba78e2f6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Prints string representation of the given <code><a class="el" href="classipc_1_1transport_1_1Native__socket__stream.html" title="Implements both Native_handle_sender and Native_handle_receiver concepts by using a stream-oriented U...">Native_socket_stream</a></code> to the given <code>ostream</code>.  <a href="classipc_1_1transport_1_1Native__socket__stream.html#ac6108711cc8b33c3b7ef0491ba78e2f6">More...</a><br /></td></tr>
<tr class="separator:ac6108711cc8b33c3b7ef0491ba78e2f6"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p >Implements both <a class="el" href="classipc_1_1transport_1_1Native__handle__sender.html" title="A documentation-only concept defining the behavior of an object capable of reliably/in-order sending ...">Native_handle_sender</a> and <a class="el" href="classipc_1_1transport_1_1Native__handle__receiver.html" title="A documentation-only concept defining the behavior of an object capable of reliably/in-order receivin...">Native_handle_receiver</a> concepts by using a stream-oriented Unix domain socket, allowing high-performance but non-zero-copy transmission of discrete messages, each containing a native handle, a binary blob, or both. </p>
<p >This is a low-level (core) transport mechanism; higher-level (structured) transport mechanisms may use <a class="el" href="classipc_1_1transport_1_1Native__socket__stream.html" title="Implements both Native_handle_sender and Native_handle_receiver concepts by using a stream-oriented U...">Native_socket_stream</a> to enable their work. <a class="el" href="classipc_1_1transport_1_1Native__socket__stream.html" title="Implements both Native_handle_sender and Native_handle_receiver concepts by using a stream-oriented U...">Native_socket_stream</a>, as of this writing, is unique in that it is able to transmit not only blobs but also native handles.</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classipc_1_1transport_1_1sync__io_1_1Native__socket__stream.html" title="Implements both sync_io::Native_handle_sender and sync_io::Native_handle_receiver concepts by using a...">sync_io::Native_socket_stream</a> and <a class="el" href="namespaceipc_1_1util_1_1sync__io.html" title="Contains common code, as well as important explanatory documentation in the following text,...">util::sync_io</a> doc headers. The latter describes a general pattern which the former implements. In general we recommend you use a <code>*this</code> rather than a <a class="el" href="classipc_1_1transport_1_1sync__io_1_1Native__socket__stream.html" title="Implements both sync_io::Native_handle_sender and sync_io::Native_handle_receiver concepts by using a...">sync_io::Native_socket_stream</a> &ndash; but you may have particular needs (summarized in <a class="el" href="namespaceipc_1_1util_1_1sync__io.html" title="Contains common code, as well as important explanatory documentation in the following text,...">util::sync_io</a> doc header) that would make you decide otherwise.</dd></dl>
<h3>Quick note on naming</h3>
<p >It appears somewhat inconsistent to name it <code><a class="el" href="classipc_1_1transport_1_1Native__socket__stream.html" title="Implements both Native_handle_sender and Native_handle_receiver concepts by using a stream-oriented U...">Native_socket_stream</a>[_acceptor]</code> and not <code>Native_handle_stream[_acceptor]</code>, given the implemented concept names <code>Native_handle_*er</code> and a key payload type being <code>Native_handle</code>. It's subjective and a matter of aesthetics even, of course, but the reasoning is: It briefly conveys (or at least suggests) that the underlying transport is the Unix domain <em>socket</em> (<em>stream</em>-oriented at that); while also suggesting that <em>native</em> handles are transmissible over it (and it in fact is unique in that capability by the way). Perhaps something like <code>Native_handle_socket_stream[_acceptor]</code> would've been more accurate, but brevity is a virtue.</p>
<dl class="section note"><dt>Note</dt><dd>The same reasoning applies for <a class="el" href="classipc_1_1transport_1_1Socket__stream__channel.html" title="A Channel with a handles pipe only (no blobs pipe) that uses a Unix domain socket connection as the u...">Socket_stream_channel</a> and <a class="el" href="classipc_1_1transport_1_1Socket__stream__channel__of__blobs.html" title="A Channel with a blobs pipe only (no handles pipe) that uses a Unix domain socket connection as the u...">Socket_stream_channel_of_blobs</a> with the <code>native_</code> part being left out for orthogonal aesthetic reasons.</dd></dl>
<h3><a class="el" href="classipc_1_1transport_1_1Blob__sender.html" title="A documentation-only concept defining the behavior of an object capable of reliably/in-order sending ...">Blob_sender</a> and <a class="el" href="classipc_1_1transport_1_1Blob__receiver.html" title="A documentation-only concept defining the behavior of an object capable of reliably/in-order receivin...">Blob_receiver</a> concept compatibility</h3>
<p ><a class="el" href="classipc_1_1transport_1_1Native__socket__stream.html" title="Implements both Native_handle_sender and Native_handle_receiver concepts by using a stream-oriented U...">Native_socket_stream</a> also implements the <a class="el" href="classipc_1_1transport_1_1Blob__sender.html" title="A documentation-only concept defining the behavior of an object capable of reliably/in-order sending ...">Blob_sender</a> and <a class="el" href="classipc_1_1transport_1_1Blob__receiver.html" title="A documentation-only concept defining the behavior of an object capable of reliably/in-order receivin...">Blob_receiver</a> concepts. To wit: You must choose whether you shall use this as a <code>Blob_sender/receiver</code> or <code>Native_handle_sender/receiver</code>, and conversely the other side must do the same in matched fashion. Doing otherwise leads to undefined behavior. To use the latter concept pair simply use <a class="el" href="classipc_1_1transport_1_1Native__socket__stream.html#a555df6a81654160285ea35b545cfd23d" title="Implements Native_handle_sender API per contract.">send_native_handle()</a> and <a class="el" href="classipc_1_1transport_1_1Native__socket__stream.html#a266b52821557f2a4fa8f81058290dee2" title="Implements Native_handle_receiver API per contract.">async_receive_native_handle()</a> and never <a class="el" href="classipc_1_1transport_1_1Native__socket__stream.html#a415febd76ee222c81d59d2bcfa9c01bc" title="Implements Blob_sender API per contract.">send_blob()</a> or <a class="el" href="classipc_1_1transport_1_1Native__socket__stream.html#ac5572c8165e25f106f18d327c07d1c3f" title="Implements Blob_receiver API per contract.">async_receive_blob()</a>. To use the former concept pair simply do the reverse. On the other side do the matched thing. All the other methods/dtor are the same regardless of concept pair chosen.</p>
<p >How does this work? Trivially: consider, say, <a class="el" href="classipc_1_1transport_1_1Native__socket__stream.html#a555df6a81654160285ea35b545cfd23d" title="Implements Native_handle_sender API per contract.">send_native_handle()</a> which can send a native handle, or none; and a blob, or none (but at least 1 of the 2). <a class="el" href="classipc_1_1transport_1_1Native__socket__stream.html#a415febd76ee222c81d59d2bcfa9c01bc" title="Implements Blob_sender API per contract.">send_blob()</a> can only take a blob (which must be present) and internally will simply act as <a class="el" href="classipc_1_1transport_1_1Native__socket__stream.html#a555df6a81654160285ea35b545cfd23d" title="Implements Native_handle_sender API per contract.">send_native_handle()</a> with a null handle. Conversely <a class="el" href="classipc_1_1transport_1_1Native__socket__stream.html#a266b52821557f2a4fa8f81058290dee2" title="Implements Native_handle_receiver API per contract.">async_receive_native_handle()</a> receives a handle (or none) and blob (or none); so <a class="el" href="classipc_1_1transport_1_1Native__socket__stream.html#ac5572c8165e25f106f18d327c07d1c3f" title="Implements Blob_receiver API per contract.">async_receive_blob()</a> will receive only a blob. The only added behaviors in <code>Blob_sender/receiver</code> "mode":</p><ul>
<li><a class="el" href="classipc_1_1transport_1_1Native__socket__stream.html#a415febd76ee222c81d59d2bcfa9c01bc" title="Implements Blob_sender API per contract.">send_blob()</a> requires a blob of size 1+. (<a class="el" href="classipc_1_1transport_1_1Native__socket__stream.html#a555df6a81654160285ea35b545cfd23d" title="Implements Native_handle_sender API per contract.">send_native_handle()</a> allows an empty meta-blob; i.e., no blob.)</li>
<li><a class="el" href="classipc_1_1transport_1_1Native__socket__stream.html#ac5572c8165e25f106f18d327c07d1c3f" title="Implements Blob_receiver API per contract.">async_receive_blob()</a> will emit an error if a payload arrives with a native handle in it: <a class="el" href="namespaceipc_1_1transport_1_1error.html#adfef15ef4e76cc55d652fbd9c2797297ae3753569086cc66c6165480bd8d2f937" title="User protocol-code mismatch: local user expected blob only and no native handle; received at least th...">error::Code::S_BLOB_RECEIVER_GOT_NON_BLOB</a>. This would only occur if the other side were using the mismatched API.</li>
</ul>
<p >Further discussion ignores the degraded <code>Blob_*</code> concepts, as they are a trivial degenerate case of <code>Native_handle_*</code>.</p>
<dl class="section see"><dt>See also</dt><dd>other, dedicated <a class="el" href="classipc_1_1transport_1_1Blob__sender.html" title="A documentation-only concept defining the behavior of an object capable of reliably/in-order sending ...">Blob_sender</a> and <a class="el" href="classipc_1_1transport_1_1Blob__receiver.html" title="A documentation-only concept defining the behavior of an object capable of reliably/in-order receivin...">Blob_receiver</a> impls namely, at least, the persistent-MQ-based <a class="el" href="classipc_1_1transport_1_1Blob__stream__mq__sender.html" title="Implements Blob_sender concept by using an adopted Persistent_mq_handle MQ handle to an MQ (message q...">Blob_stream_mq_sender</a> and <a class="el" href="classipc_1_1transport_1_1Blob__stream__mq__receiver.html" title="Implements Blob_receiver concept by using an adopted Persistent_mq_handle MQ handle to an MQ (message...">Blob_stream_mq_receiver</a>. They may appeal due to potentially better performance and/or a creation/addressing scheme that is more appealing, depending.</dd></dl>
<h3>Informal comparison to other core transport mechanisms</h3>
<p >Firstly, as noted, it is currently unique in that it can transmit native handles. The rest of the discussion here is about transmitting blobs (called meta-blobs, meaning they accompany native handles).</p>
<p >It is intended for transmission of relatively short messages &ndash; rough guidance being for max length being in the 10s-of-KiB range. With a modern Linux kernel on server hardware from about 2014 to 2020, our performance tests show that its raw speed for messages of aforementioned size is comparable to zero-copy mechanisms based on POSIX message queues and Boost SHM-based message queues. Technically we found it to be somewhat faster than the latter and somewhat slower than the former. However, for best perf, it is recommended to send handles to SHM areas containing arbitrarily long structured messages (such as ones [de]serialized using zero-copy builders: capnp and the like). This further reduces the importance of relative perf compared to other low-level transports (which, as noted, is pretty close regardless &ndash; though this is bound to stop being true for much longer messages, if the send-SHM-handles technique were to <em>not</em> be used).</p>
<h3>Cleanup</h3>
<p >Some core transports rely on SHM or SHM-style semantics, wherein the transport has kernel persistence, meaning some or all processes exiting does not free the resources involved. For those transports special measures must be taken to ensure cleanup after both relevant processes die or no longer use a transport instance. This is not the case for <a class="el" href="classipc_1_1transport_1_1Native__socket__stream.html" title="Implements both Native_handle_sender and Native_handle_receiver concepts by using a stream-oriented U...">Native_socket_stream</a>: When the underlying (hidden from user) Unix domain socket handle is closed by both sides, all resources are automatically cleaned up; and processes exiting always closes all such handles. These matters for all transports are hidden from the user as much as possible, but these internal facts are still relevant knowledge for the reader/user.</p>
<h3>How to use</h3>
<p >Generally, this class's behavior is dictated by the 2 main concepts it implements: <a class="el" href="classipc_1_1transport_1_1Native__handle__sender.html" title="A documentation-only concept defining the behavior of an object capable of reliably/in-order sending ...">Native_handle_sender</a> and <a class="el" href="classipc_1_1transport_1_1Native__handle__receiver.html" title="A documentation-only concept defining the behavior of an object capable of reliably/in-order receivin...">Native_handle_receiver</a>. Though internally a single mechanism is used for both (incoming and outgoing) <em>pipes</em> (a term I use generically, not meaning "Unix FIFOs"), the two pipes are mostly decoupled. Bottom line: Behavior is dictated by the 2 concepts, so please see their respective doc headers first. Next, see the doc headers of the main concrete APIs which discuss any behaviors relevant to <a class="el" href="classipc_1_1transport_1_1Native__socket__stream.html" title="Implements both Native_handle_sender and Native_handle_receiver concepts by using a stream-oriented U...">Native_socket_stream</a> specifically:</p><ul>
<li>dtor;</li>
<li><a class="el" href="classipc_1_1transport_1_1Native__socket__stream.html#a555df6a81654160285ea35b545cfd23d" title="Implements Native_handle_sender API per contract.">send_native_handle()</a> (or <a class="el" href="classipc_1_1transport_1_1Native__socket__stream.html#a415febd76ee222c81d59d2bcfa9c01bc" title="Implements Blob_sender API per contract.">send_blob()</a>), <code>*end_sending()</code>, <a class="el" href="classipc_1_1transport_1_1Native__socket__stream.html#aa5e699d5eead4220bf8b5604f629a970" title="Implements Native_handle_sender, Blob_sender API per contract.">auto_ping()</a>;</li>
<li><a class="el" href="classipc_1_1transport_1_1Native__socket__stream.html#a266b52821557f2a4fa8f81058290dee2" title="Implements Native_handle_receiver API per contract.">async_receive_native_handle()</a> (or <a class="el" href="classipc_1_1transport_1_1Native__socket__stream.html#ac5572c8165e25f106f18d327c07d1c3f" title="Implements Blob_receiver API per contract.">async_receive_blob()</a>), <a class="el" href="classipc_1_1transport_1_1Native__socket__stream.html#a1b4ce3ddee39f21e752ec9114ac17bbd" title="Implements Native_handle_receiver, Blob_receiver API per contract.">idle_timer_run()</a>;</li>
<li><a class="el" href="classipc_1_1transport_1_1Native__socket__stream.html#a844b8245c9341da8006f979c6b005893" title="Implements Native_handle_sender API per contract.">send_meta_blob_max_size()</a> (or <a class="el" href="classipc_1_1transport_1_1Native__socket__stream.html#a127a462a4aaf6e5cf1e42bdd33f51693" title="Implements Blob_sender API per contract.">send_blob_max_size()</a>);</li>
<li><a class="el" href="classipc_1_1transport_1_1Native__socket__stream.html#ac7659af6812efca67c410af286f0cb34" title="Implements Native_handle_receiver API per contract.">receive_meta_blob_max_size()</a> (or <a class="el" href="classipc_1_1transport_1_1Native__socket__stream.html#adb667160fd0ab3951d93d219d7bdc3be" title="Implements Blob_receiver API per contract.">receive_blob_max_size()</a>);</li>
<li>default ctor;</li>
<li>move ctor, move assignment.</li>
</ul>
<p >There is also:</p><ul>
<li><a class="el" href="classipc_1_1transport_1_1Native__socket__stream.html#af63671c0e30d39d3460331c4dd3742b2" title="OS-reported process credential (PID, etc.) info about the other connected peer&#39;s process,...">remote_peer_process_credentials()</a> which is specific to <a class="el" href="classipc_1_1transport_1_1Native__socket__stream.html" title="Implements both Native_handle_sender and Native_handle_receiver concepts by using a stream-oriented U...">Native_socket_stream</a> and not those concepts.</li>
</ul>
<p >That above list (in?)conspicuously omits the initialization API. So how does one create this connection and hence the two required <code><a class="el" href="classipc_1_1transport_1_1Native__socket__stream.html" title="Implements both Native_handle_sender and Native_handle_receiver concepts by using a stream-oriented U...">Native_socket_stream</a></code>s that are connected to each other (each in PEER state)?</p>
<p >A <a class="el" href="classipc_1_1transport_1_1Native__socket__stream.html" title="Implements both Native_handle_sender and Native_handle_receiver concepts by using a stream-oriented U...">Native_socket_stream</a> object is always in one 3 states:</p><ul>
<li>PEER. Upon entering this state, the peer is connected (is an actual peer). At this stage it exactly implements the concepts <a class="el" href="classipc_1_1transport_1_1Native__handle__sender.html" title="A documentation-only concept defining the behavior of an object capable of reliably/in-order sending ...">Native_handle_sender</a>, <a class="el" href="classipc_1_1transport_1_1Native__handle__receiver.html" title="A documentation-only concept defining the behavior of an object capable of reliably/in-order receivin...">Native_handle_receiver</a>, <a class="el" href="classipc_1_1transport_1_1Blob__sender.html" title="A documentation-only concept defining the behavior of an object capable of reliably/in-order sending ...">Blob_sender</a>, <a class="el" href="classipc_1_1transport_1_1Blob__receiver.html" title="A documentation-only concept defining the behavior of an object capable of reliably/in-order receivin...">Blob_receiver</a>. If the pipe is hosed (via an error or graceful-close), it remains in this PEER state (but cannot do anything useful anymore). It is not possible to exit PEER state.<ul>
<li>The only added behavior on top of the implemented concepts is <a class="el" href="classipc_1_1transport_1_1Native__socket__stream.html#af63671c0e30d39d3460331c4dd3742b2" title="OS-reported process credential (PID, etc.) info about the other connected peer&#39;s process,...">remote_peer_process_credentials()</a> (which is not a concept API but logically only makes sense when already connected, i.e., in PEER state).</li>
</ul>
</li>
<li>NULL. In this state, the object is doing nothing; neither connected nor connecting.</li>
<li>CONNECTING. In this state the object is trying to enter PEER state.</li>
</ul>
<p >Therefore, to be useful, one must somehow get to PEER state in which it implements the aforementioned concepts. How to do this? Answer: There are 2* ways:</p><ul>
<li>Use <a class="el" href="classipc_1_1transport_1_1Native__socket__stream__acceptor.html" title="A server object that binds to a Shared_name and listens for incoming Native_socket_stream::*_connect(...">Native_socket_stream_acceptor</a> on the side you've designated as the server for that connection or set of connections. This allows to wait for a connection and eventually, on success, moves the target <a class="el" href="classipc_1_1transport_1_1Native__socket__stream.html" title="Implements both Native_handle_sender and Native_handle_receiver concepts by using a stream-oriented U...">Native_socket_stream</a> passed to <a class="el" href="classipc_1_1transport_1_1Native__socket__stream__acceptor.html#a81426af495ba5a9c832d1ba35fe23ba5" title="Asynchronously awaits for a peer connection to be established and calls on_done_func(),...">Native_socket_stream_acceptor::async_accept()</a> to PEER state.<ul>
<li>On the other side, use a <a class="el" href="classipc_1_1transport_1_1Native__socket__stream.html" title="Implements both Native_handle_sender and Native_handle_receiver concepts by using a stream-oriented U...">Native_socket_stream</a> in NULL state and invoke <a class="el" href="classipc_1_1transport_1_1Native__socket__stream.html#a3614a9677c1a203090b97ac935093390" title="To be invoked in NULL state only, it asynchronously attempts to connect to an opposing Native_socket_...">async_connect()</a> which will move to CONNECTING state immediately and, eventually on success, to PEER state (mission accomplished). If the connect fails it will go back to NULL state.</li>
</ul>
</li>
<li>Use a mechanism, as of this writing <a class="el" href="classipc_1_1transport_1_1Channel.html" title="Peer to a bundle of 1-2 full-duplex pipe(s), one for transmitting unstructured binary blobs; the othe...">ipc::transport::Channel</a> at least, that uses the following technique:<ol type="1">
<li>A process-wide <a class="el" href="classipc_1_1transport_1_1Native__socket__stream.html" title="Implements both Native_handle_sender and Native_handle_receiver concepts by using a stream-oriented U...">Native_socket_stream</a> connection is established using via the client-server method in the above bullet point.</li>
<li>A socket-pair-generating OS call generates 2 pre-connected native stream-oriented Unix domain socket handles.<ol type="a">
<li>E.g., use boost.asio <code>asio_local_stream_socket::connect_pair()</code>.</li>
</ol>
</li>
<li>1 of the 2 handles is passed to the other side using the process-wide connection from step 1.</li>
<li>On each side, construct <a class="el" href="classipc_1_1transport_1_1Native__socket__stream.html#aae823547a7ad0b9fdc691eb40c94d7da" title="Default ctor (object is in NULL state).">Native_socket_stream()</a> using the <a class="el" href="namespaceipc_1_1transport.html#a7ee4551983d9df16ec16a3139bac50e8" title="Convenience alias for the commonly used type util::Native_handle.">Native_handle</a>-taking ctor thus entering PEER state directly at construction (on each side).</li>
</ol>
</li>
</ul>
<p >Way 2 is better, because it requires no <code>Shared_name</code>s whatsoever, hence there are no thorny naming issues. The drawback is it requires an already-existing <a class="el" href="classipc_1_1transport_1_1Native__socket__stream.html" title="Implements both Native_handle_sender and Native_handle_receiver concepts by using a stream-oriented U...">Native_socket_stream</a> in order to transmit the handle! Chicken/egg! Therefore, the informal recommendation is &ndash; if practical &ndash; use way 1 once (create chicken); then subsequently use way 2 as needed to easily create further connections.</p>
<p ><a class="el" href="classipc_1_1transport_1_1Native__socket__stream.html" title="Implements both Native_handle_sender and Native_handle_receiver concepts by using a stream-oriented U...">Native_socket_stream</a> is move-constructible and move-assignable (but not copyable). This is, at any rate, necessary to work with the boost.asio-style <a class="el" href="classipc_1_1transport_1_1Native__socket__stream__acceptor.html#a81426af495ba5a9c832d1ba35fe23ba5" title="Asynchronously awaits for a peer connection to be established and calls on_done_func(),...">Native_socket_stream_acceptor::async_accept()</a> API. A moved-from <a class="el" href="classipc_1_1transport_1_1Native__socket__stream.html" title="Implements both Native_handle_sender and Native_handle_receiver concepts by using a stream-oriented U...">Native_socket_stream</a> is as-if default-constructed; therefore it enters NULL state.</p>
<p >(*) There is, in fact, another way &ndash; one could call it way 2a. It is just like way 2; except that &ndash; upon obtaining a pre-connected <code>Native_handle</code> (one of a pair) &ndash; one first constructs a "`sync_io` core", namely a <a class="el" href="classipc_1_1transport_1_1sync__io_1_1Native__socket__stream.html" title="Implements both sync_io::Native_handle_sender and sync_io::Native_handle_receiver concepts by using a...">sync_io::Native_socket_stream</a> object, using the <em>exact</em> same signature (which takes a <code>Logger*</code>, a nickname, and the pre-connected <code>Native_handle</code>). Then, one constructs a <code>*this</code> by <code>move()</code>ing that guy into the <code><a class="el" href="namespaceipc_1_1transport_1_1sync__io.html" title="sync_io-pattern counterparts to async-I/O-pattern object types in parent namespace ipc::transport.">sync_io</a></code>-core-adopting ctor. The result is exactly the same. (Internally, whether one uses way 1 or way 2, <code>*this</code> will create a <a class="el" href="classipc_1_1transport_1_1sync__io_1_1Native__socket__stream.html" title="Implements both sync_io::Native_handle_sender and sync_io::Native_handle_receiver concepts by using a...">sync_io::Native_socket_stream</a> core itself. I tell you this, in case you are curious.)</p>
<h3>Thread safety</h3>
<p >We add no more thread safety guarantees than those mandated by the main concepts. To wit:</p><ul>
<li>Concurrent access to 2 separate <a class="el" href="classipc_1_1transport_1_1Native__socket__stream.html" title="Implements both Native_handle_sender and Native_handle_receiver concepts by using a stream-oriented U...">Native_socket_stream</a> objects is safe.</li>
<li>After construction, concurrent access to the main transmission API methods (or <a class="el" href="classipc_1_1transport_1_1Native__socket__stream.html#af63671c0e30d39d3460331c4dd3742b2" title="OS-reported process credential (PID, etc.) info about the other connected peer&#39;s process,...">remote_peer_process_credentials()</a>) and the dtor is not safe.</li>
</ul>
<p >In addition: It is not safe to invoke any of the following methods &ndash;</p><ul>
<li><a class="el" href="classipc_1_1transport_1_1Native__socket__stream.html#a127a462a4aaf6e5cf1e42bdd33f51693" title="Implements Blob_sender API per contract.">send_blob_max_size()</a>, <a class="el" href="classipc_1_1transport_1_1Native__socket__stream.html#a844b8245c9341da8006f979c6b005893" title="Implements Native_handle_sender API per contract.">send_meta_blob_max_size()</a>, <a class="el" href="classipc_1_1transport_1_1Native__socket__stream.html#adb667160fd0ab3951d93d219d7bdc3be" title="Implements Blob_receiver API per contract.">receive_blob_max_size()</a>, <a class="el" href="classipc_1_1transport_1_1Native__socket__stream.html#ac7659af6812efca67c410af286f0cb34" title="Implements Native_handle_receiver API per contract.">receive_meta_blob_max_size()</a>,</li>
<li><a class="el" href="classipc_1_1transport_1_1Native__socket__stream.html#af63671c0e30d39d3460331c4dd3742b2" title="OS-reported process credential (PID, etc.) info about the other connected peer&#39;s process,...">remote_peer_process_credentials()</a>,</li>
<li><a class="el" href="classipc_1_1transport_1_1Native__socket__stream.html#a555df6a81654160285ea35b545cfd23d" title="Implements Native_handle_sender API per contract.">send_native_handle()</a>, <a class="el" href="classipc_1_1transport_1_1Native__socket__stream.html#a415febd76ee222c81d59d2bcfa9c01bc" title="Implements Blob_sender API per contract.">send_blob()</a>, end_sending, <a class="el" href="classipc_1_1transport_1_1Native__socket__stream.html#ac3cd00ddd2e0502677630320708277a3" title="Implements Native_handle_sender, Blob_sender API per contract.">async_end_sending()</a>, <a class="el" href="classipc_1_1transport_1_1Native__socket__stream.html#aa5e699d5eead4220bf8b5604f629a970" title="Implements Native_handle_sender, Blob_sender API per contract.">auto_ping()</a>,</li>
<li><a class="el" href="classipc_1_1transport_1_1Native__socket__stream.html#a266b52821557f2a4fa8f81058290dee2" title="Implements Native_handle_receiver API per contract.">async_receive_native_handle()</a>, <a class="el" href="classipc_1_1transport_1_1Native__socket__stream.html#ac5572c8165e25f106f18d327c07d1c3f" title="Implements Blob_receiver API per contract.">async_receive_blob()</a>, <a class="el" href="classipc_1_1transport_1_1Native__socket__stream.html#a1b4ce3ddee39f21e752ec9114ac17bbd" title="Implements Native_handle_receiver, Blob_receiver API per contract.">idle_timer_run()</a></li>
</ul>
<p >...in the following state:</p><ul>
<li>You've called <code>async_connect(F)</code>; and also</li>
<li><code>F()</code> has not yet begun executing (you're not <em>in</em> or <em>past</em> <code>F()</code>).</li>
</ul>
<p >Or, more concisely: While CONNECTING, don't do other stuff. This should be common-sense, really (who wants to try sending/receiving/related, before actually knowingly being connected?), but the <code>*_max_size()</code> methods may "feel" safe. They are not. However feel free to use <a class="el" href="classipc_1_1transport_1_1sync__io_1_1Native__socket__stream.html#a00624e2fc3757012d13e3dc0feb26a21" title="The maximum length of a blob that can be sent by this protocol.">sync_io::Native_socket_stream::S_MAX_META_BLOB_LENGTH</a> instead.</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classipc_1_1transport_1_1Native__handle__sender.html" title="A documentation-only concept defining the behavior of an object capable of reliably/in-order sending ...">Native_handle_sender</a>: implemented concept. </dd>
<dd>
<a class="el" href="classipc_1_1transport_1_1Native__handle__receiver.html" title="A documentation-only concept defining the behavior of an object capable of reliably/in-order receivin...">Native_handle_receiver</a>: implemented concept. </dd>
<dd>
<a class="el" href="classipc_1_1transport_1_1Blob__sender.html" title="A documentation-only concept defining the behavior of an object capable of reliably/in-order sending ...">Blob_sender</a>: alternatively implemented concept. </dd>
<dd>
<a class="el" href="classipc_1_1transport_1_1Blob__receiver.html" title="A documentation-only concept defining the behavior of an object capable of reliably/in-order receivin...">Blob_receiver</a>: alternatively implemented concept. </dd></dl>
</div><h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="aae823547a7ad0b9fdc691eb40c94d7da" name="aae823547a7ad0b9fdc691eb40c94d7da"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aae823547a7ad0b9fdc691eb40c94d7da">&#9670;&nbsp;</a></span>Native_socket_stream() <span class="overload">[1/5]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ipc::transport::Native_socket_stream::Native_socket_stream </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Default ctor (object is in NULL state). </p>
<p >Implements <a class="el" href="classipc_1_1transport_1_1Native__handle__sender.html" title="A documentation-only concept defining the behavior of an object capable of reliably/in-order sending ...">Native_handle_sender</a> <em>and</em> <a class="el" href="classipc_1_1transport_1_1Native__handle__receiver.html" title="A documentation-only concept defining the behavior of an object capable of reliably/in-order receivin...">Native_handle_receiver</a> APIs at the same time, per their concept contracts. (Also implements <a class="el" href="classipc_1_1transport_1_1Blob__sender.html" title="A documentation-only concept defining the behavior of an object capable of reliably/in-order sending ...">Blob_sender</a> <em>and</em> <a class="el" href="classipc_1_1transport_1_1Blob__receiver.html" title="A documentation-only concept defining the behavior of an object capable of reliably/in-order receivin...">Blob_receiver</a> APIs; they are identical.) All the notes for both concepts' default ctors apply.</p>
<p >This ctor is informally intended for the following uses:</p><ul>
<li>A moved-from <a class="el" href="classipc_1_1transport_1_1Native__socket__stream.html" title="Implements both Native_handle_sender and Native_handle_receiver concepts by using a stream-oriented U...">Native_socket_stream</a> (i.e., the <code>src</code> arg move-ctor and move-assignment operator) becomes as-if defaulted-constructed.</li>
<li>A target <a class="el" href="classipc_1_1transport_1_1Native__socket__stream.html" title="Implements both Native_handle_sender and Native_handle_receiver concepts by using a stream-oriented U...">Native_socket_stream</a> for <a class="el" href="classipc_1_1transport_1_1Native__socket__stream__acceptor.html#a81426af495ba5a9c832d1ba35fe23ba5" title="Asynchronously awaits for a peer connection to be established and calls on_done_func(),...">Native_socket_stream_acceptor::async_accept()</a> shall typically be default-cted; <a class="el" href="classipc_1_1transport_1_1Native__socket__stream__acceptor.html" title="A server object that binds to a Shared_name and listens for incoming Native_socket_stream::*_connect(...">Native_socket_stream_acceptor</a> shall asynchronously move-assign a logger-apointed, nicely-nicknamed into that target <code>*this</code>.</li>
</ul>
<p >Therefore it would be unusual (though allowed) to make direct calls such as <a class="el" href="classipc_1_1transport_1_1Native__socket__stream.html#a3614a9677c1a203090b97ac935093390" title="To be invoked in NULL state only, it asynchronously attempts to connect to an opposing Native_socket_...">async_connect()</a> and <a class="el" href="classipc_1_1transport_1_1Native__socket__stream.html#a415febd76ee222c81d59d2bcfa9c01bc" title="Implements Blob_sender API per contract.">send_blob()</a> on a default-cted <a class="el" href="classipc_1_1transport_1_1Native__socket__stream.html" title="Implements both Native_handle_sender and Native_handle_receiver concepts by using a stream-oriented U...">Native_socket_stream</a> without first moving a non-default-cted object into it.</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classipc_1_1transport_1_1Native__handle__sender.html#abafdb9a1294fe2160c61d48f1cd327ff" title="Default ctor: Creates a peer object in NULL (neither connected nor connecting) state.">Native_handle_sender::Native_handle_sender()</a>: implemented concept. </dd>
<dd>
<a class="el" href="classipc_1_1transport_1_1Native__handle__receiver.html#a748df49e5098e922c5974643d7a1bbde" title="Default ctor: Creates a peer object in NULL (neither connected nor connecting) state.">Native_handle_receiver::Native_handle_receiver()</a>: implemented concept. </dd>
<dd>
<a class="el" href="classipc_1_1transport_1_1Blob__sender.html#a072e2f3b5c18d1188c75501bc5620f6f" title="Default ctor: Creates a peer object in NULL (neither connected nor connecting) state.">Blob_sender::Blob_sender()</a>: implemented concept. </dd>
<dd>
<a class="el" href="classipc_1_1transport_1_1Blob__receiver.html#a048fe523a3b315e2930029d8a6d69164" title="Default ctor: Creates a peer object in NULL (neither connected nor connecting) state.">Blob_receiver::Blob_receiver()</a>: implemented concept. </dd></dl>

</div>
</div>
<a id="a99129e374920713cfd10314f0bd21d5e" name="a99129e374920713cfd10314f0bd21d5e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a99129e374920713cfd10314f0bd21d5e">&#9670;&nbsp;</a></span>Native_socket_stream() <span class="overload">[2/5]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">ipc::transport::Native_socket_stream::Native_socket_stream </td>
          <td>(</td>
          <td class="paramtype">flow::log::Logger *&#160;</td>
          <td class="paramname"><em>logger_ptr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceipc_1_1util.html#ae6ac47812a90d1287c61e0b7de7bc4f5">util::String_view</a>&#160;</td>
          <td class="paramname"><em>nickname_str</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">explicit</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Creates a <a class="el" href="classipc_1_1transport_1_1Native__socket__stream.html" title="Implements both Native_handle_sender and Native_handle_receiver concepts by using a stream-oriented U...">Native_socket_stream</a> in NULL (not connected, not connecting) state. </p>
<p >This ctor is informally intended for the following use:</p><ul>
<li>You create a <a class="el" href="classipc_1_1transport_1_1Native__socket__stream.html" title="Implements both Native_handle_sender and Native_handle_receiver concepts by using a stream-oriented U...">Native_socket_stream</a> that is logger-appointed and nicely-nicknamed; then you call <a class="el" href="classipc_1_1transport_1_1Native__socket__stream.html#a3614a9677c1a203090b97ac935093390" title="To be invoked in NULL state only, it asynchronously attempts to connect to an opposing Native_socket_...">async_connect()</a> on it in order to move it to CONNECTING and, hopefully, PEER states. It will retain the logger and nickname throughout.</li>
</ul>
<p >Alternatively:</p><ul>
<li>If you intend to get a <a class="el" href="classipc_1_1transport_1_1Native__socket__stream.html" title="Implements both Native_handle_sender and Native_handle_receiver concepts by using a stream-oriented U...">Native_socket_stream</a> from a pre-connected <a class="el" href="namespaceipc_1_1transport.html#a7ee4551983d9df16ec16a3139bac50e8" title="Convenience alias for the commonly used type util::Native_handle.">Native_handle</a>: Use that <a class="el" href="classipc_1_1transport_1_1Native__socket__stream.html" title="Implements both Native_handle_sender and Native_handle_receiver concepts by using a stream-oriented U...">Native_socket_stream</a> ctor.</li>
<li>If you intend to get a <a class="el" href="classipc_1_1transport_1_1Native__socket__stream.html" title="Implements both Native_handle_sender and Native_handle_receiver concepts by using a stream-oriented U...">Native_socket_stream</a> by accepting it server-style: Use the default <a class="el" href="classipc_1_1transport_1_1Native__socket__stream.html" title="Implements both Native_handle_sender and Native_handle_receiver concepts by using a stream-oriented U...">Native_socket_stream</a> ctor; pass that object to <a class="el" href="classipc_1_1transport_1_1Native__socket__stream__acceptor.html#a81426af495ba5a9c832d1ba35fe23ba5" title="Asynchronously awaits for a peer connection to be established and calls on_done_func(),...">Native_socket_stream_acceptor::async_accept()</a>.</li>
</ul>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">logger_ptr</td><td>Logger to use for subsequently logging. </td></tr>
    <tr><td class="paramname">nickname_str</td><td>Human-readable nickname of the new object, as of this writing for use in <code>operator&lt;&lt;(ostream)</code> and logging only. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a1b8f0515fb970631092b12b5862d2542" name="a1b8f0515fb970631092b12b5862d2542"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1b8f0515fb970631092b12b5862d2542">&#9670;&nbsp;</a></span>Native_socket_stream() <span class="overload">[3/5]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">ipc::transport::Native_socket_stream::Native_socket_stream </td>
          <td>(</td>
          <td class="paramtype">flow::log::Logger *&#160;</td>
          <td class="paramname"><em>logger_ptr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceipc_1_1util.html#ae6ac47812a90d1287c61e0b7de7bc4f5">util::String_view</a>&#160;</td>
          <td class="paramname"><em>nickname_str</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceipc_1_1transport.html#a7ee4551983d9df16ec16a3139bac50e8">Native_handle</a> &amp;&amp;&#160;</td>
          <td class="paramname"><em>native_peer_socket_moved</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">explicit</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Constructs the socket-and-meta-blob stream by taking over an already-connected native Unix domain socket handle. </p>
<p >The socket must be freshly connected without any traffic exchanged on the connection so far; otherwise behavior undefined.</p>
<h3>Performance</h3>
<p >The taking over of <code>native_peer_socket_moved</code> should be thought of as light-weight.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">logger_ptr</td><td>Logger to use for subsequently logging. </td></tr>
    <tr><td class="paramname">native_peer_socket_moved</td><td>The wrapped native handle shall be taken over by <code>*this</code>; and this wrapper object will be made <code>.null() == true</code>. In plainer English, the main point is, this is the native socket over which traffic will proceed. </td></tr>
    <tr><td class="paramname">nickname_str</td><td>Human-readable nickname of the new object, as of this writing for use in <code>operator&lt;&lt;(ostream)</code> and logging only. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a6e3cd290da856e2f486dd1536afdea2d" name="a6e3cd290da856e2f486dd1536afdea2d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6e3cd290da856e2f486dd1536afdea2d">&#9670;&nbsp;</a></span>Native_socket_stream() <span class="overload">[4/5]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">ipc::transport::Native_socket_stream::Native_socket_stream </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classipc_1_1transport_1_1Native__socket__stream.html#a850af22a95f27d8696b9b5bca15454b5">Sync_io_obj</a> &amp;&amp;&#160;</td>
          <td class="paramname"><em>sync_io_core_in_peer_state_moved</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">explicit</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Implements <a class="el" href="classipc_1_1transport_1_1Native__handle__sender.html" title="A documentation-only concept defining the behavior of an object capable of reliably/in-order sending ...">Native_handle_sender</a> <em>and</em> <a class="el" href="classipc_1_1transport_1_1Native__handle__receiver.html" title="A documentation-only concept defining the behavior of an object capable of reliably/in-order receivin...">Native_handle_receiver</a> APIs at the same time, per their concept contracts. </p>
<p >(Also implements <a class="el" href="classipc_1_1transport_1_1Blob__sender.html" title="A documentation-only concept defining the behavior of an object capable of reliably/in-order sending ...">Blob_sender</a> <em>and</em> <a class="el" href="classipc_1_1transport_1_1Blob__receiver.html" title="A documentation-only concept defining the behavior of an object capable of reliably/in-order receivin...">Blob_receiver</a> APIs; they are identical.)</p>
<h3>Performance</h3>
<p >The taking over of <code>sync_io_core_in_peer_state_moved</code> should be thought of as light-weight.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">sync_io_core_in_peer_state_moved</td><td>See above.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classipc_1_1transport_1_1Native__handle__sender.html#aa2354a74bc6cdff9389d0b7b642fbadd" title="Destroys this peer endpoint which will end the conceptual outgoing-direction pipe (in PEER state,...">Native_handle_sender::~Native_handle_sender()</a>: implemented concept. </dd>
<dd>
<a class="el" href="classipc_1_1transport_1_1Native__handle__receiver.html#ae6d2627aa6ee2216cddbc801a28fa268" title="Destroys this peer endpoint which will end the conceptual incoming-direction pipe (in PEER state,...">Native_handle_receiver::~Native_handle_receiver()</a>: implemented concept. </dd>
<dd>
<a class="el" href="classipc_1_1transport_1_1Blob__sender.html#aa66f12eb20f59154d51899b76dc6cdad" title="Destroys this peer endpoint which will end the conceptual outgoing-direction pipe (in PEER state,...">Blob_sender::~Blob_sender()</a>: alternatively implemented concept. </dd>
<dd>
<a class="el" href="classipc_1_1transport_1_1Blob__receiver.html#afd3fa15abea7c11f014163c21c45d120" title="Destroys this peer endpoint which will end the conceptual incoming-direction pipe (in PEER state,...">Blob_receiver::~Blob_receiver()</a>: alternatively implemented concept. </dd></dl>

</div>
</div>
<a id="a433d09587c6d854e59c12d4f483516fb" name="a433d09587c6d854e59c12d4f483516fb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a433d09587c6d854e59c12d4f483516fb">&#9670;&nbsp;</a></span>Native_socket_stream() <span class="overload">[5/5]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">ipc::transport::Native_socket_stream::Native_socket_stream </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classipc_1_1transport_1_1Native__socket__stream.html">Native_socket_stream</a> &amp;&amp;&#160;</td>
          <td class="paramname"><em>src</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">default</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Move-constructs from <code>src</code>; <code>src</code> becomes as-if default-cted (therefore in NULL state). </p>
<p >Implements <a class="el" href="classipc_1_1transport_1_1Native__handle__sender.html" title="A documentation-only concept defining the behavior of an object capable of reliably/in-order sending ...">Native_handle_sender</a> <em>and</em> <a class="el" href="classipc_1_1transport_1_1Native__handle__receiver.html" title="A documentation-only concept defining the behavior of an object capable of reliably/in-order receivin...">Native_handle_receiver</a> APIs at the same time, per their concept contracts. (Also implements <a class="el" href="classipc_1_1transport_1_1Blob__sender.html" title="A documentation-only concept defining the behavior of an object capable of reliably/in-order sending ...">Blob_sender</a> <em>and</em> <a class="el" href="classipc_1_1transport_1_1Blob__receiver.html" title="A documentation-only concept defining the behavior of an object capable of reliably/in-order receivin...">Blob_receiver</a> APIs; they are identical.)</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">src</td><td>See above.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classipc_1_1transport_1_1Native__handle__sender.html#abafdb9a1294fe2160c61d48f1cd327ff" title="Default ctor: Creates a peer object in NULL (neither connected nor connecting) state.">Native_handle_sender::Native_handle_sender()</a>: implemented concept. </dd>
<dd>
<a class="el" href="classipc_1_1transport_1_1Native__handle__receiver.html#a748df49e5098e922c5974643d7a1bbde" title="Default ctor: Creates a peer object in NULL (neither connected nor connecting) state.">Native_handle_receiver::Native_handle_receiver()</a>: implemented concept. </dd>
<dd>
<a class="el" href="classipc_1_1transport_1_1Blob__sender.html#a072e2f3b5c18d1188c75501bc5620f6f" title="Default ctor: Creates a peer object in NULL (neither connected nor connecting) state.">Blob_sender::Blob_sender()</a>: implemented concept. </dd>
<dd>
<a class="el" href="classipc_1_1transport_1_1Blob__receiver.html#a048fe523a3b315e2930029d8a6d69164" title="Default ctor: Creates a peer object in NULL (neither connected nor connecting) state.">Blob_receiver::Blob_receiver()</a>: implemented concept. </dd></dl>

</div>
</div>
<a id="a1ff9e6811c0d662a6a960602be5926e0" name="a1ff9e6811c0d662a6a960602be5926e0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1ff9e6811c0d662a6a960602be5926e0">&#9670;&nbsp;</a></span>~Native_socket_stream()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">ipc::transport::Native_socket_stream::~Native_socket_stream </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">default</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Implements <a class="el" href="classipc_1_1transport_1_1Native__handle__sender.html" title="A documentation-only concept defining the behavior of an object capable of reliably/in-order sending ...">Native_handle_sender</a> <em>and</em> <a class="el" href="classipc_1_1transport_1_1Native__handle__receiver.html" title="A documentation-only concept defining the behavior of an object capable of reliably/in-order receivin...">Native_handle_receiver</a> APIs at the same time, per their concept contracts. </p>
<p >(Also implements <a class="el" href="classipc_1_1transport_1_1Blob__sender.html" title="A documentation-only concept defining the behavior of an object capable of reliably/in-order sending ...">Blob_sender</a> <em>and</em> <a class="el" href="classipc_1_1transport_1_1Blob__receiver.html" title="A documentation-only concept defining the behavior of an object capable of reliably/in-order receivin...">Blob_receiver</a> APIs; they are identical.) All the notes for both concepts' destructors apply but as a reminder:</p>
<p >Destroys this peer endpoint which will end both-direction pipes (of those still open) and cancel any pending completion handlers by invoking them ASAP with <a class="el" href="namespaceipc_1_1transport_1_1error.html#adfef15ef4e76cc55d652fbd9c2797297afe29343445a7bf167cc186a44bd2c6ed" title="Async completion handler is being called prematurely, because underlying object is shutting down,...">error::Code::S_OBJECT_SHUTDOWN_ABORTED_COMPLETION_HANDLER</a>. As of this writing these are the completion handlers that would therefore be called:</p><ul>
<li>Any handler passed to <a class="el" href="classipc_1_1transport_1_1Native__socket__stream.html#a266b52821557f2a4fa8f81058290dee2" title="Implements Native_handle_receiver API per contract.">async_receive_native_handle()</a> that has not yet been invoked. There can be 0 or more of these.</li>
<li>The handler passed to <a class="el" href="classipc_1_1transport_1_1Native__socket__stream.html#ac3cd00ddd2e0502677630320708277a3" title="Implements Native_handle_sender, Blob_sender API per contract.">async_end_sending()</a>. Since it is not valid to call <a class="el" href="classipc_1_1transport_1_1Native__socket__stream.html#ac3cd00ddd2e0502677630320708277a3" title="Implements Native_handle_sender, Blob_sender API per contract.">async_end_sending()</a> more than once, there is at most 1 of these.</li>
<li>[Not in the implemented concepts] Handler passed to <a class="el" href="classipc_1_1transport_1_1Native__socket__stream.html#a3614a9677c1a203090b97ac935093390" title="To be invoked in NULL state only, it asynchronously attempts to connect to an opposing Native_socket_...">async_connect()</a>.</li>
</ul>
<p >Note that &ndash; ignoring any intermediate move-assignments/moves-from &ndash; <a class="el" href="classipc_1_1transport_1_1Native__socket__stream.html#a3614a9677c1a203090b97ac935093390" title="To be invoked in NULL state only, it asynchronously attempts to connect to an opposing Native_socket_...">async_connect()</a> is rejected immediately outside of NULL state; and <code>async_receive_*()</code> and <code>*end_sending()</code> are rejected immediately outside of PEER state. Therefore, it is only possible the destructor will cause the invocation of <a class="el" href="classipc_1_1transport_1_1Native__socket__stream.html#a3614a9677c1a203090b97ac935093390" title="To be invoked in NULL state only, it asynchronously attempts to connect to an opposing Native_socket_...">async_connect()</a> handler &ndash; and only 1 such handler &ndash; <em>or</em> of the other methods' handlers; but not both.</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classipc_1_1transport_1_1Native__handle__sender.html#aa2354a74bc6cdff9389d0b7b642fbadd" title="Destroys this peer endpoint which will end the conceptual outgoing-direction pipe (in PEER state,...">Native_handle_sender::~Native_handle_sender()</a>: implemented concept. </dd>
<dd>
<a class="el" href="classipc_1_1transport_1_1Native__handle__receiver.html#ae6d2627aa6ee2216cddbc801a28fa268" title="Destroys this peer endpoint which will end the conceptual incoming-direction pipe (in PEER state,...">Native_handle_receiver::~Native_handle_receiver()</a>: implemented concept. </dd>
<dd>
<a class="el" href="classipc_1_1transport_1_1Blob__sender.html#aa66f12eb20f59154d51899b76dc6cdad" title="Destroys this peer endpoint which will end the conceptual outgoing-direction pipe (in PEER state,...">Blob_sender::~Blob_sender()</a>: alternatively implemented concept. </dd>
<dd>
<a class="el" href="classipc_1_1transport_1_1Blob__receiver.html#afd3fa15abea7c11f014163c21c45d120" title="Destroys this peer endpoint which will end the conceptual incoming-direction pipe (in PEER state,...">Blob_receiver::~Blob_receiver()</a>: alternatively implemented concept. </dd></dl>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="a3614a9677c1a203090b97ac935093390" name="a3614a9677c1a203090b97ac935093390"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3614a9677c1a203090b97ac935093390">&#9670;&nbsp;</a></span>async_connect()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Task_err &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool ipc::transport::Native_socket_stream::async_connect </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespaceipc_1_1transport.html#a33de1c256addb3964b839dc2dd407d24">Shared_name</a> &amp;&#160;</td>
          <td class="paramname"><em>absolute_name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Task_err &amp;&amp;&#160;</td>
          <td class="paramname"><em>on_done_func</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>To be invoked in NULL state only, it asynchronously attempts to connect to an opposing <a class="el" href="classipc_1_1transport_1_1Native__socket__stream__acceptor.html" title="A server object that binds to a Shared_name and listens for incoming Native_socket_stream::*_connect(...">Native_socket_stream_acceptor</a> or <a class="el" href="classipc_1_1transport_1_1sync__io_1_1Native__socket__stream__acceptor.html" title="sync_io-pattern counterpart to async-I/O-pattern transport::Native_socket_stream_acceptor.">sync_io::Native_socket_stream_acceptor</a> listening at the given absolute Shared_name; and on success invokes the given completion handler with a falsy value indicating <code>*this</code> has entered PEER state. </p>
<p >On failure invokes completion handler with a truthy values indicating <code>*this</code> has returned to NULL state. In the meantime <code>*this</code> is in CONNECTING state.</p>
<p >If invoked outside of NULL state this returns <code>false</code> and otherwise does nothing.</p>
<p >In particular: Do not invoke <a class="el" href="classipc_1_1transport_1_1Native__socket__stream.html#a3614a9677c1a203090b97ac935093390" title="To be invoked in NULL state only, it asynchronously attempts to connect to an opposing Native_socket_...">async_connect()</a> while one is already outstanding: <code>*this</code> must be in NULL state, not CONNECTING. Also note that <code>*this</code> (modulo moves) that has entered PEER state can never change state subsequently (even on transmission error); once a PEER, always a PEER.</p>
<p ><a class="el" href="namespaceipc.html#aa3192e586cc45d3e7c22463bf2760f89" title="Short-hand for flow::Error_code which is very common.">Error_code</a> generated and passed to <code>on_done_func()</code>: system codes most likely from <code>boost::asio::error</code> or <code>boost::system::errc</code> (but never would-block).</p>
<dl class="section return"><dt>Returns</dt><dd><code>false</code> if and only if invoked outside of PEER state.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">absolute_name</td><td>Absolute name at which the <code><a class="el" href="classipc_1_1transport_1_1Native__socket__stream__acceptor.html" title="A server object that binds to a Shared_name and listens for incoming Native_socket_stream::*_connect(...">Native_socket_stream_acceptor</a></code> is expected to be listening. </td></tr>
    <tr><td class="paramname">on_done_func</td><td><code>on_done_func(Error_code err_code)</code> is invoked from some unspecified thread, not the caller thread, indicating entrance from CONNECTING state to either NULL or PEER state. If interrupted by destructor the operation-aborted code is passed instead (see <a class="el" href="classipc_1_1transport_1_1Native__socket__stream.html#a1ff9e6811c0d662a6a960602be5926e0" title="Implements Native_handle_sender and Native_handle_receiver APIs at the same time, per their concept c...">~Native_socket_stream()</a> doc header). </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ac3cd00ddd2e0502677630320708277a3" name="ac3cd00ddd2e0502677630320708277a3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac3cd00ddd2e0502677630320708277a3">&#9670;&nbsp;</a></span>async_end_sending()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Task_err &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool ipc::transport::Native_socket_stream::async_end_sending </td>
          <td>(</td>
          <td class="paramtype">Task_err &amp;&amp;&#160;</td>
          <td class="paramname"><em>on_done_func</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Implements <a class="el" href="classipc_1_1transport_1_1Native__handle__sender.html" title="A documentation-only concept defining the behavior of an object capable of reliably/in-order sending ...">Native_handle_sender</a>, <a class="el" href="classipc_1_1transport_1_1Blob__sender.html" title="A documentation-only concept defining the behavior of an object capable of reliably/in-order sending ...">Blob_sender</a> API per contract. </p>
<p >Reminder: You may call this directly from within a completion handler you supplied to an earlier <a class="el" href="classipc_1_1transport_1_1Native__socket__stream.html#a266b52821557f2a4fa8f81058290dee2" title="Implements Native_handle_receiver API per contract.">async_receive_native_handle()</a> or <a class="el" href="classipc_1_1transport_1_1Native__socket__stream.html#ac5572c8165e25f106f18d327c07d1c3f" title="Implements Blob_receiver API per contract.">async_receive_blob()</a>. Reminder: It's not thread-safe to call this concurrently with other transmission methods or destructor on the same <code>*this</code>.</p>
<p ><a class="el" href="namespaceipc.html#aa3192e586cc45d3e7c22463bf2760f89" title="Short-hand for flow::Error_code which is very common.">Error_code</a> generated and passed to <code>on_done_func()</code>: <a class="el" href="namespaceipc_1_1transport_1_1error.html#adfef15ef4e76cc55d652fbd9c2797297adc5d7b9dbaa8c76c6835e3c9a7942410" title="Unable to send outgoing traffic: an earlier-reported, or at least logged, system error had hosed the ...">error::Code::S_LOW_LVL_TRANSPORT_HOSED_CANNOT_SEND</a> (same meaning as for <a class="el" href="classipc_1_1transport_1_1Native__socket__stream.html#a555df6a81654160285ea35b545cfd23d" title="Implements Native_handle_sender API per contract.">send_native_handle()</a>/send_blob()), <code>boost::asio::error::eof</code> (ditto), other system codes most likely from <code>boost::asio::error</code> or <code>boost::system::errc</code> (ditto), <a class="el" href="namespaceipc_1_1transport_1_1error.html#adfef15ef4e76cc55d652fbd9c2797297afe29343445a7bf167cc186a44bd2c6ed" title="Async completion handler is being called prematurely, because underlying object is shutting down,...">error::Code::S_OBJECT_SHUTDOWN_ABORTED_COMPLETION_HANDLER</a> (destructor called, canceling all pending ops; spiritually identical to <code>boost::asio::error::operation_aborted</code>),</p>
<p >Reminder: In rare circumstances, an error emitted there may represent something detected during handling of a preceding <a class="el" href="classipc_1_1transport_1_1Native__socket__stream.html#a555df6a81654160285ea35b545cfd23d" title="Implements Native_handle_sender API per contract.">send_native_handle()</a> or <a class="el" href="classipc_1_1transport_1_1Native__socket__stream.html#a415febd76ee222c81d59d2bcfa9c01bc" title="Implements Blob_sender API per contract.">send_blob()</a> call but after it returned.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Task_err</td><td>See above. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">on_done_func</td><td>See above. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>See above. Reminder: If and only if it returns <code>false</code>, we're not in PEER state, or <code>*end_sending()</code> has already been called; and <code>on_done_func()</code> will never be called, nor will an error be emitted.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classipc_1_1transport_1_1Native__handle__sender.html#a4c92fe4e43ddf819a2c767cc53cbe477" title="Equivalent to send_native_handle() but sends a graceful-close message instead of the usual payload; t...">Native_handle_sender::async_end_sending()</a>: implemented concept. </dd>
<dd>
<a class="el" href="classipc_1_1transport_1_1Blob__sender.html#a440ecfbfc9bda7d824c0acfa54b23ca9" title="Equivalent to send_blob() but sends a graceful-close message instead of the usual payload; the opposi...">Blob_sender::async_end_sending()</a>: alternatively implemented concept. </dd></dl>

</div>
</div>
<a id="ac5572c8165e25f106f18d327c07d1c3f" name="ac5572c8165e25f106f18d327c07d1c3f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac5572c8165e25f106f18d327c07d1c3f">&#9670;&nbsp;</a></span>async_receive_blob()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Task_err_sz &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool ipc::transport::Native_socket_stream::async_receive_blob </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespaceipc_1_1util.html#a6cb62ae434900f3a8915b33ec5d61a96">util::Blob_mutable</a> &amp;&#160;</td>
          <td class="paramname"><em>target_blob</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Task_err_sz &amp;&amp;&#160;</td>
          <td class="paramname"><em>on_done_func</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Implements <a class="el" href="classipc_1_1transport_1_1Blob__receiver.html" title="A documentation-only concept defining the behavior of an object capable of reliably/in-order receivin...">Blob_receiver</a> API per contract. </p>
<p >Reminder: You may call this directly from within a completion handler you supplied to an earlier <a class="el" href="classipc_1_1transport_1_1Native__socket__stream.html#ac5572c8165e25f106f18d327c07d1c3f" title="Implements Blob_receiver API per contract.">async_receive_blob()</a>. Reminder: It's not thread-safe to call this concurrently with other transmission methods or destructor on the same <code>*this</code>.</p>
<p ><a class="el" href="namespaceipc.html#aa3192e586cc45d3e7c22463bf2760f89" title="Short-hand for flow::Error_code which is very common.">Error_code</a> generated and passed to <code>on_done_func()</code>: see <a class="el" href="classipc_1_1transport_1_1Native__socket__stream.html#a266b52821557f2a4fa8f81058290dee2" title="Implements Native_handle_receiver API per contract.">async_receive_native_handle()</a>. In addition: <a class="el" href="namespaceipc_1_1transport_1_1error.html#adfef15ef4e76cc55d652fbd9c2797297ae3753569086cc66c6165480bd8d2f937" title="User protocol-code mismatch: local user expected blob only and no native handle; received at least th...">error::Code::S_BLOB_RECEIVER_GOT_NON_BLOB</a> (opposing peer seems to have used a <a class="el" href="classipc_1_1transport_1_1Native__socket__stream.html#a555df6a81654160285ea35b545cfd23d" title="Implements Native_handle_sender API per contract.">Native_socket_stream::send_native_handle()</a> call, which they shouldn't in the first place, and supplied a non-null <a class="el" href="namespaceipc_1_1transport.html#a7ee4551983d9df16ec16a3139bac50e8" title="Convenience alias for the commonly used type util::Native_handle.">Native_handle</a>, which this <a class="el" href="classipc_1_1transport_1_1Blob__receiver.html" title="A documentation-only concept defining the behavior of an object capable of reliably/in-order receivin...">Blob_receiver</a> cannot accept).</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Task_err_sz</td><td>See above. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">target_blob</td><td>See above. Reminder: The memory area described by this arg must be valid up to completion handler entry. </td></tr>
    <tr><td class="paramname">on_done_func</td><td>See above. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>See above.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classipc_1_1transport_1_1Blob__receiver.html#a8bc6642dbf4b5e3fdee9f3442f2bbe84" title="In PEER state: Asynchronously awaits one discrete message  as sent by the opposing peer via Blob_sen...">Blob_receiver::async_receive_blob()</a>: implemented concept. </dd></dl>

</div>
</div>
<a id="a266b52821557f2a4fa8f81058290dee2" name="a266b52821557f2a4fa8f81058290dee2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a266b52821557f2a4fa8f81058290dee2">&#9670;&nbsp;</a></span>async_receive_native_handle()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Task_err_sz &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool ipc::transport::Native_socket_stream::async_receive_native_handle </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespaceipc_1_1transport.html#a7ee4551983d9df16ec16a3139bac50e8">Native_handle</a> *&#160;</td>
          <td class="paramname"><em>target_hndl</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespaceipc_1_1util.html#a6cb62ae434900f3a8915b33ec5d61a96">util::Blob_mutable</a> &amp;&#160;</td>
          <td class="paramname"><em>target_meta_blob</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Task_err_sz &amp;&amp;&#160;</td>
          <td class="paramname"><em>on_done_func</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Implements <a class="el" href="classipc_1_1transport_1_1Native__handle__receiver.html" title="A documentation-only concept defining the behavior of an object capable of reliably/in-order receivin...">Native_handle_receiver</a> API per contract. </p>
<p >Reminder: You may call this directly from within a completion handler you supplied to an earlier <a class="el" href="classipc_1_1transport_1_1Native__socket__stream.html#a266b52821557f2a4fa8f81058290dee2" title="Implements Native_handle_receiver API per contract.">async_receive_native_handle()</a>. Reminder: It's not thread-safe to call this concurrently with other transmission methods or destructor on the same <code>*this</code>.</p>
<p ><a class="el" href="namespaceipc.html#aa3192e586cc45d3e7c22463bf2760f89" title="Short-hand for flow::Error_code which is very common.">Error_code</a> generated and passed to <code>on_done_func()</code>: <a class="el" href="namespaceipc_1_1transport_1_1error.html#adfef15ef4e76cc55d652fbd9c2797297afe29343445a7bf167cc186a44bd2c6ed" title="Async completion handler is being called prematurely, because underlying object is shutting down,...">error::Code::S_OBJECT_SHUTDOWN_ABORTED_COMPLETION_HANDLER</a> (destructor called, canceling all pending ops; spiritually identical to <code>boost::asio::error::operation_aborted</code>), <a class="el" href="namespaceipc_1_1transport_1_1error.html#adfef15ef4e76cc55d652fbd9c2797297adde24987f30a92b953297207ce935210" title="User protocol-code mismatch: local user-provided storage cannot fit entire message received from oppo...">error::Code::S_MESSAGE_SIZE_EXCEEDS_USER_STORAGE</a> (opposing peer has sent a message with a meta-blob exceeding <code>target_meta_blob.size()</code> in length; in particular one can give an empty buffer if no meta-blob expected), <a class="el" href="namespaceipc_1_1transport_1_1error.html#adfef15ef4e76cc55d652fbd9c2797297aad44f87d53255ba573d57086dfeab805" title="Will not receive message: either opposing user sent graceful-close via API.">error::Code::S_RECEIVES_FINISHED_CANNOT_RECEIVE</a> (peer gracefully closed pipe via <code>*end_sending()</code>), <a class="el" href="namespaceipc_1_1transport_1_1error.html#adfef15ef4e76cc55d652fbd9c2797297a1fba28e335d4189cbb25f382582efcc1" title="Unable to receive incoming traffic: an earlier-reported, or at least logged, system error had hosed t...">error::Code::S_LOW_LVL_TRANSPORT_HOSED_CANNOT_RECEIVE</a> (the outgoing-direction processing detected that the underlying transport is hosed; specific code was logged and can be obtained via <a class="el" href="classipc_1_1transport_1_1Native__socket__stream.html#a555df6a81654160285ea35b545cfd23d" title="Implements Native_handle_sender API per contract.">send_native_handle()</a>), <code>boost::asio::error::eof</code> (underlying transport hosed due to graceful closing by the other side), other system codes most likely from <code>boost::asio::error</code> or <code>boost::system::errc</code> (but never would-block), indicating the underlying transport is hosed for that specific reason, as detected during incoming-direction processing.</p>
<p ><a class="el" href="namespaceipc_1_1transport_1_1error.html#adfef15ef4e76cc55d652fbd9c2797297ac416e988563e44bf15fc6a81743eef53" title="User called an API with 1 or more arguments against the API spec.">error::Code::S_INVALID_ARGUMENT</a> shall never be emitted due to <code>target_meta_blob.size()</code> (or as of this writing for any other reason). See <a class="el" href="classipc_1_1transport_1_1Native__socket__stream.html#a859615800ba1e0546c8e5cb8a6796e41" title="Implements concept API; namely it is true: async_receive_native_handle() with smaller-than-receive_me...">S_META_BLOB_UNDERFLOW_ALLOWED</a>.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Task_err_sz</td><td>See above. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">target_hndl</td><td>See above. </td></tr>
    <tr><td class="paramname">target_meta_blob</td><td>See above. Reminder: The memory area described by this arg must be valid up to completion handler entry. </td></tr>
    <tr><td class="paramname">on_done_func</td><td>See above. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>See above.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classipc_1_1transport_1_1Native__handle__receiver.html#ae4ac1685f00467a6516f9f24f5d8a280" title="In PEER state: Asynchronously awaits one discrete message  as sent by the opposing peer via Native_h...">Native_handle_receiver::async_receive_native_handle()</a>: implemented concept. </dd></dl>

</div>
</div>
<a id="aa5e699d5eead4220bf8b5604f629a970" name="aa5e699d5eead4220bf8b5604f629a970"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa5e699d5eead4220bf8b5604f629a970">&#9670;&nbsp;</a></span>auto_ping()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool ipc::transport::Native_socket_stream::auto_ping </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespaceipc_1_1util.html#ac66141280c3b7295a86b65209f31cc58">util::Fine_duration</a>&#160;</td>
          <td class="paramname"><em>period</em> = <code>boost::chrono::seconds(2)</code></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Implements <a class="el" href="classipc_1_1transport_1_1Native__handle__sender.html" title="A documentation-only concept defining the behavior of an object capable of reliably/in-order sending ...">Native_handle_sender</a>, <a class="el" href="classipc_1_1transport_1_1Blob__sender.html" title="A documentation-only concept defining the behavior of an object capable of reliably/in-order sending ...">Blob_sender</a> API per contract. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">period</td><td>See above. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>See above.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classipc_1_1transport_1_1Native__handle__sender.html#a8a2f1282c18faec36aabf29c99b87054" title="In PEER state: Irreversibly enables periodic auto-pinging of opposing receiver with low-level message...">Native_handle_sender::auto_ping()</a>: implemented concept. </dd>
<dd>
<a class="el" href="classipc_1_1transport_1_1Blob__sender.html#ac41990a469e61a26ca9cefaf6a291a2e" title="In PEER state: Irreversibly enables periodic auto-pinging of opposing receiver with low-level message...">Blob_sender::auto_ping()</a>: alternatively implemented concept. </dd></dl>

</div>
</div>
<a id="ace134e4a6e4918212f256b60c3ed77e4" name="ace134e4a6e4918212f256b60c3ed77e4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ace134e4a6e4918212f256b60c3ed77e4">&#9670;&nbsp;</a></span>end_sending()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool ipc::transport::Native_socket_stream::end_sending </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Implements <a class="el" href="classipc_1_1transport_1_1Native__handle__sender.html" title="A documentation-only concept defining the behavior of an object capable of reliably/in-order sending ...">Native_handle_sender</a>, <a class="el" href="classipc_1_1transport_1_1Blob__sender.html" title="A documentation-only concept defining the behavior of an object capable of reliably/in-order sending ...">Blob_sender</a> API per contract. </p>
<p >Reminder: It is equivalent to <a class="el" href="classipc_1_1transport_1_1Native__socket__stream.html#ac3cd00ddd2e0502677630320708277a3" title="Implements Native_handle_sender, Blob_sender API per contract.">async_end_sending()</a> but with a no-op <code>on_done_func</code>.</p>
<dl class="section return"><dt>Returns</dt><dd>See <a class="el" href="classipc_1_1transport_1_1Native__socket__stream.html#ac3cd00ddd2e0502677630320708277a3" title="Implements Native_handle_sender, Blob_sender API per contract.">async_end_sending()</a>.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classipc_1_1transport_1_1Native__handle__sender.html#aa3c2953f7f8a48b8a0cbf49652fb6d41" title="Equivalent to async_end_sending(F) wherein F() does nothing.">Native_handle_sender::end_sending()</a>: implemented concept. </dd>
<dd>
<a class="el" href="classipc_1_1transport_1_1Blob__sender.html#a2a14c51a9d8b03008b567917589ab813" title="Equivalent to async_end_sending(F) wherein F() does nothing.">Blob_sender::end_sending()</a>: alternatively implemented concept. </dd></dl>

</div>
</div>
<a id="a1b4ce3ddee39f21e752ec9114ac17bbd" name="a1b4ce3ddee39f21e752ec9114ac17bbd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1b4ce3ddee39f21e752ec9114ac17bbd">&#9670;&nbsp;</a></span>idle_timer_run()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool ipc::transport::Native_socket_stream::idle_timer_run </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespaceipc_1_1util.html#ac66141280c3b7295a86b65209f31cc58">util::Fine_duration</a>&#160;</td>
          <td class="paramname"><em>timeout</em> = <code>boost::chrono::seconds(5)</code></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Implements <a class="el" href="classipc_1_1transport_1_1Native__handle__receiver.html" title="A documentation-only concept defining the behavior of an object capable of reliably/in-order receivin...">Native_handle_receiver</a>, <a class="el" href="classipc_1_1transport_1_1Blob__receiver.html" title="A documentation-only concept defining the behavior of an object capable of reliably/in-order receivin...">Blob_receiver</a> API per contract. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">timeout</td><td>See above. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>See above.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classipc_1_1transport_1_1Blob__receiver.html#a5be288e0479a91e352fdea6d54460b22" title="In PEER state: Irreversibly enables a conceptual idle timer whose potential side effect is,...">Blob_receiver::idle_timer_run()</a>: implemented concept. </dd>
<dd>
<a class="el" href="classipc_1_1transport_1_1Native__handle__receiver.html#a174ee15818a8bda361bdc40f094faac9" title="In PEER state: Irreversibly enables a conceptual idle timer whose potential side effect is,...">Native_handle_receiver::idle_timer_run()</a>: alternatively implemented concept. </dd></dl>

</div>
</div>
<a id="a25d9c0e12a03a3b68f7f266c23466f71" name="a25d9c0e12a03a3b68f7f266c23466f71"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a25d9c0e12a03a3b68f7f266c23466f71">&#9670;&nbsp;</a></span>nickname()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const std::string &amp; ipc::transport::Native_socket_stream::nickname </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns nickname, a brief string suitable for logging. </p>
<p >This is included in the output by the <code>ostream&lt;&lt;</code> operator as well. This method is thread-safe in that it always returns the same value.</p>
<dl class="section return"><dt>Returns</dt><dd>See above. </dd></dl>

</div>
</div>
<a id="afa23616d048eef3649bd20a2385af4c5" name="afa23616d048eef3649bd20a2385af4c5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afa23616d048eef3649bd20a2385af4c5">&#9670;&nbsp;</a></span>operator=()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classipc_1_1transport_1_1Native__socket__stream.html">Native_socket_stream</a> &amp; ipc::transport::Native_socket_stream::operator= </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classipc_1_1transport_1_1Native__socket__stream.html">Native_socket_stream</a> &amp;&amp;&#160;</td>
          <td class="paramname"><em>src</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">default</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Move-assigns from <code>src</code>; <code>*this</code> acts as if destructed; <code>src</code> becomes as-if default-cted (therefore in NULL state). </p>
<p >No-op if <code>&amp;src == this</code>. Implements <a class="el" href="classipc_1_1transport_1_1Native__handle__sender.html" title="A documentation-only concept defining the behavior of an object capable of reliably/in-order sending ...">Native_handle_sender</a> <em>and</em> <a class="el" href="classipc_1_1transport_1_1Native__handle__receiver.html" title="A documentation-only concept defining the behavior of an object capable of reliably/in-order receivin...">Native_handle_receiver</a> APIs at the same time, per their concept contracts. (Also implements <a class="el" href="classipc_1_1transport_1_1Blob__sender.html" title="A documentation-only concept defining the behavior of an object capable of reliably/in-order sending ...">Blob_sender</a> <em>and</em> <a class="el" href="classipc_1_1transport_1_1Blob__receiver.html" title="A documentation-only concept defining the behavior of an object capable of reliably/in-order receivin...">Blob_receiver</a> APIs; they are identical.)</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classipc_1_1transport_1_1Native__socket__stream.html#a1ff9e6811c0d662a6a960602be5926e0" title="Implements Native_handle_sender and Native_handle_receiver APIs at the same time, per their concept c...">~Native_socket_stream()</a>.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">src</td><td>See above. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>*this</code> (see concept API).</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classipc_1_1transport_1_1Native__handle__sender.html" title="A documentation-only concept defining the behavior of an object capable of reliably/in-order sending ...">Native_handle_sender</a> move assignment: implemented concept. </dd>
<dd>
<a class="el" href="classipc_1_1transport_1_1Native__handle__receiver.html" title="A documentation-only concept defining the behavior of an object capable of reliably/in-order receivin...">Native_handle_receiver</a> move assignment: implemented concept. </dd>
<dd>
<a class="el" href="classipc_1_1transport_1_1Blob__sender.html" title="A documentation-only concept defining the behavior of an object capable of reliably/in-order sending ...">Blob_sender</a> move assignment: implemented concept. </dd>
<dd>
<a class="el" href="classipc_1_1transport_1_1Blob__receiver.html" title="A documentation-only concept defining the behavior of an object capable of reliably/in-order receivin...">Blob_receiver</a> move assignment: implemented concept. </dd></dl>

</div>
</div>
<a id="adb667160fd0ab3951d93d219d7bdc3be" name="adb667160fd0ab3951d93d219d7bdc3be"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adb667160fd0ab3951d93d219d7bdc3be">&#9670;&nbsp;</a></span>receive_blob_max_size()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t ipc::transport::Native_socket_stream::receive_blob_max_size </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Implements <a class="el" href="classipc_1_1transport_1_1Blob__receiver.html" title="A documentation-only concept defining the behavior of an object capable of reliably/in-order receivin...">Blob_receiver</a> API per contract. </p>
<p >Note this value equals <a class="el" href="classipc_1_1transport_1_1Native__socket__stream.html#ac7659af6812efca67c410af286f0cb34" title="Implements Native_handle_receiver API per contract.">receive_meta_blob_max_size()</a> at any given time which is <em>not</em> a concept requirement.</p>
<dl class="section return"><dt>Returns</dt><dd>See above.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classipc_1_1transport_1_1Blob__receiver.html#a454ed6207aeba777f779260c142603df" title="In PEER state: Returns min target_blob.size() such that (1) async_receive_blob() shall not fail with ...">Blob_receiver::receive_blob_max_size()</a>: implemented concept. </dd></dl>

</div>
</div>
<a id="ac7659af6812efca67c410af286f0cb34" name="ac7659af6812efca67c410af286f0cb34"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac7659af6812efca67c410af286f0cb34">&#9670;&nbsp;</a></span>receive_meta_blob_max_size()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t ipc::transport::Native_socket_stream::receive_meta_blob_max_size </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Implements <a class="el" href="classipc_1_1transport_1_1Native__handle__receiver.html" title="A documentation-only concept defining the behavior of an object capable of reliably/in-order receivin...">Native_handle_receiver</a> API per contract. </p>
<p >Note this value equals <a class="el" href="classipc_1_1transport_1_1Native__socket__stream.html#adb667160fd0ab3951d93d219d7bdc3be" title="Implements Blob_receiver API per contract.">receive_blob_max_size()</a> at any given time which is <em>not</em> a concept requirement.</p>
<dl class="section return"><dt>Returns</dt><dd>See above.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classipc_1_1transport_1_1Native__handle__receiver.html#ae9dd851d38af7c3715a64d0b111ba721" title="In PEER state: Returns min target_meta_blob.size() such that (1) async_receive_native_handle() shall ...">Native_handle_receiver::receive_meta_blob_max_size()</a>: implemented concept. </dd></dl>

</div>
</div>
<a id="a559ef620bfc3f46220dc7c3522bed32d" name="a559ef620bfc3f46220dc7c3522bed32d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a559ef620bfc3f46220dc7c3522bed32d">&#9670;&nbsp;</a></span>release()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classipc_1_1transport_1_1Native__socket__stream.html#a850af22a95f27d8696b9b5bca15454b5">Native_socket_stream::Sync_io_obj</a> ipc::transport::Native_socket_stream::release </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>In PEER state only, with no prior send or receive ops, returns a <a class="el" href="classipc_1_1transport_1_1sync__io_1_1Native__socket__stream.html" title="Implements both sync_io::Native_handle_sender and sync_io::Native_handle_receiver concepts by using a...">sync_io::Native_socket_stream</a> core (as-if just constructed) operating on <code>*this</code> underlying low-level transport <code>Native_handle</code>; while <code>*this</code> becomes as-if default-cted. </p>
<p >This can be useful if one desires a <code><a class="el" href="namespaceipc_1_1transport_1_1sync__io.html" title="sync_io-pattern counterparts to async-I/O-pattern object types in parent namespace ipc::transport.">sync_io</a></code> core &ndash; e.g., to bundle into a <a class="el" href="classipc_1_1transport_1_1Channel.html" title="Peer to a bundle of 1-2 full-duplex pipe(s), one for transmitting unstructured binary blobs; the othe...">Channel</a> to then feed to a <a class="el" href="classipc_1_1transport_1_1struc_1_1Channel.html" title="Owning and wrapping a pre-connected transport::Channel peer (an endpoint of an established channel ov...">struc::Channel</a> ctor &ndash; after a successful async-I/O-style <a class="el" href="classipc_1_1transport_1_1Native__socket__stream.html#a3614a9677c1a203090b97ac935093390" title="To be invoked in NULL state only, it asynchronously attempts to connect to an opposing Native_socket_...">async_connect()</a> advanced <code>*this</code> from NULL to CONNECTING to PEER state.</p>
<p >In a sense it's the reverse of <code>*this</code> <code><a class="el" href="namespaceipc_1_1transport_1_1sync__io.html" title="sync_io-pattern counterparts to async-I/O-pattern object types in parent namespace ipc::transport.">sync_io</a></code>-core-adopting ctor.</p>
<p >Behavior is undefined if <code>*this</code> is not in PEER state, or if it is, but you've invoked <code>async_receive_*()</code>, <code>send_*()</code>, <code>*end_sending()</code>, <a class="el" href="classipc_1_1transport_1_1Native__socket__stream.html#aa5e699d5eead4220bf8b5604f629a970" title="Implements Native_handle_sender, Blob_sender API per contract.">auto_ping()</a>, or <a class="el" href="classipc_1_1transport_1_1Native__socket__stream.html#a1b4ce3ddee39f21e752ec9114ac17bbd" title="Implements Native_handle_receiver, Blob_receiver API per contract.">idle_timer_run()</a> in the past. Please be careful.</p>
<p >Corner case (unlikely but possible): If, upon entry to PEER state, <code>*this</code> failed in attempting to immediately send internal protocol-negotiation data, then the returned object shall be in NULL state, not PEER state. As of this writing one can check for this via <code>returned_guy.send_blob_max_size() == 0</code>.</p>
<dl class="section return"><dt>Returns</dt><dd>See above. </dd></dl>

</div>
</div>
<a id="af63671c0e30d39d3460331c4dd3742b2" name="af63671c0e30d39d3460331c4dd3742b2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af63671c0e30d39d3460331c4dd3742b2">&#9670;&nbsp;</a></span>remote_peer_process_credentials()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classipc_1_1util_1_1Process__credentials.html">util::Process_credentials</a> ipc::transport::Native_socket_stream::remote_peer_process_credentials </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespaceipc.html#aa3192e586cc45d3e7c22463bf2760f89">Error_code</a> *&#160;</td>
          <td class="paramname"><em>err_code</em> = <code>0</code></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>OS-reported process credential (PID, etc.) info about the <em>other</em> connected peer's process, at the time that the OS first established (via local-socket-connect or local-socket-connected-pair-generate call) that opposing peer socket. </p>
<p >The value returned, assuming a non-error-emitting execution, shall always be the same for a given <code>*this</code>.</p>
<p >Informally: To avoid (though, formally, not guarantee) <a class="el" href="namespaceipc_1_1transport_1_1error.html#adfef15ef4e76cc55d652fbd9c2797297acb14cace6f75d915cd800113c37721e7" title="Unable to access low-level details: an earlier-reported system error had hosed the underlying transpo...">error::Code::S_LOW_LVL_TRANSPORT_HOSED</a>, it is best to call this immediately upon entry of <code>*this</code> to PEER state and/or before invoking any other APIs.</p>
<p >If invoked outside of PEER state returns <code>Process_credentials()</code> immediately and otherwise does nothing.</p>
<dl class="section return"><dt>Returns</dt><dd>See above; or <code>Peer_credentials()</code> if invoked outside of PEER state or in case of error. The 2 eventualities can be distinguished by checking <code>*err_code</code> truthiness. Better yet only call <a class="el" href="classipc_1_1transport_1_1Native__socket__stream.html#af63671c0e30d39d3460331c4dd3742b2" title="OS-reported process credential (PID, etc.) info about the other connected peer&#39;s process,...">remote_peer_process_credentials()</a> in PEER state, as it is otherwise conceptually meaningless.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">err_code</td><td>See <code>flow::Error_code</code> docs for error reporting semantics. <a class="el" href="namespaceipc.html#aa3192e586cc45d3e7c22463bf2760f89" title="Short-hand for flow::Error_code which is very common.">Error_code</a> generated: <a class="el" href="namespaceipc_1_1transport_1_1error.html#adfef15ef4e76cc55d652fbd9c2797297acb14cace6f75d915cd800113c37721e7" title="Unable to access low-level details: an earlier-reported system error had hosed the underlying transpo...">error::Code::S_LOW_LVL_TRANSPORT_HOSED</a> (the incoming/outgoing-direction processing detected that the underlying transport is hosed; specific code was logged and can be obtained via <a class="el" href="classipc_1_1transport_1_1Native__socket__stream.html#a266b52821557f2a4fa8f81058290dee2" title="Implements Native_handle_receiver API per contract.">async_receive_native_handle()</a> or similar), system codes (albeit unlikely). </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a415febd76ee222c81d59d2bcfa9c01bc" name="a415febd76ee222c81d59d2bcfa9c01bc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a415febd76ee222c81d59d2bcfa9c01bc">&#9670;&nbsp;</a></span>send_blob()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool ipc::transport::Native_socket_stream::send_blob </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespaceipc_1_1util.html#ae0be7edba7e30ffa3f8b742af621f2ab">util::Blob_const</a> &amp;&#160;</td>
          <td class="paramname"><em>blob</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceipc.html#aa3192e586cc45d3e7c22463bf2760f89">Error_code</a> *&#160;</td>
          <td class="paramname"><em>err_code</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Implements <a class="el" href="classipc_1_1transport_1_1Blob__sender.html" title="A documentation-only concept defining the behavior of an object capable of reliably/in-order sending ...">Blob_sender</a> API per contract. </p>
<p >Reminder: You may call this directly from within a completion handler you supplied to an earlier <a class="el" href="classipc_1_1transport_1_1Native__socket__stream.html#ac5572c8165e25f106f18d327c07d1c3f" title="Implements Blob_receiver API per contract.">async_receive_blob()</a>. Reminder: It's not thread-safe to call this concurrently with other transmission methods or destructor on the same <code>*this</code>.</p>
<p >Reminder: <code>blob.size() == 0</code> results in undefined behavior (assertion may trip).</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">blob</td><td>See above. Reminder: The memory area described by this arg need only be valid until this method returns. Perf reminder: That area will not be copied except for very rare circumstances. </td></tr>
    <tr><td class="paramname">err_code</td><td>See above. Reminder: In rare circumstances, an error emitted here may represent something detected during handling of a <em>preceding</em> <a class="el" href="classipc_1_1transport_1_1Native__socket__stream.html#a415febd76ee222c81d59d2bcfa9c01bc" title="Implements Blob_sender API per contract.">send_blob()</a> call but after it returned. <a class="el" href="namespaceipc.html#aa3192e586cc45d3e7c22463bf2760f89" title="Short-hand for flow::Error_code which is very common.">Error_code</a> generated: see <a class="el" href="classipc_1_1transport_1_1Native__socket__stream.html#a555df6a81654160285ea35b545cfd23d" title="Implements Native_handle_sender API per contract.">send_native_handle()</a>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>See above.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classipc_1_1transport_1_1Blob__sender.html#a776b55ae93e65592b90c3943ca99e948" title="In PEER state: Synchronously, non-blockingly sends one discrete message, reliably and in-order,...">Blob_sender::send_blob()</a>: implemented concept. </dd></dl>

</div>
</div>
<a id="a127a462a4aaf6e5cf1e42bdd33f51693" name="a127a462a4aaf6e5cf1e42bdd33f51693"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a127a462a4aaf6e5cf1e42bdd33f51693">&#9670;&nbsp;</a></span>send_blob_max_size()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t ipc::transport::Native_socket_stream::send_blob_max_size </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Implements <a class="el" href="classipc_1_1transport_1_1Blob__sender.html" title="A documentation-only concept defining the behavior of an object capable of reliably/in-order sending ...">Blob_sender</a> API per contract. </p>
<p >Note this value equals <a class="el" href="classipc_1_1transport_1_1Native__socket__stream.html#a844b8245c9341da8006f979c6b005893" title="Implements Native_handle_sender API per contract.">send_meta_blob_max_size()</a> at any given time which is <em>not</em> a concept requirement. Its PEER-state constant value can also be accessed as non-concept-mandated Native_socket_stream::S_MAX_META_BLOB_LENGTH.</p>
<dl class="section return"><dt>Returns</dt><dd>See above.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classipc_1_1transport_1_1Blob__sender.html#af5d889f8a209353b3d69f70b44a2095c" title="In PEER state: Returns max blob.size() such that send_blob() shall not fail due to too-long payload w...">Blob_sender::send_blob_max_size()</a>: implemented concept. </dd></dl>

</div>
</div>
<a id="a844b8245c9341da8006f979c6b005893" name="a844b8245c9341da8006f979c6b005893"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a844b8245c9341da8006f979c6b005893">&#9670;&nbsp;</a></span>send_meta_blob_max_size()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t ipc::transport::Native_socket_stream::send_meta_blob_max_size </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Implements <a class="el" href="classipc_1_1transport_1_1Native__handle__sender.html" title="A documentation-only concept defining the behavior of an object capable of reliably/in-order sending ...">Native_handle_sender</a> API per contract. </p>
<p >Note this value equals <a class="el" href="classipc_1_1transport_1_1Native__socket__stream.html#a127a462a4aaf6e5cf1e42bdd33f51693" title="Implements Blob_sender API per contract.">send_blob_max_size()</a> at any given time which is <em>not</em> a concept requirement. Its PEER-state constant value can also be accessed as non-concept-mandated Native_socket_stream::S_MAX_META_BLOB_LENGTH.</p>
<dl class="section return"><dt>Returns</dt><dd>See above.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classipc_1_1transport_1_1Native__handle__sender.html#a74452bf96477a7b971e187c67703e8d5" title="In PEER state: Returns max meta_blob.size() such that send_native_handle() shall not fail due to too-...">Native_handle_sender::send_meta_blob_max_size()</a>: implemented concept. </dd></dl>

</div>
</div>
<a id="a555df6a81654160285ea35b545cfd23d" name="a555df6a81654160285ea35b545cfd23d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a555df6a81654160285ea35b545cfd23d">&#9670;&nbsp;</a></span>send_native_handle()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool ipc::transport::Native_socket_stream::send_native_handle </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespaceipc_1_1transport.html#a7ee4551983d9df16ec16a3139bac50e8">Native_handle</a>&#160;</td>
          <td class="paramname"><em>hndl_or_null</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespaceipc_1_1util.html#ae0be7edba7e30ffa3f8b742af621f2ab">util::Blob_const</a> &amp;&#160;</td>
          <td class="paramname"><em>meta_blob</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceipc.html#aa3192e586cc45d3e7c22463bf2760f89">Error_code</a> *&#160;</td>
          <td class="paramname"><em>err_code</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Implements <a class="el" href="classipc_1_1transport_1_1Native__handle__sender.html" title="A documentation-only concept defining the behavior of an object capable of reliably/in-order sending ...">Native_handle_sender</a> API per contract. </p>
<p >Reminder: You may call this directly from within a completion handler you supplied to an earlier <a class="el" href="classipc_1_1transport_1_1Native__socket__stream.html#a266b52821557f2a4fa8f81058290dee2" title="Implements Native_handle_receiver API per contract.">async_receive_native_handle()</a>. Reminder: It's not thread-safe to call this concurrently with other transmission methods or destructor on the same <code>*this</code>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">hndl_or_null</td><td>See above. </td></tr>
    <tr><td class="paramname">meta_blob</td><td>See above. Reminder: The memory area described by this arg need only be valid until this method returns. Perf reminder: That area will not be copied except for very rare circumstances. </td></tr>
    <tr><td class="paramname">err_code</td><td>See above. Reminder: In rare circumstances, an error emitted here may represent something detected during handling of a <em>preceding</em> <a class="el" href="classipc_1_1transport_1_1Native__socket__stream.html#a555df6a81654160285ea35b545cfd23d" title="Implements Native_handle_sender API per contract.">send_native_handle()</a> call but after it returned. <a class="el" href="namespaceipc.html#aa3192e586cc45d3e7c22463bf2760f89" title="Short-hand for flow::Error_code which is very common.">Error_code</a> generated: <a class="el" href="namespaceipc_1_1transport_1_1error.html#adfef15ef4e76cc55d652fbd9c2797297ac416e988563e44bf15fc6a81743eef53" title="User called an API with 1 or more arguments against the API spec.">error::Code::S_INVALID_ARGUMENT</a> (non-pipe-hosing error: <code>meta_blob.size()</code> exceeds <a class="el" href="classipc_1_1transport_1_1Native__socket__stream.html#a844b8245c9341da8006f979c6b005893" title="Implements Native_handle_sender API per contract.">send_meta_blob_max_size()</a>), <a class="el" href="namespaceipc_1_1transport_1_1error.html#adfef15ef4e76cc55d652fbd9c2797297a42d41c622e92e9053177ba73e75633fe" title="Will not send message: local user already ended sending via API marking this.">error::Code::S_SENDS_FINISHED_CANNOT_SEND</a> (<code>*end_sending()</code> was called earlier), <a class="el" href="namespaceipc_1_1transport_1_1error.html#adfef15ef4e76cc55d652fbd9c2797297adc5d7b9dbaa8c76c6835e3c9a7942410" title="Unable to send outgoing traffic: an earlier-reported, or at least logged, system error had hosed the ...">error::Code::S_LOW_LVL_TRANSPORT_HOSED_CANNOT_SEND</a> (the incoming-direction processing detected that the underlying transport is hosed; specific code was logged and can be obtained via <a class="el" href="classipc_1_1transport_1_1Native__socket__stream.html#a266b52821557f2a4fa8f81058290dee2" title="Implements Native_handle_receiver API per contract.">async_receive_native_handle()</a>), <code>boost::asio::error::eof</code> (underlying transport hosed due to graceful closing by the other side), other system codes most likely from <code>boost::asio::error</code> or <code>boost::system::errc</code> (but never would-block), indicating the underlying transport is hosed for that specific reason, as detected during outgoing-direction processing. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>See above.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classipc_1_1transport_1_1Native__handle__sender.html#ac96b0aa01c286d525f9dcfa6dacc4220" title="In PEER state: Synchronously, non-blockingly sends one discrete message, reliably/in-order,...">Native_handle_sender::send_native_handle()</a>: implemented concept. </dd></dl>

</div>
</div>
<h2 class="groupheader">Friends And Related Function Documentation</h2>
<a id="ac6108711cc8b33c3b7ef0491ba78e2f6" name="ac6108711cc8b33c3b7ef0491ba78e2f6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac6108711cc8b33c3b7ef0491ba78e2f6">&#9670;&nbsp;</a></span>operator&lt;&lt;()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::ostream &amp; operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>os</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classipc_1_1transport_1_1Native__socket__stream.html">Native_socket_stream</a> &amp;&#160;</td>
          <td class="paramname"><em>val</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Prints string representation of the given <code><a class="el" href="classipc_1_1transport_1_1Native__socket__stream.html" title="Implements both Native_handle_sender and Native_handle_receiver concepts by using a stream-oriented U...">Native_socket_stream</a></code> to the given <code>ostream</code>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">os</td><td>Stream to which to write. </td></tr>
    <tr><td class="paramname">val</td><td>Object to serialize. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>os</code>. </dd></dl>

</div>
</div>
<h2 class="groupheader">Member Data Documentation</h2>
<a id="a59d4ec9f05762a8bc2db4b752d4fd5f4" name="a59d4ec9f05762a8bc2db4b752d4fd5f4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a59d4ec9f05762a8bc2db4b752d4fd5f4">&#9670;&nbsp;</a></span>S_BLOB_UNDERFLOW_ALLOWED</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr bool ipc::transport::Native_socket_stream::S_BLOB_UNDERFLOW_ALLOWED = true</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Implements concept API; namely it is <code>true</code>: <a class="el" href="classipc_1_1transport_1_1Native__socket__stream.html#ac5572c8165e25f106f18d327c07d1c3f" title="Implements Blob_receiver API per contract.">async_receive_blob()</a> with smaller-than-<code><a class="el" href="classipc_1_1transport_1_1Native__socket__stream.html#adb667160fd0ab3951d93d219d7bdc3be" title="Implements Blob_receiver API per contract.">receive_blob_max_size()</a></code> size shall <em>not</em> lead to <a class="el" href="namespaceipc_1_1transport_1_1error.html#adfef15ef4e76cc55d652fbd9c2797297ac416e988563e44bf15fc6a81743eef53" title="User called an API with 1 or more arguments against the API spec.">error::Code::S_INVALID_ARGUMENT</a>; hence <a class="el" href="namespaceipc_1_1transport_1_1error.html#adfef15ef4e76cc55d652fbd9c2797297adde24987f30a92b953297207ce935210" title="User protocol-code mismatch: local user-provided storage cannot fit entire message received from oppo...">error::Code::S_MESSAGE_SIZE_EXCEEDS_USER_STORAGE</a> is possible. </p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classipc_1_1transport_1_1Blob__receiver.html#ade0c7ca248cd56e4f6c79783b5b6461f" title="If false then blob.size() &gt; receive_blob_max_size() in PEER-state async_receive_blob() shall yield no...">Blob_receiver::S_BLOB_UNDERFLOW_ALLOWED</a>: implemented concept. Accordingly also see "Blob underflow semantics" in sister concept class's doc header for potentially important discussion. </dd></dl>

</div>
</div>
<a id="a859615800ba1e0546c8e5cb8a6796e41" name="a859615800ba1e0546c8e5cb8a6796e41"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a859615800ba1e0546c8e5cb8a6796e41">&#9670;&nbsp;</a></span>S_META_BLOB_UNDERFLOW_ALLOWED</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr bool ipc::transport::Native_socket_stream::S_META_BLOB_UNDERFLOW_ALLOWED = true</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Implements concept API; namely it is <code>true</code>: <a class="el" href="classipc_1_1transport_1_1Native__socket__stream.html#a266b52821557f2a4fa8f81058290dee2" title="Implements Native_handle_receiver API per contract.">async_receive_native_handle()</a> with smaller-than-<code><a class="el" href="classipc_1_1transport_1_1Native__socket__stream.html#ac7659af6812efca67c410af286f0cb34" title="Implements Native_handle_receiver API per contract.">receive_meta_blob_max_size()</a></code> size shall <em>not</em> lead to <a class="el" href="namespaceipc_1_1transport_1_1error.html#adfef15ef4e76cc55d652fbd9c2797297ac416e988563e44bf15fc6a81743eef53" title="User called an API with 1 or more arguments against the API spec.">error::Code::S_INVALID_ARGUMENT</a>; hence <a class="el" href="namespaceipc_1_1transport_1_1error.html#adfef15ef4e76cc55d652fbd9c2797297adde24987f30a92b953297207ce935210" title="User protocol-code mismatch: local user-provided storage cannot fit entire message received from oppo...">error::Code::S_MESSAGE_SIZE_EXCEEDS_USER_STORAGE</a> is possible. </p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classipc_1_1transport_1_1Native__handle__receiver.html#a46b36a6fd79af85829de46b34d3c6849" title="If false then meta_blob.size() &gt; receive_meta_blob_max_size() in PEER-state async_receive_native_hand...">Native_handle_receiver::S_META_BLOB_UNDERFLOW_ALLOWED</a>: implemented concept. Accordingly also see "Blob underflow semantics" in that concept class's doc header for potentially important discussion. </dd></dl>

</div>
</div>
<hr/>The documentation for this class was generated from the following files:<ul>
<li>transport/<a class="el" href="native__socket__stream_8hpp.html">native_socket_stream.hpp</a></li>
<li>transport/<a class="el" href="native__socket__stream_8cpp.html">native_socket_stream.cpp</a></li>
<li>transport/<a class="el" href="transport__fwd_8hpp.html">transport_fwd.hpp</a></li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Fri Feb 23 2024 04:22:07 for Flow-IPC by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.4
</small></address>
</body>
</html>
