<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.9.4"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Flow-IPC: ipc::transport::Posix_mq_handle Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">Flow-IPC<span id="projectnumber">&#160;1.0.0</span>
   </div>
   <div id="projectbrief">Flow-IPC project: Public API.</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.4 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search",'Search','.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespaceipc.html">ipc</a></li><li class="navelem"><a class="el" href="namespaceipc_1_1transport.html">transport</a></li><li class="navelem"><a class="el" href="classipc_1_1transport_1_1Posix__mq__handle.html">Posix_mq_handle</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pub-static-methods">Static Public Member Functions</a> &#124;
<a href="#pub-static-attribs">Static Public Attributes</a> &#124;
<a href="#related">Related Functions</a> &#124;
<a href="classipc_1_1transport_1_1Posix__mq__handle-members.html">List of all members</a>  </div>
  <div class="headertitle"><div class="title">ipc::transport::Posix_mq_handle Class Reference</div></div>
</div><!--header-->
<div class="contents">

<p>Implements the <a class="el" href="classipc_1_1transport_1_1Persistent__mq__handle.html" title="A documentation-only concept defining the behavior of an object representing a light-weight handle to...">Persistent_mq_handle</a> concept by wrapping the POSIX message queue API (see <code>man mq_overview</code>).  
 <a href="classipc_1_1transport_1_1Posix__mq__handle.html#details">More...</a></p>

<p><code>#include &lt;posix_mq_handle.hpp&gt;</code></p>

<p>Inherits flow::log::Log_context.</p>
<div class="dynheader">
Collaboration diagram for ipc::transport::Posix_mq_handle:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="classipc_1_1transport_1_1Posix__mq__handle__coll__graph.svg" width="284" height="203"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe>
</div>
<center><span class="legend">[<a href="graph_legend.html">legend</a>]</span></center></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-methods" name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a6f5c4dfbc0427f2a8456fb589e5f63d3"><td class="memItemLeft" align="right" valign="top"><a id="a6f5c4dfbc0427f2a8456fb589e5f63d3" name="a6f5c4dfbc0427f2a8456fb589e5f63d3"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>Posix_mq_handle</b> ()</td></tr>
<tr class="memdesc:a6f5c4dfbc0427f2a8456fb589e5f63d3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Implements <a class="el" href="classipc_1_1transport_1_1Persistent__mq__handle.html" title="A documentation-only concept defining the behavior of an object representing a light-weight handle to...">Persistent_mq_handle</a> API: Construct null handle. <br /></td></tr>
<tr class="separator:a6f5c4dfbc0427f2a8456fb589e5f63d3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2aa595c11d407fcf343807e64a150be5"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classipc_1_1transport_1_1Posix__mq__handle.html#a2aa595c11d407fcf343807e64a150be5">Posix_mq_handle</a> (flow::log::Logger *logger_ptr, const <a class="el" href="namespaceipc_1_1transport.html#a33de1c256addb3964b839dc2dd407d24">Shared_name</a> &amp;<a class="el" href="classipc_1_1transport_1_1Posix__mq__handle.html#a7d62af06a8cea2a821908384ee098125">absolute_name</a>, <a class="el" href="namespaceipc_1_1util.html#a9d84c2bab504e6de32b20c77ca9723a2">util::Create_only</a> mode_tag, size_t max_n_msg, size_t max_msg_sz, const <a class="el" href="namespaceipc_1_1util.html#a1b398ae730d1e6040687cb2397115152">util::Permissions</a> &amp;perms=<a class="el" href="namespaceipc_1_1util.html#a1b398ae730d1e6040687cb2397115152">util::Permissions</a>(), <a class="el" href="namespaceipc.html#aa3192e586cc45d3e7c22463bf2760f89">Error_code</a> *err_code=0)</td></tr>
<tr class="memdesc:a2aa595c11d407fcf343807e64a150be5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Implements <a class="el" href="classipc_1_1transport_1_1Persistent__mq__handle.html" title="A documentation-only concept defining the behavior of an object representing a light-weight handle to...">Persistent_mq_handle</a> API: Construct handle to non-existing named MQ, creating it first.  <a href="classipc_1_1transport_1_1Posix__mq__handle.html#a2aa595c11d407fcf343807e64a150be5">More...</a><br /></td></tr>
<tr class="separator:a2aa595c11d407fcf343807e64a150be5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab6bb78f2297f6f7c801e200af963574e"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classipc_1_1transport_1_1Posix__mq__handle.html#ab6bb78f2297f6f7c801e200af963574e">Posix_mq_handle</a> (flow::log::Logger *logger_ptr, const <a class="el" href="namespaceipc_1_1transport.html#a33de1c256addb3964b839dc2dd407d24">Shared_name</a> &amp;<a class="el" href="classipc_1_1transport_1_1Posix__mq__handle.html#a7d62af06a8cea2a821908384ee098125">absolute_name</a>, <a class="el" href="namespaceipc_1_1util.html#a9571de958538d7a4a8649bbfecfac0b9">util::Open_or_create</a> mode_tag, size_t max_n_msg_on_create, size_t max_msg_sz_on_create, const <a class="el" href="namespaceipc_1_1util.html#a1b398ae730d1e6040687cb2397115152">util::Permissions</a> &amp;perms_on_create=<a class="el" href="namespaceipc_1_1util.html#a1b398ae730d1e6040687cb2397115152">util::Permissions</a>(), <a class="el" href="namespaceipc.html#aa3192e586cc45d3e7c22463bf2760f89">Error_code</a> *err_code=0)</td></tr>
<tr class="memdesc:ab6bb78f2297f6f7c801e200af963574e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Implements <a class="el" href="classipc_1_1transport_1_1Persistent__mq__handle.html" title="A documentation-only concept defining the behavior of an object representing a light-weight handle to...">Persistent_mq_handle</a> API: Construct handle to existing named MQ, or else if it does not exist creates it first and opens it (atomically).  <a href="classipc_1_1transport_1_1Posix__mq__handle.html#ab6bb78f2297f6f7c801e200af963574e">More...</a><br /></td></tr>
<tr class="separator:ab6bb78f2297f6f7c801e200af963574e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a01d1655e59059fcec0c983d8dbd8f991"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classipc_1_1transport_1_1Posix__mq__handle.html#a01d1655e59059fcec0c983d8dbd8f991">Posix_mq_handle</a> (flow::log::Logger *logger_ptr, const <a class="el" href="namespaceipc_1_1transport.html#a33de1c256addb3964b839dc2dd407d24">Shared_name</a> &amp;<a class="el" href="classipc_1_1transport_1_1Posix__mq__handle.html#a7d62af06a8cea2a821908384ee098125">absolute_name</a>, <a class="el" href="namespaceipc_1_1util.html#a3e03491b5b2b5fac26551a220946d6e5">util::Open_only</a> mode_tag, <a class="el" href="namespaceipc.html#aa3192e586cc45d3e7c22463bf2760f89">Error_code</a> *err_code=0)</td></tr>
<tr class="memdesc:a01d1655e59059fcec0c983d8dbd8f991"><td class="mdescLeft">&#160;</td><td class="mdescRight">Implements <a class="el" href="classipc_1_1transport_1_1Persistent__mq__handle.html" title="A documentation-only concept defining the behavior of an object representing a light-weight handle to...">Persistent_mq_handle</a> API: Construct handle to existing named MQ.  <a href="classipc_1_1transport_1_1Posix__mq__handle.html#a01d1655e59059fcec0c983d8dbd8f991">More...</a><br /></td></tr>
<tr class="separator:a01d1655e59059fcec0c983d8dbd8f991"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab52cab86bdc869577e8f0722c6eb3097"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classipc_1_1transport_1_1Posix__mq__handle.html#ab52cab86bdc869577e8f0722c6eb3097">Posix_mq_handle</a> (<a class="el" href="classipc_1_1transport_1_1Posix__mq__handle.html">Posix_mq_handle</a> &amp;&amp;src)</td></tr>
<tr class="memdesc:ab52cab86bdc869577e8f0722c6eb3097"><td class="mdescLeft">&#160;</td><td class="mdescRight">Implements <a class="el" href="classipc_1_1transport_1_1Persistent__mq__handle.html" title="A documentation-only concept defining the behavior of an object representing a light-weight handle to...">Persistent_mq_handle</a> API: Constructs handle from the source handle while making the latter as-if default-cted.  <a href="classipc_1_1transport_1_1Posix__mq__handle.html#ab52cab86bdc869577e8f0722c6eb3097">More...</a><br /></td></tr>
<tr class="separator:ab52cab86bdc869577e8f0722c6eb3097"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a77520d1e2b4cc9d3a5bd66a240a3ab7e"><td class="memItemLeft" align="right" valign="top"><a id="a77520d1e2b4cc9d3a5bd66a240a3ab7e" name="a77520d1e2b4cc9d3a5bd66a240a3ab7e"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>Posix_mq_handle</b> (const <a class="el" href="classipc_1_1transport_1_1Posix__mq__handle.html">Posix_mq_handle</a> &amp;)=delete</td></tr>
<tr class="memdesc:a77520d1e2b4cc9d3a5bd66a240a3ab7e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copying of handles is prohibited, per <a class="el" href="classipc_1_1transport_1_1Persistent__mq__handle.html" title="A documentation-only concept defining the behavior of an object representing a light-weight handle to...">Persistent_mq_handle</a> concept. <br /></td></tr>
<tr class="separator:a77520d1e2b4cc9d3a5bd66a240a3ab7e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa8e2e4c19715424d35b4572a29de126b"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classipc_1_1transport_1_1Posix__mq__handle.html#aa8e2e4c19715424d35b4572a29de126b">~Posix_mq_handle</a> ()</td></tr>
<tr class="memdesc:aa8e2e4c19715424d35b4572a29de126b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Implements <a class="el" href="classipc_1_1transport_1_1Persistent__mq__handle.html" title="A documentation-only concept defining the behavior of an object representing a light-weight handle to...">Persistent_mq_handle</a> API: Destroys this handle (or no-op if no handle was successfully constructed, or if it's a moved-from or default-cted handle).  <a href="classipc_1_1transport_1_1Posix__mq__handle.html#aa8e2e4c19715424d35b4572a29de126b">More...</a><br /></td></tr>
<tr class="separator:aa8e2e4c19715424d35b4572a29de126b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeec1f1528e8d51e85f0cbb784ea23e4b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classipc_1_1transport_1_1Posix__mq__handle.html">Posix_mq_handle</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classipc_1_1transport_1_1Posix__mq__handle.html#aeec1f1528e8d51e85f0cbb784ea23e4b">operator=</a> (<a class="el" href="classipc_1_1transport_1_1Posix__mq__handle.html">Posix_mq_handle</a> &amp;&amp;src)</td></tr>
<tr class="memdesc:aeec1f1528e8d51e85f0cbb784ea23e4b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Implements <a class="el" href="classipc_1_1transport_1_1Persistent__mq__handle.html" title="A documentation-only concept defining the behavior of an object representing a light-weight handle to...">Persistent_mq_handle</a> API: Replaces handle with the source handle while making the latter invalid as-if default-cted.  <a href="classipc_1_1transport_1_1Posix__mq__handle.html#aeec1f1528e8d51e85f0cbb784ea23e4b">More...</a><br /></td></tr>
<tr class="separator:aeec1f1528e8d51e85f0cbb784ea23e4b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a860882122d8755fbbeb16067cfeaa387"><td class="memItemLeft" align="right" valign="top"><a id="a860882122d8755fbbeb16067cfeaa387" name="a860882122d8755fbbeb16067cfeaa387"></a>
<a class="el" href="classipc_1_1transport_1_1Posix__mq__handle.html">Posix_mq_handle</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>operator=</b> (const <a class="el" href="classipc_1_1transport_1_1Posix__mq__handle.html">Posix_mq_handle</a> &amp;)=delete</td></tr>
<tr class="memdesc:a860882122d8755fbbeb16067cfeaa387"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copying of handles is prohibited, per <a class="el" href="classipc_1_1transport_1_1Persistent__mq__handle.html" title="A documentation-only concept defining the behavior of an object representing a light-weight handle to...">Persistent_mq_handle</a> concept. <br /></td></tr>
<tr class="separator:a860882122d8755fbbeb16067cfeaa387"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5787b3fe1eb2a7f5f6abda8b9536529b"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classipc_1_1transport_1_1Posix__mq__handle.html#a5787b3fe1eb2a7f5f6abda8b9536529b">try_send</a> (const <a class="el" href="namespaceipc_1_1util.html#ae0be7edba7e30ffa3f8b742af621f2ab">util::Blob_const</a> &amp;blob, <a class="el" href="namespaceipc.html#aa3192e586cc45d3e7c22463bf2760f89">Error_code</a> *err_code=0)</td></tr>
<tr class="memdesc:a5787b3fe1eb2a7f5f6abda8b9536529b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Implements <a class="el" href="classipc_1_1transport_1_1Persistent__mq__handle.html" title="A documentation-only concept defining the behavior of an object representing a light-weight handle to...">Persistent_mq_handle</a> API: Non-blocking send: pushes copy of message to queue and returns <code>true</code>; if queue is full then no-op and returns <code>false</code>.  <a href="classipc_1_1transport_1_1Posix__mq__handle.html#a5787b3fe1eb2a7f5f6abda8b9536529b">More...</a><br /></td></tr>
<tr class="separator:a5787b3fe1eb2a7f5f6abda8b9536529b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6e9b11537c7c83f43728aca7af348a42"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classipc_1_1transport_1_1Posix__mq__handle.html#a6e9b11537c7c83f43728aca7af348a42">send</a> (const <a class="el" href="namespaceipc_1_1util.html#ae0be7edba7e30ffa3f8b742af621f2ab">util::Blob_const</a> &amp;blob, <a class="el" href="namespaceipc.html#aa3192e586cc45d3e7c22463bf2760f89">Error_code</a> *err_code=0)</td></tr>
<tr class="memdesc:a6e9b11537c7c83f43728aca7af348a42"><td class="mdescLeft">&#160;</td><td class="mdescRight">Implements <a class="el" href="classipc_1_1transport_1_1Persistent__mq__handle.html" title="A documentation-only concept defining the behavior of an object representing a light-weight handle to...">Persistent_mq_handle</a> API: Blocking send: pushes copy of message to queue; if queue is full blocks until it is not.  <a href="classipc_1_1transport_1_1Posix__mq__handle.html#a6e9b11537c7c83f43728aca7af348a42">More...</a><br /></td></tr>
<tr class="separator:a6e9b11537c7c83f43728aca7af348a42"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abe2b3968c60945224ddfce119bcae018"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classipc_1_1transport_1_1Posix__mq__handle.html#abe2b3968c60945224ddfce119bcae018">timed_send</a> (const <a class="el" href="namespaceipc_1_1util.html#ae0be7edba7e30ffa3f8b742af621f2ab">util::Blob_const</a> &amp;blob, <a class="el" href="namespaceipc_1_1util.html#ac66141280c3b7295a86b65209f31cc58">util::Fine_duration</a> timeout_from_now, <a class="el" href="namespaceipc.html#aa3192e586cc45d3e7c22463bf2760f89">Error_code</a> *err_code=0)</td></tr>
<tr class="memdesc:abe2b3968c60945224ddfce119bcae018"><td class="mdescLeft">&#160;</td><td class="mdescRight">Implements <a class="el" href="classipc_1_1transport_1_1Persistent__mq__handle.html" title="A documentation-only concept defining the behavior of an object representing a light-weight handle to...">Persistent_mq_handle</a> API: Blocking timed send: pushes copy of message to queue; if queue is full blocks until it is not, or the specified time passes, whichever happens first.  <a href="classipc_1_1transport_1_1Posix__mq__handle.html#abe2b3968c60945224ddfce119bcae018">More...</a><br /></td></tr>
<tr class="separator:abe2b3968c60945224ddfce119bcae018"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a409b0d91e57c994341d900f840e75bb4"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classipc_1_1transport_1_1Posix__mq__handle.html#a409b0d91e57c994341d900f840e75bb4">is_sendable</a> (<a class="el" href="namespaceipc.html#aa3192e586cc45d3e7c22463bf2760f89">Error_code</a> *err_code=0)</td></tr>
<tr class="memdesc:a409b0d91e57c994341d900f840e75bb4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Implements <a class="el" href="classipc_1_1transport_1_1Persistent__mq__handle.html" title="A documentation-only concept defining the behavior of an object representing a light-weight handle to...">Persistent_mq_handle</a> API: Like <a class="el" href="classipc_1_1transport_1_1Posix__mq__handle.html#a5787b3fe1eb2a7f5f6abda8b9536529b" title="Implements Persistent_mq_handle API: Non-blocking send: pushes copy of message to queue and returns t...">try_send()</a> but without the actual pushing of a message.  <a href="classipc_1_1transport_1_1Posix__mq__handle.html#a409b0d91e57c994341d900f840e75bb4">More...</a><br /></td></tr>
<tr class="separator:a409b0d91e57c994341d900f840e75bb4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acf32c33a96d66436628153c74d4a8eb9"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classipc_1_1transport_1_1Posix__mq__handle.html#acf32c33a96d66436628153c74d4a8eb9">wait_sendable</a> (<a class="el" href="namespaceipc.html#aa3192e586cc45d3e7c22463bf2760f89">Error_code</a> *err_code=0)</td></tr>
<tr class="memdesc:acf32c33a96d66436628153c74d4a8eb9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Implements <a class="el" href="classipc_1_1transport_1_1Persistent__mq__handle.html" title="A documentation-only concept defining the behavior of an object representing a light-weight handle to...">Persistent_mq_handle</a> API: Like <a class="el" href="classipc_1_1transport_1_1Posix__mq__handle.html#a6e9b11537c7c83f43728aca7af348a42" title="Implements Persistent_mq_handle API: Blocking send: pushes copy of message to queue; if queue is full...">send()</a> but without the actual pushing of a message.  <a href="classipc_1_1transport_1_1Posix__mq__handle.html#acf32c33a96d66436628153c74d4a8eb9">More...</a><br /></td></tr>
<tr class="separator:acf32c33a96d66436628153c74d4a8eb9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa46ffcc8019c998313c18ed05b7c6ad3"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classipc_1_1transport_1_1Posix__mq__handle.html#aa46ffcc8019c998313c18ed05b7c6ad3">timed_wait_sendable</a> (<a class="el" href="namespaceipc_1_1util.html#ac66141280c3b7295a86b65209f31cc58">util::Fine_duration</a> timeout_from_now, <a class="el" href="namespaceipc.html#aa3192e586cc45d3e7c22463bf2760f89">Error_code</a> *err_code=0)</td></tr>
<tr class="memdesc:aa46ffcc8019c998313c18ed05b7c6ad3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Implements <a class="el" href="classipc_1_1transport_1_1Persistent__mq__handle.html" title="A documentation-only concept defining the behavior of an object representing a light-weight handle to...">Persistent_mq_handle</a> API: Like <a class="el" href="classipc_1_1transport_1_1Posix__mq__handle.html#abe2b3968c60945224ddfce119bcae018" title="Implements Persistent_mq_handle API: Blocking timed send: pushes copy of message to queue; if queue i...">timed_send()</a> but without the actual pushing of a message.  <a href="classipc_1_1transport_1_1Posix__mq__handle.html#aa46ffcc8019c998313c18ed05b7c6ad3">More...</a><br /></td></tr>
<tr class="separator:aa46ffcc8019c998313c18ed05b7c6ad3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abe9a423ceda292d5b01b54039102170b"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classipc_1_1transport_1_1Posix__mq__handle.html#abe9a423ceda292d5b01b54039102170b">try_receive</a> (<a class="el" href="namespaceipc_1_1util.html#a6cb62ae434900f3a8915b33ec5d61a96">util::Blob_mutable</a> *blob, <a class="el" href="namespaceipc.html#aa3192e586cc45d3e7c22463bf2760f89">Error_code</a> *err_code=0)</td></tr>
<tr class="memdesc:abe9a423ceda292d5b01b54039102170b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Implements <a class="el" href="classipc_1_1transport_1_1Persistent__mq__handle.html" title="A documentation-only concept defining the behavior of an object representing a light-weight handle to...">Persistent_mq_handle</a> API: Non-blocking receive: pops copy of message from queue into buffer and returns <code>true</code>; if queue is empty then no-op and returns <code>false</code>.  <a href="classipc_1_1transport_1_1Posix__mq__handle.html#abe9a423ceda292d5b01b54039102170b">More...</a><br /></td></tr>
<tr class="separator:abe9a423ceda292d5b01b54039102170b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a65f35bfe249b13dc3bc0442d10a55a0f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classipc_1_1transport_1_1Posix__mq__handle.html#a65f35bfe249b13dc3bc0442d10a55a0f">receive</a> (<a class="el" href="namespaceipc_1_1util.html#a6cb62ae434900f3a8915b33ec5d61a96">util::Blob_mutable</a> *blob, <a class="el" href="namespaceipc.html#aa3192e586cc45d3e7c22463bf2760f89">Error_code</a> *err_code=0)</td></tr>
<tr class="memdesc:a65f35bfe249b13dc3bc0442d10a55a0f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Implements <a class="el" href="classipc_1_1transport_1_1Persistent__mq__handle.html" title="A documentation-only concept defining the behavior of an object representing a light-weight handle to...">Persistent_mq_handle</a> API: Blocking receive: pops copy of message from queue into buffer; if queue is empty blocks until it is not.  <a href="classipc_1_1transport_1_1Posix__mq__handle.html#a65f35bfe249b13dc3bc0442d10a55a0f">More...</a><br /></td></tr>
<tr class="separator:a65f35bfe249b13dc3bc0442d10a55a0f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa853452d0d0aeeaf61461cc8a48b5c09"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classipc_1_1transport_1_1Posix__mq__handle.html#aa853452d0d0aeeaf61461cc8a48b5c09">timed_receive</a> (<a class="el" href="namespaceipc_1_1util.html#a6cb62ae434900f3a8915b33ec5d61a96">util::Blob_mutable</a> *blob, <a class="el" href="namespaceipc_1_1util.html#ac66141280c3b7295a86b65209f31cc58">util::Fine_duration</a> timeout_from_now, <a class="el" href="namespaceipc.html#aa3192e586cc45d3e7c22463bf2760f89">Error_code</a> *err_code=0)</td></tr>
<tr class="memdesc:aa853452d0d0aeeaf61461cc8a48b5c09"><td class="mdescLeft">&#160;</td><td class="mdescRight">Implements <a class="el" href="classipc_1_1transport_1_1Persistent__mq__handle.html" title="A documentation-only concept defining the behavior of an object representing a light-weight handle to...">Persistent_mq_handle</a> API: Blocking timed receive: pops copy of message from queue into buffer; if queue is empty blocks until it is not, or the specified time passes, whichever happens first.  <a href="classipc_1_1transport_1_1Posix__mq__handle.html#aa853452d0d0aeeaf61461cc8a48b5c09">More...</a><br /></td></tr>
<tr class="separator:aa853452d0d0aeeaf61461cc8a48b5c09"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a399bb25dbcfa06437b2f50abcc1500d1"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classipc_1_1transport_1_1Posix__mq__handle.html#a399bb25dbcfa06437b2f50abcc1500d1">is_receivable</a> (<a class="el" href="namespaceipc.html#aa3192e586cc45d3e7c22463bf2760f89">Error_code</a> *err_code=0)</td></tr>
<tr class="memdesc:a399bb25dbcfa06437b2f50abcc1500d1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Implements <a class="el" href="classipc_1_1transport_1_1Persistent__mq__handle.html" title="A documentation-only concept defining the behavior of an object representing a light-weight handle to...">Persistent_mq_handle</a> API: Like <a class="el" href="classipc_1_1transport_1_1Posix__mq__handle.html#abe9a423ceda292d5b01b54039102170b" title="Implements Persistent_mq_handle API: Non-blocking receive: pops copy of message from queue into buffe...">try_receive()</a> but without the actual popping of a message.  <a href="classipc_1_1transport_1_1Posix__mq__handle.html#a399bb25dbcfa06437b2f50abcc1500d1">More...</a><br /></td></tr>
<tr class="separator:a399bb25dbcfa06437b2f50abcc1500d1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0f93df71d0c476e17b32ca4d6bf82b9b"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classipc_1_1transport_1_1Posix__mq__handle.html#a0f93df71d0c476e17b32ca4d6bf82b9b">wait_receivable</a> (<a class="el" href="namespaceipc.html#aa3192e586cc45d3e7c22463bf2760f89">Error_code</a> *err_code=0)</td></tr>
<tr class="memdesc:a0f93df71d0c476e17b32ca4d6bf82b9b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Implements <a class="el" href="classipc_1_1transport_1_1Persistent__mq__handle.html" title="A documentation-only concept defining the behavior of an object representing a light-weight handle to...">Persistent_mq_handle</a> API: Like <a class="el" href="classipc_1_1transport_1_1Posix__mq__handle.html#a65f35bfe249b13dc3bc0442d10a55a0f" title="Implements Persistent_mq_handle API: Blocking receive: pops copy of message from queue into buffer; i...">receive()</a> but without the actual popping of a message.  <a href="classipc_1_1transport_1_1Posix__mq__handle.html#a0f93df71d0c476e17b32ca4d6bf82b9b">More...</a><br /></td></tr>
<tr class="separator:a0f93df71d0c476e17b32ca4d6bf82b9b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a64079f1c9315af2e75e808b6ae5312e5"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classipc_1_1transport_1_1Posix__mq__handle.html#a64079f1c9315af2e75e808b6ae5312e5">timed_wait_receivable</a> (<a class="el" href="namespaceipc_1_1util.html#ac66141280c3b7295a86b65209f31cc58">util::Fine_duration</a> timeout_from_now, <a class="el" href="namespaceipc.html#aa3192e586cc45d3e7c22463bf2760f89">Error_code</a> *err_code=0)</td></tr>
<tr class="memdesc:a64079f1c9315af2e75e808b6ae5312e5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Implements <a class="el" href="classipc_1_1transport_1_1Persistent__mq__handle.html" title="A documentation-only concept defining the behavior of an object representing a light-weight handle to...">Persistent_mq_handle</a> API: Like <a class="el" href="classipc_1_1transport_1_1Posix__mq__handle.html#aa853452d0d0aeeaf61461cc8a48b5c09" title="Implements Persistent_mq_handle API: Blocking timed receive: pops copy of message from queue into buf...">timed_receive()</a> but without the actual popping of a message.  <a href="classipc_1_1transport_1_1Posix__mq__handle.html#a64079f1c9315af2e75e808b6ae5312e5">More...</a><br /></td></tr>
<tr class="separator:a64079f1c9315af2e75e808b6ae5312e5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0afe8a636902116223b4f33f081119df"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classipc_1_1transport_1_1Posix__mq__handle.html#a0afe8a636902116223b4f33f081119df">interrupt_sends</a> ()</td></tr>
<tr class="memdesc:a0afe8a636902116223b4f33f081119df"><td class="mdescLeft">&#160;</td><td class="mdescRight">Implements <a class="el" href="classipc_1_1transport_1_1Persistent__mq__handle.html" title="A documentation-only concept defining the behavior of an object representing a light-weight handle to...">Persistent_mq_handle</a> API: Turn on preemptive/concurrent interruption of blocking-sends and sendable-waits/polls.  <a href="classipc_1_1transport_1_1Posix__mq__handle.html#a0afe8a636902116223b4f33f081119df">More...</a><br /></td></tr>
<tr class="separator:a0afe8a636902116223b4f33f081119df"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a01d842eb304fff361d72a090113ffc9f"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classipc_1_1transport_1_1Posix__mq__handle.html#a01d842eb304fff361d72a090113ffc9f">allow_sends</a> ()</td></tr>
<tr class="memdesc:a01d842eb304fff361d72a090113ffc9f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Implements <a class="el" href="classipc_1_1transport_1_1Persistent__mq__handle.html" title="A documentation-only concept defining the behavior of an object representing a light-weight handle to...">Persistent_mq_handle</a> API: Turn off preemptive/concurrent interruption of blocking-sends and sendable-waits/polls.  <a href="classipc_1_1transport_1_1Posix__mq__handle.html#a01d842eb304fff361d72a090113ffc9f">More...</a><br /></td></tr>
<tr class="separator:a01d842eb304fff361d72a090113ffc9f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a02262faa0f53b5518db359b4e5968b47"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classipc_1_1transport_1_1Posix__mq__handle.html#a02262faa0f53b5518db359b4e5968b47">interrupt_receives</a> ()</td></tr>
<tr class="memdesc:a02262faa0f53b5518db359b4e5968b47"><td class="mdescLeft">&#160;</td><td class="mdescRight">Implements <a class="el" href="classipc_1_1transport_1_1Persistent__mq__handle.html" title="A documentation-only concept defining the behavior of an object representing a light-weight handle to...">Persistent_mq_handle</a> API: Turn on preemptive/concurrent interruption of blocking-receives and receivable-waits/polls.  <a href="classipc_1_1transport_1_1Posix__mq__handle.html#a02262faa0f53b5518db359b4e5968b47">More...</a><br /></td></tr>
<tr class="separator:a02262faa0f53b5518db359b4e5968b47"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4041e66104bf38ddc9dce34d11ccd405"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classipc_1_1transport_1_1Posix__mq__handle.html#a4041e66104bf38ddc9dce34d11ccd405">allow_receives</a> ()</td></tr>
<tr class="memdesc:a4041e66104bf38ddc9dce34d11ccd405"><td class="mdescLeft">&#160;</td><td class="mdescRight">Implements <a class="el" href="classipc_1_1transport_1_1Persistent__mq__handle.html" title="A documentation-only concept defining the behavior of an object representing a light-weight handle to...">Persistent_mq_handle</a> API: Turn off preemptive/concurrent interruption of blocking-receives and receivable-waits/polls.  <a href="classipc_1_1transport_1_1Posix__mq__handle.html#a4041e66104bf38ddc9dce34d11ccd405">More...</a><br /></td></tr>
<tr class="separator:a4041e66104bf38ddc9dce34d11ccd405"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7d62af06a8cea2a821908384ee098125"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="namespaceipc_1_1transport.html#a33de1c256addb3964b839dc2dd407d24">Shared_name</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classipc_1_1transport_1_1Posix__mq__handle.html#a7d62af06a8cea2a821908384ee098125">absolute_name</a> () const</td></tr>
<tr class="memdesc:a7d62af06a8cea2a821908384ee098125"><td class="mdescLeft">&#160;</td><td class="mdescRight">Implements <a class="el" href="classipc_1_1transport_1_1Persistent__mq__handle.html" title="A documentation-only concept defining the behavior of an object representing a light-weight handle to...">Persistent_mq_handle</a> API: Returns name equal to <code>absolute_name</code> passed to ctor.  <a href="classipc_1_1transport_1_1Posix__mq__handle.html#a7d62af06a8cea2a821908384ee098125">More...</a><br /></td></tr>
<tr class="separator:a7d62af06a8cea2a821908384ee098125"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a412e7c922909eeb5707bb0abe6e27a76"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classipc_1_1transport_1_1Posix__mq__handle.html#a412e7c922909eeb5707bb0abe6e27a76">max_msg_size</a> () const</td></tr>
<tr class="memdesc:a412e7c922909eeb5707bb0abe6e27a76"><td class="mdescLeft">&#160;</td><td class="mdescRight">Implements <a class="el" href="classipc_1_1transport_1_1Persistent__mq__handle.html" title="A documentation-only concept defining the behavior of an object representing a light-weight handle to...">Persistent_mq_handle</a> API: Returns the max message size of the underlying queue.  <a href="classipc_1_1transport_1_1Posix__mq__handle.html#a412e7c922909eeb5707bb0abe6e27a76">More...</a><br /></td></tr>
<tr class="separator:a412e7c922909eeb5707bb0abe6e27a76"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a514dbdda12ec70ea1ff65abfa6237ce2"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classipc_1_1transport_1_1Posix__mq__handle.html#a514dbdda12ec70ea1ff65abfa6237ce2">max_n_msgs</a> () const</td></tr>
<tr class="memdesc:a514dbdda12ec70ea1ff65abfa6237ce2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Implements <a class="el" href="classipc_1_1transport_1_1Persistent__mq__handle.html" title="A documentation-only concept defining the behavior of an object representing a light-weight handle to...">Persistent_mq_handle</a> API: Returns the max message count of the underlying queue.  <a href="classipc_1_1transport_1_1Posix__mq__handle.html#a514dbdda12ec70ea1ff65abfa6237ce2">More...</a><br /></td></tr>
<tr class="separator:a514dbdda12ec70ea1ff65abfa6237ce2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a62bc5410c9928099dff46ba021acb879"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespaceipc_1_1transport.html#a7ee4551983d9df16ec16a3139bac50e8">Native_handle</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classipc_1_1transport_1_1Posix__mq__handle.html#a62bc5410c9928099dff46ba021acb879">native_handle</a> () const</td></tr>
<tr class="memdesc:a62bc5410c9928099dff46ba021acb879"><td class="mdescLeft">&#160;</td><td class="mdescRight">Implements <a class="el" href="classipc_1_1transport_1_1Persistent__mq__handle.html" title="A documentation-only concept defining the behavior of an object representing a light-weight handle to...">Persistent_mq_handle</a> API: Returns the stored native MQ handle; null if not open.  <a href="classipc_1_1transport_1_1Posix__mq__handle.html#a62bc5410c9928099dff46ba021acb879">More...</a><br /></td></tr>
<tr class="separator:a62bc5410c9928099dff46ba021acb879"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-static-methods" name="pub-static-methods"></a>
Static Public Member Functions</h2></td></tr>
<tr class="memitem:a658271ad982e3e0af4c3666b947019cc"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classipc_1_1transport_1_1Posix__mq__handle.html#a658271ad982e3e0af4c3666b947019cc">remove_persistent</a> (flow::log::Logger *logger_ptr, const <a class="el" href="namespaceipc_1_1transport.html#a33de1c256addb3964b839dc2dd407d24">Shared_name</a> &amp;name, <a class="el" href="namespaceipc.html#aa3192e586cc45d3e7c22463bf2760f89">Error_code</a> *err_code=0)</td></tr>
<tr class="memdesc:a658271ad982e3e0af4c3666b947019cc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Implements <a class="el" href="classipc_1_1transport_1_1Persistent__mq__handle.html" title="A documentation-only concept defining the behavior of an object representing a light-weight handle to...">Persistent_mq_handle</a> API: Removes the named persistent MQ.  <a href="classipc_1_1transport_1_1Posix__mq__handle.html#a658271ad982e3e0af4c3666b947019cc">More...</a><br /></td></tr>
<tr class="separator:a658271ad982e3e0af4c3666b947019cc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1df87fc56734cb902a71340eab6c0303"><td class="memTemplParams" colspan="2">template&lt;typename Handle_name_func &gt; </td></tr>
<tr class="memitem:a1df87fc56734cb902a71340eab6c0303"><td class="memTemplItemLeft" align="right" valign="top">static void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classipc_1_1transport_1_1Posix__mq__handle.html#a1df87fc56734cb902a71340eab6c0303">for_each_persistent</a> (const Handle_name_func &amp;handle_name_func)</td></tr>
<tr class="memdesc:a1df87fc56734cb902a71340eab6c0303"><td class="mdescLeft">&#160;</td><td class="mdescRight">Implements <a class="el" href="classipc_1_1transport_1_1Persistent__mq__handle.html" title="A documentation-only concept defining the behavior of an object representing a light-weight handle to...">Persistent_mq_handle</a> API.  <a href="classipc_1_1transport_1_1Posix__mq__handle.html#a1df87fc56734cb902a71340eab6c0303">More...</a><br /></td></tr>
<tr class="separator:a1df87fc56734cb902a71340eab6c0303"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-static-attribs" name="pub-static-attribs"></a>
Static Public Attributes</h2></td></tr>
<tr class="memitem:a1ba246862d7484019476e9b60426833e"><td class="memItemLeft" align="right" valign="top"><a id="a1ba246862d7484019476e9b60426833e" name="a1ba246862d7484019476e9b60426833e"></a>
static const <a class="el" href="namespaceipc_1_1transport.html#a33de1c256addb3964b839dc2dd407d24">Shared_name</a>&#160;</td><td class="memItemRight" valign="bottom"><b>S_RESOURCE_TYPE_ID</b> = <a class="el" href="classipc_1_1util_1_1Shared__name.html#a48f20b7b54490aa10dc64081d34c55b2">Shared_name::ct</a>(&quot;posixQ&quot;)</td></tr>
<tr class="memdesc:a1ba246862d7484019476e9b60426833e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Implements concept API. <br /></td></tr>
<tr class="separator:a1ba246862d7484019476e9b60426833e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af4a21d3354b44d99aee79af5b1464f10"><td class="memItemLeft" align="right" valign="top"><a id="af4a21d3354b44d99aee79af5b1464f10" name="af4a21d3354b44d99aee79af5b1464f10"></a>
static constexpr bool&#160;</td><td class="memItemRight" valign="bottom"><b>S_HAS_NATIVE_HANDLE</b> = true</td></tr>
<tr class="memdesc:af4a21d3354b44d99aee79af5b1464f10"><td class="mdescLeft">&#160;</td><td class="mdescRight">Implements concept API. Contrast this value with <a class="el" href="classipc_1_1transport_1_1Bipc__mq__handle.html#a7507ac097eb580a44622429c69af2f1d" title="Implements concept API.">Bipc_mq_handle::S_HAS_NATIVE_HANDLE</a>. <br /></td></tr>
<tr class="separator:af4a21d3354b44d99aee79af5b1464f10"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="related" name="related"></a>
Related Functions</h2></td></tr>
<tr><td class="ititle" colspan="2"><p >(Note that these are not member functions.) </p>
</td></tr>
<tr class="memitem:a8fb9256b66ad3dfdf742de66223466d7"><td class="memItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classipc_1_1transport_1_1Posix__mq__handle.html#a8fb9256b66ad3dfdf742de66223466d7">operator&lt;&lt;</a> (std::ostream &amp;os, const <a class="el" href="classipc_1_1transport_1_1Posix__mq__handle.html">Posix_mq_handle</a> &amp;val)</td></tr>
<tr class="memdesc:a8fb9256b66ad3dfdf742de66223466d7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Prints string representation of the given <a class="el" href="classipc_1_1transport_1_1Posix__mq__handle.html" title="Implements the Persistent_mq_handle concept by wrapping the POSIX message queue API (see man mq_overv...">Posix_mq_handle</a> to the given <code>ostream</code>.  <a href="classipc_1_1transport_1_1Posix__mq__handle.html#a8fb9256b66ad3dfdf742de66223466d7">More...</a><br /></td></tr>
<tr class="separator:a8fb9256b66ad3dfdf742de66223466d7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a65015c97813a6609da035fe86d1a36c0"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classipc_1_1transport_1_1Posix__mq__handle.html#a65015c97813a6609da035fe86d1a36c0">swap</a> (<a class="el" href="classipc_1_1transport_1_1Posix__mq__handle.html">Posix_mq_handle</a> &amp;val1, <a class="el" href="classipc_1_1transport_1_1Posix__mq__handle.html">Posix_mq_handle</a> &amp;val2)</td></tr>
<tr class="memdesc:a65015c97813a6609da035fe86d1a36c0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Implements <a class="el" href="classipc_1_1transport_1_1Persistent__mq__handle.html" title="A documentation-only concept defining the behavior of an object representing a light-weight handle to...">Persistent_mq_handle</a> related concept: Swaps two objects.  <a href="classipc_1_1transport_1_1Posix__mq__handle.html#a65015c97813a6609da035fe86d1a36c0">More...</a><br /></td></tr>
<tr class="separator:a65015c97813a6609da035fe86d1a36c0"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p >Implements the <a class="el" href="classipc_1_1transport_1_1Persistent__mq__handle.html" title="A documentation-only concept defining the behavior of an object representing a light-weight handle to...">Persistent_mq_handle</a> concept by wrapping the POSIX message queue API (see <code>man mq_overview</code>). </p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classipc_1_1transport_1_1Persistent__mq__handle.html" title="A documentation-only concept defining the behavior of an object representing a light-weight handle to...">Persistent_mq_handle</a>: implemented concept.</dd></dl>
<p>Reminder: This is available publicly in case it is useful; but it is more likely one would use a <a class="el" href="classipc_1_1transport_1_1Blob__stream__mq__sender.html" title="Implements Blob_sender concept by using an adopted Persistent_mq_handle MQ handle to an MQ (message q...">Blob_stream_mq_sender</a> or <a class="el" href="classipc_1_1transport_1_1Blob__stream__mq__receiver.html" title="Implements Blob_receiver concept by using an adopted Persistent_mq_handle MQ handle to an MQ (message...">Blob_stream_mq_receiver</a> which provides a far more convenient boost.asio-like async-capable API. It uses class(es) like this one in its impl.</p>
<p ><a class="el" href="classipc_1_1transport_1_1Posix__mq__handle.html#a62bc5410c9928099dff46ba021acb879" title="Implements Persistent_mq_handle API: Returns the stored native MQ handle; null if not open.">native_handle()</a> returns the underlying MQ descriptor; in Linux (the only OS supported as of this writing) this happens to be an FD; and as an FD it can (according to <code>man mq_overview</code>) participate in <code>epoll/poll/select()</code>. It is simple to wrap this descriptor in a boost.asio <code>posix::descriptor</code>. Having done that, one can <code>async_wait()</code> on it, awaiting writability and readability in async fashion not supported by the <a class="el" href="classipc_1_1transport_1_1Persistent__mq__handle.html" title="A documentation-only concept defining the behavior of an object representing a light-weight handle to...">Persistent_mq_handle</a> concept. Accordingly <a class="el" href="classipc_1_1transport_1_1Posix__mq__handle.html#af4a21d3354b44d99aee79af5b1464f10" title="Implements concept API. Contrast this value with Bipc_mq_handle::S_HAS_NATIVE_HANDLE.">Posix_mq_handle::S_HAS_NATIVE_HANDLE</a> is <code>true</code>. </p>
</div><h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="a2aa595c11d407fcf343807e64a150be5" name="a2aa595c11d407fcf343807e64a150be5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2aa595c11d407fcf343807e64a150be5">&#9670;&nbsp;</a></span>Posix_mq_handle() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">ipc::transport::Posix_mq_handle::Posix_mq_handle </td>
          <td>(</td>
          <td class="paramtype">flow::log::Logger *&#160;</td>
          <td class="paramname"><em>logger_ptr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespaceipc_1_1transport.html#a33de1c256addb3964b839dc2dd407d24">Shared_name</a> &amp;&#160;</td>
          <td class="paramname"><em>absolute_name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceipc_1_1util.html#a9d84c2bab504e6de32b20c77ca9723a2">util::Create_only</a>&#160;</td>
          <td class="paramname"><em>mode_tag</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>max_n_msg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>max_msg_sz</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespaceipc_1_1util.html#a1b398ae730d1e6040687cb2397115152">util::Permissions</a> &amp;&#160;</td>
          <td class="paramname"><em>perms</em> = <code><a class="el" href="namespaceipc_1_1util.html#a1b398ae730d1e6040687cb2397115152">util::Permissions</a>()</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceipc.html#aa3192e586cc45d3e7c22463bf2760f89">Error_code</a> *&#160;</td>
          <td class="paramname"><em>err_code</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">explicit</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Implements <a class="el" href="classipc_1_1transport_1_1Persistent__mq__handle.html" title="A documentation-only concept defining the behavior of an object representing a light-weight handle to...">Persistent_mq_handle</a> API: Construct handle to non-existing named MQ, creating it first. </p>
<p >If it already exists, it is an error.</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classipc_1_1transport_1_1Persistent__mq__handle.html#a22abfaa801a9e2f974a8cd179544d19a" title="Construct null handle, suitable only for being subsequently moved-to or destroyed.">Persistent_mq_handle::Persistent_mq_handle()</a>: implemented concept.</dd></dl>
<p><code>max_n_msg</code> and <code>max_msg_sz</code> are subject to certain OS limits, according to <code>man mq_overview</code>. Watch out for those: we have no control over them here. The <code>man</code> page should give you the necessary information.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">logger_ptr</td><td>See above. </td></tr>
    <tr><td class="paramname">absolute_name</td><td>See above. </td></tr>
    <tr><td class="paramname">mode_tag</td><td>See above. </td></tr>
    <tr><td class="paramname">perms</td><td>See above. Reminder: Suggest the use of <a class="el" href="namespaceipc_1_1util.html#abda2ce5bcdbc26ca63d667b87818439c" title="Maps general Permissions_level specifier to low-level Permissions value, when the underlying resource...">util::shared_resource_permissions()</a> to translate from one of a small handful of levels of access; these apply almost always in practice. </td></tr>
    <tr><td class="paramname">max_n_msg</td><td>See above. </td></tr>
    <tr><td class="paramname">max_msg_sz</td><td>See above. </td></tr>
    <tr><td class="paramname">err_code</td><td>See above. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ab6bb78f2297f6f7c801e200af963574e" name="ab6bb78f2297f6f7c801e200af963574e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab6bb78f2297f6f7c801e200af963574e">&#9670;&nbsp;</a></span>Posix_mq_handle() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">ipc::transport::Posix_mq_handle::Posix_mq_handle </td>
          <td>(</td>
          <td class="paramtype">flow::log::Logger *&#160;</td>
          <td class="paramname"><em>logger_ptr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespaceipc_1_1transport.html#a33de1c256addb3964b839dc2dd407d24">Shared_name</a> &amp;&#160;</td>
          <td class="paramname"><em>absolute_name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceipc_1_1util.html#a9571de958538d7a4a8649bbfecfac0b9">util::Open_or_create</a>&#160;</td>
          <td class="paramname"><em>mode_tag</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>max_n_msg_on_create</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>max_msg_sz_on_create</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespaceipc_1_1util.html#a1b398ae730d1e6040687cb2397115152">util::Permissions</a> &amp;&#160;</td>
          <td class="paramname"><em>perms_on_create</em> = <code><a class="el" href="namespaceipc_1_1util.html#a1b398ae730d1e6040687cb2397115152">util::Permissions</a>()</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceipc.html#aa3192e586cc45d3e7c22463bf2760f89">Error_code</a> *&#160;</td>
          <td class="paramname"><em>err_code</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">explicit</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Implements <a class="el" href="classipc_1_1transport_1_1Persistent__mq__handle.html" title="A documentation-only concept defining the behavior of an object representing a light-weight handle to...">Persistent_mq_handle</a> API: Construct handle to existing named MQ, or else if it does not exist creates it first and opens it (atomically). </p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classipc_1_1transport_1_1Persistent__mq__handle.html#a22abfaa801a9e2f974a8cd179544d19a" title="Construct null handle, suitable only for being subsequently moved-to or destroyed.">Persistent_mq_handle::Persistent_mq_handle()</a>: implemented concept.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">logger_ptr</td><td>See above. </td></tr>
    <tr><td class="paramname">absolute_name</td><td>See above. </td></tr>
    <tr><td class="paramname">mode_tag</td><td>See above. </td></tr>
    <tr><td class="paramname">perms_on_create</td><td>See above. Reminder: Suggest the use of <a class="el" href="namespaceipc_1_1util.html#abda2ce5bcdbc26ca63d667b87818439c" title="Maps general Permissions_level specifier to low-level Permissions value, when the underlying resource...">util::shared_resource_permissions()</a> to translate from one of a small handful of levels of access; these apply almost always in practice. </td></tr>
    <tr><td class="paramname">max_n_msg_on_create</td><td>See above. </td></tr>
    <tr><td class="paramname">max_msg_sz_on_create</td><td>See above. </td></tr>
    <tr><td class="paramname">err_code</td><td>See above. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a01d1655e59059fcec0c983d8dbd8f991" name="a01d1655e59059fcec0c983d8dbd8f991"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a01d1655e59059fcec0c983d8dbd8f991">&#9670;&nbsp;</a></span>Posix_mq_handle() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">ipc::transport::Posix_mq_handle::Posix_mq_handle </td>
          <td>(</td>
          <td class="paramtype">flow::log::Logger *&#160;</td>
          <td class="paramname"><em>logger_ptr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespaceipc_1_1transport.html#a33de1c256addb3964b839dc2dd407d24">Shared_name</a> &amp;&#160;</td>
          <td class="paramname"><em>absolute_name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceipc_1_1util.html#a3e03491b5b2b5fac26551a220946d6e5">util::Open_only</a>&#160;</td>
          <td class="paramname"><em>mode_tag</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceipc.html#aa3192e586cc45d3e7c22463bf2760f89">Error_code</a> *&#160;</td>
          <td class="paramname"><em>err_code</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">explicit</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Implements <a class="el" href="classipc_1_1transport_1_1Persistent__mq__handle.html" title="A documentation-only concept defining the behavior of an object representing a light-weight handle to...">Persistent_mq_handle</a> API: Construct handle to existing named MQ. </p>
<p >If it does not exist, it is an error.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">logger_ptr</td><td>See above. </td></tr>
    <tr><td class="paramname">absolute_name</td><td>See above. </td></tr>
    <tr><td class="paramname">mode_tag</td><td>See above. </td></tr>
    <tr><td class="paramname">err_code</td><td>See above. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ab52cab86bdc869577e8f0722c6eb3097" name="ab52cab86bdc869577e8f0722c6eb3097"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab52cab86bdc869577e8f0722c6eb3097">&#9670;&nbsp;</a></span>Posix_mq_handle() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ipc::transport::Posix_mq_handle::Posix_mq_handle </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classipc_1_1transport_1_1Posix__mq__handle.html">Posix_mq_handle</a> &amp;&amp;&#160;</td>
          <td class="paramname"><em>src</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Implements <a class="el" href="classipc_1_1transport_1_1Persistent__mq__handle.html" title="A documentation-only concept defining the behavior of an object representing a light-weight handle to...">Persistent_mq_handle</a> API: Constructs handle from the source handle while making the latter as-if default-cted. </p>
<p >Reminder, informally: This is a light-weight op.</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classipc_1_1transport_1_1Persistent__mq__handle.html#a22abfaa801a9e2f974a8cd179544d19a" title="Construct null handle, suitable only for being subsequently moved-to or destroyed.">Persistent_mq_handle::Persistent_mq_handle()</a>: implemented concept.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">src</td><td>See above. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aa8e2e4c19715424d35b4572a29de126b" name="aa8e2e4c19715424d35b4572a29de126b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa8e2e4c19715424d35b4572a29de126b">&#9670;&nbsp;</a></span>~Posix_mq_handle()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ipc::transport::Posix_mq_handle::~Posix_mq_handle </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Implements <a class="el" href="classipc_1_1transport_1_1Persistent__mq__handle.html" title="A documentation-only concept defining the behavior of an object representing a light-weight handle to...">Persistent_mq_handle</a> API: Destroys this handle (or no-op if no handle was successfully constructed, or if it's a moved-from or default-cted handle). </p>
<p >Reminder: The underlying MQ (if any) is <em>not</em> destroyed and can be attached-to by another handle.</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classipc_1_1transport_1_1Persistent__mq__handle.html#a1fbb936f8f80fedcb1227794ef0a451b" title="Destroys this handle (or no-op if no handle was successfully constructed, or if it&#39;s a moved-from or ...">Persistent_mq_handle::~Persistent_mq_handle()</a>: implemented concept. </dd></dl>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="a7d62af06a8cea2a821908384ee098125" name="a7d62af06a8cea2a821908384ee098125"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7d62af06a8cea2a821908384ee098125">&#9670;&nbsp;</a></span>absolute_name()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="namespaceipc_1_1transport.html#a33de1c256addb3964b839dc2dd407d24">Shared_name</a> &amp; ipc::transport::Posix_mq_handle::absolute_name </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Implements <a class="el" href="classipc_1_1transport_1_1Persistent__mq__handle.html" title="A documentation-only concept defining the behavior of an object representing a light-weight handle to...">Persistent_mq_handle</a> API: Returns name equal to <code>absolute_name</code> passed to ctor. </p>
<dl class="section return"><dt>Returns</dt><dd>See above. </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classipc_1_1transport_1_1Persistent__mq__handle.html#a5ef74ca74a9d985710af974fd6518940" title="Returns name equal to absolute_name passed to ctor.">Persistent_mq_handle::absolute_name()</a>: implemented concept. </dd></dl>

</div>
</div>
<a id="a4041e66104bf38ddc9dce34d11ccd405" name="a4041e66104bf38ddc9dce34d11ccd405"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4041e66104bf38ddc9dce34d11ccd405">&#9670;&nbsp;</a></span>allow_receives()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool ipc::transport::Posix_mq_handle::allow_receives </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Implements <a class="el" href="classipc_1_1transport_1_1Persistent__mq__handle.html" title="A documentation-only concept defining the behavior of an object representing a light-weight handle to...">Persistent_mq_handle</a> API: Turn off preemptive/concurrent interruption of blocking-receives and receivable-waits/polls. </p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classipc_1_1transport_1_1Persistent__mq__handle.html#aaedc972e2ce207875a3e7262f9064b65" title="Disables mode enabled by interrupt_receives().">Persistent_mq_handle::allow_receives()</a>: implemented concept.</dd></dl>
<h3>INFO+ logging</h3>
<p >WARNING on duplicate use, INFO otherwise.</p>
<dl class="section return"><dt>Returns</dt><dd>See above. </dd></dl>

</div>
</div>
<a id="a01d842eb304fff361d72a090113ffc9f" name="a01d842eb304fff361d72a090113ffc9f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a01d842eb304fff361d72a090113ffc9f">&#9670;&nbsp;</a></span>allow_sends()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool ipc::transport::Posix_mq_handle::allow_sends </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Implements <a class="el" href="classipc_1_1transport_1_1Persistent__mq__handle.html" title="A documentation-only concept defining the behavior of an object representing a light-weight handle to...">Persistent_mq_handle</a> API: Turn off preemptive/concurrent interruption of blocking-sends and sendable-waits/polls. </p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classipc_1_1transport_1_1Persistent__mq__handle.html#af43b22d89c5a228c2a72c321c2e24545" title="Disables mode enabled by interrupt_sends().">Persistent_mq_handle::allow_sends()</a>: implemented concept.</dd></dl>
<h3>INFO+ logging</h3>
<p >WARNING on duplicate use, INFO otherwise.</p>
<dl class="section return"><dt>Returns</dt><dd>See above. </dd></dl>

</div>
</div>
<a id="a1df87fc56734cb902a71340eab6c0303" name="a1df87fc56734cb902a71340eab6c0303"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1df87fc56734cb902a71340eab6c0303">&#9670;&nbsp;</a></span>for_each_persistent()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Handle_name_func &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void ipc::transport::Posix_mq_handle::for_each_persistent </td>
          <td>(</td>
          <td class="paramtype">const Handle_name_func &amp;&#160;</td>
          <td class="paramname"><em>handle_name_func</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Implements <a class="el" href="classipc_1_1transport_1_1Persistent__mq__handle.html" title="A documentation-only concept defining the behavior of an object representing a light-weight handle to...">Persistent_mq_handle</a> API. </p>
<p >Impl note for exposition: we use the fact that, e.g., in Linux the POSIX MQ devices are listed in flat fashion in /dev/mqueue.</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classipc_1_1transport_1_1Persistent__mq__handle.html#ac14dd419cdbc97b6630900268f8b7dd2" title="Lists all named persistent MQs currently persisting, invoking the given handler synchronously on each...">Persistent_mq_handle::for_each_persistent()</a>: implemented concept.</dd></dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Handle_name_func</td><td>See above. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">handle_name_func</td><td>See above. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a02262faa0f53b5518db359b4e5968b47" name="a02262faa0f53b5518db359b4e5968b47"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a02262faa0f53b5518db359b4e5968b47">&#9670;&nbsp;</a></span>interrupt_receives()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool ipc::transport::Posix_mq_handle::interrupt_receives </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Implements <a class="el" href="classipc_1_1transport_1_1Persistent__mq__handle.html" title="A documentation-only concept defining the behavior of an object representing a light-weight handle to...">Persistent_mq_handle</a> API: Turn on preemptive/concurrent interruption of blocking-receives and receivable-waits/polls. </p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classipc_1_1transport_1_1Persistent__mq__handle.html#a206333d3eb619588d17812f8f49013a2" title="Enables receives-interrupted mode: is_receivable() (future calls), receive() (future or concurrent ca...">Persistent_mq_handle::interrupt_receives()</a>: implemented concept.</dd></dl>
<h3>INFO+ logging</h3>
<p >WARNING on duplicate use, INFO otherwise.</p>
<dl class="section return"><dt>Returns</dt><dd>See above. </dd></dl>

</div>
</div>
<a id="a0afe8a636902116223b4f33f081119df" name="a0afe8a636902116223b4f33f081119df"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0afe8a636902116223b4f33f081119df">&#9670;&nbsp;</a></span>interrupt_sends()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool ipc::transport::Posix_mq_handle::interrupt_sends </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Implements <a class="el" href="classipc_1_1transport_1_1Persistent__mq__handle.html" title="A documentation-only concept defining the behavior of an object representing a light-weight handle to...">Persistent_mq_handle</a> API: Turn on preemptive/concurrent interruption of blocking-sends and sendable-waits/polls. </p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classipc_1_1transport_1_1Persistent__mq__handle.html#af7a883553df39b16047b49942bd734c0" title="Enables sends-interrupted mode: is_sendable() (future calls), send() (future or concurrent calls),...">Persistent_mq_handle::interrupt_sends()</a>: implemented concept.</dd></dl>
<h3>INFO+ logging</h3>
<p >WARNING on duplicate use, INFO otherwise.</p>
<dl class="section return"><dt>Returns</dt><dd>See above. </dd></dl>

</div>
</div>
<a id="a399bb25dbcfa06437b2f50abcc1500d1" name="a399bb25dbcfa06437b2f50abcc1500d1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a399bb25dbcfa06437b2f50abcc1500d1">&#9670;&nbsp;</a></span>is_receivable()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool ipc::transport::Posix_mq_handle::is_receivable </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespaceipc.html#aa3192e586cc45d3e7c22463bf2760f89">Error_code</a> *&#160;</td>
          <td class="paramname"><em>err_code</em> = <code>0</code></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Implements <a class="el" href="classipc_1_1transport_1_1Persistent__mq__handle.html" title="A documentation-only concept defining the behavior of an object representing a light-weight handle to...">Persistent_mq_handle</a> API: Like <a class="el" href="classipc_1_1transport_1_1Posix__mq__handle.html#abe9a423ceda292d5b01b54039102170b" title="Implements Persistent_mq_handle API: Non-blocking receive: pops copy of message from queue into buffe...">try_receive()</a> but without the actual popping of a message. </p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classipc_1_1transport_1_1Persistent__mq__handle.html#acdf4279219020020b1d8b3ff8a80cbe2" title="Equivalent to try_receive() except stops short of reading anything, with true result indicating that ...">Persistent_mq_handle::is_receivable()</a>: implemented concept.</dd></dl>
<h3>INFO+ logging</h3>
<p >WARNING on error.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">err_code</td><td>See above. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>See above. </dd></dl>

</div>
</div>
<a id="a409b0d91e57c994341d900f840e75bb4" name="a409b0d91e57c994341d900f840e75bb4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a409b0d91e57c994341d900f840e75bb4">&#9670;&nbsp;</a></span>is_sendable()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool ipc::transport::Posix_mq_handle::is_sendable </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespaceipc.html#aa3192e586cc45d3e7c22463bf2760f89">Error_code</a> *&#160;</td>
          <td class="paramname"><em>err_code</em> = <code>0</code></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Implements <a class="el" href="classipc_1_1transport_1_1Persistent__mq__handle.html" title="A documentation-only concept defining the behavior of an object representing a light-weight handle to...">Persistent_mq_handle</a> API: Like <a class="el" href="classipc_1_1transport_1_1Posix__mq__handle.html#a5787b3fe1eb2a7f5f6abda8b9536529b" title="Implements Persistent_mq_handle API: Non-blocking send: pushes copy of message to queue and returns t...">try_send()</a> but without the actual pushing of a message. </p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classipc_1_1transport_1_1Persistent__mq__handle.html#ab95e3d32a7ad3fa3630ba54442d8f2ee" title="Equivalent to try_send() except stops short of writing anything, with true result indicating that try...">Persistent_mq_handle::is_sendable()</a>: implemented concept.</dd></dl>
<h3>INFO+ logging</h3>
<p >WARNING on error.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">err_code</td><td>See above. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>See above. </dd></dl>

</div>
</div>
<a id="a412e7c922909eeb5707bb0abe6e27a76" name="a412e7c922909eeb5707bb0abe6e27a76"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a412e7c922909eeb5707bb0abe6e27a76">&#9670;&nbsp;</a></span>max_msg_size()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t ipc::transport::Posix_mq_handle::max_msg_size </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Implements <a class="el" href="classipc_1_1transport_1_1Persistent__mq__handle.html" title="A documentation-only concept defining the behavior of an object representing a light-weight handle to...">Persistent_mq_handle</a> API: Returns the max message size of the underlying queue. </p>
<p >Reminder: This is not required to match was was passed to <code>Create_only</code> or <code>Open_or_create</code> ctor.</p>
<dl class="section return"><dt>Returns</dt><dd>See above. </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classipc_1_1transport_1_1Persistent__mq__handle.html#ae2efe92707c53c46bc70b84f96bda217" title="Returns the max message size of the underlying queue.">Persistent_mq_handle::max_msg_size()</a>: implemented concept. </dd></dl>

</div>
</div>
<a id="a514dbdda12ec70ea1ff65abfa6237ce2" name="a514dbdda12ec70ea1ff65abfa6237ce2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a514dbdda12ec70ea1ff65abfa6237ce2">&#9670;&nbsp;</a></span>max_n_msgs()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t ipc::transport::Posix_mq_handle::max_n_msgs </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Implements <a class="el" href="classipc_1_1transport_1_1Persistent__mq__handle.html" title="A documentation-only concept defining the behavior of an object representing a light-weight handle to...">Persistent_mq_handle</a> API: Returns the max message count of the underlying queue. </p>
<p >Reminder: This is not required to match was was passed to <code>Create_only</code> or <code>Open_or_create</code> ctor.</p>
<dl class="section return"><dt>Returns</dt><dd>See above. </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classipc_1_1transport_1_1Persistent__mq__handle.html#a22575a5750d322ccf87a923a3d662756" title="Returns the max message count of the underlying queue.">Persistent_mq_handle::max_n_msgs()</a>: implemented concept. </dd></dl>

</div>
</div>
<a id="a62bc5410c9928099dff46ba021acb879" name="a62bc5410c9928099dff46ba021acb879"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a62bc5410c9928099dff46ba021acb879">&#9670;&nbsp;</a></span>native_handle()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespaceipc_1_1transport.html#a7ee4551983d9df16ec16a3139bac50e8">Native_handle</a> ipc::transport::Posix_mq_handle::native_handle </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Implements <a class="el" href="classipc_1_1transport_1_1Persistent__mq__handle.html" title="A documentation-only concept defining the behavior of an object representing a light-weight handle to...">Persistent_mq_handle</a> API: Returns the stored native MQ handle; null if not open. </p>
<dl class="section return"><dt>Returns</dt><dd>See above. </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classipc_1_1transport_1_1Persistent__mq__handle.html#a25e96c4f060cc3c4b611c4e2de60abaf" title="Available if and only if S_HAS_NATIVE_HANDLE is true: Returns the stored native MQ handle; null means...">Persistent_mq_handle::native_handle()</a>: implemented concept. </dd></dl>

</div>
</div>
<a id="aeec1f1528e8d51e85f0cbb784ea23e4b" name="aeec1f1528e8d51e85f0cbb784ea23e4b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aeec1f1528e8d51e85f0cbb784ea23e4b">&#9670;&nbsp;</a></span>operator=()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classipc_1_1transport_1_1Posix__mq__handle.html">Posix_mq_handle</a> &amp; ipc::transport::Posix_mq_handle::operator= </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classipc_1_1transport_1_1Posix__mq__handle.html">Posix_mq_handle</a> &amp;&amp;&#160;</td>
          <td class="paramname"><em>src</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Implements <a class="el" href="classipc_1_1transport_1_1Persistent__mq__handle.html" title="A documentation-only concept defining the behavior of an object representing a light-weight handle to...">Persistent_mq_handle</a> API: Replaces handle with the source handle while making the latter invalid as-if default-cted. </p>
<p >Reminder, informally: this is a light-weight op.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">src</td><td>See above. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>*this</code>. </dd></dl>

</div>
</div>
<a id="a65f35bfe249b13dc3bc0442d10a55a0f" name="a65f35bfe249b13dc3bc0442d10a55a0f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a65f35bfe249b13dc3bc0442d10a55a0f">&#9670;&nbsp;</a></span>receive()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ipc::transport::Posix_mq_handle::receive </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespaceipc_1_1util.html#a6cb62ae434900f3a8915b33ec5d61a96">util::Blob_mutable</a> *&#160;</td>
          <td class="paramname"><em>blob</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceipc.html#aa3192e586cc45d3e7c22463bf2760f89">Error_code</a> *&#160;</td>
          <td class="paramname"><em>err_code</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Implements <a class="el" href="classipc_1_1transport_1_1Persistent__mq__handle.html" title="A documentation-only concept defining the behavior of an object representing a light-weight handle to...">Persistent_mq_handle</a> API: Blocking receive: pops copy of message from queue into buffer; if queue is empty blocks until it is not. </p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classipc_1_1transport_1_1Persistent__mq__handle.html#ae1e6822d16d30dc57c95e3e051e5f8a8" title="Blocking receive: pops copy of message from queue into buffer; if queue is empty blocks until it is n...">Persistent_mq_handle::receive()</a>: implemented concept.</dd></dl>
<h3>INFO+ logging</h3>
<p >WARNING on error. (You may use the <code>flow::log::Config::this_thread_verbosity_override_auto()</code> to temporarily, in that thread only, disable/reduce logging. This is quite easy and performant.)</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">blob</td><td>See above. </td></tr>
    <tr><td class="paramname">err_code</td><td>See above. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a658271ad982e3e0af4c3666b947019cc" name="a658271ad982e3e0af4c3666b947019cc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a658271ad982e3e0af4c3666b947019cc">&#9670;&nbsp;</a></span>remove_persistent()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void ipc::transport::Posix_mq_handle::remove_persistent </td>
          <td>(</td>
          <td class="paramtype">flow::log::Logger *&#160;</td>
          <td class="paramname"><em>logger_ptr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespaceipc_1_1transport.html#a33de1c256addb3964b839dc2dd407d24">Shared_name</a> &amp;&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceipc.html#aa3192e586cc45d3e7c22463bf2760f89">Error_code</a> *&#160;</td>
          <td class="paramname"><em>err_code</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Implements <a class="el" href="classipc_1_1transport_1_1Persistent__mq__handle.html" title="A documentation-only concept defining the behavior of an object representing a light-weight handle to...">Persistent_mq_handle</a> API: Removes the named persistent MQ. </p>
<p >Reminder: name is removed immediately (if present &ndash; otherwise error), but underlying MQ continues to exist until all system-wide handles to it are closed.</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classipc_1_1transport_1_1Persistent__mq__handle.html#a2e8b8102fdbacc064d4759533a725f51" title="Removes the named persistent MQ.">Persistent_mq_handle::remove_persistent()</a>: implemented concept.</dd>
<dd>
Reminder: see also <code>util::remove_each_persistent_*()</code>.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">logger_ptr</td><td>See above. </td></tr>
    <tr><td class="paramname">name</td><td>See above. </td></tr>
    <tr><td class="paramname">err_code</td><td>See above. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a6e9b11537c7c83f43728aca7af348a42" name="a6e9b11537c7c83f43728aca7af348a42"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6e9b11537c7c83f43728aca7af348a42">&#9670;&nbsp;</a></span>send()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ipc::transport::Posix_mq_handle::send </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespaceipc_1_1util.html#ae0be7edba7e30ffa3f8b742af621f2ab">util::Blob_const</a> &amp;&#160;</td>
          <td class="paramname"><em>blob</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceipc.html#aa3192e586cc45d3e7c22463bf2760f89">Error_code</a> *&#160;</td>
          <td class="paramname"><em>err_code</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Implements <a class="el" href="classipc_1_1transport_1_1Persistent__mq__handle.html" title="A documentation-only concept defining the behavior of an object representing a light-weight handle to...">Persistent_mq_handle</a> API: Blocking send: pushes copy of message to queue; if queue is full blocks until it is not. </p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classipc_1_1transport_1_1Persistent__mq__handle.html#a9d54e47b729eec9f72dee869326bfa8f" title="Blocking send: pushes copy of message to queue; if queue is full blocks until it is not.">Persistent_mq_handle::send()</a>: implemented concept.</dd></dl>
<h3>INFO+ logging</h3>
<p >WARNING on error. (You may use the <code>flow::log::Config::this_thread_verbosity_override_auto()</code> to temporarily, in that thread only, disable/reduce logging. This is quite easy and performant.)</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">blob</td><td>See above. </td></tr>
    <tr><td class="paramname">err_code</td><td>See above. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aa853452d0d0aeeaf61461cc8a48b5c09" name="aa853452d0d0aeeaf61461cc8a48b5c09"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa853452d0d0aeeaf61461cc8a48b5c09">&#9670;&nbsp;</a></span>timed_receive()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool ipc::transport::Posix_mq_handle::timed_receive </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespaceipc_1_1util.html#a6cb62ae434900f3a8915b33ec5d61a96">util::Blob_mutable</a> *&#160;</td>
          <td class="paramname"><em>blob</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceipc_1_1util.html#ac66141280c3b7295a86b65209f31cc58">util::Fine_duration</a>&#160;</td>
          <td class="paramname"><em>timeout_from_now</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceipc.html#aa3192e586cc45d3e7c22463bf2760f89">Error_code</a> *&#160;</td>
          <td class="paramname"><em>err_code</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Implements <a class="el" href="classipc_1_1transport_1_1Persistent__mq__handle.html" title="A documentation-only concept defining the behavior of an object representing a light-weight handle to...">Persistent_mq_handle</a> API: Blocking timed receive: pops copy of message from queue into buffer; if queue is empty blocks until it is not, or the specified time passes, whichever happens first. </p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classipc_1_1transport_1_1Persistent__mq__handle.html#af547b6f1b1e51a7d6f6fbafc14c95f9d" title="Blocking timed receive: pops copy of message from queue into buffer; if queue is empty blocks until i...">Persistent_mq_handle::timed_receive()</a>: implemented concept.</dd></dl>
<h3>INFO+ logging</h3>
<p >WARNING on error or timed out. (You may use the <code>flow::log::Config::this_thread_verbosity_override_auto()</code> to temporarily, in that thread only, disable/reduce logging. This is quite easy and performant.)</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">blob</td><td>See above. </td></tr>
    <tr><td class="paramname">timeout_from_now</td><td>See above. </td></tr>
    <tr><td class="paramname">err_code</td><td>See above. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>See above. </dd></dl>

</div>
</div>
<a id="abe2b3968c60945224ddfce119bcae018" name="abe2b3968c60945224ddfce119bcae018"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abe2b3968c60945224ddfce119bcae018">&#9670;&nbsp;</a></span>timed_send()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool ipc::transport::Posix_mq_handle::timed_send </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespaceipc_1_1util.html#ae0be7edba7e30ffa3f8b742af621f2ab">util::Blob_const</a> &amp;&#160;</td>
          <td class="paramname"><em>blob</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceipc_1_1util.html#ac66141280c3b7295a86b65209f31cc58">util::Fine_duration</a>&#160;</td>
          <td class="paramname"><em>timeout_from_now</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceipc.html#aa3192e586cc45d3e7c22463bf2760f89">Error_code</a> *&#160;</td>
          <td class="paramname"><em>err_code</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Implements <a class="el" href="classipc_1_1transport_1_1Persistent__mq__handle.html" title="A documentation-only concept defining the behavior of an object representing a light-weight handle to...">Persistent_mq_handle</a> API: Blocking timed send: pushes copy of message to queue; if queue is full blocks until it is not, or the specified time passes, whichever happens first. </p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classipc_1_1transport_1_1Persistent__mq__handle.html#ab4cba10b83df79acf76c64b0deb7f624" title="Blocking timed send: pushes copy of message to queue; if queue is full blocks until it is not,...">Persistent_mq_handle::timed_send()</a>: implemented concept.</dd></dl>
<h3>INFO+ logging</h3>
<p >WARNING on error or timed out. (You may use the <code>flow::log::Config::this_thread_verbosity_override_auto()</code> to temporarily, in that thread only, disable/reduce logging. This is quite easy and performant.)</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">blob</td><td>See above. </td></tr>
    <tr><td class="paramname">timeout_from_now</td><td>See above. </td></tr>
    <tr><td class="paramname">err_code</td><td>See above. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>See above. </dd></dl>

</div>
</div>
<a id="a64079f1c9315af2e75e808b6ae5312e5" name="a64079f1c9315af2e75e808b6ae5312e5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a64079f1c9315af2e75e808b6ae5312e5">&#9670;&nbsp;</a></span>timed_wait_receivable()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool ipc::transport::Posix_mq_handle::timed_wait_receivable </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespaceipc_1_1util.html#ac66141280c3b7295a86b65209f31cc58">util::Fine_duration</a>&#160;</td>
          <td class="paramname"><em>timeout_from_now</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceipc.html#aa3192e586cc45d3e7c22463bf2760f89">Error_code</a> *&#160;</td>
          <td class="paramname"><em>err_code</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Implements <a class="el" href="classipc_1_1transport_1_1Persistent__mq__handle.html" title="A documentation-only concept defining the behavior of an object representing a light-weight handle to...">Persistent_mq_handle</a> API: Like <a class="el" href="classipc_1_1transport_1_1Posix__mq__handle.html#aa853452d0d0aeeaf61461cc8a48b5c09" title="Implements Persistent_mq_handle API: Blocking timed receive: pops copy of message from queue into buf...">timed_receive()</a> but without the actual popping of a message. </p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classipc_1_1transport_1_1Persistent__mq__handle.html#ac4f13853e38ade577faabbf9ef0af74f" title="Equivalent to timed_receive() except stops short of reading anything, with true result indicating tha...">Persistent_mq_handle::timed_wait_receivable()</a>: implemented concept.</dd></dl>
<h3>INFO+ logging</h3>
<p >WARNING on error.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">err_code</td><td>See above. </td></tr>
    <tr><td class="paramname">timeout_from_now</td><td>See above. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>See above. </dd></dl>

</div>
</div>
<a id="aa46ffcc8019c998313c18ed05b7c6ad3" name="aa46ffcc8019c998313c18ed05b7c6ad3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa46ffcc8019c998313c18ed05b7c6ad3">&#9670;&nbsp;</a></span>timed_wait_sendable()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool ipc::transport::Posix_mq_handle::timed_wait_sendable </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespaceipc_1_1util.html#ac66141280c3b7295a86b65209f31cc58">util::Fine_duration</a>&#160;</td>
          <td class="paramname"><em>timeout_from_now</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceipc.html#aa3192e586cc45d3e7c22463bf2760f89">Error_code</a> *&#160;</td>
          <td class="paramname"><em>err_code</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Implements <a class="el" href="classipc_1_1transport_1_1Persistent__mq__handle.html" title="A documentation-only concept defining the behavior of an object representing a light-weight handle to...">Persistent_mq_handle</a> API: Like <a class="el" href="classipc_1_1transport_1_1Posix__mq__handle.html#abe2b3968c60945224ddfce119bcae018" title="Implements Persistent_mq_handle API: Blocking timed send: pushes copy of message to queue; if queue i...">timed_send()</a> but without the actual pushing of a message. </p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classipc_1_1transport_1_1Persistent__mq__handle.html#aadfffb71ff2fec6508174fdf4b08327e" title="Equivalent to timed_send() except stops short of writing anything, with true result indicating that t...">Persistent_mq_handle::timed_wait_sendable()</a>: implemented concept.</dd></dl>
<h3>INFO+ logging</h3>
<p >WARNING on error.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">err_code</td><td>See above. </td></tr>
    <tr><td class="paramname">timeout_from_now</td><td>See above. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>See above. </dd></dl>

</div>
</div>
<a id="abe9a423ceda292d5b01b54039102170b" name="abe9a423ceda292d5b01b54039102170b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abe9a423ceda292d5b01b54039102170b">&#9670;&nbsp;</a></span>try_receive()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool ipc::transport::Posix_mq_handle::try_receive </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespaceipc_1_1util.html#a6cb62ae434900f3a8915b33ec5d61a96">util::Blob_mutable</a> *&#160;</td>
          <td class="paramname"><em>blob</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceipc.html#aa3192e586cc45d3e7c22463bf2760f89">Error_code</a> *&#160;</td>
          <td class="paramname"><em>err_code</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Implements <a class="el" href="classipc_1_1transport_1_1Persistent__mq__handle.html" title="A documentation-only concept defining the behavior of an object representing a light-weight handle to...">Persistent_mq_handle</a> API: Non-blocking receive: pops copy of message from queue into buffer and returns <code>true</code>; if queue is empty then no-op and returns <code>false</code>. </p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classipc_1_1transport_1_1Persistent__mq__handle.html#a84f802c77b0ce93d59e7ac78839f14cc" title="Non-blocking receive: pops copy of message from queue into buffer and returns true; if queue is empty...">Persistent_mq_handle::try_receive()</a>: implemented concept.</dd></dl>
<h3>INFO+ logging</h3>
<p >WARNING on error. (You may use the <code>flow::log::Config::this_thread_verbosity_override_auto()</code> to temporarily, in that thread only, disable/reduce logging. This is quite easy and performant.)</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">blob</td><td>See above. </td></tr>
    <tr><td class="paramname">err_code</td><td>See above. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>See above. </dd></dl>

</div>
</div>
<a id="a5787b3fe1eb2a7f5f6abda8b9536529b" name="a5787b3fe1eb2a7f5f6abda8b9536529b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5787b3fe1eb2a7f5f6abda8b9536529b">&#9670;&nbsp;</a></span>try_send()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool ipc::transport::Posix_mq_handle::try_send </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespaceipc_1_1util.html#ae0be7edba7e30ffa3f8b742af621f2ab">util::Blob_const</a> &amp;&#160;</td>
          <td class="paramname"><em>blob</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceipc.html#aa3192e586cc45d3e7c22463bf2760f89">Error_code</a> *&#160;</td>
          <td class="paramname"><em>err_code</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Implements <a class="el" href="classipc_1_1transport_1_1Persistent__mq__handle.html" title="A documentation-only concept defining the behavior of an object representing a light-weight handle to...">Persistent_mq_handle</a> API: Non-blocking send: pushes copy of message to queue and returns <code>true</code>; if queue is full then no-op and returns <code>false</code>. </p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classipc_1_1transport_1_1Persistent__mq__handle.html#ad9d38e0e16931dd96738d53b787533a1" title="Non-blocking send: pushes copy of message to queue and returns true; if queue is full then no-op and ...">Persistent_mq_handle::try_send()</a>: implemented concept.</dd></dl>
<h3>INFO+ logging</h3>
<p >WARNING on error. (You may use the <code>flow::log::Config::this_thread_verbosity_override_auto()</code> to temporarily, in that thread only, disable/reduce logging. This is quite easy and performant.)</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">blob</td><td>See above. </td></tr>
    <tr><td class="paramname">err_code</td><td>See above. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>See above. </dd></dl>

</div>
</div>
<a id="a0f93df71d0c476e17b32ca4d6bf82b9b" name="a0f93df71d0c476e17b32ca4d6bf82b9b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0f93df71d0c476e17b32ca4d6bf82b9b">&#9670;&nbsp;</a></span>wait_receivable()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ipc::transport::Posix_mq_handle::wait_receivable </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespaceipc.html#aa3192e586cc45d3e7c22463bf2760f89">Error_code</a> *&#160;</td>
          <td class="paramname"><em>err_code</em> = <code>0</code></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Implements <a class="el" href="classipc_1_1transport_1_1Persistent__mq__handle.html" title="A documentation-only concept defining the behavior of an object representing a light-weight handle to...">Persistent_mq_handle</a> API: Like <a class="el" href="classipc_1_1transport_1_1Posix__mq__handle.html#a65f35bfe249b13dc3bc0442d10a55a0f" title="Implements Persistent_mq_handle API: Blocking receive: pops copy of message from queue into buffer; i...">receive()</a> but without the actual popping of a message. </p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classipc_1_1transport_1_1Persistent__mq__handle.html#a7029f9601aa268022bd8cf7970c512c8" title="Equivalent to receive() except stops short of reading anything, with non-error return indicating that...">Persistent_mq_handle::wait_receivable()</a>: implemented concept.</dd></dl>
<h3>INFO+ logging</h3>
<p >WARNING on error.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">err_code</td><td>See above. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="acf32c33a96d66436628153c74d4a8eb9" name="acf32c33a96d66436628153c74d4a8eb9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acf32c33a96d66436628153c74d4a8eb9">&#9670;&nbsp;</a></span>wait_sendable()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ipc::transport::Posix_mq_handle::wait_sendable </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespaceipc.html#aa3192e586cc45d3e7c22463bf2760f89">Error_code</a> *&#160;</td>
          <td class="paramname"><em>err_code</em> = <code>0</code></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Implements <a class="el" href="classipc_1_1transport_1_1Persistent__mq__handle.html" title="A documentation-only concept defining the behavior of an object representing a light-weight handle to...">Persistent_mq_handle</a> API: Like <a class="el" href="classipc_1_1transport_1_1Posix__mq__handle.html#a6e9b11537c7c83f43728aca7af348a42" title="Implements Persistent_mq_handle API: Blocking send: pushes copy of message to queue; if queue is full...">send()</a> but without the actual pushing of a message. </p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classipc_1_1transport_1_1Persistent__mq__handle.html#a230060aa545bfe11eb263211c84514f1" title="Equivalent to send() except stops short of writing anything, with non-error return indicating that tr...">Persistent_mq_handle::wait_sendable()</a>: implemented concept.</dd></dl>
<h3>INFO+ logging</h3>
<p >WARNING on error.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">err_code</td><td>See above. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<h2 class="groupheader">Friends And Related Function Documentation</h2>
<a id="a8fb9256b66ad3dfdf742de66223466d7" name="a8fb9256b66ad3dfdf742de66223466d7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8fb9256b66ad3dfdf742de66223466d7">&#9670;&nbsp;</a></span>operator&lt;&lt;()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::ostream &amp; operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>os</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classipc_1_1transport_1_1Posix__mq__handle.html">Posix_mq_handle</a> &amp;&#160;</td>
          <td class="paramname"><em>val</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Prints string representation of the given <a class="el" href="classipc_1_1transport_1_1Posix__mq__handle.html" title="Implements the Persistent_mq_handle concept by wrapping the POSIX message queue API (see man mq_overv...">Posix_mq_handle</a> to the given <code>ostream</code>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">os</td><td>Stream to which to write. </td></tr>
    <tr><td class="paramname">val</td><td>Object to serialize. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>os</code>. </dd></dl>

</div>
</div>
<a id="a65015c97813a6609da035fe86d1a36c0" name="a65015c97813a6609da035fe86d1a36c0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a65015c97813a6609da035fe86d1a36c0">&#9670;&nbsp;</a></span>swap()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void swap </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classipc_1_1transport_1_1Posix__mq__handle.html">Posix_mq_handle</a> &amp;&#160;</td>
          <td class="paramname"><em>val1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classipc_1_1transport_1_1Posix__mq__handle.html">Posix_mq_handle</a> &amp;&#160;</td>
          <td class="paramname"><em>val2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Implements <a class="el" href="classipc_1_1transport_1_1Persistent__mq__handle.html" title="A documentation-only concept defining the behavior of an object representing a light-weight handle to...">Persistent_mq_handle</a> related concept: Swaps two objects. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">val1</td><td>Object. </td></tr>
    <tr><td class="paramname">val2</td><td>Object. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<hr/>The documentation for this class was generated from the following files:<ul>
<li>transport/<a class="el" href="posix__mq__handle_8hpp.html">posix_mq_handle.hpp</a></li>
<li>transport/<a class="el" href="posix__mq__handle_8cpp.html">posix_mq_handle.cpp</a></li>
<li>transport/<a class="el" href="transport__fwd_8hpp.html">transport_fwd.hpp</a></li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Wed Mar 6 2024 08:59:58 for Flow-IPC by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.4
</small></address>
</body>
</html>
