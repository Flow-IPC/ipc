<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.9.4"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Flow-IPC: ipc::session::shm::classic::Session_server&lt; S_MQ_TYPE_OR_NONE, S_TRANSMIT_NATIVE_HANDLES, Mdt_payload &gt; Class Template Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">Flow-IPC<span id="projectnumber">&#160;1.0.2</span>
   </div>
   <div id="projectbrief">Flow-IPC project: Public API.</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.4 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search",'Search','.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespaceipc.html">ipc</a></li><li class="navelem"><a class="el" href="namespaceipc_1_1session.html">session</a></li><li class="navelem"><a class="el" href="namespaceipc_1_1session_1_1shm.html">shm</a></li><li class="navelem"><a class="el" href="namespaceipc_1_1session_1_1shm_1_1classic.html">classic</a></li><li class="navelem"><a class="el" href="classipc_1_1session_1_1shm_1_1classic_1_1Session__server.html">Session_server</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-types">Public Types</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#related">Related Functions</a> &#124;
<a href="classipc_1_1session_1_1shm_1_1classic_1_1Session__server-members.html">List of all members</a>  </div>
  <div class="headertitle"><div class="title">ipc::session::shm::classic::Session_server&lt; S_MQ_TYPE_OR_NONE, S_TRANSMIT_NATIVE_HANDLES, Mdt_payload &gt; Class Template Reference</div></div>
</div><!--header-->
<div class="contents">

<p>This is to vanilla <a class="el" href="classipc_1_1session_1_1shm_1_1classic_1_1Session__server.html" title="This is to vanilla Session_server what shm::classic::Server_session is to vanilla Server_session: it ...">Session_server</a> what <a class="el" href="classipc_1_1session_1_1shm_1_1classic_1_1Server__session.html" title="Identical to session::Server_session in every way, except that it makes available two SHM arenas,...">shm::classic::Server_session</a> is to vanilla <a class="el" href="namespaceipc_1_1session.html#ab01d5bce0ab2f3435ca9dd88d27609dc" title="A vanilla Server_session with no optional capabilities.">Server_session</a>: it is the session-server type that starts SHM-enabled sessions with SHM-classic provider (<a class="el" href="classipc_1_1shm_1_1classic_1_1Pool__arena.html" title="A SHM-classic interface around a single SHM pool with allocation-algorithm services by boost....">ipc::shm::classic::Pool_arena</a>).  
 <a href="classipc_1_1session_1_1shm_1_1classic_1_1Session__server.html#details">More...</a></p>

<p><code>#include &lt;session_server.hpp&gt;</code></p>

<p>Inherits Session_server_impl&lt; Session_server&lt; S_MQ_TYPE_OR_NONE, S_TRANSMIT_NATIVE_HANDLES, Mdt_payload &gt;, Server_session&lt; S_MQ_TYPE_OR_NONE, S_TRANSMIT_NATIVE_HANDLES, Mdt_payload &gt; &gt;.</p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-types" name="pub-types"></a>
Public Types</h2></td></tr>
<tr class="memitem:a2330c13a2c20303d4be4adfe4c74b2b9"><td class="memItemLeft" align="right" valign="top"><a id="a2330c13a2c20303d4be4adfe4c74b2b9" name="a2330c13a2c20303d4be4adfe4c74b2b9"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>Server_session_obj</b> = <a class="el" href="classipc_1_1session_1_1shm_1_1classic_1_1Server__session.html">shm::classic::Server_session</a>&lt; S_MQ_TYPE_OR_NONE, S_TRANSMIT_NATIVE_HANDLES, Mdt_payload &gt;</td></tr>
<tr class="memdesc:a2330c13a2c20303d4be4adfe4c74b2b9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Short-hand for the concrete <code><a class="el" href="classipc_1_1session_1_1shm_1_1classic_1_1Server__session.html" title="Identical to session::Server_session in every way, except that it makes available two SHM arenas,...">Server_session</a></code>-like type emitted by <a class="el" href="classipc_1_1session_1_1shm_1_1classic_1_1Session__server.html#ac6733bac776ecd2995f41cb0feb81d63" title="Contract identical to simpler session::Session_server::async_accept() overload; but internally ensure...">async_accept()</a>. <br /></td></tr>
<tr class="separator:a2330c13a2c20303d4be4adfe4c74b2b9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aff4a736c67698d14a538276912e6101d"><td class="memItemLeft" align="right" valign="top"><a id="aff4a736c67698d14a538276912e6101d" name="aff4a736c67698d14a538276912e6101d"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>Mdt_reader_ptr</b> = typename Impl::Mdt_reader_ptr</td></tr>
<tr class="memdesc:aff4a736c67698d14a538276912e6101d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Short-hand for <a class="el" href="classipc_1_1session_1_1Session__mv.html#a2b1215fb0c9738b9fcfbb337d23c43df" title="Implements Session API per contract.">Session_mv::Mdt_reader_ptr</a>. <br /></td></tr>
<tr class="separator:aff4a736c67698d14a538276912e6101d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a81f60d9c8af965468c0887a2af4e2823"><td class="memItemLeft" align="right" valign="top"><a id="a81f60d9c8af965468c0887a2af4e2823" name="a81f60d9c8af965468c0887a2af4e2823"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>Mdt_builder</b> = typename Server_session_obj::Mdt_builder</td></tr>
<tr class="memdesc:a81f60d9c8af965468c0887a2af4e2823"><td class="mdescLeft">&#160;</td><td class="mdescRight">Metadata builder type passed to <code>mdt_load_func()</code> in advanced <a class="el" href="classipc_1_1session_1_1shm_1_1classic_1_1Session__server.html#ac6733bac776ecd2995f41cb0feb81d63" title="Contract identical to simpler session::Session_server::async_accept() overload; but internally ensure...">async_accept()</a> overload. <br /></td></tr>
<tr class="separator:a81f60d9c8af965468c0887a2af4e2823"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab8f638542f33b5028e1db7ce7572fef3"><td class="memItemLeft" align="right" valign="top"><a id="ab8f638542f33b5028e1db7ce7572fef3" name="ab8f638542f33b5028e1db7ce7572fef3"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>Channels</b> = typename Impl::Channels</td></tr>
<tr class="memdesc:ab8f638542f33b5028e1db7ce7572fef3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Short-hand for <a class="el" href="classipc_1_1session_1_1Session__mv.html#af87da439644b2afd73d6a13d97e7985f" title="Container (vector&lt;&gt;) of Channel_obj.">Session_mv::Channels</a>. <br /></td></tr>
<tr class="separator:ab8f638542f33b5028e1db7ce7572fef3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae4d637a7d4082c639b7ef7654cc616f3"><td class="memItemLeft" align="right" valign="top"><a id="ae4d637a7d4082c639b7ef7654cc616f3" name="ae4d637a7d4082c639b7ef7654cc616f3"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>Arena</b> = typename <a class="el" href="classipc_1_1session_1_1shm_1_1classic_1_1Session__mv.html#a07c9b1803567c2714ae48433e756047f">Server_session_obj::Base::Arena</a></td></tr>
<tr class="memdesc:ae4d637a7d4082c639b7ef7654cc616f3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Short-hand for <a class="el" href="classipc_1_1session_1_1shm_1_1classic_1_1Session__mv.html#a07c9b1803567c2714ae48433e756047f" title="The arena object on which one may call construct&lt;T&gt;(ctor_args...), where ctor_args are arguments to t...">shm::classic::Session_mv::Arena</a>. See <a class="el" href="classipc_1_1session_1_1shm_1_1classic_1_1Session__server.html#ae3e011716068f4e669bd7eed487cf207" title="Returns pointer to the per-app SHM-arena, whose lifetime extends until *this is destroyed; or null if...">app_shm()</a> in particular. <br /></td></tr>
<tr class="separator:ae4d637a7d4082c639b7ef7654cc616f3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2f814f83d98f8841f9dc01c7d8594bb2"><td class="memItemLeft" align="right" valign="top"><a id="a2f814f83d98f8841f9dc01c7d8594bb2" name="a2f814f83d98f8841f9dc01c7d8594bb2"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>Structured_msg_builder_config</b> = typename <a class="el" href="classipc_1_1session_1_1shm_1_1classic_1_1Session__mv.html#a23d60bbc945c72cd6f19fdadd7ce014d">Server_session_obj::Base::Structured_msg_builder_config</a></td></tr>
<tr class="memdesc:a2f814f83d98f8841f9dc01c7d8594bb2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Short-hand for <a class="el" href="classipc_1_1session_1_1shm_1_1classic_1_1Session__mv.html#a23d60bbc945c72cd6f19fdadd7ce014d" title="Implements Session API per contract.">shm::classic::Session_mv::Structured_msg_builder_config</a>. <br /></td></tr>
<tr class="separator:a2f814f83d98f8841f9dc01c7d8594bb2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9b709f4510613328942335b4ba5fb49d"><td class="memItemLeft" align="right" valign="top"><a id="a9b709f4510613328942335b4ba5fb49d" name="a9b709f4510613328942335b4ba5fb49d"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>Structured_msg_reader_config</b> = typename <a class="el" href="classipc_1_1session_1_1shm_1_1classic_1_1Session__mv.html#a2b27e91465c5dbdefcb12a6913a9ad4c">Server_session_obj::Base::Structured_msg_reader_config</a></td></tr>
<tr class="memdesc:a9b709f4510613328942335b4ba5fb49d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Short-hand for <a class="el" href="classipc_1_1session_1_1shm_1_1classic_1_1Session__mv.html#a2b27e91465c5dbdefcb12a6913a9ad4c" title="Implements Session API per contract.">shm::classic::Session_mv::Structured_msg_reader_config</a>. <br /></td></tr>
<tr class="separator:a9b709f4510613328942335b4ba5fb49d"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-methods" name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:af10bb97219c59c34fce50be09eaacf0c"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classipc_1_1session_1_1shm_1_1classic_1_1Session__server.html#af10bb97219c59c34fce50be09eaacf0c">Session_server</a> (flow::log::Logger *logger_ptr, const <a class="el" href="structipc_1_1session_1_1Server__app.html">Server_app</a> &amp;srv_app_ref, const <a class="el" href="structipc_1_1session_1_1Client__app.html#add718cbf6aa1d2abb26fbadcc974a7bd">Client_app::Master_set</a> &amp;cli_app_master_set_ref, <a class="el" href="namespaceipc.html#aa3192e586cc45d3e7c22463bf2760f89">Error_code</a> *err_code=0)</td></tr>
<tr class="memdesc:af10bb97219c59c34fce50be09eaacf0c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructor: identical to <a class="el" href="classipc_1_1session_1_1Session__server.html" title="To be instantiated typically once in a given process, an object of this type asynchronously listens f...">session::Session_server</a> ctor.  <a href="classipc_1_1session_1_1shm_1_1classic_1_1Session__server.html#af10bb97219c59c34fce50be09eaacf0c">More...</a><br /></td></tr>
<tr class="separator:af10bb97219c59c34fce50be09eaacf0c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac5246e4ce9df15b963ccde81715473c0"><td class="memItemLeft" align="right" valign="top"><a id="ac5246e4ce9df15b963ccde81715473c0" name="ac5246e4ce9df15b963ccde81715473c0"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>~Session_server</b> ()</td></tr>
<tr class="memdesc:ac5246e4ce9df15b963ccde81715473c0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Destructor: contract is identical to <a class="el" href="classipc_1_1session_1_1Session__server.html" title="To be instantiated typically once in a given process, an object of this type asynchronously listens f...">session::Session_server</a> dtor. <br /></td></tr>
<tr class="separator:ac5246e4ce9df15b963ccde81715473c0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af6472e74db4dee7cf5ce5be55ded4179"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classipc_1_1session_1_1shm_1_1classic_1_1Session__server.html#af6472e74db4dee7cf5ce5be55ded4179">pool_size_limit_mi</a> () const</td></tr>
<tr class="memdesc:af6472e74db4dee7cf5ce5be55ded4179"><td class="mdescLeft">&#160;</td><td class="mdescRight">The pool-size value, in mebibytes, which will be used to size the pool in subsequent <code><a class="el" href="classipc_1_1session_1_1shm_1_1classic_1_1Session__server.html#ac6733bac776ecd2995f41cb0feb81d63" title="Contract identical to simpler session::Session_server::async_accept() overload; but internally ensure...">async_accept()</a></code>s.  <a href="classipc_1_1session_1_1shm_1_1classic_1_1Session__server.html#af6472e74db4dee7cf5ce5be55ded4179">More...</a><br /></td></tr>
<tr class="separator:af6472e74db4dee7cf5ce5be55ded4179"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a855afed179ab8f4b694d9152b94a4f2f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classipc_1_1session_1_1shm_1_1classic_1_1Session__server.html#a855afed179ab8f4b694d9152b94a4f2f">pool_size_limit_mi</a> (size_t limit_mi)</td></tr>
<tr class="memdesc:a855afed179ab8f4b694d9152b94a4f2f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the value as returned by <code><a class="el" href="classipc_1_1session_1_1shm_1_1classic_1_1Session__server.html#af6472e74db4dee7cf5ce5be55ded4179" title="The pool-size value, in mebibytes, which will be used to size the pool in subsequent async_accept()s.">pool_size_limit_mi()</a></code> accessor.  <a href="classipc_1_1session_1_1shm_1_1classic_1_1Session__server.html#a855afed179ab8f4b694d9152b94a4f2f">More...</a><br /></td></tr>
<tr class="separator:a855afed179ab8f4b694d9152b94a4f2f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac6733bac776ecd2995f41cb0feb81d63"><td class="memTemplParams" colspan="2">template&lt;typename Task_err &gt; </td></tr>
<tr class="memitem:ac6733bac776ecd2995f41cb0feb81d63"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classipc_1_1session_1_1shm_1_1classic_1_1Session__server.html#ac6733bac776ecd2995f41cb0feb81d63">async_accept</a> (<a class="el" href="classipc_1_1session_1_1shm_1_1classic_1_1Session__server.html#a2330c13a2c20303d4be4adfe4c74b2b9">Server_session_obj</a> *target_session, Task_err &amp;&amp;on_done_func)</td></tr>
<tr class="memdesc:ac6733bac776ecd2995f41cb0feb81d63"><td class="mdescLeft">&#160;</td><td class="mdescRight">Contract identical to simpler <a class="el" href="classipc_1_1session_1_1Session__server.html#a13887cd64912bb5f5675e2817ff8435f" title="Asynchronously awaits for an opposing Client_session to request session establishment and calls on_do...">session::Session_server::async_accept()</a> overload; but internally ensures that the appropriate SHM-classic arenas are available for use in the emitted <a class="el" href="classipc_1_1session_1_1shm_1_1classic_1_1Session__server.html#a2330c13a2c20303d4be4adfe4c74b2b9" title="Short-hand for the concrete Server_session-like type emitted by async_accept().">Server_session_obj</a>.  <a href="classipc_1_1session_1_1shm_1_1classic_1_1Session__server.html#ac6733bac776ecd2995f41cb0feb81d63">More...</a><br /></td></tr>
<tr class="separator:ac6733bac776ecd2995f41cb0feb81d63"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab77874720a5b252df5b1d6faf5d29bb5"><td class="memTemplParams" colspan="2">template&lt;typename Task_err , typename N_init_channels_by_srv_req_func , typename Mdt_load_func &gt; </td></tr>
<tr class="memitem:ab77874720a5b252df5b1d6faf5d29bb5"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classipc_1_1session_1_1shm_1_1classic_1_1Session__server.html#ab77874720a5b252df5b1d6faf5d29bb5">async_accept</a> (<a class="el" href="classipc_1_1session_1_1shm_1_1classic_1_1Session__server.html#a2330c13a2c20303d4be4adfe4c74b2b9">Server_session_obj</a> *target_session, <a class="el" href="classipc_1_1session_1_1shm_1_1classic_1_1Session__server.html#ab8f638542f33b5028e1db7ce7572fef3">Channels</a> *init_channels_by_srv_req, <a class="el" href="classipc_1_1session_1_1shm_1_1classic_1_1Session__server.html#aff4a736c67698d14a538276912e6101d">Mdt_reader_ptr</a> *mdt_from_cli_or_null, <a class="el" href="classipc_1_1session_1_1shm_1_1classic_1_1Session__server.html#ab8f638542f33b5028e1db7ce7572fef3">Channels</a> *init_channels_by_cli_req, N_init_channels_by_srv_req_func &amp;&amp;n_init_channels_by_srv_req_func, Mdt_load_func &amp;&amp;mdt_load_func, Task_err &amp;&amp;on_done_func)</td></tr>
<tr class="memdesc:ab77874720a5b252df5b1d6faf5d29bb5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Contract identical to advanced <a class="el" href="classipc_1_1session_1_1Session__server.html#a13887cd64912bb5f5675e2817ff8435f" title="Asynchronously awaits for an opposing Client_session to request session establishment and calls on_do...">session::Session_server::async_accept()</a> overload; but internally ensures that the appropriate SHM-classic arenas are available for use in the emitted <a class="el" href="classipc_1_1session_1_1shm_1_1classic_1_1Session__server.html#a2330c13a2c20303d4be4adfe4c74b2b9" title="Short-hand for the concrete Server_session-like type emitted by async_accept().">Server_session_obj</a>.  <a href="classipc_1_1session_1_1shm_1_1classic_1_1Session__server.html#ab77874720a5b252df5b1d6faf5d29bb5">More...</a><br /></td></tr>
<tr class="separator:ab77874720a5b252df5b1d6faf5d29bb5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae3e011716068f4e669bd7eed487cf207"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classipc_1_1session_1_1shm_1_1classic_1_1Session__server.html#ae4d637a7d4082c639b7ef7654cc616f3">Arena</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classipc_1_1session_1_1shm_1_1classic_1_1Session__server.html#ae3e011716068f4e669bd7eed487cf207">app_shm</a> (const <a class="el" href="structipc_1_1session_1_1Client__app.html">Client_app</a> &amp;app)</td></tr>
<tr class="memdesc:ae3e011716068f4e669bd7eed487cf207"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns pointer to the per-<code>app</code> SHM-arena, whose lifetime extends until <code>*this</code> is destroyed; or null if the given <a class="el" href="structipc_1_1session_1_1Client__app.html" title="An App that is used as a client in at least one client-server IPC split.">Client_app</a> has not yet opened at least 1 <a class="el" href="classipc_1_1session_1_1shm_1_1classic_1_1Server__session.html" title="Identical to session::Server_session in every way, except that it makes available two SHM arenas,...">shm::classic::Server_session</a> via <a class="el" href="classipc_1_1session_1_1shm_1_1classic_1_1Session__server.html#ac6733bac776ecd2995f41cb0feb81d63" title="Contract identical to simpler session::Session_server::async_accept() overload; but internally ensure...">async_accept()</a>.  <a href="classipc_1_1session_1_1shm_1_1classic_1_1Session__server.html#ae3e011716068f4e669bd7eed487cf207">More...</a><br /></td></tr>
<tr class="separator:ae3e011716068f4e669bd7eed487cf207"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad0dafea47293d23e079b6b5c5c6a9cef"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classipc_1_1session_1_1shm_1_1classic_1_1Session__server.html#a2f814f83d98f8841f9dc01c7d8594bb2">Structured_msg_builder_config</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classipc_1_1session_1_1shm_1_1classic_1_1Session__server.html#ad0dafea47293d23e079b6b5c5c6a9cef">app_shm_builder_config</a> (const <a class="el" href="structipc_1_1session_1_1Client__app.html">Client_app</a> &amp;app)</td></tr>
<tr class="memdesc:ad0dafea47293d23e079b6b5c5c6a9cef"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns builder config suitable for capnp-serializing out-messages in SHM arena <a class="el" href="classipc_1_1session_1_1shm_1_1classic_1_1Session__server.html#ae3e011716068f4e669bd7eed487cf207" title="Returns pointer to the per-app SHM-arena, whose lifetime extends until *this is destroyed; or null if...">app_shm()</a> for the same <code><a class="el" href="structipc_1_1session_1_1Client__app.html" title="An App that is used as a client in at least one client-server IPC split.">Client_app</a> app</code>.  <a href="classipc_1_1session_1_1shm_1_1classic_1_1Session__server.html#ad0dafea47293d23e079b6b5c5c6a9cef">More...</a><br /></td></tr>
<tr class="separator:ad0dafea47293d23e079b6b5c5c6a9cef"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4bfebd1e36c1b2924b6f84294f7cb10c"><td class="memItemLeft" align="right" valign="top">Structured_msg_builder_config::Builder::Session&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classipc_1_1session_1_1shm_1_1classic_1_1Session__server.html#a4bfebd1e36c1b2924b6f84294f7cb10c">app_shm_lender_session</a> (const <a class="el" href="structipc_1_1session_1_1Client__app.html">Client_app</a> &amp;app)</td></tr>
<tr class="memdesc:a4bfebd1e36c1b2924b6f84294f7cb10c"><td class="mdescLeft">&#160;</td><td class="mdescRight">In short, what <a class="el" href="classipc_1_1session_1_1shm_1_1classic_1_1Session__server.html#ad0dafea47293d23e079b6b5c5c6a9cef" title="Returns builder config suitable for capnp-serializing out-messages in SHM arena app_shm() for the sam...">app_shm_builder_config()</a> is to <a class="el" href="classipc_1_1session_1_1shm_1_1classic_1_1Session__mv.html#a0fbea0563835e852069cdaab506dd92c" title="Identical to session_shm_builder_config() but backed by SHM arena app_shm() instead of session_shm().">shm::classic::Session_mv::app_shm_builder_config()</a>, this is to <a class="el" href="classipc_1_1session_1_1shm_1_1classic_1_1Session__mv.html#a0b7540b33fcedeaba37a3fece1bdec7a" title="When transmitting items originating in Arena app_shm() via transport::struc::shm::Builder::emit_seria...">shm::classic::Session_mv::app_shm_lender_session()</a>.  <a href="classipc_1_1session_1_1shm_1_1classic_1_1Session__server.html#a4bfebd1e36c1b2924b6f84294f7cb10c">More...</a><br /></td></tr>
<tr class="separator:a4bfebd1e36c1b2924b6f84294f7cb10c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac87840d13847fca013ef3f64de8dbcce"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classipc_1_1session_1_1shm_1_1classic_1_1Session__server.html#a9b709f4510613328942335b4ba5fb49d">Structured_msg_reader_config</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classipc_1_1session_1_1shm_1_1classic_1_1Session__server.html#ac87840d13847fca013ef3f64de8dbcce">app_shm_reader_config</a> (const <a class="el" href="structipc_1_1session_1_1Client__app.html">Client_app</a> &amp;app)</td></tr>
<tr class="memdesc:ac87840d13847fca013ef3f64de8dbcce"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns reader config counterpart to <a class="el" href="classipc_1_1session_1_1shm_1_1classic_1_1Session__server.html#ad0dafea47293d23e079b6b5c5c6a9cef" title="Returns builder config suitable for capnp-serializing out-messages in SHM arena app_shm() for the sam...">app_shm_builder_config()</a> for a given <code><a class="el" href="structipc_1_1session_1_1Client__app.html" title="An App that is used as a client in at least one client-server IPC split.">Client_app</a> app</code>.  <a href="classipc_1_1session_1_1shm_1_1classic_1_1Session__server.html#ac87840d13847fca013ef3f64de8dbcce">More...</a><br /></td></tr>
<tr class="separator:ac87840d13847fca013ef3f64de8dbcce"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a952348e52fda298ef7fd6b47295bf8b8"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classipc_1_1session_1_1shm_1_1classic_1_1Session__server.html#a952348e52fda298ef7fd6b47295bf8b8">to_ostream</a> (std::ostream *os) const</td></tr>
<tr class="memdesc:a952348e52fda298ef7fd6b47295bf8b8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Prints string representation to the given <code>ostream</code>.  <a href="classipc_1_1session_1_1shm_1_1classic_1_1Session__server.html#a952348e52fda298ef7fd6b47295bf8b8">More...</a><br /></td></tr>
<tr class="separator:a952348e52fda298ef7fd6b47295bf8b8"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="related" name="related"></a>
Related Functions</h2></td></tr>
<tr><td class="ititle" colspan="2"><p >(Note that these are not member functions.) </p>
</td></tr>
<tr class="memitem:a4556b229bf2bfc3c9eb51af13c47de3d"><td class="memTemplParams" colspan="2">template&lt;schema::MqType S_MQ_TYPE_OR_NONE, bool S_TRANSMIT_NATIVE_HANDLES, typename Mdt_payload &gt; </td></tr>
<tr class="memitem:a4556b229bf2bfc3c9eb51af13c47de3d"><td class="memTemplItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classipc_1_1session_1_1shm_1_1classic_1_1Session__server.html#a4556b229bf2bfc3c9eb51af13c47de3d">operator&lt;&lt;</a> (std::ostream &amp;os, const <a class="el" href="classipc_1_1session_1_1shm_1_1classic_1_1Session__server.html">Session_server</a>&lt; S_MQ_TYPE_OR_NONE, S_TRANSMIT_NATIVE_HANDLES, Mdt_payload &gt; &amp;val)</td></tr>
<tr class="memdesc:a4556b229bf2bfc3c9eb51af13c47de3d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Prints string representation of the given <code><a class="el" href="classipc_1_1session_1_1shm_1_1classic_1_1Session__server.html" title="This is to vanilla Session_server what shm::classic::Server_session is to vanilla Server_session: it ...">Session_server</a></code> to the given <code>ostream</code>.  <a href="classipc_1_1session_1_1shm_1_1classic_1_1Session__server.html#a4556b229bf2bfc3c9eb51af13c47de3d">More...</a><br /></td></tr>
<tr class="separator:a4556b229bf2bfc3c9eb51af13c47de3d"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><div class="compoundTemplParams">template&lt;schema::MqType S_MQ_TYPE_OR_NONE, bool S_TRANSMIT_NATIVE_HANDLES, typename Mdt_payload&gt;<br />
class ipc::session::shm::classic::Session_server&lt; S_MQ_TYPE_OR_NONE, S_TRANSMIT_NATIVE_HANDLES, Mdt_payload &gt;</div><p >This is to vanilla <a class="el" href="classipc_1_1session_1_1shm_1_1classic_1_1Session__server.html" title="This is to vanilla Session_server what shm::classic::Server_session is to vanilla Server_session: it ...">Session_server</a> what <a class="el" href="classipc_1_1session_1_1shm_1_1classic_1_1Server__session.html" title="Identical to session::Server_session in every way, except that it makes available two SHM arenas,...">shm::classic::Server_session</a> is to vanilla <a class="el" href="namespaceipc_1_1session.html#ab01d5bce0ab2f3435ca9dd88d27609dc" title="A vanilla Server_session with no optional capabilities.">Server_session</a>: it is the session-server type that starts SHM-enabled sessions with SHM-classic provider (<a class="el" href="classipc_1_1shm_1_1classic_1_1Pool__arena.html" title="A SHM-classic interface around a single SHM pool with allocation-algorithm services by boost....">ipc::shm::classic::Pool_arena</a>). </p>
<p >Its API is identical to that of <a class="el" href="classipc_1_1session_1_1shm_1_1classic_1_1Session__server.html" title="This is to vanilla Session_server what shm::classic::Server_session is to vanilla Server_session: it ...">Session_server</a>, except that it emits <a class="el" href="classipc_1_1session_1_1shm_1_1classic_1_1Session__server.html#a2330c13a2c20303d4be4adfe4c74b2b9" title="Short-hand for the concrete Server_session-like type emitted by async_accept().">Server_session_obj</a> that are <a class="el" href="classipc_1_1session_1_1shm_1_1classic_1_1Server__session.html" title="Identical to session::Server_session in every way, except that it makes available two SHM arenas,...">shm::classic::Server_session</a> and not vanilla <a class="el" href="namespaceipc_1_1session.html#ab01d5bce0ab2f3435ca9dd88d27609dc" title="A vanilla Server_session with no optional capabilities.">Server_session</a>. In addition:</p>
<h3>Max pool size configuration API (optional)</h3>
<p >If using this, as opposed to (at least) SHM-jemalloc provider (<a class="el" href="classipc_1_1session_1_1shm_1_1arena__lend_1_1jemalloc_1_1Session__server.html" title="This is to vanilla Session_server what shm::arena_lend::jemalloc::Server_session is to vanilla Server...">session::shm::arena_lend::jemalloc::Session_server</a>), you could potentially encounter "No space left on device" (<code>ENOSPC</code> in at least Linux) in <a class="el" href="classipc_1_1session_1_1shm_1_1classic_1_1Session__server.html#ac6733bac776ecd2995f41cb0feb81d63" title="Contract identical to simpler session::Session_server::async_accept() overload; but internally ensure...">async_accept()</a>. This has nothing to do with drive space, or even physical RAM in fact. It has to do with certain kernel parameters governing virtual SHM-mapped space. If this becomes a problem then please look into <a class="el" href="classipc_1_1session_1_1shm_1_1classic_1_1Session__server.html#af6472e74db4dee7cf5ce5be55ded4179" title="The pool-size value, in mebibytes, which will be used to size the pool in subsequent async_accept()s.">Session_server::pool_size_limit_mi()</a> API. See the doc header for the accessor for discussion.</p>
<p >In most cases it should not come up.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">S_MQ_TYPE_OR_NONE</td><td>See vanilla <a class="el" href="classipc_1_1session_1_1shm_1_1classic_1_1Session__server.html#af10bb97219c59c34fce50be09eaacf0c" title="Constructor: identical to session::Session_server ctor.">Session_server</a>. </td></tr>
    <tr><td class="paramname">S_TRANSMIT_NATIVE_HANDLES</td><td>See vanilla <a class="el" href="classipc_1_1session_1_1shm_1_1classic_1_1Session__server.html#af10bb97219c59c34fce50be09eaacf0c" title="Constructor: identical to session::Session_server ctor.">Session_server</a>. </td></tr>
    <tr><td class="paramname">Mdt_payload</td><td>See vanilla <a class="el" href="classipc_1_1session_1_1shm_1_1classic_1_1Session__server.html#af10bb97219c59c34fce50be09eaacf0c" title="Constructor: identical to session::Session_server ctor.">Session_server</a>. </td></tr>
  </table>
  </dd>
</dl>
</div><h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="af10bb97219c59c34fce50be09eaacf0c" name="af10bb97219c59c34fce50be09eaacf0c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af10bb97219c59c34fce50be09eaacf0c">&#9670;&nbsp;</a></span>Session_server()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;schema::MqType S_MQ_TYPE_OR_NONE, bool S_TRANSMIT_NATIVE_HANDLES, typename Mdt_payload &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classipc_1_1session_1_1shm_1_1classic_1_1Session__server.html">ipc::session::shm::classic::Session_server</a>&lt; S_MQ_TYPE_OR_NONE, S_TRANSMIT_NATIVE_HANDLES, Mdt_payload &gt;::Session_server </td>
          <td>(</td>
          <td class="paramtype">flow::log::Logger *&#160;</td>
          <td class="paramname"><em>logger_ptr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structipc_1_1session_1_1Server__app.html">Server_app</a> &amp;&#160;</td>
          <td class="paramname"><em>srv_app_ref</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structipc_1_1session_1_1Client__app.html#add718cbf6aa1d2abb26fbadcc974a7bd">Client_app::Master_set</a> &amp;&#160;</td>
          <td class="paramname"><em>cli_app_master_set_ref</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceipc.html#aa3192e586cc45d3e7c22463bf2760f89">Error_code</a> *&#160;</td>
          <td class="paramname"><em>err_code</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">explicit</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Constructor: identical to <a class="el" href="classipc_1_1session_1_1Session__server.html" title="To be instantiated typically once in a given process, an object of this type asynchronously listens f...">session::Session_server</a> ctor. </p>
<p >See its doc header. Consider also <a class="el" href="classipc_1_1session_1_1shm_1_1classic_1_1Session__server.html#af6472e74db4dee7cf5ce5be55ded4179" title="The pool-size value, in mebibytes, which will be used to size the pool in subsequent async_accept()s.">pool_size_limit_mi()</a> mutator (though if there are no problems in practice, then you can leave it alone).</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">logger_ptr</td><td>See above. </td></tr>
    <tr><td class="paramname">srv_app_ref</td><td>See above. </td></tr>
    <tr><td class="paramname">cli_app_master_set_ref</td><td>See above. </td></tr>
    <tr><td class="paramname">err_code</td><td>See above. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="ae3e011716068f4e669bd7eed487cf207" name="ae3e011716068f4e669bd7eed487cf207"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae3e011716068f4e669bd7eed487cf207">&#9670;&nbsp;</a></span>app_shm()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;schema::MqType S_MQ_TYPE_OR_NONE, bool S_TRANSMIT_NATIVE_HANDLES, typename Mdt_payload &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classipc_1_1session_1_1shm_1_1classic_1_1Session__server.html">Session_server</a>&lt; S_MQ_TYPE_OR_NONE, S_TRANSMIT_NATIVE_HANDLES, Mdt_payload &gt;<a class="el" href="classipc_1_1session_1_1shm_1_1classic_1_1Session__server.html#ae4d637a7d4082c639b7ef7654cc616f3">::Arena</a> * <a class="el" href="classipc_1_1session_1_1shm_1_1classic_1_1Session__server.html">ipc::session::shm::classic::Session_server</a>&lt; S_MQ_TYPE_OR_NONE, S_TRANSMIT_NATIVE_HANDLES, Mdt_payload &gt;::app_shm </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structipc_1_1session_1_1Client__app.html">Client_app</a> &amp;&#160;</td>
          <td class="paramname"><em>app</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns pointer to the per-<code>app</code> SHM-arena, whose lifetime extends until <code>*this</code> is destroyed; or null if the given <a class="el" href="structipc_1_1session_1_1Client__app.html" title="An App that is used as a client in at least one client-server IPC split.">Client_app</a> has not yet opened at least 1 <a class="el" href="classipc_1_1session_1_1shm_1_1classic_1_1Server__session.html" title="Identical to session::Server_session in every way, except that it makes available two SHM arenas,...">shm::classic::Server_session</a> via <a class="el" href="classipc_1_1session_1_1shm_1_1classic_1_1Session__server.html#ac6733bac776ecd2995f41cb0feb81d63" title="Contract identical to simpler session::Session_server::async_accept() overload; but internally ensure...">async_accept()</a>. </p>
<p >Alternatively you may use <a class="el" href="classipc_1_1session_1_1shm_1_1classic_1_1Session__mv.html#ac6a4f1fbafb583f37d7586c6a199430f" title="Returns SHM Arena with per-app scope, meaning its pool shall be accessible potentially beyond the lif...">shm::classic::Session_mv::app_shm()</a> off any session object filled-out by <code>*this</code> <a class="el" href="classipc_1_1session_1_1shm_1_1classic_1_1Session__server.html#ac6733bac776ecd2995f41cb0feb81d63" title="Contract identical to simpler session::Session_server::async_accept() overload; but internally ensure...">async_accept()</a>, as long as its <a class="el" href="classipc_1_1session_1_1Server__session__mv.html#ac873543383b7a6da94d4353231f34ec2" title="The opposing application is described by a Client_app; this is that description.">Server_session_mv::client_app()</a> equals <code>app</code> (by <a class="el" href="structipc_1_1session_1_1App.html#a8e67b57829fe43a122a23c699b5de8fd" title="Brief application name, readable to humans and unique across all other applications&#39; names; used both...">App::m_name</a> equality).</p>
<p >If non-null is returned, then the same pointer value shall be returned for all subsequent calls with the same (by <a class="el" href="structipc_1_1session_1_1App.html#a8e67b57829fe43a122a23c699b5de8fd" title="Brief application name, readable to humans and unique across all other applications&#39; names; used both...">App::m_name</a> equality) <code>app</code>. The non-null pointers returned for any 2 calls, where <code>app</code> is different (by <a class="el" href="structipc_1_1session_1_1App.html#a8e67b57829fe43a122a23c699b5de8fd" title="Brief application name, readable to humans and unique across all other applications&#39; names; used both...">App::m_name</a> equality) among them, shall always differ.</p>
<p >See <a class="el" href="classipc_1_1session_1_1shm_1_1classic_1_1Session__mv.html#a07c9b1803567c2714ae48433e756047f" title="The arena object on which one may call construct&lt;T&gt;(ctor_args...), where ctor_args are arguments to t...">shm::classic::Session_mv::Arena</a> doc header for useful instructions on working with <a class="el" href="classipc_1_1session_1_1shm_1_1classic_1_1Session__server.html#ae4d637a7d4082c639b7ef7654cc616f3" title="Short-hand for shm::classic::Session_mv::Arena. See app_shm() in particular.">Arena</a>, <code>lend_object()</code>, and <code>borrow_object()</code>.</p>
<h3>Perf</h3>
<p >Given the choice between Server_session_mv::app_shm() and the present method, the latter is somewhat slower; internally it involves a mutex-protected map lookup, while the former simply returns a cached pointer as of this writing.</p>
<p >Generally it is also quite fast for the user to save any non-null value returned by either <code><a class="el" href="classipc_1_1session_1_1shm_1_1classic_1_1Session__server.html#ae3e011716068f4e669bd7eed487cf207" title="Returns pointer to the per-app SHM-arena, whose lifetime extends until *this is destroyed; or null if...">app_shm()</a></code>; the pointer returned shall always be the same after all.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">app</td><td><a class="el" href="structipc_1_1session_1_1Client__app.html" title="An App that is used as a client in at least one client-server IPC split.">Client_app</a> whose segregated SHM-arena to return, if a session for a client of the app has been opened prior to this call. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Pointer to <code>*this</code>-held per-<code>app</code> SHM-arena, if it has been created; null otherwise. See above. </dd></dl>

</div>
</div>
<a id="ad0dafea47293d23e079b6b5c5c6a9cef" name="ad0dafea47293d23e079b6b5c5c6a9cef"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad0dafea47293d23e079b6b5c5c6a9cef">&#9670;&nbsp;</a></span>app_shm_builder_config()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;schema::MqType S_MQ_TYPE_OR_NONE, bool S_TRANSMIT_NATIVE_HANDLES, typename Mdt_payload &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classipc_1_1session_1_1shm_1_1classic_1_1Session__server.html">Session_server</a>&lt; S_MQ_TYPE_OR_NONE, S_TRANSMIT_NATIVE_HANDLES, Mdt_payload &gt;<a class="el" href="classipc_1_1session_1_1shm_1_1classic_1_1Session__server.html#a2f814f83d98f8841f9dc01c7d8594bb2">::Structured_msg_builder_config</a> <a class="el" href="classipc_1_1session_1_1shm_1_1classic_1_1Session__server.html">ipc::session::shm::classic::Session_server</a>&lt; S_MQ_TYPE_OR_NONE, S_TRANSMIT_NATIVE_HANDLES, Mdt_payload &gt;::app_shm_builder_config </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structipc_1_1session_1_1Client__app.html">Client_app</a> &amp;&#160;</td>
          <td class="paramname"><em>app</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns builder config suitable for capnp-serializing out-messages in SHM arena <a class="el" href="classipc_1_1session_1_1shm_1_1classic_1_1Session__server.html#ae3e011716068f4e669bd7eed487cf207" title="Returns pointer to the per-app SHM-arena, whose lifetime extends until *this is destroyed; or null if...">app_shm()</a> for the same <code><a class="el" href="structipc_1_1session_1_1Client__app.html" title="An App that is used as a client in at least one client-server IPC split.">Client_app</a> app</code>. </p>
<p >Alternatively you may use <a class="el" href="classipc_1_1session_1_1shm_1_1classic_1_1Session__mv.html#a0fbea0563835e852069cdaab506dd92c" title="Identical to session_shm_builder_config() but backed by SHM arena app_shm() instead of session_shm().">shm::classic::Session_mv::app_shm_builder_config()</a> off any session object filled-out by <code>*this</code> <a class="el" href="classipc_1_1session_1_1shm_1_1classic_1_1Session__server.html#ac6733bac776ecd2995f41cb0feb81d63" title="Contract identical to simpler session::Session_server::async_accept() overload; but internally ensure...">async_accept()</a>, as long as its <a class="el" href="classipc_1_1session_1_1Server__session__mv.html#ac873543383b7a6da94d4353231f34ec2" title="The opposing application is described by a Client_app; this is that description.">Server_session_mv::client_app()</a> equals <code>app</code> (by <a class="el" href="structipc_1_1session_1_1App.html#a8e67b57829fe43a122a23c699b5de8fd" title="Brief application name, readable to humans and unique across all other applications&#39; names; used both...">App::m_name</a> equality).</p>
<p >Unlike <a class="el" href="classipc_1_1session_1_1shm_1_1classic_1_1Session__server.html#ae3e011716068f4e669bd7eed487cf207" title="Returns pointer to the per-app SHM-arena, whose lifetime extends until *this is destroyed; or null if...">app_shm()</a> this method does not allow the case where <code>app_shm(app)</code> would have returned null. In that case the present method yields undefined behavior (assertion may trip).</p>
<h3>Perf</h3>
<p >Given the choice between Server_session_mv::app_shm_builder_config() and the present method, the latter is somewhat slower (reason: same as listed in <a class="el" href="classipc_1_1session_1_1shm_1_1classic_1_1Session__server.html#ae3e011716068f4e669bd7eed487cf207" title="Returns pointer to the per-app SHM-arena, whose lifetime extends until *this is destroyed; or null if...">app_shm()</a> doc header).</p>
<p >Generally it is also quite fast for the user to save any value returned by either <code><a class="el" href="classipc_1_1session_1_1shm_1_1classic_1_1Session__server.html#ad0dafea47293d23e079b6b5c5c6a9cef" title="Returns builder config suitable for capnp-serializing out-messages in SHM arena app_shm() for the sam...">app_shm_builder_config()</a></code>, as an equal-by-value <code>Config</code> object shall be returned for the same (by <a class="el" href="structipc_1_1session_1_1App.html#a8e67b57829fe43a122a23c699b5de8fd" title="Brief application name, readable to humans and unique across all other applications&#39; names; used both...">App::m_name</a> equality) <code>app</code>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">app</td><td>See <a class="el" href="classipc_1_1session_1_1shm_1_1classic_1_1Session__server.html#ae3e011716068f4e669bd7eed487cf207" title="Returns pointer to the per-app SHM-arena, whose lifetime extends until *this is destroyed; or null if...">app_shm()</a>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>See above. </dd></dl>

</div>
</div>
<a id="a4bfebd1e36c1b2924b6f84294f7cb10c" name="a4bfebd1e36c1b2924b6f84294f7cb10c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4bfebd1e36c1b2924b6f84294f7cb10c">&#9670;&nbsp;</a></span>app_shm_lender_session()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;schema::MqType S_MQ_TYPE_OR_NONE, bool S_TRANSMIT_NATIVE_HANDLES, typename Mdt_payload &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classipc_1_1session_1_1shm_1_1classic_1_1Session__server.html">Session_server</a>&lt; S_MQ_TYPE_OR_NONE, S_TRANSMIT_NATIVE_HANDLES, Mdt_payload &gt;::Structured_msg_builder_config::Builder::Session <a class="el" href="classipc_1_1session_1_1shm_1_1classic_1_1Session__server.html">ipc::session::shm::classic::Session_server</a>&lt; S_MQ_TYPE_OR_NONE, S_TRANSMIT_NATIVE_HANDLES, Mdt_payload &gt;::app_shm_lender_session </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structipc_1_1session_1_1Client__app.html">Client_app</a> &amp;&#160;</td>
          <td class="paramname"><em>app</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>In short, what <a class="el" href="classipc_1_1session_1_1shm_1_1classic_1_1Session__server.html#ad0dafea47293d23e079b6b5c5c6a9cef" title="Returns builder config suitable for capnp-serializing out-messages in SHM arena app_shm() for the sam...">app_shm_builder_config()</a> is to <a class="el" href="classipc_1_1session_1_1shm_1_1classic_1_1Session__mv.html#a0fbea0563835e852069cdaab506dd92c" title="Identical to session_shm_builder_config() but backed by SHM arena app_shm() instead of session_shm().">shm::classic::Session_mv::app_shm_builder_config()</a>, this is to <a class="el" href="classipc_1_1session_1_1shm_1_1classic_1_1Session__mv.html#a0b7540b33fcedeaba37a3fece1bdec7a" title="When transmitting items originating in Arena app_shm() via transport::struc::shm::Builder::emit_seria...">shm::classic::Session_mv::app_shm_lender_session()</a>. </p>
<p >Notes in <a class="el" href="classipc_1_1session_1_1shm_1_1classic_1_1Session__server.html#ad0dafea47293d23e079b6b5c5c6a9cef" title="Returns builder config suitable for capnp-serializing out-messages in SHM arena app_shm() for the sam...">app_shm_builder_config()</a> doc header apply here.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">app</td><td>See <a class="el" href="classipc_1_1session_1_1shm_1_1classic_1_1Session__server.html#ae3e011716068f4e669bd7eed487cf207" title="Returns pointer to the per-app SHM-arena, whose lifetime extends until *this is destroyed; or null if...">app_shm()</a>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>See above. </dd></dl>

</div>
</div>
<a id="ac87840d13847fca013ef3f64de8dbcce" name="ac87840d13847fca013ef3f64de8dbcce"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac87840d13847fca013ef3f64de8dbcce">&#9670;&nbsp;</a></span>app_shm_reader_config()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;schema::MqType S_MQ_TYPE_OR_NONE, bool S_TRANSMIT_NATIVE_HANDLES, typename Mdt_payload &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classipc_1_1session_1_1shm_1_1classic_1_1Session__server.html">Session_server</a>&lt; S_MQ_TYPE_OR_NONE, S_TRANSMIT_NATIVE_HANDLES, Mdt_payload &gt;<a class="el" href="classipc_1_1session_1_1shm_1_1classic_1_1Session__server.html#a9b709f4510613328942335b4ba5fb49d">::Structured_msg_reader_config</a> <a class="el" href="classipc_1_1session_1_1shm_1_1classic_1_1Session__server.html">ipc::session::shm::classic::Session_server</a>&lt; S_MQ_TYPE_OR_NONE, S_TRANSMIT_NATIVE_HANDLES, Mdt_payload &gt;::app_shm_reader_config </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structipc_1_1session_1_1Client__app.html">Client_app</a> &amp;&#160;</td>
          <td class="paramname"><em>app</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns reader config counterpart to <a class="el" href="classipc_1_1session_1_1shm_1_1classic_1_1Session__server.html#ad0dafea47293d23e079b6b5c5c6a9cef" title="Returns builder config suitable for capnp-serializing out-messages in SHM arena app_shm() for the sam...">app_shm_builder_config()</a> for a given <code><a class="el" href="structipc_1_1session_1_1Client__app.html" title="An App that is used as a client in at least one client-server IPC split.">Client_app</a> app</code>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">app</td><td>See <a class="el" href="classipc_1_1session_1_1shm_1_1classic_1_1Session__server.html#ae3e011716068f4e669bd7eed487cf207" title="Returns pointer to the per-app SHM-arena, whose lifetime extends until *this is destroyed; or null if...">app_shm()</a>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>See above. </dd></dl>

</div>
</div>
<a id="ab77874720a5b252df5b1d6faf5d29bb5" name="ab77874720a5b252df5b1d6faf5d29bb5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab77874720a5b252df5b1d6faf5d29bb5">&#9670;&nbsp;</a></span>async_accept() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;schema::MqType S_MQ_TYPE_OR_NONE, bool S_TRANSMIT_NATIVE_HANDLES, typename Mdt_payload &gt; </div>
<div class="memtemplate">
template&lt;typename Task_err , typename N_init_channels_by_srv_req_func , typename Mdt_load_func &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classipc_1_1session_1_1shm_1_1classic_1_1Session__server.html">ipc::session::shm::classic::Session_server</a>&lt; S_MQ_TYPE_OR_NONE, S_TRANSMIT_NATIVE_HANDLES, Mdt_payload &gt;::async_accept </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classipc_1_1session_1_1shm_1_1classic_1_1Session__server.html#a2330c13a2c20303d4be4adfe4c74b2b9">Server_session_obj</a> *&#160;</td>
          <td class="paramname"><em>target_session</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classipc_1_1session_1_1shm_1_1classic_1_1Session__server.html#ab8f638542f33b5028e1db7ce7572fef3">Channels</a> *&#160;</td>
          <td class="paramname"><em>init_channels_by_srv_req</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classipc_1_1session_1_1shm_1_1classic_1_1Session__server.html#aff4a736c67698d14a538276912e6101d">Mdt_reader_ptr</a> *&#160;</td>
          <td class="paramname"><em>mdt_from_cli_or_null</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classipc_1_1session_1_1shm_1_1classic_1_1Session__server.html#ab8f638542f33b5028e1db7ce7572fef3">Channels</a> *&#160;</td>
          <td class="paramname"><em>init_channels_by_cli_req</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">N_init_channels_by_srv_req_func &amp;&amp;&#160;</td>
          <td class="paramname"><em>n_init_channels_by_srv_req_func</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Mdt_load_func &amp;&amp;&#160;</td>
          <td class="paramname"><em>mdt_load_func</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Task_err &amp;&amp;&#160;</td>
          <td class="paramname"><em>on_done_func</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Contract identical to advanced <a class="el" href="classipc_1_1session_1_1Session__server.html#a13887cd64912bb5f5675e2817ff8435f" title="Asynchronously awaits for an opposing Client_session to request session establishment and calls on_do...">session::Session_server::async_accept()</a> overload; but internally ensures that the appropriate SHM-classic arenas are available for use in the emitted <a class="el" href="classipc_1_1session_1_1shm_1_1classic_1_1Session__server.html#a2330c13a2c20303d4be4adfe4c74b2b9" title="Short-hand for the concrete Server_session-like type emitted by async_accept().">Server_session_obj</a>. </p>
<p >See doc header for <a class="el" href="classipc_1_1session_1_1Session__server.html#a13887cd64912bb5f5675e2817ff8435f" title="Asynchronously awaits for an opposing Client_session to request session establishment and calls on_do...">session::Session_server::async_accept()</a> advanced overload.</p>
<p >Additional (to those documented for <a class="el" href="classipc_1_1session_1_1Session__server.html#a13887cd64912bb5f5675e2817ff8435f" title="Asynchronously awaits for an opposing Client_session to request session establishment and calls on_do...">session::Session_server::async_accept()</a>) <a class="el" href="namespaceipc.html#aa3192e586cc45d3e7c22463bf2760f89" title="Short-hand for flow::Error_code which is very common.">Error_code</a> generated and passed to <code>on_done_func()</code>: See <a class="el" href="classipc_1_1shm_1_1classic_1_1Pool__arena.html" title="A SHM-classic interface around a single SHM pool with allocation-algorithm services by boost....">shm::classic::Pool_arena</a> ctor doc header. The most likely reason for failure of that code in this context is a permissions issue creating the SHM pool or <code>ENOSPC</code> (Linux at least) a/k/a "No space left on device" if a kernel level for sum of pool sizes has been reached. In this case consider <a class="el" href="classipc_1_1session_1_1shm_1_1classic_1_1Session__server.html#af6472e74db4dee7cf5ce5be55ded4179" title="The pool-size value, in mebibytes, which will be used to size the pool in subsequent async_accept()s.">pool_size_limit_mi()</a> mutator and/or tweaking the kernel parameter.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Task_err</td><td>See above. </td></tr>
    <tr><td class="paramname">N_init_channels_by_srv_req_func</td><td>See above. </td></tr>
    <tr><td class="paramname">Mdt_load_func</td><td>See above. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">target_session</td><td>See other <a class="el" href="classipc_1_1session_1_1shm_1_1classic_1_1Session__server.html#ac6733bac776ecd2995f41cb0feb81d63" title="Contract identical to simpler session::Session_server::async_accept() overload; but internally ensure...">async_accept()</a> overload. </td></tr>
    <tr><td class="paramname">init_channels_by_srv_req</td><td>See above. </td></tr>
    <tr><td class="paramname">mdt_from_cli_or_null</td><td>See above. </td></tr>
    <tr><td class="paramname">init_channels_by_cli_req</td><td>See above. </td></tr>
    <tr><td class="paramname">n_init_channels_by_srv_req_func</td><td>See above. </td></tr>
    <tr><td class="paramname">mdt_load_func</td><td>See above. </td></tr>
    <tr><td class="paramname">on_done_func</td><td>See above. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ac6733bac776ecd2995f41cb0feb81d63" name="ac6733bac776ecd2995f41cb0feb81d63"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac6733bac776ecd2995f41cb0feb81d63">&#9670;&nbsp;</a></span>async_accept() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;schema::MqType S_MQ_TYPE_OR_NONE, bool S_TRANSMIT_NATIVE_HANDLES, typename Mdt_payload &gt; </div>
<div class="memtemplate">
template&lt;typename Task_err &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classipc_1_1session_1_1shm_1_1classic_1_1Session__server.html">ipc::session::shm::classic::Session_server</a>&lt; S_MQ_TYPE_OR_NONE, S_TRANSMIT_NATIVE_HANDLES, Mdt_payload &gt;::async_accept </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classipc_1_1session_1_1shm_1_1classic_1_1Session__server.html#a2330c13a2c20303d4be4adfe4c74b2b9">Server_session_obj</a> *&#160;</td>
          <td class="paramname"><em>target_session</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Task_err &amp;&amp;&#160;</td>
          <td class="paramname"><em>on_done_func</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Contract identical to simpler <a class="el" href="classipc_1_1session_1_1Session__server.html#a13887cd64912bb5f5675e2817ff8435f" title="Asynchronously awaits for an opposing Client_session to request session establishment and calls on_do...">session::Session_server::async_accept()</a> overload; but internally ensures that the appropriate SHM-classic arenas are available for use in the emitted <a class="el" href="classipc_1_1session_1_1shm_1_1classic_1_1Session__server.html#a2330c13a2c20303d4be4adfe4c74b2b9" title="Short-hand for the concrete Server_session-like type emitted by async_accept().">Server_session_obj</a>. </p>
<p >See doc header for <a class="el" href="classipc_1_1session_1_1Session__server.html#a13887cd64912bb5f5675e2817ff8435f" title="Asynchronously awaits for an opposing Client_session to request session establishment and calls on_do...">session::Session_server::async_accept()</a> simple overload.</p>
<p >Additional (to those documented for <a class="el" href="classipc_1_1session_1_1shm_1_1classic_1_1Session__server.html#ac6733bac776ecd2995f41cb0feb81d63" title="Contract identical to simpler session::Session_server::async_accept() overload; but internally ensure...">Session_server::async_accept()</a>) <a class="el" href="namespaceipc.html#aa3192e586cc45d3e7c22463bf2760f89" title="Short-hand for flow::Error_code which is very common.">Error_code</a> generated and passed to <code>on_done_func()</code>: See <a class="el" href="classipc_1_1shm_1_1classic_1_1Pool__arena.html" title="A SHM-classic interface around a single SHM pool with allocation-algorithm services by boost....">shm::classic::Pool_arena</a> ctor doc header. The most likely reason for failure of that code in this context is a permissions issue creating the SHM pool, or <code>ENOSPC</code> (Linux at least) a/k/a "No space left on device" if a kernel level for sum of pool sizes has been reached. In this case consider <a class="el" href="classipc_1_1session_1_1shm_1_1classic_1_1Session__server.html#af6472e74db4dee7cf5ce5be55ded4179" title="The pool-size value, in mebibytes, which will be used to size the pool in subsequent async_accept()s.">pool_size_limit_mi()</a> mutator and/or tweaking the kernel parameter.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Task_err</td><td>See above. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">target_session</td><td>See above. Reminder (though this is enforced at compile-time): the type of <code>*target_session</code> for <a class="el" href="classipc_1_1session_1_1shm_1_1classic_1_1Session__server.html#ac6733bac776ecd2995f41cb0feb81d63" title="Contract identical to simpler session::Session_server::async_accept() overload; but internally ensure...">Session_server::async_accept()</a> is <a class="el" href="namespaceipc_1_1session.html#ab01d5bce0ab2f3435ca9dd88d27609dc" title="A vanilla Server_session with no optional capabilities.">Server_session</a>; whereas here it is <a class="el" href="classipc_1_1session_1_1shm_1_1classic_1_1Server__session.html" title="Identical to session::Server_session in every way, except that it makes available two SHM arenas,...">shm::classic::Server_session</a>. </td></tr>
    <tr><td class="paramname">on_done_func</td><td>See above. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="af6472e74db4dee7cf5ce5be55ded4179" name="af6472e74db4dee7cf5ce5be55ded4179"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af6472e74db4dee7cf5ce5be55ded4179">&#9670;&nbsp;</a></span>pool_size_limit_mi() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;schema::MqType S_MQ_TYPE_OR_NONE, bool S_TRANSMIT_NATIVE_HANDLES, typename Mdt_payload &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">size_t <a class="el" href="classipc_1_1session_1_1shm_1_1classic_1_1Session__server.html">ipc::session::shm::classic::Session_server</a>&lt; S_MQ_TYPE_OR_NONE, S_TRANSMIT_NATIVE_HANDLES, Mdt_payload &gt;::pool_size_limit_mi</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The pool-size value, in mebibytes, which will be used to size the pool in subsequent <code><a class="el" href="classipc_1_1session_1_1shm_1_1classic_1_1Session__server.html#ac6733bac776ecd2995f41cb0feb81d63" title="Contract identical to simpler session::Session_server::async_accept() overload; but internally ensure...">async_accept()</a></code>s. </p>
<p >One can change this via the mutator overload.</p>
<p >A large default value is used if one does not invoke that mutator.</p>
<h3>How it works</h3>
<p >Each time <a class="el" href="classipc_1_1session_1_1shm_1_1classic_1_1Session__server.html#ac6733bac776ecd2995f41cb0feb81d63" title="Contract identical to simpler session::Session_server::async_accept() overload; but internally ensure...">async_accept()</a> succeeds, a SHM pool sized according to this value is created for the session; and potentially another SHM pool sized similarly is created for the <a class="el" href="structipc_1_1session_1_1Client__app.html" title="An App that is used as a client in at least one client-server IPC split.">Client_app</a> (if and only if a session against the same <a class="el" href="structipc_1_1session_1_1Client__app.html" title="An App that is used as a client in at least one client-server IPC split.">Client_app</a> has not yet been opened by <code>*this</code>). The <em>key point</em>: only a tiny amount of RAM is actually taken at that time for each pool; the pool size only counts against vaddr space which is essentially unlimited. Physical RAM is reserved only upon actual allocation for objects subsequently, with kernel-page-sized quantization. Therefore a huge value can be used here with no RAM-use penalty; on the other hand if this value is too small, and an allocation makes a pool run out of vaddr space, then a <code>bad_alloc</code> exception will be thrown, and you're pretty much kaput. So you should use a huge value! And indeed the default is quite large.</p>
<p >Unfortunately, at least in Linux, there is nevertheless a system-wide limit against the sum of these SHM-pool virtual sizes. This is a kernel parameter and is usually admin-configurable; it might default to half your physical RAM for example. Therefore unfortunately if too much virtual space is used by active SHM-pools across the system, a Linux (at least) <code>ENOSPC</code> (No space left on device) error might result (in our case be passed to <a class="el" href="classipc_1_1session_1_1shm_1_1classic_1_1Session__server.html#ac6733bac776ecd2995f41cb0feb81d63" title="Contract identical to simpler session::Session_server::async_accept() overload; but internally ensure...">async_accept()</a> completion handler). In that case, you can either tweak the relevant kernel parameter(s); or use <a class="el" href="classipc_1_1session_1_1shm_1_1classic_1_1Session__server.html#af6472e74db4dee7cf5ce5be55ded4179" title="The pool-size value, in mebibytes, which will be used to size the pool in subsequent async_accept()s.">pool_size_limit_mi()</a> mutator to reduce your pool sizes &ndash; assuming of course it'll be sufficient for your allocation needs.</p>
<p >For most use cases none of this will be a problem. If it becomes a problem, either use a solution above; or consider <a class="el" href="classipc_1_1session_1_1shm_1_1arena__lend_1_1jemalloc_1_1Session__server.html" title="This is to vanilla Session_server what shm::arena_lend::jemalloc::Server_session is to vanilla Server...">ipc::session::shm::arena_lend::jemalloc::Session_server</a> (SHM-jemalloc) which is a multi-pool system that adjusts dynamically without your having to worry about it at all.</p>
<dl class="section return"><dt>Returns</dt><dd>See above. </dd></dl>

</div>
</div>
<a id="a855afed179ab8f4b694d9152b94a4f2f" name="a855afed179ab8f4b694d9152b94a4f2f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a855afed179ab8f4b694d9152b94a4f2f">&#9670;&nbsp;</a></span>pool_size_limit_mi() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;schema::MqType S_MQ_TYPE_OR_NONE, bool S_TRANSMIT_NATIVE_HANDLES, typename Mdt_payload &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classipc_1_1session_1_1shm_1_1classic_1_1Session__server.html">ipc::session::shm::classic::Session_server</a>&lt; S_MQ_TYPE_OR_NONE, S_TRANSMIT_NATIVE_HANDLES, Mdt_payload &gt;::pool_size_limit_mi </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>limit_mi</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sets the value as returned by <code><a class="el" href="classipc_1_1session_1_1shm_1_1classic_1_1Session__server.html#af6472e74db4dee7cf5ce5be55ded4179" title="The pool-size value, in mebibytes, which will be used to size the pool in subsequent async_accept()s.">pool_size_limit_mi()</a></code> accessor. </p>
<p >See its doc header. Behavior is undefined if this is called concurrently with <a class="el" href="classipc_1_1session_1_1shm_1_1classic_1_1Session__server.html#ac6733bac776ecd2995f41cb0feb81d63" title="Contract identical to simpler session::Session_server::async_accept() overload; but internally ensure...">async_accept()</a> itself, or while an <a class="el" href="classipc_1_1session_1_1shm_1_1classic_1_1Session__server.html#ac6733bac776ecd2995f41cb0feb81d63" title="Contract identical to simpler session::Session_server::async_accept() overload; but internally ensure...">async_accept()</a> is outstanding.</p>
<p >A large default value is used if one does not call this.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">limit_mi</td><td>The new value. It must be positive. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a952348e52fda298ef7fd6b47295bf8b8" name="a952348e52fda298ef7fd6b47295bf8b8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a952348e52fda298ef7fd6b47295bf8b8">&#9670;&nbsp;</a></span>to_ostream()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;schema::MqType S_MQ_TYPE_OR_NONE, bool S_TRANSMIT_NATIVE_HANDLES, typename Mdt_payload &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classipc_1_1session_1_1shm_1_1classic_1_1Session__server.html">ipc::session::shm::classic::Session_server</a>&lt; S_MQ_TYPE_OR_NONE, S_TRANSMIT_NATIVE_HANDLES, Mdt_payload &gt;::to_ostream </td>
          <td>(</td>
          <td class="paramtype">std::ostream *&#160;</td>
          <td class="paramname"><em>os</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Prints string representation to the given <code>ostream</code>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">os</td><td>Stream to which to write. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<h2 class="groupheader">Friends And Related Function Documentation</h2>
<a id="a4556b229bf2bfc3c9eb51af13c47de3d" name="a4556b229bf2bfc3c9eb51af13c47de3d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4556b229bf2bfc3c9eb51af13c47de3d">&#9670;&nbsp;</a></span>operator&lt;&lt;()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;schema::MqType S_MQ_TYPE_OR_NONE, bool S_TRANSMIT_NATIVE_HANDLES, typename Mdt_payload &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::ostream &amp; operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>os</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classipc_1_1session_1_1shm_1_1classic_1_1Session__server.html">Session_server</a>&lt; S_MQ_TYPE_OR_NONE, S_TRANSMIT_NATIVE_HANDLES, Mdt_payload &gt; &amp;&#160;</td>
          <td class="paramname"><em>val</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Prints string representation of the given <code><a class="el" href="classipc_1_1session_1_1shm_1_1classic_1_1Session__server.html" title="This is to vanilla Session_server what shm::classic::Server_session is to vanilla Server_session: it ...">Session_server</a></code> to the given <code>ostream</code>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">os</td><td>Stream to which to write. </td></tr>
    <tr><td class="paramname">val</td><td>Object to serialize. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>os</code>. </dd></dl>

</div>
</div>
<hr/>The documentation for this class was generated from the following files:<ul>
<li>session/shm/classic/<a class="el" href="session_2shm_2classic_2classic__fwd_8hpp.html">classic_fwd.hpp</a></li>
<li>session/shm/classic/<a class="el" href="ipc__shm_2src_2ipc_2session_2shm_2classic_2session__server_8hpp.html">session_server.hpp</a></li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Tue Apr 30 2024 23:39:16 for Flow-IPC by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.4
</small></address>
</body>
</html>
