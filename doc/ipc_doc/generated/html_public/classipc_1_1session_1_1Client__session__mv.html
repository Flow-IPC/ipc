<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.9.4"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Flow-IPC: ipc::session::Client_session_mv&lt; Client_session_impl_t &gt; Class Template Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">Flow-IPC<span id="projectnumber">&#160;1.0</span>
   </div>
   <div id="projectbrief">Flow-IPC project: Public API.</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.4 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search",'Search','.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespaceipc.html">ipc</a></li><li class="navelem"><a class="el" href="namespaceipc_1_1session.html">session</a></li><li class="navelem"><a class="el" href="classipc_1_1session_1_1Client__session__mv.html">Client_session_mv</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-types">Public Types</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#related">Related Functions</a> &#124;
<a href="classipc_1_1session_1_1Client__session__mv-members.html">List of all members</a>  </div>
  <div class="headertitle"><div class="title">ipc::session::Client_session_mv&lt; Client_session_impl_t &gt; Class Template Reference</div></div>
</div><!--header-->
<div class="contents">

<p>Implements <a class="el" href="classipc_1_1session_1_1Session.html" title="A documentation-only concept defining the local side of an IPC conversation (session) with another en...">Session</a> concept on the <a class="el" href="structipc_1_1session_1_1Client__app.html" title="An App that is used as a client in at least one client-server IPC split.">Client_app</a> end: a <a class="el" href="classipc_1_1session_1_1Session__mv.html" title="Implements the Session concept when it is in PEER state.">Session_mv</a> that first achieves PEER state by connecting to an opposing Session_server_mv via <a class="el" href="classipc_1_1session_1_1Client__session__mv.html#ae0992c43ab3a978a1023d320d043d8de" title="To be invoked in NULL state only, and not as-if default-cted, it asynchronously attempts to connect t...">Client_session_mv::async_connect()</a>.  
 <a href="classipc_1_1session_1_1Client__session__mv.html#details">More...</a></p>

<p><code>#include &lt;client_session.hpp&gt;</code></p>
<div class="dynheader">
Inheritance diagram for ipc::session::Client_session_mv&lt; Client_session_impl_t &gt;:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="classipc_1_1session_1_1Client__session__mv__inherit__graph.svg" width="194" height="143"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe>
</div>
<center><span class="legend">[<a href="graph_legend.html">legend</a>]</span></center></div>
<div class="dynheader">
Collaboration diagram for ipc::session::Client_session_mv&lt; Client_session_impl_t &gt;:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="classipc_1_1session_1_1Client__session__mv__coll__graph.svg" width="194" height="143"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe>
</div>
<center><span class="legend">[<a href="graph_legend.html">legend</a>]</span></center></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-types" name="pub-types"></a>
Public Types</h2></td></tr>
<tr class="memitem:aaa2fa231533e672f89dd3ae63113d2a2"><td class="memItemLeft" align="right" valign="top"><a id="aaa2fa231533e672f89dd3ae63113d2a2" name="aaa2fa231533e672f89dd3ae63113d2a2"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>Base</b> = <a class="el" href="classipc_1_1session_1_1Session__mv.html">Session_mv</a>&lt; Client_session_impl_t &gt;</td></tr>
<tr class="memdesc:aaa2fa231533e672f89dd3ae63113d2a2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Short-hand for our base class. To the user: note its <code>public</code> API is inherited. <br /></td></tr>
<tr class="separator:aaa2fa231533e672f89dd3ae63113d2a2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pub_types_classipc_1_1session_1_1Session__mv"><td colspan="2" onclick="javascript:toggleInherit('pub_types_classipc_1_1session_1_1Session__mv')"><img src="closed.png" alt="-"/>&#160;Public Types inherited from <a class="el" href="classipc_1_1session_1_1Session__mv.html">ipc::session::Session_mv&lt; Client_session_impl_t &gt;</a></td></tr>
<tr class="memitem:ab92df09d894e6e1aaf3c2733da594fd2 inherit pub_types_classipc_1_1session_1_1Session__mv"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classipc_1_1session_1_1Session__mv.html#ab92df09d894e6e1aaf3c2733da594fd2">Channel_obj</a> = typename Impl::Channel_obj</td></tr>
<tr class="memdesc:ab92df09d894e6e1aaf3c2733da594fd2 inherit pub_types_classipc_1_1session_1_1Session__mv"><td class="mdescLeft">&#160;</td><td class="mdescRight">Implements Session API per contract.  <a href="classipc_1_1session_1_1Session__mv.html#ab92df09d894e6e1aaf3c2733da594fd2">More...</a><br /></td></tr>
<tr class="separator:ab92df09d894e6e1aaf3c2733da594fd2 inherit pub_types_classipc_1_1session_1_1Session__mv"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af87da439644b2afd73d6a13d97e7985f inherit pub_types_classipc_1_1session_1_1Session__mv"><td class="memItemLeft" align="right" valign="top"><a id="af87da439644b2afd73d6a13d97e7985f" name="af87da439644b2afd73d6a13d97e7985f"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>Channels</b> = typename Impl::Channels</td></tr>
<tr class="memdesc:af87da439644b2afd73d6a13d97e7985f inherit pub_types_classipc_1_1session_1_1Session__mv"><td class="mdescLeft">&#160;</td><td class="mdescRight">Container (<code>vector&lt;&gt;</code>) of <a class="el" href="classipc_1_1session_1_1Session__mv.html#ab92df09d894e6e1aaf3c2733da594fd2" title="Implements Session API per contract.">Channel_obj</a>. <br /></td></tr>
<tr class="separator:af87da439644b2afd73d6a13d97e7985f inherit pub_types_classipc_1_1session_1_1Session__mv"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acccbc643f29f002075e66cd134da70bd inherit pub_types_classipc_1_1session_1_1Session__mv"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classipc_1_1session_1_1Session__mv.html#acccbc643f29f002075e66cd134da70bd">Mdt_payload_obj</a> = typename Impl::Mdt_payload_obj</td></tr>
<tr class="memdesc:acccbc643f29f002075e66cd134da70bd inherit pub_types_classipc_1_1session_1_1Session__mv"><td class="mdescLeft">&#160;</td><td class="mdescRight">Implements Session API per contract.  <a href="classipc_1_1session_1_1Session__mv.html#acccbc643f29f002075e66cd134da70bd">More...</a><br /></td></tr>
<tr class="separator:acccbc643f29f002075e66cd134da70bd inherit pub_types_classipc_1_1session_1_1Session__mv"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af10f452e602e4ea7389c6a77dd9a0f88 inherit pub_types_classipc_1_1session_1_1Session__mv"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classipc_1_1session_1_1Session__mv.html#af10f452e602e4ea7389c6a77dd9a0f88">Mdt_builder</a> = typename Impl::Mdt_builder</td></tr>
<tr class="memdesc:af10f452e602e4ea7389c6a77dd9a0f88 inherit pub_types_classipc_1_1session_1_1Session__mv"><td class="mdescLeft">&#160;</td><td class="mdescRight">Implements Session API per contract.  <a href="classipc_1_1session_1_1Session__mv.html#af10f452e602e4ea7389c6a77dd9a0f88">More...</a><br /></td></tr>
<tr class="separator:af10f452e602e4ea7389c6a77dd9a0f88 inherit pub_types_classipc_1_1session_1_1Session__mv"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a787253f02859ea6b99ce3eba92766431 inherit pub_types_classipc_1_1session_1_1Session__mv"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classipc_1_1session_1_1Session__mv.html#a787253f02859ea6b99ce3eba92766431">Mdt_builder_ptr</a> = typename Impl::Mdt_builder_ptr</td></tr>
<tr class="memdesc:a787253f02859ea6b99ce3eba92766431 inherit pub_types_classipc_1_1session_1_1Session__mv"><td class="mdescLeft">&#160;</td><td class="mdescRight">Implements Session API per contract.  <a href="classipc_1_1session_1_1Session__mv.html#a787253f02859ea6b99ce3eba92766431">More...</a><br /></td></tr>
<tr class="separator:a787253f02859ea6b99ce3eba92766431 inherit pub_types_classipc_1_1session_1_1Session__mv"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2b1215fb0c9738b9fcfbb337d23c43df inherit pub_types_classipc_1_1session_1_1Session__mv"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classipc_1_1session_1_1Session__mv.html#a2b1215fb0c9738b9fcfbb337d23c43df">Mdt_reader_ptr</a> = typename Impl::Mdt_reader_ptr</td></tr>
<tr class="memdesc:a2b1215fb0c9738b9fcfbb337d23c43df inherit pub_types_classipc_1_1session_1_1Session__mv"><td class="mdescLeft">&#160;</td><td class="mdescRight">Implements Session API per contract.  <a href="classipc_1_1session_1_1Session__mv.html#a2b1215fb0c9738b9fcfbb337d23c43df">More...</a><br /></td></tr>
<tr class="separator:a2b1215fb0c9738b9fcfbb337d23c43df inherit pub_types_classipc_1_1session_1_1Session__mv"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac205819d4a3a066f31b5af311ff40a2a inherit pub_types_classipc_1_1session_1_1Session__mv"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classipc_1_1session_1_1Session__mv.html#ac205819d4a3a066f31b5af311ff40a2a">Structured_channel</a> = typename <a class="el" href="namespaceipc_1_1transport_1_1struc.html#aca041b0efd4a9ae18e10088b2ee3c052">transport::struc::Channel_via_heap</a>&lt; <a class="el" href="classipc_1_1session_1_1Session__mv.html#ab92df09d894e6e1aaf3c2733da594fd2">Channel_obj</a>, Message_body &gt;</td></tr>
<tr class="memdesc:ac205819d4a3a066f31b5af311ff40a2a inherit pub_types_classipc_1_1session_1_1Session__mv"><td class="mdescLeft">&#160;</td><td class="mdescRight">Implements Session API per contract.  <a href="classipc_1_1session_1_1Session__mv.html#ac205819d4a3a066f31b5af311ff40a2a">More...</a><br /></td></tr>
<tr class="separator:ac205819d4a3a066f31b5af311ff40a2a inherit pub_types_classipc_1_1session_1_1Session__mv"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9f6e9a57f6e6ab420d554a2c0eba7877 inherit pub_types_classipc_1_1session_1_1Session__mv"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classipc_1_1session_1_1Session__mv.html#a9f6e9a57f6e6ab420d554a2c0eba7877">Structured_msg_builder_config</a> = typename Impl::Structured_msg_builder_config</td></tr>
<tr class="memdesc:a9f6e9a57f6e6ab420d554a2c0eba7877 inherit pub_types_classipc_1_1session_1_1Session__mv"><td class="mdescLeft">&#160;</td><td class="mdescRight">Implements Session API per contract.  <a href="classipc_1_1session_1_1Session__mv.html#a9f6e9a57f6e6ab420d554a2c0eba7877">More...</a><br /></td></tr>
<tr class="separator:a9f6e9a57f6e6ab420d554a2c0eba7877 inherit pub_types_classipc_1_1session_1_1Session__mv"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a335c3585402cc9430f8c909e8c7e55f4 inherit pub_types_classipc_1_1session_1_1Session__mv"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classipc_1_1session_1_1Session__mv.html#a335c3585402cc9430f8c909e8c7e55f4">Structured_msg_reader_config</a> = typename Impl::Structured_msg_builder_config</td></tr>
<tr class="memdesc:a335c3585402cc9430f8c909e8c7e55f4 inherit pub_types_classipc_1_1session_1_1Session__mv"><td class="mdescLeft">&#160;</td><td class="mdescRight">Implements Session API per contract.  <a href="classipc_1_1session_1_1Session__mv.html#a335c3585402cc9430f8c909e8c7e55f4">More...</a><br /></td></tr>
<tr class="separator:a335c3585402cc9430f8c909e8c7e55f4 inherit pub_types_classipc_1_1session_1_1Session__mv"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-methods" name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:af1341c2f02d27a766996639edd32dfa8"><td class="memTemplParams" colspan="2">template&lt;typename On_passive_open_channel_handler , typename Task_err &gt; </td></tr>
<tr class="memitem:af1341c2f02d27a766996639edd32dfa8"><td class="memTemplItemLeft" align="right" valign="top">&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classipc_1_1session_1_1Client__session__mv.html#af1341c2f02d27a766996639edd32dfa8">Client_session_mv</a> (flow::log::Logger *logger_ptr, const <a class="el" href="structipc_1_1session_1_1Client__app.html">Client_app</a> &amp;cli_app_ref, const <a class="el" href="structipc_1_1session_1_1Server__app.html">Server_app</a> &amp;srv_app_ref, Task_err &amp;&amp;on_err_func, On_passive_open_channel_handler &amp;&amp;on_passive_open_channel_func)</td></tr>
<tr class="memdesc:af1341c2f02d27a766996639edd32dfa8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructs (passive-opens allowed form) in NULL state.  <a href="classipc_1_1session_1_1Client__session__mv.html#af1341c2f02d27a766996639edd32dfa8">More...</a><br /></td></tr>
<tr class="separator:af1341c2f02d27a766996639edd32dfa8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2c1a00a343a70a31cb630969138b6b25"><td class="memTemplParams" colspan="2">template&lt;typename Task_err &gt; </td></tr>
<tr class="memitem:a2c1a00a343a70a31cb630969138b6b25"><td class="memTemplItemLeft" align="right" valign="top">&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classipc_1_1session_1_1Client__session__mv.html#a2c1a00a343a70a31cb630969138b6b25">Client_session_mv</a> (flow::log::Logger *logger_ptr, const <a class="el" href="structipc_1_1session_1_1Client__app.html">Client_app</a> &amp;cli_app_ref, const <a class="el" href="structipc_1_1session_1_1Server__app.html">Server_app</a> &amp;srv_app_ref, Task_err &amp;&amp;on_err_func)</td></tr>
<tr class="memdesc:a2c1a00a343a70a31cb630969138b6b25"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructs (passive-opens disallowed form) in NULL state.  <a href="classipc_1_1session_1_1Client__session__mv.html#a2c1a00a343a70a31cb630969138b6b25">More...</a><br /></td></tr>
<tr class="separator:a2c1a00a343a70a31cb630969138b6b25"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aba3aa4758c635339289d66be45df343b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classipc_1_1session_1_1Session__mv.html#a787253f02859ea6b99ce3eba92766431">Mdt_builder_ptr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classipc_1_1session_1_1Client__session__mv.html#aba3aa4758c635339289d66be45df343b">mdt_builder</a> ()</td></tr>
<tr class="memdesc:aba3aa4758c635339289d66be45df343b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Implements <a class="el" href="classipc_1_1session_1_1Session.html" title="A documentation-only concept defining the local side of an IPC conversation (session) with another en...">Session</a> API per contract; plus usable to generate blank <code>mdt</code> argument for advanced <a class="el" href="classipc_1_1session_1_1Client__session__mv.html#ae0992c43ab3a978a1023d320d043d8de" title="To be invoked in NULL state only, and not as-if default-cted, it asynchronously attempts to connect t...">async_connect()</a> overload.  <a href="classipc_1_1session_1_1Client__session__mv.html#aba3aa4758c635339289d66be45df343b">More...</a><br /></td></tr>
<tr class="separator:aba3aa4758c635339289d66be45df343b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae0992c43ab3a978a1023d320d043d8de"><td class="memTemplParams" colspan="2">template&lt;typename Task_err &gt; </td></tr>
<tr class="memitem:ae0992c43ab3a978a1023d320d043d8de"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classipc_1_1session_1_1Client__session__mv.html#ae0992c43ab3a978a1023d320d043d8de">async_connect</a> (Task_err &amp;&amp;on_done_func)</td></tr>
<tr class="memdesc:ae0992c43ab3a978a1023d320d043d8de"><td class="mdescLeft">&#160;</td><td class="mdescRight">To be invoked in NULL state only, and not as-if default-cted, it asynchronously attempts to connect to a opposing <code><a class="el" href="classipc_1_1session_1_1Session__server.html" title="To be instantiated typically once in a given process, an object of this type asynchronously listens f...">Session_server</a></code>; and on success invokes the given completion handler with a falsy value indicating <code>*this</code> has entered PEER state.  <a href="classipc_1_1session_1_1Client__session__mv.html#ae0992c43ab3a978a1023d320d043d8de">More...</a><br /></td></tr>
<tr class="separator:ae0992c43ab3a978a1023d320d043d8de"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6a36828595840c78a9cb6d900fe9fd9c"><td class="memTemplParams" colspan="2">template&lt;typename Task_err &gt; </td></tr>
<tr class="memitem:a6a36828595840c78a9cb6d900fe9fd9c"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classipc_1_1session_1_1Client__session__mv.html#a6a36828595840c78a9cb6d900fe9fd9c">async_connect</a> (const typename <a class="el" href="classipc_1_1session_1_1Session__mv.html#a787253f02859ea6b99ce3eba92766431">Base::Mdt_builder_ptr</a> &amp;mdt, typename <a class="el" href="classipc_1_1session_1_1Session__mv.html#af87da439644b2afd73d6a13d97e7985f">Base::Channels</a> *init_channels_by_cli_req_pre_sized, typename <a class="el" href="classipc_1_1session_1_1Session__mv.html#a2b1215fb0c9738b9fcfbb337d23c43df">Base::Mdt_reader_ptr</a> *mdt_from_srv_or_null, typename <a class="el" href="classipc_1_1session_1_1Session__mv.html#af87da439644b2afd73d6a13d97e7985f">Base::Channels</a> *init_channels_by_srv_req, Task_err &amp;&amp;on_done_func)</td></tr>
<tr class="memdesc:a6a36828595840c78a9cb6d900fe9fd9c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Identical to the simpler <a class="el" href="classipc_1_1session_1_1Client__session__mv.html#ae0992c43ab3a978a1023d320d043d8de" title="To be invoked in NULL state only, and not as-if default-cted, it asynchronously attempts to connect t...">async_connect()</a> overload but offers added advanced capabilities: metadata exchange; initial-channel opening.  <a href="classipc_1_1session_1_1Client__session__mv.html#a6a36828595840c78a9cb6d900fe9fd9c">More...</a><br /></td></tr>
<tr class="separator:a6a36828595840c78a9cb6d900fe9fd9c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pub_methods_classipc_1_1session_1_1Session__mv"><td colspan="2" onclick="javascript:toggleInherit('pub_methods_classipc_1_1session_1_1Session__mv')"><img src="closed.png" alt="-"/>&#160;Public Member Functions inherited from <a class="el" href="classipc_1_1session_1_1Session__mv.html">ipc::session::Session_mv&lt; Client_session_impl_t &gt;</a></td></tr>
<tr class="memitem:af964cb260766684d46503b43d0faa777 inherit pub_methods_classipc_1_1session_1_1Session__mv"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classipc_1_1session_1_1Session__mv.html#af964cb260766684d46503b43d0faa777">Session_mv</a> ()</td></tr>
<tr class="memdesc:af964cb260766684d46503b43d0faa777 inherit pub_methods_classipc_1_1session_1_1Session__mv"><td class="mdescLeft">&#160;</td><td class="mdescRight">Implements Session API per contract.  <a href="classipc_1_1session_1_1Session__mv.html#af964cb260766684d46503b43d0faa777">More...</a><br /></td></tr>
<tr class="separator:af964cb260766684d46503b43d0faa777 inherit pub_methods_classipc_1_1session_1_1Session__mv"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad1cffabdbc41809399b4bda9330f5367 inherit pub_methods_classipc_1_1session_1_1Session__mv"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classipc_1_1session_1_1Session__mv.html#ad1cffabdbc41809399b4bda9330f5367">Session_mv</a> (<a class="el" href="classipc_1_1session_1_1Session__mv.html">Session_mv</a> &amp;&amp;src)</td></tr>
<tr class="memdesc:ad1cffabdbc41809399b4bda9330f5367 inherit pub_methods_classipc_1_1session_1_1Session__mv"><td class="mdescLeft">&#160;</td><td class="mdescRight">Implements Session API per contract.  <a href="classipc_1_1session_1_1Session__mv.html#ad1cffabdbc41809399b4bda9330f5367">More...</a><br /></td></tr>
<tr class="separator:ad1cffabdbc41809399b4bda9330f5367 inherit pub_methods_classipc_1_1session_1_1Session__mv"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1293a6369b78d12bad869ca812be0f74 inherit pub_methods_classipc_1_1session_1_1Session__mv"><td class="memItemLeft" align="right" valign="top"><a id="a1293a6369b78d12bad869ca812be0f74" name="a1293a6369b78d12bad869ca812be0f74"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>Session_mv</b> (const <a class="el" href="classipc_1_1session_1_1Session__mv.html">Session_mv</a> &amp;)=delete</td></tr>
<tr class="memdesc:a1293a6369b78d12bad869ca812be0f74 inherit pub_methods_classipc_1_1session_1_1Session__mv"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy ction is disallowed. <br /></td></tr>
<tr class="separator:a1293a6369b78d12bad869ca812be0f74 inherit pub_methods_classipc_1_1session_1_1Session__mv"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0b4f0cdde3221b0922e0b44cbb6011a2 inherit pub_methods_classipc_1_1session_1_1Session__mv"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classipc_1_1session_1_1Session__mv.html#a0b4f0cdde3221b0922e0b44cbb6011a2">~Session_mv</a> ()</td></tr>
<tr class="memdesc:a0b4f0cdde3221b0922e0b44cbb6011a2 inherit pub_methods_classipc_1_1session_1_1Session__mv"><td class="mdescLeft">&#160;</td><td class="mdescRight">Implements Session API per contract.  <a href="classipc_1_1session_1_1Session__mv.html#a0b4f0cdde3221b0922e0b44cbb6011a2">More...</a><br /></td></tr>
<tr class="separator:a0b4f0cdde3221b0922e0b44cbb6011a2 inherit pub_methods_classipc_1_1session_1_1Session__mv"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac000e14183b5dcb523ff0eaaf030968c inherit pub_methods_classipc_1_1session_1_1Session__mv"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classipc_1_1session_1_1Session__mv.html">Session_mv</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classipc_1_1session_1_1Session__mv.html#ac000e14183b5dcb523ff0eaaf030968c">operator=</a> (<a class="el" href="classipc_1_1session_1_1Session__mv.html">Session_mv</a> &amp;&amp;src)</td></tr>
<tr class="memdesc:ac000e14183b5dcb523ff0eaaf030968c inherit pub_methods_classipc_1_1session_1_1Session__mv"><td class="mdescLeft">&#160;</td><td class="mdescRight">Implements Session API per contract.  <a href="classipc_1_1session_1_1Session__mv.html#ac000e14183b5dcb523ff0eaaf030968c">More...</a><br /></td></tr>
<tr class="separator:ac000e14183b5dcb523ff0eaaf030968c inherit pub_methods_classipc_1_1session_1_1Session__mv"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeb7d7965c0fc0736b6c59f5f81a3e8c2 inherit pub_methods_classipc_1_1session_1_1Session__mv"><td class="memItemLeft" align="right" valign="top"><a id="aeb7d7965c0fc0736b6c59f5f81a3e8c2" name="aeb7d7965c0fc0736b6c59f5f81a3e8c2"></a>
<a class="el" href="classipc_1_1session_1_1Session__mv.html">Session_mv</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>operator=</b> (const <a class="el" href="classipc_1_1session_1_1Session__mv.html">Session_mv</a> &amp;)=delete</td></tr>
<tr class="memdesc:aeb7d7965c0fc0736b6c59f5f81a3e8c2 inherit pub_methods_classipc_1_1session_1_1Session__mv"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy assignment is disallowed. <br /></td></tr>
<tr class="separator:aeb7d7965c0fc0736b6c59f5f81a3e8c2 inherit pub_methods_classipc_1_1session_1_1Session__mv"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aba79f245e6f726ac6aa573e45e0bfdf3 inherit pub_methods_classipc_1_1session_1_1Session__mv"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classipc_1_1session_1_1Session__mv.html#a787253f02859ea6b99ce3eba92766431">Mdt_builder_ptr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classipc_1_1session_1_1Session__mv.html#aba79f245e6f726ac6aa573e45e0bfdf3">mdt_builder</a> ()</td></tr>
<tr class="memdesc:aba79f245e6f726ac6aa573e45e0bfdf3 inherit pub_methods_classipc_1_1session_1_1Session__mv"><td class="mdescLeft">&#160;</td><td class="mdescRight">Implements Session API per contract.  <a href="classipc_1_1session_1_1Session__mv.html#aba79f245e6f726ac6aa573e45e0bfdf3">More...</a><br /></td></tr>
<tr class="separator:aba79f245e6f726ac6aa573e45e0bfdf3 inherit pub_methods_classipc_1_1session_1_1Session__mv"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6d8cdbb86140056a7e7d2931ea642b18 inherit pub_methods_classipc_1_1session_1_1Session__mv"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classipc_1_1session_1_1Session__mv.html#a6d8cdbb86140056a7e7d2931ea642b18">open_channel</a> (<a class="el" href="classipc_1_1session_1_1Session__mv.html#ab92df09d894e6e1aaf3c2733da594fd2">Channel_obj</a> *target_channel, const <a class="el" href="classipc_1_1session_1_1Session__mv.html#a787253f02859ea6b99ce3eba92766431">Mdt_builder_ptr</a> &amp;mdt, <a class="el" href="namespaceipc.html#aa3192e586cc45d3e7c22463bf2760f89">Error_code</a> *err_code=0)</td></tr>
<tr class="memdesc:a6d8cdbb86140056a7e7d2931ea642b18 inherit pub_methods_classipc_1_1session_1_1Session__mv"><td class="mdescLeft">&#160;</td><td class="mdescRight">Implements Session API per contract.  <a href="classipc_1_1session_1_1Session__mv.html#a6d8cdbb86140056a7e7d2931ea642b18">More...</a><br /></td></tr>
<tr class="separator:a6d8cdbb86140056a7e7d2931ea642b18 inherit pub_methods_classipc_1_1session_1_1Session__mv"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a84e80e24d7b16da0a9ecf83057acfd8e inherit pub_methods_classipc_1_1session_1_1Session__mv"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classipc_1_1session_1_1Session__mv.html#a84e80e24d7b16da0a9ecf83057acfd8e">open_channel</a> (<a class="el" href="classipc_1_1session_1_1Session__mv.html#ab92df09d894e6e1aaf3c2733da594fd2">Channel_obj</a> *target_channel, <a class="el" href="namespaceipc.html#aa3192e586cc45d3e7c22463bf2760f89">Error_code</a> *err_code=0)</td></tr>
<tr class="memdesc:a84e80e24d7b16da0a9ecf83057acfd8e inherit pub_methods_classipc_1_1session_1_1Session__mv"><td class="mdescLeft">&#160;</td><td class="mdescRight">Implements Session API per contract.  <a href="classipc_1_1session_1_1Session__mv.html#a84e80e24d7b16da0a9ecf83057acfd8e">More...</a><br /></td></tr>
<tr class="separator:a84e80e24d7b16da0a9ecf83057acfd8e inherit pub_methods_classipc_1_1session_1_1Session__mv"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a749f1f679f858d2dce8562cdddc60195 inherit pub_methods_classipc_1_1session_1_1Session__mv"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="namespaceipc_1_1session.html#ade2b302f1a3623e8adc9694568d94d2c">Session_token</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classipc_1_1session_1_1Session__mv.html#a749f1f679f858d2dce8562cdddc60195">session_token</a> () const</td></tr>
<tr class="memdesc:a749f1f679f858d2dce8562cdddc60195 inherit pub_methods_classipc_1_1session_1_1Session__mv"><td class="mdescLeft">&#160;</td><td class="mdescRight">Implements Session API per contract.  <a href="classipc_1_1session_1_1Session__mv.html#a749f1f679f858d2dce8562cdddc60195">More...</a><br /></td></tr>
<tr class="separator:a749f1f679f858d2dce8562cdddc60195 inherit pub_methods_classipc_1_1session_1_1Session__mv"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a107684fdd5d233549c6daac26a81a542 inherit pub_methods_classipc_1_1session_1_1Session__mv"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structipc_1_1transport_1_1struc_1_1Heap__fixed__builder_1_1Config.html">transport::struc::Heap_fixed_builder::Config</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classipc_1_1session_1_1Session__mv.html#a107684fdd5d233549c6daac26a81a542">heap_fixed_builder_config</a> ()</td></tr>
<tr class="memdesc:a107684fdd5d233549c6daac26a81a542 inherit pub_methods_classipc_1_1session_1_1Session__mv"><td class="mdescLeft">&#160;</td><td class="mdescRight">Utility that obtains a heap-based (non-zero-copy) Struct_builder::Config, constructed with the most efficient yet safe values, for transport::struc::Msg_out (out-messages) compatible with <a class="el" href="classipc_1_1session_1_1Session__mv.html#ac205819d4a3a066f31b5af311ff40a2a" title="Implements Session API per contract.">Structured_channel</a> upgraded-from <a class="el" href="classipc_1_1session_1_1Session__mv.html#ab92df09d894e6e1aaf3c2733da594fd2" title="Implements Session API per contract.">Channel_obj</a> channels opened via <code>*this</code> Session_mv.  <a href="classipc_1_1session_1_1Session__mv.html#a107684fdd5d233549c6daac26a81a542">More...</a><br /></td></tr>
<tr class="separator:a107684fdd5d233549c6daac26a81a542 inherit pub_methods_classipc_1_1session_1_1Session__mv"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab3c69e3f8ccbd70d315bed86d697255d inherit pub_methods_classipc_1_1session_1_1Session__mv"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structipc_1_1transport_1_1struc_1_1Heap__reader_1_1Config.html">transport::struc::Heap_reader::Config</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classipc_1_1session_1_1Session__mv.html#ab3c69e3f8ccbd70d315bed86d697255d">heap_reader_config</a> ()</td></tr>
<tr class="memdesc:ab3c69e3f8ccbd70d315bed86d697255d inherit pub_methods_classipc_1_1session_1_1Session__mv"><td class="mdescLeft">&#160;</td><td class="mdescRight">Deserializing counterpart to non-<code>static</code> <a class="el" href="classipc_1_1session_1_1Session__mv.html#a107684fdd5d233549c6daac26a81a542" title="Utility that obtains a heap-based (non-zero-copy) Struct_builder::Config, constructed with the most e...">heap_fixed_builder_config()</a>.  <a href="classipc_1_1session_1_1Session__mv.html#ab3c69e3f8ccbd70d315bed86d697255d">More...</a><br /></td></tr>
<tr class="separator:ab3c69e3f8ccbd70d315bed86d697255d inherit pub_methods_classipc_1_1session_1_1Session__mv"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a142df6d6db09962a1dc0f536bf4977f0 inherit pub_methods_classipc_1_1session_1_1Session__mv"><td class="memItemLeft" align="right" valign="top">flow::log::Logger *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classipc_1_1session_1_1Session__mv.html#a142df6d6db09962a1dc0f536bf4977f0">get_logger</a> () const</td></tr>
<tr class="memdesc:a142df6d6db09962a1dc0f536bf4977f0 inherit pub_methods_classipc_1_1session_1_1Session__mv"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns logger (possibly null).  <a href="classipc_1_1session_1_1Session__mv.html#a142df6d6db09962a1dc0f536bf4977f0">More...</a><br /></td></tr>
<tr class="separator:a142df6d6db09962a1dc0f536bf4977f0 inherit pub_methods_classipc_1_1session_1_1Session__mv"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a23b43187319871c4974755175973008e inherit pub_methods_classipc_1_1session_1_1Session__mv"><td class="memItemLeft" align="right" valign="top">const flow::log::Component &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classipc_1_1session_1_1Session__mv.html#a23b43187319871c4974755175973008e">get_log_component</a> () const</td></tr>
<tr class="memdesc:a23b43187319871c4974755175973008e inherit pub_methods_classipc_1_1session_1_1Session__mv"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns log component.  <a href="classipc_1_1session_1_1Session__mv.html#a23b43187319871c4974755175973008e">More...</a><br /></td></tr>
<tr class="separator:a23b43187319871c4974755175973008e inherit pub_methods_classipc_1_1session_1_1Session__mv"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="related" name="related"></a>
Related Functions</h2></td></tr>
<tr><td class="ititle" colspan="2"><p >(Note that these are not member functions.) </p>
</td></tr>
<tr class="memitem:a8a2e780e6c5266b8c2e4207d7e256afe"><td class="memTemplParams" colspan="2">template&lt;typename Client_session_impl_t &gt; </td></tr>
<tr class="memitem:a8a2e780e6c5266b8c2e4207d7e256afe"><td class="memTemplItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classipc_1_1session_1_1Client__session__mv.html#a8a2e780e6c5266b8c2e4207d7e256afe">operator&lt;&lt;</a> (std::ostream &amp;os, const <a class="el" href="classipc_1_1session_1_1Client__session__mv.html">Client_session_mv</a>&lt; Client_session_impl_t &gt; &amp;val)</td></tr>
<tr class="memdesc:a8a2e780e6c5266b8c2e4207d7e256afe"><td class="mdescLeft">&#160;</td><td class="mdescRight">Prints string representation of the given <code><a class="el" href="classipc_1_1session_1_1Client__session__mv.html" title="Implements Session concept on the Client_app end: a Session_mv that first achieves PEER state by conn...">Client_session_mv</a></code> to the given <code>ostream</code>.  <a href="classipc_1_1session_1_1Client__session__mv.html#a8a2e780e6c5266b8c2e4207d7e256afe">More...</a><br /></td></tr>
<tr class="separator:a8a2e780e6c5266b8c2e4207d7e256afe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header related_classipc_1_1session_1_1Session__mv"><td colspan="2" onclick="javascript:toggleInherit('related_classipc_1_1session_1_1Session__mv')"><img src="closed.png" alt="-"/>&#160;Related Functions inherited from <a class="el" href="classipc_1_1session_1_1Session__mv.html">ipc::session::Session_mv&lt; Client_session_impl_t &gt;</a></td></tr>
<tr class="memitem:a07c2d7a228f070e32bf4f1fbc64e1f6d inherit related_classipc_1_1session_1_1Session__mv"><td class="memItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classipc_1_1session_1_1Session__mv.html#a07c2d7a228f070e32bf4f1fbc64e1f6d">operator&lt;&lt;</a> (std::ostream &amp;os, const <a class="el" href="classipc_1_1session_1_1Session__mv.html">Session_mv</a>&lt; Client_session_impl_t &gt; &amp;val)</td></tr>
<tr class="memdesc:a07c2d7a228f070e32bf4f1fbc64e1f6d inherit related_classipc_1_1session_1_1Session__mv"><td class="mdescLeft">&#160;</td><td class="mdescRight">Prints string representation of the given <code>Session_mv</code> to the given <code>ostream</code>.  <a href="classipc_1_1session_1_1Session__mv.html#a07c2d7a228f070e32bf4f1fbc64e1f6d">More...</a><br /></td></tr>
<tr class="separator:a07c2d7a228f070e32bf4f1fbc64e1f6d inherit related_classipc_1_1session_1_1Session__mv"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="inherited" name="inherited"></a>
Additional Inherited Members</h2></td></tr>
<tr class="inherit_header pub_static_methods_classipc_1_1session_1_1Session__mv"><td colspan="2" onclick="javascript:toggleInherit('pub_static_methods_classipc_1_1session_1_1Session__mv')"><img src="closed.png" alt="-"/>&#160;Static Public Member Functions inherited from <a class="el" href="classipc_1_1session_1_1Session__mv.html">ipc::session::Session_mv&lt; Client_session_impl_t &gt;</a></td></tr>
<tr class="memitem:a26dfe4dd3ff57daab5a36a037f835c4e inherit pub_static_methods_classipc_1_1session_1_1Session__mv"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="structipc_1_1transport_1_1struc_1_1Heap__fixed__builder_1_1Config.html">transport::struc::Heap_fixed_builder::Config</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classipc_1_1session_1_1Session__mv.html#a26dfe4dd3ff57daab5a36a037f835c4e">heap_fixed_builder_config</a> (flow::log::Logger *logger_ptr)</td></tr>
<tr class="memdesc:a26dfe4dd3ff57daab5a36a037f835c4e inherit pub_static_methods_classipc_1_1session_1_1Session__mv"><td class="mdescLeft">&#160;</td><td class="mdescRight">Utility that obtains a heap-based (non-zero-copy) Struct_builder::Config, constructed with the most efficient yet safe values, for transport::struc::Msg_out (out-messages) compatible with <a class="el" href="classipc_1_1session_1_1Session__mv.html#ac205819d4a3a066f31b5af311ff40a2a" title="Implements Session API per contract.">Structured_channel</a> upgraded-from <a class="el" href="classipc_1_1session_1_1Session__mv.html#ab92df09d894e6e1aaf3c2733da594fd2" title="Implements Session API per contract.">Channel_obj</a> channels opened via this Session_mv type.  <a href="classipc_1_1session_1_1Session__mv.html#a26dfe4dd3ff57daab5a36a037f835c4e">More...</a><br /></td></tr>
<tr class="separator:a26dfe4dd3ff57daab5a36a037f835c4e inherit pub_static_methods_classipc_1_1session_1_1Session__mv"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a411feb974e2b7ed48b08ac50bcdf43b3 inherit pub_static_methods_classipc_1_1session_1_1Session__mv"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="structipc_1_1transport_1_1struc_1_1Heap__reader_1_1Config.html">transport::struc::Heap_reader::Config</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classipc_1_1session_1_1Session__mv.html#a411feb974e2b7ed48b08ac50bcdf43b3">heap_reader_config</a> (flow::log::Logger *logger_ptr)</td></tr>
<tr class="memdesc:a411feb974e2b7ed48b08ac50bcdf43b3 inherit pub_static_methods_classipc_1_1session_1_1Session__mv"><td class="mdescLeft">&#160;</td><td class="mdescRight">Deserializing counterpart to <code>static</code> <a class="el" href="classipc_1_1session_1_1Session__mv.html#a107684fdd5d233549c6daac26a81a542" title="Utility that obtains a heap-based (non-zero-copy) Struct_builder::Config, constructed with the most e...">heap_fixed_builder_config()</a>.  <a href="classipc_1_1session_1_1Session__mv.html#a411feb974e2b7ed48b08ac50bcdf43b3">More...</a><br /></td></tr>
<tr class="separator:a411feb974e2b7ed48b08ac50bcdf43b3 inherit pub_static_methods_classipc_1_1session_1_1Session__mv"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pub_static_attribs_classipc_1_1session_1_1Session__mv"><td colspan="2" onclick="javascript:toggleInherit('pub_static_attribs_classipc_1_1session_1_1Session__mv')"><img src="closed.png" alt="-"/>&#160;Static Public Attributes inherited from <a class="el" href="classipc_1_1session_1_1Session__mv.html">ipc::session::Session_mv&lt; Client_session_impl_t &gt;</a></td></tr>
<tr class="memitem:a74af091662cb7c32e0f1c60baac3613b inherit pub_static_attribs_classipc_1_1session_1_1Session__mv"><td class="memItemLeft" align="right" valign="top">static constexpr schema::ShmType&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classipc_1_1session_1_1Session__mv.html#a74af091662cb7c32e0f1c60baac3613b">S_SHM_TYPE</a></td></tr>
<tr class="memdesc:a74af091662cb7c32e0f1c60baac3613b inherit pub_static_attribs_classipc_1_1session_1_1Session__mv"><td class="mdescLeft">&#160;</td><td class="mdescRight">Implements Session API per contract.  <a href="classipc_1_1session_1_1Session__mv.html#a74af091662cb7c32e0f1c60baac3613b">More...</a><br /></td></tr>
<tr class="separator:a74af091662cb7c32e0f1c60baac3613b inherit pub_static_attribs_classipc_1_1session_1_1Session__mv"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a62945e465ae734523036215750c90ba4 inherit pub_static_attribs_classipc_1_1session_1_1Session__mv"><td class="memItemLeft" align="right" valign="top">static constexpr bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classipc_1_1session_1_1Session__mv.html#a62945e465ae734523036215750c90ba4">S_SHM_ENABLED</a></td></tr>
<tr class="memdesc:a62945e465ae734523036215750c90ba4 inherit pub_static_attribs_classipc_1_1session_1_1Session__mv"><td class="mdescLeft">&#160;</td><td class="mdescRight">Implements Session API per contract.  <a href="classipc_1_1session_1_1Session__mv.html#a62945e465ae734523036215750c90ba4">More...</a><br /></td></tr>
<tr class="separator:a62945e465ae734523036215750c90ba4 inherit pub_static_attribs_classipc_1_1session_1_1Session__mv"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6a87002dccab497da76bb286d5a4bf95 inherit pub_static_attribs_classipc_1_1session_1_1Session__mv"><td class="memItemLeft" align="right" valign="top"><a id="a6a87002dccab497da76bb286d5a4bf95" name="a6a87002dccab497da76bb286d5a4bf95"></a>
static constexpr bool&#160;</td><td class="memItemRight" valign="bottom"><b>S_MQS_ENABLED</b></td></tr>
<tr class="memdesc:a6a87002dccab497da76bb286d5a4bf95 inherit pub_static_attribs_classipc_1_1session_1_1Session__mv"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compile-time-known constant indicating whether <a class="el" href="classipc_1_1session_1_1Session__mv.html#ab92df09d894e6e1aaf3c2733da594fd2" title="Implements Session API per contract.">Channel_obj</a> shall use a blobs pipe over message queues (MQs). <br /></td></tr>
<tr class="separator:a6a87002dccab497da76bb286d5a4bf95 inherit pub_static_attribs_classipc_1_1session_1_1Session__mv"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:addc597e6bf3555dc3788116c8cc179dd inherit pub_static_attribs_classipc_1_1session_1_1Session__mv"><td class="memItemLeft" align="right" valign="top">static constexpr bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classipc_1_1session_1_1Session__mv.html#addc597e6bf3555dc3788116c8cc179dd">S_SOCKET_STREAM_ENABLED</a></td></tr>
<tr class="memdesc:addc597e6bf3555dc3788116c8cc179dd inherit pub_static_attribs_classipc_1_1session_1_1Session__mv"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compile-time-known constant indicating whether <a class="el" href="classipc_1_1session_1_1Session__mv.html#ab92df09d894e6e1aaf3c2733da594fd2" title="Implements Session API per contract.">Channel_obj</a> shall use socket stream for any type of pipe.  <a href="classipc_1_1session_1_1Session__mv.html#addc597e6bf3555dc3788116c8cc179dd">More...</a><br /></td></tr>
<tr class="separator:addc597e6bf3555dc3788116c8cc179dd inherit pub_static_attribs_classipc_1_1session_1_1Session__mv"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pro_types_classipc_1_1session_1_1Session__mv"><td colspan="2" onclick="javascript:toggleInherit('pro_types_classipc_1_1session_1_1Session__mv')"><img src="closed.png" alt="-"/>&#160;Protected Types inherited from <a class="el" href="classipc_1_1session_1_1Session__mv.html">ipc::session::Session_mv&lt; Client_session_impl_t &gt;</a></td></tr>
<tr class="memitem:af2c186e7b4be09bff30b42aa2482dd93 inherit pro_types_classipc_1_1session_1_1Session__mv"><td class="memItemLeft" align="right" valign="top"><a id="af2c186e7b4be09bff30b42aa2482dd93" name="af2c186e7b4be09bff30b42aa2482dd93"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>Impl</b> = Client_session_impl_t</td></tr>
<tr class="memdesc:af2c186e7b4be09bff30b42aa2482dd93 inherit pro_types_classipc_1_1session_1_1Session__mv"><td class="mdescLeft">&#160;</td><td class="mdescRight">Short-hand for pImpl-lite impl type. This shall be the deepest impl sub-class desired. <br /></td></tr>
<tr class="separator:af2c186e7b4be09bff30b42aa2482dd93 inherit pro_types_classipc_1_1session_1_1Session__mv"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acb47dfa0f5645cf2da7d62ac5862e8cc inherit pro_types_classipc_1_1session_1_1Session__mv"><td class="memItemLeft" align="right" valign="top"><a id="acb47dfa0f5645cf2da7d62ac5862e8cc" name="acb47dfa0f5645cf2da7d62ac5862e8cc"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>Session_base_obj</b> = typename Impl::Session_base_obj</td></tr>
<tr class="memdesc:acb47dfa0f5645cf2da7d62ac5862e8cc inherit pro_types_classipc_1_1session_1_1Session__mv"><td class="mdescLeft">&#160;</td><td class="mdescRight">Short-hand for <a class="el" href="classipc_1_1session_1_1Session__mv.html#af2c186e7b4be09bff30b42aa2482dd93" title="Short-hand for pImpl-lite impl type. This shall be the deepest impl sub-class desired.">Impl</a>'s Session_base super-class. <br /></td></tr>
<tr class="separator:acb47dfa0f5645cf2da7d62ac5862e8cc inherit pro_types_classipc_1_1session_1_1Session__mv"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a457c661352bf3111ca4f707c15d51b3e inherit pro_types_classipc_1_1session_1_1Session__mv"><td class="memItemLeft" align="right" valign="top"><a id="a457c661352bf3111ca4f707c15d51b3e" name="a457c661352bf3111ca4f707c15d51b3e"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>Impl_ptr</b> = std::experimental::propagate_const&lt; boost::movelib::unique_ptr&lt; <a class="el" href="classipc_1_1session_1_1Session__mv.html#af2c186e7b4be09bff30b42aa2482dd93">Impl</a> &gt; &gt;</td></tr>
<tr class="memdesc:a457c661352bf3111ca4f707c15d51b3e inherit pro_types_classipc_1_1session_1_1Session__mv"><td class="mdescLeft">&#160;</td><td class="mdescRight">Short-hand for <code>const</code>-respecting wrapper around <a class="el" href="classipc_1_1session_1_1Session__mv.html#af2c186e7b4be09bff30b42aa2482dd93" title="Short-hand for pImpl-lite impl type. This shall be the deepest impl sub-class desired.">Impl</a> for the pImpl idiom. See <a class="el" href="classipc_1_1session_1_1Session__mv.html#ae5e646ae3649914384cb2e7f94aa7a25" title="pImpl target; particularly for sub-classes that must add to the above public API.">impl()</a>. <br /></td></tr>
<tr class="separator:a457c661352bf3111ca4f707c15d51b3e inherit pro_types_classipc_1_1session_1_1Session__mv"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pro_methods_classipc_1_1session_1_1Session__mv"><td colspan="2" onclick="javascript:toggleInherit('pro_methods_classipc_1_1session_1_1Session__mv')"><img src="closed.png" alt="-"/>&#160;Protected Member Functions inherited from <a class="el" href="classipc_1_1session_1_1Session__mv.html">ipc::session::Session_mv&lt; Client_session_impl_t &gt;</a></td></tr>
<tr class="memitem:a7589e9e086afae1d8be969c8e6c1987d inherit pro_methods_classipc_1_1session_1_1Session__mv"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classipc_1_1session_1_1Session__mv.html#acb47dfa0f5645cf2da7d62ac5862e8cc">Session_base_obj</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classipc_1_1session_1_1Session__mv.html#a7589e9e086afae1d8be969c8e6c1987d">base</a> () const</td></tr>
<tr class="memdesc:a7589e9e086afae1d8be969c8e6c1987d inherit pro_methods_classipc_1_1session_1_1Session__mv"><td class="mdescLeft">&#160;</td><td class="mdescRight">Provides <code>const</code> access to Session_base super-object.  <a href="classipc_1_1session_1_1Session__mv.html#a7589e9e086afae1d8be969c8e6c1987d">More...</a><br /></td></tr>
<tr class="separator:a7589e9e086afae1d8be969c8e6c1987d inherit pro_methods_classipc_1_1session_1_1Session__mv"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae5e646ae3649914384cb2e7f94aa7a25 inherit pro_methods_classipc_1_1session_1_1Session__mv"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classipc_1_1session_1_1Session__mv.html#a457c661352bf3111ca4f707c15d51b3e">Impl_ptr</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classipc_1_1session_1_1Session__mv.html#ae5e646ae3649914384cb2e7f94aa7a25">impl</a> ()</td></tr>
<tr class="memdesc:ae5e646ae3649914384cb2e7f94aa7a25 inherit pro_methods_classipc_1_1session_1_1Session__mv"><td class="mdescLeft">&#160;</td><td class="mdescRight">pImpl target; particularly for sub-classes that must add to the above <code>public</code> API.  <a href="classipc_1_1session_1_1Session__mv.html#ae5e646ae3649914384cb2e7f94aa7a25">More...</a><br /></td></tr>
<tr class="separator:ae5e646ae3649914384cb2e7f94aa7a25 inherit pro_methods_classipc_1_1session_1_1Session__mv"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a025cd4b449dbfc68008ac9379a07ca63 inherit pro_methods_classipc_1_1session_1_1Session__mv"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classipc_1_1session_1_1Session__mv.html#a457c661352bf3111ca4f707c15d51b3e">Impl_ptr</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classipc_1_1session_1_1Session__mv.html#a025cd4b449dbfc68008ac9379a07ca63">impl</a> () const</td></tr>
<tr class="memdesc:a025cd4b449dbfc68008ac9379a07ca63 inherit pro_methods_classipc_1_1session_1_1Session__mv"><td class="mdescLeft">&#160;</td><td class="mdescRight">pImpl target; particularly for sub-classes that must add to the above <code>public</code> API.  <a href="classipc_1_1session_1_1Session__mv.html#a025cd4b449dbfc68008ac9379a07ca63">More...</a><br /></td></tr>
<tr class="separator:a025cd4b449dbfc68008ac9379a07ca63 inherit pro_methods_classipc_1_1session_1_1Session__mv"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><div class="compoundTemplParams">template&lt;typename Client_session_impl_t&gt;<br />
class ipc::session::Client_session_mv&lt; Client_session_impl_t &gt;</div><p >Implements <a class="el" href="classipc_1_1session_1_1Session.html" title="A documentation-only concept defining the local side of an IPC conversation (session) with another en...">Session</a> concept on the <a class="el" href="structipc_1_1session_1_1Client__app.html" title="An App that is used as a client in at least one client-server IPC split.">Client_app</a> end: a <a class="el" href="classipc_1_1session_1_1Session__mv.html" title="Implements the Session concept when it is in PEER state.">Session_mv</a> that first achieves PEER state by connecting to an opposing Session_server_mv via <a class="el" href="classipc_1_1session_1_1Client__session__mv.html#ae0992c43ab3a978a1023d320d043d8de" title="To be invoked in NULL state only, and not as-if default-cted, it asynchronously attempts to connect t...">Client_session_mv::async_connect()</a>. </p>
<p >See overview of <a class="el" href="classipc_1_1session_1_1Session.html" title="A documentation-only concept defining the local side of an IPC conversation (session) with another en...">Session</a> hierarchy in namespace <a class="el" href="namespaceipc_1_1session.html" title="Flow-IPC module providing the broad lifecycle and shared-resource organization  via the session conc...">ipc::session</a> doc header; then come back here if desired.</p>
<p >It is unusual to use <a class="el" href="classipc_1_1session_1_1Client__session__mv.html" title="Implements Session concept on the Client_app end: a Session_mv that first achieves PEER state by conn...">Client_session_mv</a> template directly. If you do wish to set up a client-side session peer, and you do not require SHM support, then use <a class="el" href="namespaceipc_1_1session.html#a77d8fda00e1e17f595a6a5d4c44375e7" title="A vanilla Client_session with no optional capabilities.">Client_session</a> alias template. The client-specific API, particularly ctor and <a class="el" href="classipc_1_1session_1_1Client__session__mv.html#ae0992c43ab3a978a1023d320d043d8de" title="To be invoked in NULL state only, and not as-if default-cted, it asynchronously attempts to connect t...">async_connect()</a>, is in <a class="el" href="classipc_1_1session_1_1Client__session__mv.html" title="Implements Session concept on the Client_app end: a Session_mv that first achieves PEER state by conn...">Client_session_mv</a> and documented here. The side-agnostic API &ndash; active once PEER state is achieved &ndash; is described by <a class="el" href="classipc_1_1session_1_1Session.html" title="A documentation-only concept defining the local side of an IPC conversation (session) with another en...">Session</a> (concept) doc header and implemented concretely by <a class="el" href="classipc_1_1session_1_1Session__mv.html" title="Implements the Session concept when it is in PEER state.">Session_mv</a> which is our <code>public</code>, non-<code>virtual</code> super-class.</p>
<p >If you do wish to set up a client-side session peer, but you <em>do</em> require SHM support, then use <a class="el" href="namespaceipc_1_1session_1_1shm_1_1classic.html#ac6c443a72e0f22710c83bb1e8c229618" title="This is to session::Client_session what shm::classic::Server_session is to session::Server_session.">shm::classic::Client_session</a> or similar (for other SHM-provider(s)). However <a class="el" href="namespaceipc_1_1session.html#a77d8fda00e1e17f595a6a5d4c44375e7" title="A vanilla Client_session with no optional capabilities.">Client_session</a> (hence <a class="el" href="classipc_1_1session_1_1Client__session__mv.html" title="Implements Session concept on the Client_app end: a Session_mv that first achieves PEER state by conn...">Client_session_mv</a> to which it aliases) is its super-class, and until PEER state is reached its API remains the only relevant API to use. Once <a class="el" href="classipc_1_1session_1_1Client__session__mv.html#ae0992c43ab3a978a1023d320d043d8de" title="To be invoked in NULL state only, and not as-if default-cted, it asynchronously attempts to connect t...">Client_session_mv::async_connect()</a> puts <code>*this</code> into PEER state, super-class <a class="el" href="classipc_1_1session_1_1Session__mv.html" title="Implements the Session concept when it is in PEER state.">Session_mv</a> (= <a class="el" href="classipc_1_1session_1_1Session.html" title="A documentation-only concept defining the local side of an IPC conversation (session) with another en...">Session</a> concept) API continues to be relevant. Also in PEER state SHM-relevant additional API members (e.g., <a class="el" href="classipc_1_1session_1_1shm_1_1classic_1_1Session__mv.html#ac6a4f1fbafb583f37d7586c6a199430f" title="Returns SHM Arena with per-app scope, meaning its pool shall be accessible potentially beyond the lif...">shm::classic::Session_mv::app_shm()</a>`) become of interest.</p>
<p >Summary hierarchy:</p><ul>
<li><a class="el" href="classipc_1_1session_1_1Session__mv.html" title="Implements the Session concept when it is in PEER state.">Session_mv</a> (<a class="el" href="classipc_1_1session_1_1Session.html" title="A documentation-only concept defining the local side of an IPC conversation (session) with another en...">Session</a> concept impl)</li>
<li>^&ndash; <a class="el" href="classipc_1_1session_1_1Client__session__mv.html" title="Implements Session concept on the Client_app end: a Session_mv that first achieves PEER state by conn...">Client_session_mv</a> (adds <a class="el" href="classipc_1_1session_1_1Client__session__mv.html#ae0992c43ab3a978a1023d320d043d8de" title="To be invoked in NULL state only, and not as-if default-cted, it asynchronously attempts to connect t...">async_connect()</a>)</li>
<li>=alias= <a class="el" href="namespaceipc_1_1session.html#a77d8fda00e1e17f595a6a5d4c44375e7" title="A vanilla Client_session with no optional capabilities.">Client_session</a> (parameterizes by transport-configuring knobs = template params)</li>
<li>^&ndash; <a class="el" href="classipc_1_1session_1_1shm_1_1classic_1_1Session__mv.html" title="Implements the SHM-related API common to shm::classic::Server_session and shm::classic::Client_sessio...">shm::classic::Session_mv</a> (adds <code>session_shm()</code>...; suitable for <a class="el" href="structipc_1_1transport_1_1struc_1_1Channel__base_1_1Serialize__via__session__shm.html" title="Tag type for ctor selection: Backing RAM for serialization comes from a given session::Session&#39;s SHM ...">transport::struc::Channel_base::Serialize_via_session_shm</a>)</li>
<li>=alias= <a class="el" href="namespaceipc_1_1session_1_1shm_1_1classic.html#ac6c443a72e0f22710c83bb1e8c229618" title="This is to session::Client_session what shm::classic::Server_session is to session::Server_session.">shm::classic::Client_session</a> (parameterizes by aforementioned knobs = template params)</li>
</ul>
<p >We may refer to <a class="el" href="classipc_1_1session_1_1Client__session__mv.html" title="Implements Session concept on the Client_app end: a Session_mv that first achieves PEER state by conn...">Client_session_mv</a> as <a class="el" href="namespaceipc_1_1session.html#a77d8fda00e1e17f595a6a5d4c44375e7" title="A vanilla Client_session with no optional capabilities.">Client_session</a> below; particularly since it is likeliest used in that form by the user.</p>
<h3>How to use</h3>
<p >Per the <a class="el" href="classipc_1_1session_1_1Session.html" title="A documentation-only concept defining the local side of an IPC conversation (session) with another en...">Session</a> concept a <a class="el" href="namespaceipc_1_1session.html#a77d8fda00e1e17f595a6a5d4c44375e7" title="A vanilla Client_session with no optional capabilities.">Client_session</a> is open/capable of operation when in PEER state only. A <a class="el" href="namespaceipc_1_1session.html#a77d8fda00e1e17f595a6a5d4c44375e7" title="A vanilla Client_session with no optional capabilities.">Client_session</a> object is always in one of 3 states:</p><ul>
<li>NULL. In this state, the object is doing nothing; neither connected nor connecting.</li>
<li>CONNECTING. In this state the object is trying to enter PEER state.</li>
<li>PEER. At this stage it exactly implements the <a class="el" href="classipc_1_1session_1_1Session.html" title="A documentation-only concept defining the local side of an IPC conversation (session) with another en...">Session</a> concept. See <a class="el" href="classipc_1_1session_1_1Session__mv.html" title="Implements the Session concept when it is in PEER state.">Session_mv</a>. Reminder: It is not possible to exit PEER state.</li>
</ul>
<p >To get from NULL state to PEER state: Use <a class="el" href="classipc_1_1session_1_1Session__server.html" title="To be instantiated typically once in a given process, an object of this type asynchronously listens f...">Session_server</a> on the other side. On this side construct a <a class="el" href="namespaceipc_1_1session.html#a77d8fda00e1e17f595a6a5d4c44375e7" title="A vanilla Client_session with no optional capabilities.">Client_session</a> (always in NULL state) and invoke <a class="el" href="classipc_1_1session_1_1Client__session__mv.html#ae0992c43ab3a978a1023d320d043d8de" title="To be invoked in NULL state only, and not as-if default-cted, it asynchronously attempts to connect t...">async_connect()</a> which will move to CONNECTING state immediately and, eventually on success, to PEER state (mission accomplished). If the connect fails it will go back to NULL state. Being moved-from makes a <code>*this</code> as-if default-cted; therefore also moves to NULL state.</p>
<p >Once in PEER state <a class="el" href="namespaceipc_1_1session.html#a77d8fda00e1e17f595a6a5d4c44375e7" title="A vanilla Client_session with no optional capabilities.">Client_session</a> simply follows <a class="el" href="classipc_1_1session_1_1Session.html" title="A documentation-only concept defining the local side of an IPC conversation (session) with another en...">Session</a> concept semantics. At this stage our super-class <a class="el" href="classipc_1_1session_1_1Session__mv.html" title="Implements the Session concept when it is in PEER state.">Session_mv</a> implements that concept in particular. See either doc header (<a class="el" href="classipc_1_1session_1_1Session.html" title="A documentation-only concept defining the local side of an IPC conversation (session) with another en...">Session</a>, <a class="el" href="classipc_1_1session_1_1Session__mv.html" title="Implements the Session concept when it is in PEER state.">Session_mv</a>).</p>
<p >A related reminder:</p><ul>
<li><a class="el" href="classipc_1_1session_1_1Client__session__mv.html#ae0992c43ab3a978a1023d320d043d8de" title="To be invoked in NULL state only, and not as-if default-cted, it asynchronously attempts to connect t...">async_connect()</a> or the opposing <code>async_accept()</code> or both may optionally specify that 1+ <em>init-channels</em> be opened before this and the opposing <a class="el" href="classipc_1_1session_1_1Session.html" title="A documentation-only concept defining the local side of an IPC conversation (session) with another en...">Session</a> is in PEER state and emitted to user. This may be a sufficient replacement of, or complementary to, active-open/passive-open APIs available once the <a class="el" href="classipc_1_1session_1_1Session.html" title="A documentation-only concept defining the local side of an IPC conversation (session) with another en...">Session</a> is in PEER state/emitted to user. If not sufficient:</li>
<li>Either side (being a <a class="el" href="classipc_1_1session_1_1Session__mv.html" title="Implements the Session concept when it is in PEER state.">Session_mv</a> = <a class="el" href="classipc_1_1session_1_1Session.html" title="A documentation-only concept defining the local side of an IPC conversation (session) with another en...">Session</a>) has <a class="el" href="classipc_1_1session_1_1Session__mv.html#a6d8cdbb86140056a7e7d2931ea642b18" title="Implements Session API per contract.">open_channel()</a>, and hence either side can accept passive-opens when the opposing side invokes <a class="el" href="classipc_1_1session_1_1Session__mv.html#a6d8cdbb86140056a7e7d2931ea642b18" title="Implements Session API per contract.">open_channel()</a>.</li>
<li>However it is possible to configure either side to not accept passive-opens; meaning to be useful such a side shall be exclusively doing <a class="el" href="classipc_1_1session_1_1Session__mv.html#a6d8cdbb86140056a7e7d2931ea642b18" title="Implements Session API per contract.">open_channel()</a> (active-opens). One might conclude, then, that Server_session should be passive-opening, while <a class="el" href="namespaceipc_1_1session.html#a77d8fda00e1e17f595a6a5d4c44375e7" title="A vanilla Client_session with no optional capabilities.">Client_session</a> should be active-opening. That is <em>not</em> the case. In PEER state established on both sides, the 2 sides are identical in this respect. If both sides are configured to accept passive-opens, then there's no question. If one side is so configured, it can be either side. If both sides are so configured, the session is useless, as every <a class="el" href="classipc_1_1session_1_1Session__mv.html#a6d8cdbb86140056a7e7d2931ea642b18" title="Implements Session API per contract.">open_channel()</a> will fail (unless one has set up init-channels).<ul>
<li>In <a class="el" href="namespaceipc_1_1session.html#a77d8fda00e1e17f595a6a5d4c44375e7" title="A vanilla Client_session with no optional capabilities.">Client_session</a>, one specifies the on-passive-open handler in ctor; to disable passive-opens use the ctor that omits that handler.</li>
</ul>
</li>
</ul>
<h3>Thread safety and handler invocation semantics</h3>
<p >These follow the <a class="el" href="classipc_1_1session_1_1Session.html" title="A documentation-only concept defining the local side of an IPC conversation (session) with another en...">Session</a> concept policies. In particular the following prohibition extends to <a class="el" href="classipc_1_1session_1_1Client__session__mv.html#ae0992c43ab3a978a1023d320d043d8de" title="To be invoked in NULL state only, and not as-if default-cted, it asynchronously attempts to connect t...">async_connect()</a>: It is <em>not</em> allowed to invoke <code>*this</code> APIs (practically speaking <a class="el" href="classipc_1_1session_1_1Client__session__mv.html#ae0992c43ab3a978a1023d320d043d8de" title="To be invoked in NULL state only, and not as-if default-cted, it asynchronously attempts to connect t...">async_connect()</a> itself again) from within <a class="el" href="classipc_1_1session_1_1Client__session__mv.html#ae0992c43ab3a978a1023d320d043d8de" title="To be invoked in NULL state only, and not as-if default-cted, it asynchronously attempts to connect t...">async_connect()</a> completion handler.</p>
<h3>Error handling</h3>
<p >Once in PEER state, error handling follows the <a class="el" href="classipc_1_1session_1_1Session.html" title="A documentation-only concept defining the local side of an IPC conversation (session) with another en...">Session</a> concept (= <a class="el" href="classipc_1_1session_1_1Session__mv.html" title="Implements the Session concept when it is in PEER state.">Session_mv</a> concrete class) doc header. However, up to that point it is different and more akin to boost.asio semantics. Namely:</p><ul>
<li>In NULL state: there are no errors.</li>
<li>In CONNECTING state &ndash; while an <a class="el" href="classipc_1_1session_1_1Client__session__mv.html#ae0992c43ab3a978a1023d320d043d8de" title="To be invoked in NULL state only, and not as-if default-cted, it asynchronously attempts to connect t...">async_connect()</a> is outstanding &ndash; an error may occur which moves <code>*this</code> back to NULL state and emits the error into the user handler given to <a class="el" href="classipc_1_1session_1_1Client__session__mv.html#ae0992c43ab3a978a1023d320d043d8de" title="To be invoked in NULL state only, and not as-if default-cted, it asynchronously attempts to connect t...">async_connect()</a>. If dtor is invoked before <a class="el" href="classipc_1_1session_1_1Client__session__mv.html#ae0992c43ab3a978a1023d320d043d8de" title="To be invoked in NULL state only, and not as-if default-cted, it asynchronously attempts to connect t...">async_connect()</a> has a chance to complete then the handler is invoked with <a class="el" href="namespaceipc_1_1session_1_1error.html#a0708d4bec9ae853f4d7e3d7822fc8f2fafe29343445a7bf167cc186a44bd2c6ed" title="Async completion handler is being called prematurely, because underlying object is shutting down,...">session::error::Code::S_OBJECT_SHUTDOWN_ABORTED_COMPLETION_HANDLER</a>. (Subtlety: <a class="el" href="namespaceipc_1_1transport_1_1error.html#adfef15ef4e76cc55d652fbd9c2797297afe29343445a7bf167cc186a44bd2c6ed" title="Async completion handler is being called prematurely, because underlying object is shutting down,...">transport::error::Code::S_OBJECT_SHUTDOWN_ABORTED_COMPLETION_HANDLER</a> is a different value; so just be careful when checking for it.)</li>
</ul>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classipc_1_1session_1_1Session.html" title="A documentation-only concept defining the local side of an IPC conversation (session) with another en...">Session</a>: implemented concept.</dd></dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Client_session_impl_t</td><td>An implementation detail. Use one of the aliases prescribed near the top of this doc header to set this correctly. </td></tr>
  </table>
  </dd>
</dl>
</div><h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="af1341c2f02d27a766996639edd32dfa8" name="af1341c2f02d27a766996639edd32dfa8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af1341c2f02d27a766996639edd32dfa8">&#9670;&nbsp;</a></span>Client_session_mv() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Client_session_impl_t &gt; </div>
<div class="memtemplate">
template&lt;typename On_passive_open_channel_handler , typename Task_err &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classipc_1_1session_1_1Client__session__mv.html">ipc::session::Client_session_mv</a>&lt; Client_session_impl_t &gt;::Client_session_mv </td>
          <td>(</td>
          <td class="paramtype">flow::log::Logger *&#160;</td>
          <td class="paramname"><em>logger_ptr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structipc_1_1session_1_1Client__app.html">Client_app</a> &amp;&#160;</td>
          <td class="paramname"><em>cli_app_ref</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structipc_1_1session_1_1Server__app.html">Server_app</a> &amp;&#160;</td>
          <td class="paramname"><em>srv_app_ref</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Task_err &amp;&amp;&#160;</td>
          <td class="paramname"><em>on_err_func</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">On_passive_open_channel_handler &amp;&amp;&#160;</td>
          <td class="paramname"><em>on_passive_open_channel_func</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">explicit</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Constructs (passive-opens allowed form) in NULL state. </p>
<p >To be useful, invoke <a class="el" href="classipc_1_1session_1_1Client__session__mv.html#ae0992c43ab3a978a1023d320d043d8de" title="To be invoked in NULL state only, and not as-if default-cted, it asynchronously attempts to connect t...">async_connect()</a> next.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">logger_ptr</td><td>Logger to use for logging subsequently. </td></tr>
    <tr><td class="paramname">cli_app_ref</td><td>Properties of this client application. The address is copied; the object is not copied. </td></tr>
    <tr><td class="paramname">srv_app_ref</td><td>Properties of the opposing server application. The address is copied; the object is not copied. </td></tr>
    <tr><td class="paramname">on_err_func</td><td>On-error handler. See <a class="el" href="classipc_1_1session_1_1Session.html" title="A documentation-only concept defining the local side of an IPC conversation (session) with another en...">Session</a> concept doc header for semantics. </td></tr>
    <tr><td class="paramname">on_passive_open_channel_func</td><td>On-passive-open handler. See <a class="el" href="classipc_1_1session_1_1Session.html" title="A documentation-only concept defining the local side of an IPC conversation (session) with another en...">Session</a> concept doc header for semantics. </td></tr>
  </table>
  </dd>
</dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">On_passive_open_channel_handler</td><td>See <a class="el" href="classipc_1_1session_1_1Session.html" title="A documentation-only concept defining the local side of an IPC conversation (session) with another en...">Session</a> concept doc header for semantics. </td></tr>
    <tr><td class="paramname">Task_err</td><td>See <a class="el" href="classipc_1_1session_1_1Session.html" title="A documentation-only concept defining the local side of an IPC conversation (session) with another en...">Session</a> concept doc header for semantics. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a2c1a00a343a70a31cb630969138b6b25" name="a2c1a00a343a70a31cb630969138b6b25"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2c1a00a343a70a31cb630969138b6b25">&#9670;&nbsp;</a></span>Client_session_mv() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Client_session_impl_t &gt; </div>
<div class="memtemplate">
template&lt;typename Task_err &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classipc_1_1session_1_1Client__session__mv.html">ipc::session::Client_session_mv</a>&lt; Client_session_impl_t &gt;::Client_session_mv </td>
          <td>(</td>
          <td class="paramtype">flow::log::Logger *&#160;</td>
          <td class="paramname"><em>logger_ptr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structipc_1_1session_1_1Client__app.html">Client_app</a> &amp;&#160;</td>
          <td class="paramname"><em>cli_app_ref</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structipc_1_1session_1_1Server__app.html">Server_app</a> &amp;&#160;</td>
          <td class="paramname"><em>srv_app_ref</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Task_err &amp;&amp;&#160;</td>
          <td class="paramname"><em>on_err_func</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">explicit</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Constructs (passive-opens disallowed form) in NULL state. </p>
<p >To be useful, invoke <a class="el" href="classipc_1_1session_1_1Client__session__mv.html#ae0992c43ab3a978a1023d320d043d8de" title="To be invoked in NULL state only, and not as-if default-cted, it asynchronously attempts to connect t...">async_connect()</a> next.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">logger_ptr</td><td>Logger to use for logging subsequently. </td></tr>
    <tr><td class="paramname">cli_app_ref</td><td>Properties of this client application. The address is copied; the object is not copied. </td></tr>
    <tr><td class="paramname">srv_app_ref</td><td>Properties of the opposing server application. The address is copied; the object is not copied. </td></tr>
    <tr><td class="paramname">on_err_func</td><td>On-error handler. See <a class="el" href="classipc_1_1session_1_1Session.html" title="A documentation-only concept defining the local side of an IPC conversation (session) with another en...">Session</a> concept doc header for semantics. </td></tr>
  </table>
  </dd>
</dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Task_err</td><td>See <a class="el" href="classipc_1_1session_1_1Session.html" title="A documentation-only concept defining the local side of an IPC conversation (session) with another en...">Session</a> concept doc header for semantics. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="a6a36828595840c78a9cb6d900fe9fd9c" name="a6a36828595840c78a9cb6d900fe9fd9c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6a36828595840c78a9cb6d900fe9fd9c">&#9670;&nbsp;</a></span>async_connect() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Client_session_impl_t &gt; </div>
<div class="memtemplate">
template&lt;typename Task_err &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classipc_1_1session_1_1Client__session__mv.html">ipc::session::Client_session_mv</a>&lt; Client_session_impl_t &gt;::async_connect </td>
          <td>(</td>
          <td class="paramtype">const typename <a class="el" href="classipc_1_1session_1_1Session__mv.html#a787253f02859ea6b99ce3eba92766431">Base::Mdt_builder_ptr</a> &amp;&#160;</td>
          <td class="paramname"><em>mdt</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">typename <a class="el" href="classipc_1_1session_1_1Session__mv.html#af87da439644b2afd73d6a13d97e7985f">Base::Channels</a> *&#160;</td>
          <td class="paramname"><em>init_channels_by_cli_req_pre_sized</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">typename <a class="el" href="classipc_1_1session_1_1Session__mv.html#a2b1215fb0c9738b9fcfbb337d23c43df">Base::Mdt_reader_ptr</a> *&#160;</td>
          <td class="paramname"><em>mdt_from_srv_or_null</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">typename <a class="el" href="classipc_1_1session_1_1Session__mv.html#af87da439644b2afd73d6a13d97e7985f">Base::Channels</a> *&#160;</td>
          <td class="paramname"><em>init_channels_by_srv_req</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Task_err &amp;&amp;&#160;</td>
          <td class="paramname"><em>on_done_func</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Identical to the simpler <a class="el" href="classipc_1_1session_1_1Client__session__mv.html#ae0992c43ab3a978a1023d320d043d8de" title="To be invoked in NULL state only, and not as-if default-cted, it asynchronously attempts to connect t...">async_connect()</a> overload but offers added advanced capabilities: metadata exchange; initial-channel opening. </p>
<p >The other overload is identical to <code>async_connect(mdt_builder(), nullptr, nullptr, nullptr, on_done_func)</code> and requires the opposing <code>async_accept()</code> to similarly not use the corresponding features.</p>
<h3>Client-&gt;server metadata exchange</h3>
<p >Client may wish to provide information in some way, but without a structured channel &ndash; or any channel &ndash; yet available, this provides an opportunity to do so in a structured way with a one-off message available at session open, together with the opposing <a class="el" href="classipc_1_1session_1_1Session.html" title="A documentation-only concept defining the local side of an IPC conversation (session) with another en...">Session</a> object itself.</p>
<p >Similarly to how it is optionally done on a per-channel-open basis (<a class="el" href="classipc_1_1session_1_1Session__mv.html#a6d8cdbb86140056a7e7d2931ea642b18" title="Implements Session API per contract.">open_channel()</a>): call <code>mdt = <a class="el" href="classipc_1_1session_1_1Client__session__mv.html#aba3aa4758c635339289d66be45df343b" title="Implements Session API per contract; plus usable to generate blank mdt argument for advanced async_co...">mdt_builder()</a></code>; fill out the resulting capnp structure <code>*mdt</code>; then pass <code>mdt</code> to <a class="el" href="classipc_1_1session_1_1Client__session__mv.html#ae0992c43ab3a978a1023d320d043d8de" title="To be invoked in NULL state only, and not as-if default-cted, it asynchronously attempts to connect t...">async_connect()</a>. Opposing <code>async_accept()</code> shall receive deserializable <code>Mdt_reader</code> together with the freshly-opened <a class="el" href="classipc_1_1session_1_1Session.html" title="A documentation-only concept defining the local side of an IPC conversation (session) with another en...">Session</a>, though they may choose to ignore it.</p>
<p >To omit using this feature, skip the "fill out the resulting capnp structure" step. You must still call <a class="el" href="classipc_1_1session_1_1Client__session__mv.html#aba3aa4758c635339289d66be45df343b" title="Implements Session API per contract; plus usable to generate blank mdt argument for advanced async_co...">mdt_builder()</a> and pass-in the result. (The other overload does so.)</p>
<h3>Server-&gt;client metadata exchange</h3>
<p >This is the reverse of the above. Whatever the opposing server chose to supply as server-&gt;client metadata shall be deserializable at <code>*mdt_from_srv_or_null</code> once (and if) <code>on_done_func(Error_code())</code> (successful connect) fires. If <code>mdt_from_srv_or_null</code> is null, the srv-&gt;cli metadata shall be ignored.</p>
<h3>Init-channels by client request</h3>
<p >Once the session is open, <a class="el" href="classipc_1_1session_1_1Session__mv.html#a6d8cdbb86140056a7e7d2931ea642b18" title="Implements Session API per contract.">open_channel()</a> and the on-passive-open handler may be used to open channels at will. In many use cases, however, a certain number of channels is required immediately before work can really begin (and, frequently, no further channels are even needed). For convenience (to avoid asynchrony/boiler-plate) the init-channels feature will pre-open a requested # of channels making them available right away, together with the freshly-open session &ndash; to both sides.</p>
<p >The client may request 0 or more init-channels. They shall be opened and placed into <code>*init_channels_by_cli_req_pre_sized</code>; its <code>-&gt;size()</code> at entry to the method indicates the number of channels requested. If null, it is treated as if <code>-&gt;size() == 0</code>, meaning no init-channels-by-client-request are opened.</p>
<h3>Init-channels by server request</h3>
<p >This is the reverse of the above. The opposing side shall request 0 or more init-channels-by-server-request; that number of channels shall be opened; and they will be placed into <code>*init_channels_by_srv_req</code> which shall be <code>-&gt;resize()</code>d accordingly, once (and if) <code>on_done_func(Error_code())</code> (successful connect) fires.</p>
<p ><code>init_channels_by_srv_req</code> being null is allowed, but only if the opposing server requests 0 init-channels-by-server-request. Otherwise an error shall be emitted (see below).</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Task_err</td><td>See other <a class="el" href="classipc_1_1session_1_1Client__session__mv.html#ae0992c43ab3a978a1023d320d043d8de" title="To be invoked in NULL state only, and not as-if default-cted, it asynchronously attempts to connect t...">async_connect()</a> overload. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">mdt</td><td>See above. </td></tr>
    <tr><td class="paramname">init_channels_by_cli_req_pre_sized</td><td>See above: null or pointer to container of <code>Channel_obj</code> with <code>.size()</code> specifying how many channels this side is requesting to be opened on its behalf; each element will be move-assigned a PEER-state <code>Channel_obj</code> on success. Recommend simply ct-ing with <code>(n)</code> or <code>.resize(n)</code> which loads it with default-cted (NULL-state) objects to be replaced. null is treated same as <code>.empty()</code>. </td></tr>
    <tr><td class="paramname">mdt_from_srv_or_null</td><td>See above: null or pointer to <code>Reader</code> of metadata which shall be set for access on success. </td></tr>
    <tr><td class="paramname">init_channels_by_srv_req</td><td>See above: null or pointer to container of <code>Channel_obj</code> which shall be <code>.clear()</code>ed and replaced by a container of PEER-state <code>Channel_obj</code> on success the number being specified by the opposing (server) side. The number may be zero. null is allowed if and only if the number is zero; otherwise <a class="el" href="namespaceipc_1_1session_1_1error.html#a0708d4bec9ae853f4d7e3d7822fc8f2fac416e988563e44bf15fc6a81743eef53" title="User called an API with 1 or more arguments against the API spec.">error::Code::S_INVALID_ARGUMENT</a> is emitted. </td></tr>
    <tr><td class="paramname">on_done_func</td><td>See other <a class="el" href="classipc_1_1session_1_1Client__session__mv.html#ae0992c43ab3a978a1023d320d043d8de" title="To be invoked in NULL state only, and not as-if default-cted, it asynchronously attempts to connect t...">async_connect()</a> overload. Note the above target (pointer) args are touched only if falsy <a class="el" href="namespaceipc.html#aa3192e586cc45d3e7c22463bf2760f89" title="Short-hand for boost.interprocess namespace.">Error_code</a> is passed to this handler. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>See other <a class="el" href="classipc_1_1session_1_1Client__session__mv.html#ae0992c43ab3a978a1023d320d043d8de" title="To be invoked in NULL state only, and not as-if default-cted, it asynchronously attempts to connect t...">async_connect()</a> overload. </dd></dl>

</div>
</div>
<a id="ae0992c43ab3a978a1023d320d043d8de" name="ae0992c43ab3a978a1023d320d043d8de"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae0992c43ab3a978a1023d320d043d8de">&#9670;&nbsp;</a></span>async_connect() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Client_session_impl_t &gt; </div>
<div class="memtemplate">
template&lt;typename Task_err &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classipc_1_1session_1_1Client__session__mv.html">ipc::session::Client_session_mv</a>&lt; Client_session_impl_t &gt;::async_connect </td>
          <td>(</td>
          <td class="paramtype">Task_err &amp;&amp;&#160;</td>
          <td class="paramname"><em>on_done_func</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>To be invoked in NULL state only, and not as-if default-cted, it asynchronously attempts to connect to a opposing <code><a class="el" href="classipc_1_1session_1_1Session__server.html" title="To be instantiated typically once in a given process, an object of this type asynchronously listens f...">Session_server</a></code>; and on success invokes the given completion handler with a falsy value indicating <code>*this</code> has entered PEER state. </p>
<p >On failure invokes completion handler with a truthy values indicating <code>*this</code> has returned to NULL state. In the meantime <code>*this</code> is in CONNECTING state.</p>
<p >If invoked outside of NULL state, or if it is as-if default-cted (i.e., default-cted or moved-from), this returns <code>false</code> and otherwise does nothing.</p>
<p >In particular: Do not invoke <a class="el" href="classipc_1_1session_1_1Client__session__mv.html#ae0992c43ab3a978a1023d320d043d8de" title="To be invoked in NULL state only, and not as-if default-cted, it asynchronously attempts to connect t...">async_connect()</a> while one is already outstanding: <code>*this</code> must be in NULL state, not CONNECTING. Also note that <code>*this</code> (modulo moves) that has entered PEER state can never change state subsequently (even on transmission error); once a PEER, always a PEER.</p>
<p ><a class="el" href="namespaceipc.html#aa3192e586cc45d3e7c22463bf2760f89" title="Short-hand for boost.interprocess namespace.">Error_code</a> generated and passed to <code>on_done_func()</code>: <a class="el" href="namespaceipc_1_1session_1_1error.html#a0708d4bec9ae853f4d7e3d7822fc8f2fafe29343445a7bf167cc186a44bd2c6ed" title="Async completion handler is being called prematurely, because underlying object is shutting down,...">session::error::Code::S_OBJECT_SHUTDOWN_ABORTED_COMPLETION_HANDLER</a> (destructor called, canceling all pending ops; spiritually identical to <code>boost::asio::error::operation_aborted</code>), interprocess-mutex-related errors (probably from boost.interprocess) w/r/t reading the CNS (PID file), file-related system errors w/r/t reading the CNS (PID file) (see <a class="el" href="classipc_1_1session_1_1Session__server.html" title="To be instantiated typically once in a given process, an object of this type asynchronously listens f...">Session_server</a> doc header for background), <a class="el" href="namespaceipc_1_1session_1_1error.html#a0708d4bec9ae853f4d7e3d7822fc8f2fa486f5607320d062fe89e559a1e7856b2" title="Session master channel: log-in as client: The Client Namespace Store (CNS) file (a/k/a PID file) lack...">error::Code::S_CLIENT_NAMESPACE_STORE_BAD_FORMAT</a> (bad CNS contents), those emitted by <a class="el" href="classipc_1_1transport_1_1Native__socket__stream.html#a3614a9677c1a203090b97ac935093390" title="To be invoked in NULL state only, it asynchronously attempts to connect to an opposing Native_socket_...">transport::Native_socket_stream::async_connect()</a>, those emitted by <a class="el" href="classipc_1_1transport_1_1struc_1_1Channel.html#ae645cb58ad9ea6374970f1f32c5da448" title="In the synchronous/non-blocking manner of Blob_sender::send_blob() or Native_handle_sender::send_nati...">transport::struc::Channel::send()</a>, those emitted by <a class="el" href="classipc_1_1transport_1_1struc_1_1Channel.html" title="Owning and wrapping a pre-connected transport::Channel peer (an endpoint of an established channel ov...">transport::struc::Channel</a> via on-error handler (most likely <a class="el" href="namespaceipc_1_1transport_1_1error.html#adfef15ef4e76cc55d652fbd9c2797297aad44f87d53255ba573d57086dfeab805" title="Will not receive message: either opposing user sent graceful-close via API.">transport::error::Code::S_RECEIVES_FINISHED_CANNOT_RECEIVE</a> indicating graceful shutdown of opposing process coincidentally during log-in procedure, prematurely ending session while it was starting), <a class="el" href="namespaceipc_1_1session_1_1error.html#a0708d4bec9ae853f4d7e3d7822fc8f2fa866090a4d042120126722b4daf1ecc33" title="Session master channel: log-in as client: received log-in response is not the expected internal messa...">error::Code::S_CLIENT_MASTER_LOG_IN_RESPONSE_BAD</a>, <a class="el" href="namespaceipc_1_1session_1_1error.html#a0708d4bec9ae853f4d7e3d7822fc8f2fac416e988563e44bf15fc6a81743eef53" title="User called an API with 1 or more arguments against the API spec.">error::Code::S_INVALID_ARGUMENT</a> (other side expected other <a class="el" href="classipc_1_1session_1_1Client__session__mv.html#ae0992c43ab3a978a1023d320d043d8de" title="To be invoked in NULL state only, and not as-if default-cted, it asynchronously attempts to connect t...">async_connect()</a> overload with non-null <code>init_channels_by_srv_req</code> arg).</p>
<h3>How does it know "where" the <a class="el" href="classipc_1_1session_1_1Session__server.html" title="To be instantiated typically once in a given process, an object of this type asynchronously listens f...">Session_server</a> is listening?</h3>
<p >While details are internal, abstractly speaking this is determined by the <a class="el" href="structipc_1_1session_1_1Server__app.html" title="An App that is used as a server in at least one client-server IPC split.">Server_app</a> passed to the ctor. Internal detail (for general knowledge):</p><ul>
<li>The server application maintains a <em>CNS</em> (Current Namespace Store, a/k/a PID) file. Only at most 1 server <em>instance</em> (a/k/a process) shall be active at a time. The CNS contents &ndash; which are simply the active server app process's PID &ndash; determine "where" this <code>Client_session</code> will connect, and all other internally used cross-process resources (sockets, MQs, SHM pools...) are similarly segregated among different instances of the Server_app-described application.</li>
<li>The location of this file is determined by <a class="el" href="structipc_1_1session_1_1Server__app.html" title="An App that is used as a server in at least one client-server IPC split.">Server_app</a> contents. Namely, <a class="el" href="structipc_1_1session_1_1App.html#a8e67b57829fe43a122a23c699b5de8fd" title="Brief application name, readable to humans and unique across all other applications&#39; names; used both...">Server_app::m_name</a>, at least, is unique per <a class="el" href="structipc_1_1session_1_1Server__app.html" title="An App that is used as a server in at least one client-server IPC split.">Server_app</a> in the universe, and most of the PID file's name comprises it; and its location comprises <a class="el" href="structipc_1_1session_1_1Server__app.html#a4fa3317f8c57042789940be94f872500" title="Absolute path to the directory (without trailing separator) in the file system where kernel-persisten...">Server_app::m_kernel_persistent_run_dir_override</a> and/or /var/run (or equivalent).</li>
<li><a class="el" href="classipc_1_1session_1_1Client__session__mv.html#ae0992c43ab3a978a1023d320d043d8de" title="To be invoked in NULL state only, and not as-if default-cted, it asynchronously attempts to connect t...">async_connect()</a> reads the CNS (PID) file at that location, unique among <code><a class="el" href="structipc_1_1session_1_1Server__app.html" title="An App that is used as a server in at least one client-server IPC split.">Server_app</a></code>s. Now it knows "where" to connect in order to open the session; so it won't accidentally connect to some old zombie instance of the <a class="el" href="structipc_1_1session_1_1Server__app.html" title="An App that is used as a server in at least one client-server IPC split.">Server_app</a> (its PID wouldn't be in the CNS file any longer) or another application entirely (its PID file would be located elsewhere and never accessed by this <a class="el" href="classipc_1_1session_1_1Client__session__mv.html#ae0992c43ab3a978a1023d320d043d8de" title="To be invoked in NULL state only, and not as-if default-cted, it asynchronously attempts to connect t...">async_connect()</a>).</li>
</ul>
<h3>What if the CNS (PID) file does not exist? What if server is inactive?</h3>
<p >Then <a class="el" href="classipc_1_1session_1_1Client__session__mv.html#ae0992c43ab3a978a1023d320d043d8de" title="To be invoked in NULL state only, and not as-if default-cted, it asynchronously attempts to connect t...">async_connect()</a> will quickly fail (file-not-found error). Shouldn't we supply some API to await its appearance? Answer: Probably not. Why? Answer: Consider the situation where the PID file is there, but it belongs to a now-exited instance of the <a class="el" href="structipc_1_1session_1_1Server__app.html" title="An App that is used as a server in at least one client-server IPC split.">Server_app</a>; let's say it is currently suspended or restarting. <a class="el" href="classipc_1_1session_1_1Client__session__mv.html#ae0992c43ab3a978a1023d320d043d8de" title="To be invoked in NULL state only, and not as-if default-cted, it asynchronously attempts to connect t...">async_connect()</a> will fail then too: There is nothing listening (anymore) at the advertised PID. So it'll quickly fail (connection-refused error). So then we'd also need an API to await an active server's appearance whether or not the PID exists. That leads to the following to-do:</p>
<dl class="todo"><dt><b><a class="el" href="todo.html#_todo000020">Todo:</a></b></dt><dd>Consider adding an optional mode to <a class="el" href="classipc_1_1session_1_1Client__session__mv.html#ae0992c43ab3a978a1023d320d043d8de" title="To be invoked in NULL state only, and not as-if default-cted, it asynchronously attempts to connect t...">async_connect()</a> wherein it does not fail if the CNS (PID) file does not exist, or it does but the initial session-open connect op is refused; instead it detects these relatively common conditions (server not yet up and/or is restarting and/or is operationally suspended for now, etc.) as normal and waits until the condition is cleared. Without this mode, a typical user would probably do something like: oh, <a class="el" href="classipc_1_1session_1_1Client__session__mv.html#ae0992c43ab3a978a1023d320d043d8de" title="To be invoked in NULL state only, and not as-if default-cted, it asynchronously attempts to connect t...">async_connect()</a> failed; let's sleep 1 sec and try again (rinse/repeat). It's not awful, but we might as well make it easier and more responsive out of the box (optionally). Upon resolving this to-do please update the Manual section <a class="el" href="session_setup.html">Sessions: Setting Up an IPC Context</a> accordingly.</dd></dl>
<dl class="todo"><dt><b><a class="el" href="todo.html#_todo000021">Todo:</a></b></dt><dd>Add a blocking version of <code><a class="el" href="classipc_1_1session_1_1Client__session__mv.html#ae0992c43ab3a978a1023d320d043d8de" title="To be invoked in NULL state only, and not as-if default-cted, it asynchronously attempts to connect t...">Client_session::async_connect()</a></code>; and/or such a version with a timeout. This would be most useful only after first executing the to-do just preceding this one in the source code comment/docs.</dd></dl>
<dl class="section return"><dt>Returns</dt><dd><code>false</code> if and only if invoked outside of NULL state; or if <code>*this</code> is as-if default-cted.</dd></dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Task_err</td><td>Handler type matching signature of <code>flow::async::Task_asio_err</code>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">on_done_func</td><td><code>on_done_func(Error_code err_code)</code> is invoked from some unspecified thread, not the caller thread, indicating entrance from CONNECTING state to either NULL or PEER state. If interrupted by destructor the operation-aborted code is passed instead (see ~Client_session_mv() doc header). </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aba3aa4758c635339289d66be45df343b" name="aba3aa4758c635339289d66be45df343b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aba3aa4758c635339289d66be45df343b">&#9670;&nbsp;</a></span>mdt_builder()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Client_session_impl_t &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classipc_1_1session_1_1Session__mv.html#a787253f02859ea6b99ce3eba92766431">Mdt_builder_ptr</a> <a class="el" href="classipc_1_1session_1_1Client__session__mv.html">ipc::session::Client_session_mv</a>&lt; Client_session_impl_t &gt;::mdt_builder </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Implements <a class="el" href="classipc_1_1session_1_1Session.html" title="A documentation-only concept defining the local side of an IPC conversation (session) with another en...">Session</a> API per contract; plus usable to generate blank <code>mdt</code> argument for advanced <a class="el" href="classipc_1_1session_1_1Client__session__mv.html#ae0992c43ab3a978a1023d320d043d8de" title="To be invoked in NULL state only, and not as-if default-cted, it asynchronously attempts to connect t...">async_connect()</a> overload. </p>
<p >That is: can additionally be invoked in NULL state (before <a class="el" href="classipc_1_1session_1_1Client__session__mv.html#ae0992c43ab3a978a1023d320d043d8de" title="To be invoked in NULL state only, and not as-if default-cted, it asynchronously attempts to connect t...">async_connect()</a> or between a failed attempt and the next attempt). The return value can be used only as follows; otherwise undefined behavior results:</p><ul>
<li>If invoked in NULL state: pass to <a class="el" href="classipc_1_1session_1_1Client__session__mv.html#ae0992c43ab3a978a1023d320d043d8de" title="To be invoked in NULL state only, and not as-if default-cted, it asynchronously attempts to connect t...">async_connect()</a>.</li>
<li>If invoked in PEER state: pass to <a class="el" href="classipc_1_1session_1_1Session__mv.html#a6d8cdbb86140056a7e7d2931ea642b18" title="Implements Session API per contract.">open_channel()</a>.</li>
</ul>
<dl class="section return"><dt>Returns</dt><dd>See above.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classipc_1_1session_1_1Session.html#a420df732069ded1feef423adf7a30915" title="Returns a new metadata holder to be subsequently mutated by the user and then passed to open_channel(...">Session::mdt_builder()</a>: implemented concept. </dd></dl>

</div>
</div>
<h2 class="groupheader">Friends And Related Function Documentation</h2>
<a id="a8a2e780e6c5266b8c2e4207d7e256afe" name="a8a2e780e6c5266b8c2e4207d7e256afe"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8a2e780e6c5266b8c2e4207d7e256afe">&#9670;&nbsp;</a></span>operator&lt;&lt;()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Client_session_impl_t &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::ostream &amp; operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>os</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classipc_1_1session_1_1Client__session__mv.html">Client_session_mv</a>&lt; Client_session_impl_t &gt; &amp;&#160;</td>
          <td class="paramname"><em>val</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Prints string representation of the given <code><a class="el" href="classipc_1_1session_1_1Client__session__mv.html" title="Implements Session concept on the Client_app end: a Session_mv that first achieves PEER state by conn...">Client_session_mv</a></code> to the given <code>ostream</code>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">os</td><td>Stream to which to write. </td></tr>
    <tr><td class="paramname">val</td><td>Object to serialize. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>os</code>. </dd></dl>

</div>
</div>
<hr/>The documentation for this class was generated from the following files:<ul>
<li>session/<a class="el" href="ipc__session_2src_2ipc_2session_2client__session_8hpp.html">client_session.hpp</a></li>
<li>session/<a class="el" href="session__fwd_8hpp.html">session_fwd.hpp</a></li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Thu Jan 25 2024 23:58:25 for Flow-IPC by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.4
</small></address>
</body>
</html>
