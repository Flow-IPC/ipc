<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.9.4"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Flow-IPC: API Overview</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">Flow-IPC<span id="projectnumber">&#160;1.0</span>
   </div>
   <div id="projectbrief">Flow-IPC project: Full implementation reference.</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.4 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search",'Search','.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

</div><!-- top -->
<div><div class="header">
  <div class="headertitle"><div class="title">API Overview </div></div>
</div><!--header-->
<div class="contents">
<div class="textblock"><center><b>MANUAL NAVIGATION:</b> <a class="el" href="about.html">Preceding Page</a> - <a class="el" href="setup.html">Next Page</a> - <a href="./pages.html"><b>Table of Contents</b></a></center><hr  />
<p >Here we show how Flow-IPC fulfills its aims; let's take a high-level tour through the available API. (The preceding page <a class="el" href="about.html">(Manual Start) Flow-IPC: Bird's-eye View</a> summarizes the aims of Flow-IPC.)</p>
<h2>Sessions </h2>
<p >No matter the particular IPC transport (local stream socket, MQ, SHM pool), an ever-present need is to establish a naming scheme and coordinate it between the participant processes. To connect one Unix domain socket, one needs to name a server socket, and the connecting process needs to know that name. An MQ requires a name, as does a SHM pool. Developing and maintaining a convention is, normally, both necessary and annoying. Instead:</p>
<p >There is a simple scheme that designates one side of a conversation as the <b>session server</b>, the other a <b>client</b>; the latter connects to the former. (A session server process can carry on multiple sessions with different client processes.) The user need only specify the basic facts of the IPC-participating applications (like executable names and owners, and which ones are servers, and which clients they'll accept as the opposing side). This is done via the straightforward <code>struct</code> <a class="el" href="structipc_1_1session_1_1App.html" title="A description of an application in this ipc::session inter-process communication universe.">ipc::session::App</a> + its children. The rest of <a class="el" href="namespaceipc_1_1session.html" title="Flow-IPC module providing the broad lifecycle and shared-resource organization – via the session conc...">ipc::session</a> establishes internal naming conventions based off that information. Having specified those <code>App</code> basics the user, opens (on each side) an equally capable <a class="el" href="classipc_1_1session_1_1Session.html" title="A documentation-only concept defining the local side of an IPC conversation (session) with another en...">ipc::session::Session</a> that is the context for all subsequent IPC between those 2 processes.</p>
<p >Having obtained a <code>Session</code>, the application can open transport channels (and, if desired, SHM arenas) without any naming decisions to make. At that point it's off to the races... namely:</p>
<h2>Transport (unstructured) </h2>
<p >A <b>channel</b> is a bundling of the resources required for, essentially, a bidirectional pipe capable of transmitting binary messages (<b>blobs</b>) and, optionally, native handles. A particular <a class="el" href="classipc_1_1transport_1_1Channel.html" title="Peer to a bundle of 1-2 full-duplex pipe(s), one for transmitting unstructured binary blobs; the othe...">ipc::transport::Channel</a> (as specified at compile-time via its template parameters) may, for example, consist of an outgoing <a href="https://man7.org/linux/man-pages/man7/mq_overview.7.html">POSIX MQ (message queue)</a> handle and a similar incoming-MQ handle; or conceptually similar SHM-backed MQs (boost.ipc MQs). Alternatively it can consist of a Unix domain socket endpoint (which is bidirectional). (Other combinations are generically possible.) If one uses the <a class="el" href="namespaceipc_1_1session.html" title="Flow-IPC module providing the broad lifecycle and shared-resource organization – via the session conc...">ipc::session</a> API, one need not worry about any detail of opening these various handles and feeding them to the particular <code>Channel</code>. Alternatively a simple application or prototype may want to manually set them up without <a class="el" href="namespaceipc_1_1session.html" title="Flow-IPC module providing the broad lifecycle and shared-resource organization – via the session conc...">ipc::session</a>.</p>
<p >All transport APIs at this layer, as well the structured layer (see below), have an API that is as-synchronous-as-possible. In particular all send operations are non-blocking and synchronous and never return "would-block" &ndash; while guaranteeing good performance in practice. Receive APIs are asynchronous by their nature. A proactor-style API (a-la boost.asio) is provided for this and other async ops (such as connect and accept of various types)</p>
<dl class="section note"><dt>Note</dt><dd>An alternative API is available for all objects with any async operations (generally: any subset of send, receive, connect, accept). This is called the <code>sync_io</code> <b>pattern</b>, contrasting with the above <b>async-I/O pattern</b>. The <code>sync_io</code>-pattern alternative for each given I/O object is similar in spirit to reactor-style (non-blocking) APIs a-la OpenSSL's. It may help you integrate with a reactor-style event loop such as one built on <code>epoll()</code> or <code>poll()</code>. It is also the way to strictly control the background threads in your application arising for Flow-IPC's operation: if desired you can have it operate entirely within your own threads and event loop(s). See <a class="el" href="async_loop.html">Asynchronicity and Integrating with Your Event Loop</a> for more discussion of this somewhat-hairy topic.</dd>
<dd>
This async-I/O-versus-<code>sync_io</code> choice is available for all other parts of Flow-IPC, including: <a class="el" href="namespaceipc_1_1transport.html" title="Flow-IPC module providing transmission of structured messages and/or low-level blobs (and more) betwe...">ipc::transport</a> structured layer (<code>struc::sync_io::Channel</code> versus just <code>struc::Channel</code> for async-I/O alternative) and <a class="el" href="namespaceipc_1_1session.html" title="Flow-IPC module providing the broad lifecycle and shared-resource organization – via the session conc...">ipc::session</a>.</dd></dl>
<h2>Transport (structured) </h2>
<p >While a <code>Channel</code> transports blobs and/or native handles, it is likely the Flow-IPC user will want to be able to transmit schema-based structured data, gaining the benefits of that approach including arbitrary data-structuree complexity and forward/backward-compatibility. <a href="https://capnproto.org">capnp (Cap'n Proto)</a> is the best-in-class third-party framework for schema-based structured data; <a class="el" href="namespaceipc_1_1transport.html" title="Flow-IPC module providing transmission of structured messages and/or low-level blobs (and more) betwe...">ipc::transport</a>'s structured layer works by integrating with capnp.</p>
<p >To deal with structured data instead of mere blobs (though a schema-based structure can, of course, itself store blobs such as images), one simply constructs an <a class="el" href="classipc_1_1transport_1_1struc_1_1Channel.html" title="Owning and wrapping a pre-connected transport::Channel peer (an endpoint of an established channel ov...">ipc::transport::struc::Channel</a>, feeding it an <code>std::move()</code>d already-opened <a class="el" href="classipc_1_1transport_1_1Channel.html">Channel</a>. This is called <b>upgrading</b> an unstructured <code>Channel</code> to a <code>struc::Channel</code>. A key template parameter to <code>struc::Channel</code> is a capnp-generated root schema class of the user's choice. This declares, at compile-time, what data structures (messages) one can transmit via that <code>struc::Channel</code> (and an identically-typed counterpart <code>struc::Channel</code> in the opposing process).</p>
<p ><a class="el" href="classipc_1_1transport_1_1struc_1_1Channel.html">struc::Channel</a> provides fundamental niceties for a structured-channel protocol:</p><ul>
<li>If I receive a message M of type X (from available types A, B, C, ... as allowed by the top-level capnp-<code>union</code> in the specified root schema), I ask <code>struc::Channel</code> to please invoke a particular handler <code>F(M)</code> (typically given as a lambda).</li>
<li>When I send a message M', I can optionally specify that it's a <b>response</b> to earlier in-message M.</li>
<li>When I send a message M', I can optionally specify that I expect either up-to-1, or an arbitrary number of, <b>responses</b> to it. I ask that when such a response M is received, <code>struc::Channel</code> please invoke a particular handler <code>F(M)</code>.</li>
</ul>
<p ><a class="el" href="classipc_1_1transport_1_1struc_1_1Msg__out.html">struc::Msg_out</a> is a container-like data structure representing an out-message M'. <a class="el" href="classipc_1_1transport_1_1struc_1_1Msg__in.html">struc::Msg_in</a> is a receiver's read-only view into such a message M upon its receipt.</p>
<h2>Transport (structured): Zero-copy </h2>
<p >Say I prepare a message M': I construct it (<code>struc::Msg_out</code>), I mutate it via its capnp-generated mutators (as the required backing memory is gradually allocated behind the scenes), and then I <a class="el" href="classipc_1_1transport_1_1struc_1_1Channel.html#ae645cb58ad9ea6374970f1f32c5da448">struc::Channel::send()</a> it. The receiver receives it as <code>struc::Msg_in</code> M subsequently and accesses its various parts via capnp-generated accessors. <em>Zero-copy</em> means that the backing memory allocated for M' is never copied into any low-level transport. Instead only some tiny, constant-sized handle is (internally) copied into and out of the transport &ndash; and the accessors of M are directly reading the memory in M'.</p>
<p >The obvious benefit of this is performance. Notably, also, it is possible to subsequently modify M' and send it (and receive it) again. The backing memory is freed once M' and all in-messsage views like M have been destroyed. (The Ms are made available exclusively via <code>shared_ptr</code>.)</p>
<p >While zero-copy is optional, in general we recommend using it. Fortunately it is quite easy to enable. <em>Internally</em> it is accomplished by using SHM; but in terms of the public API, all you have to do is &ndash; when writing the code for opening your <a class="el" href="classipc_1_1session_1_1Session.html" title="A documentation-only concept defining the local side of an IPC conversation (session) with another en...">ipc::session::Session</a> &ndash; simply choose a SHM-backed session type. That is:</p><ul>
<li>Zero-copy (a/k/a SHM-backed): Use <code>"ipc::session::shm::...::Client_session"</code> and <code>"ipc::session::shm::...::Session_server"</code>.</li>
<li>Non-zero-copy: Use <a class="el" href="namespaceipc_1_1session.html#a77d8fda00e1e17f595a6a5d4c44375e7" title="A vanilla Client_session with no optional capabilities.">ipc::session::Client_session</a> and <a class="el" href="classipc_1_1session_1_1Session__server.html" title="To be instantiated typically once in a given process, an object of this type asynchronously listens f...">ipc::session::Session_server</a>. Whichever you choose, their APIs are identical. In particular, suppose you chose <code>Session</code> type <code>S</code>; then <code>S::Structured_channel&lt;Your_capnp_schema&gt;</code> is the alias for the proper SHM-backed-or-not <code>struc::Channel</code> type.</li>
</ul>
<p >At no point do you have to worry about naming a SHM pool, removing it from the file-system on cleanup (including following a crash), and so on. All is handled internally. Simply choose a SHM-backed <code>Session</code> type on each side at compile-time.</p>
<p >It is also possible to set this up without <a class="el" href="namespaceipc_1_1session.html" title="Flow-IPC module providing the broad lifecycle and shared-resource organization – via the session conc...">ipc::session</a>.</p>
<p >Orthogonally, for advanced needs likely driven by tight performance needs, it is possible to develop your own backing-allocation scheme: Implement the <a class="el" href="classipc_1_1transport_1_1struc_1_1Struct__builder.html" title="A documentation-only concept defining the behavior of an object capable of zero-copy-serializing,...">ipc::transport::struc::Struct_builder</a> and <a class="el" href="classipc_1_1transport_1_1struc_1_1Struct__reader.html">Struct_reader</a> concepts. For example, especially if sending small messages from one thread and not requiring end-to-end zero-copy, one could allocate out-messages from a single pre-heap-allocated buffer to reduce the cycles spent in the heap allocator to (amortized) zero.</p>
<h2>Direct storage in SHared Memory (SHM) </h2>
<p >This topic is optional: One can reap zero-copy performance by exclusively keeping IPC-communicated data structures in your <code>struc::Channel</code>-transmitted message schema of choice. Internally, we use our own SHM capabilities to accomplish this, invisibly to the API user. We reasonably claim that if you can keep your shared data structures in a capnp-schema-backed object, then it is best to do so. That said:</p>
<p >Some applications may prefer to have the two (or more) conversant processes cooperate by reading/writing directly to a non-capnp-backed data structure but rather a straight C++ <code>struct</code>. Flow-IPC provides this ability out-of-the-box. This means the user need not figure out a number of <em>very</em> hairy topics such as how to develop and use a SHM-friendly allocator. We summarize this here.</p>
<p >If and only if you used a SHM-enabled <a class="el" href="classipc_1_1session_1_1Session.html" title="A documentation-only concept defining the local side of an IPC conversation (session) with another en...">ipc::session::Session</a> implementation (as noted in the preceding section &ndash; for example <a class="el" href="namespaceipc_1_1session_1_1shm_1_1classic.html#ac6c443a72e0f22710c83bb1e8c229618" title="This is to session::Client_session what shm::classic::Server_session is to session::Server_session.">ipc::session::shm::classic::Client_session</a>), then upon opening such a session, you immediately have access to 2 SHM <b>arenas</b>.</p><ul>
<li><a class="el" href="classipc_1_1session_1_1shm_1_1classic_1_1Session__mv.html#a9ff21b10fd753fccfa4882834e677ccf">Session::session_shm()</a> is an arena pertaining to that session (pair of processes).</li>
<li><a class="el" href="classipc_1_1session_1_1shm_1_1classic_1_1Session__mv.html#ac6a4f1fbafb583f37d7586c6a199430f">Session::app_shm()</a> is an arena pertaining to multiple sessions; so it continues to persist across all sessions, until the big-daddy <code>Session_server</code> is destroyed (and thus no further session are possible to open).</li>
</ul>
<p >Each of these returns an <code>Arena</code>.</p>
<p ><a class="el" href="classipc_1_1shm_1_1classic_1_1Pool__arena.html#ab9f7ea056a55183d00dcbce573afcf36">Arena::construct&lt;T&gt;(...)</a> returns <code>shared_ptr&lt;T&gt;</code> which points to a newly constructed-in-SHM-arena object of type <code>T</code>. The sender prepares object <code>*x</code> of type <code>T</code>, then calls <a class="el" href="classipc_1_1session_1_1shm_1_1classic_1_1Session__mv.html#a794f83a8111428b3b1feec7216f692dd">Session::lend_object(x)</a> which returns a tiny payload to transmit over IPC (typically, but not necessarily, via a <code>struc::Channel</code> as part of a capnp-encoded message). The receiver then invokes <a class="el" href="classipc_1_1session_1_1shm_1_1classic_1_1Session__mv.html#a4223fc944735adb6946a9d1938d06a20"><code>auto x = Arena::borrow_object()</code></a>, passing in that aforementioned tiny payload. This recovers <code>*x</code> of type <code>T</code> in the receiver where it can be read like any C/C++ structure &ndash; because it <em>is</em> one. The backing RAM is auto-returned to the arena once all these handles (in this example <code>x</code> on each side) (and other derived <code>shared_ptr</code>s in their respective shared-groups &ndash; e.g., obtained via <code>auto x2 = x</code>) are destroyed. In a sense <code>x</code> is part of a <em>cross-process</em> <code>shared_ptr</code> group.</p>
<p >The real power comes from the possibilities for what type <code>T</code> can be. <code>T</code> can be any combination (recursively speaking) of: the basic scalars (<code>int</code>, <code>float</code>, etc.); <code>struct</code>s; and STL-compliant containers. So it can be, say, a <code>vector</code> of <code>unordered_map</code>s mapping from <code>basic_string</code> to <code>struct S { ... }</code>, where <code>...</code> itself stores anything equally arbitrarily complex. The STL-compliant container types must merely specify the allocator <code><a class="el" href="classipc_1_1shm_1_1stl_1_1Stateless__allocator.html" title="Stateless allocator usable with STL-compliant containers to store (or merely read) them directly in S...">ipc::shm::stl::Stateless_allocator</a>&lt;Arena&gt;</code>. We've provided the allocator implementation, so you need not worry about that stuff &ndash; just use it.</p>
<p >You can also directly store pointers in <code>T</code>, as long as you use <code>Stateless_allocator&lt;Arena&gt;::Pointer&lt;P&gt;</code> (not raw <code>P*</code>); though we'd informally recommend against it for the maintainability of your own algorithms. That is what the allocator concept in STL is for after all. (This advice is independent of Flow-IPC; just a general opinion.)</p>
<p >Further capabilities are outside our scope here; but the main point is: At a minimum:</p><ul>
<li>if you simply used a SHM-backed session type when setting up IPC, immediately available to you are arenas in which to allocate objects and share them between the processes involved; and</li>
<li>the object type can be an arbitrarily complex combo of C++ plain-old data-types (PODs) and STL-compliant container types, as long as you use the Flow-IPC-supplied allocator for the latter.</li>
</ul>
<h2>Low level, utilities </h2>
<p >It is possible to eschew the higher-level abstractions such as <code>Channel</code>, <code>struc::Channel</code>, and <code>Session</code>; and work more directly on the low level of IPC transports including Unix domain sockets, POSIX MQs, SHM-backed (boost.interprocess) MQs. Even in that case Flow-IPC may have useful APIs for you.</p>
<p >Of these, on the higher-level end are <a class="el" href="classipc_1_1transport_1_1Native__socket__stream.html" title="Implements both Native_handle_sender and Native_handle_receiver concepts by using a stream-oriented U...">ipc::transport::Native_socket_stream</a> (blob/handle transmission over local stream socket) and <a class="el" href="classipc_1_1transport_1_1Native__socket__stream__acceptor.html">Native_socket_stream_acceptor</a> (listening for incoming connections of that type) and <a class="el" href="classipc_1_1transport_1_1Blob__stream__mq__sender.html">Blob_stream_mq_sender</a> and <a class="el" href="classipc_1_1transport_1_1Blob__stream__mq__receiver.html">Blob_stream_mq_receiver</a> (blob transmission over MQ, with MQ type specified as template parameter).</p>
<p >Below that are the specific MQ APIs (<a class="el" href="classipc_1_1transport_1_1Posix__mq__handle.html" title="Implements the Persistent_mq_handle concept by wrapping the POSIX message queue API (see man mq_overv...">ipc::transport::Posix_mq_handle</a> and <a class="el" href="classipc_1_1transport_1_1Bipc__mq__handle.html">Bipc_mq_handle</a>) and the stream-socket-focused boost.asio extensions in sub-namespace <a class="el" href="namespaceipc_1_1transport_1_1asio__local__stream__socket.html" title="Additional (versus boost.asio) APIs for advanced work with local stream (Unix domain) sockets includi...">ipc::transport::asio_local_stream_socket</a>.</p>
<p ><a class="el" href="namespaceipc_1_1util.html" title="Flow-IPC module containing miscellaneous general-use facilities that ubiquitously used by ~all Flow-I...">ipc::util</a> stores further miscellaneous low-level utility APIs such as <a class="el" href="classipc_1_1util_1_1Process__credentials.html" title="A process&#39;s credentials (PID, UID, GID as of this writing).">ipc::util::Process_credentials</a> and permissions abstraction <a class="el" href="namespaceipc_1_1util.html#a2ec0bfdddb41a1ef0403e4bb8967705d">Permissions_level</a>.</p>
<p >Next let's get to the nitty-gritty of actually using this library: <a class="el" href="setup.html">Prerequisites and Setup</a>.</p>
<hr  />
<center><b>MANUAL NAVIGATION:</b> <a class="el" href="about.html">Preceding Page</a> - <a class="el" href="setup.html">Next Page</a> - <a href="./pages.html"><b>Table of Contents</b></a></center> </div></div><!-- contents -->
</div><!-- PageDoc -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Thu Jan 18 2024 04:29:22 for Flow-IPC by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.4
</small></address>
</body>
</html>
