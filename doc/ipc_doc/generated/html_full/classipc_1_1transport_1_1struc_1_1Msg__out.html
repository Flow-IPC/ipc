<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.9.4"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Flow-IPC: ipc::transport::struc::Msg_out&lt; Message_body, Struct_builder_t &gt; Class Template Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">Flow-IPC<span id="projectnumber">&#160;1.0.0</span>
   </div>
   <div id="projectbrief">Flow-IPC project: Full implementation reference.</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.4 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search",'Search','.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespaceipc.html">ipc</a></li><li class="navelem"><a class="el" href="namespaceipc_1_1transport.html">transport</a></li><li class="navelem"><a class="el" href="namespaceipc_1_1transport_1_1struc.html">struc</a></li><li class="navelem"><a class="el" href="classipc_1_1transport_1_1struc_1_1Msg__out.html">Msg_out</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-types">Public Types</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pro-methods">Protected Member Functions</a> &#124;
<a href="#pri-attribs">Private Attributes</a> &#124;
<a href="#related">Related Functions</a> &#124;
<a href="classipc_1_1transport_1_1struc_1_1Msg__out-members.html">List of all members</a>  </div>
  <div class="headertitle"><div class="title">ipc::transport::struc::Msg_out&lt; Message_body, Struct_builder_t &gt; Class Template Reference</div></div>
</div><!--header-->
<div class="contents">

<p>A structured out-message suitable to be sent via <a class="el" href="classipc_1_1transport_1_1struc_1_1Channel.html#ae645cb58ad9ea6374970f1f32c5da448" title="In the synchronous/non-blocking manner of Blob_sender::send_blob() or Native_handle_sender::send_nati...">struc::Channel::send()</a>.  
 <a href="classipc_1_1transport_1_1struc_1_1Msg__out.html#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="msg_8hpp_source.html">msg.hpp</a>&gt;</code></p>
<div class="dynheader">
Collaboration diagram for ipc::transport::struc::Msg_out&lt; Message_body, Struct_builder_t &gt;:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="classipc_1_1transport_1_1struc_1_1Msg__out__coll__graph.svg" width="438" height="227"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe>
</div>
<center><span class="legend">[<a href="graph_legend.html">legend</a>]</span></center></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-types" name="pub-types"></a>
Public Types</h2></td></tr>
<tr class="memitem:aab352abf2ced76f2bad6700d75290132"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classipc_1_1transport_1_1struc_1_1Msg__out.html#aab352abf2ced76f2bad6700d75290132">Body</a> = Message_body</td></tr>
<tr class="memdesc:aab352abf2ced76f2bad6700d75290132"><td class="mdescLeft">&#160;</td><td class="mdescRight">See <a class="el" href="classipc_1_1transport_1_1struc_1_1Channel.html#a27a273ed7e1aca34b721fea22c869a41" title="Short-hand for the Message_body template param, this is the capnp message schema transmissible over *...">struc::Channel::Msg_body</a>.  <a href="classipc_1_1transport_1_1struc_1_1Msg__out.html#aab352abf2ced76f2bad6700d75290132">More...</a><br /></td></tr>
<tr class="separator:aab352abf2ced76f2bad6700d75290132"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a68188b480ac3c33676b08dce72d92922"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classipc_1_1transport_1_1struc_1_1Msg__out.html#a68188b480ac3c33676b08dce72d92922">Body_builder</a> = typename Body::Builder</td></tr>
<tr class="memdesc:a68188b480ac3c33676b08dce72d92922"><td class="mdescLeft">&#160;</td><td class="mdescRight">Short-hand for capnp-generated mutating <code>Builder</code> nested class of <a class="el" href="classipc_1_1transport_1_1struc_1_1Msg__out.html#aab352abf2ced76f2bad6700d75290132" title="See struc::Channel::Msg_body.">Body</a>. See <a class="el" href="classipc_1_1transport_1_1struc_1_1Msg__out.html#a9894ad7ec2a46641c4b9b86664d0d465" title="The Body root capnp-generated mutator object.">body_root()</a>.  <a href="classipc_1_1transport_1_1struc_1_1Msg__out.html#a68188b480ac3c33676b08dce72d92922">More...</a><br /></td></tr>
<tr class="separator:a68188b480ac3c33676b08dce72d92922"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aae507a42f29546fa13075a438d96f3f5"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classipc_1_1transport_1_1struc_1_1Msg__out.html#aae507a42f29546fa13075a438d96f3f5">Builder</a> = Struct_builder_t</td></tr>
<tr class="memdesc:aae507a42f29546fa13075a438d96f3f5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Short-hand for user-specified <a class="el" href="classipc_1_1transport_1_1struc_1_1Struct__builder.html" title="A documentation-only concept defining the behavior of an object capable of zero-copy-serializing,...">Struct_builder</a> type.  <a href="classipc_1_1transport_1_1struc_1_1Msg__out.html#aae507a42f29546fa13075a438d96f3f5">More...</a><br /></td></tr>
<tr class="separator:aae507a42f29546fa13075a438d96f3f5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0e66b941a2b67ec21087581d1e44f42b"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classipc_1_1transport_1_1struc_1_1Msg__out.html#a0e66b941a2b67ec21087581d1e44f42b">Builder_config</a> = typename Builder::Config</td></tr>
<tr class="memdesc:a0e66b941a2b67ec21087581d1e44f42b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Short-hand for user-specified <a class="el" href="structipc_1_1transport_1_1struc_1_1Struct__builder_1_1Config.html" title="Copy-ctible, copy-assignable, default-ctible type â€“ informally, cheaply copyable and likely an aggreg...">Struct_builder::Config</a>.  <a href="classipc_1_1transport_1_1struc_1_1Msg__out.html#a0e66b941a2b67ec21087581d1e44f42b">More...</a><br /></td></tr>
<tr class="separator:a0e66b941a2b67ec21087581d1e44f42b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acd04d61cf19ad87610598fddbb5d8052"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classipc_1_1transport_1_1struc_1_1Msg__out.html#acd04d61cf19ad87610598fddbb5d8052">Orphanage</a> = ::capnp::Orphanage</td></tr>
<tr class="memdesc:acd04d61cf19ad87610598fddbb5d8052"><td class="mdescLeft">&#160;</td><td class="mdescRight">Short-hand for capnp orphan factory. See <a class="el" href="classipc_1_1transport_1_1struc_1_1Msg__out.html#a9303c71f8f459ede25ebe0c8f5492393" title="Convenience method that returns a capnp::Orphan factory in the same capnp::MessageBuilder as body_roo...">orphanage()</a>.  <a href="classipc_1_1transport_1_1struc_1_1Msg__out.html#acd04d61cf19ad87610598fddbb5d8052">More...</a><br /></td></tr>
<tr class="separator:acd04d61cf19ad87610598fddbb5d8052"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-methods" name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a9d4ab66d2740f40a88f476d46dd04f1e"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classipc_1_1transport_1_1struc_1_1Msg__out.html#a9d4ab66d2740f40a88f476d46dd04f1e">Msg_out</a> (const <a class="el" href="classipc_1_1transport_1_1struc_1_1Msg__out.html#a0e66b941a2b67ec21087581d1e44f42b">Builder_config</a> &amp;struct_builder_config)</td></tr>
<tr class="memdesc:a9d4ab66d2740f40a88f476d46dd04f1e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates blank <a class="el" href="classipc_1_1transport_1_1struc_1_1Msg__out.html#aab352abf2ced76f2bad6700d75290132" title="See struc::Channel::Msg_body.">Body</a>-bearing out-message message, with no native handle, all of which can be modified via <a class="el" href="classipc_1_1transport_1_1struc_1_1Msg__out.html#a9894ad7ec2a46641c4b9b86664d0d465" title="The Body root capnp-generated mutator object.">body_root()</a> and the ancillary mutator <a class="el" href="classipc_1_1transport_1_1struc_1_1Msg__out.html#aced8ef8237617c74aaf06832d1385fed" title="Store the Native_handle (potentially .null(), meaning none) in this out-message; no-ops if the same ....">store_native_handle_or_null()</a>.  <a href="classipc_1_1transport_1_1struc_1_1Msg__out.html#a9d4ab66d2740f40a88f476d46dd04f1e">More...</a><br /></td></tr>
<tr class="separator:a9d4ab66d2740f40a88f476d46dd04f1e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9738acbcfb431dc1fc0174b42787060b"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classipc_1_1transport_1_1struc_1_1Msg__out.html#a9738acbcfb431dc1fc0174b42787060b">Msg_out</a> (<a class="el" href="classipc_1_1transport_1_1struc_1_1Msg__out.html#aae507a42f29546fa13075a438d96f3f5">Builder</a> &amp;&amp;struct_builder)</td></tr>
<tr class="memdesc:a9738acbcfb431dc1fc0174b42787060b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Advanced technique: Creates message by subsuming the provided already-prepared <code><a class="el" href="classCapnp__msg__builder__interface.html">Capnp_msg_builder_interface</a></code>-bearing, root-initialized-to-<a class="el" href="classipc_1_1transport_1_1struc_1_1Msg__out.html#aab352abf2ced76f2bad6700d75290132" title="See struc::Channel::Msg_body.">Body</a> <a class="el" href="classipc_1_1transport_1_1struc_1_1Msg__out.html#aae507a42f29546fa13075a438d96f3f5" title="Short-hand for user-specified Struct_builder type.">Builder</a> object (which is moved-to <code>*this</code>), with no native handle, all of which can be (further) modified via <a class="el" href="classipc_1_1transport_1_1struc_1_1Msg__out.html#a9894ad7ec2a46641c4b9b86664d0d465" title="The Body root capnp-generated mutator object.">body_root()</a> and the ancillary mutator <a class="el" href="classipc_1_1transport_1_1struc_1_1Msg__out.html#aced8ef8237617c74aaf06832d1385fed" title="Store the Native_handle (potentially .null(), meaning none) in this out-message; no-ops if the same ....">store_native_handle_or_null()</a>.  <a href="classipc_1_1transport_1_1struc_1_1Msg__out.html#a9738acbcfb431dc1fc0174b42787060b">More...</a><br /></td></tr>
<tr class="separator:a9738acbcfb431dc1fc0174b42787060b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9289790ac6b85681c8697fc55ff8f3a7"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classipc_1_1transport_1_1struc_1_1Msg__out.html#a9289790ac6b85681c8697fc55ff8f3a7">Msg_out</a> ()</td></tr>
<tr class="memdesc:a9289790ac6b85681c8697fc55ff8f3a7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates non-message; any operation except move-to or destruction results in undefined behavior subsequently.  <a href="classipc_1_1transport_1_1struc_1_1Msg__out.html#a9289790ac6b85681c8697fc55ff8f3a7">More...</a><br /></td></tr>
<tr class="separator:a9289790ac6b85681c8697fc55ff8f3a7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a50c8fd96304e09aaf9bbacd9959c07d6"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classipc_1_1transport_1_1struc_1_1Msg__out.html#a50c8fd96304e09aaf9bbacd9959c07d6">Msg_out</a> (<a class="el" href="classipc_1_1transport_1_1struc_1_1Msg__out.html">Msg_out</a> &amp;&amp;src)</td></tr>
<tr class="memdesc:a50c8fd96304e09aaf9bbacd9959c07d6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Move ctor: Make <code>*this</code> equal to <code>src</code>, while <code>src</code> becomes as-if default-cted (in that any operation except move-to or destruction results in undefined behavior subsequently).  <a href="classipc_1_1transport_1_1struc_1_1Msg__out.html#a50c8fd96304e09aaf9bbacd9959c07d6">More...</a><br /></td></tr>
<tr class="separator:a50c8fd96304e09aaf9bbacd9959c07d6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9e5271db0ea2b86ec4c68a91c60dd17a"><td class="memItemLeft" align="right" valign="top"><a id="a9e5271db0ea2b86ec4c68a91c60dd17a" name="a9e5271db0ea2b86ec4c68a91c60dd17a"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>Msg_out</b> (const <a class="el" href="classipc_1_1transport_1_1struc_1_1Msg__out.html">Msg_out</a> &amp;)=delete</td></tr>
<tr class="memdesc:a9e5271db0ea2b86ec4c68a91c60dd17a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Disallow copying. <br /></td></tr>
<tr class="separator:a9e5271db0ea2b86ec4c68a91c60dd17a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6fe17e3ce3e3569e7b08538f525918e9"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classipc_1_1transport_1_1struc_1_1Msg__out.html#a6fe17e3ce3e3569e7b08538f525918e9">~Msg_out</a> ()</td></tr>
<tr class="memdesc:a6fe17e3ce3e3569e7b08538f525918e9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns resources, including potentially significant RAM resources and <a class="el" href="classipc_1_1transport_1_1struc_1_1Msg__out.html#ae033461f1404be60262033bafcfaccba" title="Returns whatever was the last word according to store_native_handle_or_null().">native_handle_or_null()</a>, taken throughout; in the case of SHM-based RAM resources their return may be delayed until counterpart <code><a class="el" href="classipc_1_1transport_1_1struc_1_1Msg__in.html" title="A structured in-message instance suitable as received and emittable (to user) by struc::Channel.">Msg_in</a></code>s are also destroyed.  <a href="classipc_1_1transport_1_1struc_1_1Msg__out.html#a6fe17e3ce3e3569e7b08538f525918e9">More...</a><br /></td></tr>
<tr class="separator:a6fe17e3ce3e3569e7b08538f525918e9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6a9b086eedafe0a5fc71695812677cdb"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classipc_1_1transport_1_1struc_1_1Msg__out.html">Msg_out</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classipc_1_1transport_1_1struc_1_1Msg__out.html#a6a9b086eedafe0a5fc71695812677cdb">operator=</a> (<a class="el" href="classipc_1_1transport_1_1struc_1_1Msg__out.html">Msg_out</a> &amp;&amp;src)</td></tr>
<tr class="memdesc:a6a9b086eedafe0a5fc71695812677cdb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Move assignment: Destroy <code>*this</code> contents; make <code>*this</code> equal to <code>src</code>, while <code>src</code> becomes as-if default-cted (in that any operation except move-to or destruction results in undefined behavior subsequently).  <a href="classipc_1_1transport_1_1struc_1_1Msg__out.html#a6a9b086eedafe0a5fc71695812677cdb">More...</a><br /></td></tr>
<tr class="separator:a6a9b086eedafe0a5fc71695812677cdb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a53a9746fdabdefcaf1f9bf63c81c6d85"><td class="memItemLeft" align="right" valign="top"><a id="a53a9746fdabdefcaf1f9bf63c81c6d85" name="a53a9746fdabdefcaf1f9bf63c81c6d85"></a>
<a class="el" href="classipc_1_1transport_1_1struc_1_1Msg__out.html">Msg_out</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>operator=</b> (const <a class="el" href="classipc_1_1transport_1_1struc_1_1Msg__out.html">Msg_out</a> &amp;)=delete</td></tr>
<tr class="memdesc:a53a9746fdabdefcaf1f9bf63c81c6d85"><td class="mdescLeft">&#160;</td><td class="mdescRight">Disallow copying. <br /></td></tr>
<tr class="separator:a53a9746fdabdefcaf1f9bf63c81c6d85"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9894ad7ec2a46641c4b9b86664d0d465"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classipc_1_1transport_1_1struc_1_1Msg__out.html#a68188b480ac3c33676b08dce72d92922">Body_builder</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classipc_1_1transport_1_1struc_1_1Msg__out.html#a9894ad7ec2a46641c4b9b86664d0d465">body_root</a> ()</td></tr>
<tr class="memdesc:a9894ad7ec2a46641c4b9b86664d0d465"><td class="mdescLeft">&#160;</td><td class="mdescRight">The <a class="el" href="classipc_1_1transport_1_1struc_1_1Msg__out.html#aab352abf2ced76f2bad6700d75290132" title="See struc::Channel::Msg_body.">Body</a> root capnp-generated mutator object.  <a href="classipc_1_1transport_1_1struc_1_1Msg__out.html#a9894ad7ec2a46641c4b9b86664d0d465">More...</a><br /></td></tr>
<tr class="separator:a9894ad7ec2a46641c4b9b86664d0d465"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a66eade858d6b311d6e2d633b43ee71ad"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classipc_1_1transport_1_1struc_1_1Msg__out.html#a68188b480ac3c33676b08dce72d92922">Body_builder</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classipc_1_1transport_1_1struc_1_1Msg__out.html#a66eade858d6b311d6e2d633b43ee71ad">body_root</a> () const</td></tr>
<tr class="memdesc:a66eade858d6b311d6e2d633b43ee71ad"><td class="mdescLeft">&#160;</td><td class="mdescRight">Equivalent to the other <a class="el" href="classipc_1_1transport_1_1struc_1_1Msg__out.html#a9894ad7ec2a46641c4b9b86664d0d465" title="The Body root capnp-generated mutator object.">body_root()</a> overload but immutable version.  <a href="classipc_1_1transport_1_1struc_1_1Msg__out.html#a66eade858d6b311d6e2d633b43ee71ad">More...</a><br /></td></tr>
<tr class="separator:a66eade858d6b311d6e2d633b43ee71ad"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9303c71f8f459ede25ebe0c8f5492393"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classipc_1_1transport_1_1struc_1_1Msg__out.html#acd04d61cf19ad87610598fddbb5d8052">Orphanage</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classipc_1_1transport_1_1struc_1_1Msg__out.html#a9303c71f8f459ede25ebe0c8f5492393">orphanage</a> ()</td></tr>
<tr class="memdesc:a9303c71f8f459ede25ebe0c8f5492393"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convenience method that returns a <code>capnp::Orphan</code> factory in the same <code>capnp::MessageBuilder</code> as <a class="el" href="classipc_1_1transport_1_1struc_1_1Msg__out.html#a9894ad7ec2a46641c4b9b86664d0d465" title="The Body root capnp-generated mutator object.">body_root()</a>.  <a href="classipc_1_1transport_1_1struc_1_1Msg__out.html#a9303c71f8f459ede25ebe0c8f5492393">More...</a><br /></td></tr>
<tr class="separator:a9303c71f8f459ede25ebe0c8f5492393"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aced8ef8237617c74aaf06832d1385fed"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classipc_1_1transport_1_1struc_1_1Msg__out.html#aced8ef8237617c74aaf06832d1385fed">store_native_handle_or_null</a> (<a class="el" href="namespaceipc_1_1transport.html#a7ee4551983d9df16ec16a3139bac50e8">Native_handle</a> &amp;&amp;<a class="el" href="classipc_1_1transport_1_1struc_1_1Msg__out.html#ae033461f1404be60262033bafcfaccba">native_handle_or_null</a>)</td></tr>
<tr class="memdesc:aced8ef8237617c74aaf06832d1385fed"><td class="mdescLeft">&#160;</td><td class="mdescRight">Store the <code>Native_handle</code> (potentially <code>.null()</code>, meaning none) in this out-message; no-ops if the same <code>.m_native_handle</code> already stored; otherwise returns the previously stored native handle to the OS (similarly to dtor).  <a href="classipc_1_1transport_1_1struc_1_1Msg__out.html#aced8ef8237617c74aaf06832d1385fed">More...</a><br /></td></tr>
<tr class="separator:aced8ef8237617c74aaf06832d1385fed"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae033461f1404be60262033bafcfaccba"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespaceipc_1_1transport.html#a7ee4551983d9df16ec16a3139bac50e8">Native_handle</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classipc_1_1transport_1_1struc_1_1Msg__out.html#ae033461f1404be60262033bafcfaccba">native_handle_or_null</a> () const</td></tr>
<tr class="memdesc:ae033461f1404be60262033bafcfaccba"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns whatever was the last word according to <a class="el" href="classipc_1_1transport_1_1struc_1_1Msg__out.html#aced8ef8237617c74aaf06832d1385fed" title="Store the Native_handle (potentially .null(), meaning none) in this out-message; no-ops if the same ....">store_native_handle_or_null()</a>.  <a href="classipc_1_1transport_1_1struc_1_1Msg__out.html#ae033461f1404be60262033bafcfaccba">More...</a><br /></td></tr>
<tr class="separator:ae033461f1404be60262033bafcfaccba"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a754e0f025f471105d52b3b090c27f1c0"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classipc_1_1transport_1_1struc_1_1Msg__out.html#a754e0f025f471105d52b3b090c27f1c0">to_ostream</a> (std::ostream *os) const</td></tr>
<tr class="memdesc:a754e0f025f471105d52b3b090c27f1c0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Prints string representation to the given <code>ostream</code>.  <a href="classipc_1_1transport_1_1struc_1_1Msg__out.html#a754e0f025f471105d52b3b090c27f1c0">More...</a><br /></td></tr>
<tr class="separator:a754e0f025f471105d52b3b090c27f1c0"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pro-methods" name="pro-methods"></a>
Protected Member Functions</h2></td></tr>
<tr class="memitem:a91d2575343b28f83e22a71e7f7b3ff40"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classipc_1_1transport_1_1struc_1_1Msg__out.html#a91d2575343b28f83e22a71e7f7b3ff40">emit_serialization</a> (<a class="el" href="namespaceipc_1_1transport_1_1struc.html#a82a69eaa39cbe8a002de1266f1cbb5cb">Segment_ptrs</a> *target_blobs, const typename Builder::Session &amp;session, <a class="el" href="namespaceipc.html#aa3192e586cc45d3e7c22463bf2760f89">Error_code</a> *err_code) const</td></tr>
<tr class="memdesc:a91d2575343b28f83e22a71e7f7b3ff40"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the serialization in the form of a sequence of 1+ <code>Blob</code>s.  <a href="classipc_1_1transport_1_1struc_1_1Msg__out.html#a91d2575343b28f83e22a71e7f7b3ff40">More...</a><br /></td></tr>
<tr class="separator:a91d2575343b28f83e22a71e7f7b3ff40"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adb630aeb1bb9e9335631f9e9e6dc25de"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classipc_1_1transport_1_1struc_1_1Msg__out.html#adb630aeb1bb9e9335631f9e9e6dc25de">n_serialization_segments</a> () const</td></tr>
<tr class="memdesc:adb630aeb1bb9e9335631f9e9e6dc25de"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns what <code>target_blobs.size()</code> would return after calling <code>emit_serialization(&amp;target_blobs)</code> (with an empty <code>target_blobs</code> going-in), right now.  <a href="classipc_1_1transport_1_1struc_1_1Msg__out.html#adb630aeb1bb9e9335631f9e9e6dc25de">More...</a><br /></td></tr>
<tr class="separator:adb630aeb1bb9e9335631f9e9e6dc25de"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pri-attribs" name="pri-attribs"></a>
Private Attributes</h2></td></tr>
<tr class="memitem:aa783b92d94937ebb5d95b7ad5f2c9e37"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classipc_1_1transport_1_1struc_1_1Msg__out.html#aae507a42f29546fa13075a438d96f3f5">Builder</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classipc_1_1transport_1_1struc_1_1Msg__out.html#aa783b92d94937ebb5d95b7ad5f2c9e37">m_builder</a></td></tr>
<tr class="memdesc:aa783b92d94937ebb5d95b7ad5f2c9e37"><td class="mdescLeft">&#160;</td><td class="mdescRight">The guy serializing a <a class="el" href="classipc_1_1transport_1_1struc_1_1Msg__out.html#aab352abf2ced76f2bad6700d75290132" title="See struc::Channel::Msg_body.">Body</a>. Underlying serialization potentially futher mutated by user via <a class="el" href="classipc_1_1transport_1_1struc_1_1Msg__out.html#a9894ad7ec2a46641c4b9b86664d0d465" title="The Body root capnp-generated mutator object.">body_root()</a>.  <a href="classipc_1_1transport_1_1struc_1_1Msg__out.html#aa783b92d94937ebb5d95b7ad5f2c9e37">More...</a><br /></td></tr>
<tr class="separator:aa783b92d94937ebb5d95b7ad5f2c9e37"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a90ba424b2c68cae89597356458b5c570"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classipc_1_1transport_1_1struc_1_1Msg__out.html#a68188b480ac3c33676b08dce72d92922">Body_builder</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classipc_1_1transport_1_1struc_1_1Msg__out.html#a90ba424b2c68cae89597356458b5c570">m_body_root</a></td></tr>
<tr class="memdesc:a90ba424b2c68cae89597356458b5c570"><td class="mdescLeft">&#160;</td><td class="mdescRight">See <a class="el" href="classipc_1_1transport_1_1struc_1_1Msg__out.html#a9894ad7ec2a46641c4b9b86664d0d465" title="The Body root capnp-generated mutator object.">body_root()</a>.  <a href="classipc_1_1transport_1_1struc_1_1Msg__out.html#a90ba424b2c68cae89597356458b5c570">More...</a><br /></td></tr>
<tr class="separator:a90ba424b2c68cae89597356458b5c570"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a31538b5675e0deb607f74d97e9205cf6"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespaceipc_1_1transport.html#a7ee4551983d9df16ec16a3139bac50e8">Native_handle</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classipc_1_1transport_1_1struc_1_1Msg__out.html#a31538b5675e0deb607f74d97e9205cf6">m_hndl_or_null</a></td></tr>
<tr class="memdesc:a31538b5675e0deb607f74d97e9205cf6"><td class="mdescLeft">&#160;</td><td class="mdescRight">The <code>Native_handle</code>, if any, embedded inside this message.  <a href="classipc_1_1transport_1_1struc_1_1Msg__out.html#a31538b5675e0deb607f74d97e9205cf6">More...</a><br /></td></tr>
<tr class="separator:a31538b5675e0deb607f74d97e9205cf6"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="related" name="related"></a>
Related Functions</h2></td></tr>
<tr><td class="ititle" colspan="2"><p >(Note that these are not member functions.) </p>
</td></tr>
<tr class="memitem:a134e737e55ae825527efd6a9e68bf37e"><td class="memTemplParams" colspan="2">template&lt;typename Message_body , typename Struct_builder_t &gt; </td></tr>
<tr class="memitem:a134e737e55ae825527efd6a9e68bf37e"><td class="memTemplItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classipc_1_1transport_1_1struc_1_1Msg__out.html#a134e737e55ae825527efd6a9e68bf37e">operator&lt;&lt;</a> (std::ostream &amp;os, const <a class="el" href="classipc_1_1transport_1_1struc_1_1Msg__out.html">Msg_out</a>&lt; Message_body, Struct_builder_t &gt; &amp;val)</td></tr>
<tr class="memdesc:a134e737e55ae825527efd6a9e68bf37e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Prints string representation of the given <code><a class="el" href="classipc_1_1transport_1_1struc_1_1Msg__out.html" title="A structured out-message suitable to be sent via struc::Channel::send().">Msg_out</a></code> to the given <code>ostream</code>.  <a href="classipc_1_1transport_1_1struc_1_1Msg__out.html#a134e737e55ae825527efd6a9e68bf37e">More...</a><br /></td></tr>
<tr class="separator:a134e737e55ae825527efd6a9e68bf37e"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><div class="compoundTemplParams">template&lt;typename Message_body, typename Struct_builder_t&gt;<br />
class ipc::transport::struc::Msg_out&lt; Message_body, Struct_builder_t &gt;</div><p >A structured out-message suitable to be sent via <a class="el" href="classipc_1_1transport_1_1struc_1_1Channel.html#ae645cb58ad9ea6374970f1f32c5da448" title="In the synchronous/non-blocking manner of Blob_sender::send_blob() or Native_handle_sender::send_nati...">struc::Channel::send()</a>. </p>
<p >Publicly this can be constructed directly; or via <a class="el" href="classipc_1_1transport_1_1struc_1_1Channel.html#a394e0f9cfa5f9bd4ba9ee17d3d54a8b3" title="Creates/returns empty out-message, optionally also holding a native handle, to mutate and later send(...">struc::Channel::create_msg()</a>. The latter has the advantage of reusing the serialization engine knobs registered with the channel and hence is simply easier to write. If one uses the direction-construction route, the builder (serialization) engine type &ndash; <a class="el" href="classipc_1_1transport_1_1struc_1_1Struct__builder.html" title="A documentation-only concept defining the behavior of an object capable of zero-copy-serializing,...">Struct_builder</a> <a class="el" href="classipc_1_1transport_1_1struc_1_1Msg__out.html#aae507a42f29546fa13075a438d96f3f5" title="Short-hand for user-specified Struct_builder type.">Builder</a> &ndash; must match that of the <a class="el" href="classipc_1_1transport_1_1struc_1_1Channel.html" title="Owning and wrapping a pre-connected transport::Channel peer (an endpoint of an established channel ov...">struc::Channel</a> used to <code>send()</code> a <code>*this</code>; otherwise it simply will not compile.</p>
<dl class="section see"><dt>See also</dt><dd>"Lifecycle of an out-message" section of <a class="el" href="classipc_1_1transport_1_1struc_1_1Channel.html" title="Owning and wrapping a pre-connected transport::Channel peer (an endpoint of an established channel ov...">struc::Channel</a> class doc header for useful context.</dd></dl>
<p>As explained in that doc section, a <a class="el" href="classipc_1_1transport_1_1struc_1_1Msg__out.html" title="A structured out-message suitable to be sent via struc::Channel::send().">Msg_out</a> (<a class="el" href="classipc_1_1transport_1_1struc_1_1Channel.html#a860cc99a701576879ebb5a1db58153cc" title="Encapsulation of any out-message payload sent or meant to be sent via send() (et al) by a *this of th...">struc::Channel::Msg_out</a>) is akin to a container, like <code>vector&lt;uint8_t&gt;</code>; and the <a class="el" href="classipc_1_1transport_1_1struc_1_1Msg__out.html#aae507a42f29546fa13075a438d96f3f5" title="Short-hand for user-specified Struct_builder type.">Builder</a> template param + ctor arg are akin to the allocator used by such a container. A given <code>*this</code> represents the message payload; it does not represent a particular <code>send()</code>t (past/present/future) <em>instance</em> of that payload. Modifying it is akin to modifying the <code>vector&lt;uint8_t&gt;</code>, albeit in structured-schema fashion &ndash; available API controlled by <code>Message_body</code> template param &ndash; and with an optionally attached <a class="el" href="namespaceipc_1_1transport.html#a7ee4551983d9df16ec16a3139bac50e8" title="Convenience alias for the commonly used type util::Native_handle.">Native_handle</a>.</p>
<p >As explained in that doc section, like any container, once another process has access to it &ndash; which is only possible in read-only fashion as of this writing &ndash; modifying it must be done with concurrency/synchronization considered. If the compile-time-chosen <a class="el" href="classipc_1_1transport_1_1struc_1_1Msg__out.html#aae507a42f29546fa13075a438d96f3f5" title="Short-hand for user-specified Struct_builder type.">Builder</a> is SHM-based, then this is a concern. If it is heap-based (notably <a class="el" href="classipc_1_1transport_1_1struc_1_1Heap__fixed__builder.html" title="Implements Struct_builder concept by straightforwardly allocating fixed-size segments on-demand in th...">Heap_fixed_builder</a>), then it is not: the serialization is <em>copied</em> into and out of the transport.</p>
<p >After construction, one mutates the message via <a class="el" href="classipc_1_1transport_1_1struc_1_1Msg__out.html#a9894ad7ec2a46641c4b9b86664d0d465" title="The Body root capnp-generated mutator object.">body_root()</a> and/or <a class="el" href="classipc_1_1transport_1_1struc_1_1Msg__out.html#aced8ef8237617c74aaf06832d1385fed" title="Store the Native_handle (potentially .null(), meaning none) in this out-message; no-ops if the same ....">store_native_handle_or_null()</a>. You may also use <a class="el" href="classipc_1_1transport_1_1struc_1_1Msg__out.html#a9303c71f8f459ede25ebe0c8f5492393" title="Convenience method that returns a capnp::Orphan factory in the same capnp::MessageBuilder as body_roo...">orphanage()</a> to build the message in bottom-up fashion, eventually grafting pieces in via <code><a class="el" href="classipc_1_1transport_1_1struc_1_1Msg__out.html#a9894ad7ec2a46641c4b9b86664d0d465" title="The Body root capnp-generated mutator object.">body_root()</a>-&gt;....adopt...()</code>. See <a class="el" href="classipc_1_1transport_1_1struc_1_1Msg__out.html#a9303c71f8f459ede25ebe0c8f5492393" title="Convenience method that returns a capnp::Orphan factory in the same capnp::MessageBuilder as body_roo...">orphanage()</a> doc header for more information on this technique. Lastly consider the following section for another, more holistic bottom-up appraoch (or perhaps taking the orphanage technique further).</p>
<h3>Advanced technique: Construction from earlier-prepared raw <a class="el" href="classCapnp__msg__builder__interface.html">Capnp_msg_builder_interface</a></h3>
<p >To enable the straightforward operation implied above, one uses the 1st/simple ctor form which by definition necessitates specifying the root schema, <a class="el" href="classipc_1_1transport_1_1struc_1_1Msg__out.html#aab352abf2ced76f2bad6700d75290132" title="See struc::Channel::Msg_body.">Body</a> (as to contruct one must know the type). This is typically perfectly natural: a module knows it's building a message of schema <a class="el" href="classipc_1_1transport_1_1struc_1_1Msg__out.html#aab352abf2ced76f2bad6700d75290132" title="See struc::Channel::Msg_body.">Body</a>, so they construct a <code><a class="el" href="classipc_1_1transport_1_1struc_1_1Msg__out.html" title="A structured out-message suitable to be sent via struc::Channel::send().">Msg_out</a>&lt;Body&gt;</code> (which already auto-creates a blank <a class="el" href="classipc_1_1transport_1_1struc_1_1Msg__out.html#aab352abf2ced76f2bad6700d75290132" title="See struc::Channel::Msg_body.">Body</a> via <code>initRoot&lt;Body&gt;()</code>), then fills it out via <a class="el" href="classipc_1_1transport_1_1struc_1_1Msg__out.html#a9894ad7ec2a46641c4b9b86664d0d465" title="The Body root capnp-generated mutator object.">body_root()</a> (which points to what <code>initRoot()</code> returned). The orphanage technique above is a slight complication, in that things can be built bottom-up, but in any case by then the root schema already had to be specified, even if it's actually mutated only somewhat later, once the component orphan(s) can be plugged in.</p>
<p >When working with capnp outside of <a class="el" href="namespaceipc.html" title="Catch-all namespace for the Flow-IPC project: A library/API in modern C++17 providing high-performanc...">ipc</a>, users typically do basically the same thing: start with <code>M.initRoot&lt;Body&gt;()</code>, then set stuff in its tree; or in more complex cases maybe use <code>M.getOrphanage()</code> from the same <code>MessageBuilder M</code> to help build bottom-up.</p>
<p >However consider a complex schema <code>Huge_body</code> built by collaboration between modules A and B. Now module A may be aware the ultimate product is rooted at <code>Huge_body</code>, while module B has no idea, and yet they work together to build parts of the final thing. In that case B does not necessarily think of any particular overall <code>Huge_body</code> tree but only the sub-schema types it cares about; so to it the <code>MessageBuilder M</code> is just a memory pool or heap of sorts; it makes whatever structures it wants (via <code>M.getOrphanage()</code>) from it but does not call or know about <code>initRoot&lt;Huge_body&gt;()</code>. Conceivably, even, module B is first to run its procedures (before module A) and to create <code>M</code> in the first place; and only later module A perhaps finally sets the root (<code>initRoot&lt;HugeBody&gt;()</code>) and attaches whatever orphan values module B produces, hooking them into the <code>HugeBody</code>.</p>
<p >The straightforward use of <a class="el" href="classipc_1_1transport_1_1struc_1_1Msg__out.html" title="A structured out-message suitable to be sent via struc::Channel::send().">Msg_out</a>, as described before, does in fact force one (from the start) to specify <code>HugeBody</code> by definition (it's &ndash; again &ndash; a template argument to the class template), and that may not be desirable in this module A-B scenario. So to support it: use the 2nd/advanced ctor form which takes over (via <code>std::move()</code>) an already-created <a class="el" href="classipc_1_1transport_1_1struc_1_1Msg__out.html#aae507a42f29546fa13075a438d96f3f5" title="Short-hand for user-specified Struct_builder type.">Builder</a> &ndash; not templated on any schema <code>Body</code>. The <a class="el" href="classipc_1_1transport_1_1struc_1_1Msg__out.html#aae507a42f29546fa13075a438d96f3f5" title="Short-hand for user-specified Struct_builder type.">Builder</a> exposes the direct <code>MessageBuilder</code>, so the tree can be built using whatever features in whatever order one desires... and only <em>then</em> create the <a class="el" href="classipc_1_1transport_1_1struc_1_1Msg__out.html" title="A structured out-message suitable to be sent via struc::Channel::send().">Msg_out</a>. The only constraint is that by ctor time, the <code>MessageBuilder</code> (a/k/a <a class="el" href="classCapnp__msg__builder__interface.html">Capnp_msg_builder_interface</a>) <em>is</em> initialized to be rooted at <code>Body</code>; but this could be done anytime up to that point; so module B need not do it, while module A might ultimately do it and then construct the <code><a class="el" href="classipc_1_1transport_1_1struc_1_1Msg__out.html" title="A structured out-message suitable to be sent via struc::Channel::send().">Msg_out</a>&lt;Body&gt;</code>. Alternatively, the user can omit performing <code>initRoot&lt;Body&gt;()</code>, and it will be done as needed by the ctor, resulting in a blank message at that point which then can be filled-out via <a class="el" href="classipc_1_1transport_1_1struc_1_1Msg__out.html#a9894ad7ec2a46641c4b9b86664d0d465" title="The Body root capnp-generated mutator object.">body_root()</a> mutations. (Note: This is just an example. The point is with this technique one can use a <code>MessageBuilder</code> in any fashion desired, and the only constraint is it is in fact rooted at some structure `<code>S</code>, at which point <code><a class="el" href="classipc_1_1transport_1_1struc_1_1Msg__out.html" title="A structured out-message suitable to be sent via struc::Channel::send().">Msg_out</a>&lt;S&gt;</code> can be cted. In that sense it removes any &ndash; albeit typically simplifying &ndash; <a class="el" href="namespaceipc_1_1transport.html" title="Flow-IPC module providing transmission of structured messages and/or low-level blobs (and more) betwe...">ipc::transport</a> constraints on how one builds a message, allowing one to use the full builder API provided by capnp without any stylistic concessions.)</p>
<h3>Resource use (RAM)</h3>
<p >Creating a <code>*this</code>, and mutating it via <a class="el" href="classipc_1_1transport_1_1struc_1_1Msg__out.html#a9894ad7ec2a46641c4b9b86664d0d465" title="The Body root capnp-generated mutator object.">body_root()</a>, uses proportionally large RAM resources; e.g., if you successfully store a multi-megabyte blob, <code>*this</code> will allocate RAM accordingly. Conversely, destroying <code>*this</code> returns such resources. However, if <a class="el" href="classipc_1_1transport_1_1struc_1_1Msg__out.html#aae507a42f29546fa13075a438d96f3f5" title="Short-hand for user-specified Struct_builder type.">Builder</a> is SHM-based, then a process-counting ref-count (conceptually) exists. It is 1 after construction. It is incremented each time it is <code><a class="el" href="classipc_1_1transport_1_1struc_1_1Channel.html#ae645cb58ad9ea6374970f1f32c5da448" title="In the synchronous/non-blocking manner of Blob_sender::send_blob() or Native_handle_sender::send_nati...">struc::Channel::send()</a></code>t. For each such increment, there is a decrement when the receiving process's counterpart <a class="el" href="classipc_1_1transport_1_1struc_1_1Msg__in.html" title="A structured in-message instance suitable as received and emittable (to user) by struc::Channel.">Msg_in</a>, which is always passed-around by <code>shared_ptr</code>, is no longer owned by that process (when that <code>shared_ptr</code> group's ref-count drops to zero). Once <code>*this</code> is destroyed, <em>and</em> each <code>send()</code> target process has both yielded the <a class="el" href="classipc_1_1transport_1_1struc_1_1Channel.html#ae1f4b316eaeb7ed520a84d9e21e21063" title="A ref-counted handle to Msg_in.">struc::Channel::Msg_in_ptr</a> and let that <code>shared_ptr</code> drop to ref-count-zero, the backing RAM is released.</p>
<h3>Resource use: the <a class="el" href="namespaceipc_1_1transport.html#a7ee4551983d9df16ec16a3139bac50e8" title="Convenience alias for the commonly used type util::Native_handle.">Native_handle</a> (if any)</h3>
<p >It is returned to the OS by our destructor. This does not, necessarily, destroy whatever resource it references: presumably the idea is to send it, via IPC, to the opposing process. The handle (FD) that process receives is really a new one in that process's table; there are at that point two <em>descriptors</em> referencing one resource <em>description</em>, and the latter disappears in the kernel only once both descriptors go away. If you do not wish to let the local handle (FD) be destroyed by <code>*this</code> destructor, consider (in Unix-type OS) passing-in <code>dup(your_hndl)</code> instead of <code>your_hndl</code> itself.</p>
<p >The <a class="el" href="namespaceipc_1_1transport.html#a7ee4551983d9df16ec16a3139bac50e8" title="Convenience alias for the commonly used type util::Native_handle.">Native_handle</a>, if any, stored via <a class="el" href="classipc_1_1transport_1_1struc_1_1Msg__out.html#aced8ef8237617c74aaf06832d1385fed" title="Store the Native_handle (potentially .null(), meaning none) in this out-message; no-ops if the same ....">store_native_handle_or_null()</a> is not a part of the serialization/deserialization/sharing schema described above. It just sits in <code>*this</code> until <code>*this</code> dtor runs (or it is replaced/unloaded via <a class="el" href="classipc_1_1transport_1_1struc_1_1Msg__out.html#aced8ef8237617c74aaf06832d1385fed" title="Store the Native_handle (potentially .null(), meaning none) in this out-message; no-ops if the same ....">store_native_handle_or_null()</a>). If at send() time there's one in <code>*this</code>, then a copy is transmitted to the recipient process. <a class="el" href="classipc_1_1transport_1_1struc_1_1Msg__out.html#aced8ef8237617c74aaf06832d1385fed" title="Store the Native_handle (potentially .null(), meaning none) in this out-message; no-ops if the same ....">store_native_handle_or_null()</a> on <code>*this</code> will never have any direct effect on any received copy.</p>
<h3>Impl notes</h3>
<p >Some important aspects of this class template's API, which must be accessed by the <a class="el" href="namespaceipc_1_1transport.html" title="Flow-IPC module providing transmission of structured messages and/or low-level blobs (and more) betwe...">ipc::transport</a> (structured layer) internals only, are <code>protected</code>. <a class="el" href="classipc_1_1transport_1_1struc_1_1Channel.html" title="Owning and wrapping a pre-connected transport::Channel peer (an endpoint of an established channel ov...">struc::Channel</a> then sub-classes this guy and exposes them publicly (to itself). This avoids <code>friend</code> which would would be not quite as clean, since <code>private</code> parts would be exposed too, and so on. In other words this is a class an API &ndash; not a mere data-store &ndash; but there is an internally used API which is left <code>protected</code>. As of this writing it's essentially <a class="el" href="classipc_1_1transport_1_1struc_1_1Msg__out.html#a91d2575343b28f83e22a71e7f7b3ff40" title="Returns the serialization in the form of a sequence of 1+ Blobs.">emit_serialization()</a> which the user does not access directly (<a class="el" href="classipc_1_1transport_1_1struc_1_1Channel.html#ae645cb58ad9ea6374970f1f32c5da448" title="In the synchronous/non-blocking manner of Blob_sender::send_blob() or Native_handle_sender::send_nati...">struc::Channel::send()</a> internals do).</p>
<p >The internally-used APIs are reasonably self-explanatory, so just see their doc headers. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Message_body</td><td>See <a class="el" href="classipc_1_1transport_1_1struc_1_1Channel.html" title="Owning and wrapping a pre-connected transport::Channel peer (an endpoint of an established channel ov...">struc::Channel</a>. </td></tr>
    <tr><td class="paramname">Struct_builder_t</td><td>See <a class="el" href="classipc_1_1transport_1_1struc_1_1Channel.html" title="Owning and wrapping a pre-connected transport::Channel peer (an endpoint of an established channel ov...">struc::Channel</a>. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="msg_8hpp_source.html#l00153">153</a> of file <a class="el" href="msg_8hpp_source.html">msg.hpp</a>.</p>
</div><h2 class="groupheader">Member Typedef Documentation</h2>
<a id="aab352abf2ced76f2bad6700d75290132" name="aab352abf2ced76f2bad6700d75290132"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aab352abf2ced76f2bad6700d75290132">&#9670;&nbsp;</a></span>Body</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Message_body , typename Struct_builder_t &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classipc_1_1transport_1_1struc_1_1Msg__out.html">ipc::transport::struc::Msg_out</a>&lt; Message_body, Struct_builder_t &gt;::Body =  Message_body</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>See <a class="el" href="classipc_1_1transport_1_1struc_1_1Channel.html#a27a273ed7e1aca34b721fea22c869a41" title="Short-hand for the Message_body template param, this is the capnp message schema transmissible over *...">struc::Channel::Msg_body</a>. </p>

<p class="definition">Definition at line <a class="el" href="msg_8hpp_source.html#l00159">159</a> of file <a class="el" href="msg_8hpp_source.html">msg.hpp</a>.</p>

</div>
</div>
<a id="a68188b480ac3c33676b08dce72d92922" name="a68188b480ac3c33676b08dce72d92922"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a68188b480ac3c33676b08dce72d92922">&#9670;&nbsp;</a></span>Body_builder</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Message_body , typename Struct_builder_t &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classipc_1_1transport_1_1struc_1_1Msg__out.html">ipc::transport::struc::Msg_out</a>&lt; Message_body, Struct_builder_t &gt;::Body_builder =  typename Body::Builder</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Short-hand for capnp-generated mutating <code>Builder</code> nested class of <a class="el" href="classipc_1_1transport_1_1struc_1_1Msg__out.html#aab352abf2ced76f2bad6700d75290132" title="See struc::Channel::Msg_body.">Body</a>. See <a class="el" href="classipc_1_1transport_1_1struc_1_1Msg__out.html#a9894ad7ec2a46641c4b9b86664d0d465" title="The Body root capnp-generated mutator object.">body_root()</a>. </p>

<p class="definition">Definition at line <a class="el" href="msg_8hpp_source.html#l00162">162</a> of file <a class="el" href="msg_8hpp_source.html">msg.hpp</a>.</p>

</div>
</div>
<a id="aae507a42f29546fa13075a438d96f3f5" name="aae507a42f29546fa13075a438d96f3f5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aae507a42f29546fa13075a438d96f3f5">&#9670;&nbsp;</a></span>Builder</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Message_body , typename Struct_builder_t &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classipc_1_1transport_1_1struc_1_1Msg__out.html">ipc::transport::struc::Msg_out</a>&lt; Message_body, Struct_builder_t &gt;<a class="el" href="classStruct__builder__config_1_1Builder.html">::Builder</a> =  Struct_builder_t</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Short-hand for user-specified <a class="el" href="classipc_1_1transport_1_1struc_1_1Struct__builder.html" title="A documentation-only concept defining the behavior of an object capable of zero-copy-serializing,...">Struct_builder</a> type. </p>
<p >An internally stored instance of this contains the user payload. </p>

<p class="definition">Definition at line <a class="el" href="msg_8hpp_source.html#l00168">168</a> of file <a class="el" href="msg_8hpp_source.html">msg.hpp</a>.</p>

</div>
</div>
<a id="a0e66b941a2b67ec21087581d1e44f42b" name="a0e66b941a2b67ec21087581d1e44f42b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0e66b941a2b67ec21087581d1e44f42b">&#9670;&nbsp;</a></span>Builder_config</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Message_body , typename Struct_builder_t &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classipc_1_1transport_1_1struc_1_1Msg__out.html">ipc::transport::struc::Msg_out</a>&lt; Message_body, Struct_builder_t &gt;::Builder_config =  typename Builder::Config</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Short-hand for user-specified <a class="el" href="structipc_1_1transport_1_1struc_1_1Struct__builder_1_1Config.html" title="Copy-ctible, copy-assignable, default-ctible type â€“ informally, cheaply copyable and likely an aggreg...">Struct_builder::Config</a>. </p>
<p >One can construct a <a class="el" href="classipc_1_1transport_1_1struc_1_1Msg__out.html#aae507a42f29546fa13075a438d96f3f5" title="Short-hand for user-specified Struct_builder type.">Builder</a> via <code>Builder(const Builder_config&amp;)</code>. </p>

<p class="definition">Definition at line <a class="el" href="msg_8hpp_source.html#l00174">174</a> of file <a class="el" href="msg_8hpp_source.html">msg.hpp</a>.</p>

</div>
</div>
<a id="acd04d61cf19ad87610598fddbb5d8052" name="acd04d61cf19ad87610598fddbb5d8052"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acd04d61cf19ad87610598fddbb5d8052">&#9670;&nbsp;</a></span>Orphanage</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Message_body , typename Struct_builder_t &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classipc_1_1transport_1_1struc_1_1Msg__out.html">ipc::transport::struc::Msg_out</a>&lt; Message_body, Struct_builder_t &gt;::Orphanage =  ::capnp::Orphanage</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Short-hand for capnp orphan factory. See <a class="el" href="classipc_1_1transport_1_1struc_1_1Msg__out.html#a9303c71f8f459ede25ebe0c8f5492393" title="Convenience method that returns a capnp::Orphan factory in the same capnp::MessageBuilder as body_roo...">orphanage()</a>. </p>

<p class="definition">Definition at line <a class="el" href="msg_8hpp_source.html#l00177">177</a> of file <a class="el" href="msg_8hpp_source.html">msg.hpp</a>.</p>

</div>
</div>
<h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="a9d4ab66d2740f40a88f476d46dd04f1e" name="a9d4ab66d2740f40a88f476d46dd04f1e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9d4ab66d2740f40a88f476d46dd04f1e">&#9670;&nbsp;</a></span>Msg_out() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Message_body , typename Struct_builder_t &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classipc_1_1transport_1_1struc_1_1Msg__out.html">ipc::transport::struc::Msg_out</a>&lt; Message_body, Struct_builder_t &gt;::Msg_out </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classipc_1_1transport_1_1struc_1_1Msg__out.html#a0e66b941a2b67ec21087581d1e44f42b">Builder_config</a> &amp;&#160;</td>
          <td class="paramname"><em>struct_builder_config</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">explicit</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Creates blank <a class="el" href="classipc_1_1transport_1_1struc_1_1Msg__out.html#aab352abf2ced76f2bad6700d75290132" title="See struc::Channel::Msg_body.">Body</a>-bearing out-message message, with no native handle, all of which can be modified via <a class="el" href="classipc_1_1transport_1_1struc_1_1Msg__out.html#a9894ad7ec2a46641c4b9b86664d0d465" title="The Body root capnp-generated mutator object.">body_root()</a> and the ancillary mutator <a class="el" href="classipc_1_1transport_1_1struc_1_1Msg__out.html#aced8ef8237617c74aaf06832d1385fed" title="Store the Native_handle (potentially .null(), meaning none) in this out-message; no-ops if the same ....">store_native_handle_or_null()</a>. </p>
<p >See also the alternate (advanced-technique) ctor form which may be more suitable in more complex scenarios. This is discussed in our class doc header.</p>
<h3>Obtaining the <a class="el" href="classipc_1_1transport_1_1struc_1_1Msg__out.html#a0e66b941a2b67ec21087581d1e44f42b" title="Short-hand for user-specified Struct_builder::Config.">Builder_config</a> object</h3>
<p >In the first place it is often easier/better to not invoke this ctor directly but rather invoke <a class="el" href="classipc_1_1transport_1_1struc_1_1Channel.html#a394e0f9cfa5f9bd4ba9ee17d3d54a8b3" title="Creates/returns empty out-message, optionally also holding a native handle, to mutate and later send(...">struc::Channel::create_msg()</a> which will do so for you and supply the proper <a class="el" href="classipc_1_1transport_1_1struc_1_1Msg__out.html#a0e66b941a2b67ec21087581d1e44f42b" title="Short-hand for user-specified Struct_builder::Config.">Builder_config</a>. However it is definitely possible for a <a class="el" href="classipc_1_1transport_1_1struc_1_1Msg__out.html" title="A structured out-message suitable to be sent via struc::Channel::send().">Msg_out</a> to be constructed orthogonally to a particular <a class="el" href="classipc_1_1transport_1_1struc_1_1Channel.html" title="Owning and wrapping a pre-connected transport::Channel peer (an endpoint of an established channel ov...">struc::Channel</a> &ndash; or even to a particular ipc::Session (if even applicable). How to get the <code>struct_builder_config</code> arg for this ctor then? Informally: if you're constructing the <a class="el" href="classipc_1_1transport_1_1struc_1_1Msg__out.html#a0e66b941a2b67ec21087581d1e44f42b" title="Short-hand for user-specified Struct_builder::Config.">Builder_config</a> directly, you're probably not doing the right thing. The following places are available to obtain one for safety and efficiency (and code maintainability):</p><ul>
<li>From another, compatible, <a class="el" href="classipc_1_1transport_1_1struc_1_1Channel.html" title="Owning and wrapping a pre-connected transport::Channel peer (an endpoint of an established channel ov...">struc::Channel</a> via <a class="el" href="classipc_1_1transport_1_1struc_1_1Channel.html#a969bc2021565c542c902fc14ff711c38" title="Returns the (light-weight) Builder_config specified (directly or indirectly) at construction time.">struc::Channel::struct_builder_config()</a>.</li>
<li>Heap-backed:<ul>
<li>If you have a target <a class="el" href="classipc_1_1transport_1_1struc_1_1Channel.html#a4a0188052c15cab70d712f41b0e74ba7" title="Short-hand for the transport::Channel type passed into ctor and returned by owned_channel().">struc::Channel::Owned_channel</a>: via <code>static</code> <a class="el" href="classipc_1_1transport_1_1struc_1_1Channel.html#a08062e4cc99347e94e9e917b382985ee" title="Utility for use when Builder_config template param is Heap_fixed_builder::Config, this returns such a...">struc::Channel::heap_fixed_builder_config()</a>.</li>
<li>Otherwise: <a class="el" href="classipc_1_1session_1_1Session__mv.html#a107684fdd5d233549c6daac26a81a542" title="Utility that obtains a heap-based (non-zero-copy) Struct_builder::Config, constructed with the most e...">session::Session_mv::heap_fixed_builder_config()</a> (<code>static</code> or non-<code>static</code>).</li>
</ul>
</li>
<li>SHM-backed (e.g., SHM-classic):<ul>
<li><a class="el" href="classipc_1_1session_1_1shm_1_1classic_1_1Session__mv.html#a85bb0b948b7b54c06557edd3d03d66bd" title="Returns builder config suitable for capnp-serializing out-messages in SHM arena session_shm().">session::shm::classic::Session_mv::session_shm_builder_config()</a>, <a class="el" href="classipc_1_1session_1_1shm_1_1classic_1_1Session__mv.html#a0fbea0563835e852069cdaab506dd92c" title="Identical to session_shm_builder_config() but backed by SHM arena app_shm() instead of session_shm().">session::shm::classic::Session_mv::app_shm_builder_config()</a>. Requires a <code>Session</code> object.</li>
<li><a class="el" href="classipc_1_1session_1_1shm_1_1classic_1_1Session__server.html#ad0dafea47293d23e079b6b5c5c6a9cef" title="Returns builder config suitable for capnp-serializing out-messages in SHM arena app_shm() for the sam...">session::shm::classic::Session_server::app_shm_builder_config()</a> (requires <a class="el" href="structipc_1_1session_1_1Client__app.html" title="An App that is used as a client in at least one client-server IPC split.">session::Client_app</a>). Server-only; if a <code>Session</code> is not available or applicable.</li>
</ul>
</li>
</ul>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">struct_builder_config</td><td>See above. This is neither memorized nor copied. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="msg_8hpp_source.html#l00874">874</a> of file <a class="el" href="msg_8hpp_source.html">msg.hpp</a>.</p>

</div>
</div>
<a id="a9738acbcfb431dc1fc0174b42787060b" name="a9738acbcfb431dc1fc0174b42787060b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9738acbcfb431dc1fc0174b42787060b">&#9670;&nbsp;</a></span>Msg_out() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Message_body , typename Struct_builder_t &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classipc_1_1transport_1_1struc_1_1Msg__out.html">ipc::transport::struc::Msg_out</a>&lt; Message_body, Struct_builder_t &gt;::Msg_out </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classipc_1_1transport_1_1struc_1_1Msg__out.html#aae507a42f29546fa13075a438d96f3f5">Builder</a> &amp;&amp;&#160;</td>
          <td class="paramname"><em>struct_builder</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">explicit</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Advanced technique: Creates message by subsuming the provided already-prepared <code><a class="el" href="classCapnp__msg__builder__interface.html">Capnp_msg_builder_interface</a></code>-bearing, root-initialized-to-<a class="el" href="classipc_1_1transport_1_1struc_1_1Msg__out.html#aab352abf2ced76f2bad6700d75290132" title="See struc::Channel::Msg_body.">Body</a> <a class="el" href="classipc_1_1transport_1_1struc_1_1Msg__out.html#aae507a42f29546fa13075a438d96f3f5" title="Short-hand for user-specified Struct_builder type.">Builder</a> object (which is moved-to <code>*this</code>), with no native handle, all of which can be (further) modified via <a class="el" href="classipc_1_1transport_1_1struc_1_1Msg__out.html#a9894ad7ec2a46641c4b9b86664d0d465" title="The Body root capnp-generated mutator object.">body_root()</a> and the ancillary mutator <a class="el" href="classipc_1_1transport_1_1struc_1_1Msg__out.html#aced8ef8237617c74aaf06832d1385fed" title="Store the Native_handle (potentially .null(), meaning none) in this out-message; no-ops if the same ....">store_native_handle_or_null()</a>. </p>
<p >The advanced technique revolving around the use of this ctor form is discussed in our class doc header. That said:</p><ul>
<li><code>*struct_builder.payload_msg_builder()</code> &ndash; a <a class="el" href="classCapnp__msg__builder__interface.html">Capnp_msg_builder_interface</a> &ndash; <em>must</em> already have been root-initialized, and the root type <em>must</em> be <a class="el" href="classipc_1_1transport_1_1struc_1_1Msg__out.html#aab352abf2ced76f2bad6700d75290132" title="See struc::Channel::Msg_body.">Body</a>; or <em>must</em> not have been root-initialized at all (in which case the ctor will perform <code>initRoot&lt;Body&gt;()</code>).<ul>
<li>If it was already root-initialized, but not with <code>&lt;Body&gt;</code>, then behavior is undefined, and the trouble may only be detected on the opposing side upon receipt of <code>*this</code> message, in trying to deserialize it in <a class="el" href="classipc_1_1transport_1_1struc_1_1Msg__in.html" title="A structured in-message instance suitable as received and emittable (to user) by struc::Channel.">Msg_in</a>.</li>
<li>If you chose to not root-initialize before this ctor, and therefore it performs <code>initRoot&lt;Body&gt;()</code>, then naturally the message root tree shall be blank, similarly to the other/vanilla ctor.</li>
<li>This is typically accomplished via <code>struct_builder.payload_msg_builder()-&gt;initRoot&lt;Body&gt;()</code>, although there are other techniques available. See capnp docs for <code>capnp::MessageBuilder</code> (<a class="el" href="classCapnp__msg__builder__interface.html">Capnp_msg_builder_interface</a>).</li>
</ul>
</li>
<li>That having been guaranteed, the message may be further mutated via <a class="el" href="classipc_1_1transport_1_1struc_1_1Msg__out.html#a9894ad7ec2a46641c4b9b86664d0d465" title="The Body root capnp-generated mutator object.">body_root()</a>.<ul>
<li>Naturally it may also have already been mutated (beyond <code>initRoot()</code>/etc.), possibly to its final intended form.</li>
<li>Conversely, in practice, if you chose to not root-initialize <code>struct_builder</code>, you'll want to in fact use <a class="el" href="classipc_1_1transport_1_1struc_1_1Msg__out.html#a9894ad7ec2a46641c4b9b86664d0d465" title="The Body root capnp-generated mutator object.">body_root()</a> mutations to actually load the message with something useful.</li>
</ul>
</li>
</ul>
<p >For exposition purposes: note that the other ctor form, which takes a <code>Builder::Config</code>, behaves as-if delegating to the present ctor: <code>Msg_out(Builder(struct_builder_config))</code>. When creating a straightforward message in ~one place in the user code, using that other ctor form is usually therefore more convenient, avoiding some boiler-plate.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">struct_builder</td><td>See above. Note the requirements listed. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="msg_8hpp_source.html#l00886">886</a> of file <a class="el" href="msg_8hpp_source.html">msg.hpp</a>.</p>

</div>
</div>
<a id="a9289790ac6b85681c8697fc55ff8f3a7" name="a9289790ac6b85681c8697fc55ff8f3a7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9289790ac6b85681c8697fc55ff8f3a7">&#9670;&nbsp;</a></span>Msg_out() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Message_body , typename Struct_builder_t &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classipc_1_1transport_1_1struc_1_1Msg__out.html">ipc::transport::struc::Msg_out</a>&lt; Message_body, Struct_builder_t &gt;::Msg_out</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates non-message; any operation except move-to or destruction results in undefined behavior subsequently. </p>

<p class="definition">Definition at line <a class="el" href="msg_8hpp_source.html#l00867">867</a> of file <a class="el" href="msg_8hpp_source.html">msg.hpp</a>.</p>

</div>
</div>
<a id="a50c8fd96304e09aaf9bbacd9959c07d6" name="a50c8fd96304e09aaf9bbacd9959c07d6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a50c8fd96304e09aaf9bbacd9959c07d6">&#9670;&nbsp;</a></span>Msg_out() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Message_body , typename Struct_builder_t &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classipc_1_1transport_1_1struc_1_1Msg__out.html">ipc::transport::struc::Msg_out</a>&lt; Message_body, Struct_builder_t &gt;::Msg_out </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classipc_1_1transport_1_1struc_1_1Msg__out.html">Msg_out</a>&lt; Message_body, Struct_builder_t &gt; &amp;&amp;&#160;</td>
          <td class="paramname"><em>src</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Move ctor: Make <code>*this</code> equal to <code>src</code>, while <code>src</code> becomes as-if default-cted (in that any operation except move-to or destruction results in undefined behavior subsequently). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">src</td><td>Source object. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="msg_8hpp_source.html#l00902">902</a> of file <a class="el" href="msg_8hpp_source.html">msg.hpp</a>.</p>

<p class="reference">References <a class="el" href="msg_8hpp_source.html#l00988">ipc::transport::struc::Msg_out&lt; Message_body, Struct_builder_t &gt;::operator=()</a>.</p>
<div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="classipc_1_1transport_1_1struc_1_1Msg__out_a50c8fd96304e09aaf9bbacd9959c07d6_cgraph.svg" width="328" height="47"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe>
</div>
</div>

</div>
</div>
<a id="a6fe17e3ce3e3569e7b08538f525918e9" name="a6fe17e3ce3e3569e7b08538f525918e9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6fe17e3ce3e3569e7b08538f525918e9">&#9670;&nbsp;</a></span>~Msg_out()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Message_body , typename Struct_builder_t &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classipc_1_1transport_1_1struc_1_1Msg__out.html">ipc::transport::struc::Msg_out</a>&lt; Message_body, Struct_builder_t &gt;::~<a class="el" href="classipc_1_1transport_1_1struc_1_1Msg__out.html">Msg_out</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns resources, including potentially significant RAM resources and <a class="el" href="classipc_1_1transport_1_1struc_1_1Msg__out.html#ae033461f1404be60262033bafcfaccba" title="Returns whatever was the last word according to store_native_handle_or_null().">native_handle_or_null()</a>, taken throughout; in the case of SHM-based RAM resources their return may be delayed until counterpart <code><a class="el" href="classipc_1_1transport_1_1struc_1_1Msg__in.html" title="A structured in-message instance suitable as received and emittable (to user) by struc::Channel.">Msg_in</a></code>s are also destroyed. </p>
<p >See class doc header for discussion. </p>

<p class="definition">Definition at line <a class="el" href="msg_8hpp_source.html#l00979">979</a> of file <a class="el" href="msg_8hpp_source.html">msg.hpp</a>.</p>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="a9894ad7ec2a46641c4b9b86664d0d465" name="a9894ad7ec2a46641c4b9b86664d0d465"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9894ad7ec2a46641c4b9b86664d0d465">&#9670;&nbsp;</a></span>body_root() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Message_body , typename Struct_builder_t &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classipc_1_1transport_1_1struc_1_1Msg__out.html">Msg_out</a>&lt; Message_body, Struct_builder_t &gt;<a class="el" href="classipc_1_1transport_1_1struc_1_1Msg__out.html#a68188b480ac3c33676b08dce72d92922">::Body_builder</a> * <a class="el" href="classipc_1_1transport_1_1struc_1_1Msg__out.html">ipc::transport::struc::Msg_out</a>&lt; Message_body, Struct_builder_t &gt;::body_root</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The <a class="el" href="classipc_1_1transport_1_1struc_1_1Msg__out.html#aab352abf2ced76f2bad6700d75290132" title="See struc::Channel::Msg_body.">Body</a> root capnp-generated mutator object. </p>
<p >E.g.: <code>this-&gt;<a class="el" href="classipc_1_1transport_1_1struc_1_1Msg__out.html#a9894ad7ec2a46641c4b9b86664d0d465" title="The Body root capnp-generated mutator object.">body_root()</a>-&gt;initSomeStruct().setSomeField(123)</code> will create the capnp-<code>struct</code>-typed root field <code>someStruct</code> and set the value <code>someField</code> &ndash; presumably an integer &ndash; within it. The pointer returned shall always be the same value until <code>*this</code> is destroyed.</p>
<p ><a class="el" href="classipc_1_1transport_1_1struc_1_1Msg__out.html#a68188b480ac3c33676b08dce72d92922" title="Short-hand for capnp-generated mutating Builder nested class of Body. See body_root().">Body_builder</a> is light-weight, so you may make a copy and then mutate via that, if desired. However whether <code>*(<a class="el" href="classipc_1_1transport_1_1struc_1_1Msg__out.html#a9894ad7ec2a46641c4b9b86664d0d465" title="The Body root capnp-generated mutator object.">body_root()</a>)</code> or such a copy, such a <code>Builder</code> object may not be accessed after <code>*this</code> is destroyed.</p>
<p >Informally we recommend against copying <code>*(<a class="el" href="classipc_1_1transport_1_1struc_1_1Msg__out.html#a9894ad7ec2a46641c4b9b86664d0d465" title="The Body root capnp-generated mutator object.">body_root()</a>)</code>: Light-weight or not, it's a copy, and copying a pointer is cheaper; and it may not live past <code>*this</code> anyway; and <a class="el" href="classipc_1_1transport_1_1struc_1_1Msg__out.html#a9894ad7ec2a46641c4b9b86664d0d465" title="The Body root capnp-generated mutator object.">body_root()</a> always returns the same pointer. So just store the pointer (or reference from it).</p>
<h3>Quick capnp tips</h3>
<p >You should really read all of capnp docs at its web site. They are very useful and well written and not overly formal despite being quite comprehensive. That said a couple of gotchas/tips:</p><ul>
<li>On a <code>Builder</code>, <code>.getX()</code> and <code>.setX()</code> are lightning-fast, like accessing <code>struct</code> members directly &ndash; but only when <code>X</code> is of a scalar type. Compound types, where <code>.getX()</code> returns not a native type but another <code>Builder</code>, need to perform some pointer checking and are slower. Therefore, if you plan to <code>.getX()</code> and then <code>.setA()</code> and <code>.setB()</code> (and similar) on that <code>X</code>, you should save the result (<code>auto x = ....getX();</code>); then mutate via the saved result (<code>x.setA(...); x.setB(...)</code>).</li>
<li>Let <code>X</code> be a compound field, particularly <code>List</code>, <code>Text</code> (string/list-of-characters), <code>Data</code> (list-of-bytes). It is usually, to begin, null; you must perform <code>.initX(size_t n)</code> or equivalent to initialize it (fill it with <code>n</code> zeroes). However, suppose you are mutating a message, such as a previously-sent message, and wish to <em>modify</em> the <code>X</code>. If the new value might have the same length (which is common), the correct thing to do is: check <code>.hasX()</code>; if <code>true</code>, modify <code>.getX()</code>; but if <code>false</code> then <code>.initX(n)</code> (as <code>X</code> was null after all). Performing <code>.initX()</code> on an already-<code>.initX()</code>ed value works but has a nasty invisible effect: the existing datum continues taking space in the serialization; the new datum takes a new chunk of the serialization segments (and might even cause the allocation of a new segment if needed). As of this writing capnp does not reuse such orphaned space. If the new <code>n</code> equals the old <code>n</code>, this is a straight waste of RAM; and can lead to pathologically growing memory leaks if done many times.<ul>
<li>However, if the new <code>n</code> is different from the preceding, then there is no choice but to re-<code>.initX()</code>. A list/blob/string's size cannot be modified in capnp.</li>
<li>It is best to avoid any situation where the <code>n</code> would change; try to design your protocol differently.</li>
</ul>
</li>
</ul>
<dl class="section return"><dt>Returns</dt><dd>See above. </dd></dl>

<p class="definition">Definition at line <a class="el" href="msg_8hpp_source.html#l01018">1018</a> of file <a class="el" href="msg_8hpp_source.html">msg.hpp</a>.</p>

<p class="reference">Referenced by <a class="el" href="msg__mdt__out_8hpp_source.html#l00144">ipc::transport::struc::Msg_mdt_out&lt; Struct_builder_config &gt;::Msg_mdt_out()</a>, and <a class="el" href="ipc__transport__structured_2src_2ipc_2transport_2struc_2sync__io_2channel_8hpp_source.html#l04352">ipc::transport::struc::sync_io::Channel&lt; Channel_obj, Message_body, Struct_builder_config, Struct_reader_config &gt;::send_core()</a>.</p>
<div class="dynheader">
Here is the caller graph for this function:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="classipc_1_1transport_1_1struc_1_1Msg__out_a9894ad7ec2a46641c4b9b86664d0d465_icgraph.svg" width="383" height="107"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe>
</div>
</div>

</div>
</div>
<a id="a66eade858d6b311d6e2d633b43ee71ad" name="a66eade858d6b311d6e2d633b43ee71ad"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a66eade858d6b311d6e2d633b43ee71ad">&#9670;&nbsp;</a></span>body_root() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Message_body , typename Struct_builder_t &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classipc_1_1transport_1_1struc_1_1Msg__out.html">Msg_out</a>&lt; Message_body, Struct_builder_t &gt;<a class="el" href="classipc_1_1transport_1_1struc_1_1Msg__out.html#a68188b480ac3c33676b08dce72d92922">::Body_builder</a> * <a class="el" href="classipc_1_1transport_1_1struc_1_1Msg__out.html">ipc::transport::struc::Msg_out</a>&lt; Message_body, Struct_builder_t &gt;::body_root</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Equivalent to the other <a class="el" href="classipc_1_1transport_1_1struc_1_1Msg__out.html#a9894ad7ec2a46641c4b9b86664d0d465" title="The Body root capnp-generated mutator object.">body_root()</a> overload but immutable version. </p>
<p >May be useful for, say, pretty-printing it to log (e.g.: <code>capnp::prettyPrint(M.body_root()-&gt;asReader()).flatten().cStr()</code>).</p>
<dl class="section return"><dt>Returns</dt><dd>See above. </dd></dl>

<p class="definition">Definition at line <a class="el" href="msg_8hpp_source.html#l01024">1024</a> of file <a class="el" href="msg_8hpp_source.html">msg.hpp</a>.</p>

</div>
</div>
<a id="a91d2575343b28f83e22a71e7f7b3ff40" name="a91d2575343b28f83e22a71e7f7b3ff40"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a91d2575343b28f83e22a71e7f7b3ff40">&#9670;&nbsp;</a></span>emit_serialization()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Message_body , typename Struct_builder_t &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classipc_1_1transport_1_1struc_1_1Msg__out.html">ipc::transport::struc::Msg_out</a>&lt; Message_body, Struct_builder_t &gt;::emit_serialization </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespaceipc_1_1transport_1_1struc.html#a82a69eaa39cbe8a002de1266f1cbb5cb">Segment_ptrs</a> *&#160;</td>
          <td class="paramname"><em>target_blobs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const typename Builder::Session &amp;&#160;</td>
          <td class="paramname"><em>session</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceipc.html#aa3192e586cc45d3e7c22463bf2760f89">Error_code</a> *&#160;</td>
          <td class="paramname"><em>err_code</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the serialization in the form of a sequence of 1+ <code>Blob</code>s. </p>
<p >It is meant to be invoked at <a class="el" href="classipc_1_1transport_1_1struc_1_1Channel.html#ae645cb58ad9ea6374970f1f32c5da448" title="In the synchronous/non-blocking manner of Blob_sender::send_blob() or Native_handle_sender::send_nati...">struc::Channel::send()</a> time.</p>
<p >It can be invoked repeatedly: <code>session</code> can specify a different destination each time; or the same destination each time; or an arbitrary mix thereof. In particular <a class="el" href="classipc_1_1transport_1_1struc_1_1Channel.html#ae645cb58ad9ea6374970f1f32c5da448" title="In the synchronous/non-blocking manner of Blob_sender::send_blob() or Native_handle_sender::send_nati...">struc::Channel::send()</a> (and its derivatives <a class="el" href="classipc_1_1transport_1_1struc_1_1Channel.html#aa41aee3c76035f43833078e625e6ef78" title="Equivalent to the other sync_request() overload but with no timeout; meaning it shall exit only once ...">struc::Channel::sync_request()</a>, <a class="el" href="classipc_1_1transport_1_1struc_1_1Channel.html#a97506bcb695f22e7ca6b480bae5b2346" title="Identical to send() sends the out-message not as a notification but as a request, registering the exp...">struc::Channel::async_request()</a>) shall each time specify the channel's opposing process as the destination &ndash; regardless of which <a class="el" href="classipc_1_1transport_1_1struc_1_1Channel.html" title="Owning and wrapping a pre-connected transport::Channel peer (an endpoint of an established channel ov...">struc::Channel</a>'s <a class="el" href="classipc_1_1transport_1_1struc_1_1Channel.html#a394e0f9cfa5f9bd4ba9ee17d3d54a8b3" title="Creates/returns empty out-message, optionally also holding a native handle, to mutate and later send(...">struc::Channel::create_msg()</a> originally generated <code>*this</code> (assuming that method was even used for construction of <code>*this</code> &ndash; in no way required, just often convenient).</p>
<dl class="section see"><dt>See also</dt><dd>our class doc header and/or "Lifecycle of an out-message" section of <a class="el" href="classipc_1_1transport_1_1struc_1_1Channel.html" title="Owning and wrapping a pre-connected transport::Channel peer (an endpoint of an established channel ov...">struc::Channel</a> class doc header. Recall that where it mentions <a class="el" href="classipc_1_1transport_1_1struc_1_1Channel.html#ae645cb58ad9ea6374970f1f32c5da448" title="In the synchronous/non-blocking manner of Blob_sender::send_blob() or Native_handle_sender::send_nati...">struc::Channel::send()</a>, you can understand there a 1-1 relationship with a synchronous call to <code>this-&gt;<a class="el" href="classipc_1_1transport_1_1struc_1_1Msg__out.html#a91d2575343b28f83e22a71e7f7b3ff40" title="Returns the serialization in the form of a sequence of 1+ Blobs.">emit_serialization()</a></code>.</dd></dl>
<h3>Errors</h3>
<p >See <a class="el" href="classipc_1_1transport_1_1struc_1_1Struct__builder.html#af5085934123f075c6d0701e9e45e4bcc" title="Returns the serialization in the form of a sequence of 1+ pointers to Blobs which are guaranteed to r...">Struct_builder::emit_serialization()</a>. This essentially forwards to that and emits its errors if any. Out-arg <code>native_handle_or_null</code> is untouched on error.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">target_blobs</td><td>On success (no error emitted) this is cleared and replaced with the sequence of segments as <code>Blob</code>s. </td></tr>
    <tr><td class="paramname">session</td><td>Specifies the opposing recipient for which the serialization is intended. If <code>Builder::Session</code> is <a class="el" href="structipc_1_1transport_1_1struc_1_1Null__session.html" title="Value for Struct_builder::Session when no extra information is needed when serializing Struct_builder...">Null_session</a>, then <code>Session()</code> is the only value to supply here. Otherwise more information is necessary. </td></tr>
    <tr><td class="paramname">err_code</td><td>See <code>flow::Error_code</code> docs for error reporting semantics. See above. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="msg_8hpp_source.html#l01059">1059</a> of file <a class="el" href="msg_8hpp_source.html">msg.hpp</a>.</p>

</div>
</div>
<a id="adb630aeb1bb9e9335631f9e9e6dc25de" name="adb630aeb1bb9e9335631f9e9e6dc25de"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adb630aeb1bb9e9335631f9e9e6dc25de">&#9670;&nbsp;</a></span>n_serialization_segments()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Message_body , typename Struct_builder_t &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_t <a class="el" href="classipc_1_1transport_1_1struc_1_1Msg__out.html">ipc::transport::struc::Msg_out</a>&lt; Message_body, Struct_builder_t &gt;::n_serialization_segments</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns what <code>target_blobs.size()</code> would return after calling <code>emit_serialization(&amp;target_blobs)</code> (with an empty <code>target_blobs</code> going-in), right now. </p>
<dl class="section return"><dt>Returns</dt><dd>See above. </dd></dl>

<p class="definition">Definition at line <a class="el" href="msg_8hpp_source.html#l01066">1066</a> of file <a class="el" href="msg_8hpp_source.html">msg.hpp</a>.</p>

</div>
</div>
<a id="ae033461f1404be60262033bafcfaccba" name="ae033461f1404be60262033bafcfaccba"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae033461f1404be60262033bafcfaccba">&#9670;&nbsp;</a></span>native_handle_or_null()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Message_body , typename Struct_builder_t &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespaceipc_1_1transport.html#a7ee4551983d9df16ec16a3139bac50e8">Native_handle</a> <a class="el" href="classipc_1_1transport_1_1struc_1_1Msg__out.html">ipc::transport::struc::Msg_out</a>&lt; Message_body, Struct_builder_t &gt;::native_handle_or_null</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns whatever was the last word according to <a class="el" href="classipc_1_1transport_1_1struc_1_1Msg__out.html#aced8ef8237617c74aaf06832d1385fed" title="Store the Native_handle (potentially .null(), meaning none) in this out-message; no-ops if the same ....">store_native_handle_or_null()</a>. </p>
<p >Note it is a copy; <code>*this</code> retains ownership of the OS resource.</p>
<dl class="section return"><dt>Returns</dt><dd>See ctor (which stores no handle), <a class="el" href="classipc_1_1transport_1_1struc_1_1Msg__out.html#aced8ef8237617c74aaf06832d1385fed" title="Store the Native_handle (potentially .null(), meaning none) in this out-message; no-ops if the same ....">store_native_handle_or_null()</a>. </dd></dl>

<p class="definition">Definition at line <a class="el" href="msg_8hpp_source.html#l01053">1053</a> of file <a class="el" href="msg_8hpp_source.html">msg.hpp</a>.</p>

<p class="reference">Referenced by <a class="el" href="ipc__transport__structured_2src_2ipc_2transport_2struc_2sync__io_2channel_8hpp_source.html#l04151">ipc::transport::struc::sync_io::Channel&lt; Channel_obj, Message_body, Struct_builder_config, Struct_reader_config &gt;::check_unsendable()</a>, and <a class="el" href="ipc__transport__structured_2src_2ipc_2transport_2struc_2sync__io_2channel_8hpp_source.html#l04352">ipc::transport::struc::sync_io::Channel&lt; Channel_obj, Message_body, Struct_builder_config, Struct_reader_config &gt;::send_core()</a>.</p>
<div class="dynheader">
Here is the caller graph for this function:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="classipc_1_1transport_1_1struc_1_1Msg__out_ae033461f1404be60262033bafcfaccba_icgraph.svg" width="406" height="120"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe>
</div>
</div>

</div>
</div>
<a id="a6a9b086eedafe0a5fc71695812677cdb" name="a6a9b086eedafe0a5fc71695812677cdb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6a9b086eedafe0a5fc71695812677cdb">&#9670;&nbsp;</a></span>operator=()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Message_body , typename Struct_builder_t &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classipc_1_1transport_1_1struc_1_1Msg__out.html">Msg_out</a>&lt; Message_body, Struct_builder_t &gt; &amp; <a class="el" href="classipc_1_1transport_1_1struc_1_1Msg__out.html">ipc::transport::struc::Msg_out</a>&lt; Message_body, Struct_builder_t &gt;::operator= </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classipc_1_1transport_1_1struc_1_1Msg__out.html">Msg_out</a>&lt; Message_body, Struct_builder_t &gt; &amp;&amp;&#160;</td>
          <td class="paramname"><em>src</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Move assignment: Destroy <code>*this</code> contents; make <code>*this</code> equal to <code>src</code>, while <code>src</code> becomes as-if default-cted (in that any operation except move-to or destruction results in undefined behavior subsequently). </p>
<p >no-op if <code>&amp;src == this</code>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">src</td><td>Source object. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>*this</code>. </dd></dl>

<p class="definition">Definition at line <a class="el" href="msg_8hpp_source.html#l00988">988</a> of file <a class="el" href="msg_8hpp_source.html">msg.hpp</a>.</p>

<p class="reference">Referenced by <a class="el" href="msg_8hpp_source.html#l00902">ipc::transport::struc::Msg_out&lt; Message_body, Struct_builder_t &gt;::Msg_out()</a>.</p>
<div class="dynheader">
Here is the caller graph for this function:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="classipc_1_1transport_1_1struc_1_1Msg__out_a6a9b086eedafe0a5fc71695812677cdb_icgraph.svg" width="328" height="47"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe>
</div>
</div>

</div>
</div>
<a id="a9303c71f8f459ede25ebe0c8f5492393" name="a9303c71f8f459ede25ebe0c8f5492393"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9303c71f8f459ede25ebe0c8f5492393">&#9670;&nbsp;</a></span>orphanage()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Message_body , typename Struct_builder_t &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classipc_1_1transport_1_1struc_1_1Msg__out.html">Msg_out</a>&lt; Message_body, Struct_builder_t &gt;<a class="el" href="classipc_1_1transport_1_1struc_1_1Msg__out.html#acd04d61cf19ad87610598fddbb5d8052">::Orphanage</a> <a class="el" href="classipc_1_1transport_1_1struc_1_1Msg__out.html">ipc::transport::struc::Msg_out</a>&lt; Message_body, Struct_builder_t &gt;::orphanage</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Convenience method that returns a <code>capnp::Orphan</code> factory in the same <code>capnp::MessageBuilder</code> as <a class="el" href="classipc_1_1transport_1_1struc_1_1Msg__out.html#a9894ad7ec2a46641c4b9b86664d0d465" title="The Body root capnp-generated mutator object.">body_root()</a>. </p>
<p >Therefore <code>Orphan</code>s generated via the returned <a class="el" href="classipc_1_1transport_1_1struc_1_1Msg__out.html#acd04d61cf19ad87610598fddbb5d8052" title="Short-hand for capnp orphan factory. See orphanage().">Orphanage</a> can be <code>adopt...()</code>ed by the <code>Builder</code> <code>*(<a class="el" href="classipc_1_1transport_1_1struc_1_1Msg__out.html#a9894ad7ec2a46641c4b9b86664d0d465" title="The Body root capnp-generated mutator object.">body_root()</a>)</code> and its various sub-fields' <code>Builder</code>s (at any depth).</p>
<h3>Suggested technique</h3>
<p >In general, the orphan concept is discussed briefly but usefully in the "C++ serialization" section of capnp docs (the web site). We do not attempt to get into all these topics. However consider the following pattern.</p>
<p >In general the Flow-IPC system places almost no constraints on <a class="el" href="classipc_1_1transport_1_1struc_1_1Msg__out.html#aab352abf2ced76f2bad6700d75290132" title="See struc::Channel::Msg_body.">Body</a> (the schema), but there is one: Generally there must be an anonymous capnp-<code>union</code> at the top of <a class="el" href="classipc_1_1transport_1_1struc_1_1Msg__out.html#aab352abf2ced76f2bad6700d75290132" title="See struc::Channel::Msg_body.">Body</a>, and in practice any message will eventually load the root (<a class="el" href="classipc_1_1transport_1_1struc_1_1Msg__out.html#a9894ad7ec2a46641c4b9b86664d0d465" title="The Body root capnp-generated mutator object.">body_root()</a>) with one of the <code>union</code> choices. (This is to operate within the <a class="el" href="classipc_1_1transport_1_1struc_1_1Channel.html#a160a8d49624f15a2596ee7b0244584b0" title="Registers the expectation of up to 1 notification in-message whose Msg_which equals which.">struc::Channel::expect_msg()</a> and <a class="el" href="classipc_1_1transport_1_1struc_1_1Channel.html#a3376b821b129ca3847484a178e080c67" title="Registers the expectation of 0+ notification in-messages whose Msg_which equals which.">struc::Channel::expect_msgs()</a> APIs.) The vanilla approach to building the message is top-down: <a class="el" href="classipc_1_1transport_1_1struc_1_1Msg__out.html#a9894ad7ec2a46641c4b9b86664d0d465" title="The Body root capnp-generated mutator object.">body_root()</a> is pre-initialized to be a <a class="el" href="classipc_1_1transport_1_1struc_1_1Msg__out.html#aab352abf2ced76f2bad6700d75290132" title="See struc::Channel::Msg_body.">Body</a>; then, say, if your plan is to load it with the <code>union</code> choice <code>someChoice</code>, then you'd do <code><a class="el" href="classipc_1_1transport_1_1struc_1_1Msg__out.html#a9894ad7ec2a46641c4b9b86664d0d465" title="The Body root capnp-generated mutator object.">body_root()</a>-&gt;initSomeChoice()</code>; then mutate stuff inside the <code>Builder</code> returned by that. There could be an arbitrarily complex sub-tree within that, built top-down in the same fashion.</p>
<p >Instead you may choose to build it bottom-up. For this discussion let's assume <code>struct SomeChoice</code> has a number of scalars. You would first obtain and save an <code>Orphanage</code>: <code>auto orphan_factory = M.orphanage()</code>. Next you would create an orphan, not yet connected to the root <a class="el" href="classipc_1_1transport_1_1struc_1_1Msg__out.html#a9894ad7ec2a46641c4b9b86664d0d465" title="The Body root capnp-generated mutator object.">body_root()</a>, like so: <code>auto some_choice_orphan = orphan_factory.newOrphan&lt;SomeChoice&gt;(); some_choice_builder = some_choice_orphan.get()</code>. Next you'd set the scalars within it: <code>some_choice_builder.set...(...)</code>. Lastly, when it's ready, graft it into the actual root: <code><a class="el" href="classipc_1_1transport_1_1struc_1_1Msg__out.html#a9894ad7ec2a46641c4b9b86664d0d465" title="The Body root capnp-generated mutator object.">body_root()</a>-&gt;adoptSomeChoice(some_choice_orphan)</code>.</p>
<p >Due to the simplicity of this example one might wonder why not simply build it top-down in the first place. Indeed. However, if <code>struct SomeChoice</code> is a complex tree of <code>struct</code>s within <code>List</code>s within (...), it would be reasonable to build the lowest levels of that tree by generating intermediate orphans (via <code>orphan_factory.newOrphan&lt;LowerLevelStructOrListOrWhatever&gt;()</code>), adopting them into higher-level orphans, and so on, finishing it via the top-level <code><a class="el" href="classipc_1_1transport_1_1struc_1_1Msg__out.html#a9894ad7ec2a46641c4b9b86664d0d465" title="The Body root capnp-generated mutator object.">body_root()</a>-&gt;adoptSomeChoice()</code> call.</p>
<h3>Similar technique</h3>
<p >See also the 2nd (advanced) ctor form. It allows one to do the above but takes it further by not even needing a <a class="el" href="classipc_1_1transport_1_1struc_1_1Msg__out.html" title="A structured out-message suitable to be sent via struc::Channel::send().">Msg_out</a> until the time comes to actually <a class="el" href="classipc_1_1transport_1_1struc_1_1Channel.html#ae645cb58ad9ea6374970f1f32c5da448" title="In the synchronous/non-blocking manner of Blob_sender::send_blob() or Native_handle_sender::send_nati...">struc::Channel::send()</a> the message. I.e., one would work with essentially a <a class="el" href="classCapnp__msg__builder__interface.html">Capnp_msg_builder_interface</a> directly, including invoking <code>Capnp_msg_builder_interface.getOrphanage()</code>.</p>
<dl class="section return"><dt>Returns</dt><dd>See above. </dd></dl>

<p class="definition">Definition at line <a class="el" href="msg_8hpp_source.html#l01030">1030</a> of file <a class="el" href="msg_8hpp_source.html">msg.hpp</a>.</p>

</div>
</div>
<a id="aced8ef8237617c74aaf06832d1385fed" name="aced8ef8237617c74aaf06832d1385fed"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aced8ef8237617c74aaf06832d1385fed">&#9670;&nbsp;</a></span>store_native_handle_or_null()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Message_body , typename Struct_builder_t &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classipc_1_1transport_1_1struc_1_1Msg__out.html">ipc::transport::struc::Msg_out</a>&lt; Message_body, Struct_builder_t &gt;::store_native_handle_or_null </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespaceipc_1_1transport.html#a7ee4551983d9df16ec16a3139bac50e8">Native_handle</a> &amp;&amp;&#160;</td>
          <td class="paramname"><em>native_handle_or_null</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Store the <code>Native_handle</code> (potentially <code>.null()</code>, meaning none) in this out-message; no-ops if the same <code>.m_native_handle</code> already stored; otherwise returns the previously stored native handle to the OS (similarly to dtor). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">native_handle_or_null</td><td>The <code>Native_handle</code> (<code>.null() == true</code> if none) to move into <code>*this</code>. Made <code>.null() == true</code> upon return. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="msg_8hpp_source.html#l01038">1038</a> of file <a class="el" href="msg_8hpp_source.html">msg.hpp</a>.</p>

<p class="reference">References <a class="el" href="asio__local__stream__socket_8cpp_source.html#l00416">ipc::transport::asio_local_stream_socket::release_native_peer_socket()</a>.</p>

<p class="reference">Referenced by <a class="el" href="ipc__transport__structured_2src_2ipc_2transport_2struc_2sync__io_2channel_8hpp_source.html#l04721">ipc::transport::struc::sync_io::Channel&lt; Channel_obj, Message_body, Struct_builder_config, Struct_reader_config &gt;::create_msg()</a>.</p>
<div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="classipc_1_1transport_1_1struc_1_1Msg__out_aced8ef8237617c74aaf06832d1385fed_cgraph.svg" width="350" height="71"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe>
</div>
</div>
<div class="dynheader">
Here is the caller graph for this function:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="classipc_1_1transport_1_1struc_1_1Msg__out_aced8ef8237617c74aaf06832d1385fed_icgraph.svg" width="404" height="59"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe>
</div>
</div>

</div>
</div>
<a id="a754e0f025f471105d52b3b090c27f1c0" name="a754e0f025f471105d52b3b090c27f1c0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a754e0f025f471105d52b3b090c27f1c0">&#9670;&nbsp;</a></span>to_ostream()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Message_body , typename Struct_builder_t &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classipc_1_1transport_1_1struc_1_1Msg__out.html">ipc::transport::struc::Msg_out</a>&lt; Message_body, Struct_builder_t &gt;::to_ostream </td>
          <td>(</td>
          <td class="paramtype">std::ostream *&#160;</td>
          <td class="paramname"><em>os</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Prints string representation to the given <code>ostream</code>. </p>
<p >This representation lacks newlines/indentation; includes a (potentially truncated) pretty-printed representation of <code><a class="el" href="classipc_1_1transport_1_1struc_1_1Msg__out.html#a9894ad7ec2a46641c4b9b86664d0d465" title="The Body root capnp-generated mutator object.">body_root()</a></code> contents; and includes <a class="el" href="classipc_1_1transport_1_1struc_1_1Msg__out.html#ae033461f1404be60262033bafcfaccba" title="Returns whatever was the last word according to store_native_handle_or_null().">native_handle_or_null()</a>.</p>
<p >Caution: This could be an operation expensive in processor cycles and, temporarily, RAM; and thus should be used judiciously. To help drive your decision-making: This method, internally,</p><ol type="1">
<li>uses capnp <code>kj::str(*(this-&gt;body_root))</code> to generate a <em>full</em> pretty-print of <a class="el" href="classipc_1_1transport_1_1struc_1_1Msg__out.html#a9894ad7ec2a46641c4b9b86664d0d465" title="The Body root capnp-generated mutator object.">body_root()</a> contents;</li>
<li>truncates the result of the latter, as needed for a reasonably short output, and prints the result;</li>
<li>adds <a class="el" href="classipc_1_1transport_1_1struc_1_1Msg__out.html#ae033461f1404be60262033bafcfaccba" title="Returns whatever was the last word according to store_native_handle_or_null().">native_handle_or_null()</a> and possibly a few other small information items.</li>
</ol>
<p >Because there is no reasonably-available way to stop generating the pretty-print in step 1 upon reaching a certain number of characters, the operation may take a while, if many non-default bytes have been mutated-in; and before truncation the resulting string may take significant RAM accordingly.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">os</td><td>Stream to which to write. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="msg_8hpp_source.html#l01072">1072</a> of file <a class="el" href="msg_8hpp_source.html">msg.hpp</a>.</p>

</div>
</div>
<h2 class="groupheader">Friends And Related Function Documentation</h2>
<a id="a134e737e55ae825527efd6a9e68bf37e" name="a134e737e55ae825527efd6a9e68bf37e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a134e737e55ae825527efd6a9e68bf37e">&#9670;&nbsp;</a></span>operator&lt;&lt;()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Message_body , typename Struct_builder_t &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::ostream &amp; operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>os</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classipc_1_1transport_1_1struc_1_1Msg__out.html">Msg_out</a>&lt; Message_body, Struct_builder_t &gt; &amp;&#160;</td>
          <td class="paramname"><em>val</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Prints string representation of the given <code><a class="el" href="classipc_1_1transport_1_1struc_1_1Msg__out.html" title="A structured out-message suitable to be sent via struc::Channel::send().">Msg_out</a></code> to the given <code>ostream</code>. </p>
<p >Namely it prints via <a class="el" href="classipc_1_1transport_1_1struc_1_1Msg__out.html#a754e0f025f471105d52b3b090c27f1c0" title="Prints string representation to the given ostream.">Msg_out::to_ostream()</a>`; be sure to read perf notes on that!</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">os</td><td>Stream to which to write. </td></tr>
    <tr><td class="paramname">val</td><td>Object to serialize. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>os</code>. </dd></dl>

<p class="definition">Definition at line <a class="el" href="msg_8hpp_source.html#l01108">1108</a> of file <a class="el" href="msg_8hpp_source.html">msg.hpp</a>.</p>

</div>
</div>
<h2 class="groupheader">Member Data Documentation</h2>
<a id="a90ba424b2c68cae89597356458b5c570" name="a90ba424b2c68cae89597356458b5c570"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a90ba424b2c68cae89597356458b5c570">&#9670;&nbsp;</a></span>m_body_root</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Message_body , typename Struct_builder_t &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classipc_1_1transport_1_1struc_1_1Msg__out.html#a68188b480ac3c33676b08dce72d92922">Body_builder</a> <a class="el" href="classipc_1_1transport_1_1struc_1_1Msg__out.html">ipc::transport::struc::Msg_out</a>&lt; Message_body, Struct_builder_t &gt;::m_body_root</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>See <a class="el" href="classipc_1_1transport_1_1struc_1_1Msg__out.html#a9894ad7ec2a46641c4b9b86664d0d465" title="The Body root capnp-generated mutator object.">body_root()</a>. </p>
<h3>Rationale</h3>
<p >We don't strictly need to save this; we could have <a class="el" href="classipc_1_1transport_1_1struc_1_1Msg__out.html#a9894ad7ec2a46641c4b9b86664d0d465" title="The Body root capnp-generated mutator object.">body_root()</a> return the <a class="el" href="classipc_1_1transport_1_1struc_1_1Msg__out.html#a68188b480ac3c33676b08dce72d92922" title="Short-hand for capnp-generated mutating Builder nested class of Body. See body_root().">Body_builder</a>, not a pointer to it. This would not be out of line; it is a general capnp-documented tip to act on a given <code>Builder</code> repeatedly as opposed to accessing it via an accessor each time; so we could encourage the user to do that &ndash; not our problem. (Though I (ygoldfel) am not positive that perf tip applies to the root capnp-<code>struct</code>; maybe look into it sometime for education.) It would also reduce <code>*this</code> footprint a bit and simplify/speed-up the move-ctor and move-assignment somewhat (a capnp <code>Builder</code> is light-weight but not totally tiny, consisting of a few pointers and integers). So why do this?</p>
<p >Honestly keeping it this way is firstly a historic artifact from an earlier situation where keeping a pointer made sense in a no-longer-relevant sense (explaining how here would be uninteresting). That said it's a fairly cheap little optimization that allows the repeated use of <a class="el" href="classipc_1_1transport_1_1struc_1_1Msg__out.html#a9894ad7ec2a46641c4b9b86664d0d465" title="The Body root capnp-generated mutator object.">body_root()</a> with no perf penalty, and it is nice and expressive to have a non-<code>const</code> accessor returning a pointer to <em>the</em> thing that would mutate <code>*this</code>. Similarly it's nice to have a <code>const</code> accessor returning pointer-to-<code>const</code> suitable for pretty-printing. Throw in now having to change existing call sites, and voila, this decision. </p>

<p class="definition">Definition at line <a class="el" href="msg_8hpp_source.html#l00480">480</a> of file <a class="el" href="msg_8hpp_source.html">msg.hpp</a>.</p>

</div>
</div>
<a id="aa783b92d94937ebb5d95b7ad5f2c9e37" name="aa783b92d94937ebb5d95b7ad5f2c9e37"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa783b92d94937ebb5d95b7ad5f2c9e37">&#9670;&nbsp;</a></span>m_builder</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Message_body , typename Struct_builder_t &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classipc_1_1transport_1_1struc_1_1Msg__out.html#aae507a42f29546fa13075a438d96f3f5">Builder</a> <a class="el" href="classipc_1_1transport_1_1struc_1_1Msg__out.html">ipc::transport::struc::Msg_out</a>&lt; Message_body, Struct_builder_t &gt;::m_builder</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>The guy serializing a <a class="el" href="classipc_1_1transport_1_1struc_1_1Msg__out.html#aab352abf2ced76f2bad6700d75290132" title="See struc::Channel::Msg_body.">Body</a>. Underlying serialization potentially futher mutated by user via <a class="el" href="classipc_1_1transport_1_1struc_1_1Msg__out.html#a9894ad7ec2a46641c4b9b86664d0d465" title="The Body root capnp-generated mutator object.">body_root()</a>. </p>

<p class="definition">Definition at line <a class="el" href="msg_8hpp_source.html#l00459">459</a> of file <a class="el" href="msg_8hpp_source.html">msg.hpp</a>.</p>

</div>
</div>
<a id="a31538b5675e0deb607f74d97e9205cf6" name="a31538b5675e0deb607f74d97e9205cf6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a31538b5675e0deb607f74d97e9205cf6">&#9670;&nbsp;</a></span>m_hndl_or_null</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Message_body , typename Struct_builder_t &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespaceipc_1_1transport.html#a7ee4551983d9df16ec16a3139bac50e8">Native_handle</a> <a class="el" href="classipc_1_1transport_1_1struc_1_1Msg__out.html">ipc::transport::struc::Msg_out</a>&lt; Message_body, Struct_builder_t &gt;::m_hndl_or_null</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>The <code>Native_handle</code>, if any, embedded inside this message. </p>

<p class="definition">Definition at line <a class="el" href="msg_8hpp_source.html#l00483">483</a> of file <a class="el" href="msg_8hpp_source.html">msg.hpp</a>.</p>

</div>
</div>
<hr/>The documentation for this class was generated from the following files:<ul>
<li>transport/struc/<a class="el" href="msg_8hpp_source.html">msg.hpp</a></li>
<li>transport/struc/<a class="el" href="struc__fwd_8hpp_source.html">struc_fwd.hpp</a></li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Sun Mar 10 2024 15:40:02 for Flow-IPC by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.4
</small></address>
</body>
</html>
