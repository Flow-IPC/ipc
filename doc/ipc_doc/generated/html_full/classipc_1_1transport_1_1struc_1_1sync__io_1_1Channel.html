<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.9.4"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Flow-IPC: ipc::transport::struc::sync_io::Channel&lt; Channel_obj, Message_body, Struct_builder_config, Struct_reader_config &gt; Class Template Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">Flow-IPC<span id="projectnumber">&#160;1.0</span>
   </div>
   <div id="projectbrief">Flow-IPC project: Full implementation reference.</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.4 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search",'Search','.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespaceipc.html">ipc</a></li><li class="navelem"><a class="el" href="namespaceipc_1_1transport.html">transport</a></li><li class="navelem"><a class="el" href="namespaceipc_1_1transport_1_1struc.html">struc</a></li><li class="navelem"><a class="el" href="namespaceipc_1_1transport_1_1struc_1_1sync__io.html">sync_io</a></li><li class="navelem"><a class="el" href="classipc_1_1transport_1_1struc_1_1sync__io_1_1Channel.html">Channel</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#pub-types">Public Types</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pri-types">Private Types</a> &#124;
<a href="#pri-methods">Private Member Functions</a> &#124;
<a href="#pri-attribs">Private Attributes</a> &#124;
<a href="#related">Related Functions</a> &#124;
<a href="classipc_1_1transport_1_1struc_1_1sync__io_1_1Channel-members.html">List of all members</a>  </div>
  <div class="headertitle"><div class="title">ipc::transport::struc::sync_io::Channel&lt; Channel_obj, Message_body, Struct_builder_config, Struct_reader_config &gt; Class Template Reference</div></div>
</div><!--header-->
<div class="contents">

<p><code><a class="el" href="namespaceipc_1_1transport_1_1struc_1_1sync__io.html" title="sync_io-pattern counterparts to async-I/O-pattern object types in parent namespace ipc::transport::st...">sync_io</a></code>-pattern counterpart to async-I/O-pattern <a class="el" href="classipc_1_1transport_1_1struc_1_1Channel.html" title="Owning and wrapping a pre-connected transport::Channel peer (an endpoint of an established channel ov...">transport::struc::Channel</a>.  
 <a href="classipc_1_1transport_1_1struc_1_1sync__io_1_1Channel.html#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="ipc__transport__structured_2src_2ipc_2transport_2struc_2sync__io_2channel_8hpp_source.html">channel.hpp</a>&gt;</code></p>
<div class="dynheader">
Inheritance diagram for ipc::transport::struc::sync_io::Channel&lt; Channel_obj, Message_body, Struct_builder_config, Struct_reader_config &gt;:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="classipc_1_1transport_1_1struc_1_1sync__io_1_1Channel__inherit__graph.svg" width="466" height="167"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe>
</div>
<center><span class="legend">[<a href="graph_legend.html">legend</a>]</span></center></div>
<div class="dynheader">
Collaboration diagram for ipc::transport::struc::sync_io::Channel&lt; Channel_obj, Message_body, Struct_builder_config, Struct_reader_config &gt;:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="classipc_1_1transport_1_1struc_1_1sync__io_1_1Channel__coll__graph.svg" width="984" height="1259"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe>
</div>
<center><span class="legend">[<a href="graph_legend.html">legend</a>]</span></center></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="nested-classes" name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structipc_1_1transport_1_1struc_1_1sync__io_1_1Channel_1_1Expecting__response.html">Expecting_response</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Policy for how to act upon receiving a response in-message that indicates its originating out-message is the message associated with this object in <a class="el" href="classipc_1_1transport_1_1struc_1_1sync__io_1_1Channel.html#a3d4c8da3dd620d113479f5c6a3f96c3a" title="Table mapping originating out-message to the policy for handling an in-message that indicates that ou...">Expecting_response_map</a>.  <a href="structipc_1_1transport_1_1struc_1_1sync__io_1_1Channel_1_1Expecting__response.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structipc_1_1transport_1_1struc_1_1sync__io_1_1Channel_1_1Msg__in__pipe.html">Msg_in_pipe</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Data and policy with respect to receipt of the next/currently-incomplete in-message.  <a href="structipc_1_1transport_1_1struc_1_1sync__io_1_1Channel_1_1Msg__in__pipe.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-types" name="pub-types"></a>
Public Types</h2></td></tr>
<tr class="memitem:a6dc83bd6057b7f00a19c5947d6baa7b7"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classipc_1_1transport_1_1struc_1_1sync__io_1_1Channel.html#a6dc83bd6057b7f00a19c5947d6baa7b7">Async_io_obj</a> = <a class="el" href="classipc_1_1transport_1_1struc_1_1Channel.html">transport::struc::Channel</a>&lt; Channel_obj, Message_body, Struct_builder_config, Struct_reader_config &gt;</td></tr>
<tr class="memdesc:a6dc83bd6057b7f00a19c5947d6baa7b7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Useful for generic programming, the async-I/O-pattern counterpart to <code>*this</code> type.  <a href="classipc_1_1transport_1_1struc_1_1sync__io_1_1Channel.html#a6dc83bd6057b7f00a19c5947d6baa7b7">More...</a><br /></td></tr>
<tr class="separator:a6dc83bd6057b7f00a19c5947d6baa7b7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5bb15c142ca501fe5fdfa8068d076e36"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classipc_1_1transport_1_1struc_1_1sync__io_1_1Channel.html#a5bb15c142ca501fe5fdfa8068d076e36">Sync_io_obj</a> = <a class="el" href="classipc_1_1transport_1_1Null__peer.html">Null_peer</a></td></tr>
<tr class="memdesc:a5bb15c142ca501fe5fdfa8068d076e36"><td class="mdescLeft">&#160;</td><td class="mdescRight">You may disregard.  <a href="classipc_1_1transport_1_1struc_1_1sync__io_1_1Channel.html#a5bb15c142ca501fe5fdfa8068d076e36">More...</a><br /></td></tr>
<tr class="separator:a5bb15c142ca501fe5fdfa8068d076e36"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4abac89dbd4d26c79b7915990f751a76"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classipc_1_1transport_1_1struc_1_1sync__io_1_1Channel.html#a4abac89dbd4d26c79b7915990f751a76">Owned_channel</a> = Channel_obj</td></tr>
<tr class="memdesc:a4abac89dbd4d26c79b7915990f751a76"><td class="mdescLeft">&#160;</td><td class="mdescRight">See <a class="el" href="classipc_1_1transport_1_1struc_1_1sync__io_1_1Channel.html#a6dc83bd6057b7f00a19c5947d6baa7b7" title="Useful for generic programming, the async-I/O-pattern counterpart to *this type.">Async_io_obj</a> counterpart.  <a href="classipc_1_1transport_1_1struc_1_1sync__io_1_1Channel.html#a4abac89dbd4d26c79b7915990f751a76">More...</a><br /></td></tr>
<tr class="separator:a4abac89dbd4d26c79b7915990f751a76"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8a59bbc3c6a7191b316b23661d8ba6e3"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classipc_1_1transport_1_1struc_1_1sync__io_1_1Channel.html#a8a59bbc3c6a7191b316b23661d8ba6e3">Builder_config</a> = Struct_builder_config</td></tr>
<tr class="memdesc:a8a59bbc3c6a7191b316b23661d8ba6e3"><td class="mdescLeft">&#160;</td><td class="mdescRight">See <a class="el" href="classipc_1_1transport_1_1struc_1_1sync__io_1_1Channel.html#a6dc83bd6057b7f00a19c5947d6baa7b7" title="Useful for generic programming, the async-I/O-pattern counterpart to *this type.">Async_io_obj</a> counterpart.  <a href="classipc_1_1transport_1_1struc_1_1sync__io_1_1Channel.html#a8a59bbc3c6a7191b316b23661d8ba6e3">More...</a><br /></td></tr>
<tr class="separator:a8a59bbc3c6a7191b316b23661d8ba6e3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a14a7166b2f8c117ce6ddafe943d036fa"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classipc_1_1transport_1_1struc_1_1sync__io_1_1Channel.html#a14a7166b2f8c117ce6ddafe943d036fa">Reader_config</a> = Struct_reader_config</td></tr>
<tr class="memdesc:a14a7166b2f8c117ce6ddafe943d036fa"><td class="mdescLeft">&#160;</td><td class="mdescRight">See <a class="el" href="classipc_1_1transport_1_1struc_1_1sync__io_1_1Channel.html#a6dc83bd6057b7f00a19c5947d6baa7b7" title="Useful for generic programming, the async-I/O-pattern counterpart to *this type.">Async_io_obj</a> counterpart.  <a href="classipc_1_1transport_1_1struc_1_1sync__io_1_1Channel.html#a14a7166b2f8c117ce6ddafe943d036fa">More...</a><br /></td></tr>
<tr class="separator:a14a7166b2f8c117ce6ddafe943d036fa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a34e183c252390f369f121074772c14c4"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classipc_1_1transport_1_1struc_1_1sync__io_1_1Channel.html#a34e183c252390f369f121074772c14c4">Msg_body</a> = Message_body</td></tr>
<tr class="memdesc:a34e183c252390f369f121074772c14c4"><td class="mdescLeft">&#160;</td><td class="mdescRight">See <a class="el" href="classipc_1_1transport_1_1struc_1_1sync__io_1_1Channel.html#a6dc83bd6057b7f00a19c5947d6baa7b7" title="Useful for generic programming, the async-I/O-pattern counterpart to *this type.">Async_io_obj</a> counterpart.  <a href="classipc_1_1transport_1_1struc_1_1sync__io_1_1Channel.html#a34e183c252390f369f121074772c14c4">More...</a><br /></td></tr>
<tr class="separator:a34e183c252390f369f121074772c14c4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1572a1b1cb4a72ea57f7841a5e78759b"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classipc_1_1transport_1_1struc_1_1sync__io_1_1Channel.html#a1572a1b1cb4a72ea57f7841a5e78759b">Msg_which</a> = typename Message_body::Which</td></tr>
<tr class="memdesc:a1572a1b1cb4a72ea57f7841a5e78759b"><td class="mdescLeft">&#160;</td><td class="mdescRight">See <a class="el" href="classipc_1_1transport_1_1struc_1_1sync__io_1_1Channel.html#a6dc83bd6057b7f00a19c5947d6baa7b7" title="Useful for generic programming, the async-I/O-pattern counterpart to *this type.">Async_io_obj</a> counterpart.  <a href="classipc_1_1transport_1_1struc_1_1sync__io_1_1Channel.html#a1572a1b1cb4a72ea57f7841a5e78759b">More...</a><br /></td></tr>
<tr class="separator:a1572a1b1cb4a72ea57f7841a5e78759b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa40c3ec3f45cdfea9360f7f35b9ade3c"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classipc_1_1transport_1_1struc_1_1sync__io_1_1Channel.html#aa40c3ec3f45cdfea9360f7f35b9ade3c">Msg_which_in</a> = <a class="el" href="classipc_1_1transport_1_1struc_1_1sync__io_1_1Channel.html#a1572a1b1cb4a72ea57f7841a5e78759b">Msg_which</a></td></tr>
<tr class="memdesc:aa40c3ec3f45cdfea9360f7f35b9ade3c"><td class="mdescLeft">&#160;</td><td class="mdescRight">See <a class="el" href="classipc_1_1transport_1_1struc_1_1sync__io_1_1Channel.html#a6dc83bd6057b7f00a19c5947d6baa7b7" title="Useful for generic programming, the async-I/O-pattern counterpart to *this type.">Async_io_obj</a> counterpart.  <a href="classipc_1_1transport_1_1struc_1_1sync__io_1_1Channel.html#aa40c3ec3f45cdfea9360f7f35b9ade3c">More...</a><br /></td></tr>
<tr class="separator:aa40c3ec3f45cdfea9360f7f35b9ade3c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7a731cdae5217ed9e867fb80c1fb0fd9"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classipc_1_1transport_1_1struc_1_1sync__io_1_1Channel.html#a7a731cdae5217ed9e867fb80c1fb0fd9">Msg_which_out</a> = <a class="el" href="classipc_1_1transport_1_1struc_1_1sync__io_1_1Channel.html#a1572a1b1cb4a72ea57f7841a5e78759b">Msg_which</a></td></tr>
<tr class="memdesc:a7a731cdae5217ed9e867fb80c1fb0fd9"><td class="mdescLeft">&#160;</td><td class="mdescRight">See <a class="el" href="classipc_1_1transport_1_1struc_1_1sync__io_1_1Channel.html#a6dc83bd6057b7f00a19c5947d6baa7b7" title="Useful for generic programming, the async-I/O-pattern counterpart to *this type.">Async_io_obj</a> counterpart.  <a href="classipc_1_1transport_1_1struc_1_1sync__io_1_1Channel.html#a7a731cdae5217ed9e867fb80c1fb0fd9">More...</a><br /></td></tr>
<tr class="separator:a7a731cdae5217ed9e867fb80c1fb0fd9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a83fb4462a8d4045bdb56b694bf80393c"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classipc_1_1transport_1_1struc_1_1sync__io_1_1Channel.html#a83fb4462a8d4045bdb56b694bf80393c">Msg_out</a> = <a class="el" href="classipc_1_1transport_1_1struc_1_1Msg__out.html">struc::Msg_out</a>&lt; <a class="el" href="classipc_1_1transport_1_1struc_1_1sync__io_1_1Channel.html#a34e183c252390f369f121074772c14c4">Msg_body</a>, typename Builder_config::Builder &gt;</td></tr>
<tr class="memdesc:a83fb4462a8d4045bdb56b694bf80393c"><td class="mdescLeft">&#160;</td><td class="mdescRight">See <a class="el" href="classipc_1_1transport_1_1struc_1_1sync__io_1_1Channel.html#a6dc83bd6057b7f00a19c5947d6baa7b7" title="Useful for generic programming, the async-I/O-pattern counterpart to *this type.">Async_io_obj</a> counterpart.  <a href="classipc_1_1transport_1_1struc_1_1sync__io_1_1Channel.html#a83fb4462a8d4045bdb56b694bf80393c">More...</a><br /></td></tr>
<tr class="separator:a83fb4462a8d4045bdb56b694bf80393c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac3da0ac1306b63c9e38c47b8c31e3cd2"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classipc_1_1transport_1_1struc_1_1sync__io_1_1Channel.html#ac3da0ac1306b63c9e38c47b8c31e3cd2">Msg_in</a> = <a class="el" href="classipc_1_1transport_1_1struc_1_1Msg__in.html">struc::Msg_in</a>&lt; <a class="el" href="classipc_1_1transport_1_1struc_1_1sync__io_1_1Channel.html#a34e183c252390f369f121074772c14c4">Msg_body</a>, <a class="el" href="classipc_1_1transport_1_1struc_1_1sync__io_1_1Channel.html#a14a7166b2f8c117ce6ddafe943d036fa">Reader_config</a> &gt;</td></tr>
<tr class="memdesc:ac3da0ac1306b63c9e38c47b8c31e3cd2"><td class="mdescLeft">&#160;</td><td class="mdescRight">See <a class="el" href="classipc_1_1transport_1_1struc_1_1sync__io_1_1Channel.html#a6dc83bd6057b7f00a19c5947d6baa7b7" title="Useful for generic programming, the async-I/O-pattern counterpart to *this type.">Async_io_obj</a> counterpart.  <a href="classipc_1_1transport_1_1struc_1_1sync__io_1_1Channel.html#ac3da0ac1306b63c9e38c47b8c31e3cd2">More...</a><br /></td></tr>
<tr class="separator:ac3da0ac1306b63c9e38c47b8c31e3cd2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acde2b3866547a30958035203d9d89928"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classipc_1_1transport_1_1struc_1_1sync__io_1_1Channel.html#acde2b3866547a30958035203d9d89928">Msg_in_ptr</a> = boost::shared_ptr&lt; <a class="el" href="classipc_1_1transport_1_1struc_1_1sync__io_1_1Channel.html#ac3da0ac1306b63c9e38c47b8c31e3cd2">Msg_in</a> &gt;</td></tr>
<tr class="memdesc:acde2b3866547a30958035203d9d89928"><td class="mdescLeft">&#160;</td><td class="mdescRight">See <a class="el" href="classipc_1_1transport_1_1struc_1_1sync__io_1_1Channel.html#a6dc83bd6057b7f00a19c5947d6baa7b7" title="Useful for generic programming, the async-I/O-pattern counterpart to *this type.">Async_io_obj</a> counterpart.  <a href="classipc_1_1transport_1_1struc_1_1sync__io_1_1Channel.html#acde2b3866547a30958035203d9d89928">More...</a><br /></td></tr>
<tr class="separator:acde2b3866547a30958035203d9d89928"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4ab778bce8d7e6e84788879fedc62745"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classipc_1_1transport_1_1struc_1_1sync__io_1_1Channel.html#a4ab778bce8d7e6e84788879fedc62745">Msgs_in</a> = std::vector&lt; <a class="el" href="classipc_1_1transport_1_1struc_1_1sync__io_1_1Channel.html#acde2b3866547a30958035203d9d89928">Msg_in_ptr</a> &gt;</td></tr>
<tr class="memdesc:a4ab778bce8d7e6e84788879fedc62745"><td class="mdescLeft">&#160;</td><td class="mdescRight">List of in-messages used in certain APIs like <a class="el" href="classipc_1_1transport_1_1struc_1_1sync__io_1_1Channel.html#a62f52488ba20dd6c69dfc1abadb2d69f" title="Registers the expectation (some of which may be immediately met) of 0+ notification in-messages whose...">expect_msgs()</a> to synchronously emit cached in-messages.  <a href="classipc_1_1transport_1_1struc_1_1sync__io_1_1Channel.html#a4ab778bce8d7e6e84788879fedc62745">More...</a><br /></td></tr>
<tr class="separator:a4ab778bce8d7e6e84788879fedc62745"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9b5d17887c9ad1e37081bf4ae4a70e65"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classipc_1_1transport_1_1struc_1_1sync__io_1_1Channel.html#a9b5d17887c9ad1e37081bf4ae4a70e65">msg_id_out_t</a> = <a class="el" href="classipc_1_1transport_1_1struc_1_1Channel__base.html#adcf24fa51747ed83c4b6427fbf44fecf">Channel_base::msg_id_out_t</a></td></tr>
<tr class="memdesc:a9b5d17887c9ad1e37081bf4ae4a70e65"><td class="mdescLeft">&#160;</td><td class="mdescRight">See <a class="el" href="classipc_1_1transport_1_1struc_1_1sync__io_1_1Channel.html#a6dc83bd6057b7f00a19c5947d6baa7b7" title="Useful for generic programming, the async-I/O-pattern counterpart to *this type.">Async_io_obj</a> counterpart.  <a href="classipc_1_1transport_1_1struc_1_1sync__io_1_1Channel.html#a9b5d17887c9ad1e37081bf4ae4a70e65">More...</a><br /></td></tr>
<tr class="separator:a9b5d17887c9ad1e37081bf4ae4a70e65"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pub_types_classipc_1_1transport_1_1struc_1_1Channel__base"><td colspan="2" onclick="javascript:toggleInherit('pub_types_classipc_1_1transport_1_1struc_1_1Channel__base')"><img src="closed.png" alt="-"/>&#160;Public Types inherited from <a class="el" href="classipc_1_1transport_1_1struc_1_1Channel__base.html">ipc::transport::struc::Channel_base</a></td></tr>
<tr class="memitem:adcf24fa51747ed83c4b6427fbf44fecf inherit pub_types_classipc_1_1transport_1_1struc_1_1Channel__base"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classipc_1_1transport_1_1struc_1_1Channel__base.html#adcf24fa51747ed83c4b6427fbf44fecf">msg_id_out_t</a> = <a class="el" href="namespaceipc_1_1transport_1_1struc.html#af7f35fc7588d97a838274fa25700ead9">msg_id_t</a></td></tr>
<tr class="memdesc:adcf24fa51747ed83c4b6427fbf44fecf inherit pub_types_classipc_1_1transport_1_1struc_1_1Channel__base"><td class="mdescLeft">&#160;</td><td class="mdescRight">Clarifying short-hand for outgoing-message IDs.  <a href="classipc_1_1transport_1_1struc_1_1Channel__base.html#adcf24fa51747ed83c4b6427fbf44fecf">More...</a><br /></td></tr>
<tr class="separator:adcf24fa51747ed83c4b6427fbf44fecf inherit pub_types_classipc_1_1transport_1_1struc_1_1Channel__base"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-methods" name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a9385752ed00263dec5c5080b67ce0960"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classipc_1_1transport_1_1struc_1_1sync__io_1_1Channel.html#a9385752ed00263dec5c5080b67ce0960">Channel</a> (flow::log::Logger *logger_ptr, <a class="el" href="classipc_1_1transport_1_1struc_1_1sync__io_1_1Channel.html#a4abac89dbd4d26c79b7915990f751a76">Owned_channel</a> &amp;&amp;channel, const <a class="el" href="classipc_1_1transport_1_1struc_1_1sync__io_1_1Channel.html#a8a59bbc3c6a7191b316b23661d8ba6e3">Builder_config</a> &amp;<a class="el" href="classipc_1_1transport_1_1struc_1_1sync__io_1_1Channel.html#a48a8fd167c1fe6ae95d8fc80b6a6e67f">struct_builder_config</a>, const typename Builder_config::Builder::Session &amp;<a class="el" href="classipc_1_1transport_1_1struc_1_1sync__io_1_1Channel.html#a43fa0b77781376edd13b742b832572e1">struct_lender_session</a>, const <a class="el" href="classipc_1_1transport_1_1struc_1_1sync__io_1_1Channel.html#a14a7166b2f8c117ce6ddafe943d036fa">Reader_config</a> &amp;<a class="el" href="classipc_1_1transport_1_1struc_1_1sync__io_1_1Channel.html#a7efbfbcce0d4d426b7df9b6d6fd1e373">struct_reader_config</a>, const <a class="el" href="namespaceipc_1_1transport_1_1struc.html#a6751c05fb6582a34c7c47ac470c4a48b">Session_token</a> &amp;session_token_non_nil)</td></tr>
<tr class="memdesc:a9385752ed00263dec5c5080b67ce0960"><td class="mdescLeft">&#160;</td><td class="mdescRight">Non-tag, no-log-in ctor form: Creates structured channel peer with no log-in phase (log-in phase must have occurred in a preceding <a class="el" href="classipc_1_1transport_1_1struc_1_1Channel.html" title="Owning and wrapping a pre-connected transport::Channel peer (an endpoint of an established channel ov...">struc::Channel</a> called <em>session master channel</em>), the session token already known and passed-in to this ctor.  <a href="classipc_1_1transport_1_1struc_1_1sync__io_1_1Channel.html#a9385752ed00263dec5c5080b67ce0960">More...</a><br /></td></tr>
<tr class="separator:a9385752ed00263dec5c5080b67ce0960"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5b863cba6eec77f20236d1e8c8d006a3"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classipc_1_1transport_1_1struc_1_1sync__io_1_1Channel.html#a5b863cba6eec77f20236d1e8c8d006a3">Channel</a> (flow::log::Logger *logger_ptr, <a class="el" href="classipc_1_1transport_1_1struc_1_1sync__io_1_1Channel.html#a4abac89dbd4d26c79b7915990f751a76">Owned_channel</a> &amp;&amp;channel, const <a class="el" href="classipc_1_1transport_1_1struc_1_1sync__io_1_1Channel.html#a8a59bbc3c6a7191b316b23661d8ba6e3">Builder_config</a> &amp;<a class="el" href="classipc_1_1transport_1_1struc_1_1sync__io_1_1Channel.html#a48a8fd167c1fe6ae95d8fc80b6a6e67f">struct_builder_config</a>, const typename Builder_config::Builder::Session &amp;<a class="el" href="classipc_1_1transport_1_1struc_1_1sync__io_1_1Channel.html#a43fa0b77781376edd13b742b832572e1">struct_lender_session</a>, const <a class="el" href="classipc_1_1transport_1_1struc_1_1sync__io_1_1Channel.html#a14a7166b2f8c117ce6ddafe943d036fa">Reader_config</a> &amp;<a class="el" href="classipc_1_1transport_1_1struc_1_1sync__io_1_1Channel.html#a7efbfbcce0d4d426b7df9b6d6fd1e373">struct_reader_config</a>, bool is_server)</td></tr>
<tr class="memdesc:a5b863cba6eec77f20236d1e8c8d006a3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Non-tag, with-log-in ctor form: Creates structured channel peer (endpoint of the <em>session master channel</em>) with a log-in phase, this peer being the <em>server</em> or <em>client</em> depending on the arg <code>is_server</code>.  <a href="classipc_1_1transport_1_1struc_1_1sync__io_1_1Channel.html#a5b863cba6eec77f20236d1e8c8d006a3">More...</a><br /></td></tr>
<tr class="separator:a5b863cba6eec77f20236d1e8c8d006a3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a81c366280bf0f3cd711eba0a9f81698f"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classipc_1_1transport_1_1struc_1_1sync__io_1_1Channel.html#a81c366280bf0f3cd711eba0a9f81698f">Channel</a> (flow::log::Logger *logger_ptr, <a class="el" href="classipc_1_1transport_1_1struc_1_1sync__io_1_1Channel.html#a4abac89dbd4d26c79b7915990f751a76">Owned_channel</a> &amp;&amp;channel, <a class="el" href="structipc_1_1transport_1_1struc_1_1Channel__base_1_1Serialize__via__heap.html">Serialize_via_heap</a> tag, const <a class="el" href="namespaceipc_1_1transport_1_1struc.html#a6751c05fb6582a34c7c47ac470c4a48b">Session_token</a> &amp;session_token_non_nil)</td></tr>
<tr class="memdesc:a81c366280bf0f3cd711eba0a9f81698f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Tag version of non-tag, no-log-in ctor: Serialize_via_heap (bidirectional heap-based, non-zero-copy message serialization).  <a href="classipc_1_1transport_1_1struc_1_1sync__io_1_1Channel.html#a81c366280bf0f3cd711eba0a9f81698f">More...</a><br /></td></tr>
<tr class="separator:a81c366280bf0f3cd711eba0a9f81698f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeb834160e2f34931c50291485d2d7d04"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classipc_1_1transport_1_1struc_1_1sync__io_1_1Channel.html#aeb834160e2f34931c50291485d2d7d04">Channel</a> (flow::log::Logger *logger_ptr, <a class="el" href="classipc_1_1transport_1_1struc_1_1sync__io_1_1Channel.html#a4abac89dbd4d26c79b7915990f751a76">Owned_channel</a> &amp;&amp;channel, <a class="el" href="structipc_1_1transport_1_1struc_1_1Channel__base_1_1Serialize__via__heap.html">Serialize_via_heap</a> tag, bool is_server)</td></tr>
<tr class="memdesc:aeb834160e2f34931c50291485d2d7d04"><td class="mdescLeft">&#160;</td><td class="mdescRight">Tag version of non-tag, with-log-in ctor: Serialize_via_heap (bidirectional heap-based, non-zero-copy message serialization).  <a href="classipc_1_1transport_1_1struc_1_1sync__io_1_1Channel.html#aeb834160e2f34931c50291485d2d7d04">More...</a><br /></td></tr>
<tr class="separator:aeb834160e2f34931c50291485d2d7d04"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a37296f3ac6713bd36d0c7b13d5f78fb7"><td class="memTemplParams" colspan="2">template&lt;typename Session &gt; </td></tr>
<tr class="memitem:a37296f3ac6713bd36d0c7b13d5f78fb7"><td class="memTemplItemLeft" align="right" valign="top">&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classipc_1_1transport_1_1struc_1_1sync__io_1_1Channel.html#a37296f3ac6713bd36d0c7b13d5f78fb7">Channel</a> (flow::log::Logger *logger_ptr, <a class="el" href="classipc_1_1transport_1_1struc_1_1sync__io_1_1Channel.html#a4abac89dbd4d26c79b7915990f751a76">Owned_channel</a> &amp;&amp;channel, <a class="el" href="structipc_1_1transport_1_1struc_1_1Channel__base_1_1Serialize__via__session__shm.html">Serialize_via_session_shm</a> tag, Session *session, const <a class="el" href="namespaceipc_1_1transport_1_1struc.html#a6751c05fb6582a34c7c47ac470c4a48b">Session_token</a> &amp;session_token_explicit=<a class="el" href="namespaceipc_1_1transport_1_1struc.html#ad556d20a2aa2d52b83c7afb73951d47d">NULL_SESSION_TOKEN</a>)</td></tr>
<tr class="memdesc:a37296f3ac6713bd36d0c7b13d5f78fb7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Tag version of non-tag, no-log-in ctor: Serialize_via_session_shm (bidirectional SHM-based provider, zero-copy message serialization, per-session-scope arena).  <a href="classipc_1_1transport_1_1struc_1_1sync__io_1_1Channel.html#a37296f3ac6713bd36d0c7b13d5f78fb7">More...</a><br /></td></tr>
<tr class="separator:a37296f3ac6713bd36d0c7b13d5f78fb7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2ec1232d7b9c59526f7d1a3c62483269"><td class="memTemplParams" colspan="2">template&lt;typename Session &gt; </td></tr>
<tr class="memitem:a2ec1232d7b9c59526f7d1a3c62483269"><td class="memTemplItemLeft" align="right" valign="top">&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classipc_1_1transport_1_1struc_1_1sync__io_1_1Channel.html#a2ec1232d7b9c59526f7d1a3c62483269">Channel</a> (flow::log::Logger *logger_ptr, <a class="el" href="classipc_1_1transport_1_1struc_1_1sync__io_1_1Channel.html#a4abac89dbd4d26c79b7915990f751a76">Owned_channel</a> &amp;&amp;channel, <a class="el" href="structipc_1_1transport_1_1struc_1_1Channel__base_1_1Serialize__via__session__shm.html">Serialize_via_session_shm</a> tag, Session *session, bool is_server)</td></tr>
<tr class="memdesc:a2ec1232d7b9c59526f7d1a3c62483269"><td class="mdescLeft">&#160;</td><td class="mdescRight">Tag version of non-tag, with-log-in ctor: Serialize_via_session_shm (bidirectional SHM-based provider, zero-copy message serialization, per-session-scope arena).  <a href="classipc_1_1transport_1_1struc_1_1sync__io_1_1Channel.html#a2ec1232d7b9c59526f7d1a3c62483269">More...</a><br /></td></tr>
<tr class="separator:a2ec1232d7b9c59526f7d1a3c62483269"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a454d0ced89cda0b092d4f86897400e1c"><td class="memTemplParams" colspan="2">template&lt;typename Session &gt; </td></tr>
<tr class="memitem:a454d0ced89cda0b092d4f86897400e1c"><td class="memTemplItemLeft" align="right" valign="top">&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classipc_1_1transport_1_1struc_1_1sync__io_1_1Channel.html#a454d0ced89cda0b092d4f86897400e1c">Channel</a> (flow::log::Logger *logger_ptr, <a class="el" href="classipc_1_1transport_1_1struc_1_1sync__io_1_1Channel.html#a4abac89dbd4d26c79b7915990f751a76">Owned_channel</a> &amp;&amp;channel, <a class="el" href="structipc_1_1transport_1_1struc_1_1Channel__base_1_1Serialize__via__app__shm.html">Serialize_via_app_shm</a> tag, Session *session, const <a class="el" href="namespaceipc_1_1transport_1_1struc.html#a6751c05fb6582a34c7c47ac470c4a48b">Session_token</a> &amp;session_token_explicit=<a class="el" href="namespaceipc_1_1transport_1_1struc.html#ad556d20a2aa2d52b83c7afb73951d47d">NULL_SESSION_TOKEN</a>)</td></tr>
<tr class="memdesc:a454d0ced89cda0b092d4f86897400e1c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Tag version of non-tag, no-log-in ctor: Serialize_via_app_shm (bidirectional SHM-based provider, zero-copy message serialization, per-app-scope arena).  <a href="classipc_1_1transport_1_1struc_1_1sync__io_1_1Channel.html#a454d0ced89cda0b092d4f86897400e1c">More...</a><br /></td></tr>
<tr class="separator:a454d0ced89cda0b092d4f86897400e1c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac056b37680ded4b3c26dd4c6941a72c6"><td class="memTemplParams" colspan="2">template&lt;typename Session &gt; </td></tr>
<tr class="memitem:ac056b37680ded4b3c26dd4c6941a72c6"><td class="memTemplItemLeft" align="right" valign="top">&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classipc_1_1transport_1_1struc_1_1sync__io_1_1Channel.html#ac056b37680ded4b3c26dd4c6941a72c6">Channel</a> (flow::log::Logger *logger_ptr, <a class="el" href="classipc_1_1transport_1_1struc_1_1sync__io_1_1Channel.html#a4abac89dbd4d26c79b7915990f751a76">Owned_channel</a> &amp;&amp;channel, <a class="el" href="structipc_1_1transport_1_1struc_1_1Channel__base_1_1Serialize__via__app__shm.html">Serialize_via_app_shm</a> tag, Session *session, bool is_server)</td></tr>
<tr class="memdesc:ac056b37680ded4b3c26dd4c6941a72c6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Tag version of non-tag, no-log-in ctor: Serialize_via_app_shm (bidirectional SHM-based provider, zero-copy message serialization, per-app-scope arena).  <a href="classipc_1_1transport_1_1struc_1_1sync__io_1_1Channel.html#ac056b37680ded4b3c26dd4c6941a72c6">More...</a><br /></td></tr>
<tr class="separator:ac056b37680ded4b3c26dd4c6941a72c6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aac7386bca503f1457d93c65e1bfdf71f"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classipc_1_1transport_1_1struc_1_1sync__io_1_1Channel.html#aac7386bca503f1457d93c65e1bfdf71f">~Channel</a> ()</td></tr>
<tr class="memdesc:aac7386bca503f1457d93c65e1bfdf71f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Invokes the destructor on the <a class="el" href="classipc_1_1transport_1_1struc_1_1sync__io_1_1Channel.html#a4abac89dbd4d26c79b7915990f751a76" title="See Async_io_obj counterpart.">Owned_channel</a>.  <a href="classipc_1_1transport_1_1struc_1_1sync__io_1_1Channel.html#aac7386bca503f1457d93c65e1bfdf71f">More...</a><br /></td></tr>
<tr class="separator:aac7386bca503f1457d93c65e1bfdf71f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a543aa806ec21b8550f9f440e59767d52"><td class="memTemplParams" colspan="2">template&lt;typename Create_ev_wait_hndl_func &gt; </td></tr>
<tr class="memitem:a543aa806ec21b8550f9f440e59767d52"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classipc_1_1transport_1_1struc_1_1sync__io_1_1Channel.html#a543aa806ec21b8550f9f440e59767d52">replace_event_wait_handles</a> (const Create_ev_wait_hndl_func &amp;create_ev_wait_hndl_func)</td></tr>
<tr class="memdesc:a543aa806ec21b8550f9f440e59767d52"><td class="mdescLeft">&#160;</td><td class="mdescRight">Analogous to <a class="el" href="classipc_1_1transport_1_1sync__io_1_1Native__handle__sender.html#abe6227dfa077571d6eed2707532e4360" title="To be (optionally) invoked before any start_*_ops(), supplies a factory for the util::sync_io::Asio_w...">transport::sync_io::Native_handle_sender::replace_event_wait_handles()</a>.  <a href="classipc_1_1transport_1_1struc_1_1sync__io_1_1Channel.html#a543aa806ec21b8550f9f440e59767d52">More...</a><br /></td></tr>
<tr class="separator:a543aa806ec21b8550f9f440e59767d52"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6e4f8c4207fcf678b4cfc785707d3dce"><td class="memTemplParams" colspan="2">template&lt;typename Event_wait_func_t &gt; </td></tr>
<tr class="memitem:a6e4f8c4207fcf678b4cfc785707d3dce"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classipc_1_1transport_1_1struc_1_1sync__io_1_1Channel.html#a6e4f8c4207fcf678b4cfc785707d3dce">start_ops</a> (Event_wait_func_t &amp;&amp;ev_wait_func)</td></tr>
<tr class="memdesc:a6e4f8c4207fcf678b4cfc785707d3dce"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets up the <code><a class="el" href="namespaceipc_1_1transport_1_1struc_1_1sync__io.html" title="sync_io-pattern counterparts to async-I/O-pattern object types in parent namespace ipc::transport::st...">sync_io</a></code>-pattern interaction between <code>*this</code> and the user's event loop; required before async_accept() will work (as opposed to no-op/return <code>false</code>).  <a href="classipc_1_1transport_1_1struc_1_1sync__io_1_1Channel.html#a6e4f8c4207fcf678b4cfc785707d3dce">More...</a><br /></td></tr>
<tr class="separator:a6e4f8c4207fcf678b4cfc785707d3dce"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0c00bab2dad604dde176c4190553915c"><td class="memTemplParams" colspan="2">template&lt;typename Task_err &gt; </td></tr>
<tr class="memitem:a0c00bab2dad604dde176c4190553915c"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classipc_1_1transport_1_1struc_1_1sync__io_1_1Channel.html#a0c00bab2dad604dde176c4190553915c">start_and_poll</a> (Task_err &amp;&amp;on_err_func)</td></tr>
<tr class="memdesc:a0c00bab2dad604dde176c4190553915c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Permanently memorizes the incoming-direction on-error handler, thus authorizing the emission of any in-messages (and/or an error) to handlers registered via this call, <code>expect_*()</code>, <a class="el" href="classipc_1_1transport_1_1struc_1_1sync__io_1_1Channel.html#a26dc83067e005be38567199cbedd7f19" title="See Async_io_obj counterpart; though naturally on_rsp_func() is invoked in the sync_io-pattern fashio...">async_request()</a>, <code>set_*unexpected_response_handler()</code>; and <em>synchronously</em> executes any immediately relevant such handlers due to pending in-traffic.  <a href="classipc_1_1transport_1_1struc_1_1sync__io_1_1Channel.html#a0c00bab2dad604dde176c4190553915c">More...</a><br /></td></tr>
<tr class="separator:a0c00bab2dad604dde176c4190553915c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a48a8fd167c1fe6ae95d8fc80b6a6e67f"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classipc_1_1transport_1_1struc_1_1sync__io_1_1Channel.html#a8a59bbc3c6a7191b316b23661d8ba6e3">Builder_config</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classipc_1_1transport_1_1struc_1_1sync__io_1_1Channel.html#a48a8fd167c1fe6ae95d8fc80b6a6e67f">struct_builder_config</a> () const</td></tr>
<tr class="memdesc:a48a8fd167c1fe6ae95d8fc80b6a6e67f"><td class="mdescLeft">&#160;</td><td class="mdescRight">See <a class="el" href="classipc_1_1transport_1_1struc_1_1sync__io_1_1Channel.html#a6dc83bd6057b7f00a19c5947d6baa7b7" title="Useful for generic programming, the async-I/O-pattern counterpart to *this type.">Async_io_obj</a> counterpart.  <a href="classipc_1_1transport_1_1struc_1_1sync__io_1_1Channel.html#a48a8fd167c1fe6ae95d8fc80b6a6e67f">More...</a><br /></td></tr>
<tr class="separator:a48a8fd167c1fe6ae95d8fc80b6a6e67f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a43fa0b77781376edd13b742b832572e1"><td class="memItemLeft" align="right" valign="top">const Builder_config::Builder::Session &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classipc_1_1transport_1_1struc_1_1sync__io_1_1Channel.html#a43fa0b77781376edd13b742b832572e1">struct_lender_session</a> () const</td></tr>
<tr class="memdesc:a43fa0b77781376edd13b742b832572e1"><td class="mdescLeft">&#160;</td><td class="mdescRight">See <a class="el" href="classipc_1_1transport_1_1struc_1_1sync__io_1_1Channel.html#a6dc83bd6057b7f00a19c5947d6baa7b7" title="Useful for generic programming, the async-I/O-pattern counterpart to *this type.">Async_io_obj</a> counterpart.  <a href="classipc_1_1transport_1_1struc_1_1sync__io_1_1Channel.html#a43fa0b77781376edd13b742b832572e1">More...</a><br /></td></tr>
<tr class="separator:a43fa0b77781376edd13b742b832572e1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7efbfbcce0d4d426b7df9b6d6fd1e373"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classipc_1_1transport_1_1struc_1_1sync__io_1_1Channel.html#a14a7166b2f8c117ce6ddafe943d036fa">Reader_config</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classipc_1_1transport_1_1struc_1_1sync__io_1_1Channel.html#a7efbfbcce0d4d426b7df9b6d6fd1e373">struct_reader_config</a> () const</td></tr>
<tr class="memdesc:a7efbfbcce0d4d426b7df9b6d6fd1e373"><td class="mdescLeft">&#160;</td><td class="mdescRight">See <a class="el" href="classipc_1_1transport_1_1struc_1_1sync__io_1_1Channel.html#a6dc83bd6057b7f00a19c5947d6baa7b7" title="Useful for generic programming, the async-I/O-pattern counterpart to *this type.">Async_io_obj</a> counterpart.  <a href="classipc_1_1transport_1_1struc_1_1sync__io_1_1Channel.html#a7efbfbcce0d4d426b7df9b6d6fd1e373">More...</a><br /></td></tr>
<tr class="separator:a7efbfbcce0d4d426b7df9b6d6fd1e373"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a759e1993bc61abb41380219b254ca410"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classipc_1_1transport_1_1struc_1_1sync__io_1_1Channel.html#a4abac89dbd4d26c79b7915990f751a76">Owned_channel</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classipc_1_1transport_1_1struc_1_1sync__io_1_1Channel.html#a759e1993bc61abb41380219b254ca410">owned_channel</a> () const</td></tr>
<tr class="memdesc:a759e1993bc61abb41380219b254ca410"><td class="mdescLeft">&#160;</td><td class="mdescRight">See <a class="el" href="classipc_1_1transport_1_1struc_1_1sync__io_1_1Channel.html#a6dc83bd6057b7f00a19c5947d6baa7b7" title="Useful for generic programming, the async-I/O-pattern counterpart to *this type.">Async_io_obj</a> counterpart.  <a href="classipc_1_1transport_1_1struc_1_1sync__io_1_1Channel.html#a759e1993bc61abb41380219b254ca410">More...</a><br /></td></tr>
<tr class="separator:a759e1993bc61abb41380219b254ca410"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9d97a5900bd517596b763db2d6b27b45"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classipc_1_1transport_1_1struc_1_1sync__io_1_1Channel.html#a4abac89dbd4d26c79b7915990f751a76">Owned_channel</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classipc_1_1transport_1_1struc_1_1sync__io_1_1Channel.html#a9d97a5900bd517596b763db2d6b27b45">owned_channel_mutable</a> ()</td></tr>
<tr class="memdesc:a9d97a5900bd517596b763db2d6b27b45"><td class="mdescLeft">&#160;</td><td class="mdescRight">See <a class="el" href="classipc_1_1transport_1_1struc_1_1sync__io_1_1Channel.html#a6dc83bd6057b7f00a19c5947d6baa7b7" title="Useful for generic programming, the async-I/O-pattern counterpart to *this type.">Async_io_obj</a> counterpart.  <a href="classipc_1_1transport_1_1struc_1_1sync__io_1_1Channel.html#a9d97a5900bd517596b763db2d6b27b45">More...</a><br /></td></tr>
<tr class="separator:a9d97a5900bd517596b763db2d6b27b45"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a021bb07a76c54837619c7a91dbd5de03"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="namespaceipc_1_1transport_1_1struc.html#a6751c05fb6582a34c7c47ac470c4a48b">Session_token</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classipc_1_1transport_1_1struc_1_1sync__io_1_1Channel.html#a021bb07a76c54837619c7a91dbd5de03">session_token</a> () const</td></tr>
<tr class="memdesc:a021bb07a76c54837619c7a91dbd5de03"><td class="mdescLeft">&#160;</td><td class="mdescRight">See <a class="el" href="classipc_1_1transport_1_1struc_1_1sync__io_1_1Channel.html#a6dc83bd6057b7f00a19c5947d6baa7b7" title="Useful for generic programming, the async-I/O-pattern counterpart to *this type.">Async_io_obj</a> counterpart.  <a href="classipc_1_1transport_1_1struc_1_1sync__io_1_1Channel.html#a021bb07a76c54837619c7a91dbd5de03">More...</a><br /></td></tr>
<tr class="separator:a021bb07a76c54837619c7a91dbd5de03"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a426ecae27b4ea5cf7e666e56bad6afe5"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classipc_1_1transport_1_1struc_1_1sync__io_1_1Channel.html#a83fb4462a8d4045bdb56b694bf80393c">Msg_out</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classipc_1_1transport_1_1struc_1_1sync__io_1_1Channel.html#a426ecae27b4ea5cf7e666e56bad6afe5">create_msg</a> (<a class="el" href="namespaceipc_1_1transport.html#a7ee4551983d9df16ec16a3139bac50e8">Native_handle</a> &amp;&amp;hndl_or_null=<a class="el" href="namespaceipc_1_1transport.html#a7ee4551983d9df16ec16a3139bac50e8">Native_handle</a>()) const</td></tr>
<tr class="memdesc:a426ecae27b4ea5cf7e666e56bad6afe5"><td class="mdescLeft">&#160;</td><td class="mdescRight">See <a class="el" href="classipc_1_1transport_1_1struc_1_1sync__io_1_1Channel.html#a6dc83bd6057b7f00a19c5947d6baa7b7" title="Useful for generic programming, the async-I/O-pattern counterpart to *this type.">Async_io_obj</a> counterpart.  <a href="classipc_1_1transport_1_1struc_1_1sync__io_1_1Channel.html#a426ecae27b4ea5cf7e666e56bad6afe5">More...</a><br /></td></tr>
<tr class="separator:a426ecae27b4ea5cf7e666e56bad6afe5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5fc489b9abefe5ab676f6991d6d03f0d"><td class="memTemplParams" colspan="2">template&lt;typename On_msg_handler &gt; </td></tr>
<tr class="memitem:a5fc489b9abefe5ab676f6991d6d03f0d"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classipc_1_1transport_1_1struc_1_1sync__io_1_1Channel.html#a5fc489b9abefe5ab676f6991d6d03f0d">expect_msg</a> (<a class="el" href="classipc_1_1transport_1_1struc_1_1sync__io_1_1Channel.html#aa40c3ec3f45cdfea9360f7f35b9ade3c">Msg_which_in</a> which, <a class="el" href="classipc_1_1transport_1_1struc_1_1sync__io_1_1Channel.html#acde2b3866547a30958035203d9d89928">Msg_in_ptr</a> *qd_msg, On_msg_handler &amp;&amp;on_msg_func)</td></tr>
<tr class="memdesc:a5fc489b9abefe5ab676f6991d6d03f0d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Registers the expectation (which may be immediately met) of up to 1 <em>notification</em> in-message whose <a class="el" href="classipc_1_1transport_1_1struc_1_1sync__io_1_1Channel.html#a1572a1b1cb4a72ea57f7841a5e78759b" title="See Async_io_obj counterpart.">Msg_which</a> equals <code>which</code>.  <a href="classipc_1_1transport_1_1struc_1_1sync__io_1_1Channel.html#a5fc489b9abefe5ab676f6991d6d03f0d">More...</a><br /></td></tr>
<tr class="separator:a5fc489b9abefe5ab676f6991d6d03f0d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a996e06f75024e10987eb9cf62e096eec"><td class="memTemplParams" colspan="2">template&lt;typename On_msg_handler &gt; </td></tr>
<tr class="memitem:a996e06f75024e10987eb9cf62e096eec"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classipc_1_1transport_1_1struc_1_1sync__io_1_1Channel.html#a996e06f75024e10987eb9cf62e096eec">expect_log_in_request</a> (<a class="el" href="classipc_1_1transport_1_1struc_1_1sync__io_1_1Channel.html#aa40c3ec3f45cdfea9360f7f35b9ade3c">Msg_which_in</a> which, <a class="el" href="classipc_1_1transport_1_1struc_1_1sync__io_1_1Channel.html#acde2b3866547a30958035203d9d89928">Msg_in_ptr</a> *qd_msg, On_msg_handler &amp;&amp;on_log_in_req_func)</td></tr>
<tr class="memdesc:a996e06f75024e10987eb9cf62e096eec"><td class="mdescLeft">&#160;</td><td class="mdescRight">In log-in phase as server only: Registers the expectation (which may be immediately met) of up to 1 <em>log-in request</em> in-message whose <a class="el" href="classipc_1_1transport_1_1struc_1_1sync__io_1_1Channel.html#a1572a1b1cb4a72ea57f7841a5e78759b" title="See Async_io_obj counterpart.">Msg_which</a> equals <code>which</code>.  <a href="classipc_1_1transport_1_1struc_1_1sync__io_1_1Channel.html#a996e06f75024e10987eb9cf62e096eec">More...</a><br /></td></tr>
<tr class="separator:a996e06f75024e10987eb9cf62e096eec"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a62f52488ba20dd6c69dfc1abadb2d69f"><td class="memTemplParams" colspan="2">template&lt;typename On_msg_handler &gt; </td></tr>
<tr class="memitem:a62f52488ba20dd6c69dfc1abadb2d69f"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classipc_1_1transport_1_1struc_1_1sync__io_1_1Channel.html#a62f52488ba20dd6c69dfc1abadb2d69f">expect_msgs</a> (<a class="el" href="classipc_1_1transport_1_1struc_1_1sync__io_1_1Channel.html#aa40c3ec3f45cdfea9360f7f35b9ade3c">Msg_which_in</a> which, <a class="el" href="classipc_1_1transport_1_1struc_1_1sync__io_1_1Channel.html#a4ab778bce8d7e6e84788879fedc62745">Msgs_in</a> *qd_msgs, On_msg_handler &amp;&amp;on_msg_func)</td></tr>
<tr class="memdesc:a62f52488ba20dd6c69dfc1abadb2d69f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Registers the expectation (some of which may be immediately met) of 0+ <em>notification</em> in-messages whose <a class="el" href="classipc_1_1transport_1_1struc_1_1sync__io_1_1Channel.html#a1572a1b1cb4a72ea57f7841a5e78759b" title="See Async_io_obj counterpart.">Msg_which</a> equals <code>which</code>.  <a href="classipc_1_1transport_1_1struc_1_1sync__io_1_1Channel.html#a62f52488ba20dd6c69dfc1abadb2d69f">More...</a><br /></td></tr>
<tr class="separator:a62f52488ba20dd6c69dfc1abadb2d69f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac8ba5f1a26a9f3e881b4871b0f6aa990"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classipc_1_1transport_1_1struc_1_1sync__io_1_1Channel.html#ac8ba5f1a26a9f3e881b4871b0f6aa990">undo_expect_msgs</a> (<a class="el" href="classipc_1_1transport_1_1struc_1_1sync__io_1_1Channel.html#aa40c3ec3f45cdfea9360f7f35b9ade3c">Msg_which_in</a> which)</td></tr>
<tr class="memdesc:ac8ba5f1a26a9f3e881b4871b0f6aa990"><td class="mdescLeft">&#160;</td><td class="mdescRight">See <a class="el" href="classipc_1_1transport_1_1struc_1_1sync__io_1_1Channel.html#a6dc83bd6057b7f00a19c5947d6baa7b7" title="Useful for generic programming, the async-I/O-pattern counterpart to *this type.">Async_io_obj</a> counterpart.  <a href="classipc_1_1transport_1_1struc_1_1sync__io_1_1Channel.html#ac8ba5f1a26a9f3e881b4871b0f6aa990">More...</a><br /></td></tr>
<tr class="separator:ac8ba5f1a26a9f3e881b4871b0f6aa990"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0dc388e18b0fc0fa2d8ad0a6953fb039"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classipc_1_1transport_1_1struc_1_1sync__io_1_1Channel.html#a0dc388e18b0fc0fa2d8ad0a6953fb039">send</a> (const <a class="el" href="classipc_1_1transport_1_1struc_1_1sync__io_1_1Channel.html#a83fb4462a8d4045bdb56b694bf80393c">Msg_out</a> &amp;msg, const <a class="el" href="classipc_1_1transport_1_1struc_1_1sync__io_1_1Channel.html#ac3da0ac1306b63c9e38c47b8c31e3cd2">Msg_in</a> *originating_msg_or_null=0, <a class="el" href="namespaceipc.html#aa3192e586cc45d3e7c22463bf2760f89">Error_code</a> *err_code=0)</td></tr>
<tr class="memdesc:a0dc388e18b0fc0fa2d8ad0a6953fb039"><td class="mdescLeft">&#160;</td><td class="mdescRight">See <a class="el" href="classipc_1_1transport_1_1struc_1_1sync__io_1_1Channel.html#a6dc83bd6057b7f00a19c5947d6baa7b7" title="Useful for generic programming, the async-I/O-pattern counterpart to *this type.">Async_io_obj</a> counterpart.  <a href="classipc_1_1transport_1_1struc_1_1sync__io_1_1Channel.html#a0dc388e18b0fc0fa2d8ad0a6953fb039">More...</a><br /></td></tr>
<tr class="separator:a0dc388e18b0fc0fa2d8ad0a6953fb039"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a26dc83067e005be38567199cbedd7f19"><td class="memTemplParams" colspan="2">template&lt;typename On_msg_handler &gt; </td></tr>
<tr class="memitem:a26dc83067e005be38567199cbedd7f19"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classipc_1_1transport_1_1struc_1_1sync__io_1_1Channel.html#a26dc83067e005be38567199cbedd7f19">async_request</a> (const <a class="el" href="classipc_1_1transport_1_1struc_1_1sync__io_1_1Channel.html#a83fb4462a8d4045bdb56b694bf80393c">Msg_out</a> &amp;msg, const <a class="el" href="classipc_1_1transport_1_1struc_1_1sync__io_1_1Channel.html#ac3da0ac1306b63c9e38c47b8c31e3cd2">Msg_in</a> *originating_msg_or_null, <a class="el" href="classipc_1_1transport_1_1struc_1_1Channel__base.html#adcf24fa51747ed83c4b6427fbf44fecf">msg_id_out_t</a> *id_unless_one_off, On_msg_handler &amp;&amp;on_rsp_func, <a class="el" href="namespaceipc.html#aa3192e586cc45d3e7c22463bf2760f89">Error_code</a> *err_code=0)</td></tr>
<tr class="memdesc:a26dc83067e005be38567199cbedd7f19"><td class="mdescLeft">&#160;</td><td class="mdescRight">See <a class="el" href="classipc_1_1transport_1_1struc_1_1sync__io_1_1Channel.html#a6dc83bd6057b7f00a19c5947d6baa7b7" title="Useful for generic programming, the async-I/O-pattern counterpart to *this type.">Async_io_obj</a> counterpart; though naturally <code>on_rsp_func()</code> is invoked in the <code><a class="el" href="namespaceipc_1_1transport_1_1struc_1_1sync__io.html" title="sync_io-pattern counterparts to async-I/O-pattern object types in parent namespace ipc::transport::st...">sync_io</a></code>-pattern fashion.  <a href="classipc_1_1transport_1_1struc_1_1sync__io_1_1Channel.html#a26dc83067e005be38567199cbedd7f19">More...</a><br /></td></tr>
<tr class="separator:a26dc83067e005be38567199cbedd7f19"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5aae7a7f907f56fa07a230eadec2fedf"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classipc_1_1transport_1_1struc_1_1sync__io_1_1Channel.html#a5aae7a7f907f56fa07a230eadec2fedf">undo_expect_responses</a> (<a class="el" href="classipc_1_1transport_1_1struc_1_1Channel__base.html#adcf24fa51747ed83c4b6427fbf44fecf">msg_id_out_t</a> originating_msg_id)</td></tr>
<tr class="memdesc:a5aae7a7f907f56fa07a230eadec2fedf"><td class="mdescLeft">&#160;</td><td class="mdescRight">See <a class="el" href="classipc_1_1transport_1_1struc_1_1sync__io_1_1Channel.html#a6dc83bd6057b7f00a19c5947d6baa7b7" title="Useful for generic programming, the async-I/O-pattern counterpart to *this type.">Async_io_obj</a> counterpart.  <a href="classipc_1_1transport_1_1struc_1_1sync__io_1_1Channel.html#a5aae7a7f907f56fa07a230eadec2fedf">More...</a><br /></td></tr>
<tr class="separator:a5aae7a7f907f56fa07a230eadec2fedf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5c62d2a374a3a98e7fa0aef01bf8a774"><td class="memTemplParams" colspan="2">template&lt;typename On_unexpected_response_handler &gt; </td></tr>
<tr class="memitem:a5c62d2a374a3a98e7fa0aef01bf8a774"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classipc_1_1transport_1_1struc_1_1sync__io_1_1Channel.html#a5c62d2a374a3a98e7fa0aef01bf8a774">set_unexpected_response_handler</a> (On_unexpected_response_handler &amp;&amp;on_func)</td></tr>
<tr class="memdesc:a5c62d2a374a3a98e7fa0aef01bf8a774"><td class="mdescLeft">&#160;</td><td class="mdescRight">See <a class="el" href="classipc_1_1transport_1_1struc_1_1sync__io_1_1Channel.html#a6dc83bd6057b7f00a19c5947d6baa7b7" title="Useful for generic programming, the async-I/O-pattern counterpart to *this type.">Async_io_obj</a> counterpart; though naturally <code>on_func()</code> is invoked in the <code><a class="el" href="namespaceipc_1_1transport_1_1struc_1_1sync__io.html" title="sync_io-pattern counterparts to async-I/O-pattern object types in parent namespace ipc::transport::st...">sync_io</a></code>-pattern fashion.  <a href="classipc_1_1transport_1_1struc_1_1sync__io_1_1Channel.html#a5c62d2a374a3a98e7fa0aef01bf8a774">More...</a><br /></td></tr>
<tr class="separator:a5c62d2a374a3a98e7fa0aef01bf8a774"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1f226e506cc5c04584e11480426b19da"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classipc_1_1transport_1_1struc_1_1sync__io_1_1Channel.html#a1f226e506cc5c04584e11480426b19da">unset_unexpected_response_handler</a> ()</td></tr>
<tr class="memdesc:a1f226e506cc5c04584e11480426b19da"><td class="mdescLeft">&#160;</td><td class="mdescRight">See <a class="el" href="classipc_1_1transport_1_1struc_1_1sync__io_1_1Channel.html#a6dc83bd6057b7f00a19c5947d6baa7b7" title="Useful for generic programming, the async-I/O-pattern counterpart to *this type.">Async_io_obj</a> counterpart.  <a href="classipc_1_1transport_1_1struc_1_1sync__io_1_1Channel.html#a1f226e506cc5c04584e11480426b19da">More...</a><br /></td></tr>
<tr class="separator:a1f226e506cc5c04584e11480426b19da"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3fda370cc97c89a62f77a6fcf639cfd7"><td class="memTemplParams" colspan="2">template&lt;typename On_remote_unexpected_response_handler &gt; </td></tr>
<tr class="memitem:a3fda370cc97c89a62f77a6fcf639cfd7"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classipc_1_1transport_1_1struc_1_1sync__io_1_1Channel.html#a3fda370cc97c89a62f77a6fcf639cfd7">set_remote_unexpected_response_handler</a> (On_remote_unexpected_response_handler &amp;&amp;on_func)</td></tr>
<tr class="memdesc:a3fda370cc97c89a62f77a6fcf639cfd7"><td class="mdescLeft">&#160;</td><td class="mdescRight">See <a class="el" href="classipc_1_1transport_1_1struc_1_1sync__io_1_1Channel.html#a6dc83bd6057b7f00a19c5947d6baa7b7" title="Useful for generic programming, the async-I/O-pattern counterpart to *this type.">Async_io_obj</a> counterpart; though naturally <code>on_func()</code> is invoked in the <code><a class="el" href="namespaceipc_1_1transport_1_1struc_1_1sync__io.html" title="sync_io-pattern counterparts to async-I/O-pattern object types in parent namespace ipc::transport::st...">sync_io</a></code>-pattern fashion.  <a href="classipc_1_1transport_1_1struc_1_1sync__io_1_1Channel.html#a3fda370cc97c89a62f77a6fcf639cfd7">More...</a><br /></td></tr>
<tr class="separator:a3fda370cc97c89a62f77a6fcf639cfd7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a24382a751a2c03e00c5140c89aba2c62"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classipc_1_1transport_1_1struc_1_1sync__io_1_1Channel.html#a24382a751a2c03e00c5140c89aba2c62">unset_remote_unexpected_response_handler</a> ()</td></tr>
<tr class="memdesc:a24382a751a2c03e00c5140c89aba2c62"><td class="mdescLeft">&#160;</td><td class="mdescRight">See <a class="el" href="classipc_1_1transport_1_1struc_1_1sync__io_1_1Channel.html#a6dc83bd6057b7f00a19c5947d6baa7b7" title="Useful for generic programming, the async-I/O-pattern counterpart to *this type.">Async_io_obj</a> counterpart.  <a href="classipc_1_1transport_1_1struc_1_1sync__io_1_1Channel.html#a24382a751a2c03e00c5140c89aba2c62">More...</a><br /></td></tr>
<tr class="separator:a24382a751a2c03e00c5140c89aba2c62"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae4a2a63dc88722d96ee9f3ed68cf7b86"><td class="memTemplParams" colspan="2">template&lt;typename Task_err &gt; </td></tr>
<tr class="memitem:ae4a2a63dc88722d96ee9f3ed68cf7b86"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classipc_1_1transport_1_1struc_1_1sync__io_1_1Channel.html#ae4a2a63dc88722d96ee9f3ed68cf7b86">async_end_sending</a> (<a class="el" href="namespaceipc.html#aa3192e586cc45d3e7c22463bf2760f89">Error_code</a> *sync_err_code, Task_err &amp;&amp;on_done_func)</td></tr>
<tr class="memdesc:ae4a2a63dc88722d96ee9f3ed68cf7b86"><td class="mdescLeft">&#160;</td><td class="mdescRight">See <a class="el" href="classipc_1_1transport_1_1struc_1_1sync__io_1_1Channel.html#a6dc83bd6057b7f00a19c5947d6baa7b7" title="Useful for generic programming, the async-I/O-pattern counterpart to *this type.">Async_io_obj</a> counterpart; except (1) naturally <code>on_done_func()</code> is invoked in the <code><a class="el" href="namespaceipc_1_1transport_1_1struc_1_1sync__io.html" title="sync_io-pattern counterparts to async-I/O-pattern object types in parent namespace ipc::transport::st...">sync_io</a></code>-pattern fashion, and (2) the operation may (and is very likely to) complete synchronously and thus ignore <code>on_done_func</code>.  <a href="classipc_1_1transport_1_1struc_1_1sync__io_1_1Channel.html#ae4a2a63dc88722d96ee9f3ed68cf7b86">More...</a><br /></td></tr>
<tr class="separator:ae4a2a63dc88722d96ee9f3ed68cf7b86"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pri-types" name="pri-types"></a>
Private Types</h2></td></tr>
<tr class="memitem:a5a3833cd141802041551db21198ac319"><td class="memItemLeft" align="right" valign="top">enum class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classipc_1_1transport_1_1struc_1_1sync__io_1_1Channel.html#a5a3833cd141802041551db21198ac319">Phase</a> { <a class="el" href="classipc_1_1transport_1_1struc_1_1sync__io_1_1Channel.html#a5a3833cd141802041551db21198ac319aa0ea4326c39b88d0b32f90d5ce081220">S_LOGGED_IN</a>
, <a class="el" href="classipc_1_1transport_1_1struc_1_1sync__io_1_1Channel.html#a5a3833cd141802041551db21198ac319ab64edfa66dd4c58d7aa1c3a30e142706">S_SRV_LOG_IN</a>
, <a class="el" href="classipc_1_1transport_1_1struc_1_1sync__io_1_1Channel.html#a5a3833cd141802041551db21198ac319aa0cb6b19ec0b17da2c3ed65de71ca437">S_CLI_LOG_IN</a>
 }</td></tr>
<tr class="memdesc:a5a3833cd141802041551db21198ac319"><td class="mdescLeft">&#160;</td><td class="mdescRight">The state of <code>*this</code> (given <a class="el" href="classipc_1_1transport_1_1struc_1_1sync__io_1_1Channel.html#a6e4f8c4207fcf678b4cfc785707d3dce" title="Sets up the sync_io-pattern interaction between *this and the user&#39;s event loop; required before asyn...">start_ops()</a> success); see <a class="el" href="classipc_1_1transport_1_1struc_1_1sync__io_1_1Channel.html#afca9a3012b2f41d635381a5a13ddd7c1" title="Phase (w/r/t log-in or lack thereof) of *this peer.">m_phase</a>.  <a href="classipc_1_1transport_1_1struc_1_1sync__io_1_1Channel.html#a5a3833cd141802041551db21198ac319">More...</a><br /></td></tr>
<tr class="separator:a5a3833cd141802041551db21198ac319"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9d3344a97644dad136bb47e852dda6fd"><td class="memItemLeft" align="right" valign="top">enum class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classipc_1_1transport_1_1struc_1_1sync__io_1_1Channel.html#a9d3344a97644dad136bb47e852dda6fd">Rcv_next_step</a> { <a class="el" href="classipc_1_1transport_1_1struc_1_1sync__io_1_1Channel.html#a9d3344a97644dad136bb47e852dda6fda24a42fc0479551b9f0f33d942a582edf">S_READ_LEAD_MSG</a>
, <a class="el" href="classipc_1_1transport_1_1struc_1_1sync__io_1_1Channel.html#a9d3344a97644dad136bb47e852dda6fda6d57adae739c502e8f906c7ad249cf80">S_READ_CONT_MSG</a>
, <a class="el" href="classipc_1_1transport_1_1struc_1_1sync__io_1_1Channel.html#a9d3344a97644dad136bb47e852dda6fda06d91d8c95309c139826c9abbcb0a863">S_STOP</a>
 }</td></tr>
<tr class="memdesc:a9d3344a97644dad136bb47e852dda6fd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Upon receiving an unstructured message along 1 given pipe of <a class="el" href="classipc_1_1transport_1_1struc_1_1sync__io_1_1Channel.html#a4abac89dbd4d26c79b7915990f751a76" title="See Async_io_obj counterpart.">Owned_channel</a> this indicates the next such message expected if any.  <a href="classipc_1_1transport_1_1struc_1_1sync__io_1_1Channel.html#a9d3344a97644dad136bb47e852dda6fd">More...</a><br /></td></tr>
<tr class="separator:a9d3344a97644dad136bb47e852dda6fd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a984b6afa0f437c72aca5a1ba97f33a7f"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classipc_1_1transport_1_1struc_1_1sync__io_1_1Channel.html#a984b6afa0f437c72aca5a1ba97f33a7f">Msg_out_impl</a> = <a class="el" href="classipc_1_1transport_1_1struc_1_1Msg__out__impl.html">struc::Msg_out_impl</a>&lt; <a class="el" href="classipc_1_1transport_1_1struc_1_1sync__io_1_1Channel.html#a34e183c252390f369f121074772c14c4">Msg_body</a>, typename Builder_config::Builder &gt;</td></tr>
<tr class="memdesc:a984b6afa0f437c72aca5a1ba97f33a7f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Exact equivalent of <a class="el" href="classipc_1_1transport_1_1struc_1_1sync__io_1_1Channel.html#a83fb4462a8d4045bdb56b694bf80393c" title="See Async_io_obj counterpart.">Msg_out</a> but with the internal-use (intended for us!) interface exposed.  <a href="classipc_1_1transport_1_1struc_1_1sync__io_1_1Channel.html#a984b6afa0f437c72aca5a1ba97f33a7f">More...</a><br /></td></tr>
<tr class="separator:a984b6afa0f437c72aca5a1ba97f33a7f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acb6922fb543bd544a2244412e4835e82"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classipc_1_1transport_1_1struc_1_1sync__io_1_1Channel.html#acb6922fb543bd544a2244412e4835e82">Msg_in_impl</a> = <a class="el" href="classipc_1_1transport_1_1struc_1_1Msg__in__impl.html">struc::Msg_in_impl</a>&lt; <a class="el" href="classipc_1_1transport_1_1struc_1_1sync__io_1_1Channel.html#a34e183c252390f369f121074772c14c4">Msg_body</a>, <a class="el" href="classipc_1_1transport_1_1struc_1_1sync__io_1_1Channel.html#a14a7166b2f8c117ce6ddafe943d036fa">Reader_config</a> &gt;</td></tr>
<tr class="memdesc:acb6922fb543bd544a2244412e4835e82"><td class="mdescLeft">&#160;</td><td class="mdescRight">Exact equivalent of <a class="el" href="classipc_1_1transport_1_1struc_1_1sync__io_1_1Channel.html#ac3da0ac1306b63c9e38c47b8c31e3cd2" title="See Async_io_obj counterpart.">Msg_in</a> but with the internal-use (intended for us!) interface exposed.  <a href="classipc_1_1transport_1_1struc_1_1sync__io_1_1Channel.html#acb6922fb543bd544a2244412e4835e82">More...</a><br /></td></tr>
<tr class="separator:acb6922fb543bd544a2244412e4835e82"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acbf3e5dbf6879e358f0596633e1428e0"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classipc_1_1transport_1_1struc_1_1sync__io_1_1Channel.html#acbf3e5dbf6879e358f0596633e1428e0">Msg_mdt_out</a> = <a class="el" href="classipc_1_1transport_1_1struc_1_1Msg__mdt__out.html">struc::Msg_mdt_out</a>&lt; <a class="el" href="classipc_1_1transport_1_1struc_1_1sync__io_1_1Channel.html#a8a59bbc3c6a7191b316b23661d8ba6e3">Builder_config</a> &gt;</td></tr>
<tr class="memdesc:acbf3e5dbf6879e358f0596633e1428e0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Metadata message: internal-use out-message describing the associated <a class="el" href="classipc_1_1transport_1_1struc_1_1sync__io_1_1Channel.html#a83fb4462a8d4045bdb56b694bf80393c" title="See Async_io_obj counterpart.">Msg_out</a>; or describing/containing internal message body (then not associated with a user-message).  <a href="classipc_1_1transport_1_1struc_1_1sync__io_1_1Channel.html#acbf3e5dbf6879e358f0596633e1428e0">More...</a><br /></td></tr>
<tr class="separator:acbf3e5dbf6879e358f0596633e1428e0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad77261f31055f4151c70225c3fa1da2e"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classipc_1_1transport_1_1struc_1_1sync__io_1_1Channel.html#ad77261f31055f4151c70225c3fa1da2e">msg_id_in_t</a> = <a class="el" href="namespaceipc_1_1transport_1_1struc.html#af7f35fc7588d97a838274fa25700ead9">msg_id_t</a></td></tr>
<tr class="memdesc:ad77261f31055f4151c70225c3fa1da2e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Clarifying short-hand for incoming-message IDs.  <a href="classipc_1_1transport_1_1struc_1_1sync__io_1_1Channel.html#ad77261f31055f4151c70225c3fa1da2e">More...</a><br /></td></tr>
<tr class="separator:ad77261f31055f4151c70225c3fa1da2e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a26121a19c67c5bf5c338441502d9d6f7"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classipc_1_1transport_1_1struc_1_1sync__io_1_1Channel.html#a26121a19c67c5bf5c338441502d9d6f7">On_msg_func</a> = <a class="el" href="namespaceipc.html#aa455c7f045059736578ca275fc1a851f">Function</a>&lt; void(<a class="el" href="classipc_1_1transport_1_1struc_1_1sync__io_1_1Channel.html#acde2b3866547a30958035203d9d89928">Msg_in_ptr</a> &amp;&amp;msg)&gt;</td></tr>
<tr class="memdesc:a26121a19c67c5bf5c338441502d9d6f7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Concrete type corresponding to <code>On_msg_handler</code> template param: in-message handler.  <a href="classipc_1_1transport_1_1struc_1_1sync__io_1_1Channel.html#a26121a19c67c5bf5c338441502d9d6f7">More...</a><br /></td></tr>
<tr class="separator:a26121a19c67c5bf5c338441502d9d6f7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a583ccd4bb6b1aefb09d77e5709aef5b4"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classipc_1_1transport_1_1struc_1_1sync__io_1_1Channel.html#a583ccd4bb6b1aefb09d77e5709aef5b4">On_msg_func_ptr</a> = boost::shared_ptr&lt; <a class="el" href="classipc_1_1transport_1_1struc_1_1sync__io_1_1Channel.html#a26121a19c67c5bf5c338441502d9d6f7">On_msg_func</a> &gt;</td></tr>
<tr class="memdesc:a583ccd4bb6b1aefb09d77e5709aef5b4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Ref-counted wrapper of <a class="el" href="classipc_1_1transport_1_1struc_1_1sync__io_1_1Channel.html#a26121a19c67c5bf5c338441502d9d6f7" title="Concrete type corresponding to On_msg_handler template param: in-message handler.">On_msg_func</a>.  <a href="classipc_1_1transport_1_1struc_1_1sync__io_1_1Channel.html#a583ccd4bb6b1aefb09d77e5709aef5b4">More...</a><br /></td></tr>
<tr class="separator:a583ccd4bb6b1aefb09d77e5709aef5b4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abb3be9330a898ce542afd778d8e42a49"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classipc_1_1transport_1_1struc_1_1sync__io_1_1Channel.html#abb3be9330a898ce542afd778d8e42a49">On_unexpected_response_func</a> = <a class="el" href="namespaceipc.html#aa455c7f045059736578ca275fc1a851f">Function</a>&lt; void(<a class="el" href="classipc_1_1transport_1_1struc_1_1sync__io_1_1Channel.html#acde2b3866547a30958035203d9d89928">Msg_in_ptr</a> &amp;&amp;msg)&gt;</td></tr>
<tr class="memdesc:abb3be9330a898ce542afd778d8e42a49"><td class="mdescLeft">&#160;</td><td class="mdescRight">Concrete type corresponding to <code>On_unexpected_response_handler</code> template param (see <a class="el" href="classipc_1_1transport_1_1struc_1_1sync__io_1_1Channel.html#a5c62d2a374a3a98e7fa0aef01bf8a774" title="See Async_io_obj counterpart; though naturally on_func() is invoked in the sync_io-pattern fashion.">set_unexpected_response_handler()</a>).  <a href="classipc_1_1transport_1_1struc_1_1sync__io_1_1Channel.html#abb3be9330a898ce542afd778d8e42a49">More...</a><br /></td></tr>
<tr class="separator:abb3be9330a898ce542afd778d8e42a49"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a86342fa9838aea7d49bbf3dd344445e2"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classipc_1_1transport_1_1struc_1_1sync__io_1_1Channel.html#a86342fa9838aea7d49bbf3dd344445e2">On_remote_unexpected_response_func</a> = <a class="el" href="namespaceipc.html#aa455c7f045059736578ca275fc1a851f">Function</a>&lt; void(<a class="el" href="classipc_1_1transport_1_1struc_1_1Channel__base.html#adcf24fa51747ed83c4b6427fbf44fecf">msg_id_out_t</a> msg_id_out, std::string &amp;&amp;msg_metadata_text)&gt;</td></tr>
<tr class="memdesc:a86342fa9838aea7d49bbf3dd344445e2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Concrete type corresponding to <code>On_remote_unexpected_response_handler</code> template param (see <a class="el" href="classipc_1_1transport_1_1struc_1_1sync__io_1_1Channel.html#a3fda370cc97c89a62f77a6fcf639cfd7" title="See Async_io_obj counterpart; though naturally on_func() is invoked in the sync_io-pattern fashion.">set_remote_unexpected_response_handler()</a>).  <a href="classipc_1_1transport_1_1struc_1_1sync__io_1_1Channel.html#a86342fa9838aea7d49bbf3dd344445e2">More...</a><br /></td></tr>
<tr class="separator:a86342fa9838aea7d49bbf3dd344445e2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adccd6372c0284a7f3198ac00c0935002"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classipc_1_1transport_1_1struc_1_1sync__io_1_1Channel.html#adccd6372c0284a7f3198ac00c0935002">Expecting_msg</a> = <a class="el" href="structipc_1_1transport_1_1struc_1_1sync__io_1_1Channel_1_1Expecting__response.html">Expecting_response</a></td></tr>
<tr class="memdesc:adccd6372c0284a7f3198ac00c0935002"><td class="mdescLeft">&#160;</td><td class="mdescRight">Policy for how to act upon receiving an in-message whose top-level-union <a class="el" href="classipc_1_1transport_1_1struc_1_1sync__io_1_1Channel.html#aa40c3ec3f45cdfea9360f7f35b9ade3c" title="See Async_io_obj counterpart.">Msg_which_in</a> <code>enum</code> equals the <a class="el" href="classipc_1_1transport_1_1struc_1_1sync__io_1_1Channel.html#aa40c3ec3f45cdfea9360f7f35b9ade3c" title="See Async_io_obj counterpart.">Msg_which_in</a> associated with this object in <a class="el" href="classipc_1_1transport_1_1struc_1_1sync__io_1_1Channel.html#a8d1ffe78546eb31fd41df6784a26868c" title="Table mapping in-message Msg_which_in enum value to the policy for handling an in-message with that w...">Expecting_msg_map</a>.  <a href="classipc_1_1transport_1_1struc_1_1sync__io_1_1Channel.html#adccd6372c0284a7f3198ac00c0935002">More...</a><br /></td></tr>
<tr class="separator:adccd6372c0284a7f3198ac00c0935002"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3d4c8da3dd620d113479f5c6a3f96c3a"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classipc_1_1transport_1_1struc_1_1sync__io_1_1Channel.html#a3d4c8da3dd620d113479f5c6a3f96c3a">Expecting_response_map</a> = boost::unordered_map&lt; <a class="el" href="classipc_1_1transport_1_1struc_1_1Channel__base.html#adcf24fa51747ed83c4b6427fbf44fecf">msg_id_out_t</a>, typename <a class="el" href="structipc_1_1transport_1_1struc_1_1sync__io_1_1Channel_1_1Expecting__response.html#a5f68a8c574bf52f8fce42ea01c564923">Expecting_response::Ptr</a> &gt;</td></tr>
<tr class="memdesc:a3d4c8da3dd620d113479f5c6a3f96c3a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Table mapping originating out-message to the policy for handling an in-message that indicates that out-message as the originating message (via message ID &ndash; <em>after</em> the out-message is sent via <a class="el" href="classipc_1_1transport_1_1struc_1_1sync__io_1_1Channel.html#a0dc388e18b0fc0fa2d8ad0a6953fb039" title="See Async_io_obj counterpart.">send()</a>).  <a href="classipc_1_1transport_1_1struc_1_1sync__io_1_1Channel.html#a3d4c8da3dd620d113479f5c6a3f96c3a">More...</a><br /></td></tr>
<tr class="separator:a3d4c8da3dd620d113479f5c6a3f96c3a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8d1ffe78546eb31fd41df6784a26868c"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classipc_1_1transport_1_1struc_1_1sync__io_1_1Channel.html#a8d1ffe78546eb31fd41df6784a26868c">Expecting_msg_map</a> = boost::unordered_map&lt; <a class="el" href="classipc_1_1transport_1_1struc_1_1sync__io_1_1Channel.html#aa40c3ec3f45cdfea9360f7f35b9ade3c">Msg_which_in</a>, typename <a class="el" href="structipc_1_1transport_1_1struc_1_1sync__io_1_1Channel_1_1Expecting__response.html#a5f68a8c574bf52f8fce42ea01c564923">Expecting_msg::Ptr</a> &gt;</td></tr>
<tr class="memdesc:a8d1ffe78546eb31fd41df6784a26868c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Table mapping in-message <a class="el" href="classipc_1_1transport_1_1struc_1_1sync__io_1_1Channel.html#aa40c3ec3f45cdfea9360f7f35b9ade3c" title="See Async_io_obj counterpart.">Msg_which_in</a> <code>enum</code> value to the policy for handling an in-message with that <code>which()</code> value.  <a href="classipc_1_1transport_1_1struc_1_1sync__io_1_1Channel.html#a8d1ffe78546eb31fd41df6784a26868c">More...</a><br /></td></tr>
<tr class="separator:a8d1ffe78546eb31fd41df6784a26868c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a84287334d14f54c97f7dbb0d5b04cca5"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classipc_1_1transport_1_1struc_1_1sync__io_1_1Channel.html#a84287334d14f54c97f7dbb0d5b04cca5">Msg_in_ptr_uniq</a> = boost::movelib::unique_ptr&lt; <a class="el" href="classipc_1_1transport_1_1struc_1_1sync__io_1_1Channel.html#acb6922fb543bd544a2244412e4835e82">Msg_in_impl</a> &gt;</td></tr>
<tr class="memdesc:a84287334d14f54c97f7dbb0d5b04cca5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Like <a class="el" href="classipc_1_1transport_1_1struc_1_1sync__io_1_1Channel.html#acde2b3866547a30958035203d9d89928" title="See Async_io_obj counterpart.">Msg_in_ptr</a> but <code>unique_ptr</code> instead of <code>shared_ptr</code>. Note the latter can upgrade-from a <code>move()</code>d former.  <a href="classipc_1_1transport_1_1struc_1_1sync__io_1_1Channel.html#a84287334d14f54c97f7dbb0d5b04cca5">More...</a><br /></td></tr>
<tr class="separator:a84287334d14f54c97f7dbb0d5b04cca5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2eed5db328a8c45ab16a875617a172c7"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classipc_1_1transport_1_1struc_1_1sync__io_1_1Channel.html#a2eed5db328a8c45ab16a875617a172c7">Msg_in_q</a> = std::queue&lt; <a class="el" href="classipc_1_1transport_1_1struc_1_1sync__io_1_1Channel.html#a84287334d14f54c97f7dbb0d5b04cca5">Msg_in_ptr_uniq</a> &gt;</td></tr>
<tr class="memdesc:a2eed5db328a8c45ab16a875617a172c7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Short-hand for queue (FIFO) of in-messages.  <a href="classipc_1_1transport_1_1struc_1_1sync__io_1_1Channel.html#a2eed5db328a8c45ab16a875617a172c7">More...</a><br /></td></tr>
<tr class="separator:a2eed5db328a8c45ab16a875617a172c7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a26594894094e4fa03b3c1dacd2e0f351"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classipc_1_1transport_1_1struc_1_1sync__io_1_1Channel.html#a26594894094e4fa03b3c1dacd2e0f351">Reassembly_q</a> = std::map&lt; <a class="el" href="classipc_1_1transport_1_1struc_1_1sync__io_1_1Channel.html#ad77261f31055f4151c70225c3fa1da2e">msg_id_in_t</a>, <a class="el" href="classipc_1_1transport_1_1struc_1_1sync__io_1_1Channel.html#a84287334d14f54c97f7dbb0d5b04cca5">Msg_in_ptr_uniq</a> &gt;</td></tr>
<tr class="memdesc:a26594894094e4fa03b3c1dacd2e0f351"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reassembly queue type: "queue" of all in-messages with <a class="el" href="classipc_1_1transport_1_1struc_1_1sync__io_1_1Channel.html#ad77261f31055f4151c70225c3fa1da2e" title="Clarifying short-hand for incoming-message IDs.">msg_id_in_t</a> exceeding <a class="el" href="classipc_1_1transport_1_1struc_1_1sync__io_1_1Channel.html#a26d39d4e1e2c304ef803b3721bde86f0" title="Next expected in-message ID (sequence #), incremented from initial value 1 to 2, 3,...">m_rcv_msg_next_id</a>, sorted in increasing order by that <a class="el" href="classipc_1_1transport_1_1struc_1_1sync__io_1_1Channel.html#ad77261f31055f4151c70225c3fa1da2e" title="Clarifying short-hand for incoming-message IDs.">msg_id_in_t</a> (sequence #).  <a href="classipc_1_1transport_1_1struc_1_1sync__io_1_1Channel.html#a26594894094e4fa03b3c1dacd2e0f351">More...</a><br /></td></tr>
<tr class="separator:a26594894094e4fa03b3c1dacd2e0f351"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pri-methods" name="pri-methods"></a>
Private Member Functions</h2></td></tr>
<tr class="memitem:a126c0d7ee5fcab20dc8c87884fdd7597"><td class="memTemplParams" colspan="2">template&lt;typename Task &gt; </td></tr>
<tr class="memitem:a126c0d7ee5fcab20dc8c87884fdd7597"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classipc_1_1transport_1_1struc_1_1sync__io_1_1Channel.html#a126c0d7ee5fcab20dc8c87884fdd7597">handlers_post</a> (<a class="el" href="namespaceipc_1_1util.html#ae6ac47812a90d1287c61e0b7de7bc4f5">util::String_view</a> context, Task &amp;&amp;handler)</td></tr>
<tr class="memdesc:a126c0d7ee5fcab20dc8c87884fdd7597"><td class="mdescLeft">&#160;</td><td class="mdescRight">Record handler to invoke in <a class="el" href="classipc_1_1transport_1_1struc_1_1sync__io_1_1Channel.html#a3a0adf8ce8fc29ec55b4c8c30886c1fc" title="Executes what was recorded recently in handlers_post().">handlers_poll()</a> soon.  <a href="classipc_1_1transport_1_1struc_1_1sync__io_1_1Channel.html#a126c0d7ee5fcab20dc8c87884fdd7597">More...</a><br /></td></tr>
<tr class="separator:a126c0d7ee5fcab20dc8c87884fdd7597"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3a0adf8ce8fc29ec55b4c8c30886c1fc"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classipc_1_1transport_1_1struc_1_1sync__io_1_1Channel.html#a3a0adf8ce8fc29ec55b4c8c30886c1fc">handlers_poll</a> (<a class="el" href="namespaceipc_1_1util.html#ae6ac47812a90d1287c61e0b7de7bc4f5">util::String_view</a> context)</td></tr>
<tr class="memdesc:a3a0adf8ce8fc29ec55b4c8c30886c1fc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Executes what was recorded recently in <a class="el" href="classipc_1_1transport_1_1struc_1_1sync__io_1_1Channel.html#a126c0d7ee5fcab20dc8c87884fdd7597" title="Record handler to invoke in handlers_poll() soon.">handlers_post()</a>.  <a href="classipc_1_1transport_1_1struc_1_1sync__io_1_1Channel.html#a3a0adf8ce8fc29ec55b4c8c30886c1fc">More...</a><br /></td></tr>
<tr class="separator:a3a0adf8ce8fc29ec55b4c8c30886c1fc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9b6cda20adb82073a1d7cf1b5cbfa865"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classipc_1_1transport_1_1struc_1_1sync__io_1_1Channel.html#a9b6cda20adb82073a1d7cf1b5cbfa865">rcv_blob_max_size</a> (decltype(<a class="el" href="structipc_1_1transport_1_1struc_1_1sync__io_1_1Channel_1_1Msg__in__pipe.html#a3d239c5a1e29bd6db1ee7c4764616549">Msg_in_pipe::m_lead_msg_mode</a>) mode) const</td></tr>
<tr class="memdesc:a9b6cda20adb82073a1d7cf1b5cbfa865"><td class="mdescLeft">&#160;</td><td class="mdescRight">Helper that returns the max receive-buffer size for any async-read into a given <a class="el" href="structipc_1_1transport_1_1struc_1_1sync__io_1_1Channel_1_1Msg__in__pipe.html" title="Data and policy with respect to receipt of the next/currently-incomplete in-message.">Msg_in_pipe</a>.  <a href="classipc_1_1transport_1_1struc_1_1sync__io_1_1Channel.html#a9b6cda20adb82073a1d7cf1b5cbfa865">More...</a><br /></td></tr>
<tr class="separator:a9b6cda20adb82073a1d7cf1b5cbfa865"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a252e43676b8a41a706df0655f887be63"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classipc_1_1transport_1_1struc_1_1sync__io_1_1Channel.html#a252e43676b8a41a706df0655f887be63">rcv_async_read_lead_or_continuation_msg</a> (<a class="el" href="structipc_1_1transport_1_1struc_1_1sync__io_1_1Channel_1_1Msg__in__pipe.html">Msg_in_pipe</a> *pipe, bool lead_else_cont)</td></tr>
<tr class="memdesc:a252e43676b8a41a706df0655f887be63"><td class="mdescLeft">&#160;</td><td class="mdescRight">This key method acts on the pre-condition that the given in-pipe is not known to be in would-block state; and therefore we should read (and process) as many unstructured in-messages as synchronously possible until reaching would-block state, at which point we should <code>return</code> with a pending async-wait/read on that in-pipe.  <a href="classipc_1_1transport_1_1struc_1_1sync__io_1_1Channel.html#a252e43676b8a41a706df0655f887be63">More...</a><br /></td></tr>
<tr class="separator:a252e43676b8a41a706df0655f887be63"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af546fc0ab4d0ddca0a857c57decd0620"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classipc_1_1transport_1_1struc_1_1sync__io_1_1Channel.html#a9d3344a97644dad136bb47e852dda6fd">Rcv_next_step</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classipc_1_1transport_1_1struc_1_1sync__io_1_1Channel.html#af546fc0ab4d0ddca0a857c57decd0620">rcv_on_async_read_lead_msg</a> (<a class="el" href="structipc_1_1transport_1_1struc_1_1sync__io_1_1Channel_1_1Msg__in__pipe.html">Msg_in_pipe</a> *pipe, const <a class="el" href="namespaceipc.html#aa3192e586cc45d3e7c22463bf2760f89">Error_code</a> &amp;err_code, size_t sz)</td></tr>
<tr class="memdesc:af546fc0ab4d0ddca0a857c57decd0620"><td class="mdescLeft">&#160;</td><td class="mdescRight">To execute upon completing an <code>m_channel.async_receive_*()</code> of an expected lead message along the given in-pipe, this processes the result (message or error) and returns what should be done next; does <em>not</em> invoke <a class="el" href="classipc_1_1transport_1_1struc_1_1sync__io_1_1Channel.html#a3a0adf8ce8fc29ec55b4c8c30886c1fc" title="Executes what was recorded recently in handlers_post().">handlers_poll()</a>.  <a href="classipc_1_1transport_1_1struc_1_1sync__io_1_1Channel.html#af546fc0ab4d0ddca0a857c57decd0620">More...</a><br /></td></tr>
<tr class="separator:af546fc0ab4d0ddca0a857c57decd0620"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa83fd6e35057876e2f5173df53e73371"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classipc_1_1transport_1_1struc_1_1sync__io_1_1Channel.html#a9d3344a97644dad136bb47e852dda6fd">Rcv_next_step</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classipc_1_1transport_1_1struc_1_1sync__io_1_1Channel.html#aa83fd6e35057876e2f5173df53e73371">rcv_on_async_read_continuation_msg</a> (<a class="el" href="structipc_1_1transport_1_1struc_1_1sync__io_1_1Channel_1_1Msg__in__pipe.html">Msg_in_pipe</a> *pipe, const <a class="el" href="namespaceipc.html#aa3192e586cc45d3e7c22463bf2760f89">Error_code</a> &amp;err_code, size_t sz)</td></tr>
<tr class="memdesc:aa83fd6e35057876e2f5173df53e73371"><td class="mdescLeft">&#160;</td><td class="mdescRight">Same as <a class="el" href="classipc_1_1transport_1_1struc_1_1sync__io_1_1Channel.html#af546fc0ab4d0ddca0a857c57decd0620" title="To execute upon completing an m_channel.async_receive_*() of an expected lead message along the given...">rcv_on_async_read_lead_msg()</a> but for an expected continuation message instead of lead.  <a href="classipc_1_1transport_1_1struc_1_1sync__io_1_1Channel.html#aa83fd6e35057876e2f5173df53e73371">More...</a><br /></td></tr>
<tr class="separator:aa83fd6e35057876e2f5173df53e73371"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa210976b523c04042dd083f054182441"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classipc_1_1transport_1_1struc_1_1sync__io_1_1Channel.html#aa210976b523c04042dd083f054182441">rcv_struct_new_msg_in</a> (<a class="el" href="classipc_1_1transport_1_1struc_1_1sync__io_1_1Channel.html#a84287334d14f54c97f7dbb0d5b04cca5">Msg_in_ptr_uniq</a> &amp;&amp;msg_in)</td></tr>
<tr class="memdesc:aa210976b523c04042dd083f054182441"><td class="mdescLeft">&#160;</td><td class="mdescRight">Helper from <code>rcv_on_async_read_*()</code>, processes a newly completed structured in-message, as it exits the <code><a class="el" href="classipc_1_1transport_1_1struc_1_1sync__io_1_1Channel.html" title="sync_io-pattern counterpart to async-I/O-pattern transport::struc::Channel.">Channel</a></code>-layer and enters into the structured-layer of processing.  <a href="classipc_1_1transport_1_1struc_1_1sync__io_1_1Channel.html#aa210976b523c04042dd083f054182441">More...</a><br /></td></tr>
<tr class="separator:aa210976b523c04042dd083f054182441"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab8bfe06a0aecb261dd11624c4ddec518"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classipc_1_1transport_1_1struc_1_1sync__io_1_1Channel.html#ab8bfe06a0aecb261dd11624c4ddec518">rcv_struct_new_internal_msg_in</a> (const <a class="el" href="classipc_1_1transport_1_1struc_1_1sync__io_1_1Channel.html#acb6922fb543bd544a2244412e4835e82">Msg_in_impl</a> &amp;msg_in)</td></tr>
<tr class="memdesc:ab8bfe06a0aecb261dd11624c4ddec518"><td class="mdescLeft">&#160;</td><td class="mdescRight">Helper from <code><a class="el" href="classipc_1_1transport_1_1struc_1_1sync__io_1_1Channel.html#aa210976b523c04042dd083f054182441" title="Helper from rcv_on_async_read_*(), processes a newly completed structured in-message,...">rcv_struct_new_msg_in()</a></code>: the case where the in-message has a sentinel message ID value, indicating an internal message rather that one from a user <a class="el" href="classipc_1_1transport_1_1struc_1_1sync__io_1_1Channel.html#a0dc388e18b0fc0fa2d8ad0a6953fb039" title="See Async_io_obj counterpart.">send()</a> (et al).  <a href="classipc_1_1transport_1_1struc_1_1sync__io_1_1Channel.html#ab8bfe06a0aecb261dd11624c4ddec518">More...</a><br /></td></tr>
<tr class="separator:ab8bfe06a0aecb261dd11624c4ddec518"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aff04d908fa53c7df582f3b2b6e51cfce"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classipc_1_1transport_1_1struc_1_1sync__io_1_1Channel.html#aff04d908fa53c7df582f3b2b6e51cfce">rcv_struct_new_msg_in_during_log_in_as_cli</a> (<a class="el" href="classipc_1_1transport_1_1struc_1_1sync__io_1_1Channel.html#a84287334d14f54c97f7dbb0d5b04cca5">Msg_in_ptr_uniq</a> &amp;&amp;msg_in)</td></tr>
<tr class="memdesc:aff04d908fa53c7df582f3b2b6e51cfce"><td class="mdescLeft">&#160;</td><td class="mdescRight">Helper from <code><a class="el" href="classipc_1_1transport_1_1struc_1_1sync__io_1_1Channel.html#aa210976b523c04042dd083f054182441" title="Helper from rcv_on_async_read_*(), processes a newly completed structured in-message,...">rcv_struct_new_msg_in()</a></code>: the case where <a class="el" href="classipc_1_1transport_1_1struc_1_1sync__io_1_1Channel.html#afca9a3012b2f41d635381a5a13ddd7c1" title="Phase (w/r/t log-in or lack thereof) of *this peer.">m_phase</a> is <a class="el" href="classipc_1_1transport_1_1struc_1_1sync__io_1_1Channel.html#a5a3833cd141802041551db21198ac319aa0cb6b19ec0b17da2c3ed65de71ca437" title="Logging-in phase, as client process: The general API (expect_msg(), etc.) is unavailable; only create...">Phase::S_CLI_LOG_IN</a>, and the in-message has the log-in-response value 1 + session-token=nil as required: Processes the in-message according to the rigid log-in phase algorithm.  <a href="classipc_1_1transport_1_1struc_1_1sync__io_1_1Channel.html#aff04d908fa53c7df582f3b2b6e51cfce">More...</a><br /></td></tr>
<tr class="separator:aff04d908fa53c7df582f3b2b6e51cfce"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9174c694ee8437605c089965ecea2ebf"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classipc_1_1transport_1_1struc_1_1sync__io_1_1Channel.html#a9174c694ee8437605c089965ecea2ebf">rcv_struct_new_msg_in_during_log_in_as_srv</a> (<a class="el" href="classipc_1_1transport_1_1struc_1_1sync__io_1_1Channel.html#a84287334d14f54c97f7dbb0d5b04cca5">Msg_in_ptr_uniq</a> &amp;&amp;msg_in)</td></tr>
<tr class="memdesc:a9174c694ee8437605c089965ecea2ebf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Like <a class="el" href="classipc_1_1transport_1_1struc_1_1sync__io_1_1Channel.html#aff04d908fa53c7df582f3b2b6e51cfce" title="Helper from rcv_struct_new_msg_in(): the case where m_phase is Phase::S_CLI_LOG_IN,...">rcv_struct_new_msg_in_during_log_in_as_cli()</a> but for <a class="el" href="classipc_1_1transport_1_1struc_1_1sync__io_1_1Channel.html#a5a3833cd141802041551db21198ac319ab64edfa66dd4c58d7aa1c3a30e142706" title="Logging-in phase, as server process: The general API (expect_msg(), etc.) is unavailable; only expect...">Phase::S_SRV_LOG_IN</a> instead of CLI_LOG_IN.  <a href="classipc_1_1transport_1_1struc_1_1sync__io_1_1Channel.html#a9174c694ee8437605c089965ecea2ebf">More...</a><br /></td></tr>
<tr class="separator:a9174c694ee8437605c089965ecea2ebf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a134966e02297d141b9e6d5e0d2ca3a7b"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classipc_1_1transport_1_1struc_1_1sync__io_1_1Channel.html#a134966e02297d141b9e6d5e0d2ca3a7b">rcv_struct_new_msg_in_is_next_expected</a> (<a class="el" href="classipc_1_1transport_1_1struc_1_1sync__io_1_1Channel.html#a84287334d14f54c97f7dbb0d5b04cca5">Msg_in_ptr_uniq</a> &amp;&amp;msg_in)</td></tr>
<tr class="memdesc:a134966e02297d141b9e6d5e0d2ca3a7b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Helper from <code><a class="el" href="classipc_1_1transport_1_1struc_1_1sync__io_1_1Channel.html#aa210976b523c04042dd083f054182441" title="Helper from rcv_on_async_read_*(), processes a newly completed structured in-message,...">rcv_struct_new_msg_in()</a></code> (possibly indirectly): the case where the in-message's session-token and message ID have been validated (and the latter indicates a user, not internal, message), and the message ID (seq #) indicates this is the next expected in-order message (hence <a class="el" href="classipc_1_1transport_1_1struc_1_1sync__io_1_1Channel.html#a26d39d4e1e2c304ef803b3721bde86f0" title="Next expected in-message ID (sequence #), incremented from initial value 1 to 2, 3,...">m_rcv_msg_next_id</a> was just <code>++</code>ed).  <a href="classipc_1_1transport_1_1struc_1_1sync__io_1_1Channel.html#a134966e02297d141b9e6d5e0d2ca3a7b">More...</a><br /></td></tr>
<tr class="separator:a134966e02297d141b9e6d5e0d2ca3a7b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a795baef6fefbc4749daf5ceda52943c1"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classipc_1_1transport_1_1struc_1_1sync__io_1_1Channel.html#a795baef6fefbc4749daf5ceda52943c1">rcv_struct_inform_of_unexpected_response</a> (<a class="el" href="classipc_1_1transport_1_1struc_1_1sync__io_1_1Channel.html#a84287334d14f54c97f7dbb0d5b04cca5">Msg_in_ptr_uniq</a> &amp;&amp;msg_in)</td></tr>
<tr class="memdesc:a795baef6fefbc4749daf5ceda52943c1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Helper from <a class="el" href="classipc_1_1transport_1_1struc_1_1sync__io_1_1Channel.html#a134966e02297d141b9e6d5e0d2ca3a7b" title="Helper from rcv_struct_new_msg_in() (possibly indirectly): the case where the in-message&#39;s session-to...">rcv_struct_new_msg_in_is_next_expected()</a> that reacts to receiving an otherwise valid reponse in-message when no such response is expected.  <a href="classipc_1_1transport_1_1struc_1_1sync__io_1_1Channel.html#a795baef6fefbc4749daf5ceda52943c1">More...</a><br /></td></tr>
<tr class="separator:a795baef6fefbc4749daf5ceda52943c1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab17b00ae995cf634c721420cd85fdef2"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classipc_1_1transport_1_1struc_1_1sync__io_1_1Channel.html#ab17b00ae995cf634c721420cd85fdef2">handle_async_err_code</a> (const <a class="el" href="namespaceipc.html#aa3192e586cc45d3e7c22463bf2760f89">Error_code</a> &amp;err_code, <a class="el" href="namespaceipc_1_1util.html#ae6ac47812a90d1287c61e0b7de7bc4f5">util::String_view</a> context)</td></tr>
<tr class="memdesc:ab17b00ae995cf634c721420cd85fdef2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Helper for async handlers: returns <code>true</code> if and only if <code>err_code</code> indicates a new error or <a class="el" href="classipc_1_1transport_1_1struc_1_1sync__io_1_1Channel.html#a95cfe30e685e828d62318c9b2bc4b137" title="Starts falsy; becomes forever truthy (with a specific Error_code that will not change thereafter) whe...">m_channel_err_code_or_ok</a> indicates a previously-occurred one or both; updates <a class="el" href="classipc_1_1transport_1_1struc_1_1sync__io_1_1Channel.html#a95cfe30e685e828d62318c9b2bc4b137" title="Starts falsy; becomes forever truthy (with a specific Error_code that will not change thereafter) whe...">m_channel_err_code_or_ok</a> to <code>err_code</code> in the former case.  <a href="classipc_1_1transport_1_1struc_1_1sync__io_1_1Channel.html#ab17b00ae995cf634c721420cd85fdef2">More...</a><br /></td></tr>
<tr class="separator:ab17b00ae995cf634c721420cd85fdef2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad3f5d174c65db9d5ec3b14769fb9574a"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classipc_1_1transport_1_1struc_1_1sync__io_1_1Channel.html#ad3f5d174c65db9d5ec3b14769fb9574a">handle_new_error</a> (const <a class="el" href="namespaceipc.html#aa3192e586cc45d3e7c22463bf2760f89">Error_code</a> &amp;err_code_not_ok, <a class="el" href="namespaceipc_1_1util.html#ae6ac47812a90d1287c61e0b7de7bc4f5">util::String_view</a> context)</td></tr>
<tr class="memdesc:ad3f5d174c65db9d5ec3b14769fb9574a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Helper that handles the situation where <a class="el" href="classipc_1_1transport_1_1struc_1_1sync__io_1_1Channel.html#a95cfe30e685e828d62318c9b2bc4b137" title="Starts falsy; becomes forever truthy (with a specific Error_code that will not change thereafter) whe...">m_channel_err_code_or_ok</a> is falsy, and processing has found a new error condition.  <a href="classipc_1_1transport_1_1struc_1_1sync__io_1_1Channel.html#ad3f5d174c65db9d5ec3b14769fb9574a">More...</a><br /></td></tr>
<tr class="separator:ad3f5d174c65db9d5ec3b14769fb9574a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae2a7cdf855b3cdcab1a2e1cd74834cc4"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classipc_1_1transport_1_1struc_1_1sync__io_1_1Channel.html#ae2a7cdf855b3cdcab1a2e1cd74834cc4">check_not_started_ops</a> (<a class="el" href="namespaceipc_1_1util.html#ae6ac47812a90d1287c61e0b7de7bc4f5">util::String_view</a> context) const</td></tr>
<tr class="memdesc:ae2a7cdf855b3cdcab1a2e1cd74834cc4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Helper that returns <code>true</code> if and only if <a class="el" href="classipc_1_1transport_1_1struc_1_1sync__io_1_1Channel.html#a6e4f8c4207fcf678b4cfc785707d3dce" title="Sets up the sync_io-pattern interaction between *this and the user&#39;s event loop; required before asyn...">start_ops()</a> has not yet been called.  <a href="classipc_1_1transport_1_1struc_1_1sync__io_1_1Channel.html#ae2a7cdf855b3cdcab1a2e1cd74834cc4">More...</a><br /></td></tr>
<tr class="separator:ae2a7cdf855b3cdcab1a2e1cd74834cc4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abeb37ac07422166123553920393d5ab4"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classipc_1_1transport_1_1struc_1_1sync__io_1_1Channel.html#abeb37ac07422166123553920393d5ab4">check_prior_error</a> (<a class="el" href="namespaceipc_1_1util.html#ae6ac47812a90d1287c61e0b7de7bc4f5">util::String_view</a> context) const</td></tr>
<tr class="memdesc:abeb37ac07422166123553920393d5ab4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Helper for some public APIs to use at the top: ensures that no prior error has been detected (by incoming-direction processing or <a class="el" href="classipc_1_1transport_1_1struc_1_1sync__io_1_1Channel.html#a0dc388e18b0fc0fa2d8ad0a6953fb039" title="See Async_io_obj counterpart.">send()</a>); returns <code>true</code> if not; <code>false</code> if so.  <a href="classipc_1_1transport_1_1struc_1_1sync__io_1_1Channel.html#abeb37ac07422166123553920393d5ab4">More...</a><br /></td></tr>
<tr class="separator:abeb37ac07422166123553920393d5ab4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae6b2691d6471330d8b7cc7e8e9320054"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classipc_1_1transport_1_1struc_1_1sync__io_1_1Channel.html#ae6b2691d6471330d8b7cc7e8e9320054">check_phase_and_prior_error</a> (<a class="el" href="classipc_1_1transport_1_1struc_1_1sync__io_1_1Channel.html#a5a3833cd141802041551db21198ac319">Phase</a> required_phase, <a class="el" href="namespaceipc_1_1util.html#ae6ac47812a90d1287c61e0b7de7bc4f5">util::String_view</a> context) const</td></tr>
<tr class="memdesc:ae6b2691d6471330d8b7cc7e8e9320054"><td class="mdescLeft">&#160;</td><td class="mdescRight">Helper for most public APIs to use at the top: ensures <a class="el" href="classipc_1_1transport_1_1struc_1_1sync__io_1_1Channel.html#abeb37ac07422166123553920393d5ab4" title="Helper for some public APIs to use at the top: ensures that no prior error has been detected (by inco...">check_prior_error()</a> passes, and that <a class="el" href="classipc_1_1transport_1_1struc_1_1sync__io_1_1Channel.html#afca9a3012b2f41d635381a5a13ddd7c1" title="Phase (w/r/t log-in or lack thereof) of *this peer.">m_phase</a> equals <code>required_phase</code>; returns <code>true</code> if not; <code>false</code> if so.  <a href="classipc_1_1transport_1_1struc_1_1sync__io_1_1Channel.html#ae6b2691d6471330d8b7cc7e8e9320054">More...</a><br /></td></tr>
<tr class="separator:ae6b2691d6471330d8b7cc7e8e9320054"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2552eada8012c4a8c4d2fc5f02e9f69b"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classipc_1_1transport_1_1struc_1_1sync__io_1_1Channel.html#a2552eada8012c4a8c4d2fc5f02e9f69b">expect_msgs_impl</a> (<a class="el" href="classipc_1_1transport_1_1struc_1_1sync__io_1_1Channel.html#a4ab778bce8d7e6e84788879fedc62745">Msgs_in</a> *qd_msgs, bool one_off, <a class="el" href="classipc_1_1transport_1_1struc_1_1sync__io_1_1Channel.html#aa40c3ec3f45cdfea9360f7f35b9ade3c">Msg_which_in</a> which, <a class="el" href="classipc_1_1transport_1_1struc_1_1sync__io_1_1Channel.html#a583ccd4bb6b1aefb09d77e5709aef5b4">On_msg_func_ptr</a> &amp;&amp;on_msg_func)</td></tr>
<tr class="memdesc:a2552eada8012c4a8c4d2fc5f02e9f69b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Core of <a class="el" href="classipc_1_1transport_1_1struc_1_1sync__io_1_1Channel.html#a5fc489b9abefe5ab676f6991d6d03f0d" title="Registers the expectation (which may be immediately met) of up to 1 notification in-message whose Msg...">expect_msg()</a>, <a class="el" href="classipc_1_1transport_1_1struc_1_1sync__io_1_1Channel.html#a62f52488ba20dd6c69dfc1abadb2d69f" title="Registers the expectation (some of which may be immediately met) of 0+ notification in-messages whose...">expect_msgs()</a>, and <a class="el" href="classipc_1_1transport_1_1struc_1_1sync__io_1_1Channel.html#a996e06f75024e10987eb9cf62e096eec" title="In log-in phase as server only: Registers the expectation (which may be immediately met) of up to 1 l...">expect_log_in_request()</a>.  <a href="classipc_1_1transport_1_1struc_1_1sync__io_1_1Channel.html#a2552eada8012c4a8c4d2fc5f02e9f69b">More...</a><br /></td></tr>
<tr class="separator:a2552eada8012c4a8c4d2fc5f02e9f69b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aafaf244b9483c724eaba1d6bee561035"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classipc_1_1transport_1_1struc_1_1sync__io_1_1Channel.html#aafaf244b9483c724eaba1d6bee561035">send_impl</a> (const <a class="el" href="classipc_1_1transport_1_1struc_1_1sync__io_1_1Channel.html#a83fb4462a8d4045bdb56b694bf80393c">Msg_out</a> &amp;msg, const <a class="el" href="classipc_1_1transport_1_1struc_1_1sync__io_1_1Channel.html#ac3da0ac1306b63c9e38c47b8c31e3cd2">Msg_in</a> *originating_msg_or_null, <a class="el" href="namespaceipc.html#aa3192e586cc45d3e7c22463bf2760f89">Error_code</a> *err_code, const <a class="el" href="classipc_1_1transport_1_1struc_1_1sync__io_1_1Channel.html#a583ccd4bb6b1aefb09d77e5709aef5b4">On_msg_func_ptr</a> &amp;on_rsp_func_or_null, <a class="el" href="classipc_1_1transport_1_1struc_1_1Channel__base.html#adcf24fa51747ed83c4b6427fbf44fecf">msg_id_out_t</a> *id_unless_one_off)</td></tr>
<tr class="memdesc:aafaf244b9483c724eaba1d6bee561035"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classipc_1_1transport_1_1struc_1_1sync__io_1_1Channel.html#a0dc388e18b0fc0fa2d8ad0a6953fb039" title="See Async_io_obj counterpart.">send()</a> and <a class="el" href="classipc_1_1transport_1_1struc_1_1sync__io_1_1Channel.html#a26dc83067e005be38567199cbedd7f19" title="See Async_io_obj counterpart; though naturally on_rsp_func() is invoked in the sync_io-pattern fashio...">async_request()</a> implementation.  <a href="classipc_1_1transport_1_1struc_1_1sync__io_1_1Channel.html#aafaf244b9483c724eaba1d6bee561035">More...</a><br /></td></tr>
<tr class="separator:aafaf244b9483c724eaba1d6bee561035"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0550bcab7578fcd9aa90a4add39eb3c7"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classipc_1_1transport_1_1struc_1_1sync__io_1_1Channel.html#a0550bcab7578fcd9aa90a4add39eb3c7">send_core</a> (const <a class="el" href="classipc_1_1transport_1_1struc_1_1sync__io_1_1Channel.html#acbf3e5dbf6879e358f0596633e1428e0">Msg_mdt_out</a> &amp;mdt, const <a class="el" href="classipc_1_1transport_1_1struc_1_1sync__io_1_1Channel.html#a984b6afa0f437c72aca5a1ba97f33a7f">Msg_out_impl</a> *msg, <a class="el" href="namespaceipc.html#aa3192e586cc45d3e7c22463bf2760f89">Error_code</a> *err_code_or_ignore)</td></tr>
<tr class="memdesc:a0550bcab7578fcd9aa90a4add39eb3c7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Core of <a class="el" href="classipc_1_1transport_1_1struc_1_1sync__io_1_1Channel.html#a0dc388e18b0fc0fa2d8ad0a6953fb039" title="See Async_io_obj counterpart.">send()</a> or internal-message-send: Serializes the given structured out-messages (metadata out-message; user out-message optionally) and <code>Owned_channel::send*()</code>s the result (synchronously).  <a href="classipc_1_1transport_1_1struc_1_1sync__io_1_1Channel.html#a0550bcab7578fcd9aa90a4add39eb3c7">More...</a><br /></td></tr>
<tr class="separator:a0550bcab7578fcd9aa90a4add39eb3c7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae43681c46951acd7e3c06d3cd73854f6"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classipc_1_1transport_1_1struc_1_1sync__io_1_1Channel.html#ae43681c46951acd7e3c06d3cd73854f6">check_unsendable</a> (const <a class="el" href="classipc_1_1transport_1_1struc_1_1sync__io_1_1Channel.html#a83fb4462a8d4045bdb56b694bf80393c">Msg_out</a> &amp;msg) const</td></tr>
<tr class="memdesc:ae43681c46951acd7e3c06d3cd73854f6"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classipc_1_1transport_1_1struc_1_1sync__io_1_1Channel.html#a0dc388e18b0fc0fa2d8ad0a6953fb039" title="See Async_io_obj counterpart.">send()</a> and <a class="el" href="classipc_1_1transport_1_1struc_1_1sync__io_1_1Channel.html#a26dc83067e005be38567199cbedd7f19" title="See Async_io_obj counterpart; though naturally on_rsp_func() is invoked in the sync_io-pattern fashio...">async_request()</a> helper that returns <code>true</code> if and only if <code>msg</code> contains a native handle, but <a class="el" href="classipc_1_1transport_1_1struc_1_1sync__io_1_1Channel.html#a4abac89dbd4d26c79b7915990f751a76" title="See Async_io_obj counterpart.">Owned_channel</a> is compile-time-incapable of transporting them.  <a href="classipc_1_1transport_1_1struc_1_1sync__io_1_1Channel.html#ae43681c46951acd7e3c06d3cd73854f6">More...</a><br /></td></tr>
<tr class="separator:ae43681c46951acd7e3c06d3cd73854f6"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pri-attribs" name="pri-attribs"></a>
Private Attributes</h2></td></tr>
<tr class="memitem:a47816a05b0af2d8b5c26ecaf01b89b1f"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classipc_1_1transport_1_1struc_1_1sync__io_1_1Channel.html#a8a59bbc3c6a7191b316b23661d8ba6e3">Builder_config</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classipc_1_1transport_1_1struc_1_1sync__io_1_1Channel.html#a47816a05b0af2d8b5c26ecaf01b89b1f">m_struct_builder_config</a></td></tr>
<tr class="memdesc:a47816a05b0af2d8b5c26ecaf01b89b1f"><td class="mdescLeft">&#160;</td><td class="mdescRight">The builder engine config for out-messages: Small data store, such that the <a class="el" href="classipc_1_1transport_1_1struc_1_1Struct__builder.html" title="A documentation-only concept defining the behavior of an object capable of zero-copy-serializing,...">Struct_builder</a> <code>Builder_config::Builder</code> (really the containing class of <a class="el" href="classipc_1_1transport_1_1struc_1_1sync__io_1_1Channel.html#a8a59bbc3c6a7191b316b23661d8ba6e3" title="See Async_io_obj counterpart.">Builder_config</a>) main-ctor takes an object of this type, its contents being knobs controlling the behavior of the resulting <a class="el" href="classipc_1_1transport_1_1struc_1_1Struct__builder.html" title="A documentation-only concept defining the behavior of an object capable of zero-copy-serializing,...">Struct_builder</a>.  <a href="classipc_1_1transport_1_1struc_1_1sync__io_1_1Channel.html#a47816a05b0af2d8b5c26ecaf01b89b1f">More...</a><br /></td></tr>
<tr class="separator:a47816a05b0af2d8b5c26ecaf01b89b1f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa4cd0e7c721ee3af4d1faa2ada5ad646"><td class="memItemLeft" align="right" valign="top">const Builder_config::Builder::Session&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classipc_1_1transport_1_1struc_1_1sync__io_1_1Channel.html#aa4cd0e7c721ee3af4d1faa2ada5ad646">m_struct_lender_session</a></td></tr>
<tr class="memdesc:aa4cd0e7c721ee3af4d1faa2ada5ad646"><td class="mdescLeft">&#160;</td><td class="mdescRight">Value (possibly of size 0 depending on this type) to pass to <a class="el" href="classipc_1_1transport_1_1struc_1_1Msg__out.html#a91d2575343b28f83e22a71e7f7b3ff40" title="Returns the serialization in the form of a sequence of 1+ Blobs.">Msg_out::emit_serialization()</a> to indicate the opposing side of the <a class="el" href="classipc_1_1transport_1_1struc_1_1sync__io_1_1Channel.html#a4abac89dbd4d26c79b7915990f751a76" title="See Async_io_obj counterpart.">Owned_channel</a>.  <a href="classipc_1_1transport_1_1struc_1_1sync__io_1_1Channel.html#aa4cd0e7c721ee3af4d1faa2ada5ad646">More...</a><br /></td></tr>
<tr class="separator:aa4cd0e7c721ee3af4d1faa2ada5ad646"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af7ac60b2b7a7baf26a96cf4635d4c320"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classipc_1_1transport_1_1struc_1_1sync__io_1_1Channel.html#a14a7166b2f8c117ce6ddafe943d036fa">Reader_config</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classipc_1_1transport_1_1struc_1_1sync__io_1_1Channel.html#af7ac60b2b7a7baf26a96cf4635d4c320">m_struct_reader_config</a></td></tr>
<tr class="memdesc:af7ac60b2b7a7baf26a96cf4635d4c320"><td class="mdescLeft">&#160;</td><td class="mdescRight">Analogous to <a class="el" href="classipc_1_1transport_1_1struc_1_1sync__io_1_1Channel.html#a47816a05b0af2d8b5c26ecaf01b89b1f" title="The builder engine config for out-messages: Small data store, such that the Struct_builder Builder_co...">m_struct_builder_config</a> but for deserialization.  <a href="classipc_1_1transport_1_1struc_1_1sync__io_1_1Channel.html#af7ac60b2b7a7baf26a96cf4635d4c320">More...</a><br /></td></tr>
<tr class="separator:af7ac60b2b7a7baf26a96cf4635d4c320"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9a63c3620852f2354fe145364a73c688"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classipc_1_1transport_1_1struc_1_1sync__io_1_1Channel.html#a9a63c3620852f2354fe145364a73c688">m_started_ops</a></td></tr>
<tr class="memdesc:a9a63c3620852f2354fe145364a73c688"><td class="mdescLeft">&#160;</td><td class="mdescRight">Whether <a class="el" href="classipc_1_1transport_1_1struc_1_1sync__io_1_1Channel.html#a6e4f8c4207fcf678b4cfc785707d3dce" title="Sets up the sync_io-pattern interaction between *this and the user&#39;s event loop; required before asyn...">start_ops()</a> has been called yet or not.  <a href="classipc_1_1transport_1_1struc_1_1sync__io_1_1Channel.html#a9a63c3620852f2354fe145364a73c688">More...</a><br /></td></tr>
<tr class="separator:a9a63c3620852f2354fe145364a73c688"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad1fcc872d76e6a59321f5d67b2e0a70b"><td class="memItemLeft" align="right" valign="top">flow::async::Task_asio_err&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classipc_1_1transport_1_1struc_1_1sync__io_1_1Channel.html#ad1fcc872d76e6a59321f5d67b2e0a70b">m_on_err_func</a></td></tr>
<tr class="memdesc:ad1fcc872d76e6a59321f5d67b2e0a70b"><td class="mdescLeft">&#160;</td><td class="mdescRight">The channel-hosed error reporting handler.  <a href="classipc_1_1transport_1_1struc_1_1sync__io_1_1Channel.html#ad1fcc872d76e6a59321f5d67b2e0a70b">More...</a><br /></td></tr>
<tr class="separator:ad1fcc872d76e6a59321f5d67b2e0a70b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9c04f15d4d17cd43aca70136119e1d28"><td class="memItemLeft" align="right" valign="top">boost::array&lt; std::optional&lt; <a class="el" href="structipc_1_1transport_1_1struc_1_1sync__io_1_1Channel_1_1Msg__in__pipe.html">Msg_in_pipe</a> &gt;, 2 &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classipc_1_1transport_1_1struc_1_1sync__io_1_1Channel.html#a9c04f15d4d17cd43aca70136119e1d28">m_rcv_pipes</a></td></tr>
<tr class="memdesc:a9c04f15d4d17cd43aca70136119e1d28"><td class="mdescLeft">&#160;</td><td class="mdescRight">1 or 2 active (via <code>optional</code>) <code>struct</code>s containing policy and state w/r/t receipt of low-level (unstructured) messages with the aim to complete the next structured in-message(s).  <a href="classipc_1_1transport_1_1struc_1_1sync__io_1_1Channel.html#a9c04f15d4d17cd43aca70136119e1d28">More...</a><br /></td></tr>
<tr class="separator:a9c04f15d4d17cd43aca70136119e1d28"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0986d9820ae3a1203014d94c193b4ca4"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classipc_1_1transport_1_1struc_1_1sync__io_1_1Channel.html#abb3be9330a898ce542afd778d8e42a49">On_unexpected_response_func</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classipc_1_1transport_1_1struc_1_1sync__io_1_1Channel.html#a0986d9820ae3a1203014d94c193b4ca4">m_on_unexpected_response_func_or_empty</a></td></tr>
<tr class="memdesc:a0986d9820ae3a1203014d94c193b4ca4"><td class="mdescLeft">&#160;</td><td class="mdescRight">See <a class="el" href="classipc_1_1transport_1_1struc_1_1sync__io_1_1Channel.html#a5c62d2a374a3a98e7fa0aef01bf8a774" title="See Async_io_obj counterpart; though naturally on_func() is invoked in the sync_io-pattern fashion.">set_unexpected_response_handler()</a>.  <a href="classipc_1_1transport_1_1struc_1_1sync__io_1_1Channel.html#a0986d9820ae3a1203014d94c193b4ca4">More...</a><br /></td></tr>
<tr class="separator:a0986d9820ae3a1203014d94c193b4ca4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a491a1a9eff4e277f3e5cd32c0178adbf"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classipc_1_1transport_1_1struc_1_1sync__io_1_1Channel.html#a86342fa9838aea7d49bbf3dd344445e2">On_remote_unexpected_response_func</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classipc_1_1transport_1_1struc_1_1sync__io_1_1Channel.html#a491a1a9eff4e277f3e5cd32c0178adbf">m_on_remote_unexpected_response_func_or_empty</a></td></tr>
<tr class="memdesc:a491a1a9eff4e277f3e5cd32c0178adbf"><td class="mdescLeft">&#160;</td><td class="mdescRight">See <a class="el" href="classipc_1_1transport_1_1struc_1_1sync__io_1_1Channel.html#a3fda370cc97c89a62f77a6fcf639cfd7" title="See Async_io_obj counterpart; though naturally on_func() is invoked in the sync_io-pattern fashion.">set_remote_unexpected_response_handler()</a>.  <a href="classipc_1_1transport_1_1struc_1_1sync__io_1_1Channel.html#a491a1a9eff4e277f3e5cd32c0178adbf">More...</a><br /></td></tr>
<tr class="separator:a491a1a9eff4e277f3e5cd32c0178adbf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a49e257338f9b20fd70c42142eb2db4f0"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespaceipc_1_1transport_1_1struc.html#a6751c05fb6582a34c7c47ac470c4a48b">Session_token</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classipc_1_1transport_1_1struc_1_1sync__io_1_1Channel.html#a49e257338f9b20fd70c42142eb2db4f0">m_session_token</a></td></tr>
<tr class="memdesc:a49e257338f9b20fd70c42142eb2db4f0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Session token: in <a class="el" href="classipc_1_1transport_1_1struc_1_1sync__io_1_1Channel.html#a5a3833cd141802041551db21198ac319aa0ea4326c39b88d0b32f90d5ce081220" title="Regular-operation phase: the general API (expect_msg(), etc.) is available.">Phase::S_LOGGED_IN</a> to send in every out-message and check-against every in-message; in log-in phase <em>as client</em> equals nil; in log-in phase <em>as server</em> it is auto-generated at construction.  <a href="classipc_1_1transport_1_1struc_1_1sync__io_1_1Channel.html#a49e257338f9b20fd70c42142eb2db4f0">More...</a><br /></td></tr>
<tr class="separator:a49e257338f9b20fd70c42142eb2db4f0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5132d96a55a628a7830c19c630390582"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classipc_1_1transport_1_1struc_1_1Channel__base.html#adcf24fa51747ed83c4b6427fbf44fecf">msg_id_out_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classipc_1_1transport_1_1struc_1_1sync__io_1_1Channel.html#a5132d96a55a628a7830c19c630390582">m_snd_msg_next_id</a></td></tr>
<tr class="memdesc:a5132d96a55a628a7830c19c630390582"><td class="mdescLeft">&#160;</td><td class="mdescRight">Next out-message ID (for the next <a class="el" href="classipc_1_1transport_1_1struc_1_1sync__io_1_1Channel.html#a0dc388e18b0fc0fa2d8ad0a6953fb039" title="See Async_io_obj counterpart.">send()</a> or <a class="el" href="classipc_1_1transport_1_1struc_1_1sync__io_1_1Channel.html#a26dc83067e005be38567199cbedd7f19" title="See Async_io_obj counterpart; though naturally on_rsp_func() is invoked in the sync_io-pattern fashio...">async_request()</a>).  <a href="classipc_1_1transport_1_1struc_1_1sync__io_1_1Channel.html#a5132d96a55a628a7830c19c630390582">More...</a><br /></td></tr>
<tr class="separator:a5132d96a55a628a7830c19c630390582"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afca9a3012b2f41d635381a5a13ddd7c1"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classipc_1_1transport_1_1struc_1_1sync__io_1_1Channel.html#a5a3833cd141802041551db21198ac319">Phase</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classipc_1_1transport_1_1struc_1_1sync__io_1_1Channel.html#afca9a3012b2f41d635381a5a13ddd7c1">m_phase</a></td></tr>
<tr class="memdesc:afca9a3012b2f41d635381a5a13ddd7c1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Phase (w/r/t log-in or lack thereof) of <code>*this</code> peer.  <a href="classipc_1_1transport_1_1struc_1_1sync__io_1_1Channel.html#afca9a3012b2f41d635381a5a13ddd7c1">More...</a><br /></td></tr>
<tr class="separator:afca9a3012b2f41d635381a5a13ddd7c1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa14373afb4601567d1640f7b0b3faa45"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classipc_1_1transport_1_1struc_1_1sync__io_1_1Channel.html#aa14373afb4601567d1640f7b0b3faa45">m_phase_log_in_started</a></td></tr>
<tr class="memdesc:aa14373afb4601567d1640f7b0b3faa45"><td class="mdescLeft">&#160;</td><td class="mdescRight">Used when <a class="el" href="classipc_1_1transport_1_1struc_1_1sync__io_1_1Channel.html#afca9a3012b2f41d635381a5a13ddd7c1" title="Phase (w/r/t log-in or lack thereof) of *this peer.">m_phase</a> is <a class="el" href="classipc_1_1transport_1_1struc_1_1sync__io_1_1Channel.html#a5a3833cd141802041551db21198ac319ab64edfa66dd4c58d7aa1c3a30e142706" title="Logging-in phase, as server process: The general API (expect_msg(), etc.) is unavailable; only expect...">Phase::S_SRV_LOG_IN</a>, this starts <code>false</code> and is changed to <code>true</code> at thread-U call of <a class="el" href="classipc_1_1transport_1_1struc_1_1sync__io_1_1Channel.html#a996e06f75024e10987eb9cf62e096eec" title="In log-in phase as server only: Registers the expectation (which may be immediately met) of up to 1 l...">expect_log_in_request()</a>; if already <code>true</code> then a 2nd (illegal) <a class="el" href="classipc_1_1transport_1_1struc_1_1sync__io_1_1Channel.html#a996e06f75024e10987eb9cf62e096eec" title="In log-in phase as server only: Registers the expectation (which may be immediately met) of up to 1 l...">expect_log_in_request()</a> call has been made and shall be ignored (no-op, return sentinel).  <a href="classipc_1_1transport_1_1struc_1_1sync__io_1_1Channel.html#aa14373afb4601567d1640f7b0b3faa45">More...</a><br /></td></tr>
<tr class="separator:aa14373afb4601567d1640f7b0b3faa45"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a95cfe30e685e828d62318c9b2bc4b137"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespaceipc.html#aa3192e586cc45d3e7c22463bf2760f89">Error_code</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classipc_1_1transport_1_1struc_1_1sync__io_1_1Channel.html#a95cfe30e685e828d62318c9b2bc4b137">m_channel_err_code_or_ok</a></td></tr>
<tr class="memdesc:a95cfe30e685e828d62318c9b2bc4b137"><td class="mdescLeft">&#160;</td><td class="mdescRight">Starts falsy; becomes forever truthy (with a specific <a class="el" href="namespaceipc.html#aa3192e586cc45d3e7c22463bf2760f89" title="Short-hand for boost.interprocess namespace.">Error_code</a> that will not change thereafter) when one of the following detects the first channel-hosing condition: <a class="el" href="classipc_1_1transport_1_1struc_1_1sync__io_1_1Channel.html#a0dc388e18b0fc0fa2d8ad0a6953fb039" title="See Async_io_obj counterpart.">send()</a> or <a class="el" href="classipc_1_1transport_1_1struc_1_1sync__io_1_1Channel.html#a26dc83067e005be38567199cbedd7f19" title="See Async_io_obj counterpart; though naturally on_rsp_func() is invoked in the sync_io-pattern fashio...">async_request()</a>, on-receive handler <a class="el" href="classipc_1_1transport_1_1struc_1_1sync__io_1_1Channel.html#af546fc0ab4d0ddca0a857c57decd0620" title="To execute upon completing an m_channel.async_receive_*() of an expected lead message along the given...">rcv_on_async_read_lead_msg()</a> or <a class="el" href="classipc_1_1transport_1_1struc_1_1sync__io_1_1Channel.html#aa83fd6e35057876e2f5173df53e73371" title="Same as rcv_on_async_read_lead_msg() but for an expected continuation message instead of lead.">rcv_on_async_read_continuation_msg()</a>.  <a href="classipc_1_1transport_1_1struc_1_1sync__io_1_1Channel.html#a95cfe30e685e828d62318c9b2bc4b137">More...</a><br /></td></tr>
<tr class="separator:a95cfe30e685e828d62318c9b2bc4b137"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abf9a2118d887439717e17d0515be3e43"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classipc_1_1transport_1_1struc_1_1sync__io_1_1Channel.html#a3d4c8da3dd620d113479f5c6a3f96c3a">Expecting_response_map</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classipc_1_1transport_1_1struc_1_1sync__io_1_1Channel.html#abf9a2118d887439717e17d0515be3e43">m_rcv_expecting_response_map</a></td></tr>
<tr class="memdesc:abf9a2118d887439717e17d0515be3e43"><td class="mdescLeft">&#160;</td><td class="mdescRight">Map storing current policy for expecting responses. See <a class="el" href="classipc_1_1transport_1_1struc_1_1sync__io_1_1Channel.html#a3d4c8da3dd620d113479f5c6a3f96c3a" title="Table mapping originating out-message to the policy for handling an in-message that indicates that ou...">Expecting_response_map</a> doc header for details.  <a href="classipc_1_1transport_1_1struc_1_1sync__io_1_1Channel.html#abf9a2118d887439717e17d0515be3e43">More...</a><br /></td></tr>
<tr class="separator:abf9a2118d887439717e17d0515be3e43"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a072fb8667ba55ff69230fd48d400ee88"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classipc_1_1transport_1_1struc_1_1sync__io_1_1Channel.html#a8d1ffe78546eb31fd41df6784a26868c">Expecting_msg_map</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classipc_1_1transport_1_1struc_1_1sync__io_1_1Channel.html#a072fb8667ba55ff69230fd48d400ee88">m_rcv_expecting_msg_map</a></td></tr>
<tr class="memdesc:a072fb8667ba55ff69230fd48d400ee88"><td class="mdescLeft">&#160;</td><td class="mdescRight">Map storing current policy for expecting non-response messages.  <a href="classipc_1_1transport_1_1struc_1_1sync__io_1_1Channel.html#a072fb8667ba55ff69230fd48d400ee88">More...</a><br /></td></tr>
<tr class="separator:a072fb8667ba55ff69230fd48d400ee88"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a26d39d4e1e2c304ef803b3721bde86f0"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classipc_1_1transport_1_1struc_1_1sync__io_1_1Channel.html#ad77261f31055f4151c70225c3fa1da2e">msg_id_in_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classipc_1_1transport_1_1struc_1_1sync__io_1_1Channel.html#a26d39d4e1e2c304ef803b3721bde86f0">m_rcv_msg_next_id</a></td></tr>
<tr class="memdesc:a26d39d4e1e2c304ef803b3721bde86f0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Next expected in-message ID (sequence #), incremented from initial value 1 to 2, 3, ... on in-order message receipt.  <a href="classipc_1_1transport_1_1struc_1_1sync__io_1_1Channel.html#a26d39d4e1e2c304ef803b3721bde86f0">More...</a><br /></td></tr>
<tr class="separator:a26d39d4e1e2c304ef803b3721bde86f0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1218e59c91d08758cd997d77913abd5a"><td class="memItemLeft" align="right" valign="top">std::optional&lt; <a class="el" href="classipc_1_1transport_1_1struc_1_1sync__io_1_1Channel.html#a26594894094e4fa03b3c1dacd2e0f351">Reassembly_q</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classipc_1_1transport_1_1struc_1_1sync__io_1_1Channel.html#a1218e59c91d08758cd997d77913abd5a">m_rcv_reassembly_q</a></td></tr>
<tr class="memdesc:a1218e59c91d08758cd997d77913abd5a"><td class="mdescLeft">&#160;</td><td class="mdescRight">When <code>Owned_channel::S_HAS_2_PIPES</code>, stores the reassembly queue of in-messages to feed into <a class="el" href="classipc_1_1transport_1_1struc_1_1sync__io_1_1Channel.html#ae9f5a798718d98523342acf55400d628" title="Queues of in-messages, keyed by Msg_which_in, each in msg_id_in_t (sequence #) order,...">m_rcv_pending_msgs</a> once in-messages filling the <a class="el" href="classipc_1_1transport_1_1struc_1_1sync__io_1_1Channel.html#ad77261f31055f4151c70225c3fa1da2e" title="Clarifying short-hand for incoming-message IDs.">msg_id_in_t</a> (sequence #) gap between <a class="el" href="classipc_1_1transport_1_1struc_1_1sync__io_1_1Channel.html#a26d39d4e1e2c304ef803b3721bde86f0" title="Next expected in-message ID (sequence #), incremented from initial value 1 to 2, 3,...">m_rcv_msg_next_id</a> and <code>m_rcv_reassembly_q.front()</code> is filled.  <a href="classipc_1_1transport_1_1struc_1_1sync__io_1_1Channel.html#a1218e59c91d08758cd997d77913abd5a">More...</a><br /></td></tr>
<tr class="separator:a1218e59c91d08758cd997d77913abd5a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae9f5a798718d98523342acf55400d628"><td class="memItemLeft" align="right" valign="top">boost::unordered_map&lt; <a class="el" href="classipc_1_1transport_1_1struc_1_1sync__io_1_1Channel.html#aa40c3ec3f45cdfea9360f7f35b9ade3c">Msg_which_in</a>, <a class="el" href="classipc_1_1transport_1_1struc_1_1sync__io_1_1Channel.html#a2eed5db328a8c45ab16a875617a172c7">Msg_in_q</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classipc_1_1transport_1_1struc_1_1sync__io_1_1Channel.html#ae9f5a798718d98523342acf55400d628">m_rcv_pending_msgs</a></td></tr>
<tr class="memdesc:ae9f5a798718d98523342acf55400d628"><td class="mdescLeft">&#160;</td><td class="mdescRight">Queues of in-messages, keyed by <a class="el" href="classipc_1_1transport_1_1struc_1_1sync__io_1_1Channel.html#aa40c3ec3f45cdfea9360f7f35b9ade3c" title="See Async_io_obj counterpart.">Msg_which_in</a>, each in <a class="el" href="classipc_1_1transport_1_1struc_1_1sync__io_1_1Channel.html#ad77261f31055f4151c70225c3fa1da2e" title="Clarifying short-hand for incoming-message IDs.">msg_id_in_t</a> (sequence #) order, for which no <a class="el" href="classipc_1_1transport_1_1struc_1_1sync__io_1_1Channel.html#aa40c3ec3f45cdfea9360f7f35b9ade3c" title="See Async_io_obj counterpart.">Msg_which_in</a> handler has yet been registered by the user (<a class="el" href="classipc_1_1transport_1_1struc_1_1sync__io_1_1Channel.html#a5fc489b9abefe5ab676f6991d6d03f0d" title="Registers the expectation (which may be immediately met) of up to 1 notification in-message whose Msg...">expect_msg()</a>, <a class="el" href="classipc_1_1transport_1_1struc_1_1sync__io_1_1Channel.html#a62f52488ba20dd6c69dfc1abadb2d69f" title="Registers the expectation (some of which may be immediately met) of 0+ notification in-messages whose...">expect_msgs()</a>, <a class="el" href="classipc_1_1transport_1_1struc_1_1sync__io_1_1Channel.html#a996e06f75024e10987eb9cf62e096eec" title="In log-in phase as server only: Registers the expectation (which may be immediately met) of up to 1 l...">expect_log_in_request()</a>).  <a href="classipc_1_1transport_1_1struc_1_1sync__io_1_1Channel.html#ae9f5a798718d98523342acf55400d628">More...</a><br /></td></tr>
<tr class="separator:ae9f5a798718d98523342acf55400d628"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abe17c6f98af890eaf522c97eb21e2e35"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classipc_1_1transport_1_1struc_1_1sync__io_1_1Channel.html#a4abac89dbd4d26c79b7915990f751a76">Owned_channel</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classipc_1_1transport_1_1struc_1_1sync__io_1_1Channel.html#abe17c6f98af890eaf522c97eb21e2e35">m_channel</a></td></tr>
<tr class="memdesc:abe17c6f98af890eaf522c97eb21e2e35"><td class="mdescLeft">&#160;</td><td class="mdescRight">The <a class="el" href="classipc_1_1transport_1_1struc_1_1sync__io_1_1Channel.html" title="sync_io-pattern counterpart to async-I/O-pattern transport::struc::Channel.">Channel</a> taken-over in ctor, lifetime until dtor.  <a href="classipc_1_1transport_1_1struc_1_1sync__io_1_1Channel.html#abe17c6f98af890eaf522c97eb21e2e35">More...</a><br /></td></tr>
<tr class="separator:abe17c6f98af890eaf522c97eb21e2e35"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2c0013237f845e5589cf0063886c7431"><td class="memItemLeft" align="right" valign="top">std::vector&lt; boost::movelib::unique_ptr&lt; <a class="el" href="namespaceipc_1_1util.html#a31e67d3a017477a04b313927e2f2c733">util::Task</a> &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classipc_1_1transport_1_1struc_1_1sync__io_1_1Channel.html#a2c0013237f845e5589cf0063886c7431">m_sync_io_handlers</a></td></tr>
<tr class="memdesc:a2c0013237f845e5589cf0063886c7431"><td class="mdescLeft">&#160;</td><td class="mdescRight">The handlers as pushed by <a class="el" href="classipc_1_1transport_1_1struc_1_1sync__io_1_1Channel.html#a126c0d7ee5fcab20dc8c87884fdd7597" title="Record handler to invoke in handlers_poll() soon.">handlers_post()</a> to be flushed via <a class="el" href="classipc_1_1transport_1_1struc_1_1sync__io_1_1Channel.html#a3a0adf8ce8fc29ec55b4c8c30886c1fc" title="Executes what was recorded recently in handlers_post().">handlers_poll()</a> (internally by <code>*this</code>).  <a href="classipc_1_1transport_1_1struc_1_1sync__io_1_1Channel.html#a2c0013237f845e5589cf0063886c7431">More...</a><br /></td></tr>
<tr class="separator:a2c0013237f845e5589cf0063886c7431"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="related" name="related"></a>
Related Functions</h2></td></tr>
<tr><td class="ititle" colspan="2"><p >(Note that these are not member functions.) </p>
</td></tr>
<tr class="memitem:a0351bb14f40312b30e6cae4927f3373b"><td class="memTemplParams" colspan="2">template&lt;typename Channel_obj , typename Message_body , typename Struct_builder_config , typename Struct_reader_config &gt; </td></tr>
<tr class="memitem:a0351bb14f40312b30e6cae4927f3373b"><td class="memTemplItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classipc_1_1transport_1_1struc_1_1sync__io_1_1Channel.html#a0351bb14f40312b30e6cae4927f3373b">operator&lt;&lt;</a> (std::ostream &amp;os, const <a class="el" href="classipc_1_1transport_1_1struc_1_1sync__io_1_1Channel.html">Channel</a>&lt; Channel_obj, Message_body, Struct_builder_config, Struct_reader_config &gt; &amp;val)</td></tr>
<tr class="memdesc:a0351bb14f40312b30e6cae4927f3373b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Prints string representation of the given <a class="el" href="classipc_1_1transport_1_1struc_1_1sync__io_1_1Channel.html" title="sync_io-pattern counterpart to async-I/O-pattern transport::struc::Channel.">struc::sync_io::Channel</a> to the given <code>ostream</code>.  <a href="classipc_1_1transport_1_1struc_1_1sync__io_1_1Channel.html#a0351bb14f40312b30e6cae4927f3373b">More...</a><br /></td></tr>
<tr class="separator:a0351bb14f40312b30e6cae4927f3373b"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="inherited" name="inherited"></a>
Additional Inherited Members</h2></td></tr>
<tr class="inherit_header pub_static_attribs_classipc_1_1transport_1_1struc_1_1Channel__base"><td colspan="2" onclick="javascript:toggleInherit('pub_static_attribs_classipc_1_1transport_1_1struc_1_1Channel__base')"><img src="closed.png" alt="-"/>&#160;Static Public Attributes inherited from <a class="el" href="classipc_1_1transport_1_1struc_1_1Channel__base.html">ipc::transport::struc::Channel_base</a></td></tr>
<tr class="memitem:ab0eb05b5fb52364c99868a8535aaf26e inherit pub_static_attribs_classipc_1_1transport_1_1struc_1_1Channel__base"><td class="memItemLeft" align="right" valign="top">static constexpr <a class="el" href="structipc_1_1transport_1_1struc_1_1Channel__base_1_1Serialize__via__heap.html">Serialize_via_heap</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classipc_1_1transport_1_1struc_1_1Channel__base.html#ab0eb05b5fb52364c99868a8535aaf26e">S_SERIALIZE_VIA_HEAP</a> = {}</td></tr>
<tr class="memdesc:ab0eb05b5fb52364c99868a8535aaf26e inherit pub_static_attribs_classipc_1_1transport_1_1struc_1_1Channel__base"><td class="mdescLeft">&#160;</td><td class="mdescRight">The sole value of the tag type <a class="el" href="structipc_1_1transport_1_1struc_1_1Channel__base_1_1Serialize__via__heap.html" title="Tag type for ctor selection: Backing memory for serialization comes from fixed-size segment allocatio...">Serialize_via_heap</a>.  <a href="classipc_1_1transport_1_1struc_1_1Channel__base.html#ab0eb05b5fb52364c99868a8535aaf26e">More...</a><br /></td></tr>
<tr class="separator:ab0eb05b5fb52364c99868a8535aaf26e inherit pub_static_attribs_classipc_1_1transport_1_1struc_1_1Channel__base"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9bdb94c1ba4fac92fbbd0f843e8525ba inherit pub_static_attribs_classipc_1_1transport_1_1struc_1_1Channel__base"><td class="memItemLeft" align="right" valign="top">static constexpr <a class="el" href="structipc_1_1transport_1_1struc_1_1Channel__base_1_1Serialize__via__session__shm.html">Serialize_via_session_shm</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classipc_1_1transport_1_1struc_1_1Channel__base.html#a9bdb94c1ba4fac92fbbd0f843e8525ba">S_SERIALIZE_VIA_SESSION_SHM</a> = {}</td></tr>
<tr class="memdesc:a9bdb94c1ba4fac92fbbd0f843e8525ba inherit pub_static_attribs_classipc_1_1transport_1_1struc_1_1Channel__base"><td class="mdescLeft">&#160;</td><td class="mdescRight">The sole value of the tag type <a class="el" href="structipc_1_1transport_1_1struc_1_1Channel__base_1_1Serialize__via__session__shm.html" title="Tag type for ctor selection: Backing RAM for serialization comes from a given session::Session&#39;s SHM ...">Serialize_via_session_shm</a>.  <a href="classipc_1_1transport_1_1struc_1_1Channel__base.html#a9bdb94c1ba4fac92fbbd0f843e8525ba">More...</a><br /></td></tr>
<tr class="separator:a9bdb94c1ba4fac92fbbd0f843e8525ba inherit pub_static_attribs_classipc_1_1transport_1_1struc_1_1Channel__base"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af732121649271d1368a2fb637917ce7b inherit pub_static_attribs_classipc_1_1transport_1_1struc_1_1Channel__base"><td class="memItemLeft" align="right" valign="top">static constexpr <a class="el" href="structipc_1_1transport_1_1struc_1_1Channel__base_1_1Serialize__via__app__shm.html">Serialize_via_app_shm</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classipc_1_1transport_1_1struc_1_1Channel__base.html#af732121649271d1368a2fb637917ce7b">S_SERIALIZE_VIA_APP_SHM</a> = {}</td></tr>
<tr class="memdesc:af732121649271d1368a2fb637917ce7b inherit pub_static_attribs_classipc_1_1transport_1_1struc_1_1Channel__base"><td class="mdescLeft">&#160;</td><td class="mdescRight">The sole value of the tag type <a class="el" href="structipc_1_1transport_1_1struc_1_1Channel__base_1_1Serialize__via__app__shm.html" title="Similar to Serialize_via_session_shm but assumes per-app-scope SHM-arena (as opposed to per-session-s...">Serialize_via_app_shm</a>.  <a href="classipc_1_1transport_1_1struc_1_1Channel__base.html#af732121649271d1368a2fb637917ce7b">More...</a><br /></td></tr>
<tr class="separator:af732121649271d1368a2fb637917ce7b inherit pub_static_attribs_classipc_1_1transport_1_1struc_1_1Channel__base"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><div class="compoundTemplParams">template&lt;typename Channel_obj, typename Message_body, typename Struct_builder_config, typename Struct_reader_config&gt;<br />
class ipc::transport::struc::sync_io::Channel&lt; Channel_obj, Message_body, Struct_builder_config, Struct_reader_config &gt;</div><p ><code><a class="el" href="namespaceipc_1_1transport_1_1struc_1_1sync__io.html" title="sync_io-pattern counterparts to async-I/O-pattern object types in parent namespace ipc::transport::st...">sync_io</a></code>-pattern counterpart to async-I/O-pattern <a class="el" href="classipc_1_1transport_1_1struc_1_1Channel.html" title="Owning and wrapping a pre-connected transport::Channel peer (an endpoint of an established channel ov...">transport::struc::Channel</a>. </p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classipc_1_1transport_1_1struc_1_1Channel.html" title="Owning and wrapping a pre-connected transport::Channel peer (an endpoint of an established channel ov...">transport::struc::Channel</a> and <a class="el" href="namespaceipc_1_1util_1_1sync__io.html" title="Contains common code, as well as important explanatory documentation in the following text,...">util::sync_io</a> doc headers. The latter describes the general pattern which we implement here; it also contrasts it with the async-I/O pattern, which the former implements. In general we recommend you use a <a class="el" href="classipc_1_1transport_1_1struc_1_1Channel.html" title="Owning and wrapping a pre-connected transport::Channel peer (an endpoint of an established channel ov...">transport::struc::Channel</a> rather than a <code>*this</code> &ndash; but you may have particular needs (summarized in <a class="el" href="namespaceipc_1_1util_1_1sync__io.html" title="Contains common code, as well as important explanatory documentation in the following text,...">util::sync_io</a> doc header) that would make you decide otherwise.</dd></dl>
<p>All notes on functionality in <a class="el" href="classipc_1_1transport_1_1struc_1_1Channel.html" title="Owning and wrapping a pre-connected transport::Channel peer (an endpoint of an established channel ov...">transport::struc::Channel</a> (a/k/a alias <a class="el" href="classipc_1_1transport_1_1struc_1_1sync__io_1_1Channel.html#a6dc83bd6057b7f00a19c5947d6baa7b7" title="Useful for generic programming, the async-I/O-pattern counterpart to *this type.">Channel::Async_io_obj</a>) doc header apply to us. The difference, as usual given <code><a class="el" href="namespaceipc_1_1transport_1_1struc_1_1sync__io.html" title="sync_io-pattern counterparts to async-I/O-pattern object types in parent namespace ipc::transport::st...">sync_io</a></code> and async-I/O mutual counterparts, is in how results are reported. Because <a class="el" href="classipc_1_1transport_1_1struc_1_1Channel.html" title="Owning and wrapping a pre-connected transport::Channel peer (an endpoint of an established channel ov...">struc::Channel</a> in general stands apart from the many concept impls of <code><a class="el" href="classipc_1_1transport_1_1Blob__sender.html" title="A documentation-only concept defining the behavior of an object capable of reliably/in-order sending ...">Blob_sender</a></code>, <code><a class="el" href="classipc_1_1transport_1_1Blob__receiver.html" title="A documentation-only concept defining the behavior of an object capable of reliably/in-order receivin...">Blob_receiver</a></code>, etc. &ndash; e.g., <a class="el" href="classipc_1_1transport_1_1Native__socket__stream.html" title="Implements both Native_handle_sender and Native_handle_receiver concepts by using a stream-oriented U...">Native_socket_stream</a> &ndash; it may be helpful to summarize how this <code><a class="el" href="namespaceipc_1_1transport_1_1struc_1_1sync__io.html" title="sync_io-pattern counterparts to async-I/O-pattern object types in parent namespace ipc::transport::st...">sync_io</a></code>-pattern type reports results. The APIs look somewhat different from those core-layer guys owing to the more complex mission statement here versus there.</p>
<ul>
<li><code>expect_*(..., F)</code>: This says you want messages of a certain type, and when one arrives to invoke <code>F(I)</code>, <code>I</code> being the in-message. However, depending on the API 1+ message(s) may already have been cached and are immediately available. These are synchronously emitted via an out-arg; for example <a class="el" href="classipc_1_1transport_1_1struc_1_1sync__io_1_1Channel.html#a62f52488ba20dd6c69dfc1abadb2d69f" title="Registers the expectation (some of which may be immediately met) of 0+ notification in-messages whose...">expect_msgs()</a> takes a list-of-in-messages out-arg. Depending on the API future messages may be relevant and will be emitted via <code>F()</code>.</li>
<li><code>async_request(M, ..., F)</code>: This says you want <code>M</code> sent and expect 1 or 0+ (depending on args) response(s), and when one arrives to invoke <code>F(I)</code>, <code>I</code> being a response. Since it is not possible to have received a response to a not-yet-sent out-message, that is just how it works. There are no synchronous out-args.</li>
<li><code>set_*unexpected_response_handler()</code>: If it's set, and an unexpected-response event occurs, this fires. If not, it doesn't. There are no synchronous out-args.</li>
<li><code>start_and_poll(F)</code>: This begins incoming-direction operation. <code>F()</code> is the on-error handler. It fires up to once per <code>*this</code> to indicate underlying <code>Owned_channel</code> or other channel-hosing error (including receiving graceful-close). An error may synchronously occur right then, plus any <code>expect_*()</code>- and <code><a class="el" href="classipc_1_1transport_1_1struc_1_1sync__io_1_1Channel.html#a26dc83067e005be38567199cbedd7f19" title="See Async_io_obj counterpart; though naturally on_rsp_func() is invoked in the sync_io-pattern fashio...">async_request()</a></code>-triggered in-messages may be synchronously detected. Therefore &ndash; and this is quite rare (singular as of this writing in Flow-IPC):<ul>
<li><code>start_and_poll(F)</code> may <em>synchronously</em> (!) call a number of queued-up (in a sense) handlers including:<ul>
<li><code>expect_*()</code> handlers;</li>
<li><code><a class="el" href="classipc_1_1transport_1_1struc_1_1sync__io_1_1Channel.html#a26dc83067e005be38567199cbedd7f19" title="See Async_io_obj counterpart; though naturally on_rsp_func() is invoked in the sync_io-pattern fashio...">async_request()</a></code> handlers;</li>
<li><code>set_*unexpected_response_handler()</code> handlers;</li>
<li>on-error handler <code>F()</code> itself.</li>
</ul>
</li>
</ul>
</li>
</ul>
<p >Tip: If you'd rather not worry about <code><a class="el" href="classipc_1_1transport_1_1struc_1_1sync__io_1_1Channel.html#a0c00bab2dad604dde176c4190553915c" title="Permanently memorizes the incoming-direction on-error handler, thus authorizing the emission of any i...">start_and_poll()</a></code>-executed handlers &ndash; except on-error handler which might occur regardless &ndash; then avoid calling <code>expect_*()</code>, <a class="el" href="classipc_1_1transport_1_1struc_1_1sync__io_1_1Channel.html#a26dc83067e005be38567199cbedd7f19" title="See Async_io_obj counterpart; though naturally on_rsp_func() is invoked in the sync_io-pattern fashio...">async_request()</a>, <code>set_*()</code> before <a class="el" href="classipc_1_1transport_1_1struc_1_1sync__io_1_1Channel.html#a0c00bab2dad604dde176c4190553915c" title="Permanently memorizes the incoming-direction on-error handler, thus authorizing the emission of any i...">start_and_poll()</a>. (No in-messages are ever dropped, so you won't "miss" something by registering an expectation too late.) That said there's nothing wrong per se with setting those things up before <a class="el" href="classipc_1_1transport_1_1struc_1_1sync__io_1_1Channel.html#a0c00bab2dad604dde176c4190553915c" title="Permanently memorizes the incoming-direction on-error handler, thus authorizing the emission of any i...">start_and_poll()</a> either. Just be ready for the <code>_and_poll</code> part.</p>
<h3>Implementation overview</h3>
<p >Like all <code><a class="el" href="namespaceipc_1_1transport_1_1struc_1_1sync__io.html" title="sync_io-pattern counterparts to async-I/O-pattern object types in parent namespace ipc::transport::st...">sync_io</a></code>-core object types, this one is essentially a linear state machine with no actual asynchronicity or concurrency. (Some <code><a class="el" href="namespaceipc_1_1transport_1_1struc_1_1sync__io.html" title="sync_io-pattern counterparts to async-I/O-pattern object types in parent namespace ipc::transport::st...">sync_io</a></code>s do need to start threads in order to perform unavoidable blocking operations &ndash; namely the <code>Blob_stream_mq_*</code> guys with at least the bipc MQ type which lacks an FD-tickling API &ndash; but this can be thought of similarly to a background kernel service. Anyway <a class="el" href="classipc_1_1transport_1_1struc_1_1sync__io_1_1Channel.html" title="sync_io-pattern counterpart to async-I/O-pattern transport::struc::Channel.">sync_io::Channel</a> doesn't even feature that caveat.)</p>
<p >So as with other <code><a class="el" href="namespaceipc_1_1transport_1_1struc_1_1sync__io.html" title="sync_io-pattern counterparts to async-I/O-pattern object types in parent namespace ipc::transport::st...">sync_io</a></code> cores, it's a linear sequence of API calls into <code>*this</code> that may not be mutually concurrent (when non-<code>const</code>). As with those others in this context an API call is either a method call (duh) or an async-wait <code>Event_wait_func</code> calling into <code>*this</code> via <code>(*on_active_ev_func)()</code>. Hence we don't care what thread a given thing runs in, as long as our user (e.g., <a class="el" href="classipc_1_1transport_1_1struc_1_1Channel.html" title="Owning and wrapping a pre-connected transport::Channel peer (an endpoint of an established channel ov...">transport::struc::Channel</a>) doesn't invoke things concurrently.</p>
<p >So it's "just" a matter of implementing each direction &ndash; outgoing (<a class="el" href="classipc_1_1transport_1_1struc_1_1sync__io_1_1Channel.html#a0dc388e18b0fc0fa2d8ad0a6953fb039" title="See Async_io_obj counterpart.">send()</a> et al), incoming (<code>expect_*()</code>, <a class="el" href="classipc_1_1transport_1_1struc_1_1sync__io_1_1Channel.html#a26dc83067e005be38567199cbedd7f19" title="See Async_io_obj counterpart; though naturally on_rsp_func() is invoked in the sync_io-pattern fashio...">async_request()</a>), and their (reasonably limited) interplay (e.g., <a class="el" href="classipc_1_1transport_1_1struc_1_1sync__io_1_1Channel.html#a26dc83067e005be38567199cbedd7f19" title="See Async_io_obj counterpart; though naturally on_rsp_func() is invoked in the sync_io-pattern fashio...">async_request()</a> conceptually = a <a class="el" href="classipc_1_1transport_1_1struc_1_1sync__io_1_1Channel.html#a0dc388e18b0fc0fa2d8ad0a6953fb039" title="See Async_io_obj counterpart.">send()</a> + registering expectation of particular future response in-message(s)).</p>
<h3>Implementation: layers</h3>
<p >In the outgoing direction, the layers involved are fairly straightforward: <a class="el" href="classipc_1_1transport_1_1struc_1_1sync__io_1_1Channel.html#a0dc388e18b0fc0fa2d8ad0a6953fb039" title="See Async_io_obj counterpart.">send()</a> is synchronous. When it is called, the zero-copy serialization of the structured out-message <a class="el" href="classipc_1_1transport_1_1struc_1_1sync__io_1_1Channel.html#a83fb4462a8d4045bdb56b694bf80393c" title="See Async_io_obj counterpart.">Msg_out</a> has been completed: the raw blobs comprised by it are easily accessible from the <a class="el" href="classipc_1_1transport_1_1struc_1_1sync__io_1_1Channel.html#a83fb4462a8d4045bdb56b694bf80393c" title="See Async_io_obj counterpart.">Msg_out</a> (<a class="el" href="classipc_1_1transport_1_1struc_1_1Msg__out.html#a91d2575343b28f83e22a71e7f7b3ff40" title="Returns the serialization in the form of a sequence of 1+ Blobs.">Msg_out::emit_serialization()</a>) passed to <a class="el" href="classipc_1_1transport_1_1struc_1_1sync__io_1_1Channel.html#a0dc388e18b0fc0fa2d8ad0a6953fb039" title="See Async_io_obj counterpart.">send()</a> (as is the optional <a class="el" href="namespaceipc_1_1transport.html#a7ee4551983d9df16ec16a3139bac50e8" title="Convenience alias for the commonly used type util::Native_handle.">Native_handle</a>). The 1+ blobs + the <a class="el" href="namespaceipc_1_1transport.html#a7ee4551983d9df16ec16a3139bac50e8" title="Convenience alias for the commonly used type util::Native_handle.">Native_handle</a> are synchronously <code>Channel::send_*()</code>ed, and then <a class="el" href="classipc_1_1transport_1_1struc_1_1sync__io_1_1Channel.html#a0dc388e18b0fc0fa2d8ad0a6953fb039" title="See Async_io_obj counterpart.">send()</a> returns. In addition, but still synchronously within <a class="el" href="classipc_1_1transport_1_1struc_1_1sync__io_1_1Channel.html#a0dc388e18b0fc0fa2d8ad0a6953fb039" title="See Async_io_obj counterpart.">send()</a>, each such user message is internally accompanied by another similarly-serialized message: the <em>metadata</em> message. This message, with a schema in structured_msg.capnp (a detail/ file), represents a <em>description</em> of the associated <a class="el" href="classipc_1_1transport_1_1struc_1_1sync__io_1_1Channel.html#a83fb4462a8d4045bdb56b694bf80393c" title="See Async_io_obj counterpart.">Msg_out</a>. Its schema is controlled by us and is sufficiently small to require just one segment (blob) and no <a class="el" href="namespaceipc_1_1transport.html#a7ee4551983d9df16ec16a3139bac50e8" title="Convenience alias for the commonly used type util::Native_handle.">Native_handle</a>. This contains information about the message (a/k/a metadata), notably: its message ID (discussed below), the ID of the message to which it responds (or 0 if unsolicited), and the session token. To summarize, then, <a class="el" href="classipc_1_1transport_1_1struc_1_1sync__io_1_1Channel.html#a0dc388e18b0fc0fa2d8ad0a6953fb039" title="See Async_io_obj counterpart.">send()</a> of a user message in fact sends exactly 1 metadata message (<a class="el" href="classipc_1_1transport_1_1struc_1_1Msg__mdt__out.html" title="Internally used (data-free) addendum on-top of Msg_out; really an alias to Msg_out&lt;schema::detail::St...">Msg_mdt_out</a>, a special-purpose sub-class of <a class="el" href="classipc_1_1transport_1_1struc_1_1Msg__out.html" title="A structured out-message suitable to be sent via struc::Channel::send().">Msg_out</a>, adding no data members but a convenient internally-used APIs to set its fields), across exactly 1 blob (segment), plus 1+ blobs (segments) serializing the user message. (<a class="el" href="classipc_1_1transport_1_1struc_1_1sync__io_1_1Channel.html#a26dc83067e005be38567199cbedd7f19" title="See Async_io_obj counterpart; though naturally on_rsp_func() is invoked in the sync_io-pattern fashio...">async_request()</a> = internally such a <a class="el" href="classipc_1_1transport_1_1struc_1_1sync__io_1_1Channel.html#a0dc388e18b0fc0fa2d8ad0a6953fb039" title="See Async_io_obj counterpart.">send()</a> more or less, plus registering that future in-message(s) with certain metadata content are expected.)</p>
<p >Lastly, for some special purposes, we sometimes send internal messages. An internal message consists of <em>only</em> the metadata (<a class="el" href="classipc_1_1transport_1_1struc_1_1Msg__mdt__out.html" title="Internally used (data-free) addendum on-top of Msg_out; really an alias to Msg_out&lt;schema::detail::St...">Msg_mdt_out</a>, alias <a class="el" href="classipc_1_1transport_1_1struc_1_1sync__io_1_1Channel.html#acbf3e5dbf6879e358f0596633e1428e0" title="Metadata message: internal-use out-message describing the associated Msg_out; or describing/containin...">Msg_mdt_out</a>), with the optional internal-message-body field filled-out, and no user message. Hence in this case exactly 1 <code>Blob</code> (segment) is sent. In the few cases where an internal message is required, internal code calls <a class="el" href="classipc_1_1transport_1_1struc_1_1sync__io_1_1Channel.html#a0550bcab7578fcd9aa90a4add39eb3c7" title="Core of send() or internal-message-send: Serializes the given structured out-messages (metadata out-m...">send_core()</a> directly (with the <a class="el" href="classipc_1_1transport_1_1struc_1_1sync__io_1_1Channel.html#a83fb4462a8d4045bdb56b694bf80393c" title="See Async_io_obj counterpart.">Msg_out</a> arg set to null); whereas a user message goes through <a class="el" href="classipc_1_1transport_1_1struc_1_1sync__io_1_1Channel.html#a0dc388e18b0fc0fa2d8ad0a6953fb039" title="See Async_io_obj counterpart.">send()</a> or <a class="el" href="classipc_1_1transport_1_1struc_1_1sync__io_1_1Channel.html#a26dc83067e005be38567199cbedd7f19" title="See Async_io_obj counterpart; though naturally on_rsp_func() is invoked in the sync_io-pattern fashio...">async_request()</a> which invokes <a class="el" href="classipc_1_1transport_1_1struc_1_1sync__io_1_1Channel.html#a0550bcab7578fcd9aa90a4add39eb3c7" title="Core of send() or internal-message-send: Serializes the given structured out-messages (metadata out-m...">send_core()</a> (with <a class="el" href="classipc_1_1transport_1_1struc_1_1sync__io_1_1Channel.html#a83fb4462a8d4045bdb56b694bf80393c" title="See Async_io_obj counterpart.">Msg_out</a> arg non-null but rather the user-supplied <a class="el" href="classipc_1_1transport_1_1struc_1_1sync__io_1_1Channel.html#a83fb4462a8d4045bdb56b694bf80393c" title="See Async_io_obj counterpart.">Msg_out</a>).</p>
<p >In the incoming direction, it is much more complex. Receiving a blob, or blob+handle pair, is by definition a (potentially) asynchronous operation; and a given structured in-message may consist of more than 1 blob/blob+handle pair. The zero-copy deserialization invoked by the user can only occur once all of them are received, so we must build up 1 given structured in-message over 1+ async-read ops and only emit the result (a newly allocated/cted <a class="el" href="classipc_1_1transport_1_1struc_1_1Msg__in.html" title="A structured in-message instance suitable as received and emittable (to user) by struc::Channel.">Msg_in</a> a/k/a <a class="el" href="classipc_1_1transport_1_1struc_1_1sync__io_1_1Channel.html#acde2b3866547a30958035203d9d89928" title="See Async_io_obj counterpart.">Msg_in_ptr</a>) to the user once the last of the 1+ async-read ops finishes. So that's 2 layers: async-read op at the <a class="el" href="classipc_1_1transport_1_1struc_1_1sync__io_1_1Channel.html#a4abac89dbd4d26c79b7915990f751a76" title="See Async_io_obj counterpart.">Owned_channel</a> level; then the structured level once a <a class="el" href="classipc_1_1transport_1_1struc_1_1Msg__in.html" title="A structured in-message instance suitable as received and emittable (to user) by struc::Channel.">Msg_in</a> is ready. <a class="el" href="classipc_1_1transport_1_1struc_1_1Msg__in.html" title="A structured in-message instance suitable as received and emittable (to user) by struc::Channel.">Msg_in</a> represents, conceptually, a pointer to 1-2 serialized in-messages: the metadata in-message (always present) and, except for internal messages, the user-supplied in-message (supplied originally via <a class="el" href="classipc_1_1transport_1_1struc_1_1sync__io_1_1Channel.html#a83fb4462a8d4045bdb56b694bf80393c" title="See Async_io_obj counterpart.">Msg_out</a>). However, to the user, only the latter is accessible, and an internal message is by definition never emitted to the user (if it were, there would be nothing for them to access).</p>
<p >The preceding paragraph talks only of <em>one</em> <a class="el" href="classipc_1_1transport_1_1struc_1_1sync__io_1_1Channel.html" title="sync_io-pattern counterpart to async-I/O-pattern transport::struc::Channel.">Channel</a> pipe. It is possible <a class="el" href="classipc_1_1transport_1_1struc_1_1sync__io_1_1Channel.html#a4abac89dbd4d26c79b7915990f751a76" title="See Async_io_obj counterpart.">Owned_channel</a> contains 2 pipes (<a class="el" href="classipc_1_1transport_1_1Channel.html#a85184d886cee9b4a0d0e7b67796a238b" title="Useful for generic programming: true if and only if types imply both blobs and handles pipes are enab...">Channel::S_HAS_2_PIPES</a>), operating potentially in parallel. (This may be useful for perf; discussion omitted here.) Naturally this creates the possibility of reordering of in-messages. Hence, optionally, there is another layer between completing a <a class="el" href="classipc_1_1transport_1_1struc_1_1Msg__in.html" title="A structured in-message instance suitable as received and emittable (to user) by struc::Channel.">Msg_in</a> (<a class="el" href="classipc_1_1transport_1_1struc_1_1sync__io_1_1Channel.html#acde2b3866547a30958035203d9d89928" title="See Async_io_obj counterpart.">Msg_in_ptr</a>) and emitting it: a simple reassembly queue. To make this work: each in-message (hence each out-message instance) is supplied with a unique message ID (required anyway for, at least, request-response correlation); and that message ID doubles as a <em>sequence #</em> (1, 2, ...). <a class="el" href="classipc_1_1transport_1_1struc_1_1sync__io_1_1Channel.html#a26594894094e4fa03b3c1dacd2e0f351" title="Reassembly queue type: &quot;queue&quot; of all in-messages with msg_id_in_t exceeding m_rcv_msg_next_id,...">Reassembly_q</a> is a reassembly queue that is (probably infrequently) used to temporarily store out-of-order structured in-messages, flushing them once the gap between last-emitted-to-next-layer in-message-sequence-# and lowest-in-message-sequence-#-in-reassembly-queue is filled.</p>
<p >Okay; let's assume an in-message has gone through the above 2-3 layers (<a class="el" href="classipc_1_1transport_1_1struc_1_1sync__io_1_1Channel.html" title="sync_io-pattern counterpart to async-I/O-pattern transport::struc::Channel.">Channel</a> layer, (optional) reassembly queue layer, <a class="el" href="classipc_1_1transport_1_1struc_1_1Msg__in.html" title="A structured in-message instance suitable as received and emittable (to user) by struc::Channel.">Msg_in</a> completion layer). Can we finally emit it to the user? Often yes... but generally no:</p>
<p >In the incoming-direction, we add <em>notification</em> and <em>response</em> expectation APIs (these are mandatory before the <code>*this</code> user receives an emitted in-message via handler). This adds a further layer of processing. Once a <a class="el" href="classipc_1_1transport_1_1struc_1_1Msg__in.html" title="A structured in-message instance suitable as received and emittable (to user) by struc::Channel.">Msg_in</a> (<a class="el" href="classipc_1_1transport_1_1struc_1_1sync__io_1_1Channel.html#acde2b3866547a30958035203d9d89928" title="See Async_io_obj counterpart.">Msg_in_ptr</a>) is assembled and ready to deserialize, one of 2 things happens: either an <a class="el" href="classipc_1_1transport_1_1struc_1_1sync__io_1_1Channel.html#a5fc489b9abefe5ab676f6991d6d03f0d" title="Registers the expectation (which may be immediately met) of up to 1 notification in-message whose Msg...">expect_msg()</a> or <a class="el" href="classipc_1_1transport_1_1struc_1_1sync__io_1_1Channel.html#a26dc83067e005be38567199cbedd7f19" title="See Async_io_obj counterpart; though naturally on_rsp_func() is invoked in the sync_io-pattern fashio...">async_request()</a> has registered a handler for this in-message &ndash; then it is immediately emitted to that handler (done!); or not &ndash; then it is stored inside <code>*this</code>. (Once a handler is <em>subsequently</em> registered, the appropriate stored in-messages shall be emitted via synchronous out-args such as <code>qd_msgs</code> for <a class="el" href="classipc_1_1transport_1_1struc_1_1sync__io_1_1Channel.html#a62f52488ba20dd6c69dfc1abadb2d69f" title="Registers the expectation (some of which may be immediately met) of 0+ notification in-messages whose...">expect_msgs()</a>.)</p>
<p >That's the overview. Various doc headers on <code>private</code> types and/or data members should fill in the details. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Channel_obj</td><td>See <a class="el" href="classipc_1_1transport_1_1struc_1_1sync__io_1_1Channel.html#a6dc83bd6057b7f00a19c5947d6baa7b7" title="Useful for generic programming, the async-I/O-pattern counterpart to *this type.">Async_io_obj</a> doc header. </td></tr>
    <tr><td class="paramname">Message_body</td><td>See <a class="el" href="classipc_1_1transport_1_1struc_1_1sync__io_1_1Channel.html#a6dc83bd6057b7f00a19c5947d6baa7b7" title="Useful for generic programming, the async-I/O-pattern counterpart to *this type.">Async_io_obj</a> doc header. </td></tr>
    <tr><td class="paramname">Struct_builder_config</td><td>See <a class="el" href="classipc_1_1transport_1_1struc_1_1sync__io_1_1Channel.html#a6dc83bd6057b7f00a19c5947d6baa7b7" title="Useful for generic programming, the async-I/O-pattern counterpart to *this type.">Async_io_obj</a> doc header. </td></tr>
    <tr><td class="paramname">Struct_reader_config</td><td>See <a class="el" href="classipc_1_1transport_1_1struc_1_1sync__io_1_1Channel.html#a6dc83bd6057b7f00a19c5947d6baa7b7" title="Useful for generic programming, the async-I/O-pattern counterpart to *this type.">Async_io_obj</a> doc header. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="ipc__transport__structured_2src_2ipc_2transport_2struc_2sync__io_2channel_8hpp_source.html#l00178">178</a> of file <a class="el" href="ipc__transport__structured_2src_2ipc_2transport_2struc_2sync__io_2channel_8hpp_source.html">channel.hpp</a>.</p>
</div><h2 class="groupheader">Member Typedef Documentation</h2>
<a id="a6dc83bd6057b7f00a19c5947d6baa7b7" name="a6dc83bd6057b7f00a19c5947d6baa7b7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6dc83bd6057b7f00a19c5947d6baa7b7">&#9670;&nbsp;</a></span>Async_io_obj</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Channel_obj , typename Message_body , typename Struct_builder_config , typename Struct_reader_config &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classipc_1_1transport_1_1struc_1_1sync__io_1_1Channel.html">ipc::transport::struc::sync_io::Channel</a>&lt; Channel_obj, Message_body, Struct_builder_config, Struct_reader_config &gt;::Async_io_obj =  <a class="el" href="classipc_1_1transport_1_1struc_1_1Channel.html">transport::struc::Channel</a>&lt;Channel_obj, Message_body, Struct_builder_config, Struct_reader_config&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Useful for generic programming, the async-I/O-pattern counterpart to <code>*this</code> type. </p>

<p class="definition">Definition at line <a class="el" href="ipc__transport__structured_2src_2ipc_2transport_2struc_2sync__io_2channel_8hpp_source.html#l00187">187</a> of file <a class="el" href="ipc__transport__structured_2src_2ipc_2transport_2struc_2sync__io_2channel_8hpp_source.html">channel.hpp</a>.</p>

</div>
</div>
<a id="a8a59bbc3c6a7191b316b23661d8ba6e3" name="a8a59bbc3c6a7191b316b23661d8ba6e3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8a59bbc3c6a7191b316b23661d8ba6e3">&#9670;&nbsp;</a></span>Builder_config</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Channel_obj , typename Message_body , typename Struct_builder_config , typename Struct_reader_config &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classipc_1_1transport_1_1struc_1_1sync__io_1_1Channel.html">ipc::transport::struc::sync_io::Channel</a>&lt; Channel_obj, Message_body, Struct_builder_config, Struct_reader_config &gt;::Builder_config =  Struct_builder_config</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>See <a class="el" href="classipc_1_1transport_1_1struc_1_1sync__io_1_1Channel.html#a6dc83bd6057b7f00a19c5947d6baa7b7" title="Useful for generic programming, the async-I/O-pattern counterpart to *this type.">Async_io_obj</a> counterpart. </p>

<p class="definition">Definition at line <a class="el" href="ipc__transport__structured_2src_2ipc_2transport_2struc_2sync__io_2channel_8hpp_source.html#l00200">200</a> of file <a class="el" href="ipc__transport__structured_2src_2ipc_2transport_2struc_2sync__io_2channel_8hpp_source.html">channel.hpp</a>.</p>

</div>
</div>
<a id="adccd6372c0284a7f3198ac00c0935002" name="adccd6372c0284a7f3198ac00c0935002"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adccd6372c0284a7f3198ac00c0935002">&#9670;&nbsp;</a></span>Expecting_msg</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Channel_obj , typename Message_body , typename Struct_builder_config , typename Struct_reader_config &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classipc_1_1transport_1_1struc_1_1sync__io_1_1Channel.html">ipc::transport::struc::sync_io::Channel</a>&lt; Channel_obj, Message_body, Struct_builder_config, Struct_reader_config &gt;::Expecting_msg =  <a class="el" href="structipc_1_1transport_1_1struc_1_1sync__io_1_1Channel_1_1Expecting__response.html">Expecting_response</a></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Policy for how to act upon receiving an in-message whose top-level-union <a class="el" href="classipc_1_1transport_1_1struc_1_1sync__io_1_1Channel.html#aa40c3ec3f45cdfea9360f7f35b9ade3c" title="See Async_io_obj counterpart.">Msg_which_in</a> <code>enum</code> equals the <a class="el" href="classipc_1_1transport_1_1struc_1_1sync__io_1_1Channel.html#aa40c3ec3f45cdfea9360f7f35b9ade3c" title="See Async_io_obj counterpart.">Msg_which_in</a> associated with this object in <a class="el" href="classipc_1_1transport_1_1struc_1_1sync__io_1_1Channel.html#a8d1ffe78546eb31fd41df6784a26868c" title="Table mapping in-message Msg_which_in enum value to the policy for handling an in-message with that w...">Expecting_msg_map</a>. </p>
<p >It is aliased to <a class="el" href="structipc_1_1transport_1_1struc_1_1sync__io_1_1Channel_1_1Expecting__response.html" title="Policy for how to act upon receiving a response in-message that indicates its originating out-message...">Expecting_response</a> for brevity, since that <code>struct</code>'s fields are easily reworked to the present application.</p><ul>
<li><code>m_one_expected</code> is repurposed to apply to <a class="el" href="classipc_1_1transport_1_1struc_1_1sync__io_1_1Channel.html#ac8ba5f1a26a9f3e881b4871b0f6aa990" title="See Async_io_obj counterpart.">undo_expect_msgs()</a>.</li>
<li><code>m_on_msg_func</code> is repurposed as the handler for a <a class="el" href="classipc_1_1transport_1_1struc_1_1sync__io_1_1Channel.html#aa40c3ec3f45cdfea9360f7f35b9ade3c" title="See Async_io_obj counterpart.">Msg_which_in</a> value (see <a class="el" href="classipc_1_1transport_1_1struc_1_1sync__io_1_1Channel.html#a5fc489b9abefe5ab676f6991d6d03f0d" title="Registers the expectation (which may be immediately met) of up to 1 notification in-message whose Msg...">expect_msg()</a>, <a class="el" href="classipc_1_1transport_1_1struc_1_1sync__io_1_1Channel.html#a62f52488ba20dd6c69dfc1abadb2d69f" title="Registers the expectation (some of which may be immediately met) of 0+ notification in-messages whose...">expect_msgs()</a>). </li>
</ul>

<p class="definition">Definition at line <a class="el" href="ipc__transport__structured_2src_2ipc_2transport_2struc_2sync__io_2channel_8hpp_source.html#l00982">982</a> of file <a class="el" href="ipc__transport__structured_2src_2ipc_2transport_2struc_2sync__io_2channel_8hpp_source.html">channel.hpp</a>.</p>

</div>
</div>
<a id="a8d1ffe78546eb31fd41df6784a26868c" name="a8d1ffe78546eb31fd41df6784a26868c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8d1ffe78546eb31fd41df6784a26868c">&#9670;&nbsp;</a></span>Expecting_msg_map</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Channel_obj , typename Message_body , typename Struct_builder_config , typename Struct_reader_config &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classipc_1_1transport_1_1struc_1_1sync__io_1_1Channel.html">ipc::transport::struc::sync_io::Channel</a>&lt; Channel_obj, Message_body, Struct_builder_config, Struct_reader_config &gt;::Expecting_msg_map =  boost::unordered_map&lt;<a class="el" href="classipc_1_1transport_1_1struc_1_1sync__io_1_1Channel.html#aa40c3ec3f45cdfea9360f7f35b9ade3c">Msg_which_in</a>, typename <a class="el" href="structipc_1_1transport_1_1struc_1_1sync__io_1_1Channel_1_1Expecting__response.html#a5f68a8c574bf52f8fce42ea01c564923">Expecting_msg::Ptr</a>&gt;</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Table mapping in-message <a class="el" href="classipc_1_1transport_1_1struc_1_1sync__io_1_1Channel.html#aa40c3ec3f45cdfea9360f7f35b9ade3c" title="See Async_io_obj counterpart.">Msg_which_in</a> <code>enum</code> value to the policy for handling an in-message with that <code>which()</code> value. </p>

<p class="definition">Definition at line <a class="el" href="ipc__transport__structured_2src_2ipc_2transport_2struc_2sync__io_2channel_8hpp_source.html#l00994">994</a> of file <a class="el" href="ipc__transport__structured_2src_2ipc_2transport_2struc_2sync__io_2channel_8hpp_source.html">channel.hpp</a>.</p>

</div>
</div>
<a id="a3d4c8da3dd620d113479f5c6a3f96c3a" name="a3d4c8da3dd620d113479f5c6a3f96c3a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3d4c8da3dd620d113479f5c6a3f96c3a">&#9670;&nbsp;</a></span>Expecting_response_map</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Channel_obj , typename Message_body , typename Struct_builder_config , typename Struct_reader_config &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classipc_1_1transport_1_1struc_1_1sync__io_1_1Channel.html">ipc::transport::struc::sync_io::Channel</a>&lt; Channel_obj, Message_body, Struct_builder_config, Struct_reader_config &gt;::Expecting_response_map =  boost::unordered_map&lt;<a class="el" href="classipc_1_1transport_1_1struc_1_1Channel__base.html#adcf24fa51747ed83c4b6427fbf44fecf">msg_id_out_t</a>, typename <a class="el" href="structipc_1_1transport_1_1struc_1_1sync__io_1_1Channel_1_1Expecting__response.html#a5f68a8c574bf52f8fce42ea01c564923">Expecting_response::Ptr</a>&gt;</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Table mapping originating out-message to the policy for handling an in-message that indicates that out-message as the originating message (via message ID &ndash; <em>after</em> the out-message is sent via <a class="el" href="classipc_1_1transport_1_1struc_1_1sync__io_1_1Channel.html#a0dc388e18b0fc0fa2d8ad0a6953fb039" title="See Async_io_obj counterpart.">send()</a>). </p>

<p class="definition">Definition at line <a class="el" href="ipc__transport__structured_2src_2ipc_2transport_2struc_2sync__io_2channel_8hpp_source.html#l00988">988</a> of file <a class="el" href="ipc__transport__structured_2src_2ipc_2transport_2struc_2sync__io_2channel_8hpp_source.html">channel.hpp</a>.</p>

</div>
</div>
<a id="a34e183c252390f369f121074772c14c4" name="a34e183c252390f369f121074772c14c4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a34e183c252390f369f121074772c14c4">&#9670;&nbsp;</a></span>Msg_body</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Channel_obj , typename Message_body , typename Struct_builder_config , typename Struct_reader_config &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classipc_1_1transport_1_1struc_1_1sync__io_1_1Channel.html">ipc::transport::struc::sync_io::Channel</a>&lt; Channel_obj, Message_body, Struct_builder_config, Struct_reader_config &gt;::Msg_body =  Message_body</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>See <a class="el" href="classipc_1_1transport_1_1struc_1_1sync__io_1_1Channel.html#a6dc83bd6057b7f00a19c5947d6baa7b7" title="Useful for generic programming, the async-I/O-pattern counterpart to *this type.">Async_io_obj</a> counterpart. </p>

<p class="definition">Definition at line <a class="el" href="ipc__transport__structured_2src_2ipc_2transport_2struc_2sync__io_2channel_8hpp_source.html#l00205">205</a> of file <a class="el" href="ipc__transport__structured_2src_2ipc_2transport_2struc_2sync__io_2channel_8hpp_source.html">channel.hpp</a>.</p>

</div>
</div>
<a id="ad77261f31055f4151c70225c3fa1da2e" name="ad77261f31055f4151c70225c3fa1da2e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad77261f31055f4151c70225c3fa1da2e">&#9670;&nbsp;</a></span>msg_id_in_t</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Channel_obj , typename Message_body , typename Struct_builder_config , typename Struct_reader_config &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classipc_1_1transport_1_1struc_1_1sync__io_1_1Channel.html">ipc::transport::struc::sync_io::Channel</a>&lt; Channel_obj, Message_body, Struct_builder_config, Struct_reader_config &gt;::msg_id_in_t =  <a class="el" href="namespaceipc_1_1transport_1_1struc.html#af7f35fc7588d97a838274fa25700ead9">msg_id_t</a></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Clarifying short-hand for incoming-message IDs. </p>

<p class="definition">Definition at line <a class="el" href="ipc__transport__structured_2src_2ipc_2transport_2struc_2sync__io_2channel_8hpp_source.html#l00897">897</a> of file <a class="el" href="ipc__transport__structured_2src_2ipc_2transport_2struc_2sync__io_2channel_8hpp_source.html">channel.hpp</a>.</p>

</div>
</div>
<a id="a9b5d17887c9ad1e37081bf4ae4a70e65" name="a9b5d17887c9ad1e37081bf4ae4a70e65"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9b5d17887c9ad1e37081bf4ae4a70e65">&#9670;&nbsp;</a></span>msg_id_out_t</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Channel_obj , typename Message_body , typename Struct_builder_config , typename Struct_reader_config &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classipc_1_1transport_1_1struc_1_1sync__io_1_1Channel.html">ipc::transport::struc::sync_io::Channel</a>&lt; Channel_obj, Message_body, Struct_builder_config, Struct_reader_config &gt;::msg_id_out_t =  <a class="el" href="classipc_1_1transport_1_1struc_1_1Channel__base.html#adcf24fa51747ed83c4b6427fbf44fecf">Channel_base::msg_id_out_t</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>See <a class="el" href="classipc_1_1transport_1_1struc_1_1sync__io_1_1Channel.html#a6dc83bd6057b7f00a19c5947d6baa7b7" title="Useful for generic programming, the async-I/O-pattern counterpart to *this type.">Async_io_obj</a> counterpart. </p>

<p class="definition">Definition at line <a class="el" href="ipc__transport__structured_2src_2ipc_2transport_2struc_2sync__io_2channel_8hpp_source.html#l00229">229</a> of file <a class="el" href="ipc__transport__structured_2src_2ipc_2transport_2struc_2sync__io_2channel_8hpp_source.html">channel.hpp</a>.</p>

</div>
</div>
<a id="ac3da0ac1306b63c9e38c47b8c31e3cd2" name="ac3da0ac1306b63c9e38c47b8c31e3cd2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac3da0ac1306b63c9e38c47b8c31e3cd2">&#9670;&nbsp;</a></span>Msg_in</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Channel_obj , typename Message_body , typename Struct_builder_config , typename Struct_reader_config &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classipc_1_1transport_1_1struc_1_1sync__io_1_1Channel.html">ipc::transport::struc::sync_io::Channel</a>&lt; Channel_obj, Message_body, Struct_builder_config, Struct_reader_config &gt;::Msg_in =  <a class="el" href="classipc_1_1transport_1_1struc_1_1Msg__in.html">struc::Msg_in</a>&lt;<a class="el" href="classipc_1_1transport_1_1struc_1_1sync__io_1_1Channel.html#a34e183c252390f369f121074772c14c4">Msg_body</a>, <a class="el" href="classipc_1_1transport_1_1struc_1_1sync__io_1_1Channel.html#a14a7166b2f8c117ce6ddafe943d036fa">Reader_config</a>&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>See <a class="el" href="classipc_1_1transport_1_1struc_1_1sync__io_1_1Channel.html#a6dc83bd6057b7f00a19c5947d6baa7b7" title="Useful for generic programming, the async-I/O-pattern counterpart to *this type.">Async_io_obj</a> counterpart. </p>

<p class="definition">Definition at line <a class="el" href="ipc__transport__structured_2src_2ipc_2transport_2struc_2sync__io_2channel_8hpp_source.html#l00220">220</a> of file <a class="el" href="ipc__transport__structured_2src_2ipc_2transport_2struc_2sync__io_2channel_8hpp_source.html">channel.hpp</a>.</p>

</div>
</div>
<a id="acb6922fb543bd544a2244412e4835e82" name="acb6922fb543bd544a2244412e4835e82"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acb6922fb543bd544a2244412e4835e82">&#9670;&nbsp;</a></span>Msg_in_impl</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Channel_obj , typename Message_body , typename Struct_builder_config , typename Struct_reader_config &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classipc_1_1transport_1_1struc_1_1sync__io_1_1Channel.html">ipc::transport::struc::sync_io::Channel</a>&lt; Channel_obj, Message_body, Struct_builder_config, Struct_reader_config &gt;::Msg_in_impl =  <a class="el" href="classipc_1_1transport_1_1struc_1_1Msg__in__impl.html">struc::Msg_in_impl</a>&lt;<a class="el" href="classipc_1_1transport_1_1struc_1_1sync__io_1_1Channel.html#a34e183c252390f369f121074772c14c4">Msg_body</a>, <a class="el" href="classipc_1_1transport_1_1struc_1_1sync__io_1_1Channel.html#a14a7166b2f8c117ce6ddafe943d036fa">Reader_config</a>&gt;</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Exact equivalent of <a class="el" href="classipc_1_1transport_1_1struc_1_1sync__io_1_1Channel.html#ac3da0ac1306b63c9e38c47b8c31e3cd2" title="See Async_io_obj counterpart.">Msg_in</a> but with the internal-use (intended for us!) interface exposed. </p>

<p class="definition">Definition at line <a class="el" href="ipc__transport__structured_2src_2ipc_2transport_2struc_2sync__io_2channel_8hpp_source.html#l00888">888</a> of file <a class="el" href="ipc__transport__structured_2src_2ipc_2transport_2struc_2sync__io_2channel_8hpp_source.html">channel.hpp</a>.</p>

</div>
</div>
<a id="acde2b3866547a30958035203d9d89928" name="acde2b3866547a30958035203d9d89928"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acde2b3866547a30958035203d9d89928">&#9670;&nbsp;</a></span>Msg_in_ptr</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Channel_obj , typename Message_body , typename Struct_builder_config , typename Struct_reader_config &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classipc_1_1transport_1_1struc_1_1sync__io_1_1Channel.html">ipc::transport::struc::sync_io::Channel</a>&lt; Channel_obj, Message_body, Struct_builder_config, Struct_reader_config &gt;::Msg_in_ptr =  boost::shared_ptr&lt;<a class="el" href="classipc_1_1transport_1_1struc_1_1sync__io_1_1Channel.html#ac3da0ac1306b63c9e38c47b8c31e3cd2">Msg_in</a>&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>See <a class="el" href="classipc_1_1transport_1_1struc_1_1sync__io_1_1Channel.html#a6dc83bd6057b7f00a19c5947d6baa7b7" title="Useful for generic programming, the async-I/O-pattern counterpart to *this type.">Async_io_obj</a> counterpart. </p>

<p class="definition">Definition at line <a class="el" href="ipc__transport__structured_2src_2ipc_2transport_2struc_2sync__io_2channel_8hpp_source.html#l00223">223</a> of file <a class="el" href="ipc__transport__structured_2src_2ipc_2transport_2struc_2sync__io_2channel_8hpp_source.html">channel.hpp</a>.</p>

</div>
</div>
<a id="a84287334d14f54c97f7dbb0d5b04cca5" name="a84287334d14f54c97f7dbb0d5b04cca5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a84287334d14f54c97f7dbb0d5b04cca5">&#9670;&nbsp;</a></span>Msg_in_ptr_uniq</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Channel_obj , typename Message_body , typename Struct_builder_config , typename Struct_reader_config &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classipc_1_1transport_1_1struc_1_1sync__io_1_1Channel.html">ipc::transport::struc::sync_io::Channel</a>&lt; Channel_obj, Message_body, Struct_builder_config, Struct_reader_config &gt;::Msg_in_ptr_uniq =  boost::movelib::unique_ptr&lt;<a class="el" href="classipc_1_1transport_1_1struc_1_1sync__io_1_1Channel.html#acb6922fb543bd544a2244412e4835e82">Msg_in_impl</a>&gt;</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Like <a class="el" href="classipc_1_1transport_1_1struc_1_1sync__io_1_1Channel.html#acde2b3866547a30958035203d9d89928" title="See Async_io_obj counterpart.">Msg_in_ptr</a> but <code>unique_ptr</code> instead of <code>shared_ptr</code>. Note the latter can upgrade-from a <code>move()</code>d former. </p>

<p class="definition">Definition at line <a class="el" href="ipc__transport__structured_2src_2ipc_2transport_2struc_2sync__io_2channel_8hpp_source.html#l00997">997</a> of file <a class="el" href="ipc__transport__structured_2src_2ipc_2transport_2struc_2sync__io_2channel_8hpp_source.html">channel.hpp</a>.</p>

</div>
</div>
<a id="a2eed5db328a8c45ab16a875617a172c7" name="a2eed5db328a8c45ab16a875617a172c7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2eed5db328a8c45ab16a875617a172c7">&#9670;&nbsp;</a></span>Msg_in_q</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Channel_obj , typename Message_body , typename Struct_builder_config , typename Struct_reader_config &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classipc_1_1transport_1_1struc_1_1sync__io_1_1Channel.html">ipc::transport::struc::sync_io::Channel</a>&lt; Channel_obj, Message_body, Struct_builder_config, Struct_reader_config &gt;::Msg_in_q =  std::queue&lt;<a class="el" href="classipc_1_1transport_1_1struc_1_1sync__io_1_1Channel.html#a84287334d14f54c97f7dbb0d5b04cca5">Msg_in_ptr_uniq</a>&gt;</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Short-hand for queue (FIFO) of in-messages. </p>

<p class="definition">Definition at line <a class="el" href="ipc__transport__structured_2src_2ipc_2transport_2struc_2sync__io_2channel_8hpp_source.html#l01000">1000</a> of file <a class="el" href="ipc__transport__structured_2src_2ipc_2transport_2struc_2sync__io_2channel_8hpp_source.html">channel.hpp</a>.</p>

</div>
</div>
<a id="acbf3e5dbf6879e358f0596633e1428e0" name="acbf3e5dbf6879e358f0596633e1428e0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acbf3e5dbf6879e358f0596633e1428e0">&#9670;&nbsp;</a></span>Msg_mdt_out</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Channel_obj , typename Message_body , typename Struct_builder_config , typename Struct_reader_config &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classipc_1_1transport_1_1struc_1_1sync__io_1_1Channel.html">ipc::transport::struc::sync_io::Channel</a>&lt; Channel_obj, Message_body, Struct_builder_config, Struct_reader_config &gt;::Msg_mdt_out =  <a class="el" href="classipc_1_1transport_1_1struc_1_1Msg__mdt__out.html">struc::Msg_mdt_out</a>&lt;<a class="el" href="classipc_1_1transport_1_1struc_1_1sync__io_1_1Channel.html#a8a59bbc3c6a7191b316b23661d8ba6e3">Builder_config</a>&gt;</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Metadata message: internal-use out-message describing the associated <a class="el" href="classipc_1_1transport_1_1struc_1_1sync__io_1_1Channel.html#a83fb4462a8d4045bdb56b694bf80393c" title="See Async_io_obj counterpart.">Msg_out</a>; or describing/containing internal message body (then not associated with a user-message). </p>

<p class="definition">Definition at line <a class="el" href="ipc__transport__structured_2src_2ipc_2transport_2struc_2sync__io_2channel_8hpp_source.html#l00894">894</a> of file <a class="el" href="ipc__transport__structured_2src_2ipc_2transport_2struc_2sync__io_2channel_8hpp_source.html">channel.hpp</a>.</p>

</div>
</div>
<a id="a83fb4462a8d4045bdb56b694bf80393c" name="a83fb4462a8d4045bdb56b694bf80393c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a83fb4462a8d4045bdb56b694bf80393c">&#9670;&nbsp;</a></span>Msg_out</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Channel_obj , typename Message_body , typename Struct_builder_config , typename Struct_reader_config &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classipc_1_1transport_1_1struc_1_1sync__io_1_1Channel.html">ipc::transport::struc::sync_io::Channel</a>&lt; Channel_obj, Message_body, Struct_builder_config, Struct_reader_config &gt;::Msg_out =  <a class="el" href="classipc_1_1transport_1_1struc_1_1Msg__out.html">struc::Msg_out</a>&lt;<a class="el" href="classipc_1_1transport_1_1struc_1_1sync__io_1_1Channel.html#a34e183c252390f369f121074772c14c4">Msg_body</a>, typename Builder_config::Builder&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>See <a class="el" href="classipc_1_1transport_1_1struc_1_1sync__io_1_1Channel.html#a6dc83bd6057b7f00a19c5947d6baa7b7" title="Useful for generic programming, the async-I/O-pattern counterpart to *this type.">Async_io_obj</a> counterpart. </p>

<p class="definition">Definition at line <a class="el" href="ipc__transport__structured_2src_2ipc_2transport_2struc_2sync__io_2channel_8hpp_source.html#l00217">217</a> of file <a class="el" href="ipc__transport__structured_2src_2ipc_2transport_2struc_2sync__io_2channel_8hpp_source.html">channel.hpp</a>.</p>

</div>
</div>
<a id="a984b6afa0f437c72aca5a1ba97f33a7f" name="a984b6afa0f437c72aca5a1ba97f33a7f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a984b6afa0f437c72aca5a1ba97f33a7f">&#9670;&nbsp;</a></span>Msg_out_impl</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Channel_obj , typename Message_body , typename Struct_builder_config , typename Struct_reader_config &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classipc_1_1transport_1_1struc_1_1sync__io_1_1Channel.html">ipc::transport::struc::sync_io::Channel</a>&lt; Channel_obj, Message_body, Struct_builder_config, Struct_reader_config &gt;::Msg_out_impl =  <a class="el" href="classipc_1_1transport_1_1struc_1_1Msg__out__impl.html">struc::Msg_out_impl</a>&lt;<a class="el" href="classipc_1_1transport_1_1struc_1_1sync__io_1_1Channel.html#a34e183c252390f369f121074772c14c4">Msg_body</a>, typename Builder_config::Builder&gt;</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Exact equivalent of <a class="el" href="classipc_1_1transport_1_1struc_1_1sync__io_1_1Channel.html#a83fb4462a8d4045bdb56b694bf80393c" title="See Async_io_obj counterpart.">Msg_out</a> but with the internal-use (intended for us!) interface exposed. </p>

<p class="definition">Definition at line <a class="el" href="ipc__transport__structured_2src_2ipc_2transport_2struc_2sync__io_2channel_8hpp_source.html#l00885">885</a> of file <a class="el" href="ipc__transport__structured_2src_2ipc_2transport_2struc_2sync__io_2channel_8hpp_source.html">channel.hpp</a>.</p>

</div>
</div>
<a id="a1572a1b1cb4a72ea57f7841a5e78759b" name="a1572a1b1cb4a72ea57f7841a5e78759b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1572a1b1cb4a72ea57f7841a5e78759b">&#9670;&nbsp;</a></span>Msg_which</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Channel_obj , typename Message_body , typename Struct_builder_config , typename Struct_reader_config &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classipc_1_1transport_1_1struc_1_1sync__io_1_1Channel.html">ipc::transport::struc::sync_io::Channel</a>&lt; Channel_obj, Message_body, Struct_builder_config, Struct_reader_config &gt;::Msg_which =  typename Message_body::Which</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>See <a class="el" href="classipc_1_1transport_1_1struc_1_1sync__io_1_1Channel.html#a6dc83bd6057b7f00a19c5947d6baa7b7" title="Useful for generic programming, the async-I/O-pattern counterpart to *this type.">Async_io_obj</a> counterpart. </p>

<p class="definition">Definition at line <a class="el" href="ipc__transport__structured_2src_2ipc_2transport_2struc_2sync__io_2channel_8hpp_source.html#l00208">208</a> of file <a class="el" href="ipc__transport__structured_2src_2ipc_2transport_2struc_2sync__io_2channel_8hpp_source.html">channel.hpp</a>.</p>

</div>
</div>
<a id="aa40c3ec3f45cdfea9360f7f35b9ade3c" name="aa40c3ec3f45cdfea9360f7f35b9ade3c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa40c3ec3f45cdfea9360f7f35b9ade3c">&#9670;&nbsp;</a></span>Msg_which_in</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Channel_obj , typename Message_body , typename Struct_builder_config , typename Struct_reader_config &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classipc_1_1transport_1_1struc_1_1sync__io_1_1Channel.html">ipc::transport::struc::sync_io::Channel</a>&lt; Channel_obj, Message_body, Struct_builder_config, Struct_reader_config &gt;::Msg_which_in =  <a class="el" href="classipc_1_1transport_1_1struc_1_1sync__io_1_1Channel.html#a1572a1b1cb4a72ea57f7841a5e78759b">Msg_which</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>See <a class="el" href="classipc_1_1transport_1_1struc_1_1sync__io_1_1Channel.html#a6dc83bd6057b7f00a19c5947d6baa7b7" title="Useful for generic programming, the async-I/O-pattern counterpart to *this type.">Async_io_obj</a> counterpart. </p>

<p class="definition">Definition at line <a class="el" href="ipc__transport__structured_2src_2ipc_2transport_2struc_2sync__io_2channel_8hpp_source.html#l00211">211</a> of file <a class="el" href="ipc__transport__structured_2src_2ipc_2transport_2struc_2sync__io_2channel_8hpp_source.html">channel.hpp</a>.</p>

</div>
</div>
<a id="a7a731cdae5217ed9e867fb80c1fb0fd9" name="a7a731cdae5217ed9e867fb80c1fb0fd9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7a731cdae5217ed9e867fb80c1fb0fd9">&#9670;&nbsp;</a></span>Msg_which_out</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Channel_obj , typename Message_body , typename Struct_builder_config , typename Struct_reader_config &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classipc_1_1transport_1_1struc_1_1sync__io_1_1Channel.html">ipc::transport::struc::sync_io::Channel</a>&lt; Channel_obj, Message_body, Struct_builder_config, Struct_reader_config &gt;::Msg_which_out =  <a class="el" href="classipc_1_1transport_1_1struc_1_1sync__io_1_1Channel.html#a1572a1b1cb4a72ea57f7841a5e78759b">Msg_which</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>See <a class="el" href="classipc_1_1transport_1_1struc_1_1sync__io_1_1Channel.html#a6dc83bd6057b7f00a19c5947d6baa7b7" title="Useful for generic programming, the async-I/O-pattern counterpart to *this type.">Async_io_obj</a> counterpart. </p>

<p class="definition">Definition at line <a class="el" href="ipc__transport__structured_2src_2ipc_2transport_2struc_2sync__io_2channel_8hpp_source.html#l00214">214</a> of file <a class="el" href="ipc__transport__structured_2src_2ipc_2transport_2struc_2sync__io_2channel_8hpp_source.html">channel.hpp</a>.</p>

</div>
</div>
<a id="a4ab778bce8d7e6e84788879fedc62745" name="a4ab778bce8d7e6e84788879fedc62745"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4ab778bce8d7e6e84788879fedc62745">&#9670;&nbsp;</a></span>Msgs_in</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Channel_obj , typename Message_body , typename Struct_builder_config , typename Struct_reader_config &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classipc_1_1transport_1_1struc_1_1sync__io_1_1Channel.html">ipc::transport::struc::sync_io::Channel</a>&lt; Channel_obj, Message_body, Struct_builder_config, Struct_reader_config &gt;::Msgs_in =  std::vector&lt;<a class="el" href="classipc_1_1transport_1_1struc_1_1sync__io_1_1Channel.html#acde2b3866547a30958035203d9d89928">Msg_in_ptr</a>&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>List of in-messages used in certain APIs like <a class="el" href="classipc_1_1transport_1_1struc_1_1sync__io_1_1Channel.html#a62f52488ba20dd6c69dfc1abadb2d69f" title="Registers the expectation (some of which may be immediately met) of 0+ notification in-messages whose...">expect_msgs()</a> to synchronously emit cached in-messages. </p>

<p class="definition">Definition at line <a class="el" href="ipc__transport__structured_2src_2ipc_2transport_2struc_2sync__io_2channel_8hpp_source.html#l00226">226</a> of file <a class="el" href="ipc__transport__structured_2src_2ipc_2transport_2struc_2sync__io_2channel_8hpp_source.html">channel.hpp</a>.</p>

</div>
</div>
<a id="a26121a19c67c5bf5c338441502d9d6f7" name="a26121a19c67c5bf5c338441502d9d6f7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a26121a19c67c5bf5c338441502d9d6f7">&#9670;&nbsp;</a></span>On_msg_func</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Channel_obj , typename Message_body , typename Struct_builder_config , typename Struct_reader_config &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classipc_1_1transport_1_1struc_1_1sync__io_1_1Channel.html">ipc::transport::struc::sync_io::Channel</a>&lt; Channel_obj, Message_body, Struct_builder_config, Struct_reader_config &gt;::On_msg_func =  <a class="el" href="namespaceipc.html#aa455c7f045059736578ca275fc1a851f">Function</a>&lt;void (<a class="el" href="classipc_1_1transport_1_1struc_1_1sync__io_1_1Channel.html#acde2b3866547a30958035203d9d89928">Msg_in_ptr</a>&amp;&amp; msg)&gt;</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Concrete type corresponding to <code>On_msg_handler</code> template param: in-message handler. </p>

<p class="definition">Definition at line <a class="el" href="ipc__transport__structured_2src_2ipc_2transport_2struc_2sync__io_2channel_8hpp_source.html#l00900">900</a> of file <a class="el" href="ipc__transport__structured_2src_2ipc_2transport_2struc_2sync__io_2channel_8hpp_source.html">channel.hpp</a>.</p>

</div>
</div>
<a id="a583ccd4bb6b1aefb09d77e5709aef5b4" name="a583ccd4bb6b1aefb09d77e5709aef5b4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a583ccd4bb6b1aefb09d77e5709aef5b4">&#9670;&nbsp;</a></span>On_msg_func_ptr</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Channel_obj , typename Message_body , typename Struct_builder_config , typename Struct_reader_config &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classipc_1_1transport_1_1struc_1_1sync__io_1_1Channel.html">ipc::transport::struc::sync_io::Channel</a>&lt; Channel_obj, Message_body, Struct_builder_config, Struct_reader_config &gt;::On_msg_func_ptr =  boost::shared_ptr&lt;<a class="el" href="classipc_1_1transport_1_1struc_1_1sync__io_1_1Channel.html#a26121a19c67c5bf5c338441502d9d6f7">On_msg_func</a>&gt;</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Ref-counted wrapper of <a class="el" href="classipc_1_1transport_1_1struc_1_1sync__io_1_1Channel.html#a26121a19c67c5bf5c338441502d9d6f7" title="Concrete type corresponding to On_msg_handler template param: in-message handler.">On_msg_func</a>. </p>

<p class="definition">Definition at line <a class="el" href="ipc__transport__structured_2src_2ipc_2transport_2struc_2sync__io_2channel_8hpp_source.html#l00903">903</a> of file <a class="el" href="ipc__transport__structured_2src_2ipc_2transport_2struc_2sync__io_2channel_8hpp_source.html">channel.hpp</a>.</p>

</div>
</div>
<a id="a86342fa9838aea7d49bbf3dd344445e2" name="a86342fa9838aea7d49bbf3dd344445e2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a86342fa9838aea7d49bbf3dd344445e2">&#9670;&nbsp;</a></span>On_remote_unexpected_response_func</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Channel_obj , typename Message_body , typename Struct_builder_config , typename Struct_reader_config &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classipc_1_1transport_1_1struc_1_1sync__io_1_1Channel.html">ipc::transport::struc::sync_io::Channel</a>&lt; Channel_obj, Message_body, Struct_builder_config, Struct_reader_config &gt;::On_remote_unexpected_response_func =  <a class="el" href="namespaceipc.html#aa455c7f045059736578ca275fc1a851f">Function</a>&lt;void (<a class="el" href="classipc_1_1transport_1_1struc_1_1Channel__base.html#adcf24fa51747ed83c4b6427fbf44fecf">msg_id_out_t</a> msg_id_out, std::string&amp;&amp; msg_metadata_text)&gt;</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Concrete type corresponding to <code>On_remote_unexpected_response_handler</code> template param (see <a class="el" href="classipc_1_1transport_1_1struc_1_1sync__io_1_1Channel.html#a3fda370cc97c89a62f77a6fcf639cfd7" title="See Async_io_obj counterpart; though naturally on_func() is invoked in the sync_io-pattern fashion.">set_remote_unexpected_response_handler()</a>). </p>

<p class="definition">Definition at line <a class="el" href="ipc__transport__structured_2src_2ipc_2transport_2struc_2sync__io_2channel_8hpp_source.html#l00915">915</a> of file <a class="el" href="ipc__transport__structured_2src_2ipc_2transport_2struc_2sync__io_2channel_8hpp_source.html">channel.hpp</a>.</p>

</div>
</div>
<a id="abb3be9330a898ce542afd778d8e42a49" name="abb3be9330a898ce542afd778d8e42a49"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abb3be9330a898ce542afd778d8e42a49">&#9670;&nbsp;</a></span>On_unexpected_response_func</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Channel_obj , typename Message_body , typename Struct_builder_config , typename Struct_reader_config &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classipc_1_1transport_1_1struc_1_1sync__io_1_1Channel.html">ipc::transport::struc::sync_io::Channel</a>&lt; Channel_obj, Message_body, Struct_builder_config, Struct_reader_config &gt;::On_unexpected_response_func =  <a class="el" href="namespaceipc.html#aa455c7f045059736578ca275fc1a851f">Function</a>&lt;void (<a class="el" href="classipc_1_1transport_1_1struc_1_1sync__io_1_1Channel.html#acde2b3866547a30958035203d9d89928">Msg_in_ptr</a>&amp;&amp; msg)&gt;</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Concrete type corresponding to <code>On_unexpected_response_handler</code> template param (see <a class="el" href="classipc_1_1transport_1_1struc_1_1sync__io_1_1Channel.html#a5c62d2a374a3a98e7fa0aef01bf8a774" title="See Async_io_obj counterpart; though naturally on_func() is invoked in the sync_io-pattern fashion.">set_unexpected_response_handler()</a>). </p>

<p class="definition">Definition at line <a class="el" href="ipc__transport__structured_2src_2ipc_2transport_2struc_2sync__io_2channel_8hpp_source.html#l00909">909</a> of file <a class="el" href="ipc__transport__structured_2src_2ipc_2transport_2struc_2sync__io_2channel_8hpp_source.html">channel.hpp</a>.</p>

</div>
</div>
<a id="a4abac89dbd4d26c79b7915990f751a76" name="a4abac89dbd4d26c79b7915990f751a76"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4abac89dbd4d26c79b7915990f751a76">&#9670;&nbsp;</a></span>Owned_channel</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Channel_obj , typename Message_body , typename Struct_builder_config , typename Struct_reader_config &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classipc_1_1transport_1_1struc_1_1sync__io_1_1Channel.html">ipc::transport::struc::sync_io::Channel</a>&lt; Channel_obj, Message_body, Struct_builder_config, Struct_reader_config &gt;::Owned_channel =  Channel_obj</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>See <a class="el" href="classipc_1_1transport_1_1struc_1_1sync__io_1_1Channel.html#a6dc83bd6057b7f00a19c5947d6baa7b7" title="Useful for generic programming, the async-I/O-pattern counterpart to *this type.">Async_io_obj</a> counterpart. </p>

<p class="definition">Definition at line <a class="el" href="ipc__transport__structured_2src_2ipc_2transport_2struc_2sync__io_2channel_8hpp_source.html#l00193">193</a> of file <a class="el" href="ipc__transport__structured_2src_2ipc_2transport_2struc_2sync__io_2channel_8hpp_source.html">channel.hpp</a>.</p>

</div>
</div>
<a id="a14a7166b2f8c117ce6ddafe943d036fa" name="a14a7166b2f8c117ce6ddafe943d036fa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a14a7166b2f8c117ce6ddafe943d036fa">&#9670;&nbsp;</a></span>Reader_config</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Channel_obj , typename Message_body , typename Struct_builder_config , typename Struct_reader_config &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classipc_1_1transport_1_1struc_1_1sync__io_1_1Channel.html">ipc::transport::struc::sync_io::Channel</a>&lt; Channel_obj, Message_body, Struct_builder_config, Struct_reader_config &gt;::Reader_config =  Struct_reader_config</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>See <a class="el" href="classipc_1_1transport_1_1struc_1_1sync__io_1_1Channel.html#a6dc83bd6057b7f00a19c5947d6baa7b7" title="Useful for generic programming, the async-I/O-pattern counterpart to *this type.">Async_io_obj</a> counterpart. </p>

<p class="definition">Definition at line <a class="el" href="ipc__transport__structured_2src_2ipc_2transport_2struc_2sync__io_2channel_8hpp_source.html#l00202">202</a> of file <a class="el" href="ipc__transport__structured_2src_2ipc_2transport_2struc_2sync__io_2channel_8hpp_source.html">channel.hpp</a>.</p>

</div>
</div>
<a id="a26594894094e4fa03b3c1dacd2e0f351" name="a26594894094e4fa03b3c1dacd2e0f351"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a26594894094e4fa03b3c1dacd2e0f351">&#9670;&nbsp;</a></span>Reassembly_q</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Channel_obj , typename Message_body , typename Struct_builder_config , typename Struct_reader_config &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classipc_1_1transport_1_1struc_1_1sync__io_1_1Channel.html">ipc::transport::struc::sync_io::Channel</a>&lt; Channel_obj, Message_body, Struct_builder_config, Struct_reader_config &gt;::Reassembly_q =  std::map&lt;<a class="el" href="classipc_1_1transport_1_1struc_1_1sync__io_1_1Channel.html#ad77261f31055f4151c70225c3fa1da2e">msg_id_in_t</a>, <a class="el" href="classipc_1_1transport_1_1struc_1_1sync__io_1_1Channel.html#a84287334d14f54c97f7dbb0d5b04cca5">Msg_in_ptr_uniq</a>&gt;</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Reassembly queue type: "queue" of all in-messages with <a class="el" href="classipc_1_1transport_1_1struc_1_1sync__io_1_1Channel.html#ad77261f31055f4151c70225c3fa1da2e" title="Clarifying short-hand for incoming-message IDs.">msg_id_in_t</a> exceeding <a class="el" href="classipc_1_1transport_1_1struc_1_1sync__io_1_1Channel.html#a26d39d4e1e2c304ef803b3721bde86f0" title="Next expected in-message ID (sequence #), incremented from initial value 1 to 2, 3,...">m_rcv_msg_next_id</a>, sorted in increasing order by that <a class="el" href="classipc_1_1transport_1_1struc_1_1sync__io_1_1Channel.html#ad77261f31055f4151c70225c3fa1da2e" title="Clarifying short-hand for incoming-message IDs.">msg_id_in_t</a> (sequence #). </p>
<p >Relevant only if <code>Owned_channel::S_HAS_2_PIPES == true</code>. </p>

<p class="definition">Definition at line <a class="el" href="ipc__transport__structured_2src_2ipc_2transport_2struc_2sync__io_2channel_8hpp_source.html#l01006">1006</a> of file <a class="el" href="ipc__transport__structured_2src_2ipc_2transport_2struc_2sync__io_2channel_8hpp_source.html">channel.hpp</a>.</p>

</div>
</div>
<a id="a5bb15c142ca501fe5fdfa8068d076e36" name="a5bb15c142ca501fe5fdfa8068d076e36"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5bb15c142ca501fe5fdfa8068d076e36">&#9670;&nbsp;</a></span>Sync_io_obj</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Channel_obj , typename Message_body , typename Struct_builder_config , typename Struct_reader_config &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classipc_1_1transport_1_1struc_1_1sync__io_1_1Channel.html">ipc::transport::struc::sync_io::Channel</a>&lt; Channel_obj, Message_body, Struct_builder_config, Struct_reader_config &gt;::Sync_io_obj =  <a class="el" href="classipc_1_1transport_1_1Null__peer.html">Null_peer</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>You may disregard. </p>

<p class="definition">Definition at line <a class="el" href="ipc__transport__structured_2src_2ipc_2transport_2struc_2sync__io_2channel_8hpp_source.html#l00190">190</a> of file <a class="el" href="ipc__transport__structured_2src_2ipc_2transport_2struc_2sync__io_2channel_8hpp_source.html">channel.hpp</a>.</p>

</div>
</div>
<h2 class="groupheader">Member Enumeration Documentation</h2>
<a id="a5a3833cd141802041551db21198ac319" name="a5a3833cd141802041551db21198ac319"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5a3833cd141802041551db21198ac319">&#9670;&nbsp;</a></span>Phase</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Channel_obj , typename Message_body , typename Struct_builder_config , typename Struct_reader_config &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">enum class <a class="el" href="classipc_1_1transport_1_1struc_1_1sync__io_1_1Channel.html#a5a3833cd141802041551db21198ac319">ipc::transport::struc::sync_io::Channel::Phase</a></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">strong</span><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>The state of <code>*this</code> (given <a class="el" href="classipc_1_1transport_1_1struc_1_1sync__io_1_1Channel.html#a6e4f8c4207fcf678b4cfc785707d3dce" title="Sets up the sync_io-pattern interaction between *this and the user&#39;s event loop; required before asyn...">start_ops()</a> success); see <a class="el" href="classipc_1_1transport_1_1struc_1_1sync__io_1_1Channel.html#afca9a3012b2f41d635381a5a13ddd7c1" title="Phase (w/r/t log-in or lack thereof) of *this peer.">m_phase</a>. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="a5a3833cd141802041551db21198ac319aa0ea4326c39b88d0b32f90d5ce081220" name="a5a3833cd141802041551db21198ac319aa0ea4326c39b88d0b32f90d5ce081220"></a>S_LOGGED_IN&#160;</td><td class="fielddoc"><p >Regular-operation phase: the general API (<a class="el" href="classipc_1_1transport_1_1struc_1_1sync__io_1_1Channel.html#a5fc489b9abefe5ab676f6991d6d03f0d" title="Registers the expectation (which may be immediately met) of up to 1 notification in-message whose Msg...">expect_msg()</a>, etc.) is available. </p>
<p >Most <code><a class="el" href="classipc_1_1transport_1_1struc_1_1Channel.html" title="Owning and wrapping a pre-connected transport::Channel peer (an endpoint of an established channel ov...">struc::Channel</a></code>s begin in this phase, via ctor that takes <code>session_token_non_nil</code>. This is the terminal phase. Phases that lead to it are <code>S_SRV_LOG_IN</code> and <code>S_CLI_LOG_IN</code>. </p>
</td></tr>
<tr><td class="fieldname"><a id="a5a3833cd141802041551db21198ac319ab64edfa66dd4c58d7aa1c3a30e142706" name="a5a3833cd141802041551db21198ac319ab64edfa66dd4c58d7aa1c3a30e142706"></a>S_SRV_LOG_IN&#160;</td><td class="fielddoc"><p >Logging-in phase, as server process: The general API (<a class="el" href="classipc_1_1transport_1_1struc_1_1sync__io_1_1Channel.html#a5fc489b9abefe5ab676f6991d6d03f0d" title="Registers the expectation (which may be immediately met) of up to 1 notification in-message whose Msg...">expect_msg()</a>, etc.) is unavailable; only <a class="el" href="classipc_1_1transport_1_1struc_1_1sync__io_1_1Channel.html#a996e06f75024e10987eb9cf62e096eec" title="In log-in phase as server only: Registers the expectation (which may be immediately met) of up to 1 l...">expect_log_in_request()</a> and <a class="el" href="classipc_1_1transport_1_1struc_1_1sync__io_1_1Channel.html#a0dc388e18b0fc0fa2d8ad0a6953fb039" title="See Async_io_obj counterpart.">send()</a> are available. </p>
<p >This is an initial phase for a <em>session master channel</em>, via ctor that does not take <code>session_token_non_nil</code> and has <code>is_server == true</code>. Leads to <code>S_LOGGED_IN</code>. </p>
</td></tr>
<tr><td class="fieldname"><a id="a5a3833cd141802041551db21198ac319aa0cb6b19ec0b17da2c3ed65de71ca437" name="a5a3833cd141802041551db21198ac319aa0cb6b19ec0b17da2c3ed65de71ca437"></a>S_CLI_LOG_IN&#160;</td><td class="fielddoc"><p >Logging-in phase, as client process: The general API (<a class="el" href="classipc_1_1transport_1_1struc_1_1sync__io_1_1Channel.html#a5fc489b9abefe5ab676f6991d6d03f0d" title="Registers the expectation (which may be immediately met) of up to 1 notification in-message whose Msg...">expect_msg()</a>, etc.) is unavailable; only <a class="el" href="classipc_1_1transport_1_1struc_1_1sync__io_1_1Channel.html#a426ecae27b4ea5cf7e666e56bad6afe5" title="See Async_io_obj counterpart.">create_msg()</a> and <a class="el" href="classipc_1_1transport_1_1struc_1_1sync__io_1_1Channel.html#a0dc388e18b0fc0fa2d8ad0a6953fb039" title="See Async_io_obj counterpart.">send()</a> (response-expecting form) are available. </p>
<p >This is an initial phase for a <em>session master channel</em>, via ctor that does not take <code>session_token_non_nil</code> and has <code>is_server == false</code>. Leads to <code>S_LOGGED_IN</code>. </p>
</td></tr>
</table>

<p class="definition">Definition at line <a class="el" href="ipc__transport__structured_2src_2ipc_2transport_2struc_2sync__io_2channel_8hpp_source.html#l00919">919</a> of file <a class="el" href="ipc__transport__structured_2src_2ipc_2transport_2struc_2sync__io_2channel_8hpp_source.html">channel.hpp</a>.</p>

</div>
</div>
<a id="a9d3344a97644dad136bb47e852dda6fd" name="a9d3344a97644dad136bb47e852dda6fd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9d3344a97644dad136bb47e852dda6fd">&#9670;&nbsp;</a></span>Rcv_next_step</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Channel_obj , typename Message_body , typename Struct_builder_config , typename Struct_reader_config &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">enum class <a class="el" href="classipc_1_1transport_1_1struc_1_1sync__io_1_1Channel.html#a9d3344a97644dad136bb47e852dda6fd">ipc::transport::struc::sync_io::Channel::Rcv_next_step</a></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">strong</span><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Upon receiving an unstructured message along 1 given pipe of <a class="el" href="classipc_1_1transport_1_1struc_1_1sync__io_1_1Channel.html#a4abac89dbd4d26c79b7915990f751a76" title="See Async_io_obj counterpart.">Owned_channel</a> this indicates the next such message expected if any. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="a9d3344a97644dad136bb47e852dda6fda24a42fc0479551b9f0f33d942a582edf" name="a9d3344a97644dad136bb47e852dda6fda24a42fc0479551b9f0f33d942a582edf"></a>S_READ_LEAD_MSG&#160;</td><td class="fielddoc"><p >Next message is lead message. </p>
<p >The case in these situations:</p><ul>
<li>Initial state (<a class="el" href="classipc_1_1transport_1_1struc_1_1sync__io_1_1Channel.html#a0c00bab2dad604dde176c4190553915c" title="Permanently memorizes the incoming-direction on-error handler, thus authorizing the emission of any i...">start_and_poll()</a>).</li>
<li>The last message was lead unstructured message comprised by a structured internal message. (An internal structured message = always 1 unstructured lead message.)</li>
<li>The last message was continuation unstructured message N of N comprised by a structured user message's serialization; where N is the segment count for the serialization of the user message. N itself is communicated in the lead unstructured message (the metadata). Ideally, and typically, N=1. </li>
</ul>
</td></tr>
<tr><td class="fieldname"><a id="a9d3344a97644dad136bb47e852dda6fda6d57adae739c502e8f906c7ad249cf80" name="a9d3344a97644dad136bb47e852dda6fda6d57adae739c502e8f906c7ad249cf80"></a>S_READ_CONT_MSG&#160;</td><td class="fielddoc"><p >Next message is continuation message. </p>
<p >The case in these situations:</p><ul>
<li>The last message was lead unstructured message comprised by a structured user message message. (An user structured message = always 1 unstructured lead message containing metadata + 1+ continuation messages comprised by structured user message's serialization.)</li>
<li>The last message was continuation unstructured message less-than-N of N comprised by a structured user message's serialization; where N is the segment count for the serialization of the user message. N itself is communicated in the lead unstructured message. Ideally, and typically, N=1. </li>
</ul>
</td></tr>
<tr><td class="fieldname"><a id="a9d3344a97644dad136bb47e852dda6fda06d91d8c95309c139826c9abbcb0a863" name="a9d3344a97644dad136bb47e852dda6fda06d91d8c95309c139826c9abbcb0a863"></a>S_STOP&#160;</td><td class="fielddoc"><p >The pipe should no longer be read-from ever (the case on error). </p>
</td></tr>
</table>

<p class="definition">Definition at line <a class="el" href="ipc__transport__structured_2src_2ipc_2transport_2struc_2sync__io_2channel_8hpp_source.html#l01244">1244</a> of file <a class="el" href="ipc__transport__structured_2src_2ipc_2transport_2struc_2sync__io_2channel_8hpp_source.html">channel.hpp</a>.</p>

</div>
</div>
<h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="a9385752ed00263dec5c5080b67ce0960" name="a9385752ed00263dec5c5080b67ce0960"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9385752ed00263dec5c5080b67ce0960">&#9670;&nbsp;</a></span>Channel() <span class="overload">[1/8]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Channel_obj , typename Message_body , typename Struct_builder_config , typename Struct_reader_config &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classipc_1_1transport_1_1struc_1_1sync__io_1_1Channel.html">ipc::transport::struc::sync_io::Channel</a>&lt; Channel_obj, Message_body, Struct_builder_config, Struct_reader_config &gt;::Channel </td>
          <td>(</td>
          <td class="paramtype">flow::log::Logger *&#160;</td>
          <td class="paramname"><em>logger_ptr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classipc_1_1transport_1_1struc_1_1sync__io_1_1Channel.html#a4abac89dbd4d26c79b7915990f751a76">Owned_channel</a> &amp;&amp;&#160;</td>
          <td class="paramname"><em>channel</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classipc_1_1transport_1_1struc_1_1sync__io_1_1Channel.html#a8a59bbc3c6a7191b316b23661d8ba6e3">Builder_config</a> &amp;&#160;</td>
          <td class="paramname"><em>struct_builder_config</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const typename Builder_config::Builder::Session &amp;&#160;</td>
          <td class="paramname"><em>struct_lender_session</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classipc_1_1transport_1_1struc_1_1sync__io_1_1Channel.html#a14a7166b2f8c117ce6ddafe943d036fa">Reader_config</a> &amp;&#160;</td>
          <td class="paramname"><em>struct_reader_config</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespaceipc_1_1transport_1_1struc.html#a6751c05fb6582a34c7c47ac470c4a48b">Session_token</a> &amp;&#160;</td>
          <td class="paramname"><em>session_token_non_nil</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">explicit</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Non-tag, no-log-in ctor form: Creates structured channel peer with no log-in phase (log-in phase must have occurred in a preceding <a class="el" href="classipc_1_1transport_1_1struc_1_1Channel.html" title="Owning and wrapping a pre-connected transport::Channel peer (an endpoint of an established channel ov...">struc::Channel</a> called <em>session master channel</em>), the session token already known and passed-in to this ctor. </p>
<p >Consider also:</p><ul>
<li>A tag-form ctor (usually simpler than manually cting <code>struct_builder_config</code> and <code>struct_reader_config</code>).</li>
<li>With-log-in ctor (usually needed for session master channel only).</li>
</ul>
<dl class="section note"><dt>Note</dt><dd>This ctor form is forwarded-to from <a class="el" href="classipc_1_1transport_1_1struc_1_1sync__io_1_1Channel.html#a6dc83bd6057b7f00a19c5947d6baa7b7" title="Useful for generic programming, the async-I/O-pattern counterpart to *this type.">Async_io_obj</a> ctor. Documentation below applies to both ctors except where noted.</dd></dl>
<p>If <code>*this</code> ctor is for <a class="el" href="classipc_1_1transport_1_1struc_1_1sync__io_1_1Channel.html" title="sync_io-pattern counterpart to async-I/O-pattern transport::struc::Channel.">sync_io::Channel</a>: You'll need to <a class="el" href="classipc_1_1transport_1_1struc_1_1sync__io_1_1Channel.html#a6e4f8c4207fcf678b4cfc785707d3dce" title="Sets up the sync_io-pattern interaction between *this and the user&#39;s event loop; required before asyn...">start_ops()</a> (possibly preceded by <a class="el" href="classipc_1_1transport_1_1struc_1_1sync__io_1_1Channel.html#a543aa806ec21b8550f9f440e59767d52" title="Analogous to transport::sync_io::Native_handle_sender::replace_event_wait_handles().">replace_event_wait_handles()</a>) per <code><a class="el" href="namespaceipc_1_1transport_1_1struc_1_1sync__io.html" title="sync_io-pattern counterparts to async-I/O-pattern object types in parent namespace ipc::transport::st...">sync_io</a></code> pattern. (If <code>*this</code> ctor is for <a class="el" href="classipc_1_1transport_1_1struc_1_1sync__io_1_1Channel.html#a6dc83bd6057b7f00a19c5947d6baa7b7" title="Useful for generic programming, the async-I/O-pattern counterpart to *this type.">Async_io_obj</a>: not applicable.) Then:</p>
<p >You may <a class="el" href="classipc_1_1transport_1_1struc_1_1sync__io_1_1Channel.html#a0dc388e18b0fc0fa2d8ad0a6953fb039" title="See Async_io_obj counterpart.">send()</a> (et al) immediately after this. However no in-messages shall be emitted, regardless of registered expectations such as via <a class="el" href="classipc_1_1transport_1_1struc_1_1sync__io_1_1Channel.html#a5fc489b9abefe5ab676f6991d6d03f0d" title="Registers the expectation (which may be immediately met) of up to 1 notification in-message whose Msg...">expect_msg()</a>, until you invoke <a class="el" href="classipc_1_1transport_1_1struc_1_1sync__io_1_1Channel.html#a0c00bab2dad604dde176c4190553915c" title="Permanently memorizes the incoming-direction on-error handler, thus authorizing the emission of any i...">start_and_poll()</a>. (For <a class="el" href="classipc_1_1transport_1_1struc_1_1sync__io_1_1Channel.html#a6dc83bd6057b7f00a19c5947d6baa7b7" title="Useful for generic programming, the async-I/O-pattern counterpart to *this type.">Async_io_obj</a>: <a class="el" href="classipc_1_1transport_1_1struc_1_1Channel.html#a33b4785c212ad88d8322fcc2f4369351" title="Permanently memorizes the incoming-direction on-error handler, thus authorizing the emission of any i...">transport::struc::Channel::start()</a>.)</p>
<p >Consider, also, <code><a class="el" href="classipc_1_1transport_1_1struc_1_1sync__io_1_1Channel.html#a9d97a5900bd517596b763db2d6b27b45" title="See Async_io_obj counterpart.">owned_channel_mutable()</a>-&gt;auto_ping()</code> and/or <code><a class="el" href="classipc_1_1transport_1_1struc_1_1sync__io_1_1Channel.html#a9d97a5900bd517596b763db2d6b27b45" title="See Async_io_obj counterpart.">owned_channel_mutable()</a>-&gt;idle_timer_run()</code>, if you desire these features to be ambiently enabled. See <a class="el" href="classipc_1_1transport_1_1Channel.html#a290395d720167759bfa1eda1e86bf123" title="Performs hndl_snd()-&gt; and/or blob_snd()-&gt; same method, returning true if all (1-2) invoked methods re...">Channel::auto_ping()</a>, <a class="el" href="classipc_1_1transport_1_1Channel.html#abf25364b49b9fdd3ba4b1541b3a50356" title="Performs hndl_rcv()-&gt; and/or blob_rcv()-&gt; same method, returning true if all (1-2) invoked methods re...">Channel::idle_timer_run()</a> for background.</p>
<h3>How/whether to obtain a <a class="el" href="classipc_1_1transport_1_1struc_1_1sync__io_1_1Channel.html#a8a59bbc3c6a7191b316b23661d8ba6e3" title="See Async_io_obj counterpart.">Builder_config</a> <code>struct_builder_config</code> (and related)</h3>
<p >It is easiest, usually, to use a different ctor form instead; namely use a tagged-ctor version that will set everything up. See <code>Channel_base::Serialize_via_*</code>. Only use the present ctor form:</p><ul>
<li>IF: your serialization strategy of choice is simply not covered by the tagged-ctor versions available (you have a custom builder/reader you want to use for advanced purposes). OR:</li>
<li>IF: you want to use a different serialization strategy in the outgoing direction versus incoming direction: e.g., this side sends only short things &ndash; and you want to use <a class="el" href="classipc_1_1transport_1_1struc_1_1Heap__fixed__builder.html" title="Implements Struct_builder concept by straightforwardly allocating fixed-size segments on-demand in th...">Heap_fixed_builder</a> here and <a class="el" href="classipc_1_1transport_1_1struc_1_1Heap__reader.html" title="Implements Struct_reader concept by straightforwardly interpreting a serialization by Heap_fixed_buil...">Heap_reader</a> there; but the other side sends huge things, so you want SHM-based serialization there and deserialization here. The tag ctors assume symmetry and don't support this.</li>
</ul>
<p >If you've chosen to use this ctor form:</p>
<p >Formally speaking it's simply up to you to construct these args before calling this ctor; see the docs for the particular <a class="el" href="classipc_1_1transport_1_1struc_1_1sync__io_1_1Channel.html#a8a59bbc3c6a7191b316b23661d8ba6e3" title="See Async_io_obj counterpart.">Builder_config</a> class of choice. Informally: if you're constructing the <a class="el" href="classipc_1_1transport_1_1struc_1_1sync__io_1_1Channel.html#a8a59bbc3c6a7191b316b23661d8ba6e3" title="See Async_io_obj counterpart.">Builder_config</a> and/or specifying <code>struct_lender_session</code> (less so <a class="el" href="classipc_1_1transport_1_1struc_1_1sync__io_1_1Channel.html#a14a7166b2f8c117ce6ddafe943d036fa" title="See Async_io_obj counterpart.">Reader_config</a>, but for consistency it too) directly, you're probably not doing the right thing. The following places are available to obtain tese for safety and efficiency (and code maintainability):</p><ul>
<li>From another, compatible, <code><a class="el" href="classipc_1_1transport_1_1struc_1_1sync__io_1_1Channel.html" title="sync_io-pattern counterpart to async-I/O-pattern transport::struc::Channel.">Channel</a></code> via <a class="el" href="classipc_1_1transport_1_1struc_1_1sync__io_1_1Channel.html#a48a8fd167c1fe6ae95d8fc80b6a6e67f" title="See Async_io_obj counterpart.">struct_builder_config()</a>, <a class="el" href="classipc_1_1transport_1_1struc_1_1sync__io_1_1Channel.html#a43fa0b77781376edd13b742b832572e1" title="See Async_io_obj counterpart.">struct_lender_session()</a>, <a class="el" href="classipc_1_1transport_1_1struc_1_1sync__io_1_1Channel.html#a7efbfbcce0d4d426b7df9b6d6fd1e373" title="See Async_io_obj counterpart.">struct_reader_config()</a>.</li>
<li>Heap-backed:<ul>
<li><code>struct_lender_session</code> is always <code>NULL_SESSION</code>. As for the other 2:</li>
<li>If you have the target <a class="el" href="classipc_1_1transport_1_1struc_1_1sync__io_1_1Channel.html#a4abac89dbd4d26c79b7915990f751a76" title="See Async_io_obj counterpart.">Owned_channel</a>: via <code>static</code> heap_fixed_builder_config() and heap_reader_config().</li>
<li>Otherwise: <a class="el" href="classipc_1_1session_1_1Session__mv.html#a107684fdd5d233549c6daac26a81a542" title="Utility that obtains a heap-based (non-zero-copy) Struct_builder::Config, constructed with the most e...">session::Session_mv::heap_fixed_builder_config()</a> (<code>static</code> or non-<code>static</code>), <a class="el" href="classipc_1_1session_1_1Session__mv.html#ab3c69e3f8ccbd70d315bed86d697255d" title="Deserializing counterpart to non-static heap_fixed_builder_config().">session::Session_mv::heap_reader_config()</a> (ditto).</li>
</ul>
</li>
<li>SHM-backed (using SHM-classic as example):<ul>
<li><a class="el" href="classipc_1_1session_1_1shm_1_1classic_1_1Session__mv.html#a85bb0b948b7b54c06557edd3d03d66bd" title="Returns builder config suitable for capnp-serializing out-messages in SHM arena session_shm().">session::shm::classic::Session_mv::session_shm_builder_config()</a> (ditto reader), <a class="el" href="classipc_1_1session_1_1shm_1_1classic_1_1Session__mv.html#a3af67219e611f450402824e5b8b162d6" title="When transmitting items originating in Arena session_shm() via transport::struc::shm::Builder::emit_s...">session::shm::classic::Session_mv::session_shm_lender_session()</a>, <a class="el" href="classipc_1_1session_1_1shm_1_1classic_1_1Session__mv.html#a0fbea0563835e852069cdaab506dd92c" title="Identical to session_shm_builder_config() but backed by SHM arena app_shm() instead of session_shm().">session::shm::classic::Session_mv::app_shm_builder_config()</a> (ditto reader), <a class="el" href="classipc_1_1session_1_1shm_1_1classic_1_1Session__mv.html#a0b7540b33fcedeaba37a3fece1bdec7a" title="When transmitting items originating in Arena app_shm() via transport::struc::shm::Builder::emit_seria...">session::shm::classic::Session_mv::app_shm_lender_session()</a>. Requires a <code>Session</code> object.</li>
<li><a class="el" href="classipc_1_1session_1_1shm_1_1classic_1_1Session__server.html#ad0dafea47293d23e079b6b5c5c6a9cef" title="Returns builder config suitable for capnp-serializing out-messages in SHM arena app_shm() for the sam...">session::shm::classic::Session_server::app_shm_builder_config()</a> (requires <a class="el" href="structipc_1_1session_1_1Client__app.html" title="An App that is used as a client in at least one client-server IPC split.">session::Client_app</a>). Server-only; if a <code>Session</code> is not available or applicable.</li>
</ul>
</li>
</ul>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">logger_ptr</td><td>Logger to use for logging subsequently. </td></tr>
    <tr><td class="paramname">channel</td><td><a class="el" href="classipc_1_1transport_1_1struc_1_1sync__io_1_1Channel.html" title="sync_io-pattern counterpart to async-I/O-pattern transport::struc::Channel.">Channel</a> in PEER state with no prior traffic. All configurations (1 pipe, 2 pipes) are supported. If <code>channel.initialized()</code> is <code>false</code>, behavior is undefined (assertion may trip): suggest sanity-checking this prior to this ctor. Behavior is undefined if it is not in PEER state or has had prior traffic. (Reminder: PEER state does not mean it isn't hosed from error/whatever: This is handled gracefully.) The channel is moved-into <code>*this</code>. </td></tr>
    <tr><td class="paramname">struct_builder_config</td><td>The serialization engine config to use for serializing out-messages. This small object is copied. </td></tr>
    <tr><td class="paramname">struct_lender_session</td><td>See <a class="el" href="classipc_1_1transport_1_1struc_1_1Struct__builder.html#ab90424897efed06ffc6b0884761fb31f" title="Type objects of which specify to emit_serialization() the opposing recipient for which the serializat...">Struct_builder::Session</a> (and/or <a class="el" href="classipc_1_1transport_1_1struc_1_1Struct__builder.html#a89874da2fb8c9f112a1152b0b38d2281" title="Returns the serialization in the form of a sequence of 1+ pointers to Blobs which are guaranteed to r...">Struct_builder::emit_serialization()</a>) concept doc header. This small value (typically a pointer) is copied; or the type may be <a class="el" href="structipc_1_1transport_1_1struc_1_1Null__session.html" title="Value for Struct_builder::Session when no extra information is needed when serializing Struct_builder...">Null_session</a> which is empty; then there is nothing to even copy. </td></tr>
    <tr><td class="paramname">struct_reader_config</td><td>The deserialization engine config to use for deserializing in-messages. This small object is copied. </td></tr>
    <tr><td class="paramname">session_token_non_nil</td><td>The session token to place into all out-messages and for which value to check against all in-messages. If a check fails, the channel is hosed immediately. Behavior undefined if it equals nil (assertion may trip). See class doc header regarding how to obtain the value to pass-in here. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="ipc__transport__structured_2src_2ipc_2transport_2struc_2sync__io_2channel_8hpp_source.html#l01972">1972</a> of file <a class="el" href="ipc__transport__structured_2src_2ipc_2transport_2struc_2sync__io_2channel_8hpp_source.html">channel.hpp</a>.</p>

<p class="reference">References <a class="el" href="ipc__transport__structured_2src_2ipc_2transport_2struc_2sync__io_2channel_8hpp_source.html#l01817">ipc::transport::struc::sync_io::Channel&lt; Channel_obj, Message_body, Struct_builder_config, Struct_reader_config &gt;::m_rcv_reassembly_q</a>, and <a class="el" href="ipc__transport__structured_2src_2ipc_2transport_2struc_2sync__io_2channel_8hpp_source.html#l01715">ipc::transport::struc::sync_io::Channel&lt; Channel_obj, Message_body, Struct_builder_config, Struct_reader_config &gt;::m_session_token</a>.</p>

</div>
</div>
<a id="a5b863cba6eec77f20236d1e8c8d006a3" name="a5b863cba6eec77f20236d1e8c8d006a3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5b863cba6eec77f20236d1e8c8d006a3">&#9670;&nbsp;</a></span>Channel() <span class="overload">[2/8]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Channel_obj , typename Message_body , typename Struct_builder_config , typename Struct_reader_config &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classipc_1_1transport_1_1struc_1_1sync__io_1_1Channel.html">ipc::transport::struc::sync_io::Channel</a>&lt; Channel_obj, Message_body, Struct_builder_config, Struct_reader_config &gt;::Channel </td>
          <td>(</td>
          <td class="paramtype">flow::log::Logger *&#160;</td>
          <td class="paramname"><em>logger_ptr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classipc_1_1transport_1_1struc_1_1sync__io_1_1Channel.html#a4abac89dbd4d26c79b7915990f751a76">Owned_channel</a> &amp;&amp;&#160;</td>
          <td class="paramname"><em>channel</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classipc_1_1transport_1_1struc_1_1sync__io_1_1Channel.html#a8a59bbc3c6a7191b316b23661d8ba6e3">Builder_config</a> &amp;&#160;</td>
          <td class="paramname"><em>struct_builder_config</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const typename Builder_config::Builder::Session &amp;&#160;</td>
          <td class="paramname"><em>struct_lender_session</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classipc_1_1transport_1_1struc_1_1sync__io_1_1Channel.html#a14a7166b2f8c117ce6ddafe943d036fa">Reader_config</a> &amp;&#160;</td>
          <td class="paramname"><em>struct_reader_config</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>is_server</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">explicit</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Non-tag, with-log-in ctor form: Creates structured channel peer (endpoint of the <em>session master channel</em>) with a log-in phase, this peer being the <em>server</em> or <em>client</em> depending on the arg <code>is_server</code>. </p>
<p >Consider also:</p><ul>
<li>A tag-form ctor (usually simpler than manually cting <code>struct_builder_config</code> and <code>struct_reader_config</code>).</li>
<li>No-log-in ctor (since present ctor is usually needed for session master channel only).</li>
</ul>
<p >No general user communication can occur until the log-in phase is completed. As such <code>*this</code> would be the <em>session master channel</em> with, presumably, exactly 1 such <code>*this</code> in the entire process at a given time. See <a class="el" href="classipc_1_1transport_1_1struc_1_1sync__io_1_1Channel.html#a6dc83bd6057b7f00a19c5947d6baa7b7" title="Useful for generic programming, the async-I/O-pattern counterpart to *this type.">Async_io_obj</a> class doc header for background.</p>
<dl class="section note"><dt>Note</dt><dd>This ctor form is forwarded-to from <a class="el" href="classipc_1_1transport_1_1struc_1_1sync__io_1_1Channel.html#a6dc83bd6057b7f00a19c5947d6baa7b7" title="Useful for generic programming, the async-I/O-pattern counterpart to *this type.">Async_io_obj</a> ctor. Documentation below applies to both ctors except where noted.</dd></dl>
<p>If <code>*this</code> ctor is for <a class="el" href="classipc_1_1transport_1_1struc_1_1sync__io_1_1Channel.html" title="sync_io-pattern counterpart to async-I/O-pattern transport::struc::Channel.">sync_io::Channel</a>: You'll need to <a class="el" href="classipc_1_1transport_1_1struc_1_1sync__io_1_1Channel.html#a6e4f8c4207fcf678b4cfc785707d3dce" title="Sets up the sync_io-pattern interaction between *this and the user&#39;s event loop; required before asyn...">start_ops()</a> (possibly preceded by <a class="el" href="classipc_1_1transport_1_1struc_1_1sync__io_1_1Channel.html#a543aa806ec21b8550f9f440e59767d52" title="Analogous to transport::sync_io::Native_handle_sender::replace_event_wait_handles().">replace_event_wait_handles()</a>) per <code><a class="el" href="namespaceipc_1_1transport_1_1struc_1_1sync__io.html" title="sync_io-pattern counterparts to async-I/O-pattern object types in parent namespace ipc::transport::st...">sync_io</a></code> pattern. (If <code>*this</code> ctor is for <a class="el" href="classipc_1_1transport_1_1struc_1_1sync__io_1_1Channel.html#a6dc83bd6057b7f00a19c5947d6baa7b7" title="Useful for generic programming, the async-I/O-pattern counterpart to *this type.">Async_io_obj</a>: not applicable.) Then:</p>
<p >You may <a class="el" href="classipc_1_1transport_1_1struc_1_1sync__io_1_1Channel.html#a0dc388e18b0fc0fa2d8ad0a6953fb039" title="See Async_io_obj counterpart.">send()</a> (et al) immediately after this. However no in-messages shall be emitted, regardless of registered expectations such as via <a class="el" href="classipc_1_1transport_1_1struc_1_1sync__io_1_1Channel.html#a5fc489b9abefe5ab676f6991d6d03f0d" title="Registers the expectation (which may be immediately met) of up to 1 notification in-message whose Msg...">expect_msg()</a>, until you invoke <a class="el" href="classipc_1_1transport_1_1struc_1_1sync__io_1_1Channel.html#a0c00bab2dad604dde176c4190553915c" title="Permanently memorizes the incoming-direction on-error handler, thus authorizing the emission of any i...">start_and_poll()</a>. (For <a class="el" href="classipc_1_1transport_1_1struc_1_1sync__io_1_1Channel.html#a6dc83bd6057b7f00a19c5947d6baa7b7" title="Useful for generic programming, the async-I/O-pattern counterpart to *this type.">Async_io_obj</a>: <a class="el" href="classipc_1_1transport_1_1struc_1_1Channel.html#a33b4785c212ad88d8322fcc2f4369351" title="Permanently memorizes the incoming-direction on-error handler, thus authorizing the emission of any i...">transport::struc::Channel::start()</a>.)</p>
<p >Consider, also, <code><a class="el" href="classipc_1_1transport_1_1struc_1_1sync__io_1_1Channel.html#a9d97a5900bd517596b763db2d6b27b45" title="See Async_io_obj counterpart.">owned_channel_mutable()</a>-&gt;auto_ping()</code> and/or <code><a class="el" href="classipc_1_1transport_1_1struc_1_1sync__io_1_1Channel.html#a9d97a5900bd517596b763db2d6b27b45" title="See Async_io_obj counterpart.">owned_channel_mutable()</a>-&gt;idle_timer_run()</code>, if you desire these features to be ambiently enabled. See <a class="el" href="classipc_1_1transport_1_1Channel.html#a290395d720167759bfa1eda1e86bf123" title="Performs hndl_snd()-&gt; and/or blob_snd()-&gt; same method, returning true if all (1-2) invoked methods re...">Channel::auto_ping()</a>, <a class="el" href="classipc_1_1transport_1_1Channel.html#abf25364b49b9fdd3ba4b1541b3a50356" title="Performs hndl_rcv()-&gt; and/or blob_rcv()-&gt; same method, returning true if all (1-2) invoked methods re...">Channel::idle_timer_run()</a> for background.</p>
<h3>As server</h3>
<p >To begin the log-in phase &ndash; and thus start to move to the logged-in phase, in which general traffic can occur &ndash; you must use <a class="el" href="classipc_1_1transport_1_1struc_1_1sync__io_1_1Channel.html#a996e06f75024e10987eb9cf62e096eec" title="In log-in phase as server only: Registers the expectation (which may be immediately met) of up to 1 l...">expect_log_in_request()</a>. <code>*this</code> will proceed to logged-in phase automatically once the log-in request message <code>M</code> arrives, and you then invoke <code>send(X, M)</code>, where <code>X</code> is the log-in response out-message you create/fill-out. To be clear the phase change occurs as the last step in that successful <a class="el" href="classipc_1_1transport_1_1struc_1_1sync__io_1_1Channel.html#a0dc388e18b0fc0fa2d8ad0a6953fb039" title="See Async_io_obj counterpart.">send()</a>.</p>
<h3>As client</h3>
<p >To begin the log-in phase &ndash; and thus start to move to the logged-in phase, in which general traffic can occur &ndash; you must <code>send(X, nullptr, nullptr, F)</code>, where <code>X</code> is the log-in request out-message you create/fill-out, while <code>F()</code> is the handler for the log-in response. <code>*this</code> will proceed to logged-in phase automatically once the response to X arrives; and will then invoke <code>F()</code> for any further validation the user may desire.</p>
<h3>How/whether to obtain a <a class="el" href="classipc_1_1transport_1_1struc_1_1sync__io_1_1Channel.html#a8a59bbc3c6a7191b316b23661d8ba6e3" title="See Async_io_obj counterpart.">Builder_config</a> <code>struct_builder_config</code> (and <a class="el" href="classipc_1_1transport_1_1struc_1_1sync__io_1_1Channel.html#a14a7166b2f8c117ce6ddafe943d036fa" title="See Async_io_obj counterpart.">Reader_config</a> similarly)</h3>
<p >See notes for the other (no-log-in) non-tag ctor overload.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">logger_ptr</td><td>See other ctor overload. </td></tr>
    <tr><td class="paramname">channel</td><td>See other ctor overload. </td></tr>
    <tr><td class="paramname">struct_builder_config</td><td>See other ctor overload. </td></tr>
    <tr><td class="paramname">struct_lender_session</td><td>See other ctor overload. </td></tr>
    <tr><td class="paramname">struct_reader_config</td><td>See other ctor overload. </td></tr>
    <tr><td class="paramname">is_server</td><td>See above. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="ipc__transport__structured_2src_2ipc_2transport_2struc_2sync__io_2channel_8hpp_source.html#l02012">2012</a> of file <a class="el" href="ipc__transport__structured_2src_2ipc_2transport_2struc_2sync__io_2channel_8hpp_source.html">channel.hpp</a>.</p>

<p class="reference">References <a class="el" href="ipc__transport__structured_2src_2ipc_2transport_2struc_2sync__io_2channel_8hpp_source.html#l01817">ipc::transport::struc::sync_io::Channel&lt; Channel_obj, Message_body, Struct_builder_config, Struct_reader_config &gt;::m_rcv_reassembly_q</a>.</p>

</div>
</div>
<a id="a81c366280bf0f3cd711eba0a9f81698f" name="a81c366280bf0f3cd711eba0a9f81698f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a81c366280bf0f3cd711eba0a9f81698f">&#9670;&nbsp;</a></span>Channel() <span class="overload">[3/8]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Channel_obj , typename Message_body , typename Struct_builder_config , typename Struct_reader_config &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classipc_1_1transport_1_1struc_1_1sync__io_1_1Channel.html">ipc::transport::struc::sync_io::Channel</a>&lt; Channel_obj, Message_body, Struct_builder_config, Struct_reader_config &gt;::Channel </td>
          <td>(</td>
          <td class="paramtype">flow::log::Logger *&#160;</td>
          <td class="paramname"><em>logger_ptr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classipc_1_1transport_1_1struc_1_1sync__io_1_1Channel.html#a4abac89dbd4d26c79b7915990f751a76">Owned_channel</a> &amp;&amp;&#160;</td>
          <td class="paramname"><em>channel</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structipc_1_1transport_1_1struc_1_1Channel__base_1_1Serialize__via__heap.html">Serialize_via_heap</a>&#160;</td>
          <td class="paramname"><em>tag</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespaceipc_1_1transport_1_1struc.html#a6751c05fb6582a34c7c47ac470c4a48b">Session_token</a> &amp;&#160;</td>
          <td class="paramname"><em>session_token_non_nil</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">explicit</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Tag version of non-tag, no-log-in ctor: Serialize_via_heap (bidirectional heap-based, non-zero-copy message serialization). </p>
<dl class="section see"><dt>See also</dt><dd>Serialize_via_heap doc header for serialization-related background. </dd>
<dd>
non-tag, no-log-in ctor. As directed there, use the present form whenever sufficient, and indeed you want this type of serialization setup. Consider also the other tag forms for other serialization methods which may match your requirements better.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">logger_ptr</td><td>See non-tag ctor form. </td></tr>
    <tr><td class="paramname">channel</td><td>See non-tag ctor form. </td></tr>
    <tr><td class="paramname">tag</td><td>Ctor-selecting tag. </td></tr>
    <tr><td class="paramname">session_token_non_nil</td><td>See non-tag ctor form. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="ipc__transport__structured_2src_2ipc_2transport_2struc_2sync__io_2channel_8hpp_source.html#l02055">2055</a> of file <a class="el" href="ipc__transport__structured_2src_2ipc_2transport_2struc_2sync__io_2channel_8hpp_source.html">channel.hpp</a>.</p>

</div>
</div>
<a id="aeb834160e2f34931c50291485d2d7d04" name="aeb834160e2f34931c50291485d2d7d04"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aeb834160e2f34931c50291485d2d7d04">&#9670;&nbsp;</a></span>Channel() <span class="overload">[4/8]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Channel_obj , typename Message_body , typename Struct_builder_config , typename Struct_reader_config &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classipc_1_1transport_1_1struc_1_1sync__io_1_1Channel.html">ipc::transport::struc::sync_io::Channel</a>&lt; Channel_obj, Message_body, Struct_builder_config, Struct_reader_config &gt;::Channel </td>
          <td>(</td>
          <td class="paramtype">flow::log::Logger *&#160;</td>
          <td class="paramname"><em>logger_ptr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classipc_1_1transport_1_1struc_1_1sync__io_1_1Channel.html#a4abac89dbd4d26c79b7915990f751a76">Owned_channel</a> &amp;&amp;&#160;</td>
          <td class="paramname"><em>channel</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structipc_1_1transport_1_1struc_1_1Channel__base_1_1Serialize__via__heap.html">Serialize_via_heap</a>&#160;</td>
          <td class="paramname"><em>tag</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>is_server</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">explicit</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Tag version of non-tag, with-log-in ctor: Serialize_via_heap (bidirectional heap-based, non-zero-copy message serialization). </p>
<dl class="section see"><dt>See also</dt><dd>Serialize_via_heap doc header for serialization-related background. </dd>
<dd>
non-tag, with-log-in ctor. As directed there, use the present form whenever sufficient, and indeed you want this type of serialization setup. Consider also the other tag forms for other serialization methods which may match your requirements better.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">logger_ptr</td><td>See non-tag ctor form. </td></tr>
    <tr><td class="paramname">channel</td><td>See non-tag ctor form. </td></tr>
    <tr><td class="paramname">tag</td><td>Ctor-selecting tag. </td></tr>
    <tr><td class="paramname">is_server</td><td>See non-tag ctor form. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="ipc__transport__structured_2src_2ipc_2transport_2struc_2sync__io_2channel_8hpp_source.html#l02067">2067</a> of file <a class="el" href="ipc__transport__structured_2src_2ipc_2transport_2struc_2sync__io_2channel_8hpp_source.html">channel.hpp</a>.</p>

</div>
</div>
<a id="a37296f3ac6713bd36d0c7b13d5f78fb7" name="a37296f3ac6713bd36d0c7b13d5f78fb7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a37296f3ac6713bd36d0c7b13d5f78fb7">&#9670;&nbsp;</a></span>Channel() <span class="overload">[5/8]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Channel_obj , typename Message_body , typename Struct_builder_config , typename Struct_reader_config &gt; </div>
<div class="memtemplate">
template&lt;typename Session &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classipc_1_1transport_1_1struc_1_1sync__io_1_1Channel.html">ipc::transport::struc::sync_io::Channel</a>&lt; Channel_obj, Message_body, Struct_builder_config, Struct_reader_config &gt;::Channel </td>
          <td>(</td>
          <td class="paramtype">flow::log::Logger *&#160;</td>
          <td class="paramname"><em>logger_ptr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classipc_1_1transport_1_1struc_1_1sync__io_1_1Channel.html#a4abac89dbd4d26c79b7915990f751a76">Owned_channel</a> &amp;&amp;&#160;</td>
          <td class="paramname"><em>channel</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structipc_1_1transport_1_1struc_1_1Channel__base_1_1Serialize__via__session__shm.html">Serialize_via_session_shm</a>&#160;</td>
          <td class="paramname"><em>tag</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Session *&#160;</td>
          <td class="paramname"><em>session</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespaceipc_1_1transport_1_1struc.html#a6751c05fb6582a34c7c47ac470c4a48b">Session_token</a> &amp;&#160;</td>
          <td class="paramname"><em>session_token_explicit</em> = <code><a class="el" href="namespaceipc_1_1transport_1_1struc.html#ad556d20a2aa2d52b83c7afb73951d47d">NULL_SESSION_TOKEN</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">explicit</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Tag version of non-tag, no-log-in ctor: Serialize_via_session_shm (bidirectional SHM-based provider, zero-copy message serialization, per-session-scope arena). </p>
<dl class="section see"><dt>See also</dt><dd>Serialize_via_session_shm doc header for serialization-related background. </dd>
<dd>
non-tag, no-log-in ctor. As directed there, use the present form whenever sufficient, and indeed you want this type of serialization setup. Consider also the other tag forms for other serialization methods which may match your requirements better.</dd></dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Session</td><td>One of, at least: <a class="el" href="namespaceipc_1_1session_1_1shm_1_1classic.html#ac6c443a72e0f22710c83bb1e8c229618" title="This is to session::Client_session what shm::classic::Server_session is to session::Server_session.">session::shm::classic::Client_session</a>, <a class="el" href="classipc_1_1session_1_1shm_1_1classic_1_1Server__session.html" title="Identical to session::Server_session in every way, except that it makes available two SHM arenas,...">session::shm::classic::Server_session</a>, <a class="el" href="namespaceipc_1_1session_1_1shm_1_1arena__lend_1_1jemalloc.html#a837b4566cb2a734eb0ba58f285d084fe" title="This is to session::Client_session what shm::arena_lend::jemalloc::Server_session is to session::Serv...">session::shm::arena_lend::jemalloc::Client_session</a>, <a class="el" href="classipc_1_1session_1_1shm_1_1arena__lend_1_1jemalloc_1_1Server__session.html" title="Identical to session::Server_session in every way, except that it makes available two SHM arenas,...">session::shm::arena_lend::jemalloc::Server_session</a>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">logger_ptr</td><td>See non-tag ctor form. </td></tr>
    <tr><td class="paramname">channel</td><td>See non-tag ctor form. </td></tr>
    <tr><td class="paramname">tag</td><td>Ctor-selecting tag. </td></tr>
    <tr><td class="paramname">session</td><td><code>session-&gt;session_shm()</code> shall be used as the backing SHM space. <code>*session</code> must be in PEER state, or behavior is undefined. </td></tr>
    <tr><td class="paramname">session_token_explicit</td><td>See non-tag ctor form. However, for convenience, if you instead supply value equal to <code>NULL_SESSION_TOKEN</code> (i.e., nil) (which is default), then <code>session-&gt;<a class="el" href="classipc_1_1transport_1_1struc_1_1sync__io_1_1Channel.html#a021bb07a76c54837619c7a91dbd5de03" title="See Async_io_obj counterpart.">session_token()</a></code> shall be used. After all... why not? That's probably what you want. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="ipc__transport__structured_2src_2ipc_2transport_2struc_2sync__io_2channel_8hpp_source.html#l02080">2080</a> of file <a class="el" href="ipc__transport__structured_2src_2ipc_2transport_2struc_2sync__io_2channel_8hpp_source.html">channel.hpp</a>.</p>

</div>
</div>
<a id="a2ec1232d7b9c59526f7d1a3c62483269" name="a2ec1232d7b9c59526f7d1a3c62483269"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2ec1232d7b9c59526f7d1a3c62483269">&#9670;&nbsp;</a></span>Channel() <span class="overload">[6/8]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Channel_obj , typename Message_body , typename Struct_builder_config , typename Struct_reader_config &gt; </div>
<div class="memtemplate">
template&lt;typename Session &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classipc_1_1transport_1_1struc_1_1sync__io_1_1Channel.html">ipc::transport::struc::sync_io::Channel</a>&lt; Channel_obj, Message_body, Struct_builder_config, Struct_reader_config &gt;::Channel </td>
          <td>(</td>
          <td class="paramtype">flow::log::Logger *&#160;</td>
          <td class="paramname"><em>logger_ptr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classipc_1_1transport_1_1struc_1_1sync__io_1_1Channel.html#a4abac89dbd4d26c79b7915990f751a76">Owned_channel</a> &amp;&amp;&#160;</td>
          <td class="paramname"><em>channel</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structipc_1_1transport_1_1struc_1_1Channel__base_1_1Serialize__via__session__shm.html">Serialize_via_session_shm</a>&#160;</td>
          <td class="paramname"><em>tag</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Session *&#160;</td>
          <td class="paramname"><em>session</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>is_server</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">explicit</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Tag version of non-tag, with-log-in ctor: Serialize_via_session_shm (bidirectional SHM-based provider, zero-copy message serialization, per-session-scope arena). </p>
<dl class="section see"><dt>See also</dt><dd>Serialize_via_session_shm doc header for serialization-related background. </dd>
<dd>
non-tag, no-log-in ctor. As directed there, use the present form whenever sufficient, and indeed you want this type of serialization setup. Consider also the other tag forms for other serialization methods which may match your requirements better.</dd></dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Session</td><td>One of, at least: <a class="el" href="namespaceipc_1_1session_1_1shm_1_1classic.html#ac6c443a72e0f22710c83bb1e8c229618" title="This is to session::Client_session what shm::classic::Server_session is to session::Server_session.">session::shm::classic::Client_session</a>, <a class="el" href="classipc_1_1session_1_1shm_1_1classic_1_1Server__session.html" title="Identical to session::Server_session in every way, except that it makes available two SHM arenas,...">session::shm::classic::Server_session</a>, <a class="el" href="namespaceipc_1_1session_1_1shm_1_1arena__lend_1_1jemalloc.html#a837b4566cb2a734eb0ba58f285d084fe" title="This is to session::Client_session what shm::arena_lend::jemalloc::Server_session is to session::Serv...">session::shm::arena_lend::jemalloc::Client_session</a>, <a class="el" href="classipc_1_1session_1_1shm_1_1arena__lend_1_1jemalloc_1_1Server__session.html" title="Identical to session::Server_session in every way, except that it makes available two SHM arenas,...">session::shm::arena_lend::jemalloc::Server_session</a>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">logger_ptr</td><td>See non-tag ctor form. </td></tr>
    <tr><td class="paramname">channel</td><td>See non-tag ctor form. </td></tr>
    <tr><td class="paramname">tag</td><td>Ctor-selecting tag. </td></tr>
    <tr><td class="paramname">session</td><td><code>session-&gt;session_shm()</code> shall be used as the backing SHM space. <code>*session</code> must be in PEER state, or behavior is undefined. </td></tr>
    <tr><td class="paramname">is_server</td><td>See non-tag ctor form. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="ipc__transport__structured_2src_2ipc_2transport_2struc_2sync__io_2channel_8hpp_source.html#l02095">2095</a> of file <a class="el" href="ipc__transport__structured_2src_2ipc_2transport_2struc_2sync__io_2channel_8hpp_source.html">channel.hpp</a>.</p>

</div>
</div>
<a id="a454d0ced89cda0b092d4f86897400e1c" name="a454d0ced89cda0b092d4f86897400e1c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a454d0ced89cda0b092d4f86897400e1c">&#9670;&nbsp;</a></span>Channel() <span class="overload">[7/8]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Channel_obj , typename Message_body , typename Struct_builder_config , typename Struct_reader_config &gt; </div>
<div class="memtemplate">
template&lt;typename Session &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classipc_1_1transport_1_1struc_1_1sync__io_1_1Channel.html">ipc::transport::struc::sync_io::Channel</a>&lt; Channel_obj, Message_body, Struct_builder_config, Struct_reader_config &gt;::Channel </td>
          <td>(</td>
          <td class="paramtype">flow::log::Logger *&#160;</td>
          <td class="paramname"><em>logger_ptr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classipc_1_1transport_1_1struc_1_1sync__io_1_1Channel.html#a4abac89dbd4d26c79b7915990f751a76">Owned_channel</a> &amp;&amp;&#160;</td>
          <td class="paramname"><em>channel</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structipc_1_1transport_1_1struc_1_1Channel__base_1_1Serialize__via__app__shm.html">Serialize_via_app_shm</a>&#160;</td>
          <td class="paramname"><em>tag</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Session *&#160;</td>
          <td class="paramname"><em>session</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespaceipc_1_1transport_1_1struc.html#a6751c05fb6582a34c7c47ac470c4a48b">Session_token</a> &amp;&#160;</td>
          <td class="paramname"><em>session_token_explicit</em> = <code><a class="el" href="namespaceipc_1_1transport_1_1struc.html#ad556d20a2aa2d52b83c7afb73951d47d">NULL_SESSION_TOKEN</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">explicit</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Tag version of non-tag, no-log-in ctor: Serialize_via_app_shm (bidirectional SHM-based provider, zero-copy message serialization, per-app-scope arena). </p>
<dl class="section see"><dt>See also</dt><dd>Serialize_via_app_shm doc header for serialization-related background. </dd>
<dd>
non-tag, no-log-in ctor. As directed there, use the present form whenever sufficient, and indeed you want this type of serialization setup. Consider also the other tag forms for other serialization methods which may match your requirements better.</dd></dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Session</td><td>One of, at least: <a class="el" href="namespaceipc_1_1session_1_1shm_1_1classic.html#ac6c443a72e0f22710c83bb1e8c229618" title="This is to session::Client_session what shm::classic::Server_session is to session::Server_session.">session::shm::classic::Client_session</a>, <a class="el" href="classipc_1_1session_1_1shm_1_1classic_1_1Server__session.html" title="Identical to session::Server_session in every way, except that it makes available two SHM arenas,...">session::shm::classic::Server_session</a>, <a class="el" href="classipc_1_1session_1_1shm_1_1arena__lend_1_1jemalloc_1_1Server__session.html" title="Identical to session::Server_session in every way, except that it makes available two SHM arenas,...">session::shm::arena_lend::jemalloc::Server_session</a> (not <a class="el" href="namespaceipc_1_1session_1_1shm_1_1arena__lend_1_1jemalloc.html#a837b4566cb2a734eb0ba58f285d084fe" title="This is to session::Client_session what shm::arena_lend::jemalloc::Server_session is to session::Serv...">session::shm::arena_lend::jemalloc::Client_session</a> &ndash; will not compile). </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">logger_ptr</td><td>See non-tag ctor form. </td></tr>
    <tr><td class="paramname">channel</td><td>See non-tag ctor form. </td></tr>
    <tr><td class="paramname">tag</td><td>Ctor-selecting tag. </td></tr>
    <tr><td class="paramname">session</td><td><code>session-&gt;app_shm()</code> shall be used as the backing SHM space. <code>*session</code> must be in PEER state, or behavior is undefined. </td></tr>
    <tr><td class="paramname">session_token_explicit</td><td>See <code>session_token_explicit</code> in the Serialize_via_session_shm counterpart to this ctor form. Spoiler alert: probably you'll want to leave this at default. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="ipc__transport__structured_2src_2ipc_2transport_2struc_2sync__io_2channel_8hpp_source.html#l02108">2108</a> of file <a class="el" href="ipc__transport__structured_2src_2ipc_2transport_2struc_2sync__io_2channel_8hpp_source.html">channel.hpp</a>.</p>

</div>
</div>
<a id="ac056b37680ded4b3c26dd4c6941a72c6" name="ac056b37680ded4b3c26dd4c6941a72c6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac056b37680ded4b3c26dd4c6941a72c6">&#9670;&nbsp;</a></span>Channel() <span class="overload">[8/8]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Channel_obj , typename Message_body , typename Struct_builder_config , typename Struct_reader_config &gt; </div>
<div class="memtemplate">
template&lt;typename Session &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classipc_1_1transport_1_1struc_1_1sync__io_1_1Channel.html">ipc::transport::struc::sync_io::Channel</a>&lt; Channel_obj, Message_body, Struct_builder_config, Struct_reader_config &gt;::Channel </td>
          <td>(</td>
          <td class="paramtype">flow::log::Logger *&#160;</td>
          <td class="paramname"><em>logger_ptr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classipc_1_1transport_1_1struc_1_1sync__io_1_1Channel.html#a4abac89dbd4d26c79b7915990f751a76">Owned_channel</a> &amp;&amp;&#160;</td>
          <td class="paramname"><em>channel</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structipc_1_1transport_1_1struc_1_1Channel__base_1_1Serialize__via__app__shm.html">Serialize_via_app_shm</a>&#160;</td>
          <td class="paramname"><em>tag</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Session *&#160;</td>
          <td class="paramname"><em>session</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>is_server</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">explicit</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Tag version of non-tag, no-log-in ctor: Serialize_via_app_shm (bidirectional SHM-based provider, zero-copy message serialization, per-app-scope arena). </p>
<dl class="section see"><dt>See also</dt><dd>Serialize_via_app_shm doc header for serialization-related background. </dd>
<dd>
non-tag, no-log-in ctor. As directed there, use the present form whenever sufficient, and indeed you want this type of serialization setup. Consider also the other tag forms for other serialization methods which may match your requirements better.</dd></dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Session</td><td>One of, at least: <a class="el" href="namespaceipc_1_1session_1_1shm_1_1classic.html#ac6c443a72e0f22710c83bb1e8c229618" title="This is to session::Client_session what shm::classic::Server_session is to session::Server_session.">session::shm::classic::Client_session</a>, <a class="el" href="classipc_1_1session_1_1shm_1_1classic_1_1Server__session.html" title="Identical to session::Server_session in every way, except that it makes available two SHM arenas,...">session::shm::classic::Server_session</a>, <a class="el" href="classipc_1_1session_1_1shm_1_1arena__lend_1_1jemalloc_1_1Server__session.html" title="Identical to session::Server_session in every way, except that it makes available two SHM arenas,...">session::shm::arena_lend::jemalloc::Server_session</a> (not ession::shm::arena_lend::jemalloc::Client_session &ndash; will not compile). </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">logger_ptr</td><td>See non-tag ctor form. </td></tr>
    <tr><td class="paramname">channel</td><td>See non-tag ctor form. </td></tr>
    <tr><td class="paramname">tag</td><td>Ctor-selecting tag. </td></tr>
    <tr><td class="paramname">session</td><td><code>session-&gt;app_shm()</code> shall be used as the backing SHM space. <code>*session</code> must be in PEER state, or behavior is undefined. </td></tr>
    <tr><td class="paramname">is_server</td><td>See non-tag ctor form. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="ipc__transport__structured_2src_2ipc_2transport_2struc_2sync__io_2channel_8hpp_source.html#l02123">2123</a> of file <a class="el" href="ipc__transport__structured_2src_2ipc_2transport_2struc_2sync__io_2channel_8hpp_source.html">channel.hpp</a>.</p>

</div>
</div>
<a id="aac7386bca503f1457d93c65e1bfdf71f" name="aac7386bca503f1457d93c65e1bfdf71f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aac7386bca503f1457d93c65e1bfdf71f">&#9670;&nbsp;</a></span>~Channel()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Channel_obj , typename Message_body , typename Struct_builder_config , typename Struct_reader_config &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classipc_1_1transport_1_1struc_1_1sync__io_1_1Channel.html">ipc::transport::struc::sync_io::Channel</a>&lt; Channel_obj, Message_body, Struct_builder_config, Struct_reader_config &gt;::~<a class="el" href="classipc_1_1transport_1_1struc_1_1sync__io_1_1Channel.html">Channel</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Invokes the destructor on the <a class="el" href="classipc_1_1transport_1_1struc_1_1sync__io_1_1Channel.html#a4abac89dbd4d26c79b7915990f751a76" title="See Async_io_obj counterpart.">Owned_channel</a>. </p>
<p >Reminder: It is recommended, before invoking this destructor, to:</p><ul>
<li>Call <code>async_end_sending(F)</code>.</li>
<li>Invoke this destructor once <code>F()</code> fires.</li>
</ul>
<p >See discussion in <a class="el" href="classipc_1_1transport_1_1struc_1_1sync__io_1_1Channel.html#ae4a2a63dc88722d96ee9f3ed68cf7b86" title="See Async_io_obj counterpart; except (1) naturally on_done_func() is invoked in the sync_io-pattern f...">async_end_sending()</a> doc header or shorter version in class doc header. </p>

<p class="definition">Definition at line <a class="el" href="ipc__transport__structured_2src_2ipc_2transport_2struc_2sync__io_2channel_8hpp_source.html#l02135">2135</a> of file <a class="el" href="ipc__transport__structured_2src_2ipc_2transport_2struc_2sync__io_2channel_8hpp_source.html">channel.hpp</a>.</p>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="ae4a2a63dc88722d96ee9f3ed68cf7b86" name="ae4a2a63dc88722d96ee9f3ed68cf7b86"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae4a2a63dc88722d96ee9f3ed68cf7b86">&#9670;&nbsp;</a></span>async_end_sending()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Channel_obj , typename Message_body , typename Struct_builder_config , typename Struct_reader_config &gt; </div>
<div class="memtemplate">
template&lt;typename Task_err &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classipc_1_1transport_1_1struc_1_1sync__io_1_1Channel.html">ipc::transport::struc::sync_io::Channel</a>&lt; Channel_obj, Message_body, Struct_builder_config, Struct_reader_config &gt;::async_end_sending </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespaceipc.html#aa3192e586cc45d3e7c22463bf2760f89">Error_code</a> *&#160;</td>
          <td class="paramname"><em>sync_err_code</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Task_err &amp;&amp;&#160;</td>
          <td class="paramname"><em>on_done_func</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>See <a class="el" href="classipc_1_1transport_1_1struc_1_1sync__io_1_1Channel.html#a6dc83bd6057b7f00a19c5947d6baa7b7" title="Useful for generic programming, the async-I/O-pattern counterpart to *this type.">Async_io_obj</a> counterpart; except (1) naturally <code>on_done_func()</code> is invoked in the <code><a class="el" href="namespaceipc_1_1transport_1_1struc_1_1sync__io.html" title="sync_io-pattern counterparts to async-I/O-pattern object types in parent namespace ipc::transport::st...">sync_io</a></code>-pattern fashion, and (2) the operation may (and is very likely to) complete synchronously and thus ignore <code>on_done_func</code>. </p>
<dl class="section note"><dt>Note</dt><dd>It is highly recommended to read the <a class="el" href="classipc_1_1transport_1_1struc_1_1sync__io_1_1Channel.html#a6dc83bd6057b7f00a19c5947d6baa7b7" title="Useful for generic programming, the async-I/O-pattern counterpart to *this type.">Async_io_obj</a> <a class="el" href="classipc_1_1transport_1_1struc_1_1Channel.html#ab08057edd9832d94ea0e18a17c42200a" title="Operating at the unstructured layer, executes a graceful-close send by forwarding to the async transp...">transport::struc::Channel::async_end_sending()</a> doc header's recommendations on how/when/why to use the method.</dd></dl>
<p>The sync-versus-async-completion dichotomy is exactly forwarded from <a class="el" href="classipc_1_1transport_1_1struc_1_1sync__io_1_1Channel.html#a4abac89dbd4d26c79b7915990f751a76" title="See Async_io_obj counterpart.">Owned_channel</a>, and you can read the details in <a class="el" href="classipc_1_1transport_1_1sync__io_1_1Native__handle__sender.html#a9b99e18949cf819bfae4e08e44744fc6" title="Equivalent to send_native_handle() but sends a graceful-close message instead of the usual payload; t...">sync_io::Native_handle_sender::async_end_sending()</a> doc header.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Task_err</td><td>See above. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">sync_err_code</td><td>See above. </td></tr>
    <tr><td class="paramname">on_done_func</td><td>See above. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>See above. In addition <code>false</code> returned if called before <a class="el" href="classipc_1_1transport_1_1struc_1_1sync__io_1_1Channel.html#a6e4f8c4207fcf678b4cfc785707d3dce" title="Sets up the sync_io-pattern interaction between *this and the user&#39;s event loop; required before asyn...">start_ops()</a>. </dd></dl>

<p class="definition">Definition at line <a class="el" href="ipc__transport__structured_2src_2ipc_2transport_2struc_2sync__io_2channel_8hpp_source.html#l04122">4122</a> of file <a class="el" href="ipc__transport__structured_2src_2ipc_2transport_2struc_2sync__io_2channel_8hpp_source.html">channel.hpp</a>.</p>

</div>
</div>
<a id="a26dc83067e005be38567199cbedd7f19" name="a26dc83067e005be38567199cbedd7f19"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a26dc83067e005be38567199cbedd7f19">&#9670;&nbsp;</a></span>async_request()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Channel_obj , typename Message_body , typename Struct_builder_config , typename Struct_reader_config &gt; </div>
<div class="memtemplate">
template&lt;typename On_msg_handler &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classipc_1_1transport_1_1struc_1_1sync__io_1_1Channel.html">ipc::transport::struc::sync_io::Channel</a>&lt; Channel_obj, Message_body, Struct_builder_config, Struct_reader_config &gt;::async_request </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classipc_1_1transport_1_1struc_1_1sync__io_1_1Channel.html#a83fb4462a8d4045bdb56b694bf80393c">Msg_out</a> &amp;&#160;</td>
          <td class="paramname"><em>msg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classipc_1_1transport_1_1struc_1_1sync__io_1_1Channel.html#ac3da0ac1306b63c9e38c47b8c31e3cd2">Msg_in</a> *&#160;</td>
          <td class="paramname"><em>originating_msg_or_null</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classipc_1_1transport_1_1struc_1_1Channel__base.html#adcf24fa51747ed83c4b6427fbf44fecf">msg_id_out_t</a> *&#160;</td>
          <td class="paramname"><em>id_unless_one_off</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">On_msg_handler &amp;&amp;&#160;</td>
          <td class="paramname"><em>on_rsp_func</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceipc.html#aa3192e586cc45d3e7c22463bf2760f89">Error_code</a> *&#160;</td>
          <td class="paramname"><em>err_code</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>See <a class="el" href="classipc_1_1transport_1_1struc_1_1sync__io_1_1Channel.html#a6dc83bd6057b7f00a19c5947d6baa7b7" title="Useful for generic programming, the async-I/O-pattern counterpart to *this type.">Async_io_obj</a> counterpart; though naturally <code>on_rsp_func()</code> is invoked in the <code><a class="el" href="namespaceipc_1_1transport_1_1struc_1_1sync__io.html" title="sync_io-pattern counterparts to async-I/O-pattern object types in parent namespace ipc::transport::st...">sync_io</a></code>-pattern fashion. </p>
<p >There is no possibility of the response expectation being immediately (synchronously) met.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">On_msg_handler</td><td>See <a class="el" href="classipc_1_1transport_1_1struc_1_1sync__io_1_1Channel.html#a5fc489b9abefe5ab676f6991d6d03f0d" title="Registers the expectation (which may be immediately met) of up to 1 notification in-message whose Msg...">expect_msg()</a>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">msg</td><td>See above. </td></tr>
    <tr><td class="paramname">originating_msg_or_null</td><td>See above. </td></tr>
    <tr><td class="paramname">id_unless_one_off</td><td>See above. </td></tr>
    <tr><td class="paramname">on_rsp_func</td><td>See above. </td></tr>
    <tr><td class="paramname">err_code</td><td>See above. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>See above. In addition <code>false</code> returned if called before <a class="el" href="classipc_1_1transport_1_1struc_1_1sync__io_1_1Channel.html#a6e4f8c4207fcf678b4cfc785707d3dce" title="Sets up the sync_io-pattern interaction between *this and the user&#39;s event loop; required before asyn...">start_ops()</a>. </dd></dl>

<p class="definition">Definition at line <a class="el" href="ipc__transport__structured_2src_2ipc_2transport_2struc_2sync__io_2channel_8hpp_source.html#l03762">3762</a> of file <a class="el" href="ipc__transport__structured_2src_2ipc_2transport_2struc_2sync__io_2channel_8hpp_source.html">channel.hpp</a>.</p>

</div>
</div>
<a id="ae2a7cdf855b3cdcab1a2e1cd74834cc4" name="ae2a7cdf855b3cdcab1a2e1cd74834cc4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae2a7cdf855b3cdcab1a2e1cd74834cc4">&#9670;&nbsp;</a></span>check_not_started_ops()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Channel_obj , typename Message_body , typename Struct_builder_config , typename Struct_reader_config &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classipc_1_1transport_1_1struc_1_1sync__io_1_1Channel.html">ipc::transport::struc::sync_io::Channel</a>&lt; Channel_obj, Message_body, Struct_builder_config, Struct_reader_config &gt;::check_not_started_ops </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespaceipc_1_1util.html#ae6ac47812a90d1287c61e0b7de7bc4f5">util::String_view</a>&#160;</td>
          <td class="paramname"><em>context</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Helper that returns <code>true</code> if and only if <a class="el" href="classipc_1_1transport_1_1struc_1_1sync__io_1_1Channel.html#a6e4f8c4207fcf678b4cfc785707d3dce" title="Sets up the sync_io-pattern interaction between *this and the user&#39;s event loop; required before asyn...">start_ops()</a> has not yet been called. </p>
<p >This guard is required for APIs that trigger <a class="el" href="classipc_1_1transport_1_1struc_1_1sync__io_1_1Channel.html#abe17c6f98af890eaf522c97eb21e2e35" title="The Channel taken-over in ctor, lifetime until dtor.">m_channel</a> transmission API calls. Outgoing-direction such calls would be, e.g., <a class="el" href="classipc_1_1transport_1_1struc_1_1sync__io_1_1Channel.html#a0dc388e18b0fc0fa2d8ad0a6953fb039" title="See Async_io_obj counterpart.">send()</a> and <a class="el" href="classipc_1_1transport_1_1struc_1_1sync__io_1_1Channel.html#ae4a2a63dc88722d96ee9f3ed68cf7b86" title="See Async_io_obj counterpart; except (1) naturally on_done_func() is invoked in the sync_io-pattern f...">async_end_sending()</a>. Incoming-direction transmission is all triggered by <a class="el" href="classipc_1_1transport_1_1struc_1_1sync__io_1_1Channel.html#a0c00bab2dad604dde176c4190553915c" title="Permanently memorizes the incoming-direction on-error handler, thus authorizing the emission of any i...">start_and_poll()</a> (which begins the async-read chain(s) indefinitely.)</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">context</td><td>Brief context string for logging. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if not started (do not proceed); else <code>false</code>. </dd></dl>

<p class="definition">Definition at line <a class="el" href="ipc__transport__structured_2src_2ipc_2transport_2struc_2sync__io_2channel_8hpp_source.html#l02262">2262</a> of file <a class="el" href="ipc__transport__structured_2src_2ipc_2transport_2struc_2sync__io_2channel_8hpp_source.html">channel.hpp</a>.</p>

</div>
</div>
<a id="ae6b2691d6471330d8b7cc7e8e9320054" name="ae6b2691d6471330d8b7cc7e8e9320054"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae6b2691d6471330d8b7cc7e8e9320054">&#9670;&nbsp;</a></span>check_phase_and_prior_error()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Channel_obj , typename Message_body , typename Struct_builder_config , typename Struct_reader_config &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classipc_1_1transport_1_1struc_1_1sync__io_1_1Channel.html">ipc::transport::struc::sync_io::Channel</a>&lt; Channel_obj, Message_body, Struct_builder_config, Struct_reader_config &gt;::check_phase_and_prior_error </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classipc_1_1transport_1_1struc_1_1sync__io_1_1Channel.html#a5a3833cd141802041551db21198ac319">Phase</a>&#160;</td>
          <td class="paramname"><em>required_phase</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceipc_1_1util.html#ae6ac47812a90d1287c61e0b7de7bc4f5">util::String_view</a>&#160;</td>
          <td class="paramname"><em>context</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Helper for most public APIs to use at the top: ensures <a class="el" href="classipc_1_1transport_1_1struc_1_1sync__io_1_1Channel.html#abeb37ac07422166123553920393d5ab4" title="Helper for some public APIs to use at the top: ensures that no prior error has been detected (by inco...">check_prior_error()</a> passes, and that <a class="el" href="classipc_1_1transport_1_1struc_1_1sync__io_1_1Channel.html#afca9a3012b2f41d635381a5a13ddd7c1" title="Phase (w/r/t log-in or lack thereof) of *this peer.">m_phase</a> equals <code>required_phase</code>; returns <code>true</code> if not; <code>false</code> if so. </p>
<p >I.e., please no-op if returns <code>true</code>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">required_phase</td><td><a class="el" href="classipc_1_1transport_1_1struc_1_1sync__io_1_1Channel.html#afca9a3012b2f41d635381a5a13ddd7c1" title="Phase (w/r/t log-in or lack thereof) of *this peer.">m_phase</a> must equal this to return <code>false</code>. </td></tr>
    <tr><td class="paramname">context</td><td>Brief context string for logging. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>See above. <code>true</code> bad. <code>false</code> good. </dd></dl>

<p class="definition">Definition at line <a class="el" href="ipc__transport__structured_2src_2ipc_2transport_2struc_2sync__io_2channel_8hpp_source.html#l04148">4148</a> of file <a class="el" href="ipc__transport__structured_2src_2ipc_2transport_2struc_2sync__io_2channel_8hpp_source.html">channel.hpp</a>.</p>

</div>
</div>
<a id="abeb37ac07422166123553920393d5ab4" name="abeb37ac07422166123553920393d5ab4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abeb37ac07422166123553920393d5ab4">&#9670;&nbsp;</a></span>check_prior_error()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Channel_obj , typename Message_body , typename Struct_builder_config , typename Struct_reader_config &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classipc_1_1transport_1_1struc_1_1sync__io_1_1Channel.html">ipc::transport::struc::sync_io::Channel</a>&lt; Channel_obj, Message_body, Struct_builder_config, Struct_reader_config &gt;::check_prior_error </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespaceipc_1_1util.html#ae6ac47812a90d1287c61e0b7de7bc4f5">util::String_view</a>&#160;</td>
          <td class="paramname"><em>context</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Helper for some public APIs to use at the top: ensures that no prior error has been detected (by incoming-direction processing or <a class="el" href="classipc_1_1transport_1_1struc_1_1sync__io_1_1Channel.html#a0dc388e18b0fc0fa2d8ad0a6953fb039" title="See Async_io_obj counterpart.">send()</a>); returns <code>true</code> if not; <code>false</code> if so. </p>
<p >I.e., please no-op if returns <code>true</code>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">context</td><td>Brief context string for logging. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>See above. <code>true</code> bad. <code>false</code> good. </dd></dl>

<p class="definition">Definition at line <a class="el" href="ipc__transport__structured_2src_2ipc_2transport_2struc_2sync__io_2channel_8hpp_source.html#l04134">4134</a> of file <a class="el" href="ipc__transport__structured_2src_2ipc_2transport_2struc_2sync__io_2channel_8hpp_source.html">channel.hpp</a>.</p>

</div>
</div>
<a id="ae43681c46951acd7e3c06d3cd73854f6" name="ae43681c46951acd7e3c06d3cd73854f6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae43681c46951acd7e3c06d3cd73854f6">&#9670;&nbsp;</a></span>check_unsendable()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Channel_obj , typename Message_body , typename Struct_builder_config , typename Struct_reader_config &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classipc_1_1transport_1_1struc_1_1sync__io_1_1Channel.html">ipc::transport::struc::sync_io::Channel</a>&lt; Channel_obj, Message_body, Struct_builder_config, Struct_reader_config &gt;::check_unsendable </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classipc_1_1transport_1_1struc_1_1sync__io_1_1Channel.html#a83fb4462a8d4045bdb56b694bf80393c">Msg_out</a> &amp;&#160;</td>
          <td class="paramname"><em>msg</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><a class="el" href="classipc_1_1transport_1_1struc_1_1sync__io_1_1Channel.html#a0dc388e18b0fc0fa2d8ad0a6953fb039" title="See Async_io_obj counterpart.">send()</a> and <a class="el" href="classipc_1_1transport_1_1struc_1_1sync__io_1_1Channel.html#a26dc83067e005be38567199cbedd7f19" title="See Async_io_obj counterpart; though naturally on_rsp_func() is invoked in the sync_io-pattern fashio...">async_request()</a> helper that returns <code>true</code> if and only if <code>msg</code> contains a native handle, but <a class="el" href="classipc_1_1transport_1_1struc_1_1sync__io_1_1Channel.html#a4abac89dbd4d26c79b7915990f751a76" title="See Async_io_obj counterpart.">Owned_channel</a> is compile-time-incapable of transporting them. </p>
<p >No <code>*this</code> state other than logging context is accessed.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">msg</td><td>See, e.g., <a class="el" href="classipc_1_1transport_1_1struc_1_1sync__io_1_1Channel.html#a0dc388e18b0fc0fa2d8ad0a6953fb039" title="See Async_io_obj counterpart.">send()</a>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if unsendable; else <code>false</code>. </dd></dl>

<p class="definition">Definition at line <a class="el" href="ipc__transport__structured_2src_2ipc_2transport_2struc_2sync__io_2channel_8hpp_source.html#l03719">3719</a> of file <a class="el" href="ipc__transport__structured_2src_2ipc_2transport_2struc_2sync__io_2channel_8hpp_source.html">channel.hpp</a>.</p>

<p class="reference">References <a class="el" href="msg_8hpp_source.html#l01052">ipc::transport::struc::Msg_out&lt; Message_body, Struct_builder_t &gt;::native_handle_or_null()</a>.</p>
<div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="classipc_1_1transport_1_1struc_1_1sync__io_1_1Channel_ae43681c46951acd7e3c06d3cd73854f6_cgraph.svg" width="382" height="59"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe>
</div>
</div>

</div>
</div>
<a id="a426ecae27b4ea5cf7e666e56bad6afe5" name="a426ecae27b4ea5cf7e666e56bad6afe5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a426ecae27b4ea5cf7e666e56bad6afe5">&#9670;&nbsp;</a></span>create_msg()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Channel_obj , typename Message_body , typename Struct_builder_config , typename Struct_reader_config &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classipc_1_1transport_1_1struc_1_1sync__io_1_1Channel.html">Channel</a>&lt; Channel_obj, Message_body, Struct_builder_config, Struct_reader_config &gt;<a class="el" href="classipc_1_1transport_1_1struc_1_1sync__io_1_1Channel.html#a83fb4462a8d4045bdb56b694bf80393c">::Msg_out</a> <a class="el" href="classipc_1_1transport_1_1struc_1_1sync__io_1_1Channel.html">ipc::transport::struc::sync_io::Channel</a>&lt; Channel_obj, Message_body, Struct_builder_config, Struct_reader_config &gt;::create_msg </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespaceipc_1_1transport.html#a7ee4551983d9df16ec16a3139bac50e8">Native_handle</a> &amp;&amp;&#160;</td>
          <td class="paramname"><em>hndl_or_null</em> = <code><a class="el" href="namespaceipc_1_1transport.html#a7ee4551983d9df16ec16a3139bac50e8">Native_handle</a>()</code></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>See <a class="el" href="classipc_1_1transport_1_1struc_1_1sync__io_1_1Channel.html#a6dc83bd6057b7f00a19c5947d6baa7b7" title="Useful for generic programming, the async-I/O-pattern counterpart to *this type.">Async_io_obj</a> counterpart. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">hndl_or_null</td><td>See above. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>See above. </dd></dl>

<p class="definition">Definition at line <a class="el" href="ipc__transport__structured_2src_2ipc_2transport_2struc_2sync__io_2channel_8hpp_source.html#l04168">4168</a> of file <a class="el" href="ipc__transport__structured_2src_2ipc_2transport_2struc_2sync__io_2channel_8hpp_source.html">channel.hpp</a>.</p>

<p class="reference">References <a class="el" href="msg_8hpp_source.html#l01037">ipc::transport::struc::Msg_out&lt; Message_body, Struct_builder_t &gt;::store_native_handle_or_null()</a>.</p>
<div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="classipc_1_1transport_1_1struc_1_1sync__io_1_1Channel_a426ecae27b4ea5cf7e666e56bad6afe5_cgraph.svg" width="592" height="71"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe>
</div>
</div>

</div>
</div>
<a id="a996e06f75024e10987eb9cf62e096eec" name="a996e06f75024e10987eb9cf62e096eec"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a996e06f75024e10987eb9cf62e096eec">&#9670;&nbsp;</a></span>expect_log_in_request()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Channel_obj , typename Message_body , typename Struct_builder_config , typename Struct_reader_config &gt; </div>
<div class="memtemplate">
template&lt;typename On_msg_handler &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classipc_1_1transport_1_1struc_1_1sync__io_1_1Channel.html">ipc::transport::struc::sync_io::Channel</a>&lt; Channel_obj, Message_body, Struct_builder_config, Struct_reader_config &gt;::expect_log_in_request </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classipc_1_1transport_1_1struc_1_1sync__io_1_1Channel.html#aa40c3ec3f45cdfea9360f7f35b9ade3c">Msg_which_in</a>&#160;</td>
          <td class="paramname"><em>which</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classipc_1_1transport_1_1struc_1_1sync__io_1_1Channel.html#acde2b3866547a30958035203d9d89928">Msg_in_ptr</a> *&#160;</td>
          <td class="paramname"><em>qd_msg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">On_msg_handler &amp;&amp;&#160;</td>
          <td class="paramname"><em>on_log_in_req_func</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>In log-in phase as server only: Registers the expectation (which may be immediately met) of up to 1 <em>log-in request</em> in-message whose <a class="el" href="classipc_1_1transport_1_1struc_1_1sync__io_1_1Channel.html#a1572a1b1cb4a72ea57f7841a5e78759b" title="See Async_io_obj counterpart.">Msg_which</a> equals <code>which</code>. </p>
<p >No-op and return <code>false</code> if <a class="el" href="classipc_1_1transport_1_1struc_1_1sync__io_1_1Channel.html#a996e06f75024e10987eb9cf62e096eec" title="In log-in phase as server only: Registers the expectation (which may be immediately met) of up to 1 l...">expect_log_in_request()</a> has already been invoked, if log-in phase is not active or active in the client role, or if a prior error has hosed the owned <a class="el" href="classipc_1_1transport_1_1struc_1_1sync__io_1_1Channel.html" title="sync_io-pattern counterpart to async-I/O-pattern transport::struc::Channel.">Channel</a>.</p>
<p >The expectation is unregistered upon receipt of the applicable in-message (and firing it with that in-message <a class="el" href="classipc_1_1transport_1_1struc_1_1sync__io_1_1Channel.html#acde2b3866547a30958035203d9d89928" title="See Async_io_obj counterpart.">Msg_in_ptr</a> as arg). In addition:</p>
<p >The 1 expected in-message may already be available synchronously. In that case:</p><ul>
<li><code>*qd_msg</code> shall be loaded with that message; and it is purged from <code>*this</code>. You must handle it as you see fit upon return from this method.</li>
<li>The expectation is immediately unregistered.</li>
<li><code>on_log_in_req_func</code> is ignored (it is not memorized).</li>
</ul>
<p >Therefore <code>on_log_in_req_func()</code> can <em>only</em> execute upon a future <code><a class="el" href="namespaceipc_1_1transport_1_1struc_1_1sync__io.html" title="sync_io-pattern counterparts to async-I/O-pattern object types in parent namespace ipc::transport::st...">sync_io</a></code>-pattern async-wait firing its <code>(*on_active_ev_func)()</code>.</p>
<h3>Tips</h3>
<p >Informally the proper behavior is:</p><ol type="1">
<li>Construct in log-in-as-server phase.</li>
<li>Invoke <a class="el" href="classipc_1_1transport_1_1struc_1_1sync__io_1_1Channel.html#a996e06f75024e10987eb9cf62e096eec" title="In log-in phase as server only: Registers the expectation (which may be immediately met) of up to 1 l...">expect_log_in_request()</a>.</li>
<li>Await <code>on_log_in_req_func(X&amp;&amp;)</code> firing, or immediate delivery of <code>X</code> via <code>*qd_msg</code>, where X is the log-in request.</li>
<li>After <code>on_log_in_req_func(X&amp;&amp;)</code> handler, or immediate delivery pf <code>X</code> via <code>*qd_msg</code>: check X for correctness (such as process identity checks). If it fails checks, destroy <code>*this</code>; else:</li>
<li>Fill out <code>X = this-&gt;<a class="el" href="classipc_1_1transport_1_1struc_1_1sync__io_1_1Channel.html#a426ecae27b4ea5cf7e666e56bad6afe5" title="See Async_io_obj counterpart.">create_msg()</a></code> (the log-in response) as needed via <code>X-&gt;body_root()</code>.</li>
<li><code>send(X)</code>. The latter automatically moves <code>*this</code> to logged-in phase locally: the bulk of the API becomes available.</li>
</ol>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">On_msg_handler</td><td>See <a class="el" href="classipc_1_1transport_1_1struc_1_1sync__io_1_1Channel.html#a5fc489b9abefe5ab676f6991d6d03f0d" title="Registers the expectation (which may be immediately met) of up to 1 notification in-message whose Msg...">expect_msg()</a>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">which</td><td>See <a class="el" href="classipc_1_1transport_1_1struc_1_1sync__io_1_1Channel.html#a5fc489b9abefe5ab676f6991d6d03f0d" title="Registers the expectation (which may be immediately met) of up to 1 notification in-message whose Msg...">expect_msg()</a>. </td></tr>
    <tr><td class="paramname">qd_msg</td><td>See <a class="el" href="classipc_1_1transport_1_1struc_1_1sync__io_1_1Channel.html#a5fc489b9abefe5ab676f6991d6d03f0d" title="Registers the expectation (which may be immediately met) of up to 1 notification in-message whose Msg...">expect_msg()</a>. </td></tr>
    <tr><td class="paramname">on_log_in_req_func</td><td>See above. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> on success; <code>false</code> due to one of the above conditions. </dd></dl>

<p class="definition">Definition at line <a class="el" href="ipc__transport__structured_2src_2ipc_2transport_2struc_2sync__io_2channel_8hpp_source.html#l04233">4233</a> of file <a class="el" href="ipc__transport__structured_2src_2ipc_2transport_2struc_2sync__io_2channel_8hpp_source.html">channel.hpp</a>.</p>

</div>
</div>
<a id="a5fc489b9abefe5ab676f6991d6d03f0d" name="a5fc489b9abefe5ab676f6991d6d03f0d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5fc489b9abefe5ab676f6991d6d03f0d">&#9670;&nbsp;</a></span>expect_msg()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Channel_obj , typename Message_body , typename Struct_builder_config , typename Struct_reader_config &gt; </div>
<div class="memtemplate">
template&lt;typename On_msg_handler &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classipc_1_1transport_1_1struc_1_1sync__io_1_1Channel.html">ipc::transport::struc::sync_io::Channel</a>&lt; Channel_obj, Message_body, Struct_builder_config, Struct_reader_config &gt;::expect_msg </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classipc_1_1transport_1_1struc_1_1sync__io_1_1Channel.html#aa40c3ec3f45cdfea9360f7f35b9ade3c">Msg_which_in</a>&#160;</td>
          <td class="paramname"><em>which</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classipc_1_1transport_1_1struc_1_1sync__io_1_1Channel.html#acde2b3866547a30958035203d9d89928">Msg_in_ptr</a> *&#160;</td>
          <td class="paramname"><em>qd_msg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">On_msg_handler &amp;&amp;&#160;</td>
          <td class="paramname"><em>on_msg_func</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Registers the expectation (which may be immediately met) of up to 1 <em>notification</em> in-message whose <a class="el" href="classipc_1_1transport_1_1struc_1_1sync__io_1_1Channel.html#a1572a1b1cb4a72ea57f7841a5e78759b" title="See Async_io_obj counterpart.">Msg_which</a> equals <code>which</code>. </p>
<p >No-op and return <code>false</code> if <code>which</code> is already being expected, if log-in phase is not yet completed, or if a prior error has hosed the owned <a class="el" href="classipc_1_1transport_1_1struc_1_1sync__io_1_1Channel.html" title="sync_io-pattern counterpart to async-I/O-pattern transport::struc::Channel.">Channel</a>.</p>
<p >The expectation is unregistered upon receipt of the applicable in-message (and firing it with that in-message <a class="el" href="classipc_1_1transport_1_1struc_1_1sync__io_1_1Channel.html#acde2b3866547a30958035203d9d89928" title="See Async_io_obj counterpart.">Msg_in_ptr</a> as arg). In addition:</p>
<p >The 1 expected in-message may already be available synchronously. In that case:</p><ul>
<li><code>*qd_msg</code> shall be loaded with that message; and it is purged from <code>*this</code>. You must handle it as you see fit upon return from this method.</li>
<li>The expectation is immediately unregistered.</li>
<li><code>on_msg_func</code> is ignored (it is not memorized).</li>
</ul>
<p >Therefore <code>on_msg_func()</code> can <em>only</em> execute upon a future <code><a class="el" href="namespaceipc_1_1transport_1_1struc_1_1sync__io.html" title="sync_io-pattern counterparts to async-I/O-pattern object types in parent namespace ipc::transport::st...">sync_io</a></code>-pattern async-wait firing its <code>(*on_active_ev_func)()</code>.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">On_msg_handler</td><td>Handler type for in-messages; see class doc header for in-message handling signature. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">which</td><td>Top-level <a class="el" href="classipc_1_1transport_1_1struc_1_1sync__io_1_1Channel.html#a34e183c252390f369f121074772c14c4" title="See Async_io_obj counterpart.">Msg_body</a> union <code>which()</code> value to expect. </td></tr>
    <tr><td class="paramname">qd_msg</td><td><code>*qd_msg</code> is set to null if no message is immediately available; else set to that message (see above). </td></tr>
    <tr><td class="paramname">on_msg_func</td><td><code>on_msg_func(M)</code> shall be invoked in the manner explained in class doc header, on receipt of message with <code>which() == which</code>; unless it is immediately available and therefore loaded into <code>*qd_msg</code>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> on success; <code>false</code> due to one of the above conditions. </dd></dl>

<p class="definition">Definition at line <a class="el" href="ipc__transport__structured_2src_2ipc_2transport_2struc_2sync__io_2channel_8hpp_source.html#l04182">4182</a> of file <a class="el" href="ipc__transport__structured_2src_2ipc_2transport_2struc_2sync__io_2channel_8hpp_source.html">channel.hpp</a>.</p>

</div>
</div>
<a id="a62f52488ba20dd6c69dfc1abadb2d69f" name="a62f52488ba20dd6c69dfc1abadb2d69f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a62f52488ba20dd6c69dfc1abadb2d69f">&#9670;&nbsp;</a></span>expect_msgs()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Channel_obj , typename Message_body , typename Struct_builder_config , typename Struct_reader_config &gt; </div>
<div class="memtemplate">
template&lt;typename On_msg_handler &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classipc_1_1transport_1_1struc_1_1sync__io_1_1Channel.html">ipc::transport::struc::sync_io::Channel</a>&lt; Channel_obj, Message_body, Struct_builder_config, Struct_reader_config &gt;::expect_msgs </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classipc_1_1transport_1_1struc_1_1sync__io_1_1Channel.html#aa40c3ec3f45cdfea9360f7f35b9ade3c">Msg_which_in</a>&#160;</td>
          <td class="paramname"><em>which</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classipc_1_1transport_1_1struc_1_1sync__io_1_1Channel.html#a4ab778bce8d7e6e84788879fedc62745">Msgs_in</a> *&#160;</td>
          <td class="paramname"><em>qd_msgs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">On_msg_handler &amp;&amp;&#160;</td>
          <td class="paramname"><em>on_msg_func</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Registers the expectation (some of which may be immediately met) of 0+ <em>notification</em> in-messages whose <a class="el" href="classipc_1_1transport_1_1struc_1_1sync__io_1_1Channel.html#a1572a1b1cb4a72ea57f7841a5e78759b" title="See Async_io_obj counterpart.">Msg_which</a> equals <code>which</code>. </p>
<p >No-op and return <code>false</code> if <code>which</code> is already being expected, if log-in phase is not yet completed, or if a prior error has hosed the owned <a class="el" href="classipc_1_1transport_1_1struc_1_1sync__io_1_1Channel.html" title="sync_io-pattern counterpart to async-I/O-pattern transport::struc::Channel.">Channel</a>.</p>
<p >The expectation is unregistered upon subsequent <code>undo_expect_msgs(which)</code>.</p>
<p >1+ expected in-messages may already be available synchronously. In that case:</p><ul>
<li><code>*qd_msgs</code> is loaded with those messages; and they are purged from <code>*this</code>. You must handle them as you see fit upon return from this method.</li>
<li>The expectation continues to be registered; <code>on_msg_func()</code> may be invoked in the future.</li>
</ul>
<p >Therefore <code>on_msg_func()</code> can <em>only</em> execute upon a future <code><a class="el" href="namespaceipc_1_1transport_1_1struc_1_1sync__io.html" title="sync_io-pattern counterparts to async-I/O-pattern object types in parent namespace ipc::transport::st...">sync_io</a></code>-pattern async-wait firing its <code>(*on_active_ev_func)()</code>.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">On_msg_handler</td><td>See <a class="el" href="classipc_1_1transport_1_1struc_1_1sync__io_1_1Channel.html#a5fc489b9abefe5ab676f6991d6d03f0d" title="Registers the expectation (which may be immediately met) of up to 1 notification in-message whose Msg...">expect_msg()</a>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">which</td><td>See <a class="el" href="classipc_1_1transport_1_1struc_1_1sync__io_1_1Channel.html#a5fc489b9abefe5ab676f6991d6d03f0d" title="Registers the expectation (which may be immediately met) of up to 1 notification in-message whose Msg...">expect_msg()</a>. </td></tr>
    <tr><td class="paramname">qd_msgs</td><td><code>*qd_msgs</code> is cleared; then filled with any messages (possibly none) immediately available. </td></tr>
    <tr><td class="paramname">on_msg_func</td><td>See above and <a class="el" href="classipc_1_1transport_1_1struc_1_1sync__io_1_1Channel.html#a5fc489b9abefe5ab676f6991d6d03f0d" title="Registers the expectation (which may be immediately met) of up to 1 notification in-message whose Msg...">expect_msg()</a>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>See <a class="el" href="classipc_1_1transport_1_1struc_1_1sync__io_1_1Channel.html#a5fc489b9abefe5ab676f6991d6d03f0d" title="Registers the expectation (which may be immediately met) of up to 1 notification in-message whose Msg...">expect_msg()</a>. </dd></dl>

<p class="definition">Definition at line <a class="el" href="ipc__transport__structured_2src_2ipc_2transport_2struc_2sync__io_2channel_8hpp_source.html#l04214">4214</a> of file <a class="el" href="ipc__transport__structured_2src_2ipc_2transport_2struc_2sync__io_2channel_8hpp_source.html">channel.hpp</a>.</p>

</div>
</div>
<a id="a2552eada8012c4a8c4d2fc5f02e9f69b" name="a2552eada8012c4a8c4d2fc5f02e9f69b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2552eada8012c4a8c4d2fc5f02e9f69b">&#9670;&nbsp;</a></span>expect_msgs_impl()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Channel_obj , typename Message_body , typename Struct_builder_config , typename Struct_reader_config &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classipc_1_1transport_1_1struc_1_1sync__io_1_1Channel.html">ipc::transport::struc::sync_io::Channel</a>&lt; Channel_obj, Message_body, Struct_builder_config, Struct_reader_config &gt;::expect_msgs_impl </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classipc_1_1transport_1_1struc_1_1sync__io_1_1Channel.html#a4ab778bce8d7e6e84788879fedc62745">Msgs_in</a> *&#160;</td>
          <td class="paramname"><em>qd_msgs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>one_off</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classipc_1_1transport_1_1struc_1_1sync__io_1_1Channel.html#aa40c3ec3f45cdfea9360f7f35b9ade3c">Msg_which_in</a>&#160;</td>
          <td class="paramname"><em>which</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classipc_1_1transport_1_1struc_1_1sync__io_1_1Channel.html#a583ccd4bb6b1aefb09d77e5709aef5b4">On_msg_func_ptr</a> &amp;&amp;&#160;</td>
          <td class="paramname"><em>on_msg_func</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Core of <a class="el" href="classipc_1_1transport_1_1struc_1_1sync__io_1_1Channel.html#a5fc489b9abefe5ab676f6991d6d03f0d" title="Registers the expectation (which may be immediately met) of up to 1 notification in-message whose Msg...">expect_msg()</a>, <a class="el" href="classipc_1_1transport_1_1struc_1_1sync__io_1_1Channel.html#a62f52488ba20dd6c69dfc1abadb2d69f" title="Registers the expectation (some of which may be immediately met) of 0+ notification in-messages whose...">expect_msgs()</a>, and <a class="el" href="classipc_1_1transport_1_1struc_1_1sync__io_1_1Channel.html#a996e06f75024e10987eb9cf62e096eec" title="In log-in phase as server only: Registers the expectation (which may be immediately met) of up to 1 l...">expect_log_in_request()</a>. </p>
<p >Records the expectation of the given message type (<code>which</code>) in <a class="el" href="classipc_1_1transport_1_1struc_1_1sync__io_1_1Channel.html#ae9f5a798718d98523342acf55400d628" title="Queues of in-messages, keyed by Msg_which_in, each in msg_id_in_t (sequence #) order,...">m_rcv_pending_msgs</a>; then scans messages queued-up in <a class="el" href="classipc_1_1transport_1_1struc_1_1sync__io_1_1Channel.html#ae9f5a798718d98523342acf55400d628" title="Queues of in-messages, keyed by Msg_which_in, each in msg_id_in_t (sequence #) order,...">m_rcv_pending_msgs</a> with matching <a class="el" href="classipc_1_1transport_1_1struc_1_1sync__io_1_1Channel.html#aa40c3ec3f45cdfea9360f7f35b9ade3c" title="See Async_io_obj counterpart.">Msg_which_in</a>, in order. It async-emits one (if <code>one_off</code>) or all (otherwise) such messages into <code>*qd_msgs</code> out-arg.</p>
<p >Note that, if <code>one_off</code>, and a matching in-message is queued, <a class="el" href="classipc_1_1transport_1_1struc_1_1sync__io_1_1Channel.html#ae9f5a798718d98523342acf55400d628" title="Queues of in-messages, keyed by Msg_which_in, each in msg_id_in_t (sequence #) order,...">m_rcv_pending_msgs</a> will not have changed when comparing pre- and post-state.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">qd_msgs</td><td>See <a class="el" href="classipc_1_1transport_1_1struc_1_1sync__io_1_1Channel.html#a62f52488ba20dd6c69dfc1abadb2d69f" title="Registers the expectation (some of which may be immediately met) of 0+ notification in-messages whose...">expect_msgs()</a> and similar. </td></tr>
    <tr><td class="paramname">one_off</td><td><code>true</code> for <a class="el" href="classipc_1_1transport_1_1struc_1_1sync__io_1_1Channel.html#a5fc489b9abefe5ab676f6991d6d03f0d" title="Registers the expectation (which may be immediately met) of up to 1 notification in-message whose Msg...">expect_msg()</a> and <a class="el" href="classipc_1_1transport_1_1struc_1_1sync__io_1_1Channel.html#a996e06f75024e10987eb9cf62e096eec" title="In log-in phase as server only: Registers the expectation (which may be immediately met) of up to 1 l...">expect_log_in_request()</a> (which are almost identical); <code>false</code> for <a class="el" href="classipc_1_1transport_1_1struc_1_1sync__io_1_1Channel.html#a62f52488ba20dd6c69dfc1abadb2d69f" title="Registers the expectation (some of which may be immediately met) of 0+ notification in-messages whose...">expect_msgs()</a>. In the latter case <a class="el" href="classipc_1_1transport_1_1struc_1_1sync__io_1_1Channel.html#ac8ba5f1a26a9f3e881b4871b0f6aa990" title="See Async_io_obj counterpart.">undo_expect_msgs()</a> is a thing. </td></tr>
    <tr><td class="paramname">which</td><td>Message type to expect. </td></tr>
    <tr><td class="paramname">on_msg_func</td><td>See <a class="el" href="classipc_1_1transport_1_1struc_1_1sync__io_1_1Channel.html#a5fc489b9abefe5ab676f6991d6d03f0d" title="Registers the expectation (which may be immediately met) of up to 1 notification in-message whose Msg...">expect_msg()</a> among others. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> usually; <code>false</code> if <code>which</code> expectation is already in <a class="el" href="classipc_1_1transport_1_1struc_1_1sync__io_1_1Channel.html#ae9f5a798718d98523342acf55400d628" title="Queues of in-messages, keyed by Msg_which_in, each in msg_id_in_t (sequence #) order,...">m_rcv_pending_msgs</a>; or if <a class="el" href="classipc_1_1transport_1_1struc_1_1sync__io_1_1Channel.html#afca9a3012b2f41d635381a5a13ddd7c1" title="Phase (w/r/t log-in or lack thereof) of *this peer.">m_phase</a> is LOGGED_IN, and <a class="el" href="classipc_1_1transport_1_1struc_1_1sync__io_1_1Channel.html#ae9f5a798718d98523342acf55400d628" title="Queues of in-messages, keyed by Msg_which_in, each in msg_id_in_t (sequence #) order,...">m_rcv_pending_msgs</a> does contain a queued-up in-message already, <em>and</em> its <a class="el" href="classipc_1_1transport_1_1struc_1_1sync__io_1_1Channel.html#aa40c3ec3f45cdfea9360f7f35b9ade3c" title="See Async_io_obj counterpart.">Msg_which_in</a> does not equal <code>which</code>. The latter indicates that the logging-in opposing peer disagrees with the expected protocol and issued a log-in request of unexpected type; the on-error handler shall fire asynchronously+immediately, similarly to having received the erroneous in-message <em>after</em> <a class="el" href="classipc_1_1transport_1_1struc_1_1sync__io_1_1Channel.html#a2552eada8012c4a8c4d2fc5f02e9f69b" title="Core of expect_msg(), expect_msgs(), and expect_log_in_request().">expect_msgs_impl()</a> returns. </dd></dl>

<p class="definition">Definition at line <a class="el" href="ipc__transport__structured_2src_2ipc_2transport_2struc_2sync__io_2channel_8hpp_source.html#l04273">4273</a> of file <a class="el" href="ipc__transport__structured_2src_2ipc_2transport_2struc_2sync__io_2channel_8hpp_source.html">channel.hpp</a>.</p>

<p class="reference">References <a class="el" href="namespaceipc_1_1transport_1_1struc_1_1error.html#a990b9ff850cf9aaf354efdd07d86a71dad88bc7df9bd2dcdf4370585c912a9a61">ipc::transport::struc::error::S_STRUCT_CHANNEL_GOT_UNEXPECTED_LOG_IN_REQUEST</a>.</p>

</div>
</div>
<a id="ab17b00ae995cf634c721420cd85fdef2" name="ab17b00ae995cf634c721420cd85fdef2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab17b00ae995cf634c721420cd85fdef2">&#9670;&nbsp;</a></span>handle_async_err_code()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Channel_obj , typename Message_body , typename Struct_builder_config , typename Struct_reader_config &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classipc_1_1transport_1_1struc_1_1sync__io_1_1Channel.html">ipc::transport::struc::sync_io::Channel</a>&lt; Channel_obj, Message_body, Struct_builder_config, Struct_reader_config &gt;::handle_async_err_code </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespaceipc.html#aa3192e586cc45d3e7c22463bf2760f89">Error_code</a> &amp;&#160;</td>
          <td class="paramname"><em>err_code</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceipc_1_1util.html#ae6ac47812a90d1287c61e0b7de7bc4f5">util::String_view</a>&#160;</td>
          <td class="paramname"><em>context</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Helper for async handlers: returns <code>true</code> if and only if <code>err_code</code> indicates a new error or <a class="el" href="classipc_1_1transport_1_1struc_1_1sync__io_1_1Channel.html#a95cfe30e685e828d62318c9b2bc4b137" title="Starts falsy; becomes forever truthy (with a specific Error_code that will not change thereafter) whe...">m_channel_err_code_or_ok</a> indicates a previously-occurred one or both; updates <a class="el" href="classipc_1_1transport_1_1struc_1_1sync__io_1_1Channel.html#a95cfe30e685e828d62318c9b2bc4b137" title="Starts falsy; becomes forever truthy (with a specific Error_code that will not change thereafter) whe...">m_channel_err_code_or_ok</a> to <code>err_code</code> in the former case. </p>
<p >Logs appropriately.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">err_code</td><td>Code from the async op. </td></tr>
    <tr><td class="paramname">context</td><td>Brief context string for logging. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if <code>err_code</code> or a prior condition indicate the channel is hosed; <code>false</code> otherwise. </dd></dl>

<p class="definition">Definition at line <a class="el" href="ipc__transport__structured_2src_2ipc_2transport_2struc_2sync__io_2channel_8hpp_source.html#l03641">3641</a> of file <a class="el" href="ipc__transport__structured_2src_2ipc_2transport_2struc_2sync__io_2channel_8hpp_source.html">channel.hpp</a>.</p>

</div>
</div>
<a id="ad3f5d174c65db9d5ec3b14769fb9574a" name="ad3f5d174c65db9d5ec3b14769fb9574a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad3f5d174c65db9d5ec3b14769fb9574a">&#9670;&nbsp;</a></span>handle_new_error()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Channel_obj , typename Message_body , typename Struct_builder_config , typename Struct_reader_config &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classipc_1_1transport_1_1struc_1_1sync__io_1_1Channel.html">ipc::transport::struc::sync_io::Channel</a>&lt; Channel_obj, Message_body, Struct_builder_config, Struct_reader_config &gt;::handle_new_error </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespaceipc.html#aa3192e586cc45d3e7c22463bf2760f89">Error_code</a> &amp;&#160;</td>
          <td class="paramname"><em>err_code_not_ok</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceipc_1_1util.html#ae6ac47812a90d1287c61e0b7de7bc4f5">util::String_view</a>&#160;</td>
          <td class="paramname"><em>context</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Helper that handles the situation where <a class="el" href="classipc_1_1transport_1_1struc_1_1sync__io_1_1Channel.html#a95cfe30e685e828d62318c9b2bc4b137" title="Starts falsy; becomes forever truthy (with a specific Error_code that will not change thereafter) whe...">m_channel_err_code_or_ok</a> is falsy, and processing has found a new error condition. </p>
<p >Sets <a class="el" href="classipc_1_1transport_1_1struc_1_1sync__io_1_1Channel.html#a95cfe30e685e828d62318c9b2bc4b137" title="Starts falsy; becomes forever truthy (with a specific Error_code that will not change thereafter) whe...">m_channel_err_code_or_ok</a> accordingly and emits to on-error handler.</p>
<p >Do <em>not</em> use when synchronously emitting an error (<a class="el" href="classipc_1_1transport_1_1struc_1_1sync__io_1_1Channel.html#a0550bcab7578fcd9aa90a4add39eb3c7" title="Core of send() or internal-message-send: Serializes the given structured out-messages (metadata out-m...">send_core()</a> only as of this writing).</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">err_code_not_ok</td><td>Truthy code (or assertion may trip). </td></tr>
    <tr><td class="paramname">context</td><td>Brief context string for logging. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="ipc__transport__structured_2src_2ipc_2transport_2struc_2sync__io_2channel_8hpp_source.html#l03676">3676</a> of file <a class="el" href="ipc__transport__structured_2src_2ipc_2transport_2struc_2sync__io_2channel_8hpp_source.html">channel.hpp</a>.</p>

</div>
</div>
<a id="a3a0adf8ce8fc29ec55b4c8c30886c1fc" name="a3a0adf8ce8fc29ec55b4c8c30886c1fc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3a0adf8ce8fc29ec55b4c8c30886c1fc">&#9670;&nbsp;</a></span>handlers_poll()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Channel_obj , typename Message_body , typename Struct_builder_config , typename Struct_reader_config &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classipc_1_1transport_1_1struc_1_1sync__io_1_1Channel.html">ipc::transport::struc::sync_io::Channel</a>&lt; Channel_obj, Message_body, Struct_builder_config, Struct_reader_config &gt;::handlers_poll </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespaceipc_1_1util.html#ae6ac47812a90d1287c61e0b7de7bc4f5">util::String_view</a>&#160;</td>
          <td class="paramname"><em>context</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Executes what was recorded recently in <a class="el" href="classipc_1_1transport_1_1struc_1_1sync__io_1_1Channel.html#a126c0d7ee5fcab20dc8c87884fdd7597" title="Record handler to invoke in handlers_poll() soon.">handlers_post()</a>. </p>
<p >As of this writing this is done after scanning each unstructured (low-level) in-message. If <a class="el" href="classipc_1_1transport_1_1Channel.html#a85184d886cee9b4a0d0e7b67796a238b" title="Useful for generic programming: true if and only if types imply both blobs and handles pipes are enab...">Channel::S_HAS_2_PIPES</a> is <code>true</code>, then 1+ handlers may execute here; otherwise at most 1 can execute here.</p>
<dl class="section see"><dt>See also</dt><dd>Doc header for <a class="el" href="classipc_1_1transport_1_1struc_1_1sync__io_1_1Channel.html#a2c0013237f845e5589cf0063886c7431" title="The handlers as pushed by handlers_post() to be flushed via handlers_poll() (internally by *this).">m_sync_io_handlers</a> which discusses the design+trade-offs here.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">context</td><td>Brief context string for logging. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="ipc__transport__structured_2src_2ipc_2transport_2struc_2sync__io_2channel_8hpp_source.html#l03194">3194</a> of file <a class="el" href="ipc__transport__structured_2src_2ipc_2transport_2struc_2sync__io_2channel_8hpp_source.html">channel.hpp</a>.</p>

</div>
</div>
<a id="a126c0d7ee5fcab20dc8c87884fdd7597" name="a126c0d7ee5fcab20dc8c87884fdd7597"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a126c0d7ee5fcab20dc8c87884fdd7597">&#9670;&nbsp;</a></span>handlers_post()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Channel_obj , typename Message_body , typename Struct_builder_config , typename Struct_reader_config &gt; </div>
<div class="memtemplate">
template&lt;typename Task &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classipc_1_1transport_1_1struc_1_1sync__io_1_1Channel.html">ipc::transport::struc::sync_io::Channel</a>&lt; Channel_obj, Message_body, Struct_builder_config, Struct_reader_config &gt;::handlers_post </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespaceipc_1_1util.html#ae6ac47812a90d1287c61e0b7de7bc4f5">util::String_view</a>&#160;</td>
          <td class="paramname"><em>context</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Task &amp;&amp;&#160;</td>
          <td class="paramname"><em>handler</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Record handler to invoke in <a class="el" href="classipc_1_1transport_1_1struc_1_1sync__io_1_1Channel.html#a3a0adf8ce8fc29ec55b4c8c30886c1fc" title="Executes what was recorded recently in handlers_post().">handlers_poll()</a> soon. </p>
<p >The context for this is: we're scanning an unstructured (low-level) message received along a pipe of <a class="el" href="classipc_1_1transport_1_1struc_1_1sync__io_1_1Channel.html#a4abac89dbd4d26c79b7915990f751a76" title="See Async_io_obj counterpart.">Owned_channel</a>; and it completed something such that the user shall be informed of this via a completion handler they had registered. As of this writing the relevant completion handlers are:</p><ul>
<li>those from <code>expect_*()</code>;</li>
<li>those from <a class="el" href="classipc_1_1transport_1_1struc_1_1sync__io_1_1Channel.html#a26dc83067e005be38567199cbedd7f19" title="See Async_io_obj counterpart; though naturally on_rsp_func() is invoked in the sync_io-pattern fashio...">async_request()</a>;</li>
<li>those from <code>set_*unexpected_response_handler()</code>.</li>
</ul>
<p >(<a class="el" href="classipc_1_1transport_1_1struc_1_1sync__io_1_1Channel.html#ae4a2a63dc88722d96ee9f3ed68cf7b86" title="See Async_io_obj counterpart; except (1) naturally on_done_func() is invoked in the sync_io-pattern f...">async_end_sending()</a> completion handler is a separate, lower-level thing.)</p>
<dl class="section see"><dt>See also</dt><dd>Doc header for <a class="el" href="classipc_1_1transport_1_1struc_1_1sync__io_1_1Channel.html#a2c0013237f845e5589cf0063886c7431" title="The handlers as pushed by handlers_post() to be flushed via handlers_poll() (internally by *this).">m_sync_io_handlers</a> which discusses the design+trade-offs here.</dd></dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Task</td><td>Function type matching <code>void F()</code>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">context</td><td>Brief context string for logging. </td></tr>
    <tr><td class="paramname">handler</td><td>Code to run in <a class="el" href="classipc_1_1transport_1_1struc_1_1sync__io_1_1Channel.html#a3a0adf8ce8fc29ec55b4c8c30886c1fc" title="Executes what was recorded recently in handlers_post().">handlers_poll()</a>. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="ipc__transport__structured_2src_2ipc_2transport_2struc_2sync__io_2channel_8hpp_source.html#l03171">3171</a> of file <a class="el" href="ipc__transport__structured_2src_2ipc_2transport_2struc_2sync__io_2channel_8hpp_source.html">channel.hpp</a>.</p>

</div>
</div>
<a id="a759e1993bc61abb41380219b254ca410" name="a759e1993bc61abb41380219b254ca410"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a759e1993bc61abb41380219b254ca410">&#9670;&nbsp;</a></span>owned_channel()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Channel_obj , typename Message_body , typename Struct_builder_config , typename Struct_reader_config &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classipc_1_1transport_1_1struc_1_1sync__io_1_1Channel.html">Channel</a>&lt; Channel_obj, Message_body, Struct_builder_config, Struct_reader_config &gt;<a class="el" href="classipc_1_1transport_1_1struc_1_1sync__io_1_1Channel.html#a4abac89dbd4d26c79b7915990f751a76">::Owned_channel</a> &amp; <a class="el" href="classipc_1_1transport_1_1struc_1_1sync__io_1_1Channel.html">ipc::transport::struc::sync_io::Channel</a>&lt; Channel_obj, Message_body, Struct_builder_config, Struct_reader_config &gt;::owned_channel</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>See <a class="el" href="classipc_1_1transport_1_1struc_1_1sync__io_1_1Channel.html#a6dc83bd6057b7f00a19c5947d6baa7b7" title="Useful for generic programming, the async-I/O-pattern counterpart to *this type.">Async_io_obj</a> counterpart. </p>
<dl class="section return"><dt>Returns</dt><dd>See above. </dd></dl>

<p class="definition">Definition at line <a class="el" href="ipc__transport__structured_2src_2ipc_2transport_2struc_2sync__io_2channel_8hpp_source.html#l04496">4496</a> of file <a class="el" href="ipc__transport__structured_2src_2ipc_2transport_2struc_2sync__io_2channel_8hpp_source.html">channel.hpp</a>.</p>

</div>
</div>
<a id="a9d97a5900bd517596b763db2d6b27b45" name="a9d97a5900bd517596b763db2d6b27b45"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9d97a5900bd517596b763db2d6b27b45">&#9670;&nbsp;</a></span>owned_channel_mutable()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Channel_obj , typename Message_body , typename Struct_builder_config , typename Struct_reader_config &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classipc_1_1transport_1_1struc_1_1sync__io_1_1Channel.html">Channel</a>&lt; Channel_obj, Message_body, Struct_builder_config, Struct_reader_config &gt;<a class="el" href="classipc_1_1transport_1_1struc_1_1sync__io_1_1Channel.html#a4abac89dbd4d26c79b7915990f751a76">::Owned_channel</a> * <a class="el" href="classipc_1_1transport_1_1struc_1_1sync__io_1_1Channel.html">ipc::transport::struc::sync_io::Channel</a>&lt; Channel_obj, Message_body, Struct_builder_config, Struct_reader_config &gt;::owned_channel_mutable</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>See <a class="el" href="classipc_1_1transport_1_1struc_1_1sync__io_1_1Channel.html#a6dc83bd6057b7f00a19c5947d6baa7b7" title="Useful for generic programming, the async-I/O-pattern counterpart to *this type.">Async_io_obj</a> counterpart. </p>
<p >Reminder: can be useful for <code>-&gt;auto_ping()</code> and <code>-&gt;idle_timer_run()</code>. </p><dl class="section return"><dt>Returns</dt><dd>See above. </dd></dl>

<p class="definition">Definition at line <a class="el" href="ipc__transport__structured_2src_2ipc_2transport_2struc_2sync__io_2channel_8hpp_source.html#l04502">4502</a> of file <a class="el" href="ipc__transport__structured_2src_2ipc_2transport_2struc_2sync__io_2channel_8hpp_source.html">channel.hpp</a>.</p>

</div>
</div>
<a id="a252e43676b8a41a706df0655f887be63" name="a252e43676b8a41a706df0655f887be63"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a252e43676b8a41a706df0655f887be63">&#9670;&nbsp;</a></span>rcv_async_read_lead_or_continuation_msg()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Channel_obj , typename Message_body , typename Struct_builder_config , typename Struct_reader_config &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classipc_1_1transport_1_1struc_1_1sync__io_1_1Channel.html">ipc::transport::struc::sync_io::Channel</a>&lt; Channel_obj, Message_body, Struct_builder_config, Struct_reader_config &gt;::rcv_async_read_lead_or_continuation_msg </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structipc_1_1transport_1_1struc_1_1sync__io_1_1Channel_1_1Msg__in__pipe.html">Msg_in_pipe</a> *&#160;</td>
          <td class="paramname"><em>pipe</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>lead_else_cont</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>This key method acts on the pre-condition that the given in-pipe is not known to be in would-block state; and therefore we should read (and process) as many unstructured in-messages as synchronously possible until reaching would-block state, at which point we should <code>return</code> with a pending async-wait/read on that in-pipe. </p>
<p >This shall be called in exactly the following situations:</p><ul>
<li>initially (<a class="el" href="classipc_1_1transport_1_1struc_1_1sync__io_1_1Channel.html#a0c00bab2dad604dde176c4190553915c" title="Permanently memorizes the incoming-direction on-error handler, thus authorizing the emission of any i...">start_and_poll()</a>);</li>
<li>upon this sequence occurring:<ol type="1">
<li>An async-read (from this very method) yielded would-block.</li>
<li>The would-block ended &ndash; a message was received asynchronously.</li>
<li><a class="el" href="classipc_1_1transport_1_1struc_1_1sync__io_1_1Channel.html#af546fc0ab4d0ddca0a857c57decd0620" title="To execute upon completing an m_channel.async_receive_*() of an expected lead message along the given...">rcv_on_async_read_lead_msg()</a> or <a class="el" href="classipc_1_1transport_1_1struc_1_1sync__io_1_1Channel.html#aa83fd6e35057876e2f5173df53e73371" title="Same as rcv_on_async_read_lead_msg() but for an expected continuation message instead of lead.">rcv_on_async_read_continuation_msg()</a> processed that in-message and would like to now read as many in-messages as possible that follow it (synchronously).</li>
</ol>
</li>
</ul>
<p >To avoid growing the stack proportionally to the # of pending in-messages on the low-level transport, this method does not call itself &ndash; it reads all available messages in a loop until would-block or pipe-hosing error. Therefore the following is <em>not</em> a trigger for calling this method:</p><ul>
<li>we've executed an async-read, and it yielded an in-message synchronously, which we then processed; and would like to now read as many in-messages as possible that follow it (synchronously).</li>
</ul>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lead_else_cont</td><td><code>true</code> if seeking lead unstructured in-message; <code>false</code> if continuation. It may be helpful to look at Rcv_next_step docs for brief overview of when it would be one versus the other. Or if you love reading and being confused by ygoldfel's verbiage then <a class="el" href="structipc_1_1transport_1_1struc_1_1sync__io_1_1Channel_1_1Msg__in__pipe.html" title="Data and policy with respect to receipt of the next/currently-incomplete in-message.">Msg_in_pipe</a> doc header. (The preceding sentence was written by ygoldfel. Self-shade only.) </td></tr>
    <tr><td class="paramname">pipe</td><td>Pointer into <a class="el" href="classipc_1_1transport_1_1struc_1_1sync__io_1_1Channel.html#a9c04f15d4d17cd43aca70136119e1d28" title="1 or 2 active (via optional) structs containing policy and state w/r/t receipt of low-level (unstruct...">m_rcv_pipes</a> array. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="ipc__transport__structured_2src_2ipc_2transport_2struc_2sync__io_2channel_8hpp_source.html#l02457">2457</a> of file <a class="el" href="ipc__transport__structured_2src_2ipc_2transport_2struc_2sync__io_2channel_8hpp_source.html">channel.hpp</a>.</p>

<p class="reference">References <a class="el" href="structipc_1_1transport_1_1struc_1_1sync__io_1_1Channel_1_1Msg__in__pipe.html#a3d239c5a1e29bd6db1ee7c4764616549">ipc::transport::struc::sync_io::Channel&lt; Channel_obj, Message_body, Struct_builder_config, Struct_reader_config &gt;::Msg_in_pipe::m_lead_msg_mode</a>, <a class="el" href="ipc__transport__structured_2src_2ipc_2transport_2struc_2sync__io_2channel_8hpp_source.html#l01183">ipc::transport::struc::sync_io::Channel&lt; Channel_obj, Message_body, Struct_builder_config, Struct_reader_config &gt;::Msg_in_pipe::m_n_segs_left_after_this_read</a>, <a class="el" href="ipc__transport__structured_2src_2ipc_2transport_2struc_2sync__io_2channel_8hpp_source.html#l01202">ipc::transport::struc::sync_io::Channel&lt; Channel_obj, Message_body, Struct_builder_config, Struct_reader_config &gt;::Msg_in_pipe::m_target_blob</a>, <a class="el" href="ipc__transport__structured_2src_2ipc_2transport_2struc_2sync__io_2channel_8hpp_source.html#l01215">ipc::transport::struc::sync_io::Channel&lt; Channel_obj, Message_body, Struct_builder_config, Struct_reader_config &gt;::Msg_in_pipe::m_target_hndl</a>, <a class="el" href="native__handle_8cpp_source.html#l00060">ipc::util::Native_handle::null()</a>, and <a class="el" href="namespaceipc_1_1transport_1_1error.html#adfef15ef4e76cc55d652fbd9c2797297aa667487757f9d6300f6888bac40bcc24">ipc::transport::error::S_SYNC_IO_WOULD_BLOCK</a>.</p>
<div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="classipc_1_1transport_1_1struc_1_1sync__io_1_1Channel_a252e43676b8a41a706df0655f887be63_cgraph.svg" width="444" height="59"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe>
</div>
</div>

</div>
</div>
<a id="a9b6cda20adb82073a1d7cf1b5cbfa865" name="a9b6cda20adb82073a1d7cf1b5cbfa865"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9b6cda20adb82073a1d7cf1b5cbfa865">&#9670;&nbsp;</a></span>rcv_blob_max_size()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Channel_obj , typename Message_body , typename Struct_builder_config , typename Struct_reader_config &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_t <a class="el" href="classipc_1_1transport_1_1struc_1_1sync__io_1_1Channel.html">ipc::transport::struc::sync_io::Channel</a>&lt; Channel_obj, Message_body, Struct_builder_config, Struct_reader_config &gt;::rcv_blob_max_size </td>
          <td>(</td>
          <td class="paramtype">decltype(<a class="el" href="structipc_1_1transport_1_1struc_1_1sync__io_1_1Channel_1_1Msg__in__pipe.html#a3d239c5a1e29bd6db1ee7c4764616549">Msg_in_pipe::m_lead_msg_mode</a>)&#160;</td>
          <td class="paramname"><em>mode</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Helper that returns the max receive-buffer size for any async-read into a given <a class="el" href="structipc_1_1transport_1_1struc_1_1sync__io_1_1Channel_1_1Msg__in__pipe.html" title="Data and policy with respect to receipt of the next/currently-incomplete in-message.">Msg_in_pipe</a>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">mode</td><td><a class="el" href="structipc_1_1transport_1_1struc_1_1sync__io_1_1Channel_1_1Msg__in__pipe.html#a3d239c5a1e29bd6db1ee7c4764616549" title="The immutable mode of behavior along this pipe, which must be enabled: Whether to use Native_handle_r...">Msg_in_pipe::m_lead_msg_mode</a>. The reason we don't take a <code>const <a class="el" href="structipc_1_1transport_1_1struc_1_1sync__io_1_1Channel_1_1Msg__in__pipe.html" title="Data and policy with respect to receipt of the next/currently-incomplete in-message.">Msg_in_pipe</a>&amp;</code> here is that there is a use case where this value is necessary just before the <a class="el" href="structipc_1_1transport_1_1struc_1_1sync__io_1_1Channel_1_1Msg__in__pipe.html" title="Data and policy with respect to receipt of the next/currently-incomplete in-message.">Msg_in_pipe</a> is actually constructed. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>See above. </dd></dl>

<p class="definition">Definition at line <a class="el" href="ipc__transport__structured_2src_2ipc_2transport_2struc_2sync__io_2channel_8hpp_source.html#l02427">2427</a> of file <a class="el" href="ipc__transport__structured_2src_2ipc_2transport_2struc_2sync__io_2channel_8hpp_source.html">channel.hpp</a>.</p>

</div>
</div>
<a id="aa83fd6e35057876e2f5173df53e73371" name="aa83fd6e35057876e2f5173df53e73371"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa83fd6e35057876e2f5173df53e73371">&#9670;&nbsp;</a></span>rcv_on_async_read_continuation_msg()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Channel_obj , typename Message_body , typename Struct_builder_config , typename Struct_reader_config &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classipc_1_1transport_1_1struc_1_1sync__io_1_1Channel.html">Channel</a>&lt; Channel_obj, Message_body, Struct_builder_config, Struct_reader_config &gt;<a class="el" href="classipc_1_1transport_1_1struc_1_1sync__io_1_1Channel.html#a9d3344a97644dad136bb47e852dda6fd">::Rcv_next_step</a> <a class="el" href="classipc_1_1transport_1_1struc_1_1sync__io_1_1Channel.html">ipc::transport::struc::sync_io::Channel</a>&lt; Channel_obj, Message_body, Struct_builder_config, Struct_reader_config &gt;::rcv_on_async_read_continuation_msg </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structipc_1_1transport_1_1struc_1_1sync__io_1_1Channel_1_1Msg__in__pipe.html">Msg_in_pipe</a> *&#160;</td>
          <td class="paramname"><em>pipe</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespaceipc.html#aa3192e586cc45d3e7c22463bf2760f89">Error_code</a> &amp;&#160;</td>
          <td class="paramname"><em>err_code</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>sz</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Same as <a class="el" href="classipc_1_1transport_1_1struc_1_1sync__io_1_1Channel.html#af546fc0ab4d0ddca0a857c57decd0620" title="To execute upon completing an m_channel.async_receive_*() of an expected lead message along the given...">rcv_on_async_read_lead_msg()</a> but for an expected continuation message instead of lead. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pipe</td><td>See <a class="el" href="classipc_1_1transport_1_1struc_1_1sync__io_1_1Channel.html#af546fc0ab4d0ddca0a857c57decd0620" title="To execute upon completing an m_channel.async_receive_*() of an expected lead message along the given...">rcv_on_async_read_lead_msg()</a>. </td></tr>
    <tr><td class="paramname">err_code</td><td>See <a class="el" href="classipc_1_1transport_1_1struc_1_1sync__io_1_1Channel.html#af546fc0ab4d0ddca0a857c57decd0620" title="To execute upon completing an m_channel.async_receive_*() of an expected lead message along the given...">rcv_on_async_read_lead_msg()</a>. </td></tr>
    <tr><td class="paramname">sz</td><td>See <a class="el" href="classipc_1_1transport_1_1struc_1_1sync__io_1_1Channel.html#af546fc0ab4d0ddca0a857c57decd0620" title="To execute upon completing an m_channel.async_receive_*() of an expected lead message along the given...">rcv_on_async_read_lead_msg()</a>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>What to do next: read another continuation message; read lead message; or stop (pipe-hosing error). </dd></dl>

<p class="definition">Definition at line <a class="el" href="ipc__transport__structured_2src_2ipc_2transport_2struc_2sync__io_2channel_8hpp_source.html#l02784">2784</a> of file <a class="el" href="ipc__transport__structured_2src_2ipc_2transport_2struc_2sync__io_2channel_8hpp_source.html">channel.hpp</a>.</p>

<p class="reference">References <a class="el" href="ipc__transport__structured_2src_2ipc_2transport_2struc_2sync__io_2channel_8hpp_source.html#l01237">ipc::transport::struc::sync_io::Channel&lt; Channel_obj, Message_body, Struct_builder_config, Struct_reader_config &gt;::Msg_in_pipe::m_incomplete_msg</a>, <a class="el" href="structipc_1_1transport_1_1struc_1_1sync__io_1_1Channel_1_1Msg__in__pipe.html#a3d239c5a1e29bd6db1ee7c4764616549">ipc::transport::struc::sync_io::Channel&lt; Channel_obj, Message_body, Struct_builder_config, Struct_reader_config &gt;::Msg_in_pipe::m_lead_msg_mode</a>, <a class="el" href="ipc__transport__structured_2src_2ipc_2transport_2struc_2sync__io_2channel_8hpp_source.html#l01183">ipc::transport::struc::sync_io::Channel&lt; Channel_obj, Message_body, Struct_builder_config, Struct_reader_config &gt;::Msg_in_pipe::m_n_segs_left_after_this_read</a>, <a class="el" href="ipc__transport__structured_2src_2ipc_2transport_2struc_2sync__io_2channel_8hpp_source.html#l01202">ipc::transport::struc::sync_io::Channel&lt; Channel_obj, Message_body, Struct_builder_config, Struct_reader_config &gt;::Msg_in_pipe::m_target_blob</a>, <a class="el" href="ipc__transport__structured_2src_2ipc_2transport_2struc_2sync__io_2channel_8hpp_source.html#l01215">ipc::transport::struc::sync_io::Channel&lt; Channel_obj, Message_body, Struct_builder_config, Struct_reader_config &gt;::Msg_in_pipe::m_target_hndl</a>, <a class="el" href="native__handle_8cpp_source.html#l00060">ipc::util::Native_handle::null()</a>, <a class="el" href="namespaceipc_1_1transport_1_1struc_1_1error.html#a990b9ff850cf9aaf354efdd07d86a71dade89b3f5038a04f02d8f4ae68698a069">ipc::transport::struc::error::S_INTERNAL_ERROR_DESERIALIZE_TARGET_ALLOC_FAILED</a>, <a class="el" href="namespaceipc_1_1transport_1_1error.html#adfef15ef4e76cc55d652fbd9c2797297afe29343445a7bf167cc186a44bd2c6ed">ipc::transport::error::S_OBJECT_SHUTDOWN_ABORTED_COMPLETION_HANDLER</a>, <a class="el" href="namespaceipc_1_1transport_1_1struc_1_1error.html#a990b9ff850cf9aaf354efdd07d86a71da64f092d17e34549f74d37f8f03c98954">ipc::transport::struc::error::S_STRUCT_CHANNEL_INTERNAL_PROTOCOL_MISMATCH_GOT_HNDL</a>, and <a class="el" href="namespaceipc_1_1transport_1_1struc_1_1error.html#a990b9ff850cf9aaf354efdd07d86a71dae77f8d36304752faf1a967c474457569">ipc::transport::struc::error::S_STRUCT_CHANNEL_INTERNAL_PROTOCOL_MISMATCH_GOT_NO_BLOB</a>.</p>
<div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="classipc_1_1transport_1_1struc_1_1sync__io_1_1Channel_aa83fd6e35057876e2f5173df53e73371_cgraph.svg" width="419" height="59"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe>
</div>
</div>

</div>
</div>
<a id="af546fc0ab4d0ddca0a857c57decd0620" name="af546fc0ab4d0ddca0a857c57decd0620"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af546fc0ab4d0ddca0a857c57decd0620">&#9670;&nbsp;</a></span>rcv_on_async_read_lead_msg()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Channel_obj , typename Message_body , typename Struct_builder_config , typename Struct_reader_config &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classipc_1_1transport_1_1struc_1_1sync__io_1_1Channel.html">Channel</a>&lt; Channel_obj, Message_body, Struct_builder_config, Struct_reader_config &gt;<a class="el" href="classipc_1_1transport_1_1struc_1_1sync__io_1_1Channel.html#a9d3344a97644dad136bb47e852dda6fd">::Rcv_next_step</a> <a class="el" href="classipc_1_1transport_1_1struc_1_1sync__io_1_1Channel.html">ipc::transport::struc::sync_io::Channel</a>&lt; Channel_obj, Message_body, Struct_builder_config, Struct_reader_config &gt;::rcv_on_async_read_lead_msg </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structipc_1_1transport_1_1struc_1_1sync__io_1_1Channel_1_1Msg__in__pipe.html">Msg_in_pipe</a> *&#160;</td>
          <td class="paramname"><em>pipe</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespaceipc.html#aa3192e586cc45d3e7c22463bf2760f89">Error_code</a> &amp;&#160;</td>
          <td class="paramname"><em>err_code</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>sz</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>To execute upon completing an <code>m_channel.async_receive_*()</code> of an expected lead message along the given in-pipe, this processes the result (message or error) and returns what should be done next; does <em>not</em> invoke <a class="el" href="classipc_1_1transport_1_1struc_1_1sync__io_1_1Channel.html#a3a0adf8ce8fc29ec55b4c8c30886c1fc" title="Executes what was recorded recently in handlers_post().">handlers_poll()</a>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pipe</td><td>See <a class="el" href="classipc_1_1transport_1_1struc_1_1sync__io_1_1Channel.html#a252e43676b8a41a706df0655f887be63" title="This key method acts on the pre-condition that the given in-pipe is not known to be in would-block st...">rcv_async_read_lead_or_continuation_msg()</a>. <code>*pipe-&gt;m_target_blob</code> and <code>*pipe-&gt;m_target_hndl</code> may have been received-into. </td></tr>
    <tr><td class="paramname">err_code</td><td>From <code>Channel::async_receive_*()</code>. </td></tr>
    <tr><td class="paramname">sz</td><td>From <code>Channel::async_receive_*()</code>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>What to do next: read another lead message; read continuation message; or stop (pipe-hosing error). </dd></dl>

<p class="definition">Definition at line <a class="el" href="ipc__transport__structured_2src_2ipc_2transport_2struc_2sync__io_2channel_8hpp_source.html#l02640">2640</a> of file <a class="el" href="ipc__transport__structured_2src_2ipc_2transport_2struc_2sync__io_2channel_8hpp_source.html">channel.hpp</a>.</p>

<p class="reference">References <a class="el" href="ipc__transport__structured_2src_2ipc_2transport_2struc_2sync__io_2channel_8hpp_source.html#l01237">ipc::transport::struc::sync_io::Channel&lt; Channel_obj, Message_body, Struct_builder_config, Struct_reader_config &gt;::Msg_in_pipe::m_incomplete_msg</a>, <a class="el" href="structipc_1_1transport_1_1struc_1_1sync__io_1_1Channel_1_1Msg__in__pipe.html#a3d239c5a1e29bd6db1ee7c4764616549">ipc::transport::struc::sync_io::Channel&lt; Channel_obj, Message_body, Struct_builder_config, Struct_reader_config &gt;::Msg_in_pipe::m_lead_msg_mode</a>, <a class="el" href="ipc__transport__structured_2src_2ipc_2transport_2struc_2sync__io_2channel_8hpp_source.html#l01183">ipc::transport::struc::sync_io::Channel&lt; Channel_obj, Message_body, Struct_builder_config, Struct_reader_config &gt;::Msg_in_pipe::m_n_segs_left_after_this_read</a>, <a class="el" href="ipc__transport__structured_2src_2ipc_2transport_2struc_2sync__io_2channel_8hpp_source.html#l01202">ipc::transport::struc::sync_io::Channel&lt; Channel_obj, Message_body, Struct_builder_config, Struct_reader_config &gt;::Msg_in_pipe::m_target_blob</a>, <a class="el" href="ipc__transport__structured_2src_2ipc_2transport_2struc_2sync__io_2channel_8hpp_source.html#l01215">ipc::transport::struc::sync_io::Channel&lt; Channel_obj, Message_body, Struct_builder_config, Struct_reader_config &gt;::Msg_in_pipe::m_target_hndl</a>, <a class="el" href="native__handle_8cpp_source.html#l00060">ipc::util::Native_handle::null()</a>, <a class="el" href="namespaceipc_1_1transport_1_1struc_1_1error.html#a990b9ff850cf9aaf354efdd07d86a71dade89b3f5038a04f02d8f4ae68698a069">ipc::transport::struc::error::S_INTERNAL_ERROR_DESERIALIZE_TARGET_ALLOC_FAILED</a>, <a class="el" href="namespaceipc_1_1transport_1_1error.html#adfef15ef4e76cc55d652fbd9c2797297afe29343445a7bf167cc186a44bd2c6ed">ipc::transport::error::S_OBJECT_SHUTDOWN_ABORTED_COMPLETION_HANDLER</a>, <a class="el" href="namespaceipc_1_1transport_1_1struc_1_1error.html#a990b9ff850cf9aaf354efdd07d86a71dae77f8d36304752faf1a967c474457569">ipc::transport::struc::error::S_STRUCT_CHANNEL_INTERNAL_PROTOCOL_MISMATCH_GOT_NO_BLOB</a>, and <a class="el" href="namespaceipc_1_1transport_1_1struc_1_1error.html#a990b9ff850cf9aaf354efdd07d86a71dadaf85866b948217cbf039a7b4f89dbd3">ipc::transport::struc::error::S_STRUCT_CHANNEL_INTERNAL_PROTOCOL_MISMATCH_GOT_NO_HNDL</a>.</p>
<div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="classipc_1_1transport_1_1struc_1_1sync__io_1_1Channel_af546fc0ab4d0ddca0a857c57decd0620_cgraph.svg" width="374" height="59"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe>
</div>
</div>

</div>
</div>
<a id="a795baef6fefbc4749daf5ceda52943c1" name="a795baef6fefbc4749daf5ceda52943c1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a795baef6fefbc4749daf5ceda52943c1">&#9670;&nbsp;</a></span>rcv_struct_inform_of_unexpected_response()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Channel_obj , typename Message_body , typename Struct_builder_config , typename Struct_reader_config &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classipc_1_1transport_1_1struc_1_1sync__io_1_1Channel.html">ipc::transport::struc::sync_io::Channel</a>&lt; Channel_obj, Message_body, Struct_builder_config, Struct_reader_config &gt;::rcv_struct_inform_of_unexpected_response </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classipc_1_1transport_1_1struc_1_1sync__io_1_1Channel.html#a84287334d14f54c97f7dbb0d5b04cca5">Msg_in_ptr_uniq</a> &amp;&amp;&#160;</td>
          <td class="paramname"><em>msg_in</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Helper from <a class="el" href="classipc_1_1transport_1_1struc_1_1sync__io_1_1Channel.html#a134966e02297d141b9e6d5e0d2ca3a7b" title="Helper from rcv_struct_new_msg_in() (possibly indirectly): the case where the in-message&#39;s session-to...">rcv_struct_new_msg_in_is_next_expected()</a> that reacts to receiving an otherwise valid reponse in-message when no such response is expected. </p>
<p >Hence it deals with <a class="el" href="classipc_1_1transport_1_1struc_1_1sync__io_1_1Channel.html#a5c62d2a374a3a98e7fa0aef01bf8a774" title="See Async_io_obj counterpart; though naturally on_func() is invoked in the sync_io-pattern fashion.">set_unexpected_response_handler()</a> (if set) handler invocation and informing the opposing side, so that it might invoke its <a class="el" href="classipc_1_1transport_1_1struc_1_1sync__io_1_1Channel.html#a3fda370cc97c89a62f77a6fcf639cfd7" title="See Async_io_obj counterpart; though naturally on_func() is invoked in the sync_io-pattern fashion.">set_remote_unexpected_response_handler()</a> (if set) handler.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">msg_in</td><td>See <a class="el" href="classipc_1_1transport_1_1struc_1_1sync__io_1_1Channel.html#a134966e02297d141b9e6d5e0d2ca3a7b" title="Helper from rcv_struct_new_msg_in() (possibly indirectly): the case where the in-message&#39;s session-to...">rcv_struct_new_msg_in_is_next_expected()</a>. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="ipc__transport__structured_2src_2ipc_2transport_2struc_2sync__io_2channel_8hpp_source.html#l03585">3585</a> of file <a class="el" href="ipc__transport__structured_2src_2ipc_2transport_2struc_2sync__io_2channel_8hpp_source.html">channel.hpp</a>.</p>

<p class="reference">References <a class="el" href="msg__mdt__out_8hpp_source.html#l00193">ipc::transport::struc::Msg_mdt_out&lt; Struct_builder_config &gt;::internal_msg_body_root()</a>.</p>
<div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="classipc_1_1transport_1_1struc_1_1sync__io_1_1Channel_a795baef6fefbc4749daf5ceda52943c1_cgraph.svg" width="392" height="71"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe>
</div>
</div>

</div>
</div>
<a id="ab8bfe06a0aecb261dd11624c4ddec518" name="ab8bfe06a0aecb261dd11624c4ddec518"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab8bfe06a0aecb261dd11624c4ddec518">&#9670;&nbsp;</a></span>rcv_struct_new_internal_msg_in()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Channel_obj , typename Message_body , typename Struct_builder_config , typename Struct_reader_config &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classipc_1_1transport_1_1struc_1_1sync__io_1_1Channel.html">ipc::transport::struc::sync_io::Channel</a>&lt; Channel_obj, Message_body, Struct_builder_config, Struct_reader_config &gt;::rcv_struct_new_internal_msg_in </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classipc_1_1transport_1_1struc_1_1sync__io_1_1Channel.html#acb6922fb543bd544a2244412e4835e82">Msg_in_impl</a> &amp;&#160;</td>
          <td class="paramname"><em>msg_in</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Helper from <code><a class="el" href="classipc_1_1transport_1_1struc_1_1sync__io_1_1Channel.html#aa210976b523c04042dd083f054182441" title="Helper from rcv_on_async_read_*(), processes a newly completed structured in-message,...">rcv_struct_new_msg_in()</a></code>: the case where the in-message has a sentinel message ID value, indicating an internal message rather that one from a user <a class="el" href="classipc_1_1transport_1_1struc_1_1sync__io_1_1Channel.html#a0dc388e18b0fc0fa2d8ad0a6953fb039" title="See Async_io_obj counterpart.">send()</a> (et al). </p>
<p ><a class="el" href="classipc_1_1transport_1_1struc_1_1sync__io_1_1Channel.html#a95cfe30e685e828d62318c9b2bc4b137" title="Starts falsy; becomes forever truthy (with a specific Error_code that will not change thereafter) whe...">m_channel_err_code_or_ok</a> must be falsy.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">msg_in</td><td>Deserialized in-message with sentinel message ID value. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>See <a class="el" href="classipc_1_1transport_1_1struc_1_1sync__io_1_1Channel.html#aa210976b523c04042dd083f054182441" title="Helper from rcv_on_async_read_*(), processes a newly completed structured in-message,...">rcv_struct_new_msg_in()</a>. </dd></dl>

<p class="definition">Definition at line <a class="el" href="ipc__transport__structured_2src_2ipc_2transport_2struc_2sync__io_2channel_8hpp_source.html#l03226">3226</a> of file <a class="el" href="ipc__transport__structured_2src_2ipc_2transport_2struc_2sync__io_2channel_8hpp_source.html">channel.hpp</a>.</p>

<p class="reference">References <a class="el" href="msg__impl_8hpp_source.html#l00235">ipc::transport::struc::Msg_in_impl&lt; Message_body, Struct_reader_config &gt;::internal_msg_body_root()</a>, <a class="el" href="msg__impl_8hpp_source.html#l00228">ipc::transport::struc::Msg_in_impl&lt; Message_body, Struct_reader_config &gt;::originating_msg_id_or_none()</a>, <a class="el" href="namespaceipc_1_1transport_1_1struc_1_1error.html#a990b9ff850cf9aaf354efdd07d86a71da86f9bea5b4ceda65e11b2a3ec7e389f7">ipc::transport::struc::error::S_STRUCT_CHANNEL_INTERNAL_PROTOCOL_INTERNAL_MSG_TYPE_UNKNOWN</a>, and <a class="el" href="namespaceipc_1_1transport_1_1struc_1_1error.html#a990b9ff850cf9aaf354efdd07d86a71da26ab25e100104aeb567d90f794313e3b">ipc::transport::struc::error::S_STRUCT_CHANNEL_INTERNAL_PROTOCOL_MISUSED_SCHEMA</a>.</p>
<div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="classipc_1_1transport_1_1struc_1_1sync__io_1_1Channel_ab8bfe06a0aecb261dd11624c4ddec518_cgraph.svg" width="398" height="131"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe>
</div>
</div>

</div>
</div>
<a id="aa210976b523c04042dd083f054182441" name="aa210976b523c04042dd083f054182441"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa210976b523c04042dd083f054182441">&#9670;&nbsp;</a></span>rcv_struct_new_msg_in()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Channel_obj , typename Message_body , typename Struct_builder_config , typename Struct_reader_config &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classipc_1_1transport_1_1struc_1_1sync__io_1_1Channel.html">ipc::transport::struc::sync_io::Channel</a>&lt; Channel_obj, Message_body, Struct_builder_config, Struct_reader_config &gt;::rcv_struct_new_msg_in </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classipc_1_1transport_1_1struc_1_1sync__io_1_1Channel.html#a84287334d14f54c97f7dbb0d5b04cca5">Msg_in_ptr_uniq</a> &amp;&amp;&#160;</td>
          <td class="paramname"><em>msg_in</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Helper from <code>rcv_on_async_read_*()</code>, processes a newly completed structured in-message, as it exits the <code><a class="el" href="classipc_1_1transport_1_1struc_1_1sync__io_1_1Channel.html" title="sync_io-pattern counterpart to async-I/O-pattern transport::struc::Channel.">Channel</a></code>-layer and enters into the structured-layer of processing. </p>
<p ><a class="el" href="classipc_1_1transport_1_1struc_1_1sync__io_1_1Channel.html#a95cfe30e685e828d62318c9b2bc4b137" title="Starts falsy; becomes forever truthy (with a specific Error_code that will not change thereafter) whe...">m_channel_err_code_or_ok</a> must be falsy.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">msg_in</td><td>The completed structured in-message: after <a class="el" href="classipc_1_1transport_1_1struc_1_1Msg__in.html#acd387ce27214601a70a0e1c6025075f1" title="To be invoked after exactly one successful add_serialization_segment() call (and that Blob being fill...">Msg_in::deserialize_mdt()</a> but before <a class="el" href="classipc_1_1transport_1_1struc_1_1Msg__in.html#acc5514d773db8edb0d8d0c3d52743a6a" title="To be invoked after deserialize_mdt() == N, and add_serialization_segment() was called N times (with ...">Msg_in::deserialize_body()</a>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>false</code> if something in <code>msg_in</code> triggers truthy <a class="el" href="classipc_1_1transport_1_1struc_1_1sync__io_1_1Channel.html#a95cfe30e685e828d62318c9b2bc4b137" title="Starts falsy; becomes forever truthy (with a specific Error_code that will not change thereafter) whe...">m_channel_err_code_or_ok</a>; hence the async-read chain must end now. Otherwise <code>true</code>. </dd></dl>

<p class="definition">Definition at line <a class="el" href="ipc__transport__structured_2src_2ipc_2transport_2struc_2sync__io_2channel_8hpp_source.html#l02891">2891</a> of file <a class="el" href="ipc__transport__structured_2src_2ipc_2transport_2struc_2sync__io_2channel_8hpp_source.html">channel.hpp</a>.</p>

<p class="reference">References <a class="el" href="namespaceipc_1_1transport_1_1struc_1_1error.html#a990b9ff850cf9aaf354efdd07d86a71da2fba90660c799be216d283a3129f1f63">ipc::transport::struc::error::S_STRUCT_CHANNEL_INTERNAL_PROTOCOL_BAD_AUTH</a>, <a class="el" href="namespaceipc_1_1transport_1_1struc_1_1error.html#a990b9ff850cf9aaf354efdd07d86a71daab47c241a659164b808ddba23736d02b">ipc::transport::struc::error::S_STRUCT_CHANNEL_INTERNAL_PROTOCOL_LOG_IN_MISUSED_SCHEMA</a>, and <a class="el" href="namespaceipc_1_1transport_1_1struc_1_1error.html#a990b9ff850cf9aaf354efdd07d86a71da26ab25e100104aeb567d90f794313e3b">ipc::transport::struc::error::S_STRUCT_CHANNEL_INTERNAL_PROTOCOL_MISUSED_SCHEMA</a>.</p>

</div>
</div>
<a id="aff04d908fa53c7df582f3b2b6e51cfce" name="aff04d908fa53c7df582f3b2b6e51cfce"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aff04d908fa53c7df582f3b2b6e51cfce">&#9670;&nbsp;</a></span>rcv_struct_new_msg_in_during_log_in_as_cli()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Channel_obj , typename Message_body , typename Struct_builder_config , typename Struct_reader_config &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classipc_1_1transport_1_1struc_1_1sync__io_1_1Channel.html">ipc::transport::struc::sync_io::Channel</a>&lt; Channel_obj, Message_body, Struct_builder_config, Struct_reader_config &gt;::rcv_struct_new_msg_in_during_log_in_as_cli </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classipc_1_1transport_1_1struc_1_1sync__io_1_1Channel.html#a84287334d14f54c97f7dbb0d5b04cca5">Msg_in_ptr_uniq</a> &amp;&amp;&#160;</td>
          <td class="paramname"><em>msg_in</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Helper from <code><a class="el" href="classipc_1_1transport_1_1struc_1_1sync__io_1_1Channel.html#aa210976b523c04042dd083f054182441" title="Helper from rcv_on_async_read_*(), processes a newly completed structured in-message,...">rcv_struct_new_msg_in()</a></code>: the case where <a class="el" href="classipc_1_1transport_1_1struc_1_1sync__io_1_1Channel.html#afca9a3012b2f41d635381a5a13ddd7c1" title="Phase (w/r/t log-in or lack thereof) of *this peer.">m_phase</a> is <a class="el" href="classipc_1_1transport_1_1struc_1_1sync__io_1_1Channel.html#a5a3833cd141802041551db21198ac319aa0cb6b19ec0b17da2c3ed65de71ca437" title="Logging-in phase, as client process: The general API (expect_msg(), etc.) is unavailable; only create...">Phase::S_CLI_LOG_IN</a>, and the in-message has the log-in-response value 1 + session-token=nil as required: Processes the in-message according to the rigid log-in phase algorithm. </p>
<p ><a class="el" href="classipc_1_1transport_1_1struc_1_1sync__io_1_1Channel.html#aa210976b523c04042dd083f054182441" title="Helper from rcv_on_async_read_*(), processes a newly completed structured in-message,...">rcv_struct_new_msg_in()</a> returns what this returns, immediately.</p>
<p ><a class="el" href="classipc_1_1transport_1_1struc_1_1sync__io_1_1Channel.html#a95cfe30e685e828d62318c9b2bc4b137" title="Starts falsy; becomes forever truthy (with a specific Error_code that will not change thereafter) whe...">m_channel_err_code_or_ok</a> must be falsy.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">msg_in</td><td>Deserialized in-message with message ID 1 and session-token=nil. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>See <a class="el" href="classipc_1_1transport_1_1struc_1_1sync__io_1_1Channel.html#aa210976b523c04042dd083f054182441" title="Helper from rcv_on_async_read_*(), processes a newly completed structured in-message,...">rcv_struct_new_msg_in()</a>. </dd></dl>

<p class="definition">Definition at line <a class="el" href="ipc__transport__structured_2src_2ipc_2transport_2struc_2sync__io_2channel_8hpp_source.html#l03286">3286</a> of file <a class="el" href="ipc__transport__structured_2src_2ipc_2transport_2struc_2sync__io_2channel_8hpp_source.html">channel.hpp</a>.</p>

<p class="reference">References <a class="el" href="namespaceipc_1_1transport_1_1struc_1_1error.html#a990b9ff850cf9aaf354efdd07d86a71daab47c241a659164b808ddba23736d02b">ipc::transport::struc::error::S_STRUCT_CHANNEL_INTERNAL_PROTOCOL_LOG_IN_MISUSED_SCHEMA</a>.</p>

</div>
</div>
<a id="a9174c694ee8437605c089965ecea2ebf" name="a9174c694ee8437605c089965ecea2ebf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9174c694ee8437605c089965ecea2ebf">&#9670;&nbsp;</a></span>rcv_struct_new_msg_in_during_log_in_as_srv()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Channel_obj , typename Message_body , typename Struct_builder_config , typename Struct_reader_config &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classipc_1_1transport_1_1struc_1_1sync__io_1_1Channel.html">ipc::transport::struc::sync_io::Channel</a>&lt; Channel_obj, Message_body, Struct_builder_config, Struct_reader_config &gt;::rcv_struct_new_msg_in_during_log_in_as_srv </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classipc_1_1transport_1_1struc_1_1sync__io_1_1Channel.html#a84287334d14f54c97f7dbb0d5b04cca5">Msg_in_ptr_uniq</a> &amp;&amp;&#160;</td>
          <td class="paramname"><em>msg_in</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Like <a class="el" href="classipc_1_1transport_1_1struc_1_1sync__io_1_1Channel.html#aff04d908fa53c7df582f3b2b6e51cfce" title="Helper from rcv_struct_new_msg_in(): the case where m_phase is Phase::S_CLI_LOG_IN,...">rcv_struct_new_msg_in_during_log_in_as_cli()</a> but for <a class="el" href="classipc_1_1transport_1_1struc_1_1sync__io_1_1Channel.html#a5a3833cd141802041551db21198ac319ab64edfa66dd4c58d7aa1c3a30e142706" title="Logging-in phase, as server process: The general API (expect_msg(), etc.) is unavailable; only expect...">Phase::S_SRV_LOG_IN</a> instead of CLI_LOG_IN. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">msg_in</td><td>See <a class="el" href="classipc_1_1transport_1_1struc_1_1sync__io_1_1Channel.html#aff04d908fa53c7df582f3b2b6e51cfce" title="Helper from rcv_struct_new_msg_in(): the case where m_phase is Phase::S_CLI_LOG_IN,...">rcv_struct_new_msg_in_during_log_in_as_cli()</a>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>See <a class="el" href="classipc_1_1transport_1_1struc_1_1sync__io_1_1Channel.html#aff04d908fa53c7df582f3b2b6e51cfce" title="Helper from rcv_struct_new_msg_in(): the case where m_phase is Phase::S_CLI_LOG_IN,...">rcv_struct_new_msg_in_during_log_in_as_cli()</a>. </dd></dl>

<p class="definition">Definition at line <a class="el" href="ipc__transport__structured_2src_2ipc_2transport_2struc_2sync__io_2channel_8hpp_source.html#l03366">3366</a> of file <a class="el" href="ipc__transport__structured_2src_2ipc_2transport_2struc_2sync__io_2channel_8hpp_source.html">channel.hpp</a>.</p>

<p class="reference">References <a class="el" href="namespaceipc_1_1transport_1_1struc_1_1error.html#a990b9ff850cf9aaf354efdd07d86a71dad88bc7df9bd2dcdf4370585c912a9a61">ipc::transport::struc::error::S_STRUCT_CHANNEL_GOT_UNEXPECTED_LOG_IN_REQUEST</a>, and <a class="el" href="namespaceipc_1_1transport_1_1struc_1_1error.html#a990b9ff850cf9aaf354efdd07d86a71daab47c241a659164b808ddba23736d02b">ipc::transport::struc::error::S_STRUCT_CHANNEL_INTERNAL_PROTOCOL_LOG_IN_MISUSED_SCHEMA</a>.</p>

</div>
</div>
<a id="a134966e02297d141b9e6d5e0d2ca3a7b" name="a134966e02297d141b9e6d5e0d2ca3a7b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a134966e02297d141b9e6d5e0d2ca3a7b">&#9670;&nbsp;</a></span>rcv_struct_new_msg_in_is_next_expected()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Channel_obj , typename Message_body , typename Struct_builder_config , typename Struct_reader_config &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classipc_1_1transport_1_1struc_1_1sync__io_1_1Channel.html">ipc::transport::struc::sync_io::Channel</a>&lt; Channel_obj, Message_body, Struct_builder_config, Struct_reader_config &gt;::rcv_struct_new_msg_in_is_next_expected </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classipc_1_1transport_1_1struc_1_1sync__io_1_1Channel.html#a84287334d14f54c97f7dbb0d5b04cca5">Msg_in_ptr_uniq</a> &amp;&amp;&#160;</td>
          <td class="paramname"><em>msg_in</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Helper from <code><a class="el" href="classipc_1_1transport_1_1struc_1_1sync__io_1_1Channel.html#aa210976b523c04042dd083f054182441" title="Helper from rcv_on_async_read_*(), processes a newly completed structured in-message,...">rcv_struct_new_msg_in()</a></code> (possibly indirectly): the case where the in-message's session-token and message ID have been validated (and the latter indicates a user, not internal, message), and the message ID (seq #) indicates this is the next expected in-order message (hence <a class="el" href="classipc_1_1transport_1_1struc_1_1sync__io_1_1Channel.html#a26d39d4e1e2c304ef803b3721bde86f0" title="Next expected in-message ID (sequence #), incremented from initial value 1 to 2, 3,...">m_rcv_msg_next_id</a> was just <code>++</code>ed). </p>
<p ><a class="el" href="classipc_1_1transport_1_1struc_1_1sync__io_1_1Channel.html#afca9a3012b2f41d635381a5a13ddd7c1" title="Phase (w/r/t log-in or lack thereof) of *this peer.">m_phase</a> may be any of the 3 values; but the special processing in <a class="el" href="classipc_1_1transport_1_1struc_1_1sync__io_1_1Channel.html#aff04d908fa53c7df582f3b2b6e51cfce" title="Helper from rcv_struct_new_msg_in(): the case where m_phase is Phase::S_CLI_LOG_IN,...">rcv_struct_new_msg_in_during_log_in_as_cli()</a> or <a class="el" href="classipc_1_1transport_1_1struc_1_1sync__io_1_1Channel.html#a9174c694ee8437605c089965ecea2ebf" title="Like rcv_struct_new_msg_in_during_log_in_as_cli() but for Phase::S_SRV_LOG_IN instead of CLI_LOG_IN.">rcv_struct_new_msg_in_during_log_in_as_srv()</a> must have already completed if not LOGGED_IN.</p>
<p >Assuming no detected error therein, this method processes taking <code>msg_in</code> from the lower 2-3 layers (Channel-layer, structured message layer, possibly reassembly queue layer) into the next 1-2 (possibly caching in <a class="el" href="classipc_1_1transport_1_1struc_1_1sync__io_1_1Channel.html#ae9f5a798718d98523342acf55400d628" title="Queues of in-messages, keyed by Msg_which_in, each in msg_id_in_t (sequence #) order,...">m_rcv_pending_msgs</a>, emission to user).</p>
<p >Handles just <code>msg_in</code> itself: Does not check whether the gap to any messages in <a class="el" href="classipc_1_1transport_1_1struc_1_1sync__io_1_1Channel.html#a1218e59c91d08758cd997d77913abd5a" title="When Owned_channel::S_HAS_2_PIPES, stores the reassembly queue of in-messages to feed into m_rcv_pend...">m_rcv_reassembly_q</a> has been filled by this. That is, it's not self-perpetuating: caller must call us again for any messages dequeued from <a class="el" href="classipc_1_1transport_1_1struc_1_1sync__io_1_1Channel.html#a1218e59c91d08758cd997d77913abd5a" title="When Owned_channel::S_HAS_2_PIPES, stores the reassembly queue of in-messages to feed into m_rcv_pend...">m_rcv_reassembly_q</a>.</p>
<p ><a class="el" href="classipc_1_1transport_1_1struc_1_1sync__io_1_1Channel.html#a95cfe30e685e828d62318c9b2bc4b137" title="Starts falsy; becomes forever truthy (with a specific Error_code that will not change thereafter) whe...">m_channel_err_code_or_ok</a> must be falsy.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">msg_in</td><td>Deserialized in-message with sentinel message ID value. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>See <a class="el" href="classipc_1_1transport_1_1struc_1_1sync__io_1_1Channel.html#aa210976b523c04042dd083f054182441" title="Helper from rcv_on_async_read_*(), processes a newly completed structured in-message,...">rcv_struct_new_msg_in()</a>. </dd></dl>

<p class="definition">Definition at line <a class="el" href="ipc__transport__structured_2src_2ipc_2transport_2struc_2sync__io_2channel_8hpp_source.html#l03471">3471</a> of file <a class="el" href="ipc__transport__structured_2src_2ipc_2transport_2struc_2sync__io_2channel_8hpp_source.html">channel.hpp</a>.</p>

<p class="reference">References <a class="el" href="ipc__transport__structured_2src_2ipc_2transport_2struc_2sync__io_2channel_8hpp_source.html#l00970">ipc::transport::struc::sync_io::Channel&lt; Channel_obj, Message_body, Struct_builder_config, Struct_reader_config &gt;::Expecting_response::m_on_msg_func</a>, and <a class="el" href="ipc__transport__structured_2src_2ipc_2transport_2struc_2sync__io_2channel_8hpp_source.html#l00962">ipc::transport::struc::sync_io::Channel&lt; Channel_obj, Message_body, Struct_builder_config, Struct_reader_config &gt;::Expecting_response::m_one_expected</a>.</p>

</div>
</div>
<a id="a543aa806ec21b8550f9f440e59767d52" name="a543aa806ec21b8550f9f440e59767d52"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a543aa806ec21b8550f9f440e59767d52">&#9670;&nbsp;</a></span>replace_event_wait_handles()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Channel_obj , typename Message_body , typename Struct_builder_config , typename Struct_reader_config &gt; </div>
<div class="memtemplate">
template&lt;typename Create_ev_wait_hndl_func &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classipc_1_1transport_1_1struc_1_1sync__io_1_1Channel.html">ipc::transport::struc::sync_io::Channel</a>&lt; Channel_obj, Message_body, Struct_builder_config, Struct_reader_config &gt;::replace_event_wait_handles </td>
          <td>(</td>
          <td class="paramtype">const Create_ev_wait_hndl_func &amp;&#160;</td>
          <td class="paramname"><em>create_ev_wait_hndl_func</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Analogous to <a class="el" href="classipc_1_1transport_1_1sync__io_1_1Native__handle__sender.html#abe6227dfa077571d6eed2707532e4360" title="To be (optionally) invoked before any start_*_ops(), supplies a factory for the util::sync_io::Asio_w...">transport::sync_io::Native_handle_sender::replace_event_wait_handles()</a>. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Create_ev_wait_hndl_func</td><td>See above. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">create_ev_wait_hndl_func</td><td>See above. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>See above. </dd></dl>

<p class="definition">Definition at line <a class="el" href="ipc__transport__structured_2src_2ipc_2transport_2struc_2sync__io_2channel_8hpp_source.html#l02143">2143</a> of file <a class="el" href="ipc__transport__structured_2src_2ipc_2transport_2struc_2sync__io_2channel_8hpp_source.html">channel.hpp</a>.</p>

<p class="reference">Referenced by <a class="el" href="ipc__transport__structured_2src_2ipc_2transport_2struc_2channel_8hpp_source.html#l01593">ipc::transport::struc::Channel&lt; Channel_obj, Message_body, Struct_builder_config, Struct_reader_config &gt;::Channel()</a>.</p>
<div class="dynheader">
Here is the caller graph for this function:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="classipc_1_1transport_1_1struc_1_1sync__io_1_1Channel_a543aa806ec21b8550f9f440e59767d52_icgraph.svg" width="362" height="59"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe>
</div>
</div>

</div>
</div>
<a id="a0dc388e18b0fc0fa2d8ad0a6953fb039" name="a0dc388e18b0fc0fa2d8ad0a6953fb039"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0dc388e18b0fc0fa2d8ad0a6953fb039">&#9670;&nbsp;</a></span>send()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Channel_obj , typename Message_body , typename Struct_builder_config , typename Struct_reader_config &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classipc_1_1transport_1_1struc_1_1sync__io_1_1Channel.html">ipc::transport::struc::sync_io::Channel</a>&lt; Channel_obj, Message_body, Struct_builder_config, Struct_reader_config &gt;::send </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classipc_1_1transport_1_1struc_1_1sync__io_1_1Channel.html#a83fb4462a8d4045bdb56b694bf80393c">Msg_out</a> &amp;&#160;</td>
          <td class="paramname"><em>msg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classipc_1_1transport_1_1struc_1_1sync__io_1_1Channel.html#ac3da0ac1306b63c9e38c47b8c31e3cd2">Msg_in</a> *&#160;</td>
          <td class="paramname"><em>originating_msg_or_null</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceipc.html#aa3192e586cc45d3e7c22463bf2760f89">Error_code</a> *&#160;</td>
          <td class="paramname"><em>err_code</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>See <a class="el" href="classipc_1_1transport_1_1struc_1_1sync__io_1_1Channel.html#a6dc83bd6057b7f00a19c5947d6baa7b7" title="Useful for generic programming, the async-I/O-pattern counterpart to *this type.">Async_io_obj</a> counterpart. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">msg</td><td>See above. </td></tr>
    <tr><td class="paramname">originating_msg_or_null</td><td>See above. </td></tr>
    <tr><td class="paramname">err_code</td><td>See above. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>See above. In addition <code>false</code> returned if called before <a class="el" href="classipc_1_1transport_1_1struc_1_1sync__io_1_1Channel.html#a6e4f8c4207fcf678b4cfc785707d3dce" title="Sets up the sync_io-pattern interaction between *this and the user&#39;s event loop; required before asyn...">start_ops()</a>. </dd></dl>

<p class="definition">Definition at line <a class="el" href="ipc__transport__structured_2src_2ipc_2transport_2struc_2sync__io_2channel_8hpp_source.html#l03737">3737</a> of file <a class="el" href="ipc__transport__structured_2src_2ipc_2transport_2struc_2sync__io_2channel_8hpp_source.html">channel.hpp</a>.</p>

</div>
</div>
<a id="a0550bcab7578fcd9aa90a4add39eb3c7" name="a0550bcab7578fcd9aa90a4add39eb3c7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0550bcab7578fcd9aa90a4add39eb3c7">&#9670;&nbsp;</a></span>send_core()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Channel_obj , typename Message_body , typename Struct_builder_config , typename Struct_reader_config &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classipc_1_1transport_1_1struc_1_1sync__io_1_1Channel.html">ipc::transport::struc::sync_io::Channel</a>&lt; Channel_obj, Message_body, Struct_builder_config, Struct_reader_config &gt;::send_core </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classipc_1_1transport_1_1struc_1_1sync__io_1_1Channel.html#acbf3e5dbf6879e358f0596633e1428e0">Msg_mdt_out</a> &amp;&#160;</td>
          <td class="paramname"><em>mdt</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classipc_1_1transport_1_1struc_1_1sync__io_1_1Channel.html#a984b6afa0f437c72aca5a1ba97f33a7f">Msg_out_impl</a> *&#160;</td>
          <td class="paramname"><em>msg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceipc.html#aa3192e586cc45d3e7c22463bf2760f89">Error_code</a> *&#160;</td>
          <td class="paramname"><em>err_code_or_ignore</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Core of <a class="el" href="classipc_1_1transport_1_1struc_1_1sync__io_1_1Channel.html#a0dc388e18b0fc0fa2d8ad0a6953fb039" title="See Async_io_obj counterpart.">send()</a> or internal-message-send: Serializes the given structured out-messages (metadata out-message; user out-message optionally) and <code>Owned_channel::send*()</code>s the result (synchronously). </p>
<p >This is the last step of <a class="el" href="classipc_1_1transport_1_1struc_1_1sync__io_1_1Channel.html#a0dc388e18b0fc0fa2d8ad0a6953fb039" title="See Async_io_obj counterpart.">send()</a> and <a class="el" href="classipc_1_1transport_1_1struc_1_1sync__io_1_1Channel.html#a26dc83067e005be38567199cbedd7f19" title="See Async_io_obj counterpart; though naturally on_rsp_func() is invoked in the sync_io-pattern fashio...">async_request()</a> (for user out-messages) or an internal attempt to send internal out-message. As such (being the last step): If user message (<code>msg</code> not null), and <a class="el" href="classipc_1_1transport_1_1struc_1_1sync__io_1_1Channel.html#a0550bcab7578fcd9aa90a4add39eb3c7" title="Core of send() or internal-message-send: Serializes the given structured out-messages (metadata out-m...">send_core()</a> succeeds in <a class="el" href="classipc_1_1transport_1_1struc_1_1sync__io_1_1Channel.html#a5a3833cd141802041551db21198ac319ab64edfa66dd4c58d7aa1c3a30e142706" title="Logging-in phase, as server process: The general API (expect_msg(), etc.) is unavailable; only expect...">Phase::S_SRV_LOG_IN</a>, <a class="el" href="classipc_1_1transport_1_1struc_1_1sync__io_1_1Channel.html#afca9a3012b2f41d635381a5a13ddd7c1" title="Phase (w/r/t log-in or lack thereof) of *this peer.">m_phase</a> moves to <a class="el" href="classipc_1_1transport_1_1struc_1_1sync__io_1_1Channel.html#a5a3833cd141802041551db21198ac319aa0ea4326c39b88d0b32f90d5ce081220" title="Regular-operation phase: the general API (expect_msg(), etc.) is available.">Phase::S_LOGGED_IN</a> within this method.</p>
<p >As of this writing <code>msg</code> being null (internal message) means we are logged-in; behavior is undefined (assertion may trip) otherwise. Rationale: We aim to keep log-in phase very rigid. This detail could change in the future.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">mdt</td><td>Finalized metadata out-message (message about user message; or the internal message itself if it's not "about" anything) to serialize and send over <a class="el" href="classipc_1_1transport_1_1struc_1_1sync__io_1_1Channel.html#a4abac89dbd4d26c79b7915990f751a76" title="See Async_io_obj counterpart.">Owned_channel</a>. If internal message: <code>msg</code> shall be null, <code>mdt</code>-held ID shall be 0 and a filled-out <a class="el" href="classipc_1_1transport_1_1struc_1_1Msg__mdt__out.html#a1541fa2c6343cbcddf3feac9fcf67c46" title="Returns a builder for the internal-message root; to be called only if id_or_none == 0 in ctor.">Msg_mdt_out::internal_msg_body_root()</a>. Otherwise the opposite of all 3 shall hold. </td></tr>
    <tr><td class="paramname">msg</td><td>Pointer to user out-message (as from <a class="el" href="classipc_1_1transport_1_1struc_1_1sync__io_1_1Channel.html#a426ecae27b4ea5cf7e666e56bad6afe5" title="See Async_io_obj counterpart.">create_msg()</a> or direct <a class="el" href="classipc_1_1transport_1_1struc_1_1sync__io_1_1Channel.html#a83fb4462a8d4045bdb56b694bf80393c" title="See Async_io_obj counterpart.">Msg_out</a> ction); or null is this is an internal message send. </td></tr>
    <tr><td class="paramname">err_code_or_ignore</td><td>See <a class="el" href="classipc_1_1transport_1_1struc_1_1sync__io_1_1Channel.html#aafaf244b9483c724eaba1d6bee561035" title="send() and async_request() implementation.">send_impl()</a> (analogous meaning, even if <a class="el" href="classipc_1_1transport_1_1struc_1_1sync__io_1_1Channel.html#aafaf244b9483c724eaba1d6bee561035" title="send() and async_request() implementation.">send_impl()</a> is not calling <a class="el" href="classipc_1_1transport_1_1struc_1_1sync__io_1_1Channel.html#a0550bcab7578fcd9aa90a4add39eb3c7" title="Core of send() or internal-message-send: Serializes the given structured out-messages (metadata out-m...">send_core()</a> in this case). Or, additionally, leave it null to ignore errors as follows: <a class="el" href="classipc_1_1transport_1_1struc_1_1sync__io_1_1Channel.html#a95cfe30e685e828d62318c9b2bc4b137" title="Starts falsy; becomes forever truthy (with a specific Error_code that will not change thereafter) whe...">m_channel_err_code_or_ok</a> is not touched even on error; the idea being this is a best-effort internal message; and if it exposes error on an <a class="el" href="classipc_1_1transport_1_1struc_1_1sync__io_1_1Channel.html#abe17c6f98af890eaf522c97eb21e2e35" title="The Channel taken-over in ctor, lifetime until dtor.">m_channel</a> out-pipe, then the next user send will just see the same error and emit it that time. Otherwise an internal error could detect the problem &ndash; and our caller would not emit it. Thus it would get lost. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>See <a class="el" href="classipc_1_1transport_1_1struc_1_1sync__io_1_1Channel.html#aafaf244b9483c724eaba1d6bee561035" title="send() and async_request() implementation.">send_impl()</a> (analogous meaning, even if <a class="el" href="classipc_1_1transport_1_1struc_1_1sync__io_1_1Channel.html#aafaf244b9483c724eaba1d6bee561035" title="send() and async_request() implementation.">send_impl()</a> is not calling <a class="el" href="classipc_1_1transport_1_1struc_1_1sync__io_1_1Channel.html#a0550bcab7578fcd9aa90a4add39eb3c7" title="Core of send() or internal-message-send: Serializes the given structured out-messages (metadata out-m...">send_core()</a> in this case). As of this writing, at this stage, there is only one remaining reason this might return <code>false</code>: <code>Owned_channel::send*()</code> yielded <a class="el" href="namespaceipc_1_1transport_1_1error.html#adfef15ef4e76cc55d652fbd9c2797297a42d41c622e92e9053177ba73e75633fe" title="Will not send message: local user already ended sending via API marking this.">transport::error::Code::S_SENDS_FINISHED_CANNOT_SEND</a>. </dd></dl>

<p class="definition">Definition at line <a class="el" href="ipc__transport__structured_2src_2ipc_2transport_2struc_2sync__io_2channel_8hpp_source.html#l03920">3920</a> of file <a class="el" href="ipc__transport__structured_2src_2ipc_2transport_2struc_2sync__io_2channel_8hpp_source.html">channel.hpp</a>.</p>

<p class="reference">References <a class="el" href="msg_8hpp_source.html#l01017">ipc::transport::struc::Msg_out&lt; Message_body, Struct_builder_t &gt;::body_root()</a>, <a class="el" href="msg__mdt__out_8hpp_source.html#l00200">ipc::transport::struc::Msg_mdt_out&lt; Struct_builder_config &gt;::body_root()</a>, <a class="el" href="msg__mdt__out_8hpp_source.html#l00206">ipc::transport::struc::Msg_mdt_out&lt; Struct_builder_config &gt;::emit_serialization()</a>, <a class="el" href="msg__impl_8hpp_source.html#l00172">ipc::transport::struc::Msg_out_impl&lt; Message_body, Struct_builder &gt;::emit_serialization()</a>, <a class="el" href="msg__impl_8hpp_source.html#l00180">ipc::transport::struc::Msg_out_impl&lt; Message_body, Struct_builder &gt;::n_serialization_segments()</a>, <a class="el" href="msg_8hpp_source.html#l01052">ipc::transport::struc::Msg_out&lt; Message_body, Struct_builder_t &gt;::native_handle_or_null()</a>, and <a class="el" href="namespaceipc_1_1transport_1_1error.html#adfef15ef4e76cc55d652fbd9c2797297a42d41c622e92e9053177ba73e75633fe">ipc::transport::error::S_SENDS_FINISHED_CANNOT_SEND</a>.</p>
<div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="classipc_1_1transport_1_1struc_1_1sync__io_1_1Channel_a0550bcab7578fcd9aa90a4add39eb3c7_cgraph.svg" width="451" height="384"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe>
</div>
</div>

</div>
</div>
<a id="aafaf244b9483c724eaba1d6bee561035" name="aafaf244b9483c724eaba1d6bee561035"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aafaf244b9483c724eaba1d6bee561035">&#9670;&nbsp;</a></span>send_impl()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Channel_obj , typename Message_body , typename Struct_builder_config , typename Struct_reader_config &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classipc_1_1transport_1_1struc_1_1sync__io_1_1Channel.html">ipc::transport::struc::sync_io::Channel</a>&lt; Channel_obj, Message_body, Struct_builder_config, Struct_reader_config &gt;::send_impl </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classipc_1_1transport_1_1struc_1_1sync__io_1_1Channel.html#a83fb4462a8d4045bdb56b694bf80393c">Msg_out</a> &amp;&#160;</td>
          <td class="paramname"><em>msg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classipc_1_1transport_1_1struc_1_1sync__io_1_1Channel.html#ac3da0ac1306b63c9e38c47b8c31e3cd2">Msg_in</a> *&#160;</td>
          <td class="paramname"><em>originating_msg_or_null</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceipc.html#aa3192e586cc45d3e7c22463bf2760f89">Error_code</a> *&#160;</td>
          <td class="paramname"><em>err_code</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classipc_1_1transport_1_1struc_1_1sync__io_1_1Channel.html#a583ccd4bb6b1aefb09d77e5709aef5b4">On_msg_func_ptr</a> &amp;&#160;</td>
          <td class="paramname"><em>on_rsp_func_or_null</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classipc_1_1transport_1_1struc_1_1Channel__base.html#adcf24fa51747ed83c4b6427fbf44fecf">msg_id_out_t</a> *&#160;</td>
          <td class="paramname"><em>id_unless_one_off</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><a class="el" href="classipc_1_1transport_1_1struc_1_1sync__io_1_1Channel.html#a0dc388e18b0fc0fa2d8ad0a6953fb039" title="See Async_io_obj counterpart.">send()</a> and <a class="el" href="classipc_1_1transport_1_1struc_1_1sync__io_1_1Channel.html#a26dc83067e005be38567199cbedd7f19" title="See Async_io_obj counterpart; though naturally on_rsp_func() is invoked in the sync_io-pattern fashio...">async_request()</a> implementation. </p>
<p >Note this is still the higher-level, public <a class="el" href="classipc_1_1transport_1_1struc_1_1sync__io_1_1Channel.html#a0dc388e18b0fc0fa2d8ad0a6953fb039" title="See Async_io_obj counterpart.">send()</a> or <a class="el" href="classipc_1_1transport_1_1struc_1_1sync__io_1_1Channel.html#a26dc83067e005be38567199cbedd7f19" title="See Async_io_obj counterpart; though naturally on_rsp_func() is invoked in the sync_io-pattern fashio...">async_request()</a> really; it handles <em>user</em> messages; and once it has decided to indeed attempt the actual sending over <a class="el" href="classipc_1_1transport_1_1struc_1_1sync__io_1_1Channel.html#a4abac89dbd4d26c79b7915990f751a76" title="See Async_io_obj counterpart.">Owned_channel</a>, it synchronously invokes <a class="el" href="classipc_1_1transport_1_1struc_1_1sync__io_1_1Channel.html#a0550bcab7578fcd9aa90a4add39eb3c7" title="Core of send() or internal-message-send: Serializes the given structured out-messages (metadata out-m...">send_core()</a>. To send an internal message use <a class="el" href="classipc_1_1transport_1_1struc_1_1sync__io_1_1Channel.html#a0550bcab7578fcd9aa90a4add39eb3c7" title="Core of send() or internal-message-send: Serializes the given structured out-messages (metadata out-m...">send_core()</a> directly.</p>
<p ><code>check_unsendable(msg)</code> and <code><a class="el" href="classipc_1_1transport_1_1struc_1_1sync__io_1_1Channel.html#abeb37ac07422166123553920393d5ab4" title="Helper for some public APIs to use at the top: ensures that no prior error has been detected (by inco...">check_prior_error()</a></code> must have returned <code>false</code>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">msg</td><td>See <a class="el" href="classipc_1_1transport_1_1struc_1_1sync__io_1_1Channel.html#a0dc388e18b0fc0fa2d8ad0a6953fb039" title="See Async_io_obj counterpart.">send()</a> and sync_request(). </td></tr>
    <tr><td class="paramname">originating_msg_or_null</td><td>See <a class="el" href="classipc_1_1transport_1_1struc_1_1sync__io_1_1Channel.html#a0dc388e18b0fc0fa2d8ad0a6953fb039" title="See Async_io_obj counterpart.">send()</a> and sync_request(). </td></tr>
    <tr><td class="paramname">err_code</td><td>Non-null target <a class="el" href="namespaceipc.html#aa3192e586cc45d3e7c22463bf2760f89" title="Short-hand for boost.interprocess namespace.">Error_code</a>. </td></tr>
    <tr><td class="paramname">on_rsp_func_or_null</td><td>For <a class="el" href="classipc_1_1transport_1_1struc_1_1sync__io_1_1Channel.html#a26dc83067e005be38567199cbedd7f19" title="See Async_io_obj counterpart; though naturally on_rsp_func() is invoked in the sync_io-pattern fashio...">async_request()</a> non-null pointer to <code>on_rsp_func</code>; else null. </td></tr>
    <tr><td class="paramname">id_unless_one_off</td><td>Ignored if <code>on_rsp_func_or_null</code> is null: See <a class="el" href="classipc_1_1transport_1_1struc_1_1sync__io_1_1Channel.html#a26dc83067e005be38567199cbedd7f19" title="See Async_io_obj counterpart; though naturally on_rsp_func() is invoked in the sync_io-pattern fashio...">async_request()</a>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>See <a class="el" href="classipc_1_1transport_1_1struc_1_1sync__io_1_1Channel.html#a0dc388e18b0fc0fa2d8ad0a6953fb039" title="See Async_io_obj counterpart.">send()</a> and <a class="el" href="classipc_1_1transport_1_1struc_1_1sync__io_1_1Channel.html#a26dc83067e005be38567199cbedd7f19" title="See Async_io_obj counterpart; though naturally on_rsp_func() is invoked in the sync_io-pattern fashio...">async_request()</a>. </dd></dl>

<p class="definition">Definition at line <a class="el" href="ipc__transport__structured_2src_2ipc_2transport_2struc_2sync__io_2channel_8hpp_source.html#l03791">3791</a> of file <a class="el" href="ipc__transport__structured_2src_2ipc_2transport_2struc_2sync__io_2channel_8hpp_source.html">channel.hpp</a>.</p>

</div>
</div>
<a id="a021bb07a76c54837619c7a91dbd5de03" name="a021bb07a76c54837619c7a91dbd5de03"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a021bb07a76c54837619c7a91dbd5de03">&#9670;&nbsp;</a></span>session_token()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Channel_obj , typename Message_body , typename Struct_builder_config , typename Struct_reader_config &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="namespaceipc_1_1transport_1_1struc.html#a6751c05fb6582a34c7c47ac470c4a48b">Session_token</a> &amp; <a class="el" href="classipc_1_1transport_1_1struc_1_1sync__io_1_1Channel.html">ipc::transport::struc::sync_io::Channel</a>&lt; Channel_obj, Message_body, Struct_builder_config, Struct_reader_config &gt;::session_token</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>See <a class="el" href="classipc_1_1transport_1_1struc_1_1sync__io_1_1Channel.html#a6dc83bd6057b7f00a19c5947d6baa7b7" title="Useful for generic programming, the async-I/O-pattern counterpart to *this type.">Async_io_obj</a> counterpart. </p>
<dl class="section return"><dt>Returns</dt><dd>See above. </dd></dl>

<p class="definition">Definition at line <a class="el" href="ipc__transport__structured_2src_2ipc_2transport_2struc_2sync__io_2channel_8hpp_source.html#l04508">4508</a> of file <a class="el" href="ipc__transport__structured_2src_2ipc_2transport_2struc_2sync__io_2channel_8hpp_source.html">channel.hpp</a>.</p>

<p class="reference">References <a class="el" href="ipc__transport__structured_2src_2ipc_2transport_2struc_2channel_8cpp_source.html#l00035">ipc::transport::struc::NULL_SESSION_TOKEN</a>.</p>

</div>
</div>
<a id="a3fda370cc97c89a62f77a6fcf639cfd7" name="a3fda370cc97c89a62f77a6fcf639cfd7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3fda370cc97c89a62f77a6fcf639cfd7">&#9670;&nbsp;</a></span>set_remote_unexpected_response_handler()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Channel_obj , typename Message_body , typename Struct_builder_config , typename Struct_reader_config &gt; </div>
<div class="memtemplate">
template&lt;typename On_remote_unexpected_response_handler &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classipc_1_1transport_1_1struc_1_1sync__io_1_1Channel.html">ipc::transport::struc::sync_io::Channel</a>&lt; Channel_obj, Message_body, Struct_builder_config, Struct_reader_config &gt;::set_remote_unexpected_response_handler </td>
          <td>(</td>
          <td class="paramtype">On_remote_unexpected_response_handler &amp;&amp;&#160;</td>
          <td class="paramname"><em>on_func</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>See <a class="el" href="classipc_1_1transport_1_1struc_1_1sync__io_1_1Channel.html#a6dc83bd6057b7f00a19c5947d6baa7b7" title="Useful for generic programming, the async-I/O-pattern counterpart to *this type.">Async_io_obj</a> counterpart; though naturally <code>on_func()</code> is invoked in the <code><a class="el" href="namespaceipc_1_1transport_1_1struc_1_1sync__io.html" title="sync_io-pattern counterparts to async-I/O-pattern object types in parent namespace ipc::transport::st...">sync_io</a></code>-pattern fashion. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">On_remote_unexpected_response_handler</td><td>See above. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">on_func</td><td>See above. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>See above. </dd></dl>

<p class="definition">Definition at line <a class="el" href="ipc__transport__structured_2src_2ipc_2transport_2struc_2sync__io_2channel_8hpp_source.html#l04466">4466</a> of file <a class="el" href="ipc__transport__structured_2src_2ipc_2transport_2struc_2sync__io_2channel_8hpp_source.html">channel.hpp</a>.</p>

</div>
</div>
<a id="a5c62d2a374a3a98e7fa0aef01bf8a774" name="a5c62d2a374a3a98e7fa0aef01bf8a774"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5c62d2a374a3a98e7fa0aef01bf8a774">&#9670;&nbsp;</a></span>set_unexpected_response_handler()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Channel_obj , typename Message_body , typename Struct_builder_config , typename Struct_reader_config &gt; </div>
<div class="memtemplate">
template&lt;typename On_unexpected_response_handler &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classipc_1_1transport_1_1struc_1_1sync__io_1_1Channel.html">ipc::transport::struc::sync_io::Channel</a>&lt; Channel_obj, Message_body, Struct_builder_config, Struct_reader_config &gt;::set_unexpected_response_handler </td>
          <td>(</td>
          <td class="paramtype">On_unexpected_response_handler &amp;&amp;&#160;</td>
          <td class="paramname"><em>on_func</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>See <a class="el" href="classipc_1_1transport_1_1struc_1_1sync__io_1_1Channel.html#a6dc83bd6057b7f00a19c5947d6baa7b7" title="Useful for generic programming, the async-I/O-pattern counterpart to *this type.">Async_io_obj</a> counterpart; though naturally <code>on_func()</code> is invoked in the <code><a class="el" href="namespaceipc_1_1transport_1_1struc_1_1sync__io.html" title="sync_io-pattern counterparts to async-I/O-pattern object types in parent namespace ipc::transport::st...">sync_io</a></code>-pattern fashion. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">On_unexpected_response_handler</td><td>See above. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">on_func</td><td>See above. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>See above. </dd></dl>

<p class="definition">Definition at line <a class="el" href="ipc__transport__structured_2src_2ipc_2transport_2struc_2sync__io_2channel_8hpp_source.html#l04435">4435</a> of file <a class="el" href="ipc__transport__structured_2src_2ipc_2transport_2struc_2sync__io_2channel_8hpp_source.html">channel.hpp</a>.</p>

</div>
</div>
<a id="a0c00bab2dad604dde176c4190553915c" name="a0c00bab2dad604dde176c4190553915c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0c00bab2dad604dde176c4190553915c">&#9670;&nbsp;</a></span>start_and_poll()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Channel_obj , typename Message_body , typename Struct_builder_config , typename Struct_reader_config &gt; </div>
<div class="memtemplate">
template&lt;typename Task_err &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classipc_1_1transport_1_1struc_1_1sync__io_1_1Channel.html">ipc::transport::struc::sync_io::Channel</a>&lt; Channel_obj, Message_body, Struct_builder_config, Struct_reader_config &gt;::start_and_poll </td>
          <td>(</td>
          <td class="paramtype">Task_err &amp;&amp;&#160;</td>
          <td class="paramname"><em>on_err_func</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Permanently memorizes the incoming-direction on-error handler, thus authorizing the emission of any in-messages (and/or an error) to handlers registered via this call, <code>expect_*()</code>, <a class="el" href="classipc_1_1transport_1_1struc_1_1sync__io_1_1Channel.html#a26dc83067e005be38567199cbedd7f19" title="See Async_io_obj counterpart; though naturally on_rsp_func() is invoked in the sync_io-pattern fashio...">async_request()</a>, <code>set_*unexpected_response_handler()</code>; and <em>synchronously</em> executes any immediately relevant such handlers due to pending in-traffic. </p>
<p >To be clear: the caller must be ready for 0+ (potentially many) handlers to be synchronously invoked by this call. Even <code>on_err_func()</code> itself may be executed. That said, recursive-mayhem is unlikely to be a concern, since <a class="el" href="classipc_1_1transport_1_1struc_1_1sync__io_1_1Channel.html#a0c00bab2dad604dde176c4190553915c" title="Permanently memorizes the incoming-direction on-error handler, thus authorizing the emission of any i...">start_and_poll()</a> itself is a one-time operation for a given <code>*this</code>.</p>
<p >Until this is invoked, any incoming lower-level traffic is nevertheless saved in this process's or opposing process's user RAM to be emitted as required by, and after, <a class="el" href="classipc_1_1transport_1_1struc_1_1sync__io_1_1Channel.html#a0c00bab2dad604dde176c4190553915c" title="Permanently memorizes the incoming-direction on-error handler, thus authorizing the emission of any i...">start_and_poll()</a>. Therefore there is no need to worry about in-traffic disappearing without a trace due to <a class="el" href="classipc_1_1transport_1_1struc_1_1sync__io_1_1Channel.html#a0c00bab2dad604dde176c4190553915c" title="Permanently memorizes the incoming-direction on-error handler, thus authorizing the emission of any i...">start_and_poll()</a> being invoked too late.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Task_err</td><td>Handler type matching signature of <code>flow::async::Task_asio_err</code>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">on_err_func</td><td>The permanent on-channel-hosed error handler. See class doc header for discussion of error semantics. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> on success; <code>false</code> if <a class="el" href="classipc_1_1transport_1_1struc_1_1sync__io_1_1Channel.html#a6e4f8c4207fcf678b4cfc785707d3dce" title="Sets up the sync_io-pattern interaction between *this and the user&#39;s event loop; required before asyn...">start_ops()</a> not yet called, or if already <code><a class="el" href="classipc_1_1transport_1_1struc_1_1sync__io_1_1Channel.html#a0c00bab2dad604dde176c4190553915c" title="Permanently memorizes the incoming-direction on-error handler, thus authorizing the emission of any i...">start_and_poll()</a></code>ed, or if a prior error outgoing-direction error has hosed the owned <a class="el" href="classipc_1_1transport_1_1struc_1_1sync__io_1_1Channel.html" title="sync_io-pattern counterpart to async-I/O-pattern transport::struc::Channel.">Channel</a> (then no-op). </dd></dl>

<p class="definition">Definition at line <a class="el" href="ipc__transport__structured_2src_2ipc_2transport_2struc_2sync__io_2channel_8hpp_source.html#l02275">2275</a> of file <a class="el" href="ipc__transport__structured_2src_2ipc_2transport_2struc_2sync__io_2channel_8hpp_source.html">channel.hpp</a>.</p>

<p class="reference">References <a class="el" href="namespaceipc_1_1transport_1_1struc_1_1error.html#a990b9ff850cf9aaf354efdd07d86a71dade89b3f5038a04f02d8f4ae68698a069">ipc::transport::struc::error::S_INTERNAL_ERROR_DESERIALIZE_TARGET_ALLOC_FAILED</a>.</p>

</div>
</div>
<a id="a6e4f8c4207fcf678b4cfc785707d3dce" name="a6e4f8c4207fcf678b4cfc785707d3dce"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6e4f8c4207fcf678b4cfc785707d3dce">&#9670;&nbsp;</a></span>start_ops()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Channel_obj , typename Message_body , typename Struct_builder_config , typename Struct_reader_config &gt; </div>
<div class="memtemplate">
template&lt;typename Event_wait_func_t &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classipc_1_1transport_1_1struc_1_1sync__io_1_1Channel.html">ipc::transport::struc::sync_io::Channel</a>&lt; Channel_obj, Message_body, Struct_builder_config, Struct_reader_config &gt;::start_ops </td>
          <td>(</td>
          <td class="paramtype">Event_wait_func_t &amp;&amp;&#160;</td>
          <td class="paramname"><em>ev_wait_func</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sets up the <code><a class="el" href="namespaceipc_1_1transport_1_1struc_1_1sync__io.html" title="sync_io-pattern counterparts to async-I/O-pattern object types in parent namespace ipc::transport::st...">sync_io</a></code>-pattern interaction between <code>*this</code> and the user's event loop; required before async_accept() will work (as opposed to no-op/return <code>false</code>). </p>
<p ><code>ev_wait_func()</code> &ndash; with signature matching <a class="el" href="namespaceipc_1_1util_1_1sync__io.html#aa0b9a3cc6bdc7dedbef4f9e06851aa24" title="In sync_io pattern, concrete type storing user-supplied function invoked by pattern-implementing ipc:...">util::sync_io::Event_wait_func</a> &ndash; is a key function memorized by <code>*this</code>. It shall be invoked by <code>*this</code> operations when some op cannot complete synchronously and requires a certain event (readable/writable) to be active on a certain native-handle.</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="namespaceipc_1_1util_1_1sync__io.html#aa0b9a3cc6bdc7dedbef4f9e06851aa24" title="In sync_io pattern, concrete type storing user-supplied function invoked by pattern-implementing ipc:...">util::sync_io::Event_wait_func</a> doc header for useful and complete instructions on how to write an <code>ev_wait_func()</code> properly. Doing so correctly is the crux of using the <code><a class="el" href="namespaceipc_1_1transport_1_1struc_1_1sync__io.html" title="sync_io-pattern counterparts to async-I/O-pattern object types in parent namespace ipc::transport::st...">sync_io</a></code> pattern.</dd></dl>
<p>This is a standard <code><a class="el" href="namespaceipc_1_1transport_1_1struc_1_1sync__io.html" title="sync_io-pattern counterparts to async-I/O-pattern object types in parent namespace ipc::transport::st...">sync_io</a></code>-pattern API per <a class="el" href="namespaceipc_1_1util_1_1sync__io.html" title="Contains common code, as well as important explanatory documentation in the following text,...">util::sync_io</a> doc header.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Event_wait_func_t</td><td>Function type matching <a class="el" href="namespaceipc_1_1util_1_1sync__io.html#aa0b9a3cc6bdc7dedbef4f9e06851aa24" title="In sync_io pattern, concrete type storing user-supplied function invoked by pattern-implementing ipc:...">util::sync_io::Event_wait_func</a>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ev_wait_func</td><td>See above. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>false</code> if this has already been invoked; no-op logging aside. <code>true</code> otherwise. </dd></dl>

<p class="definition">Definition at line <a class="el" href="ipc__transport__structured_2src_2ipc_2transport_2struc_2sync__io_2channel_8hpp_source.html#l02150">2150</a> of file <a class="el" href="ipc__transport__structured_2src_2ipc_2transport_2struc_2sync__io_2channel_8hpp_source.html">channel.hpp</a>.</p>

<p class="reference">Referenced by <a class="el" href="ipc__transport__structured_2src_2ipc_2transport_2struc_2channel_8hpp_source.html#l01593">ipc::transport::struc::Channel&lt; Channel_obj, Message_body, Struct_builder_config, Struct_reader_config &gt;::Channel()</a>.</p>
<div class="dynheader">
Here is the caller graph for this function:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="classipc_1_1transport_1_1struc_1_1sync__io_1_1Channel_a6e4f8c4207fcf678b4cfc785707d3dce_icgraph.svg" width="371" height="47"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe>
</div>
</div>

</div>
</div>
<a id="a48a8fd167c1fe6ae95d8fc80b6a6e67f" name="a48a8fd167c1fe6ae95d8fc80b6a6e67f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a48a8fd167c1fe6ae95d8fc80b6a6e67f">&#9670;&nbsp;</a></span>struct_builder_config()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Channel_obj , typename Message_body , typename Struct_builder_config , typename Struct_reader_config &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classipc_1_1transport_1_1struc_1_1sync__io_1_1Channel.html">Channel</a>&lt; Channel_obj, Message_body, Struct_builder_config, Struct_reader_config &gt;<a class="el" href="classipc_1_1transport_1_1struc_1_1sync__io_1_1Channel.html#a8a59bbc3c6a7191b316b23661d8ba6e3">::Builder_config</a> &amp; <a class="el" href="classipc_1_1transport_1_1struc_1_1sync__io_1_1Channel.html">ipc::transport::struc::sync_io::Channel</a>&lt; Channel_obj, Message_body, Struct_builder_config, Struct_reader_config &gt;::struct_builder_config</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>See <a class="el" href="classipc_1_1transport_1_1struc_1_1sync__io_1_1Channel.html#a6dc83bd6057b7f00a19c5947d6baa7b7" title="Useful for generic programming, the async-I/O-pattern counterpart to *this type.">Async_io_obj</a> counterpart. </p>
<dl class="section return"><dt>Returns</dt><dd>See above. </dd></dl>

<p class="definition">Definition at line <a class="el" href="ipc__transport__structured_2src_2ipc_2transport_2struc_2sync__io_2channel_8hpp_source.html#l03699">3699</a> of file <a class="el" href="ipc__transport__structured_2src_2ipc_2transport_2struc_2sync__io_2channel_8hpp_source.html">channel.hpp</a>.</p>

</div>
</div>
<a id="a43fa0b77781376edd13b742b832572e1" name="a43fa0b77781376edd13b742b832572e1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a43fa0b77781376edd13b742b832572e1">&#9670;&nbsp;</a></span>struct_lender_session()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Channel_obj , typename Message_body , typename Struct_builder_config , typename Struct_reader_config &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classipc_1_1transport_1_1struc_1_1sync__io_1_1Channel.html">Channel</a>&lt; Channel_obj, Message_body, Struct_builder_config, Struct_reader_config &gt;::Builder_config::Builder::Session &amp; <a class="el" href="classipc_1_1transport_1_1struc_1_1sync__io_1_1Channel.html">ipc::transport::struc::sync_io::Channel</a>&lt; Channel_obj, Message_body, Struct_builder_config, Struct_reader_config &gt;::struct_lender_session</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>See <a class="el" href="classipc_1_1transport_1_1struc_1_1sync__io_1_1Channel.html#a6dc83bd6057b7f00a19c5947d6baa7b7" title="Useful for generic programming, the async-I/O-pattern counterpart to *this type.">Async_io_obj</a> counterpart. </p>
<dl class="section return"><dt>Returns</dt><dd>See above. </dd></dl>

<p class="definition">Definition at line <a class="el" href="ipc__transport__structured_2src_2ipc_2transport_2struc_2sync__io_2channel_8hpp_source.html#l03706">3706</a> of file <a class="el" href="ipc__transport__structured_2src_2ipc_2transport_2struc_2sync__io_2channel_8hpp_source.html">channel.hpp</a>.</p>

</div>
</div>
<a id="a7efbfbcce0d4d426b7df9b6d6fd1e373" name="a7efbfbcce0d4d426b7df9b6d6fd1e373"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7efbfbcce0d4d426b7df9b6d6fd1e373">&#9670;&nbsp;</a></span>struct_reader_config()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Channel_obj , typename Message_body , typename Struct_builder_config , typename Struct_reader_config &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classipc_1_1transport_1_1struc_1_1sync__io_1_1Channel.html">Channel</a>&lt; Channel_obj, Message_body, Struct_builder_config, Struct_reader_config &gt;<a class="el" href="classipc_1_1transport_1_1struc_1_1sync__io_1_1Channel.html#a14a7166b2f8c117ce6ddafe943d036fa">::Reader_config</a> &amp; <a class="el" href="classipc_1_1transport_1_1struc_1_1sync__io_1_1Channel.html">ipc::transport::struc::sync_io::Channel</a>&lt; Channel_obj, Message_body, Struct_builder_config, Struct_reader_config &gt;::struct_reader_config</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>See <a class="el" href="classipc_1_1transport_1_1struc_1_1sync__io_1_1Channel.html#a6dc83bd6057b7f00a19c5947d6baa7b7" title="Useful for generic programming, the async-I/O-pattern counterpart to *this type.">Async_io_obj</a> counterpart. </p>
<dl class="section return"><dt>Returns</dt><dd>See above. </dd></dl>

<p class="definition">Definition at line <a class="el" href="ipc__transport__structured_2src_2ipc_2transport_2struc_2sync__io_2channel_8hpp_source.html#l03713">3713</a> of file <a class="el" href="ipc__transport__structured_2src_2ipc_2transport_2struc_2sync__io_2channel_8hpp_source.html">channel.hpp</a>.</p>

</div>
</div>
<a id="ac8ba5f1a26a9f3e881b4871b0f6aa990" name="ac8ba5f1a26a9f3e881b4871b0f6aa990"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac8ba5f1a26a9f3e881b4871b0f6aa990">&#9670;&nbsp;</a></span>undo_expect_msgs()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Channel_obj , typename Message_body , typename Struct_builder_config , typename Struct_reader_config &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classipc_1_1transport_1_1struc_1_1sync__io_1_1Channel.html">ipc::transport::struc::sync_io::Channel</a>&lt; Channel_obj, Message_body, Struct_builder_config, Struct_reader_config &gt;::undo_expect_msgs </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classipc_1_1transport_1_1struc_1_1sync__io_1_1Channel.html#aa40c3ec3f45cdfea9360f7f35b9ade3c">Msg_which_in</a>&#160;</td>
          <td class="paramname"><em>which</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>See <a class="el" href="classipc_1_1transport_1_1struc_1_1sync__io_1_1Channel.html#a6dc83bd6057b7f00a19c5947d6baa7b7" title="Useful for generic programming, the async-I/O-pattern counterpart to *this type.">Async_io_obj</a> counterpart. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">which</td><td>See above. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>See above. </dd></dl>

<p class="definition">Definition at line <a class="el" href="ipc__transport__structured_2src_2ipc_2transport_2struc_2sync__io_2channel_8hpp_source.html#l04381">4381</a> of file <a class="el" href="ipc__transport__structured_2src_2ipc_2transport_2struc_2sync__io_2channel_8hpp_source.html">channel.hpp</a>.</p>

</div>
</div>
<a id="a5aae7a7f907f56fa07a230eadec2fedf" name="a5aae7a7f907f56fa07a230eadec2fedf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5aae7a7f907f56fa07a230eadec2fedf">&#9670;&nbsp;</a></span>undo_expect_responses()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Channel_obj , typename Message_body , typename Struct_builder_config , typename Struct_reader_config &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classipc_1_1transport_1_1struc_1_1sync__io_1_1Channel.html">ipc::transport::struc::sync_io::Channel</a>&lt; Channel_obj, Message_body, Struct_builder_config, Struct_reader_config &gt;::undo_expect_responses </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classipc_1_1transport_1_1struc_1_1Channel__base.html#adcf24fa51747ed83c4b6427fbf44fecf">msg_id_out_t</a>&#160;</td>
          <td class="paramname"><em>originating_msg_id</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>See <a class="el" href="classipc_1_1transport_1_1struc_1_1sync__io_1_1Channel.html#a6dc83bd6057b7f00a19c5947d6baa7b7" title="Useful for generic programming, the async-I/O-pattern counterpart to *this type.">Async_io_obj</a> counterpart. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">originating_msg_id</td><td>See above. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>See above. </dd></dl>

<p class="definition">Definition at line <a class="el" href="ipc__transport__structured_2src_2ipc_2transport_2struc_2sync__io_2channel_8hpp_source.html#l04406">4406</a> of file <a class="el" href="ipc__transport__structured_2src_2ipc_2transport_2struc_2sync__io_2channel_8hpp_source.html">channel.hpp</a>.</p>

</div>
</div>
<a id="a24382a751a2c03e00c5140c89aba2c62" name="a24382a751a2c03e00c5140c89aba2c62"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a24382a751a2c03e00c5140c89aba2c62">&#9670;&nbsp;</a></span>unset_remote_unexpected_response_handler()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Channel_obj , typename Message_body , typename Struct_builder_config , typename Struct_reader_config &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classipc_1_1transport_1_1struc_1_1sync__io_1_1Channel.html">ipc::transport::struc::sync_io::Channel</a>&lt; Channel_obj, Message_body, Struct_builder_config, Struct_reader_config &gt;::unset_remote_unexpected_response_handler</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>See <a class="el" href="classipc_1_1transport_1_1struc_1_1sync__io_1_1Channel.html#a6dc83bd6057b7f00a19c5947d6baa7b7" title="Useful for generic programming, the async-I/O-pattern counterpart to *this type.">Async_io_obj</a> counterpart. </p>
<dl class="section return"><dt>Returns</dt><dd>See above. </dd></dl>

<p class="definition">Definition at line <a class="el" href="ipc__transport__structured_2src_2ipc_2transport_2struc_2sync__io_2channel_8hpp_source.html#l04481">4481</a> of file <a class="el" href="ipc__transport__structured_2src_2ipc_2transport_2struc_2sync__io_2channel_8hpp_source.html">channel.hpp</a>.</p>

</div>
</div>
<a id="a1f226e506cc5c04584e11480426b19da" name="a1f226e506cc5c04584e11480426b19da"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1f226e506cc5c04584e11480426b19da">&#9670;&nbsp;</a></span>unset_unexpected_response_handler()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Channel_obj , typename Message_body , typename Struct_builder_config , typename Struct_reader_config &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classipc_1_1transport_1_1struc_1_1sync__io_1_1Channel.html">ipc::transport::struc::sync_io::Channel</a>&lt; Channel_obj, Message_body, Struct_builder_config, Struct_reader_config &gt;::unset_unexpected_response_handler</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>See <a class="el" href="classipc_1_1transport_1_1struc_1_1sync__io_1_1Channel.html#a6dc83bd6057b7f00a19c5947d6baa7b7" title="Useful for generic programming, the async-I/O-pattern counterpart to *this type.">Async_io_obj</a> counterpart. </p>
<dl class="section return"><dt>Returns</dt><dd>See above. </dd></dl>

<p class="definition">Definition at line <a class="el" href="ipc__transport__structured_2src_2ipc_2transport_2struc_2sync__io_2channel_8hpp_source.html#l04450">4450</a> of file <a class="el" href="ipc__transport__structured_2src_2ipc_2transport_2struc_2sync__io_2channel_8hpp_source.html">channel.hpp</a>.</p>

</div>
</div>
<h2 class="groupheader">Friends And Related Function Documentation</h2>
<a id="a0351bb14f40312b30e6cae4927f3373b" name="a0351bb14f40312b30e6cae4927f3373b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0351bb14f40312b30e6cae4927f3373b">&#9670;&nbsp;</a></span>operator&lt;&lt;()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Channel_obj , typename Message_body , typename Struct_builder_config , typename Struct_reader_config &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::ostream &amp; operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>os</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classipc_1_1transport_1_1struc_1_1sync__io_1_1Channel.html">Channel</a>&lt; Channel_obj, Message_body, Struct_builder_config, Struct_reader_config &gt; &amp;&#160;</td>
          <td class="paramname"><em>val</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Prints string representation of the given <a class="el" href="classipc_1_1transport_1_1struc_1_1sync__io_1_1Channel.html" title="sync_io-pattern counterpart to async-I/O-pattern transport::struc::Channel.">struc::sync_io::Channel</a> to the given <code>ostream</code>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">os</td><td>Stream to which to write. </td></tr>
    <tr><td class="paramname">val</td><td>Object to serialize. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>os</code>. </dd></dl>

</div>
</div>
<h2 class="groupheader">Member Data Documentation</h2>
<a id="abe17c6f98af890eaf522c97eb21e2e35" name="abe17c6f98af890eaf522c97eb21e2e35"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abe17c6f98af890eaf522c97eb21e2e35">&#9670;&nbsp;</a></span>m_channel</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Channel_obj , typename Message_body , typename Struct_builder_config , typename Struct_reader_config &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classipc_1_1transport_1_1struc_1_1sync__io_1_1Channel.html#a4abac89dbd4d26c79b7915990f751a76">Owned_channel</a> <a class="el" href="classipc_1_1transport_1_1struc_1_1sync__io_1_1Channel.html">ipc::transport::struc::sync_io::Channel</a>&lt; Channel_obj, Message_body, Struct_builder_config, Struct_reader_config &gt;::m_channel</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>The <a class="el" href="classipc_1_1transport_1_1struc_1_1sync__io_1_1Channel.html" title="sync_io-pattern counterpart to async-I/O-pattern transport::struc::Channel.">Channel</a> taken-over in ctor, lifetime until dtor. </p>
<dl class="section see"><dt>See also</dt><dd>also <a class="el" href="classipc_1_1transport_1_1struc_1_1sync__io_1_1Channel.html#a95cfe30e685e828d62318c9b2bc4b137" title="Starts falsy; becomes forever truthy (with a specific Error_code that will not change thereafter) whe...">m_channel_err_code_or_ok</a>. </dd></dl>

<p class="definition">Definition at line <a class="el" href="ipc__transport__structured_2src_2ipc_2transport_2struc_2sync__io_2channel_8hpp_source.html#l01868">1868</a> of file <a class="el" href="ipc__transport__structured_2src_2ipc_2transport_2struc_2sync__io_2channel_8hpp_source.html">channel.hpp</a>.</p>

</div>
</div>
<a id="a95cfe30e685e828d62318c9b2bc4b137" name="a95cfe30e685e828d62318c9b2bc4b137"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a95cfe30e685e828d62318c9b2bc4b137">&#9670;&nbsp;</a></span>m_channel_err_code_or_ok</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Channel_obj , typename Message_body , typename Struct_builder_config , typename Struct_reader_config &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespaceipc.html#aa3192e586cc45d3e7c22463bf2760f89">Error_code</a> <a class="el" href="classipc_1_1transport_1_1struc_1_1sync__io_1_1Channel.html">ipc::transport::struc::sync_io::Channel</a>&lt; Channel_obj, Message_body, Struct_builder_config, Struct_reader_config &gt;::m_channel_err_code_or_ok</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Starts falsy; becomes forever truthy (with a specific <a class="el" href="namespaceipc.html#aa3192e586cc45d3e7c22463bf2760f89" title="Short-hand for boost.interprocess namespace.">Error_code</a> that will not change thereafter) when one of the following detects the first channel-hosing condition: <a class="el" href="classipc_1_1transport_1_1struc_1_1sync__io_1_1Channel.html#a0dc388e18b0fc0fa2d8ad0a6953fb039" title="See Async_io_obj counterpart.">send()</a> or <a class="el" href="classipc_1_1transport_1_1struc_1_1sync__io_1_1Channel.html#a26dc83067e005be38567199cbedd7f19" title="See Async_io_obj counterpart; though naturally on_rsp_func() is invoked in the sync_io-pattern fashio...">async_request()</a>, on-receive handler <a class="el" href="classipc_1_1transport_1_1struc_1_1sync__io_1_1Channel.html#af546fc0ab4d0ddca0a857c57decd0620" title="To execute upon completing an m_channel.async_receive_*() of an expected lead message along the given...">rcv_on_async_read_lead_msg()</a> or <a class="el" href="classipc_1_1transport_1_1struc_1_1sync__io_1_1Channel.html#aa83fd6e35057876e2f5173df53e73371" title="Same as rcv_on_async_read_lead_msg() but for an expected continuation message instead of lead.">rcv_on_async_read_continuation_msg()</a>. </p>
<p >Once that becomes the case:</p><ul>
<li>Any <em>subsequent</em> on-receive handler (possibly none but at most one per ongoing async-read chain, of which there are 1-2) will immediately no-op and end async chain.</li>
<li>Any <em>subsequent</em> <a class="el" href="classipc_1_1transport_1_1struc_1_1sync__io_1_1Channel.html#a0dc388e18b0fc0fa2d8ad0a6953fb039" title="See Async_io_obj counterpart.">send()</a> or <a class="el" href="classipc_1_1transport_1_1struc_1_1sync__io_1_1Channel.html#a26dc83067e005be38567199cbedd7f19" title="See Async_io_obj counterpart; though naturally on_rsp_func() is invoked in the sync_io-pattern fashio...">async_request()</a> will immediately no-op and return <code>false</code>.</li>
<li>Any subsequent other mutable-state-touching API &ndash; e.g., <a class="el" href="classipc_1_1transport_1_1struc_1_1sync__io_1_1Channel.html#a021bb07a76c54837619c7a91dbd5de03" title="See Async_io_obj counterpart.">session_token()</a>, <a class="el" href="classipc_1_1transport_1_1struc_1_1sync__io_1_1Channel.html#a5fc489b9abefe5ab676f6991d6d03f0d" title="Registers the expectation (which may be immediately met) of up to 1 notification in-message whose Msg...">expect_msg()</a> &ndash; will immediately no-op and return <code>false</code>/null/sentinel value. Exception: <a class="el" href="classipc_1_1transport_1_1struc_1_1sync__io_1_1Channel.html#ae4a2a63dc88722d96ee9f3ed68cf7b86" title="See Async_io_obj counterpart; except (1) naturally on_done_func() is invoked in the sync_io-pattern f...">async_end_sending()</a> (see below). <a class="el" href="classipc_1_1transport_1_1struc_1_1sync__io_1_1Channel.html#a426ecae27b4ea5cf7e666e56bad6afe5" title="See Async_io_obj counterpart.">create_msg()</a> is a convenience thing that does not touch mutable state, so it won't care either.</li>
</ul>
<dl class="section note"><dt>Note</dt><dd><a class="el" href="classipc_1_1transport_1_1struc_1_1sync__io_1_1Channel.html#ae4a2a63dc88722d96ee9f3ed68cf7b86" title="See Async_io_obj counterpart; except (1) naturally on_done_func() is invoked in the sync_io-pattern f...">async_end_sending()</a> is orthogonal to this. It is a Channel-level call that (per its doc header) simply forwards to <a class="el" href="classipc_1_1transport_1_1struc_1_1sync__io_1_1Channel.html#ae4a2a63dc88722d96ee9f3ed68cf7b86" title="See Async_io_obj counterpart; except (1) naturally on_done_func() is invoked in the sync_io-pattern f...">Channel::async_end_sending()</a>, no questions asked. The <code>F()</code> passed to <a class="el" href="classipc_1_1transport_1_1struc_1_1sync__io_1_1Channel.html#ae4a2a63dc88722d96ee9f3ed68cf7b86" title="See Async_io_obj counterpart; except (1) naturally on_done_func() is invoked in the sync_io-pattern f...">async_end_sending()</a> may well trigger synchronous emission of <code>E</code>, with <code>E == m_channel_err_code_or_ok</code>; or not; but nothing should or does count on this. </dd></dl>

<p class="definition">Definition at line <a class="el" href="ipc__transport__structured_2src_2ipc_2transport_2struc_2sync__io_2channel_8hpp_source.html#l01768">1768</a> of file <a class="el" href="ipc__transport__structured_2src_2ipc_2transport_2struc_2sync__io_2channel_8hpp_source.html">channel.hpp</a>.</p>

</div>
</div>
<a id="ad1fcc872d76e6a59321f5d67b2e0a70b" name="ad1fcc872d76e6a59321f5d67b2e0a70b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad1fcc872d76e6a59321f5d67b2e0a70b">&#9670;&nbsp;</a></span>m_on_err_func</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Channel_obj , typename Message_body , typename Struct_builder_config , typename Struct_reader_config &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">flow::async::Task_asio_err <a class="el" href="classipc_1_1transport_1_1struc_1_1sync__io_1_1Channel.html">ipc::transport::struc::sync_io::Channel</a>&lt; Channel_obj, Message_body, Struct_builder_config, Struct_reader_config &gt;::m_on_err_func</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>The channel-hosed error reporting handler. </p>
<p >See <a class="el" href="classipc_1_1transport_1_1struc_1_1sync__io_1_1Channel.html#a0c00bab2dad604dde176c4190553915c" title="Permanently memorizes the incoming-direction on-error handler, thus authorizing the emission of any i...">start_and_poll()</a> + class doc header for discussion of error semantics. </p>

<p class="definition">Definition at line <a class="el" href="ipc__transport__structured_2src_2ipc_2transport_2struc_2sync__io_2channel_8hpp_source.html#l01684">1684</a> of file <a class="el" href="ipc__transport__structured_2src_2ipc_2transport_2struc_2sync__io_2channel_8hpp_source.html">channel.hpp</a>.</p>

</div>
</div>
<a id="a491a1a9eff4e277f3e5cd32c0178adbf" name="a491a1a9eff4e277f3e5cd32c0178adbf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a491a1a9eff4e277f3e5cd32c0178adbf">&#9670;&nbsp;</a></span>m_on_remote_unexpected_response_func_or_empty</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Channel_obj , typename Message_body , typename Struct_builder_config , typename Struct_reader_config &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classipc_1_1transport_1_1struc_1_1sync__io_1_1Channel.html#a86342fa9838aea7d49bbf3dd344445e2">On_remote_unexpected_response_func</a> <a class="el" href="classipc_1_1transport_1_1struc_1_1sync__io_1_1Channel.html">ipc::transport::struc::sync_io::Channel</a>&lt; Channel_obj, Message_body, Struct_builder_config, Struct_reader_config &gt;::m_on_remote_unexpected_response_func_or_empty</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>See <a class="el" href="classipc_1_1transport_1_1struc_1_1sync__io_1_1Channel.html#a3fda370cc97c89a62f77a6fcf639cfd7" title="See Async_io_obj counterpart; though naturally on_func() is invoked in the sync_io-pattern fashion.">set_remote_unexpected_response_handler()</a>. </p>

<p class="definition">Definition at line <a class="el" href="ipc__transport__structured_2src_2ipc_2transport_2struc_2sync__io_2channel_8hpp_source.html#l01698">1698</a> of file <a class="el" href="ipc__transport__structured_2src_2ipc_2transport_2struc_2sync__io_2channel_8hpp_source.html">channel.hpp</a>.</p>

</div>
</div>
<a id="a0986d9820ae3a1203014d94c193b4ca4" name="a0986d9820ae3a1203014d94c193b4ca4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0986d9820ae3a1203014d94c193b4ca4">&#9670;&nbsp;</a></span>m_on_unexpected_response_func_or_empty</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Channel_obj , typename Message_body , typename Struct_builder_config , typename Struct_reader_config &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classipc_1_1transport_1_1struc_1_1sync__io_1_1Channel.html#abb3be9330a898ce542afd778d8e42a49">On_unexpected_response_func</a> <a class="el" href="classipc_1_1transport_1_1struc_1_1sync__io_1_1Channel.html">ipc::transport::struc::sync_io::Channel</a>&lt; Channel_obj, Message_body, Struct_builder_config, Struct_reader_config &gt;::m_on_unexpected_response_func_or_empty</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>See <a class="el" href="classipc_1_1transport_1_1struc_1_1sync__io_1_1Channel.html#a5c62d2a374a3a98e7fa0aef01bf8a774" title="See Async_io_obj counterpart; though naturally on_func() is invoked in the sync_io-pattern fashion.">set_unexpected_response_handler()</a>. </p>

<p class="definition">Definition at line <a class="el" href="ipc__transport__structured_2src_2ipc_2transport_2struc_2sync__io_2channel_8hpp_source.html#l01695">1695</a> of file <a class="el" href="ipc__transport__structured_2src_2ipc_2transport_2struc_2sync__io_2channel_8hpp_source.html">channel.hpp</a>.</p>

</div>
</div>
<a id="afca9a3012b2f41d635381a5a13ddd7c1" name="afca9a3012b2f41d635381a5a13ddd7c1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afca9a3012b2f41d635381a5a13ddd7c1">&#9670;&nbsp;</a></span>m_phase</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Channel_obj , typename Message_body , typename Struct_builder_config , typename Struct_reader_config &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classipc_1_1transport_1_1struc_1_1sync__io_1_1Channel.html#a5a3833cd141802041551db21198ac319">Phase</a> <a class="el" href="classipc_1_1transport_1_1struc_1_1sync__io_1_1Channel.html">ipc::transport::struc::sync_io::Channel</a>&lt; Channel_obj, Message_body, Struct_builder_config, Struct_reader_config &gt;::m_phase</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Phase (w/r/t log-in or lack thereof) of <code>*this</code> peer. </p>
<p >It is either <a class="el" href="classipc_1_1transport_1_1struc_1_1sync__io_1_1Channel.html#a5a3833cd141802041551db21198ac319aa0ea4326c39b88d0b32f90d5ce081220" title="Regular-operation phase: the general API (expect_msg(), etc.) is available.">Phase::S_LOGGED_IN</a> throughout; or starts as one of the other 2 values, then is assigned LOGGED_IN and unmodified further.</p>
<p >If not LOGGED_IN from the start (see ctors) then it is written exactly once:</p><ul>
<li><a class="el" href="classipc_1_1transport_1_1struc_1_1sync__io_1_1Channel.html#a5a3833cd141802041551db21198ac319ab64edfa66dd4c58d7aa1c3a30e142706" title="Logging-in phase, as server process: The general API (expect_msg(), etc.) is unavailable; only expect...">Phase::S_SRV_LOG_IN</a> =&gt; <a class="el" href="classipc_1_1transport_1_1struc_1_1sync__io_1_1Channel.html#a5a3833cd141802041551db21198ac319aa0ea4326c39b88d0b32f90d5ce081220" title="Regular-operation phase: the general API (expect_msg(), etc.) is available.">Phase::S_LOGGED_IN</a> (see ctors): When <a class="el" href="classipc_1_1transport_1_1struc_1_1sync__io_1_1Channel.html#a0dc388e18b0fc0fa2d8ad0a6953fb039" title="See Async_io_obj counterpart.">send()</a> of the log-in response is invoked.</li>
<li><a class="el" href="classipc_1_1transport_1_1struc_1_1sync__io_1_1Channel.html#a5a3833cd141802041551db21198ac319aa0cb6b19ec0b17da2c3ed65de71ca437" title="Logging-in phase, as client process: The general API (expect_msg(), etc.) is unavailable; only create...">Phase::S_CLI_LOG_IN</a> =&gt; <a class="el" href="classipc_1_1transport_1_1struc_1_1sync__io_1_1Channel.html#a5a3833cd141802041551db21198ac319aa0ea4326c39b88d0b32f90d5ce081220" title="Regular-operation phase: the general API (expect_msg(), etc.) is available.">Phase::S_LOGGED_IN</a> (see ctors): When response to the <a class="el" href="classipc_1_1transport_1_1struc_1_1sync__io_1_1Channel.html#a26dc83067e005be38567199cbedd7f19" title="See Async_io_obj counterpart; though naturally on_rsp_func() is invoked in the sync_io-pattern fashio...">async_request()</a> of the log-in request is received.</li>
</ul>
<p >It is generally checked at the start of all or most APIs (<a class="el" href="classipc_1_1transport_1_1struc_1_1sync__io_1_1Channel.html#ae6b2691d6471330d8b7cc7e8e9320054" title="Helper for most public APIs to use at the top: ensures check_prior_error() passes,...">check_phase_and_prior_error()</a>). In particular many APIs, such as <a class="el" href="classipc_1_1transport_1_1struc_1_1sync__io_1_1Channel.html#a5fc489b9abefe5ab676f6991d6d03f0d" title="Registers the expectation (which may be immediately met) of up to 1 notification in-message whose Msg...">expect_msg()</a>, no-op and return sentinel unless LOGGED_IN; ~one (<a class="el" href="classipc_1_1transport_1_1struc_1_1sync__io_1_1Channel.html#a996e06f75024e10987eb9cf62e096eec" title="In log-in phase as server only: Registers the expectation (which may be immediately met) of up to 1 l...">expect_log_in_request()</a>) does the same unless in a proper <code>*_LOG_IN</code> phase. If the user is acting sanely, they would invoke the log-in APIs before entry to LOGGED_IN and vice versa for the logged-in APIs; namely:</p><ul>
<li>SRV_LOG_IN -&gt; LOGGED_IN: After <a class="el" href="classipc_1_1transport_1_1struc_1_1sync__io_1_1Channel.html#a0dc388e18b0fc0fa2d8ad0a6953fb039" title="See Async_io_obj counterpart.">send()</a> of the log-in response, which itself would be only after the handler passed to <a class="el" href="classipc_1_1transport_1_1struc_1_1sync__io_1_1Channel.html#a996e06f75024e10987eb9cf62e096eec" title="In log-in phase as server only: Registers the expectation (which may be immediately met) of up to 1 l...">expect_log_in_request()</a> fires.</li>
<li>CLI_LOG_IN -&gt; LOGGED_IN: After the handler, passed to <a class="el" href="classipc_1_1transport_1_1struc_1_1sync__io_1_1Channel.html#a26dc83067e005be38567199cbedd7f19" title="See Async_io_obj counterpart; though naturally on_rsp_func() is invoked in the sync_io-pattern fashio...">async_request()</a> along with log-in request out-message, fires indicating receiving the expected log-in response.</li>
</ul>
<p >If the user disregards these best practices and invokes a logged-in API before those points, then they're engaging in a race. Worst-case, they'll get an unexpected sentinel return of something like <a class="el" href="classipc_1_1transport_1_1struc_1_1sync__io_1_1Channel.html#a5fc489b9abefe5ab676f6991d6d03f0d" title="Registers the expectation (which may be immediately met) of up to 1 notification in-message whose Msg...">expect_msg()</a> &ndash; their own fault. </p>

<p class="definition">Definition at line <a class="el" href="ipc__transport__structured_2src_2ipc_2transport_2struc_2sync__io_2channel_8hpp_source.html#l01743">1743</a> of file <a class="el" href="ipc__transport__structured_2src_2ipc_2transport_2struc_2sync__io_2channel_8hpp_source.html">channel.hpp</a>.</p>

</div>
</div>
<a id="aa14373afb4601567d1640f7b0b3faa45" name="aa14373afb4601567d1640f7b0b3faa45"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa14373afb4601567d1640f7b0b3faa45">&#9670;&nbsp;</a></span>m_phase_log_in_started</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Channel_obj , typename Message_body , typename Struct_builder_config , typename Struct_reader_config &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classipc_1_1transport_1_1struc_1_1sync__io_1_1Channel.html">ipc::transport::struc::sync_io::Channel</a>&lt; Channel_obj, Message_body, Struct_builder_config, Struct_reader_config &gt;::m_phase_log_in_started</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Used when <a class="el" href="classipc_1_1transport_1_1struc_1_1sync__io_1_1Channel.html#afca9a3012b2f41d635381a5a13ddd7c1" title="Phase (w/r/t log-in or lack thereof) of *this peer.">m_phase</a> is <a class="el" href="classipc_1_1transport_1_1struc_1_1sync__io_1_1Channel.html#a5a3833cd141802041551db21198ac319ab64edfa66dd4c58d7aa1c3a30e142706" title="Logging-in phase, as server process: The general API (expect_msg(), etc.) is unavailable; only expect...">Phase::S_SRV_LOG_IN</a>, this starts <code>false</code> and is changed to <code>true</code> at thread-U call of <a class="el" href="classipc_1_1transport_1_1struc_1_1sync__io_1_1Channel.html#a996e06f75024e10987eb9cf62e096eec" title="In log-in phase as server only: Registers the expectation (which may be immediately met) of up to 1 l...">expect_log_in_request()</a>; if already <code>true</code> then a 2nd (illegal) <a class="el" href="classipc_1_1transport_1_1struc_1_1sync__io_1_1Channel.html#a996e06f75024e10987eb9cf62e096eec" title="In log-in phase as server only: Registers the expectation (which may be immediately met) of up to 1 l...">expect_log_in_request()</a> call has been made and shall be ignored (no-op, return sentinel). </p>

<p class="definition">Definition at line <a class="el" href="ipc__transport__structured_2src_2ipc_2transport_2struc_2sync__io_2channel_8hpp_source.html#l01750">1750</a> of file <a class="el" href="ipc__transport__structured_2src_2ipc_2transport_2struc_2sync__io_2channel_8hpp_source.html">channel.hpp</a>.</p>

</div>
</div>
<a id="a072fb8667ba55ff69230fd48d400ee88" name="a072fb8667ba55ff69230fd48d400ee88"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a072fb8667ba55ff69230fd48d400ee88">&#9670;&nbsp;</a></span>m_rcv_expecting_msg_map</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Channel_obj , typename Message_body , typename Struct_builder_config , typename Struct_reader_config &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classipc_1_1transport_1_1struc_1_1sync__io_1_1Channel.html#a8d1ffe78546eb31fd41df6784a26868c">Expecting_msg_map</a> <a class="el" href="classipc_1_1transport_1_1struc_1_1sync__io_1_1Channel.html">ipc::transport::struc::sync_io::Channel</a>&lt; Channel_obj, Message_body, Struct_builder_config, Struct_reader_config &gt;::m_rcv_expecting_msg_map</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Map storing current policy for expecting non-response messages. </p>
<p >See <a class="el" href="classipc_1_1transport_1_1struc_1_1sync__io_1_1Channel.html#a8d1ffe78546eb31fd41df6784a26868c" title="Table mapping in-message Msg_which_in enum value to the policy for handling an in-message with that w...">Expecting_msg_map</a> and <a class="el" href="classipc_1_1transport_1_1struc_1_1sync__io_1_1Channel.html#adccd6372c0284a7f3198ac00c0935002" title="Policy for how to act upon receiving an in-message whose top-level-union Msg_which_in enum equals the...">Expecting_msg</a> doc headers for details. </p>

<p class="definition">Definition at line <a class="el" href="ipc__transport__structured_2src_2ipc_2transport_2struc_2sync__io_2channel_8hpp_source.html#l01777">1777</a> of file <a class="el" href="ipc__transport__structured_2src_2ipc_2transport_2struc_2sync__io_2channel_8hpp_source.html">channel.hpp</a>.</p>

</div>
</div>
<a id="abf9a2118d887439717e17d0515be3e43" name="abf9a2118d887439717e17d0515be3e43"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abf9a2118d887439717e17d0515be3e43">&#9670;&nbsp;</a></span>m_rcv_expecting_response_map</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Channel_obj , typename Message_body , typename Struct_builder_config , typename Struct_reader_config &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classipc_1_1transport_1_1struc_1_1sync__io_1_1Channel.html#a3d4c8da3dd620d113479f5c6a3f96c3a">Expecting_response_map</a> <a class="el" href="classipc_1_1transport_1_1struc_1_1sync__io_1_1Channel.html">ipc::transport::struc::sync_io::Channel</a>&lt; Channel_obj, Message_body, Struct_builder_config, Struct_reader_config &gt;::m_rcv_expecting_response_map</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Map storing current policy for expecting responses. See <a class="el" href="classipc_1_1transport_1_1struc_1_1sync__io_1_1Channel.html#a3d4c8da3dd620d113479f5c6a3f96c3a" title="Table mapping originating out-message to the policy for handling an in-message that indicates that ou...">Expecting_response_map</a> doc header for details. </p>

<p class="definition">Definition at line <a class="el" href="ipc__transport__structured_2src_2ipc_2transport_2struc_2sync__io_2channel_8hpp_source.html#l01771">1771</a> of file <a class="el" href="ipc__transport__structured_2src_2ipc_2transport_2struc_2sync__io_2channel_8hpp_source.html">channel.hpp</a>.</p>

</div>
</div>
<a id="a26d39d4e1e2c304ef803b3721bde86f0" name="a26d39d4e1e2c304ef803b3721bde86f0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a26d39d4e1e2c304ef803b3721bde86f0">&#9670;&nbsp;</a></span>m_rcv_msg_next_id</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Channel_obj , typename Message_body , typename Struct_builder_config , typename Struct_reader_config &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classipc_1_1transport_1_1struc_1_1sync__io_1_1Channel.html#ad77261f31055f4151c70225c3fa1da2e">msg_id_in_t</a> <a class="el" href="classipc_1_1transport_1_1struc_1_1sync__io_1_1Channel.html">ipc::transport::struc::sync_io::Channel</a>&lt; Channel_obj, Message_body, Struct_builder_config, Struct_reader_config &gt;::m_rcv_msg_next_id</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Next expected in-message ID (sequence #), incremented from initial value 1 to 2, 3, ... on in-order message receipt. </p>
<p >It is used purely for sanity checking of the opposing sender's payloads, when <a class="el" href="classipc_1_1transport_1_1struc_1_1sync__io_1_1Channel.html#a4abac89dbd4d26c79b7915990f751a76" title="See Async_io_obj counterpart.">Owned_channel</a> stores only 1 pipe (<a class="el" href="classipc_1_1transport_1_1Channel.html#a85184d886cee9b4a0d0e7b67796a238b" title="Useful for generic programming: true if and only if types imply both blobs and handles pipes are enab...">Channel::S_HAS_2_PIPES</a> is <code>false</code>). Or: it is used with <a class="el" href="classipc_1_1transport_1_1struc_1_1sync__io_1_1Channel.html#a1218e59c91d08758cd997d77913abd5a" title="When Owned_channel::S_HAS_2_PIPES, stores the reassembly queue of in-messages to feed into m_rcv_pend...">m_rcv_reassembly_q</a> if <a class="el" href="classipc_1_1transport_1_1struc_1_1sync__io_1_1Channel.html#a4abac89dbd4d26c79b7915990f751a76" title="See Async_io_obj counterpart.">Owned_channel</a> stores 2 pipes (<a class="el" href="classipc_1_1transport_1_1Channel.html#a85184d886cee9b4a0d0e7b67796a238b" title="Useful for generic programming: true if and only if types imply both blobs and handles pipes are enab...">Channel::S_HAS_2_PIPES</a> is <code>true</code>).</p>
<h3>Algorithm summary: 2 in-pipes</h3>
<p >In that latter case a handle-less in-message may arrive along the blobs in-pipe; while a handle-paired message may arrive along the handles in-pipe; and since the two might race, the one sent 1st might arrive 2nd, and vice versa. Then the out-of-order one would be stored temporarily in <a class="el" href="classipc_1_1transport_1_1struc_1_1sync__io_1_1Channel.html#a1218e59c91d08758cd997d77913abd5a" title="When Owned_channel::S_HAS_2_PIPES, stores the reassembly queue of in-messages to feed into m_rcv_pend...">m_rcv_reassembly_q</a>. (In theory this could occur for several in-messages.) This is detected by noting that an in-message's message ID (sequence number) exceeds <a class="el" href="classipc_1_1transport_1_1struc_1_1sync__io_1_1Channel.html#a26d39d4e1e2c304ef803b3721bde86f0" title="Next expected in-message ID (sequence #), incremented from initial value 1 to 2, 3,...">m_rcv_msg_next_id</a>. If it equals it, then it is in-order and skips <a class="el" href="classipc_1_1transport_1_1struc_1_1sync__io_1_1Channel.html#a1218e59c91d08758cd997d77913abd5a" title="When Owned_channel::S_HAS_2_PIPES, stores the reassembly queue of in-messages to feed into m_rcv_pend...">m_rcv_reassembly_q</a>. If it is lower, then that is misbehavior by the opposing peer and hoses the pipe.</p>
<p >Technically we could be more stringent in our sanity checking: while races may occur between the 2 in-pipes, for a <em>given</em> 1 of 2 pipes (the blobs pipe; the handles pipe), the message IDs must always be increasing, as these are reliable, in-order pipes. However we choose to not worry about this enforcement; in-order behavior of our various transports shall (possibly) be checked elsewhere and is a hard assumption. On the other hand it is cheap to check for non-repeating (always increasing) message IDs along the totality of the pipes, so we do.</p>
<h3>Algorithm summary: 1 in-pipe</h3>
<p >Each message received must contain ID, in fact, equal <a class="el" href="classipc_1_1transport_1_1struc_1_1sync__io_1_1Channel.html#a26d39d4e1e2c304ef803b3721bde86f0" title="Next expected in-message ID (sequence #), incremented from initial value 1 to 2, 3,...">m_rcv_msg_next_id</a> which is then incremented. There is no reassembly, as there is only 1 in-pipe, and it must be in-order. This is (as noted just above) easy to sanity-check. </p>

<p class="definition">Definition at line <a class="el" href="ipc__transport__structured_2src_2ipc_2transport_2struc_2sync__io_2channel_8hpp_source.html#l01806">1806</a> of file <a class="el" href="ipc__transport__structured_2src_2ipc_2transport_2struc_2sync__io_2channel_8hpp_source.html">channel.hpp</a>.</p>

</div>
</div>
<a id="ae9f5a798718d98523342acf55400d628" name="ae9f5a798718d98523342acf55400d628"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae9f5a798718d98523342acf55400d628">&#9670;&nbsp;</a></span>m_rcv_pending_msgs</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Channel_obj , typename Message_body , typename Struct_builder_config , typename Struct_reader_config &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">boost::unordered_map&lt;<a class="el" href="classipc_1_1transport_1_1struc_1_1sync__io_1_1Channel.html#aa40c3ec3f45cdfea9360f7f35b9ade3c">Msg_which_in</a>, <a class="el" href="classipc_1_1transport_1_1struc_1_1sync__io_1_1Channel.html#a2eed5db328a8c45ab16a875617a172c7">Msg_in_q</a>&gt; <a class="el" href="classipc_1_1transport_1_1struc_1_1sync__io_1_1Channel.html">ipc::transport::struc::sync_io::Channel</a>&lt; Channel_obj, Message_body, Struct_builder_config, Struct_reader_config &gt;::m_rcv_pending_msgs</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Queues of in-messages, keyed by <a class="el" href="classipc_1_1transport_1_1struc_1_1sync__io_1_1Channel.html#aa40c3ec3f45cdfea9360f7f35b9ade3c" title="See Async_io_obj counterpart.">Msg_which_in</a>, each in <a class="el" href="classipc_1_1transport_1_1struc_1_1sync__io_1_1Channel.html#ad77261f31055f4151c70225c3fa1da2e" title="Clarifying short-hand for incoming-message IDs.">msg_id_in_t</a> (sequence #) order, for which no <a class="el" href="classipc_1_1transport_1_1struc_1_1sync__io_1_1Channel.html#aa40c3ec3f45cdfea9360f7f35b9ade3c" title="See Async_io_obj counterpart.">Msg_which_in</a> handler has yet been registered by the user (<a class="el" href="classipc_1_1transport_1_1struc_1_1sync__io_1_1Channel.html#a5fc489b9abefe5ab676f6991d6d03f0d" title="Registers the expectation (which may be immediately met) of up to 1 notification in-message whose Msg...">expect_msg()</a>, <a class="el" href="classipc_1_1transport_1_1struc_1_1sync__io_1_1Channel.html#a62f52488ba20dd6c69dfc1abadb2d69f" title="Registers the expectation (some of which may be immediately met) of 0+ notification in-messages whose...">expect_msgs()</a>, <a class="el" href="classipc_1_1transport_1_1struc_1_1sync__io_1_1Channel.html#a996e06f75024e10987eb9cf62e096eec" title="In log-in phase as server only: Registers the expectation (which may be immediately met) of up to 1 l...">expect_log_in_request()</a>). </p>
<p >They'll stay there until such a thing is indeed registered; once it is, that queue's elements are fed, in order, to that handler, and the element is removed from <a class="el" href="classipc_1_1transport_1_1struc_1_1sync__io_1_1Channel.html#ae9f5a798718d98523342acf55400d628" title="Queues of in-messages, keyed by Msg_which_in, each in msg_id_in_t (sequence #) order,...">m_rcv_pending_msgs</a>.</p>
<h3>Corner case: a response arrives to an originating out-message for which no response is expected</h3>
<p >It is relatively normal, if ideally avoided (informally speaking), that there is no <a class="el" href="classipc_1_1transport_1_1struc_1_1sync__io_1_1Channel.html#aa40c3ec3f45cdfea9360f7f35b9ade3c" title="See Async_io_obj counterpart.">Msg_which_in</a> listener yet registered for a given in-message. (One can be registered later: then such messages will be flushed to that handler.) By contrast: It is a <em>user protocol</em> error that a response arrives unexpectedly. Let's break down the realistic possibilities for how that might happen:</p><ul>
<li>A response arrives to message M, but the local user never issued a request for that message as triggered by <a class="el" href="classipc_1_1transport_1_1struc_1_1sync__io_1_1Channel.html#a26dc83067e005be38567199cbedd7f19" title="See Async_io_obj counterpart; though naturally on_rsp_func() is invoked in the sync_io-pattern fashio...">async_request()</a>. The opposing user must have erroneously issued a response to a non-request.</li>
<li>A response arrives to message M, and the local user <em>did</em> issue an <a class="el" href="classipc_1_1transport_1_1struc_1_1sync__io_1_1Channel.html#a26dc83067e005be38567199cbedd7f19" title="See Async_io_obj counterpart; though naturally on_rsp_func() is invoked in the sync_io-pattern fashio...">async_request()</a> for that message; but either it was a one-off request &ndash; and this is the 2nd/3rd/... response &ndash; or it was an open-ended request, but the local user called <a class="el" href="classipc_1_1transport_1_1struc_1_1sync__io_1_1Channel.html#a5aae7a7f907f56fa07a230eadec2fedf" title="See Async_io_obj counterpart.">undo_expect_responses()</a> for it since. Typically this is a miscommunication at the user level: e.g., opposing user indicated a previous response was the last one but then erroneously sent another response anyway. Or, more simply, it sent 2+ responses to a one-off request (again erroneously).</li>
</ul>
<p >Both situations involve non-trivial user-level protocol mistakes. What to do?</p><ul>
<li>We could hose the whole channel: fire all handlers with some fatal <a class="el" href="namespaceipc.html#aa3192e586cc45d3e7c22463bf2760f89" title="Short-hand for boost.interprocess namespace.">Error_code</a> and disallow further work. This feels too draconian and inflexible at such a high layer.</li>
<li>Or we could inform the user of the problem.</li>
</ul>
<p >We choose the latter. In particular:</p><ul>
<li>We fire the user-protocol-error handler (see <a class="el" href="classipc_1_1transport_1_1struc_1_1sync__io_1_1Channel.html#a0c00bab2dad604dde176c4190553915c" title="Permanently memorizes the incoming-direction on-error handler, thus authorizing the emission of any i...">start_and_poll()</a>) locally. We feed them the problem in-message and then forget that message: they can do with it as they wish.</li>
<li>We send an internal message to the opposing peer indicating the issue including the triggering in-message ID (to them, out-message ID). The opposing peer <code><a class="el" href="classipc_1_1transport_1_1struc_1_1sync__io_1_1Channel.html" title="sync_io-pattern counterpart to async-I/O-pattern transport::struc::Channel.">Channel</a></code> shall fire their own user-protocol-error handler similarly.</li>
</ul>
<p >Other than that the channel continues operating. The user can choose to close it, or ignore the problem, or alert, or whatever.</p>
<p >To wit: </p><dl class="section see"><dt>See also</dt><dd><a class="el" href="classipc_1_1transport_1_1struc_1_1sync__io_1_1Channel.html#a5c62d2a374a3a98e7fa0aef01bf8a774" title="See Async_io_obj counterpart; though naturally on_func() is invoked in the sync_io-pattern fashion.">set_unexpected_response_handler()</a>. </dd>
<dd>
<a class="el" href="classipc_1_1transport_1_1struc_1_1sync__io_1_1Channel.html#a3fda370cc97c89a62f77a6fcf639cfd7" title="See Async_io_obj counterpart; though naturally on_func() is invoked in the sync_io-pattern fashion.">set_remote_unexpected_response_handler()</a>. </dd></dl>

<p class="definition">Definition at line <a class="el" href="ipc__transport__structured_2src_2ipc_2transport_2struc_2sync__io_2channel_8hpp_source.html#l01859">1859</a> of file <a class="el" href="ipc__transport__structured_2src_2ipc_2transport_2struc_2sync__io_2channel_8hpp_source.html">channel.hpp</a>.</p>

</div>
</div>
<a id="a9c04f15d4d17cd43aca70136119e1d28" name="a9c04f15d4d17cd43aca70136119e1d28"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9c04f15d4d17cd43aca70136119e1d28">&#9670;&nbsp;</a></span>m_rcv_pipes</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Channel_obj , typename Message_body , typename Struct_builder_config , typename Struct_reader_config &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">boost::array&lt;std::optional&lt;<a class="el" href="structipc_1_1transport_1_1struc_1_1sync__io_1_1Channel_1_1Msg__in__pipe.html">Msg_in_pipe</a>&gt;, 2&gt; <a class="el" href="classipc_1_1transport_1_1struc_1_1sync__io_1_1Channel.html">ipc::transport::struc::sync_io::Channel</a>&lt; Channel_obj, Message_body, Struct_builder_config, Struct_reader_config &gt;::m_rcv_pipes</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>1 or 2 active (via <code>optional</code>) <code>struct</code>s containing policy and state w/r/t receipt of low-level (unstructured) messages with the aim to complete the next structured in-message(s). </p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="structipc_1_1transport_1_1struc_1_1sync__io_1_1Channel_1_1Msg__in__pipe.html" title="Data and policy with respect to receipt of the next/currently-incomplete in-message.">Msg_in_pipe</a> doc header for detailed algorithm overview. </dd></dl>

<p class="definition">Definition at line <a class="el" href="ipc__transport__structured_2src_2ipc_2transport_2struc_2sync__io_2channel_8hpp_source.html#l01692">1692</a> of file <a class="el" href="ipc__transport__structured_2src_2ipc_2transport_2struc_2sync__io_2channel_8hpp_source.html">channel.hpp</a>.</p>

</div>
</div>
<a id="a1218e59c91d08758cd997d77913abd5a" name="a1218e59c91d08758cd997d77913abd5a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1218e59c91d08758cd997d77913abd5a">&#9670;&nbsp;</a></span>m_rcv_reassembly_q</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Channel_obj , typename Message_body , typename Struct_builder_config , typename Struct_reader_config &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::optional&lt;<a class="el" href="classipc_1_1transport_1_1struc_1_1sync__io_1_1Channel.html#a26594894094e4fa03b3c1dacd2e0f351">Reassembly_q</a>&gt; <a class="el" href="classipc_1_1transport_1_1struc_1_1sync__io_1_1Channel.html">ipc::transport::struc::sync_io::Channel</a>&lt; Channel_obj, Message_body, Struct_builder_config, Struct_reader_config &gt;::m_rcv_reassembly_q</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>When <code>Owned_channel::S_HAS_2_PIPES</code>, stores the reassembly queue of in-messages to feed into <a class="el" href="classipc_1_1transport_1_1struc_1_1sync__io_1_1Channel.html#ae9f5a798718d98523342acf55400d628" title="Queues of in-messages, keyed by Msg_which_in, each in msg_id_in_t (sequence #) order,...">m_rcv_pending_msgs</a> once in-messages filling the <a class="el" href="classipc_1_1transport_1_1struc_1_1sync__io_1_1Channel.html#ad77261f31055f4151c70225c3fa1da2e" title="Clarifying short-hand for incoming-message IDs.">msg_id_in_t</a> (sequence #) gap between <a class="el" href="classipc_1_1transport_1_1struc_1_1sync__io_1_1Channel.html#a26d39d4e1e2c304ef803b3721bde86f0" title="Next expected in-message ID (sequence #), incremented from initial value 1 to 2, 3,...">m_rcv_msg_next_id</a> and <code>m_rcv_reassembly_q.front()</code> is filled. </p>
<p >Once that occurs, the maximally long sequence of in-messages at the front of this queue are moved into <a class="el" href="classipc_1_1transport_1_1struc_1_1sync__io_1_1Channel.html#ae9f5a798718d98523342acf55400d628" title="Queues of in-messages, keyed by Msg_which_in, each in msg_id_in_t (sequence #) order,...">m_rcv_pending_msgs</a> (or fed to waiting handlers immediately if possible). Left uninitialized if <code>!S_HAS_2_PIPES</code>.</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classipc_1_1transport_1_1struc_1_1sync__io_1_1Channel.html#a26d39d4e1e2c304ef803b3721bde86f0" title="Next expected in-message ID (sequence #), incremented from initial value 1 to 2, 3,...">m_rcv_msg_next_id</a> for algorithm summary; <a class="el" href="classipc_1_1transport_1_1struc_1_1sync__io_1_1Channel.html#a26594894094e4fa03b3c1dacd2e0f351" title="Reassembly queue type: &quot;queue&quot; of all in-messages with msg_id_in_t exceeding m_rcv_msg_next_id,...">Reassembly_q</a> doc header for data structure details. </dd></dl>

<p class="definition">Definition at line <a class="el" href="ipc__transport__structured_2src_2ipc_2transport_2struc_2sync__io_2channel_8hpp_source.html#l01817">1817</a> of file <a class="el" href="ipc__transport__structured_2src_2ipc_2transport_2struc_2sync__io_2channel_8hpp_source.html">channel.hpp</a>.</p>

<p class="reference">Referenced by <a class="el" href="ipc__transport__structured_2src_2ipc_2transport_2struc_2sync__io_2channel_8hpp_source.html#l01972">ipc::transport::struc::sync_io::Channel&lt; Channel_obj, Message_body, Struct_builder_config, Struct_reader_config &gt;::Channel()</a>.</p>

</div>
</div>
<a id="a49e257338f9b20fd70c42142eb2db4f0" name="a49e257338f9b20fd70c42142eb2db4f0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a49e257338f9b20fd70c42142eb2db4f0">&#9670;&nbsp;</a></span>m_session_token</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Channel_obj , typename Message_body , typename Struct_builder_config , typename Struct_reader_config &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespaceipc_1_1transport_1_1struc.html#a6751c05fb6582a34c7c47ac470c4a48b">Session_token</a> <a class="el" href="classipc_1_1transport_1_1struc_1_1sync__io_1_1Channel.html">ipc::transport::struc::sync_io::Channel</a>&lt; Channel_obj, Message_body, Struct_builder_config, Struct_reader_config &gt;::m_session_token</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Session token: in <a class="el" href="classipc_1_1transport_1_1struc_1_1sync__io_1_1Channel.html#a5a3833cd141802041551db21198ac319aa0ea4326c39b88d0b32f90d5ce081220" title="Regular-operation phase: the general API (expect_msg(), etc.) is available.">Phase::S_LOGGED_IN</a> to send in every out-message and check-against every in-message; in log-in phase <em>as client</em> equals nil; in log-in phase <em>as server</em> it is auto-generated at construction. </p>
<p >In non-log-in phase, it's either provided by user in ctor (if log-in phase skipped), or:</p><ul>
<li>inherited from log-in phase (if <em>as server</em>);</li>
<li>deserialized from the log-in response (if <em>as client</em>).</li>
</ul>
<p >It's used in 2 ways:</p><ul>
<li>It is sent in every (structured) message &ndash; namely in the lead unstructured message. SO whenever an <code>mdt</code> message is created, we load <a class="el" href="classipc_1_1transport_1_1struc_1_1sync__io_1_1Channel.html#a49e257338f9b20fd70c42142eb2db4f0" title="Session token: in Phase::S_LOGGED_IN to send in every out-message and check-against every in-message;...">m_session_token</a> into it at that time.</li>
<li>Every message is checked against it (if not correct, channel is hosed immediately).<ul>
<li>There is exactly one exception to this: The log-in request (received in log-in phase <em>as server</em>) must have nil session token: we have not yet sent <a class="el" href="classipc_1_1transport_1_1struc_1_1sync__io_1_1Channel.html#a49e257338f9b20fd70c42142eb2db4f0" title="Session token: in Phase::S_LOGGED_IN to send in every out-message and check-against every in-message;...">m_session_token</a> (which we generated at ction) to it in the response message, so the client could not have known it. </li>
</ul>
</li>
</ul>

<p class="definition">Definition at line <a class="el" href="ipc__transport__structured_2src_2ipc_2transport_2struc_2sync__io_2channel_8hpp_source.html#l01715">1715</a> of file <a class="el" href="ipc__transport__structured_2src_2ipc_2transport_2struc_2sync__io_2channel_8hpp_source.html">channel.hpp</a>.</p>

<p class="reference">Referenced by <a class="el" href="ipc__transport__structured_2src_2ipc_2transport_2struc_2sync__io_2channel_8hpp_source.html#l01972">ipc::transport::struc::sync_io::Channel&lt; Channel_obj, Message_body, Struct_builder_config, Struct_reader_config &gt;::Channel()</a>.</p>

</div>
</div>
<a id="a5132d96a55a628a7830c19c630390582" name="a5132d96a55a628a7830c19c630390582"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5132d96a55a628a7830c19c630390582">&#9670;&nbsp;</a></span>m_snd_msg_next_id</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Channel_obj , typename Message_body , typename Struct_builder_config , typename Struct_reader_config &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classipc_1_1transport_1_1struc_1_1Channel__base.html#adcf24fa51747ed83c4b6427fbf44fecf">msg_id_out_t</a> <a class="el" href="classipc_1_1transport_1_1struc_1_1sync__io_1_1Channel.html">ipc::transport::struc::sync_io::Channel</a>&lt; Channel_obj, Message_body, Struct_builder_config, Struct_reader_config &gt;::m_snd_msg_next_id</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Next out-message ID (for the next <a class="el" href="classipc_1_1transport_1_1struc_1_1sync__io_1_1Channel.html#a0dc388e18b0fc0fa2d8ad0a6953fb039" title="See Async_io_obj counterpart.">send()</a> or <a class="el" href="classipc_1_1transport_1_1struc_1_1sync__io_1_1Channel.html#a26dc83067e005be38567199cbedd7f19" title="See Async_io_obj counterpart; though naturally on_rsp_func() is invoked in the sync_io-pattern fashio...">async_request()</a>). </p>

<p class="definition">Definition at line <a class="el" href="ipc__transport__structured_2src_2ipc_2transport_2struc_2sync__io_2channel_8hpp_source.html#l01718">1718</a> of file <a class="el" href="ipc__transport__structured_2src_2ipc_2transport_2struc_2sync__io_2channel_8hpp_source.html">channel.hpp</a>.</p>

</div>
</div>
<a id="a9a63c3620852f2354fe145364a73c688" name="a9a63c3620852f2354fe145364a73c688"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9a63c3620852f2354fe145364a73c688">&#9670;&nbsp;</a></span>m_started_ops</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Channel_obj , typename Message_body , typename Struct_builder_config , typename Struct_reader_config &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classipc_1_1transport_1_1struc_1_1sync__io_1_1Channel.html">ipc::transport::struc::sync_io::Channel</a>&lt; Channel_obj, Message_body, Struct_builder_config, Struct_reader_config &gt;::m_started_ops</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Whether <a class="el" href="classipc_1_1transport_1_1struc_1_1sync__io_1_1Channel.html#a6e4f8c4207fcf678b4cfc785707d3dce" title="Sets up the sync_io-pattern interaction between *this and the user&#39;s event loop; required before asyn...">start_ops()</a> has been called yet or not. </p>
<p >We could've used <a class="el" href="classipc_1_1transport_1_1struc_1_1sync__io_1_1Channel.html#abe17c6f98af890eaf522c97eb21e2e35" title="The Channel taken-over in ctor, lifetime until dtor.">m_channel</a> built-in guards against that, but then as of this writing there's no way to check that at the top of our own various APIs (<a class="el" href="classipc_1_1transport_1_1struc_1_1sync__io_1_1Channel.html#ae2a7cdf855b3cdcab1a2e1cd74834cc4" title="Helper that returns true if and only if start_ops() has not yet been called.">check_not_started_ops()</a>). </p>

<p class="definition">Definition at line <a class="el" href="ipc__transport__structured_2src_2ipc_2transport_2struc_2sync__io_2channel_8hpp_source.html#l01678">1678</a> of file <a class="el" href="ipc__transport__structured_2src_2ipc_2transport_2struc_2sync__io_2channel_8hpp_source.html">channel.hpp</a>.</p>

</div>
</div>
<a id="a47816a05b0af2d8b5c26ecaf01b89b1f" name="a47816a05b0af2d8b5c26ecaf01b89b1f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a47816a05b0af2d8b5c26ecaf01b89b1f">&#9670;&nbsp;</a></span>m_struct_builder_config</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Channel_obj , typename Message_body , typename Struct_builder_config , typename Struct_reader_config &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classipc_1_1transport_1_1struc_1_1sync__io_1_1Channel.html#a8a59bbc3c6a7191b316b23661d8ba6e3">Builder_config</a> <a class="el" href="classipc_1_1transport_1_1struc_1_1sync__io_1_1Channel.html">ipc::transport::struc::sync_io::Channel</a>&lt; Channel_obj, Message_body, Struct_builder_config, Struct_reader_config &gt;::m_struct_builder_config</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>The builder engine config for out-messages: Small data store, such that the <a class="el" href="classipc_1_1transport_1_1struc_1_1Struct__builder.html" title="A documentation-only concept defining the behavior of an object capable of zero-copy-serializing,...">Struct_builder</a> <code>Builder_config::Builder</code> (really the containing class of <a class="el" href="classipc_1_1transport_1_1struc_1_1sync__io_1_1Channel.html#a8a59bbc3c6a7191b316b23661d8ba6e3" title="See Async_io_obj counterpart.">Builder_config</a>) main-ctor takes an object of this type, its contents being knobs controlling the behavior of the resulting <a class="el" href="classipc_1_1transport_1_1struc_1_1Struct__builder.html" title="A documentation-only concept defining the behavior of an object capable of zero-copy-serializing,...">Struct_builder</a>. </p>
<ul>
<li>The <em>type</em> <a class="el" href="classipc_1_1transport_1_1struc_1_1sync__io_1_1Channel.html#a8a59bbc3c6a7191b316b23661d8ba6e3" title="See Async_io_obj counterpart.">Builder_config</a> (a template parameter) determines the logic part of the serialization policy: what is the source of RAM for segments (heap? SHM?), as the user mutates an out-message? How big is each segment?</li>
<li>The <em>members</em> inside <a class="el" href="classipc_1_1transport_1_1struc_1_1sync__io_1_1Channel.html#a47816a05b0af2d8b5c26ecaf01b89b1f" title="The builder engine config for out-messages: Small data store, such that the Struct_builder Builder_co...">m_struct_builder_config</a> further tweak the application of that logic by being knobs: Should prefix/postfix space be left in the serialization? How quickly should the segments grow? Where to log?<ul>
<li>This <code>Config</code> is passed to <code>Builder</code> ctor to configure it.</li>
</ul>
</li>
</ul>
<h3>Rationale</h3>
<p >By storing this value, copied from the one passed to ctor, we delegate the policy decision (as to what kind of capnp-structured-to-binary serialization engine to use) to the <code>*this</code> config (user). The knobs controlling the configuration of that engine, each time it's created for a given out-message, depend on the builder concrete type, so we don't know what they are or even their nature or number. They are stored opaquely (to us) inside this item.</p>
<p >This member is used in two ways.</p><ul>
<li>Every out-message (whether user-created or an internal one) is accompanied by/is an internal-use <em>metadata</em> message, which is just another <a class="el" href="classipc_1_1transport_1_1struc_1_1Msg__out.html" title="A structured out-message suitable to be sent via struc::Channel::send().">Msg_out</a> albeit with an internal friendly API, <a class="el" href="classipc_1_1transport_1_1struc_1_1Msg__mdt__out.html" title="Internally used (data-free) addendum on-top of Msg_out; really an alias to Msg_out&lt;schema::detail::St...">Msg_mdt_out</a>, tailored to the stuff we need to put into these. The builder config used to create this is <a class="el" href="classipc_1_1transport_1_1struc_1_1sync__io_1_1Channel.html#a47816a05b0af2d8b5c26ecaf01b89b1f" title="The builder engine config for out-messages: Small data store, such that the Struct_builder Builder_co...">m_struct_builder_config</a>.<ul>
<li>So the schema template param is the internal-use metadata stuff from structured_msg.capnp.</li>
</ul>
</li>
<li>Every user out-message created via <a class="el" href="classipc_1_1transport_1_1struc_1_1sync__io_1_1Channel.html#a426ecae27b4ea5cf7e666e56bad6afe5" title="See Async_io_obj counterpart.">create_msg()</a> is supplied by the latter with <a class="el" href="classipc_1_1transport_1_1struc_1_1sync__io_1_1Channel.html#a47816a05b0af2d8b5c26ecaf01b89b1f" title="The builder engine config for out-messages: Small data store, such that the Struct_builder Builder_co...">m_struct_builder_config</a> as the builder config.<ul>
<li>So the schema template param is <code>&lt;Message_body&gt;</code>, the <code><a class="el" href="classipc_1_1transport_1_1struc_1_1sync__io_1_1Channel.html" title="sync_io-pattern counterpart to async-I/O-pattern transport::struc::Channel.">Channel</a></code> template param from the user.</li>
<li>The user is allowed to simply direct-construct the <a class="el" href="classipc_1_1transport_1_1struc_1_1sync__io_1_1Channel.html#a83fb4462a8d4045bdb56b694bf80393c" title="See Async_io_obj counterpart.">Msg_out</a> without any <a class="el" href="classipc_1_1transport_1_1struc_1_1sync__io_1_1Channel.html#a426ecae27b4ea5cf7e666e56bad6afe5" title="See Async_io_obj counterpart.">create_msg()</a>. They have to supply the builder config themselves again, though. It has to be the same type as <a class="el" href="classipc_1_1transport_1_1struc_1_1sync__io_1_1Channel.html#a47816a05b0af2d8b5c26ecaf01b89b1f" title="The builder engine config for out-messages: Small data store, such that the Struct_builder Builder_co...">m_struct_builder_config</a>, or it won't compile; but in theory it could have different knob values. E.g., it could have a null <code>Logger</code>, while <code>*this</code> one logs-galore. Usually one would want to keep it equal (but certainly need not be the same actual <a class="el" href="classipc_1_1transport_1_1struc_1_1sync__io_1_1Channel.html#a8a59bbc3c6a7191b316b23661d8ba6e3" title="See Async_io_obj counterpart.">Builder_config</a> object).</li>
</ul>
</li>
</ul>
<p >So it's an important member, but arguably its type is more important than its contents (knobs). </p>

<p class="definition">Definition at line <a class="el" href="ipc__transport__structured_2src_2ipc_2transport_2struc_2sync__io_2channel_8hpp_source.html#l01658">1658</a> of file <a class="el" href="ipc__transport__structured_2src_2ipc_2transport_2struc_2sync__io_2channel_8hpp_source.html">channel.hpp</a>.</p>

</div>
</div>
<a id="aa4cd0e7c721ee3af4d1faa2ada5ad646" name="aa4cd0e7c721ee3af4d1faa2ada5ad646"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa4cd0e7c721ee3af4d1faa2ada5ad646">&#9670;&nbsp;</a></span>m_struct_lender_session</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Channel_obj , typename Message_body , typename Struct_builder_config , typename Struct_reader_config &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const Builder_config::Builder::Session <a class="el" href="classipc_1_1transport_1_1struc_1_1sync__io_1_1Channel.html">ipc::transport::struc::sync_io::Channel</a>&lt; Channel_obj, Message_body, Struct_builder_config, Struct_reader_config &gt;::m_struct_lender_session</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Value (possibly of size 0 depending on this type) to pass to <a class="el" href="classipc_1_1transport_1_1struc_1_1Msg__out.html#a91d2575343b28f83e22a71e7f7b3ff40" title="Returns the serialization in the form of a sequence of 1+ Blobs.">Msg_out::emit_serialization()</a> to indicate the opposing side of the <a class="el" href="classipc_1_1transport_1_1struc_1_1sync__io_1_1Channel.html#a4abac89dbd4d26c79b7915990f751a76" title="See Async_io_obj counterpart.">Owned_channel</a>. </p>
<p >If the type is <a class="el" href="structipc_1_1transport_1_1struc_1_1Null__session.html" title="Value for Struct_builder::Session when no extra information is needed when serializing Struct_builder...">Null_session</a> (zero-sized), then no information is necessary to indicate this. </p>

<p class="definition">Definition at line <a class="el" href="ipc__transport__structured_2src_2ipc_2transport_2struc_2sync__io_2channel_8hpp_source.html#l01665">1665</a> of file <a class="el" href="ipc__transport__structured_2src_2ipc_2transport_2struc_2sync__io_2channel_8hpp_source.html">channel.hpp</a>.</p>

</div>
</div>
<a id="af7ac60b2b7a7baf26a96cf4635d4c320" name="af7ac60b2b7a7baf26a96cf4635d4c320"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af7ac60b2b7a7baf26a96cf4635d4c320">&#9670;&nbsp;</a></span>m_struct_reader_config</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Channel_obj , typename Message_body , typename Struct_builder_config , typename Struct_reader_config &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classipc_1_1transport_1_1struc_1_1sync__io_1_1Channel.html#a14a7166b2f8c117ce6ddafe943d036fa">Reader_config</a> <a class="el" href="classipc_1_1transport_1_1struc_1_1sync__io_1_1Channel.html">ipc::transport::struc::sync_io::Channel</a>&lt; Channel_obj, Message_body, Struct_builder_config, Struct_reader_config &gt;::m_struct_reader_config</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Analogous to <a class="el" href="classipc_1_1transport_1_1struc_1_1sync__io_1_1Channel.html#a47816a05b0af2d8b5c26ecaf01b89b1f" title="The builder engine config for out-messages: Small data store, such that the Struct_builder Builder_co...">m_struct_builder_config</a> but for deserialization. </p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classipc_1_1transport_1_1struc_1_1sync__io_1_1Channel.html#a47816a05b0af2d8b5c26ecaf01b89b1f" title="The builder engine config for out-messages: Small data store, such that the Struct_builder Builder_co...">m_struct_builder_config</a> </dd></dl>

<p class="definition">Definition at line <a class="el" href="ipc__transport__structured_2src_2ipc_2transport_2struc_2sync__io_2channel_8hpp_source.html#l01671">1671</a> of file <a class="el" href="ipc__transport__structured_2src_2ipc_2transport_2struc_2sync__io_2channel_8hpp_source.html">channel.hpp</a>.</p>

</div>
</div>
<a id="a2c0013237f845e5589cf0063886c7431" name="a2c0013237f845e5589cf0063886c7431"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2c0013237f845e5589cf0063886c7431">&#9670;&nbsp;</a></span>m_sync_io_handlers</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Channel_obj , typename Message_body , typename Struct_builder_config , typename Struct_reader_config &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;boost::movelib::unique_ptr&lt;<a class="el" href="namespaceipc_1_1util.html#a31e67d3a017477a04b313927e2f2c733">util::Task</a>&gt; &gt; <a class="el" href="classipc_1_1transport_1_1struc_1_1sync__io_1_1Channel.html">ipc::transport::struc::sync_io::Channel</a>&lt; Channel_obj, Message_body, Struct_builder_config, Struct_reader_config &gt;::m_sync_io_handlers</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>The handlers as pushed by <a class="el" href="classipc_1_1transport_1_1struc_1_1sync__io_1_1Channel.html#a126c0d7ee5fcab20dc8c87884fdd7597" title="Record handler to invoke in handlers_poll() soon.">handlers_post()</a> to be flushed via <a class="el" href="classipc_1_1transport_1_1struc_1_1sync__io_1_1Channel.html#a3a0adf8ce8fc29ec55b4c8c30886c1fc" title="Executes what was recorded recently in handlers_post().">handlers_poll()</a> (internally by <code>*this</code>). </p>
<p ><a class="el" href="classipc_1_1transport_1_1struc_1_1sync__io_1_1Channel.html#a3a0adf8ce8fc29ec55b4c8c30886c1fc" title="Executes what was recorded recently in handlers_post().">handlers_poll()</a> is only called internally as opposed to from a user API: there is no method the user can invoke that is immediately servable; except:</p><ul>
<li><code>expect_*()</code> (all going through expect_msg_impl()): But they emit immediate results avoiding the handler function.</li>
<li>async_sync_end_sending(): Same.</li>
</ul>
<p >Unlike the core-layer guys, which always deal with at most 1 in-message at a given time, we have a situation where there can be more than 1 handler pending at a time; so this is a list as opposed to just 1 item. That said, there is indeed only 1 at a time if <a class="el" href="classipc_1_1transport_1_1Channel.html#a85184d886cee9b4a0d0e7b67796a238b" title="Useful for generic programming: true if and only if types imply both blobs and handles pipes are enab...">Channel::S_HAS_2_PIPES</a> is <code>false</code>; but 1+ may be saved, and fired in <a class="el" href="classipc_1_1transport_1_1struc_1_1sync__io_1_1Channel.html#a3a0adf8ce8fc29ec55b4c8c30886c1fc" title="Executes what was recorded recently in handlers_post().">handlers_poll()</a> soon, if HAS_2_PIPES is <code>true</code>. At the risk of verbosity to try to help understanding let's examine each case.</p>
<h3><code>HAS_2_PIPES = false</code>: How do we keep it to 1 handler (or 0) at a time?</h3>
<p >Well, why do handlers fire? Answer:</p><ul>
<li>If a user is expecting an in-message (a notification via <code>expect_*()</code> or a response via <a class="el" href="classipc_1_1transport_1_1struc_1_1sync__io_1_1Channel.html#a26dc83067e005be38567199cbedd7f19" title="See Async_io_obj counterpart; though naturally on_rsp_func() is invoked in the sync_io-pattern fashio...">async_request()</a>), and that message arrives, then a saved handler shall fire.</li>
<li>If a user is not expecting a response, but one arrives, then a special handler shall fire if set.</li>
<li>If the <em>opposing</em> user is not expecting a response, but one arrives, then they send an internal message which arrives to <em>us</em>, and then a special handler <em>here</em> shall fire if set.</li>
<li>If something bad is reported to an <code>async_receive_*()</code> handler via <code>Error_code</code>, then the channel is hosed, and <a class="el" href="classipc_1_1transport_1_1struc_1_1sync__io_1_1Channel.html#ad1fcc872d76e6a59321f5d67b2e0a70b" title="The channel-hosed error reporting handler.">m_on_err_func</a> shall fire.</li>
</ul>
<p >Now, as noted, any cached in-messages to <code>expect_*()</code> are not a part of this equation (they are reported differently); nor is the special case of the <a class="el" href="classipc_1_1transport_1_1struc_1_1sync__io_1_1Channel.html#abe17c6f98af890eaf522c97eb21e2e35" title="The Channel taken-over in ctor, lifetime until dtor.">m_channel</a> <a class="el" href="classipc_1_1transport_1_1struc_1_1sync__io_1_1Channel.html#ae4a2a63dc88722d96ee9f3ed68cf7b86" title="See Async_io_obj counterpart; except (1) naturally on_done_func() is invoked in the sync_io-pattern f...">async_end_sending()</a> stuff which is at a lower level and handled separately. So the above 4 bullet points are the only relevant things.</p>
<p >Naturally, then, a handler can fire only as a reaction to an <code>m_channel.async_receive_*()</code> receiving an unstructured msg which then completes a structured message (either by itself or by combining with a preceding one). So we choose to fire (synchronously call) any such handler immediately upon processing an unstructured message's contents. You can see this in <a class="el" href="classipc_1_1transport_1_1struc_1_1sync__io_1_1Channel.html#a252e43676b8a41a706df0655f887be63" title="This key method acts on the pre-condition that the given in-pipe is not known to be in would-block st...">rcv_async_read_lead_or_continuation_msg()</a>. So we <a class="el" href="classipc_1_1transport_1_1struc_1_1sync__io_1_1Channel.html#a126c0d7ee5fcab20dc8c87884fdd7597" title="Record handler to invoke in handlers_poll() soon.">handlers_post()</a> while processing it... then <a class="el" href="classipc_1_1transport_1_1struc_1_1sync__io_1_1Channel.html#a3a0adf8ce8fc29ec55b4c8c30886c1fc" title="Executes what was recorded recently in handlers_post().">handlers_poll()</a> right after finishing doing so.</p>
<p >That leaves the possibility of said processing <code><a class="el" href="classipc_1_1transport_1_1struc_1_1sync__io_1_1Channel.html#a126c0d7ee5fcab20dc8c87884fdd7597" title="Record handler to invoke in handlers_poll() soon.">handlers_post()</a></code>ing 2+ handlers. However, no, that is not possible as of this writing:</p><ul>
<li>If an in-message is a response (it either is or isn't: it is a metadata header), then either<ul>
<li>it is a response to a message earlier marked as awaiting response; or</li>
<li>it is not &ndash; and it is invalid and is reported (if so configured) via unexpected-response handler.</li>
</ul>
</li>
<li>If it is not a response, then either<ul>
<li>it is expected via earlier expect_msg_impl() (fire handler); or</li>
<li>it is not expected (cache it for later non-handler-emission, possibly, via expect_msg_impl()).</li>
</ul>
</li>
<li>Otherwise it is malformed somehow (internal protocol error a/k/a bug here or in opposing guy).</li>
</ul>
<p >Therefore you can see the fate of a given message is to go down one of these paths, each of which ends either with no handler being posted; or one being posted.</p>
<p >Then we <a class="el" href="classipc_1_1transport_1_1struc_1_1sync__io_1_1Channel.html#a3a0adf8ce8fc29ec55b4c8c30886c1fc" title="Executes what was recorded recently in handlers_post().">handlers_poll()</a> it before trying to read the next unstructured message (or stopping forever).</p>
<h3><code>HAS_2_PIPES = true</code>: Why there can be 1+ handlers at a time</h3>
<p >The key difference is just after the structured message has been fully deserialized but before it is then given to the layer where its structured contents are either cached or emitted to the user. Namely, we check its ID against the next expected ID (sequence number). If there is only 1 pipe, it must always have the next expected ID. However if there are 2, as is the case here, then the seq # may exceed the expected ID causing message to be stored in <a class="el" href="classipc_1_1transport_1_1struc_1_1sync__io_1_1Channel.html#a1218e59c91d08758cd997d77913abd5a" title="When Owned_channel::S_HAS_2_PIPES, stores the reassembly queue of in-messages to feed into m_rcv_pend...">m_rcv_reassembly_q</a>. No problem so far....</p>
<p >Now say an in-message arrives that closes the gap between the next expected seq # and the lowest seq # in <a class="el" href="classipc_1_1transport_1_1struc_1_1sync__io_1_1Channel.html#a1218e59c91d08758cd997d77913abd5a" title="When Owned_channel::S_HAS_2_PIPES, stores the reassembly queue of in-messages to feed into m_rcv_pend...">m_rcv_reassembly_q</a>. Now potentially the entire <a class="el" href="classipc_1_1transport_1_1struc_1_1sync__io_1_1Channel.html#a1218e59c91d08758cd997d77913abd5a" title="When Owned_channel::S_HAS_2_PIPES, stores the reassembly queue of in-messages to feed into m_rcv_pend...">m_rcv_reassembly_q</a> must be emitted to the user! E.g., if we receive 1, 2, 4, 5, 6, 7, 3, then after 3 we must emit 4-5-6-7 as well. So in total upon receiving 1 unstructured message (the last continuation message comprised by structured message 3, we then emit five messages in one go).</p>
<p >So that's why there can be multiple handlers.</p>
<h3>Rationale: Expressing this as a function object</h3>
<p >I (ygoldfel) suspect the semantics of this guy and <a class="el" href="classipc_1_1transport_1_1struc_1_1sync__io_1_1Channel.html#a126c0d7ee5fcab20dc8c87884fdd7597" title="Record handler to invoke in handlers_poll() soon.">handlers_post()</a> and <a class="el" href="classipc_1_1transport_1_1struc_1_1sync__io_1_1Channel.html#a3a0adf8ce8fc29ec55b4c8c30886c1fc" title="Executes what was recorded recently in handlers_post().">handlers_poll()</a> might be confusing. It may look like some sort of generalized boost.asio-<code>post()</code>-lite scheme, but in reality it is much simpler than that. In actual reality: we read an in-message; as a result we either need to do nothing user-handler-wise, or we need to invoke 1 relevant handler. (As of this writing no one in-message can mean 2+ user handlers are applicable. See above. Conceivably that could change but....) This calling-of-user-handler just needs to occur a few stack frames up (synchronously at that) and can be triggered by all manner of situations a few stack frames down. So, really, this could be communicated in some kind of union-enumeration combo. Expressing it as an actual function to run just seemed like the most code-economical way to express it. It's easier to code "execute this" rather than "decode this union-enumeration thing to tell you what you should execute." Perf-wise it might be worse... maybe... as <code>Function&lt;&gt;</code> is a polymorphic data structure. (Premature optimization is the root of all ev... and so on.)</p>
<h3>Rationale: Communicating this via <a class="el" href="classipc_1_1transport_1_1struc_1_1sync__io_1_1Channel.html#a126c0d7ee5fcab20dc8c87884fdd7597" title="Record handler to invoke in handlers_poll() soon.">handlers_post()</a> to <a class="el" href="classipc_1_1transport_1_1struc_1_1sync__io_1_1Channel.html#a3a0adf8ce8fc29ec55b4c8c30886c1fc" title="Executes what was recorded recently in handlers_post().">handlers_poll()</a></h3>
<p >Orthogonally, saving it (whether a union-enumeration thing or a callback) in this data structure (<a class="el" href="classipc_1_1transport_1_1struc_1_1sync__io_1_1Channel.html#a2c0013237f845e5589cf0063886c7431" title="The handlers as pushed by handlers_post() to be flushed via handlers_poll() (internally by *this).">m_sync_io_handlers</a>) <em>felt</em> more economical (in terms of lines of code) than returning it up a function-call chain. On the other hand, though, the algorithm would be more rigid-looking and robust that other way; generally speaking I (ygoldfel) always prefer to keep less state and be more functional in style &ndash; this here going against that. Indeed <a class="el" href="classipc_1_1transport_1_1Native__socket__stream_1_1Impl.html" title="Internal, non-movable pImpl implementation of Native_socket_stream class.">Native_socket_stream::Impl</a> does it that more-functional way albeit in a totally different setting. Well, we'll see. Anyway it works at least. </p>

<p class="definition">Definition at line <a class="el" href="ipc__transport__structured_2src_2ipc_2transport_2struc_2sync__io_2channel_8hpp_source.html#l01956">1956</a> of file <a class="el" href="ipc__transport__structured_2src_2ipc_2transport_2struc_2sync__io_2channel_8hpp_source.html">channel.hpp</a>.</p>

</div>
</div>
<hr/>The documentation for this class was generated from the following files:<ul>
<li>transport/struc/<a class="el" href="struc__fwd_8hpp_source.html">struc_fwd.hpp</a></li>
<li>transport/struc/sync_io/<a class="el" href="ipc__transport__structured_2src_2ipc_2transport_2struc_2sync__io_2channel_8hpp_source.html">channel.hpp</a></li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Wed Jan 17 2024 05:40:03 for Flow-IPC by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.4
</small></address>
</body>
</html>
