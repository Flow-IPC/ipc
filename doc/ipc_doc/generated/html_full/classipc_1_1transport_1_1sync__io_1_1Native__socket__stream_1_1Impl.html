<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.9.4"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Flow-IPC: ipc::transport::sync_io::Native_socket_stream::Impl Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">Flow-IPC<span id="projectnumber">&#160;2.0.0</span>
   </div>
   <div id="projectbrief">Flow-IPC project: Full implementation reference.</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.4 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search",'Search','.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespaceipc.html">ipc</a></li><li class="navelem"><a class="el" href="namespaceipc_1_1transport.html">transport</a></li><li class="navelem"><a class="el" href="namespaceipc_1_1transport_1_1sync__io.html">sync_io</a></li><li class="navelem"><a class="el" href="classipc_1_1transport_1_1sync__io_1_1Native__socket__stream.html">Native_socket_stream</a></li><li class="navelem"><a class="el" href="classipc_1_1transport_1_1sync__io_1_1Native__socket__stream_1_1Impl.html">Impl</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pub-static-attribs">Static Public Attributes</a> &#124;
<a href="#pri-types">Private Types</a> &#124;
<a href="#pri-methods">Private Member Functions</a> &#124;
<a href="#pri-attribs">Private Attributes</a> &#124;
<a href="#pri-static-attribs">Static Private Attributes</a> &#124;
<a href="#related">Related Functions</a> &#124;
<a href="classipc_1_1transport_1_1sync__io_1_1Native__socket__stream_1_1Impl-members.html">List of all members</a>  </div>
  <div class="headertitle"><div class="title">ipc::transport::sync_io::Native_socket_stream::Impl Class Reference</div></div>
</div><!--header-->
<div class="contents">

<p>Internal, non-movable pImpl implementation of <a class="el" href="classipc_1_1transport_1_1sync__io_1_1Native__socket__stream.html" title="Implements both sync_io::Native_handle_sender and sync_io::Native_handle_receiver concepts by using a...">sync_io::Native_socket_stream</a> class.  
 <a href="classipc_1_1transport_1_1sync__io_1_1Native__socket__stream_1_1Impl.html#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="sync__io_2detail_2native__socket__stream__impl_8hpp_source.html">native_socket_stream_impl.hpp</a>&gt;</code></p>
<div class="dynheader">
Inheritance diagram for ipc::transport::sync_io::Native_socket_stream::Impl:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="classipc_1_1transport_1_1sync__io_1_1Native__socket__stream_1_1Impl__inherit__graph.svg" width="310" height="119"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe>
</div>
<center><span class="legend">[<a href="graph_legend.html">legend</a>]</span></center></div>
<div class="dynheader">
Collaboration diagram for ipc::transport::sync_io::Native_socket_stream::Impl:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="classipc_1_1transport_1_1sync__io_1_1Native__socket__stream_1_1Impl__coll__graph.svg" width="1263" height="1631"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe>
</div>
<center><span class="legend">[<a href="graph_legend.html">legend</a>]</span></center></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="nested-classes" name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structipc_1_1transport_1_1sync__io_1_1Native__socket__stream_1_1Impl_1_1Rcv__user__request.html">Rcv_user_request</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Identical to <a class="el" href="structipc_1_1transport_1_1sync__io_1_1Async__adapter__receiver_1_1User__request.html" title="Data store representing a deficit user async-receive request: either one being currently handled by m...">sync_io::Async_adapter_receiver::User_request</a>, except we only keep at most 1 of these and thus don't need a <code>Ptr</code> alias inside.  <a href="structipc_1_1transport_1_1sync__io_1_1Native__socket__stream_1_1Impl_1_1Rcv__user__request.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structipc_1_1transport_1_1sync__io_1_1Native__socket__stream_1_1Impl_1_1Snd__low__lvl__payload.html">Snd_low_lvl_payload</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Data store representing a payload corresponding to exactly one attempted async write-op, albeit used if and only if we encounter would-block in <code>send_*()</code> or <a class="el" href="classipc_1_1transport_1_1sync__io_1_1Native__socket__stream_1_1Impl.html#a4b31da3a7ff63f307bd08e288c391556" title="Handler for the async-wait, via util::sync_io::Timer_event_emitter, of the auto-ping timer firing; if...">snd_on_ev_auto_ping_now_timer_fired()</a> or <code>*end_sending()</code> and have to queue (and therefore one-time-copy) data in <a class="el" href="classipc_1_1transport_1_1sync__io_1_1Native__socket__stream_1_1Impl.html#a1af9eb83b9afee25ba153a2ca066858d" title="Queue storing (at head) the currently in-progress async write-op of a Snd_low_lvl_payload; followed b...">m_snd_pending_payloads_q</a>.  <a href="structipc_1_1transport_1_1sync__io_1_1Native__socket__stream_1_1Impl_1_1Snd__low__lvl__payload.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-methods" name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:ae9194e2eefe81185d1bf067b1f934657"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classipc_1_1transport_1_1sync__io_1_1Native__socket__stream_1_1Impl.html#ae9194e2eefe81185d1bf067b1f934657">Impl</a> (flow::log::Logger *logger_ptr, <a class="el" href="namespaceipc_1_1util.html#ae6ac47812a90d1287c61e0b7de7bc4f5">util::String_view</a> nickname_str)</td></tr>
<tr class="memdesc:ae9194e2eefe81185d1bf067b1f934657"><td class="mdescLeft">&#160;</td><td class="mdescRight">See <a class="el" href="classipc_1_1transport_1_1sync__io_1_1Native__socket__stream.html" title="Implements both sync_io::Native_handle_sender and sync_io::Native_handle_receiver concepts by using a...">Native_socket_stream</a> counterpart.  <a href="classipc_1_1transport_1_1sync__io_1_1Native__socket__stream_1_1Impl.html#ae9194e2eefe81185d1bf067b1f934657">More...</a><br /></td></tr>
<tr class="separator:ae9194e2eefe81185d1bf067b1f934657"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a90f29990e2e88052232c218c076414c7"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classipc_1_1transport_1_1sync__io_1_1Native__socket__stream_1_1Impl.html#a90f29990e2e88052232c218c076414c7">Impl</a> (flow::log::Logger *logger_ptr, <a class="el" href="namespaceipc_1_1util.html#ae6ac47812a90d1287c61e0b7de7bc4f5">util::String_view</a> nickname_str, <a class="el" href="namespaceipc_1_1transport.html#a7ee4551983d9df16ec16a3139bac50e8">Native_handle</a> &amp;&amp;native_peer_socket_moved)</td></tr>
<tr class="memdesc:a90f29990e2e88052232c218c076414c7"><td class="mdescLeft">&#160;</td><td class="mdescRight">See <a class="el" href="classipc_1_1transport_1_1sync__io_1_1Native__socket__stream.html" title="Implements both sync_io::Native_handle_sender and sync_io::Native_handle_receiver concepts by using a...">Native_socket_stream</a> counterpart.  <a href="classipc_1_1transport_1_1sync__io_1_1Native__socket__stream_1_1Impl.html#a90f29990e2e88052232c218c076414c7">More...</a><br /></td></tr>
<tr class="separator:a90f29990e2e88052232c218c076414c7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adeb067b178e7688dde0ca7c5eb877b1d"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classipc_1_1transport_1_1sync__io_1_1Native__socket__stream_1_1Impl.html#adeb067b178e7688dde0ca7c5eb877b1d">~Impl</a> ()</td></tr>
<tr class="memdesc:adeb067b178e7688dde0ca7c5eb877b1d"><td class="mdescLeft">&#160;</td><td class="mdescRight">See <a class="el" href="classipc_1_1transport_1_1sync__io_1_1Native__socket__stream.html" title="Implements both sync_io::Native_handle_sender and sync_io::Native_handle_receiver concepts by using a...">Native_socket_stream</a> counterpart.  <a href="classipc_1_1transport_1_1sync__io_1_1Native__socket__stream_1_1Impl.html#adeb067b178e7688dde0ca7c5eb877b1d">More...</a><br /></td></tr>
<tr class="separator:adeb067b178e7688dde0ca7c5eb877b1d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0ddd1b1e57bc61827d457e16e3db8600"><td class="memItemLeft" align="right" valign="top">const std::string &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classipc_1_1transport_1_1sync__io_1_1Native__socket__stream_1_1Impl.html#a0ddd1b1e57bc61827d457e16e3db8600">nickname</a> () const</td></tr>
<tr class="memdesc:a0ddd1b1e57bc61827d457e16e3db8600"><td class="mdescLeft">&#160;</td><td class="mdescRight">See <a class="el" href="classipc_1_1transport_1_1sync__io_1_1Native__socket__stream.html" title="Implements both sync_io::Native_handle_sender and sync_io::Native_handle_receiver concepts by using a...">Native_socket_stream</a> counterpart.  <a href="classipc_1_1transport_1_1sync__io_1_1Native__socket__stream_1_1Impl.html#a0ddd1b1e57bc61827d457e16e3db8600">More...</a><br /></td></tr>
<tr class="separator:a0ddd1b1e57bc61827d457e16e3db8600"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8b9839bb39e95a51ed7c920137438a21"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classipc_1_1transport_1_1sync__io_1_1Native__socket__stream_1_1Impl.html#a8b9839bb39e95a51ed7c920137438a21">replace_event_wait_handles</a> (const <a class="el" href="namespaceipc.html#aa455c7f045059736578ca275fc1a851f">Function</a>&lt; <a class="el" href="classipc_1_1util_1_1sync__io_1_1Asio__waitable__native__handle.html">util::sync_io::Asio_waitable_native_handle</a>()&gt; &amp;create_ev_wait_hndl_func)</td></tr>
<tr class="memdesc:a8b9839bb39e95a51ed7c920137438a21"><td class="mdescLeft">&#160;</td><td class="mdescRight">See <a class="el" href="classipc_1_1transport_1_1sync__io_1_1Native__socket__stream.html" title="Implements both sync_io::Native_handle_sender and sync_io::Native_handle_receiver concepts by using a...">Native_socket_stream</a> counterpart.  <a href="classipc_1_1transport_1_1sync__io_1_1Native__socket__stream_1_1Impl.html#a8b9839bb39e95a51ed7c920137438a21">More...</a><br /></td></tr>
<tr class="separator:a8b9839bb39e95a51ed7c920137438a21"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6600090ca22c9b940155f7920b1465e4"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classipc_1_1util_1_1Process__credentials.html">util::Process_credentials</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classipc_1_1transport_1_1sync__io_1_1Native__socket__stream_1_1Impl.html#a6600090ca22c9b940155f7920b1465e4">remote_peer_process_credentials</a> (<a class="el" href="namespaceipc.html#aa3192e586cc45d3e7c22463bf2760f89">Error_code</a> *err_code) const</td></tr>
<tr class="memdesc:a6600090ca22c9b940155f7920b1465e4"><td class="mdescLeft">&#160;</td><td class="mdescRight">See <a class="el" href="classipc_1_1transport_1_1sync__io_1_1Native__socket__stream.html" title="Implements both sync_io::Native_handle_sender and sync_io::Native_handle_receiver concepts by using a...">Native_socket_stream</a> counterpart.  <a href="classipc_1_1transport_1_1sync__io_1_1Native__socket__stream_1_1Impl.html#a6600090ca22c9b940155f7920b1465e4">More...</a><br /></td></tr>
<tr class="separator:a6600090ca22c9b940155f7920b1465e4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3c5187e34876a0419ff70734ec0fbf14"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classipc_1_1transport_1_1sync__io_1_1Native__socket__stream_1_1Impl.html#a3c5187e34876a0419ff70734ec0fbf14">sync_connect</a> (const <a class="el" href="namespaceipc_1_1transport.html#a33de1c256addb3964b839dc2dd407d24">Shared_name</a> &amp;absolute_name, <a class="el" href="namespaceipc.html#aa3192e586cc45d3e7c22463bf2760f89">Error_code</a> *err_code)</td></tr>
<tr class="memdesc:a3c5187e34876a0419ff70734ec0fbf14"><td class="mdescLeft">&#160;</td><td class="mdescRight">See <a class="el" href="classipc_1_1transport_1_1sync__io_1_1Native__socket__stream.html" title="Implements both sync_io::Native_handle_sender and sync_io::Native_handle_receiver concepts by using a...">Native_socket_stream</a> counterpart.  <a href="classipc_1_1transport_1_1sync__io_1_1Native__socket__stream_1_1Impl.html#a3c5187e34876a0419ff70734ec0fbf14">More...</a><br /></td></tr>
<tr class="separator:a3c5187e34876a0419ff70734ec0fbf14"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5fe9845081e656642a8b9f82f82228f6"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classipc_1_1transport_1_1sync__io_1_1Native__socket__stream_1_1Impl.html#a5fe9845081e656642a8b9f82f82228f6">send_meta_blob_max_size</a> () const</td></tr>
<tr class="memdesc:a5fe9845081e656642a8b9f82f82228f6"><td class="mdescLeft">&#160;</td><td class="mdescRight">See <a class="el" href="classipc_1_1transport_1_1sync__io_1_1Native__socket__stream.html" title="Implements both sync_io::Native_handle_sender and sync_io::Native_handle_receiver concepts by using a...">Native_socket_stream</a> counterpart.  <a href="classipc_1_1transport_1_1sync__io_1_1Native__socket__stream_1_1Impl.html#a5fe9845081e656642a8b9f82f82228f6">More...</a><br /></td></tr>
<tr class="separator:a5fe9845081e656642a8b9f82f82228f6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afa6b6e1be0f00add0b53b3263c412c76"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classipc_1_1transport_1_1sync__io_1_1Native__socket__stream_1_1Impl.html#afa6b6e1be0f00add0b53b3263c412c76">send_blob_max_size</a> () const</td></tr>
<tr class="memdesc:afa6b6e1be0f00add0b53b3263c412c76"><td class="mdescLeft">&#160;</td><td class="mdescRight">See <a class="el" href="classipc_1_1transport_1_1sync__io_1_1Native__socket__stream.html" title="Implements both sync_io::Native_handle_sender and sync_io::Native_handle_receiver concepts by using a...">Native_socket_stream</a> counterpart.  <a href="classipc_1_1transport_1_1sync__io_1_1Native__socket__stream_1_1Impl.html#afa6b6e1be0f00add0b53b3263c412c76">More...</a><br /></td></tr>
<tr class="separator:afa6b6e1be0f00add0b53b3263c412c76"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a65eea0cec146df598fce1d9ab5ce7e15"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classipc_1_1transport_1_1sync__io_1_1Native__socket__stream_1_1Impl.html#a65eea0cec146df598fce1d9ab5ce7e15">start_send_native_handle_ops</a> (<a class="el" href="namespaceipc_1_1util_1_1sync__io.html#aa0b9a3cc6bdc7dedbef4f9e06851aa24">util::sync_io::Event_wait_func</a> &amp;&amp;ev_wait_func)</td></tr>
<tr class="memdesc:a65eea0cec146df598fce1d9ab5ce7e15"><td class="mdescLeft">&#160;</td><td class="mdescRight">See <a class="el" href="classipc_1_1transport_1_1sync__io_1_1Native__socket__stream.html" title="Implements both sync_io::Native_handle_sender and sync_io::Native_handle_receiver concepts by using a...">Native_socket_stream</a> counterpart.  <a href="classipc_1_1transport_1_1sync__io_1_1Native__socket__stream_1_1Impl.html#a65eea0cec146df598fce1d9ab5ce7e15">More...</a><br /></td></tr>
<tr class="separator:a65eea0cec146df598fce1d9ab5ce7e15"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6a01d2df2772ee72e4386e84684394e3"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classipc_1_1transport_1_1sync__io_1_1Native__socket__stream_1_1Impl.html#a6a01d2df2772ee72e4386e84684394e3">start_send_blob_ops</a> (<a class="el" href="namespaceipc_1_1util_1_1sync__io.html#aa0b9a3cc6bdc7dedbef4f9e06851aa24">util::sync_io::Event_wait_func</a> &amp;&amp;ev_wait_func)</td></tr>
<tr class="memdesc:a6a01d2df2772ee72e4386e84684394e3"><td class="mdescLeft">&#160;</td><td class="mdescRight">See <a class="el" href="classipc_1_1transport_1_1sync__io_1_1Native__socket__stream.html" title="Implements both sync_io::Native_handle_sender and sync_io::Native_handle_receiver concepts by using a...">Native_socket_stream</a> counterpart.  <a href="classipc_1_1transport_1_1sync__io_1_1Native__socket__stream_1_1Impl.html#a6a01d2df2772ee72e4386e84684394e3">More...</a><br /></td></tr>
<tr class="separator:a6a01d2df2772ee72e4386e84684394e3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a59e9935bdd704c40173a40e87b5db131"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classipc_1_1transport_1_1sync__io_1_1Native__socket__stream_1_1Impl.html#a59e9935bdd704c40173a40e87b5db131">send_native_handle</a> (<a class="el" href="namespaceipc_1_1transport.html#a7ee4551983d9df16ec16a3139bac50e8">Native_handle</a> hndl_or_null, const <a class="el" href="namespaceipc_1_1util.html#ae0be7edba7e30ffa3f8b742af621f2ab">util::Blob_const</a> &amp;meta_blob, <a class="el" href="namespaceipc.html#aa3192e586cc45d3e7c22463bf2760f89">Error_code</a> *err_code)</td></tr>
<tr class="memdesc:a59e9935bdd704c40173a40e87b5db131"><td class="mdescLeft">&#160;</td><td class="mdescRight">See <a class="el" href="classipc_1_1transport_1_1sync__io_1_1Native__socket__stream.html" title="Implements both sync_io::Native_handle_sender and sync_io::Native_handle_receiver concepts by using a...">Native_socket_stream</a> counterpart.  <a href="classipc_1_1transport_1_1sync__io_1_1Native__socket__stream_1_1Impl.html#a59e9935bdd704c40173a40e87b5db131">More...</a><br /></td></tr>
<tr class="separator:a59e9935bdd704c40173a40e87b5db131"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaef639c110a0e3d6804da84f9458ae78"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classipc_1_1transport_1_1sync__io_1_1Native__socket__stream_1_1Impl.html#aaef639c110a0e3d6804da84f9458ae78">send_blob</a> (const <a class="el" href="namespaceipc_1_1util.html#ae0be7edba7e30ffa3f8b742af621f2ab">util::Blob_const</a> &amp;blob, <a class="el" href="namespaceipc.html#aa3192e586cc45d3e7c22463bf2760f89">Error_code</a> *err_code)</td></tr>
<tr class="memdesc:aaef639c110a0e3d6804da84f9458ae78"><td class="mdescLeft">&#160;</td><td class="mdescRight">See <a class="el" href="classipc_1_1transport_1_1sync__io_1_1Native__socket__stream.html" title="Implements both sync_io::Native_handle_sender and sync_io::Native_handle_receiver concepts by using a...">Native_socket_stream</a> counterpart.  <a href="classipc_1_1transport_1_1sync__io_1_1Native__socket__stream_1_1Impl.html#aaef639c110a0e3d6804da84f9458ae78">More...</a><br /></td></tr>
<tr class="separator:aaef639c110a0e3d6804da84f9458ae78"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0aca995c7150e72219b422c188d9bc23"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classipc_1_1transport_1_1sync__io_1_1Native__socket__stream_1_1Impl.html#a0aca995c7150e72219b422c188d9bc23">async_end_sending</a> (<a class="el" href="namespaceipc.html#aa3192e586cc45d3e7c22463bf2760f89">Error_code</a> *sync_err_code, flow::async::Task_asio_err &amp;&amp;on_done_func)</td></tr>
<tr class="memdesc:a0aca995c7150e72219b422c188d9bc23"><td class="mdescLeft">&#160;</td><td class="mdescRight">See <a class="el" href="classipc_1_1transport_1_1sync__io_1_1Native__socket__stream.html" title="Implements both sync_io::Native_handle_sender and sync_io::Native_handle_receiver concepts by using a...">Native_socket_stream</a> counterpart.  <a href="classipc_1_1transport_1_1sync__io_1_1Native__socket__stream_1_1Impl.html#a0aca995c7150e72219b422c188d9bc23">More...</a><br /></td></tr>
<tr class="separator:a0aca995c7150e72219b422c188d9bc23"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aef7a604a32db50eaf5fc501e5a205dd3"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classipc_1_1transport_1_1sync__io_1_1Native__socket__stream_1_1Impl.html#aef7a604a32db50eaf5fc501e5a205dd3">end_sending</a> ()</td></tr>
<tr class="memdesc:aef7a604a32db50eaf5fc501e5a205dd3"><td class="mdescLeft">&#160;</td><td class="mdescRight">See <a class="el" href="classipc_1_1transport_1_1sync__io_1_1Native__socket__stream.html" title="Implements both sync_io::Native_handle_sender and sync_io::Native_handle_receiver concepts by using a...">Native_socket_stream</a> counterpart.  <a href="classipc_1_1transport_1_1sync__io_1_1Native__socket__stream_1_1Impl.html#aef7a604a32db50eaf5fc501e5a205dd3">More...</a><br /></td></tr>
<tr class="separator:aef7a604a32db50eaf5fc501e5a205dd3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab7b382067804495cbae180a5bc1a2757"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classipc_1_1transport_1_1sync__io_1_1Native__socket__stream_1_1Impl.html#ab7b382067804495cbae180a5bc1a2757">auto_ping</a> (<a class="el" href="namespaceipc_1_1util.html#ac66141280c3b7295a86b65209f31cc58">util::Fine_duration</a> period)</td></tr>
<tr class="memdesc:ab7b382067804495cbae180a5bc1a2757"><td class="mdescLeft">&#160;</td><td class="mdescRight">See <a class="el" href="classipc_1_1transport_1_1sync__io_1_1Native__socket__stream.html" title="Implements both sync_io::Native_handle_sender and sync_io::Native_handle_receiver concepts by using a...">Native_socket_stream</a> counterpart.  <a href="classipc_1_1transport_1_1sync__io_1_1Native__socket__stream_1_1Impl.html#ab7b382067804495cbae180a5bc1a2757">More...</a><br /></td></tr>
<tr class="separator:ab7b382067804495cbae180a5bc1a2757"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af5d6e9275386dfefddb7a97248b039a7"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classipc_1_1transport_1_1sync__io_1_1Native__socket__stream_1_1Impl.html#af5d6e9275386dfefddb7a97248b039a7">receive_meta_blob_max_size</a> () const</td></tr>
<tr class="memdesc:af5d6e9275386dfefddb7a97248b039a7"><td class="mdescLeft">&#160;</td><td class="mdescRight">See <a class="el" href="classipc_1_1transport_1_1sync__io_1_1Native__socket__stream.html" title="Implements both sync_io::Native_handle_sender and sync_io::Native_handle_receiver concepts by using a...">Native_socket_stream</a> counterpart.  <a href="classipc_1_1transport_1_1sync__io_1_1Native__socket__stream_1_1Impl.html#af5d6e9275386dfefddb7a97248b039a7">More...</a><br /></td></tr>
<tr class="separator:af5d6e9275386dfefddb7a97248b039a7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ace12ebbb258f933e517255294f372795"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classipc_1_1transport_1_1sync__io_1_1Native__socket__stream_1_1Impl.html#ace12ebbb258f933e517255294f372795">receive_blob_max_size</a> () const</td></tr>
<tr class="memdesc:ace12ebbb258f933e517255294f372795"><td class="mdescLeft">&#160;</td><td class="mdescRight">See <a class="el" href="classipc_1_1transport_1_1sync__io_1_1Native__socket__stream.html" title="Implements both sync_io::Native_handle_sender and sync_io::Native_handle_receiver concepts by using a...">Native_socket_stream</a> counterpart.  <a href="classipc_1_1transport_1_1sync__io_1_1Native__socket__stream_1_1Impl.html#ace12ebbb258f933e517255294f372795">More...</a><br /></td></tr>
<tr class="separator:ace12ebbb258f933e517255294f372795"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4a94088b9f00288ae7e2cf3c7b49c444"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classipc_1_1transport_1_1sync__io_1_1Native__socket__stream_1_1Impl.html#a4a94088b9f00288ae7e2cf3c7b49c444">start_receive_native_handle_ops</a> (<a class="el" href="namespaceipc_1_1util_1_1sync__io.html#aa0b9a3cc6bdc7dedbef4f9e06851aa24">util::sync_io::Event_wait_func</a> &amp;&amp;ev_wait_func)</td></tr>
<tr class="memdesc:a4a94088b9f00288ae7e2cf3c7b49c444"><td class="mdescLeft">&#160;</td><td class="mdescRight">See <a class="el" href="classipc_1_1transport_1_1sync__io_1_1Native__socket__stream.html" title="Implements both sync_io::Native_handle_sender and sync_io::Native_handle_receiver concepts by using a...">Native_socket_stream</a> counterpart.  <a href="classipc_1_1transport_1_1sync__io_1_1Native__socket__stream_1_1Impl.html#a4a94088b9f00288ae7e2cf3c7b49c444">More...</a><br /></td></tr>
<tr class="separator:a4a94088b9f00288ae7e2cf3c7b49c444"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a12e99a2479fbf08b2fa32a2f17ed1ca7"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classipc_1_1transport_1_1sync__io_1_1Native__socket__stream_1_1Impl.html#a12e99a2479fbf08b2fa32a2f17ed1ca7">start_receive_blob_ops</a> (<a class="el" href="namespaceipc_1_1util_1_1sync__io.html#aa0b9a3cc6bdc7dedbef4f9e06851aa24">util::sync_io::Event_wait_func</a> &amp;&amp;ev_wait_func)</td></tr>
<tr class="memdesc:a12e99a2479fbf08b2fa32a2f17ed1ca7"><td class="mdescLeft">&#160;</td><td class="mdescRight">See <a class="el" href="classipc_1_1transport_1_1sync__io_1_1Native__socket__stream.html" title="Implements both sync_io::Native_handle_sender and sync_io::Native_handle_receiver concepts by using a...">Native_socket_stream</a> counterpart.  <a href="classipc_1_1transport_1_1sync__io_1_1Native__socket__stream_1_1Impl.html#a12e99a2479fbf08b2fa32a2f17ed1ca7">More...</a><br /></td></tr>
<tr class="separator:a12e99a2479fbf08b2fa32a2f17ed1ca7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa3b06f1d59f5635c81a99e4ae8f7b8c7"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classipc_1_1transport_1_1sync__io_1_1Native__socket__stream_1_1Impl.html#aa3b06f1d59f5635c81a99e4ae8f7b8c7">async_receive_native_handle</a> (<a class="el" href="namespaceipc_1_1transport.html#a7ee4551983d9df16ec16a3139bac50e8">Native_handle</a> *target_hndl, const <a class="el" href="namespaceipc_1_1util.html#a6cb62ae434900f3a8915b33ec5d61a96">util::Blob_mutable</a> &amp;target_meta_blob, <a class="el" href="namespaceipc.html#aa3192e586cc45d3e7c22463bf2760f89">Error_code</a> *sync_err_code, size_t *sync_sz, flow::async::Task_asio_err_sz &amp;&amp;on_done_func)</td></tr>
<tr class="memdesc:aa3b06f1d59f5635c81a99e4ae8f7b8c7"><td class="mdescLeft">&#160;</td><td class="mdescRight">See <a class="el" href="classipc_1_1transport_1_1sync__io_1_1Native__socket__stream.html" title="Implements both sync_io::Native_handle_sender and sync_io::Native_handle_receiver concepts by using a...">Native_socket_stream</a> counterpart.  <a href="classipc_1_1transport_1_1sync__io_1_1Native__socket__stream_1_1Impl.html#aa3b06f1d59f5635c81a99e4ae8f7b8c7">More...</a><br /></td></tr>
<tr class="separator:aa3b06f1d59f5635c81a99e4ae8f7b8c7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4c3d1ba7c70649898a7893daf076c7ae"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classipc_1_1transport_1_1sync__io_1_1Native__socket__stream_1_1Impl.html#a4c3d1ba7c70649898a7893daf076c7ae">async_receive_blob</a> (const <a class="el" href="namespaceipc_1_1util.html#a6cb62ae434900f3a8915b33ec5d61a96">util::Blob_mutable</a> &amp;target_blob, <a class="el" href="namespaceipc.html#aa3192e586cc45d3e7c22463bf2760f89">Error_code</a> *sync_err_code, size_t *sync_sz, flow::async::Task_asio_err_sz &amp;&amp;on_done_func)</td></tr>
<tr class="memdesc:a4c3d1ba7c70649898a7893daf076c7ae"><td class="mdescLeft">&#160;</td><td class="mdescRight">See <a class="el" href="classipc_1_1transport_1_1sync__io_1_1Native__socket__stream.html" title="Implements both sync_io::Native_handle_sender and sync_io::Native_handle_receiver concepts by using a...">Native_socket_stream</a> counterpart.  <a href="classipc_1_1transport_1_1sync__io_1_1Native__socket__stream_1_1Impl.html#a4c3d1ba7c70649898a7893daf076c7ae">More...</a><br /></td></tr>
<tr class="separator:a4c3d1ba7c70649898a7893daf076c7ae"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abedd0db5a5ae04e47085728ae548d07c"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classipc_1_1transport_1_1sync__io_1_1Native__socket__stream_1_1Impl.html#abedd0db5a5ae04e47085728ae548d07c">idle_timer_run</a> (<a class="el" href="namespaceipc_1_1util.html#ac66141280c3b7295a86b65209f31cc58">util::Fine_duration</a> timeout)</td></tr>
<tr class="memdesc:abedd0db5a5ae04e47085728ae548d07c"><td class="mdescLeft">&#160;</td><td class="mdescRight">See <a class="el" href="classipc_1_1transport_1_1sync__io_1_1Native__socket__stream.html" title="Implements both sync_io::Native_handle_sender and sync_io::Native_handle_receiver concepts by using a...">Native_socket_stream</a> counterpart.  <a href="classipc_1_1transport_1_1sync__io_1_1Native__socket__stream_1_1Impl.html#abedd0db5a5ae04e47085728ae548d07c">More...</a><br /></td></tr>
<tr class="separator:abedd0db5a5ae04e47085728ae548d07c"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-static-attribs" name="pub-static-attribs"></a>
Static Public Attributes</h2></td></tr>
<tr class="memitem:a7b825476c04ea53eccea862d34f830c6"><td class="memItemLeft" align="right" valign="top">static const size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classipc_1_1transport_1_1sync__io_1_1Native__socket__stream_1_1Impl.html#a7b825476c04ea53eccea862d34f830c6">S_MAX_META_BLOB_LENGTH</a> = <a class="el" href="classipc_1_1transport_1_1sync__io_1_1Native__socket__stream_1_1Impl.html#ad5e487595e2a58f7ff25b4f4c91fe4bc">S_META_BLOB_LENGTH_PING_SENTINEL</a> - 1</td></tr>
<tr class="memdesc:a7b825476c04ea53eccea862d34f830c6"><td class="mdescLeft">&#160;</td><td class="mdescRight">See <a class="el" href="classipc_1_1transport_1_1sync__io_1_1Native__socket__stream.html" title="Implements both sync_io::Native_handle_sender and sync_io::Native_handle_receiver concepts by using a...">Native_socket_stream</a> counterpart.  <a href="classipc_1_1transport_1_1sync__io_1_1Native__socket__stream_1_1Impl.html#a7b825476c04ea53eccea862d34f830c6">More...</a><br /></td></tr>
<tr class="separator:a7b825476c04ea53eccea862d34f830c6"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pri-types" name="pri-types"></a>
Private Types</h2></td></tr>
<tr class="memitem:a9c9825f74472868eb1397c33edf78fb4"><td class="memItemLeft" align="right" valign="top">enum class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classipc_1_1transport_1_1sync__io_1_1Native__socket__stream_1_1Impl.html#a9c9825f74472868eb1397c33edf78fb4">State</a> { <a class="el" href="classipc_1_1transport_1_1sync__io_1_1Native__socket__stream_1_1Impl.html#a9c9825f74472868eb1397c33edf78fb4ac6bd7568063494695099321f427efcb2">S_NULL</a>
, <a class="el" href="classipc_1_1transport_1_1sync__io_1_1Native__socket__stream_1_1Impl.html#a9c9825f74472868eb1397c33edf78fb4aae585d03fce4ac2011967830bf0ffbfb">S_CONNECTING</a>
, <a class="el" href="classipc_1_1transport_1_1sync__io_1_1Native__socket__stream_1_1Impl.html#a9c9825f74472868eb1397c33edf78fb4ad9a05d721258c584cd559c56fd035887">S_PEER</a>
 }</td></tr>
<tr class="memdesc:a9c9825f74472868eb1397c33edf78fb4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Overall state of a <a class="el" href="classipc_1_1transport_1_1sync__io_1_1Native__socket__stream_1_1Impl.html" title="Internal, non-movable pImpl implementation of sync_io::Native_socket_stream class.">Native_socket_stream::Impl</a>.  <a href="classipc_1_1transport_1_1sync__io_1_1Native__socket__stream_1_1Impl.html#a9c9825f74472868eb1397c33edf78fb4">More...</a><br /></td></tr>
<tr class="separator:a9c9825f74472868eb1397c33edf78fb4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0e765fbfee2c76293b572b01c9be5680"><td class="memItemLeft" align="right" valign="top">enum class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classipc_1_1transport_1_1sync__io_1_1Native__socket__stream_1_1Impl.html#a0e765fbfee2c76293b572b01c9be5680">Rcv_msg_state</a> { <a class="el" href="classipc_1_1transport_1_1sync__io_1_1Native__socket__stream_1_1Impl.html#a0e765fbfee2c76293b572b01c9be5680a89db9d0c66e2aa217b6106106d0e95a2">S_MSG_START</a>
, <a class="el" href="classipc_1_1transport_1_1sync__io_1_1Native__socket__stream_1_1Impl.html#a0e765fbfee2c76293b572b01c9be5680a3249b7cad0ab1d3cc8e9960568a412ae">S_HEAD_PAYLOAD</a>
, <a class="el" href="classipc_1_1transport_1_1sync__io_1_1Native__socket__stream_1_1Impl.html#a0e765fbfee2c76293b572b01c9be5680afd393481cb76843d8c7ab099451efaf1">S_META_BLOB_PAYLOAD</a>
 }</td></tr>
<tr class="memdesc:a0e765fbfee2c76293b572b01c9be5680"><td class="mdescLeft">&#160;</td><td class="mdescRight">Used to organize tje incoming-direction state machine tactically, this indicates what part of payload 1 ("head payload," mandatory) or payload 2 ("meta-blob payload," optional) we are currently reading, based on the next byte to be read.  <a href="classipc_1_1transport_1_1sync__io_1_1Native__socket__stream_1_1Impl.html#a0e765fbfee2c76293b572b01c9be5680">More...</a><br /></td></tr>
<tr class="separator:a0e765fbfee2c76293b572b01c9be5680"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac5471d1f4f7cad2aeb239b5f458f12f2"><td class="memItemLeft" align="right" valign="top">enum class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classipc_1_1transport_1_1sync__io_1_1Native__socket__stream_1_1Impl.html#ac5471d1f4f7cad2aeb239b5f458f12f2">Op</a> { <b>S_SND</b>
, <b>S_RCV</b>
, <b>S_CONN</b>
 }</td></tr>
<tr class="memdesc:ac5471d1f4f7cad2aeb239b5f458f12f2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compile-time tagging enumeration identifying the op-type of a given <code><a class="el" href="namespaceipc_1_1transport_1_1sync__io.html" title="sync_io-pattern counterparts to async-I/O-pattern object types in parent namespace ipc::transport.">sync_io</a></code> activity.  <a href="classipc_1_1transport_1_1sync__io_1_1Native__socket__stream_1_1Impl.html#ac5471d1f4f7cad2aeb239b5f458f12f2">More...</a><br /></td></tr>
<tr class="separator:ac5471d1f4f7cad2aeb239b5f458f12f2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a881c376f1ee37f9b1a20f770824f55d9"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classipc_1_1transport_1_1sync__io_1_1Native__socket__stream_1_1Impl.html#a881c376f1ee37f9b1a20f770824f55d9">low_lvl_payload_blob_length_t</a> = uint16_t</td></tr>
<tr class="memdesc:a881c376f1ee37f9b1a20f770824f55d9"><td class="mdescLeft">&#160;</td><td class="mdescRight">The type used to encode the meta-blob length; this puts a cap on how long the meta-blobs can be.  <a href="classipc_1_1transport_1_1sync__io_1_1Native__socket__stream_1_1Impl.html#a881c376f1ee37f9b1a20f770824f55d9">More...</a><br /></td></tr>
<tr class="separator:a881c376f1ee37f9b1a20f770824f55d9"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pri-methods" name="pri-methods"></a>
Private Member Functions</h2></td></tr>
<tr class="memitem:ae43a7982c98b4eb6501e7f74f3f6fa04"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classipc_1_1transport_1_1sync__io_1_1Native__socket__stream_1_1Impl.html#ae43a7982c98b4eb6501e7f74f3f6fa04">Impl</a> (flow::log::Logger *logger_ptr, <a class="el" href="namespaceipc_1_1util.html#ae6ac47812a90d1287c61e0b7de7bc4f5">util::String_view</a> nickname_str, std::nullptr_t tag)</td></tr>
<tr class="memdesc:ae43a7982c98b4eb6501e7f74f3f6fa04"><td class="mdescLeft">&#160;</td><td class="mdescRight">Helper delegated-to ctor that sets up everything except <a class="el" href="classipc_1_1transport_1_1sync__io_1_1Native__socket__stream_1_1Impl.html#a42aab631e9c70bfaa53764309adfe37c" title="The peer stream-type Unix domain socket; or null pointer if we&#39;ve detected the connection has become ...">m_peer_socket</a> (left null) and <a class="el" href="classipc_1_1transport_1_1sync__io_1_1Native__socket__stream_1_1Impl.html#a0ac6a82eda9256cba45f3b5365d79355" title="Descriptor waitable by outside event loop async-waits â€“ storing the same Native_handle as (and thus b...">m_ev_wait_hndl_peer_socket</a> (left holding no native handle); and sets NULL <a class="el" href="classipc_1_1transport_1_1sync__io_1_1Native__socket__stream_1_1Impl.html#a64e47a38b3ed59e37295336114918142" title="The current state of *this.">m_state</a>; the real ctor shall set both of them to their real initial values.  <a href="classipc_1_1transport_1_1sync__io_1_1Native__socket__stream_1_1Impl.html#ae43a7982c98b4eb6501e7f74f3f6fa04">More...</a><br /></td></tr>
<tr class="separator:ae43a7982c98b4eb6501e7f74f3f6fa04"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3c6214376ab8bc59823635d405f9704a"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classipc_1_1transport_1_1sync__io_1_1Native__socket__stream_1_1Impl.html#a3c6214376ab8bc59823635d405f9704a">start_connect_ops</a> (<a class="el" href="namespaceipc_1_1util_1_1sync__io.html#aa0b9a3cc6bdc7dedbef4f9e06851aa24">util::sync_io::Event_wait_func</a> &amp;&amp;ev_wait_func)</td></tr>
<tr class="memdesc:a3c6214376ab8bc59823635d405f9704a"><td class="mdescLeft">&#160;</td><td class="mdescRight">It is <code>start_ops&lt;Op::S_CONN&gt;()</code>.  <a href="classipc_1_1transport_1_1sync__io_1_1Native__socket__stream_1_1Impl.html#a3c6214376ab8bc59823635d405f9704a">More...</a><br /></td></tr>
<tr class="separator:a3c6214376ab8bc59823635d405f9704a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad6443fb49be059dbe76c75d86a18197e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classipc_1_1transport_1_1sync__io_1_1Native__socket__stream_1_1Impl.html#ad6443fb49be059dbe76c75d86a18197e">async_connect</a> (const <a class="el" href="namespaceipc_1_1transport.html#a33de1c256addb3964b839dc2dd407d24">Shared_name</a> &amp;absolute_name, <a class="el" href="namespaceipc.html#aa3192e586cc45d3e7c22463bf2760f89">Error_code</a> *sync_err_code, flow::async::Task_asio_err &amp;&amp;on_done_func)</td></tr>
<tr class="memdesc:ad6443fb49be059dbe76c75d86a18197e"><td class="mdescLeft">&#160;</td><td class="mdescRight">The core of <a class="el" href="classipc_1_1transport_1_1sync__io_1_1Native__socket__stream_1_1Impl.html#a3c5187e34876a0419ff70734ec0fbf14" title="See Native_socket_stream counterpart.">sync_connect()</a>, written in the <code><a class="el" href="namespaceipc_1_1transport_1_1sync__io.html" title="sync_io-pattern counterparts to async-I/O-pattern object types in parent namespace ipc::transport.">sync_io</a></code>-pattern style.  <a href="classipc_1_1transport_1_1sync__io_1_1Native__socket__stream_1_1Impl.html#ad6443fb49be059dbe76c75d86a18197e">More...</a><br /></td></tr>
<tr class="separator:ad6443fb49be059dbe76c75d86a18197e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaf965dc1eea3bee807c2fb6c4a937bb5"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classipc_1_1transport_1_1sync__io_1_1Native__socket__stream_1_1Impl.html#aaf965dc1eea3bee807c2fb6c4a937bb5">conn_on_ev_peer_socket_writable</a> (flow::async::Task_asio_err &amp;&amp;on_done_func)</td></tr>
<tr class="memdesc:aaf965dc1eea3bee807c2fb6c4a937bb5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Handler for the async-wait in case <a class="el" href="classipc_1_1transport_1_1sync__io_1_1Native__socket__stream_1_1Impl.html#ad6443fb49be059dbe76c75d86a18197e" title="The core of sync_connect(), written in the sync_io-pattern style.">async_connect()</a> cannot synchronously complete the <a class="el" href="classipc_1_1transport_1_1sync__io_1_1Native__socket__stream_1_1Impl.html#a42aab631e9c70bfaa53764309adfe37c" title="The peer stream-type Unix domain socket; or null pointer if we&#39;ve detected the connection has become ...">m_peer_socket</a> connect (boost.asio yields would-block).  <a href="classipc_1_1transport_1_1sync__io_1_1Native__socket__stream_1_1Impl.html#aaf965dc1eea3bee807c2fb6c4a937bb5">More...</a><br /></td></tr>
<tr class="separator:aaf965dc1eea3bee807c2fb6c4a937bb5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6337b0d5d703f124def66853e36b62e5"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classipc_1_1transport_1_1sync__io_1_1Native__socket__stream_1_1Impl.html#a6337b0d5d703f124def66853e36b62e5">async_end_sending_impl</a> (<a class="el" href="namespaceipc.html#aa3192e586cc45d3e7c22463bf2760f89">Error_code</a> *sync_err_code_ptr_or_null, flow::async::Task_asio_err &amp;&amp;on_done_func_or_empty)</td></tr>
<tr class="memdesc:a6337b0d5d703f124def66853e36b62e5"><td class="mdescLeft">&#160;</td><td class="mdescRight"><code>*end_sending()</code> body.  <a href="classipc_1_1transport_1_1sync__io_1_1Native__socket__stream_1_1Impl.html#a6337b0d5d703f124def66853e36b62e5">More...</a><br /></td></tr>
<tr class="separator:a6337b0d5d703f124def66853e36b62e5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4b31da3a7ff63f307bd08e288c391556"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classipc_1_1transport_1_1sync__io_1_1Native__socket__stream_1_1Impl.html#a4b31da3a7ff63f307bd08e288c391556">snd_on_ev_auto_ping_now_timer_fired</a> ()</td></tr>
<tr class="memdesc:a4b31da3a7ff63f307bd08e288c391556"><td class="mdescLeft">&#160;</td><td class="mdescRight">Handler for the async-wait, via <a class="el" href="classipc_1_1util_1_1sync__io_1_1Timer__event__emitter.html" title="An object of this type, used internally to implement sync_io-pattern objects that require timer event...">util::sync_io::Timer_event_emitter</a>, of the auto-ping timer firing; if all is cool, sends auto-ping and schedules the next such async-wait.  <a href="classipc_1_1transport_1_1sync__io_1_1Native__socket__stream_1_1Impl.html#a4b31da3a7ff63f307bd08e288c391556">More...</a><br /></td></tr>
<tr class="separator:a4b31da3a7ff63f307bd08e288c391556"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3c1c949f345f0ceef5eeca3c2edec291"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classipc_1_1transport_1_1sync__io_1_1Native__socket__stream_1_1Impl.html#a3c1c949f345f0ceef5eeca3c2edec291">snd_sync_write_or_q_payload</a> (<a class="el" href="namespaceipc_1_1transport.html#a7ee4551983d9df16ec16a3139bac50e8">Native_handle</a> hndl_or_null, const <a class="el" href="namespaceipc_1_1util.html#ae0be7edba7e30ffa3f8b742af621f2ab">util::Blob_const</a> &amp;orig_blob, bool avoid_qing)</td></tr>
<tr class="memdesc:a3c1c949f345f0ceef5eeca3c2edec291"><td class="mdescLeft">&#160;</td><td class="mdescRight">Either synchronously sends <code>hndl_or_null</code> handle (if any) and <code>orig_blob</code> low-level blob over <a class="el" href="classipc_1_1transport_1_1sync__io_1_1Native__socket__stream_1_1Impl.html#a42aab631e9c70bfaa53764309adfe37c" title="The peer stream-type Unix domain socket; or null pointer if we&#39;ve detected the connection has become ...">m_peer_socket</a>, or if an async-send is in progress queues both to be sent later; in the former case any unsent trailing portion of the payload is queued and async-sent via <a class="el" href="classipc_1_1transport_1_1sync__io_1_1Native__socket__stream_1_1Impl.html#a5e9ed53ef25f4413c8da315f8dbcff2c" title="Initiates async-write over m_peer_socket of the low-level payload at the head of out-queue m_snd_pend...">snd_async_write_q_head_payload()</a>, with dropping-sans-queuing allowed under certain circumstances in <code>avoid_qing</code> mode.  <a href="classipc_1_1transport_1_1sync__io_1_1Native__socket__stream_1_1Impl.html#a3c1c949f345f0ceef5eeca3c2edec291">More...</a><br /></td></tr>
<tr class="separator:a3c1c949f345f0ceef5eeca3c2edec291"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5e9ed53ef25f4413c8da315f8dbcff2c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classipc_1_1transport_1_1sync__io_1_1Native__socket__stream_1_1Impl.html#a5e9ed53ef25f4413c8da315f8dbcff2c">snd_async_write_q_head_payload</a> ()</td></tr>
<tr class="memdesc:a5e9ed53ef25f4413c8da315f8dbcff2c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initiates async-write over <a class="el" href="classipc_1_1transport_1_1sync__io_1_1Native__socket__stream_1_1Impl.html#a42aab631e9c70bfaa53764309adfe37c" title="The peer stream-type Unix domain socket; or null pointer if we&#39;ve detected the connection has become ...">m_peer_socket</a> of the low-level payload at the head of out-queue <a class="el" href="classipc_1_1transport_1_1sync__io_1_1Native__socket__stream_1_1Impl.html#a1af9eb83b9afee25ba153a2ca066858d" title="Queue storing (at head) the currently in-progress async write-op of a Snd_low_lvl_payload; followed b...">m_snd_pending_payloads_q</a>, with completion handler <a class="el" href="classipc_1_1transport_1_1sync__io_1_1Native__socket__stream_1_1Impl.html#a2c2b11477fb5089af7608c45dec939c0" title="Completion handler, from outside event loop via sync_io pattern, for the async-wait initiated by snd_...">snd_on_ev_peer_socket_writable_or_error()</a>.  <a href="classipc_1_1transport_1_1sync__io_1_1Native__socket__stream_1_1Impl.html#a5e9ed53ef25f4413c8da315f8dbcff2c">More...</a><br /></td></tr>
<tr class="separator:a5e9ed53ef25f4413c8da315f8dbcff2c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2c2b11477fb5089af7608c45dec939c0"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classipc_1_1transport_1_1sync__io_1_1Native__socket__stream_1_1Impl.html#a2c2b11477fb5089af7608c45dec939c0">snd_on_ev_peer_socket_writable_or_error</a> ()</td></tr>
<tr class="memdesc:a2c2b11477fb5089af7608c45dec939c0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Completion handler, from outside event loop via <code><a class="el" href="namespaceipc_1_1transport_1_1sync__io.html" title="sync_io-pattern counterparts to async-I/O-pattern object types in parent namespace ipc::transport.">sync_io</a></code> pattern, for the async-wait initiated by <a class="el" href="classipc_1_1transport_1_1sync__io_1_1Native__socket__stream_1_1Impl.html#a5e9ed53ef25f4413c8da315f8dbcff2c" title="Initiates async-write over m_peer_socket of the low-level payload at the head of out-queue m_snd_pend...">snd_async_write_q_head_payload()</a>.  <a href="classipc_1_1transport_1_1sync__io_1_1Native__socket__stream_1_1Impl.html#a2c2b11477fb5089af7608c45dec939c0">More...</a><br /></td></tr>
<tr class="separator:a2c2b11477fb5089af7608c45dec939c0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af321a9b3ed8dc21f23988bf79c7c33f0"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classipc_1_1transport_1_1sync__io_1_1Native__socket__stream_1_1Impl.html#af321a9b3ed8dc21f23988bf79c7c33f0">snd_nb_write_low_lvl_payload</a> (<a class="el" href="namespaceipc_1_1transport.html#a7ee4551983d9df16ec16a3139bac50e8">Native_handle</a> hndl_or_null, const <a class="el" href="namespaceipc_1_1util.html#ae0be7edba7e30ffa3f8b742af621f2ab">util::Blob_const</a> &amp;blob, <a class="el" href="namespaceipc.html#aa3192e586cc45d3e7c22463bf2760f89">Error_code</a> *err_code)</td></tr>
<tr class="memdesc:af321a9b3ed8dc21f23988bf79c7c33f0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Utility that sends non-empty <code>blob</code>, and (unless null) <code>hndl_or_null</code> associated with its 1st byte, synchronously to the maximum extent possible without blocking, over <a class="el" href="classipc_1_1transport_1_1sync__io_1_1Native__socket__stream_1_1Impl.html#a42aab631e9c70bfaa53764309adfe37c" title="The peer stream-type Unix domain socket; or null pointer if we&#39;ve detected the connection has become ...">m_peer_socket</a>.  <a href="classipc_1_1transport_1_1sync__io_1_1Native__socket__stream_1_1Impl.html#af321a9b3ed8dc21f23988bf79c7c33f0">More...</a><br /></td></tr>
<tr class="separator:af321a9b3ed8dc21f23988bf79c7c33f0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a53b356e756923271fbb9b7a7beb8f54a"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classipc_1_1transport_1_1sync__io_1_1Native__socket__stream_1_1Impl.html#a53b356e756923271fbb9b7a7beb8f54a">rcv_on_ev_idle_timer_fired</a> ()</td></tr>
<tr class="memdesc:a53b356e756923271fbb9b7a7beb8f54a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Handler for the async-wait, via <a class="el" href="classipc_1_1util_1_1sync__io_1_1Timer__event__emitter.html" title="An object of this type, used internally to implement sync_io-pattern objects that require timer event...">util::sync_io::Timer_event_emitter</a>, of the idle timer firing; if still relevant it records the idle-timeout error in <a class="el" href="classipc_1_1transport_1_1sync__io_1_1Native__socket__stream_1_1Impl.html#ab824da16816893b2ffe2e778a7169b62" title="The first and only connection-hosing error condition detected when attempting to low-level-read on m_...">m_rcv_pending_err_code</a>; and if an <a class="el" href="classipc_1_1transport_1_1sync__io_1_1Native__socket__stream_1_1Impl.html#ae16d560bf3c4eccfa975d47af71cb145" title="Body of both async_receive_native_handle() and async_receive_blob().">async_receive_native_handle_impl()</a> is in progress (awaiting data via async-wait), it completes that operation with the appropriate idle-timeout error (completion handler in <a class="el" href="classipc_1_1transport_1_1sync__io_1_1Native__socket__stream_1_1Impl.html#a9098de978da64572c419019597274d68" title="Null if no async_receive_*() is currently pending; else describes the arguments to that pending async...">m_rcv_user_request</a> runs synchronously).  <a href="classipc_1_1transport_1_1sync__io_1_1Native__socket__stream_1_1Impl.html#a53b356e756923271fbb9b7a7beb8f54a">More...</a><br /></td></tr>
<tr class="separator:a53b356e756923271fbb9b7a7beb8f54a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adff873e21beee6c31a552293d8b0004c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classipc_1_1transport_1_1sync__io_1_1Native__socket__stream_1_1Impl.html#adff873e21beee6c31a552293d8b0004c">rcv_not_idle</a> ()</td></tr>
<tr class="memdesc:adff873e21beee6c31a552293d8b0004c"><td class="mdescLeft">&#160;</td><td class="mdescRight">No-ops if <a class="el" href="classipc_1_1transport_1_1sync__io_1_1Native__socket__stream_1_1Impl.html#abedd0db5a5ae04e47085728ae548d07c" title="See Native_socket_stream counterpart.">idle_timer_run()</a> is not engaged; otherwise reacts to non-idleness of the in-pipe by rescheduling idle timer to occur in <a class="el" href="classipc_1_1transport_1_1sync__io_1_1Native__socket__stream_1_1Impl.html#ada7f2368dc0591f7a903946201c83636" title="timeout from idle_timer_run() args; or zero() if not yet called.">m_rcv_idle_timeout</a> again.  <a href="classipc_1_1transport_1_1sync__io_1_1Native__socket__stream_1_1Impl.html#adff873e21beee6c31a552293d8b0004c">More...</a><br /></td></tr>
<tr class="separator:adff873e21beee6c31a552293d8b0004c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae16d560bf3c4eccfa975d47af71cb145"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classipc_1_1transport_1_1sync__io_1_1Native__socket__stream_1_1Impl.html#ae16d560bf3c4eccfa975d47af71cb145">async_receive_native_handle_impl</a> (<a class="el" href="namespaceipc_1_1transport.html#a7ee4551983d9df16ec16a3139bac50e8">Native_handle</a> *target_hndl_or_null, const <a class="el" href="namespaceipc_1_1util.html#a6cb62ae434900f3a8915b33ec5d61a96">util::Blob_mutable</a> &amp;target_meta_blob, <a class="el" href="namespaceipc.html#aa3192e586cc45d3e7c22463bf2760f89">Error_code</a> *sync_err_code, size_t *sync_sz, flow::async::Task_asio_err_sz &amp;&amp;on_done_func)</td></tr>
<tr class="memdesc:ae16d560bf3c4eccfa975d47af71cb145"><td class="mdescLeft">&#160;</td><td class="mdescRight">Body of both <a class="el" href="classipc_1_1transport_1_1sync__io_1_1Native__socket__stream_1_1Impl.html#aa3b06f1d59f5635c81a99e4ae8f7b8c7" title="See Native_socket_stream counterpart.">async_receive_native_handle()</a> and <a class="el" href="classipc_1_1transport_1_1sync__io_1_1Native__socket__stream_1_1Impl.html#a4c3d1ba7c70649898a7893daf076c7ae" title="See Native_socket_stream counterpart.">async_receive_blob()</a>.  <a href="classipc_1_1transport_1_1sync__io_1_1Native__socket__stream_1_1Impl.html#ae16d560bf3c4eccfa975d47af71cb145">More...</a><br /></td></tr>
<tr class="separator:ae16d560bf3c4eccfa975d47af71cb145"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa8c4ec6715dc5c437ed285cfea600b46"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classipc_1_1transport_1_1sync__io_1_1Native__socket__stream_1_1Impl.html#aa8c4ec6715dc5c437ed285cfea600b46">rcv_read_msg</a> (<a class="el" href="namespaceipc.html#aa3192e586cc45d3e7c22463bf2760f89">Error_code</a> *sync_err_code, size_t *sync_sz)</td></tr>
<tr class="memdesc:aa8c4ec6715dc5c437ed285cfea600b46"><td class="mdescLeft">&#160;</td><td class="mdescRight">Begins read chain (completing it as synchronously as possible, async-completing the rest) for the next in-message.  <a href="classipc_1_1transport_1_1sync__io_1_1Native__socket__stream_1_1Impl.html#aa8c4ec6715dc5c437ed285cfea600b46">More...</a><br /></td></tr>
<tr class="separator:aa8c4ec6715dc5c437ed285cfea600b46"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0ba676425c97ae496255a155f41943f8"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classipc_1_1transport_1_1sync__io_1_1Native__socket__stream_1_1Impl.html#a0ba676425c97ae496255a155f41943f8">rcv_read_blob</a> (<a class="el" href="classipc_1_1transport_1_1sync__io_1_1Native__socket__stream_1_1Impl.html#a0e765fbfee2c76293b572b01c9be5680">Rcv_msg_state</a> msg_state, const <a class="el" href="namespaceipc_1_1util.html#a6cb62ae434900f3a8915b33ec5d61a96">util::Blob_mutable</a> &amp;target_blob, <a class="el" href="namespaceipc.html#aa3192e586cc45d3e7c22463bf2760f89">Error_code</a> *sync_err_code, size_t *sync_sz)</td></tr>
<tr class="memdesc:a0ba676425c97ae496255a155f41943f8"><td class="mdescLeft">&#160;</td><td class="mdescRight">A somewhat-general utility that continues read chain with the aim to complete the present in-message, with the pre-condition (among others) that (1) there is no known would-block condition on the in-pipe, and (2) at least byte 1 + the handle-or-not within payload 1 have already been acquired.  <a href="classipc_1_1transport_1_1sync__io_1_1Native__socket__stream_1_1Impl.html#a0ba676425c97ae496255a155f41943f8">More...</a><br /></td></tr>
<tr class="separator:a0ba676425c97ae496255a155f41943f8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa342b6f0c7e2015517a5c465e4963fc7"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classipc_1_1transport_1_1sync__io_1_1Native__socket__stream_1_1Impl.html#aa342b6f0c7e2015517a5c465e4963fc7">rcv_on_handle_finalized</a> (<a class="el" href="namespaceipc_1_1transport.html#a7ee4551983d9df16ec16a3139bac50e8">Native_handle</a> hndl_or_null, size_t n_rcvd, <a class="el" href="namespaceipc.html#aa3192e586cc45d3e7c22463bf2760f89">Error_code</a> *sync_err_code, size_t *sync_sz)</td></tr>
<tr class="memdesc:aa342b6f0c7e2015517a5c465e4963fc7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Helper of <a class="el" href="classipc_1_1transport_1_1sync__io_1_1Native__socket__stream_1_1Impl.html#aa8c4ec6715dc5c437ed285cfea600b46" title="Begins read chain (completing it as synchronously as possible, async-completing the rest) for the nex...">rcv_read_msg()</a> &ndash; it could have been inlined instead of a method but for readability concerns &ndash; that reacts to that guy's initial nb-read (into <code>Native_handle</code> + leading bytes of payload 1 blob) getting at least 1 byte (and therefore the <code>Native_handle</code> if any).  <a href="classipc_1_1transport_1_1sync__io_1_1Native__socket__stream_1_1Impl.html#aa342b6f0c7e2015517a5c465e4963fc7">More...</a><br /></td></tr>
<tr class="separator:aa342b6f0c7e2015517a5c465e4963fc7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3b6b76dfbddc562ece4f64742ff6d2c7"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classipc_1_1transport_1_1sync__io_1_1Native__socket__stream_1_1Impl.html#a3b6b76dfbddc562ece4f64742ff6d2c7">rcv_on_head_payload</a> (<a class="el" href="namespaceipc.html#aa3192e586cc45d3e7c22463bf2760f89">Error_code</a> *sync_err_code, size_t *sync_sz)</td></tr>
<tr class="memdesc:a3b6b76dfbddc562ece4f64742ff6d2c7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reacts to payload 1 having been completely received.  <a href="classipc_1_1transport_1_1sync__io_1_1Native__socket__stream_1_1Impl.html#a3b6b76dfbddc562ece4f64742ff6d2c7">More...</a><br /></td></tr>
<tr class="separator:a3b6b76dfbddc562ece4f64742ff6d2c7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af324ad8945ab79d74e937e9c38c2fbb5"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classipc_1_1transport_1_1sync__io_1_1Native__socket__stream_1_1Impl.html#af324ad8945ab79d74e937e9c38c2fbb5">rcv_on_ev_peer_socket_readable_or_error</a> (<a class="el" href="classipc_1_1transport_1_1sync__io_1_1Native__socket__stream_1_1Impl.html#a0e765fbfee2c76293b572b01c9be5680">Rcv_msg_state</a> msg_state, size_t n_left)</td></tr>
<tr class="memdesc:af324ad8945ab79d74e937e9c38c2fbb5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Completion handler, from outside event loop via <code><a class="el" href="namespaceipc_1_1transport_1_1sync__io.html" title="sync_io-pattern counterparts to async-I/O-pattern object types in parent namespace ipc::transport.">sync_io</a></code> pattern, for the async-wait initiated by various <code>rcv_*()</code> methods trying to get to the goal of obtaining a complete in-message.  <a href="classipc_1_1transport_1_1sync__io_1_1Native__socket__stream_1_1Impl.html#af324ad8945ab79d74e937e9c38c2fbb5">More...</a><br /></td></tr>
<tr class="separator:af324ad8945ab79d74e937e9c38c2fbb5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a25e051170a8eb568745f809bb186f980"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classipc_1_1transport_1_1sync__io_1_1Native__socket__stream_1_1Impl.html#a25e051170a8eb568745f809bb186f980">rcv_nb_read_low_lvl_payload</a> (<a class="el" href="namespaceipc_1_1transport.html#a7ee4551983d9df16ec16a3139bac50e8">Native_handle</a> *target_payload_hndl_or_null, const <a class="el" href="namespaceipc_1_1util.html#a6cb62ae434900f3a8915b33ec5d61a96">util::Blob_mutable</a> &amp;target_payload_blob, <a class="el" href="namespaceipc.html#aa3192e586cc45d3e7c22463bf2760f89">Error_code</a> *err_code)</td></tr>
<tr class="memdesc:a25e051170a8eb568745f809bb186f980"><td class="mdescLeft">&#160;</td><td class="mdescRight">Utility that synchronously, non-blockingly attempts to read over <a class="el" href="classipc_1_1transport_1_1sync__io_1_1Native__socket__stream_1_1Impl.html#a42aab631e9c70bfaa53764309adfe37c" title="The peer stream-type Unix domain socket; or null pointer if we&#39;ve detected the connection has become ...">m_peer_socket</a> into the target blob and (optionally) <code>Native_handle</code> (nullifying it if not present), reporting error or would-block if encountered.  <a href="classipc_1_1transport_1_1sync__io_1_1Native__socket__stream_1_1Impl.html#a25e051170a8eb568745f809bb186f980">More...</a><br /></td></tr>
<tr class="separator:a25e051170a8eb568745f809bb186f980"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a18de125ad318ba69cee7d8cb8204ad12"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classipc_1_1transport_1_1sync__io_1_1Native__socket__stream_1_1Impl.html#a18de125ad318ba69cee7d8cb8204ad12">state_peer</a> (<a class="el" href="namespaceipc_1_1util.html#ae6ac47812a90d1287c61e0b7de7bc4f5">util::String_view</a> context) const</td></tr>
<tr class="memdesc:a18de125ad318ba69cee7d8cb8204ad12"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks whether <a class="el" href="classipc_1_1transport_1_1sync__io_1_1Native__socket__stream_1_1Impl.html#a64e47a38b3ed59e37295336114918142" title="The current state of *this.">m_state</a> has reached <a class="el" href="classipc_1_1transport_1_1sync__io_1_1Native__socket__stream_1_1Impl.html#a9c9825f74472868eb1397c33edf78fb4ad9a05d721258c584cd559c56fd035887" title="Is or was a connected peer.">State::S_PEER</a>; if so returns <code>true</code>; if not logs WARNING and returns <code>false</code>.  <a href="classipc_1_1transport_1_1sync__io_1_1Native__socket__stream_1_1Impl.html#a18de125ad318ba69cee7d8cb8204ad12">More...</a><br /></td></tr>
<tr class="separator:a18de125ad318ba69cee7d8cb8204ad12"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3c1ea07348e9e1cd7ff6c8dbdca290d9"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="classipc_1_1transport_1_1sync__io_1_1Native__socket__stream_1_1Impl.html#ac5471d1f4f7cad2aeb239b5f458f12f2">Op</a> OP&gt; </td></tr>
<tr class="memitem:a3c1ea07348e9e1cd7ff6c8dbdca290d9"><td class="memTemplItemLeft" align="right" valign="top">const <a class="el" href="namespaceipc_1_1util_1_1sync__io.html#aa0b9a3cc6bdc7dedbef4f9e06851aa24">util::sync_io::Event_wait_func</a> *&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classipc_1_1transport_1_1sync__io_1_1Native__socket__stream_1_1Impl.html#a3c1ea07348e9e1cd7ff6c8dbdca290d9">sync_io_ev_wait_func</a> () const</td></tr>
<tr class="memdesc:a3c1ea07348e9e1cd7ff6c8dbdca290d9"><td class="mdescLeft">&#160;</td><td class="mdescRight">For boiler-plate-reducing generic code: Returns the <code>m_*_ev_wait_func</code> corresponding to the given Op.  <a href="classipc_1_1transport_1_1sync__io_1_1Native__socket__stream_1_1Impl.html#a3c1ea07348e9e1cd7ff6c8dbdca290d9">More...</a><br /></td></tr>
<tr class="separator:a3c1ea07348e9e1cd7ff6c8dbdca290d9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6c55ac2f7dad90d23bbd878e753ff791"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="classipc_1_1transport_1_1sync__io_1_1Native__socket__stream_1_1Impl.html#ac5471d1f4f7cad2aeb239b5f458f12f2">Op</a> OP&gt; </td></tr>
<tr class="memitem:a6c55ac2f7dad90d23bbd878e753ff791"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="namespaceipc_1_1util_1_1sync__io.html#aa0b9a3cc6bdc7dedbef4f9e06851aa24">util::sync_io::Event_wait_func</a> *&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classipc_1_1transport_1_1sync__io_1_1Native__socket__stream_1_1Impl.html#a6c55ac2f7dad90d23bbd878e753ff791">sync_io_ev_wait_func</a> ()</td></tr>
<tr class="memdesc:a6c55ac2f7dad90d23bbd878e753ff791"><td class="mdescLeft">&#160;</td><td class="mdescRight"><code>const</code> version of the other overload.  <a href="classipc_1_1transport_1_1sync__io_1_1Native__socket__stream_1_1Impl.html#a6c55ac2f7dad90d23bbd878e753ff791">More...</a><br /></td></tr>
<tr class="separator:a6c55ac2f7dad90d23bbd878e753ff791"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7457705b8f6e8fc6c73dd758e593c7a9"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="classipc_1_1transport_1_1sync__io_1_1Native__socket__stream_1_1Impl.html#ac5471d1f4f7cad2aeb239b5f458f12f2">Op</a> OP&gt; </td></tr>
<tr class="memitem:a7457705b8f6e8fc6c73dd758e593c7a9"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classipc_1_1transport_1_1sync__io_1_1Native__socket__stream_1_1Impl.html#a7457705b8f6e8fc6c73dd758e593c7a9">op_started</a> (<a class="el" href="namespaceipc_1_1util.html#ae6ac47812a90d1287c61e0b7de7bc4f5">util::String_view</a> context) const</td></tr>
<tr class="memdesc:a7457705b8f6e8fc6c73dd758e593c7a9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Helper that returns <code>true</code> silently if the given Op <code>start_*_ops()</code> has been called; else logs WARNING and returns <code>false</code>.  <a href="classipc_1_1transport_1_1sync__io_1_1Native__socket__stream_1_1Impl.html#a7457705b8f6e8fc6c73dd758e593c7a9">More...</a><br /></td></tr>
<tr class="separator:a7457705b8f6e8fc6c73dd758e593c7a9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7065a2f2c759cc9e66d46c613e628a96"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="classipc_1_1transport_1_1sync__io_1_1Native__socket__stream_1_1Impl.html#ac5471d1f4f7cad2aeb239b5f458f12f2">Op</a> OP&gt; </td></tr>
<tr class="memitem:a7065a2f2c759cc9e66d46c613e628a96"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classipc_1_1transport_1_1sync__io_1_1Native__socket__stream_1_1Impl.html#a7065a2f2c759cc9e66d46c613e628a96">start_ops</a> (<a class="el" href="namespaceipc_1_1util_1_1sync__io.html#aa0b9a3cc6bdc7dedbef4f9e06851aa24">util::sync_io::Event_wait_func</a> &amp;&amp;ev_wait_func)</td></tr>
<tr class="memdesc:a7065a2f2c759cc9e66d46c613e628a96"><td class="mdescLeft">&#160;</td><td class="mdescRight">Boiler-plate-reducing body of <code>start_*_ops()</code> for the given Op.  <a href="classipc_1_1transport_1_1sync__io_1_1Native__socket__stream_1_1Impl.html#a7065a2f2c759cc9e66d46c613e628a96">More...</a><br /></td></tr>
<tr class="separator:a7065a2f2c759cc9e66d46c613e628a96"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pri-attribs" name="pri-attribs"></a>
Private Attributes</h2></td></tr>
<tr class="memitem:a1374593e1cecd44ccb07d939f3673a35"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classipc_1_1transport_1_1sync__io_1_1Native__socket__stream_1_1Impl.html#a1374593e1cecd44ccb07d939f3673a35">m_nickname</a></td></tr>
<tr class="memdesc:a1374593e1cecd44ccb07d939f3673a35"><td class="mdescLeft">&#160;</td><td class="mdescRight">See <a class="el" href="classipc_1_1transport_1_1sync__io_1_1Native__socket__stream_1_1Impl.html#a0ddd1b1e57bc61827d457e16e3db8600" title="See Native_socket_stream counterpart.">nickname()</a>.  <a href="classipc_1_1transport_1_1sync__io_1_1Native__socket__stream_1_1Impl.html#a1374593e1cecd44ccb07d939f3673a35">More...</a><br /></td></tr>
<tr class="separator:a1374593e1cecd44ccb07d939f3673a35"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a64e47a38b3ed59e37295336114918142"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classipc_1_1transport_1_1sync__io_1_1Native__socket__stream_1_1Impl.html#a9c9825f74472868eb1397c33edf78fb4">State</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classipc_1_1transport_1_1sync__io_1_1Native__socket__stream_1_1Impl.html#a64e47a38b3ed59e37295336114918142">m_state</a></td></tr>
<tr class="memdesc:a64e47a38b3ed59e37295336114918142"><td class="mdescLeft">&#160;</td><td class="mdescRight">The current state of <code>*this</code>.  <a href="classipc_1_1transport_1_1sync__io_1_1Native__socket__stream_1_1Impl.html#a64e47a38b3ed59e37295336114918142">More...</a><br /></td></tr>
<tr class="separator:a64e47a38b3ed59e37295336114918142"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a393316703a666a9b022f2b879337b920"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classipc_1_1transport_1_1Protocol__negotiator.html">Protocol_negotiator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classipc_1_1transport_1_1sync__io_1_1Native__socket__stream_1_1Impl.html#a393316703a666a9b022f2b879337b920">m_protocol_negotiator</a></td></tr>
<tr class="memdesc:a393316703a666a9b022f2b879337b920"><td class="mdescLeft">&#160;</td><td class="mdescRight">Handles the protocol negotiation at the start of the pipe.  <a href="classipc_1_1transport_1_1sync__io_1_1Native__socket__stream_1_1Impl.html#a393316703a666a9b022f2b879337b920">More...</a><br /></td></tr>
<tr class="separator:a393316703a666a9b022f2b879337b920"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1caa342f726a273deb64317cbec8b5ea"><td class="memItemLeft" align="right" valign="top">flow::util::Task_engine&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classipc_1_1transport_1_1sync__io_1_1Native__socket__stream_1_1Impl.html#a1caa342f726a273deb64317cbec8b5ea">m_nb_task_engine</a></td></tr>
<tr class="memdesc:a1caa342f726a273deb64317cbec8b5ea"><td class="mdescLeft">&#160;</td><td class="mdescRight">The <code>Task_engine</code> for <a class="el" href="classipc_1_1transport_1_1sync__io_1_1Native__socket__stream_1_1Impl.html#a42aab631e9c70bfaa53764309adfe37c" title="The peer stream-type Unix domain socket; or null pointer if we&#39;ve detected the connection has become ...">m_peer_socket</a>.  <a href="classipc_1_1transport_1_1sync__io_1_1Native__socket__stream_1_1Impl.html#a1caa342f726a273deb64317cbec8b5ea">More...</a><br /></td></tr>
<tr class="separator:a1caa342f726a273deb64317cbec8b5ea"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0900c54fc01d0d67b94208b47fff7469"><td class="memItemLeft" align="right" valign="top">flow::util::Task_engine&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classipc_1_1transport_1_1sync__io_1_1Native__socket__stream_1_1Impl.html#a0900c54fc01d0d67b94208b47fff7469">m_ev_hndl_task_engine_unused</a></td></tr>
<tr class="memdesc:a0900c54fc01d0d67b94208b47fff7469"><td class="mdescLeft">&#160;</td><td class="mdescRight">The <code>Task_engine</code> for <code>m_*ev_wait_hndl_*</code>, unless it is replaced via <a class="el" href="classipc_1_1transport_1_1sync__io_1_1Native__socket__stream_1_1Impl.html#a8b9839bb39e95a51ed7c920137438a21" title="See Native_socket_stream counterpart.">replace_event_wait_handles()</a>.  <a href="classipc_1_1transport_1_1sync__io_1_1Native__socket__stream_1_1Impl.html#a0900c54fc01d0d67b94208b47fff7469">More...</a><br /></td></tr>
<tr class="separator:a0900c54fc01d0d67b94208b47fff7469"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a42aab631e9c70bfaa53764309adfe37c"><td class="memItemLeft" align="right" valign="top">boost::movelib::unique_ptr&lt; <a class="el" href="namespaceipc_1_1transport_1_1asio__local__stream__socket.html#a1788f9dbd896bb71b3693f9ae25b40ae">asio_local_stream_socket::Peer_socket</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classipc_1_1transport_1_1sync__io_1_1Native__socket__stream_1_1Impl.html#a42aab631e9c70bfaa53764309adfe37c">m_peer_socket</a></td></tr>
<tr class="memdesc:a42aab631e9c70bfaa53764309adfe37c"><td class="mdescLeft">&#160;</td><td class="mdescRight">The peer stream-type Unix domain socket; or null pointer if we've detected the connection has become hosed and hence have ceased all all work on the boost.asio <code>Peer_socket</code> short of its destruction.  <a href="classipc_1_1transport_1_1sync__io_1_1Native__socket__stream_1_1Impl.html#a42aab631e9c70bfaa53764309adfe37c">More...</a><br /></td></tr>
<tr class="separator:a42aab631e9c70bfaa53764309adfe37c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2a389318796d7386b114649a61c7d4f9"><td class="memItemLeft" align="right" valign="top">boost::movelib::unique_ptr&lt; <a class="el" href="namespaceipc_1_1transport_1_1asio__local__stream__socket.html#a1788f9dbd896bb71b3693f9ae25b40ae">asio_local_stream_socket::Peer_socket</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classipc_1_1transport_1_1sync__io_1_1Native__socket__stream_1_1Impl.html#a2a389318796d7386b114649a61c7d4f9">m_peer_socket_hosed</a></td></tr>
<tr class="memdesc:a2a389318796d7386b114649a61c7d4f9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Null to start, this takes on the value from <a class="el" href="classipc_1_1transport_1_1sync__io_1_1Native__socket__stream_1_1Impl.html#a42aab631e9c70bfaa53764309adfe37c" title="The peer stream-type Unix domain socket; or null pointer if we&#39;ve detected the connection has become ...">m_peer_socket</a> when and only when <a class="el" href="classipc_1_1transport_1_1sync__io_1_1Native__socket__stream_1_1Impl.html#a42aab631e9c70bfaa53764309adfe37c" title="The peer stream-type Unix domain socket; or null pointer if we&#39;ve detected the connection has become ...">m_peer_socket</a> is nullified (which occurs when and only when an error is detected on it).  <a href="classipc_1_1transport_1_1sync__io_1_1Native__socket__stream_1_1Impl.html#a2a389318796d7386b114649a61c7d4f9">More...</a><br /></td></tr>
<tr class="separator:a2a389318796d7386b114649a61c7d4f9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0ac6a82eda9256cba45f3b5365d79355"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classipc_1_1util_1_1sync__io_1_1Asio__waitable__native__handle.html">util::sync_io::Asio_waitable_native_handle</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classipc_1_1transport_1_1sync__io_1_1Native__socket__stream_1_1Impl.html#a0ac6a82eda9256cba45f3b5365d79355">m_ev_wait_hndl_peer_socket</a></td></tr>
<tr class="memdesc:a0ac6a82eda9256cba45f3b5365d79355"><td class="mdescLeft">&#160;</td><td class="mdescRight">Descriptor waitable by outside event loop async-waits &ndash; storing the same <code>Native_handle</code> as (and thus being used to wait on events from) <a class="el" href="classipc_1_1transport_1_1sync__io_1_1Native__socket__stream_1_1Impl.html#a42aab631e9c70bfaa53764309adfe37c" title="The peer stream-type Unix domain socket; or null pointer if we&#39;ve detected the connection has become ...">m_peer_socket</a>.  <a href="classipc_1_1transport_1_1sync__io_1_1Native__socket__stream_1_1Impl.html#a0ac6a82eda9256cba45f3b5365d79355">More...</a><br /></td></tr>
<tr class="separator:a0ac6a82eda9256cba45f3b5365d79355"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abc7d2b14208ed2b8c0add0c26f7fbf27"><td class="memItemLeft" align="right" valign="top">flow::util::Mutex_non_recursive&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classipc_1_1transport_1_1sync__io_1_1Native__socket__stream_1_1Impl.html#abc7d2b14208ed2b8c0add0c26f7fbf27">m_peer_socket_mutex</a></td></tr>
<tr class="memdesc:abc7d2b14208ed2b8c0add0c26f7fbf27"><td class="mdescLeft">&#160;</td><td class="mdescRight">Protects <a class="el" href="classipc_1_1transport_1_1sync__io_1_1Native__socket__stream_1_1Impl.html#a42aab631e9c70bfaa53764309adfe37c" title="The peer stream-type Unix domain socket; or null pointer if we&#39;ve detected the connection has become ...">m_peer_socket</a> and its bros <a class="el" href="classipc_1_1transport_1_1sync__io_1_1Native__socket__stream_1_1Impl.html#a0ac6a82eda9256cba45f3b5365d79355" title="Descriptor waitable by outside event loop async-waits â€“ storing the same Native_handle as (and thus b...">m_ev_wait_hndl_peer_socket</a> and <a class="el" href="classipc_1_1transport_1_1sync__io_1_1Native__socket__stream_1_1Impl.html#a2a389318796d7386b114649a61c7d4f9" title="Null to start, this takes on the value from m_peer_socket when and only when m_peer_socket is nullifi...">m_peer_socket_hosed</a>.  <a href="classipc_1_1transport_1_1sync__io_1_1Native__socket__stream_1_1Impl.html#abc7d2b14208ed2b8c0add0c26f7fbf27">More...</a><br /></td></tr>
<tr class="separator:abc7d2b14208ed2b8c0add0c26f7fbf27"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a54c3fdde2cf99fda314ee3387f70a02e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classipc_1_1util_1_1sync__io_1_1Timer__event__emitter.html">util::sync_io::Timer_event_emitter</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classipc_1_1transport_1_1sync__io_1_1Native__socket__stream_1_1Impl.html#a54c3fdde2cf99fda314ee3387f70a02e">m_timer_worker</a></td></tr>
<tr class="memdesc:a54c3fdde2cf99fda314ee3387f70a02e"><td class="mdescLeft">&#160;</td><td class="mdescRight">As typical in timer-needing <code><a class="el" href="namespaceipc_1_1transport_1_1sync__io.html" title="sync_io-pattern counterparts to async-I/O-pattern object types in parent namespace ipc::transport.">sync_io</a></code>-pattern-implementing objects, maintains a thread exclusively for <code>Timer</code> wait completion handlers which ferry timer-fired events to internal IPC-mechanisms waitable by the <code><a class="el" href="namespaceipc_1_1transport_1_1sync__io.html" title="sync_io-pattern counterparts to async-I/O-pattern object types in parent namespace ipc::transport.">sync_io</a></code>-pattern-using outside event loop.  <a href="classipc_1_1transport_1_1sync__io_1_1Native__socket__stream_1_1Impl.html#a54c3fdde2cf99fda314ee3387f70a02e">More...</a><br /></td></tr>
<tr class="separator:a54c3fdde2cf99fda314ee3387f70a02e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae094bf64dda8f6c6e013400a77fd1343"><td class="memItemLeft" align="right" valign="top">std::optional&lt; flow::async::Single_thread_task_loop &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classipc_1_1transport_1_1sync__io_1_1Native__socket__stream_1_1Impl.html#ae094bf64dda8f6c6e013400a77fd1343">m_conn_async_worker</a></td></tr>
<tr class="memdesc:ae094bf64dda8f6c6e013400a77fd1343"><td class="mdescLeft">&#160;</td><td class="mdescRight">Event loop used exclusively by <a class="el" href="classipc_1_1transport_1_1sync__io_1_1Native__socket__stream_1_1Impl.html#a3c5187e34876a0419ff70734ec0fbf14" title="See Native_socket_stream counterpart.">sync_connect()</a> which as needed <code>-&gt;start()</code>s a short-lived thread and <code>-&gt;stop()</code>s it before returning, in case <a class="el" href="classipc_1_1transport_1_1sync__io_1_1Native__socket__stream_1_1Impl.html#ad6443fb49be059dbe76c75d86a18197e" title="The core of sync_connect(), written in the sync_io-pattern style.">async_connect()</a> does not complete synchronously.  <a href="classipc_1_1transport_1_1sync__io_1_1Native__socket__stream_1_1Impl.html#ae094bf64dda8f6c6e013400a77fd1343">More...</a><br /></td></tr>
<tr class="separator:ae094bf64dda8f6c6e013400a77fd1343"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa2d79438a470aa94feb2fbbcd72dc629"><td class="memItemLeft" align="right" valign="top">std::optional&lt; <a class="el" href="classipc_1_1util_1_1sync__io_1_1Asio__waitable__native__handle.html">util::sync_io::Asio_waitable_native_handle</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classipc_1_1transport_1_1sync__io_1_1Native__socket__stream_1_1Impl.html#aa2d79438a470aa94feb2fbbcd72dc629">m_conn_ev_wait_hndl_peer_socket</a></td></tr>
<tr class="memdesc:aa2d79438a470aa94feb2fbbcd72dc629"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is to (<a class="el" href="classipc_1_1transport_1_1sync__io_1_1Native__socket__stream_1_1Impl.html#a42aab631e9c70bfaa53764309adfe37c" title="The peer stream-type Unix domain socket; or null pointer if we&#39;ve detected the connection has become ...">m_peer_socket</a>, <a class="el" href="classipc_1_1transport_1_1sync__io_1_1Native__socket__stream_1_1Impl.html#ae094bf64dda8f6c6e013400a77fd1343" title="Event loop used exclusively by sync_connect() which as needed -&gt;start()s a short-lived thread and -&gt;s...">m_conn_async_worker</a>) what <a class="el" href="classipc_1_1transport_1_1sync__io_1_1Native__socket__stream_1_1Impl.html#a0ac6a82eda9256cba45f3b5365d79355" title="Descriptor waitable by outside event loop async-waits â€“ storing the same Native_handle as (and thus b...">m_ev_wait_hndl_peer_socket</a> is to (<a class="el" href="classipc_1_1transport_1_1sync__io_1_1Native__socket__stream_1_1Impl.html#a42aab631e9c70bfaa53764309adfe37c" title="The peer stream-type Unix domain socket; or null pointer if we&#39;ve detected the connection has become ...">m_peer_socket</a>, <a class="el" href="classipc_1_1transport_1_1Native__socket__stream_1_1Impl.html#a4a7ab0a981614724b559b38634634d8a" title="Single-thread worker pool for all internal async work in both directions.">transport::Native_socket_stream::Impl::m_worker</a>), respectively.  <a href="classipc_1_1transport_1_1sync__io_1_1Native__socket__stream_1_1Impl.html#aa2d79438a470aa94feb2fbbcd72dc629">More...</a><br /></td></tr>
<tr class="separator:aa2d79438a470aa94feb2fbbcd72dc629"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa020c49ecb9fb12fb554342f096b9822"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespaceipc_1_1util_1_1sync__io.html#aa0b9a3cc6bdc7dedbef4f9e06851aa24">util::sync_io::Event_wait_func</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classipc_1_1transport_1_1sync__io_1_1Native__socket__stream_1_1Impl.html#aa020c49ecb9fb12fb554342f096b9822">m_conn_ev_wait_func</a></td></tr>
<tr class="memdesc:aa020c49ecb9fb12fb554342f096b9822"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function (set forever in <a class="el" href="classipc_1_1transport_1_1sync__io_1_1Native__socket__stream_1_1Impl.html#a3c6214376ab8bc59823635d405f9704a" title="It is start_ops&lt;Op::S_CONN&gt;().">start_connect_ops()</a>) through which we invoke the outside event loop's async-wait facility for descriptors/events relevant to connect-ops.  <a href="classipc_1_1transport_1_1sync__io_1_1Native__socket__stream_1_1Impl.html#aa020c49ecb9fb12fb554342f096b9822">More...</a><br /></td></tr>
<tr class="separator:aa020c49ecb9fb12fb554342f096b9822"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1af9eb83b9afee25ba153a2ca066858d"><td class="memItemLeft" align="right" valign="top">std::queue&lt; <a class="el" href="structipc_1_1transport_1_1sync__io_1_1Native__socket__stream_1_1Impl_1_1Snd__low__lvl__payload.html#a2d3a01b00a000c3f40b3d580cd3b1c35">Snd_low_lvl_payload::Ptr</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classipc_1_1transport_1_1sync__io_1_1Native__socket__stream_1_1Impl.html#a1af9eb83b9afee25ba153a2ca066858d">m_snd_pending_payloads_q</a></td></tr>
<tr class="memdesc:a1af9eb83b9afee25ba153a2ca066858d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Queue storing (at head) the currently in-progress async write-op of a <a class="el" href="structipc_1_1transport_1_1sync__io_1_1Native__socket__stream_1_1Impl_1_1Snd__low__lvl__payload.html" title="Data store representing a payload corresponding to exactly one attempted async write-op,...">Snd_low_lvl_payload</a>; followed by the payloads that should be written after that completes, in order.  <a href="classipc_1_1transport_1_1sync__io_1_1Native__socket__stream_1_1Impl.html#a1af9eb83b9afee25ba153a2ca066858d">More...</a><br /></td></tr>
<tr class="separator:a1af9eb83b9afee25ba153a2ca066858d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0257a7903bff120aa1523f8de04bccf7"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespaceipc.html#aa3192e586cc45d3e7c22463bf2760f89">Error_code</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classipc_1_1transport_1_1sync__io_1_1Native__socket__stream_1_1Impl.html#a0257a7903bff120aa1523f8de04bccf7">m_snd_pending_err_code</a></td></tr>
<tr class="memdesc:a0257a7903bff120aa1523f8de04bccf7"><td class="mdescLeft">&#160;</td><td class="mdescRight">The first and only connection-hosing error condition detected when attempting to low-level-write on <a class="el" href="classipc_1_1transport_1_1sync__io_1_1Native__socket__stream_1_1Impl.html#a42aab631e9c70bfaa53764309adfe37c" title="The peer stream-type Unix domain socket; or null pointer if we&#39;ve detected the connection has become ...">m_peer_socket</a>; or falsy if no such error has yet been detected.  <a href="classipc_1_1transport_1_1sync__io_1_1Native__socket__stream_1_1Impl.html#a0257a7903bff120aa1523f8de04bccf7">More...</a><br /></td></tr>
<tr class="separator:a0257a7903bff120aa1523f8de04bccf7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acfefc83c990b1b6cd903f5ad323e5dfa"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classipc_1_1transport_1_1sync__io_1_1Native__socket__stream_1_1Impl.html#acfefc83c990b1b6cd903f5ad323e5dfa">m_snd_finished</a></td></tr>
<tr class="memdesc:acfefc83c990b1b6cd903f5ad323e5dfa"><td class="mdescLeft">&#160;</td><td class="mdescRight"><code>false</code> at start; set to <code>true</code> forever on the first <code>*end_sending()</code> invocation; <code>true</code> will prevent any subsequent <a class="el" href="classipc_1_1transport_1_1sync__io_1_1Native__socket__stream_1_1Impl.html#a59e9935bdd704c40173a40e87b5db131" title="See Native_socket_stream counterpart.">send_native_handle()</a>/send_blob() calls from proceeding.  <a href="classipc_1_1transport_1_1sync__io_1_1Native__socket__stream_1_1Impl.html#acfefc83c990b1b6cd903f5ad323e5dfa">More...</a><br /></td></tr>
<tr class="separator:acfefc83c990b1b6cd903f5ad323e5dfa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a92372b2da3a4bdccda23b27b2865f01d"><td class="memItemLeft" align="right" valign="top">flow::async::Task_asio_err&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classipc_1_1transport_1_1sync__io_1_1Native__socket__stream_1_1Impl.html#a92372b2da3a4bdccda23b27b2865f01d">m_snd_pending_on_last_send_done_func_or_empty</a></td></tr>
<tr class="memdesc:a92372b2da3a4bdccda23b27b2865f01d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function passed to <a class="el" href="classipc_1_1transport_1_1sync__io_1_1Native__socket__stream_1_1Impl.html#a0aca995c7150e72219b422c188d9bc23" title="See Native_socket_stream counterpart.">async_end_sending()</a>, if it returned <code>true</code> and was unable to synchronously flush everything including the graceful-close itself (synchronously detecting new or previous pipe-hosing error <em>does</em> entail flushing everything); otherwise <code>.empty()</code>.  <a href="classipc_1_1transport_1_1sync__io_1_1Native__socket__stream_1_1Impl.html#a92372b2da3a4bdccda23b27b2865f01d">More...</a><br /></td></tr>
<tr class="separator:a92372b2da3a4bdccda23b27b2865f01d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4cb5d8ce6fa402c2cbaf27ec9654277c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespaceipc_1_1util.html#ac66141280c3b7295a86b65209f31cc58">util::Fine_duration</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classipc_1_1transport_1_1sync__io_1_1Native__socket__stream_1_1Impl.html#a4cb5d8ce6fa402c2cbaf27ec9654277c">m_snd_auto_ping_period</a></td></tr>
<tr class="memdesc:a4cb5d8ce6fa402c2cbaf27ec9654277c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Equals <code>zero()</code> before <a class="el" href="classipc_1_1transport_1_1sync__io_1_1Native__socket__stream_1_1Impl.html#ab7b382067804495cbae180a5bc1a2757" title="See Native_socket_stream counterpart.">auto_ping()</a>; immutably equals <code>period</code> (<a class="el" href="classipc_1_1transport_1_1sync__io_1_1Native__socket__stream_1_1Impl.html#ab7b382067804495cbae180a5bc1a2757" title="See Native_socket_stream counterpart.">auto_ping()</a> arg) subsequently to that first successful call (if any).  <a href="classipc_1_1transport_1_1sync__io_1_1Native__socket__stream_1_1Impl.html#a4cb5d8ce6fa402c2cbaf27ec9654277c">More...</a><br /></td></tr>
<tr class="separator:a4cb5d8ce6fa402c2cbaf27ec9654277c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a311a0641a1da83530311e16845105c2c"><td class="memItemLeft" align="right" valign="top">flow::util::Timer&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classipc_1_1transport_1_1sync__io_1_1Native__socket__stream_1_1Impl.html#a311a0641a1da83530311e16845105c2c">m_snd_auto_ping_timer</a></td></tr>
<tr class="memdesc:a311a0641a1da83530311e16845105c2c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Timer that fires <a class="el" href="classipc_1_1transport_1_1sync__io_1_1Native__socket__stream_1_1Impl.html#a4b31da3a7ff63f307bd08e288c391556" title="Handler for the async-wait, via util::sync_io::Timer_event_emitter, of the auto-ping timer firing; if...">snd_on_ev_auto_ping_now_timer_fired()</a> (which sends an auto-ping) and is always scheduled to fire <a class="el" href="classipc_1_1transport_1_1sync__io_1_1Native__socket__stream_1_1Impl.html#a4cb5d8ce6fa402c2cbaf27ec9654277c" title="Equals zero() before auto_ping(); immutably equals period (auto_ping() arg) subsequently to that firs...">m_snd_auto_ping_period</a> after the last send (<a class="el" href="classipc_1_1transport_1_1sync__io_1_1Native__socket__stream_1_1Impl.html#a59e9935bdd704c40173a40e87b5db131" title="See Native_socket_stream counterpart.">send_native_handle()</a>, <a class="el" href="classipc_1_1transport_1_1sync__io_1_1Native__socket__stream_1_1Impl.html#ab7b382067804495cbae180a5bc1a2757" title="See Native_socket_stream counterpart.">auto_ping()</a>, <a class="el" href="classipc_1_1transport_1_1sync__io_1_1Native__socket__stream_1_1Impl.html#a4b31da3a7ff63f307bd08e288c391556" title="Handler for the async-wait, via util::sync_io::Timer_event_emitter, of the auto-ping timer firing; if...">snd_on_ev_auto_ping_now_timer_fired()</a> itself).  <a href="classipc_1_1transport_1_1sync__io_1_1Native__socket__stream_1_1Impl.html#a311a0641a1da83530311e16845105c2c">More...</a><br /></td></tr>
<tr class="separator:a311a0641a1da83530311e16845105c2c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3116d5b66bf35bec158905bbde4f6854"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classipc_1_1util_1_1sync__io_1_1Timer__event__emitter.html#a1533a54927a64579fda02c61ec94b735">util::sync_io::Timer_event_emitter::Timer_fired_read_end</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classipc_1_1transport_1_1sync__io_1_1Native__socket__stream_1_1Impl.html#a3116d5b66bf35bec158905bbde4f6854">m_snd_auto_ping_timer_fired_peer</a></td></tr>
<tr class="memdesc:a3116d5b66bf35bec158905bbde4f6854"><td class="mdescLeft">&#160;</td><td class="mdescRight">Read-end of IPC-mechanism used by <a class="el" href="classipc_1_1transport_1_1sync__io_1_1Native__socket__stream_1_1Impl.html#a54c3fdde2cf99fda314ee3387f70a02e" title="As typical in timer-needing sync_io-pattern-implementing objects, maintains a thread exclusively for ...">m_timer_worker</a> to ferry timer-fired events from <a class="el" href="classipc_1_1transport_1_1sync__io_1_1Native__socket__stream_1_1Impl.html#a311a0641a1da83530311e16845105c2c" title="Timer that fires snd_on_ev_auto_ping_now_timer_fired() (which sends an auto-ping) and is always sched...">m_snd_auto_ping_timer</a> to <code><a class="el" href="namespaceipc_1_1transport_1_1sync__io.html" title="sync_io-pattern counterparts to async-I/O-pattern object types in parent namespace ipc::transport.">sync_io</a></code> outside async-wait to our actual on-timer-fired handler logic.  <a href="classipc_1_1transport_1_1sync__io_1_1Native__socket__stream_1_1Impl.html#a3116d5b66bf35bec158905bbde4f6854">More...</a><br /></td></tr>
<tr class="separator:a3116d5b66bf35bec158905bbde4f6854"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a459618a64d769ba8798a6380e9292181"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classipc_1_1util_1_1sync__io_1_1Asio__waitable__native__handle.html">util::sync_io::Asio_waitable_native_handle</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classipc_1_1transport_1_1sync__io_1_1Native__socket__stream_1_1Impl.html#a459618a64d769ba8798a6380e9292181">m_snd_ev_wait_hndl_auto_ping_timer_fired_peer</a></td></tr>
<tr class="memdesc:a459618a64d769ba8798a6380e9292181"><td class="mdescLeft">&#160;</td><td class="mdescRight">Descriptor waitable by outside event loop async-waits &ndash; storing the same <code>Native_handle</code> as (and thus being used to wait on events from) <a class="el" href="classipc_1_1transport_1_1sync__io_1_1Native__socket__stream_1_1Impl.html#a3116d5b66bf35bec158905bbde4f6854" title="Read-end of IPC-mechanism used by m_timer_worker to ferry timer-fired events from m_snd_auto_ping_tim...">m_snd_auto_ping_timer_fired_peer</a>.  <a href="classipc_1_1transport_1_1sync__io_1_1Native__socket__stream_1_1Impl.html#a459618a64d769ba8798a6380e9292181">More...</a><br /></td></tr>
<tr class="separator:a459618a64d769ba8798a6380e9292181"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abd4d8d43776c3956c6896ca721e95dab"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespaceipc_1_1util_1_1sync__io.html#aa0b9a3cc6bdc7dedbef4f9e06851aa24">util::sync_io::Event_wait_func</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classipc_1_1transport_1_1sync__io_1_1Native__socket__stream_1_1Impl.html#abd4d8d43776c3956c6896ca721e95dab">m_snd_ev_wait_func</a></td></tr>
<tr class="memdesc:abd4d8d43776c3956c6896ca721e95dab"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function (set forever in <code>start_send_*_ops()</code>) through which we invoke the outside event loop's async-wait facility for descriptors/events relevant to send-ops.  <a href="classipc_1_1transport_1_1sync__io_1_1Native__socket__stream_1_1Impl.html#abd4d8d43776c3956c6896ca721e95dab">More...</a><br /></td></tr>
<tr class="separator:abd4d8d43776c3956c6896ca721e95dab"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9098de978da64572c419019597274d68"><td class="memItemLeft" align="right" valign="top">std::optional&lt; <a class="el" href="structipc_1_1transport_1_1sync__io_1_1Native__socket__stream_1_1Impl_1_1Rcv__user__request.html">Rcv_user_request</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classipc_1_1transport_1_1sync__io_1_1Native__socket__stream_1_1Impl.html#a9098de978da64572c419019597274d68">m_rcv_user_request</a></td></tr>
<tr class="memdesc:a9098de978da64572c419019597274d68"><td class="mdescLeft">&#160;</td><td class="mdescRight">Null if no <code>async_receive_*()</code> is currently pending; else describes the arguments to that pending <code>async_receive_*()</code>.  <a href="classipc_1_1transport_1_1sync__io_1_1Native__socket__stream_1_1Impl.html#a9098de978da64572c419019597274d68">More...</a><br /></td></tr>
<tr class="separator:a9098de978da64572c419019597274d68"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6676379057415274d2c6f2f096828cf9"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classipc_1_1transport_1_1sync__io_1_1Native__socket__stream_1_1Impl.html#a881c376f1ee37f9b1a20f770824f55d9">low_lvl_payload_blob_length_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classipc_1_1transport_1_1sync__io_1_1Native__socket__stream_1_1Impl.html#a6676379057415274d2c6f2f096828cf9">m_rcv_target_meta_length</a></td></tr>
<tr class="memdesc:a6676379057415274d2c6f2f096828cf9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Direct-write target, storing the length in bytes of the next meta-blob; 0 meaning the current user message contains no meta-blob but only a native handle (or represents graceful-close if that is also not present); and 0xFF... (<a class="el" href="classipc_1_1transport_1_1sync__io_1_1Native__socket__stream_1_1Impl.html#ad5e487595e2a58f7ff25b4f4c91fe4bc" title="Value for the length field in payload 1 that means &quot;not a length; indicating this is a ping message....">S_META_BLOB_LENGTH_PING_SENTINEL</a>) meaning it's a mere ping.  <a href="classipc_1_1transport_1_1sync__io_1_1Native__socket__stream_1_1Impl.html#a6676379057415274d2c6f2f096828cf9">More...</a><br /></td></tr>
<tr class="separator:a6676379057415274d2c6f2f096828cf9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab824da16816893b2ffe2e778a7169b62"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespaceipc.html#aa3192e586cc45d3e7c22463bf2760f89">Error_code</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classipc_1_1transport_1_1sync__io_1_1Native__socket__stream_1_1Impl.html#ab824da16816893b2ffe2e778a7169b62">m_rcv_pending_err_code</a></td></tr>
<tr class="memdesc:ab824da16816893b2ffe2e778a7169b62"><td class="mdescLeft">&#160;</td><td class="mdescRight">The first and only connection-hosing error condition detected when attempting to low-level-read on <a class="el" href="classipc_1_1transport_1_1sync__io_1_1Native__socket__stream_1_1Impl.html#a42aab631e9c70bfaa53764309adfe37c" title="The peer stream-type Unix domain socket; or null pointer if we&#39;ve detected the connection has become ...">m_peer_socket</a>; or falsy if no such error has yet been detected.  <a href="classipc_1_1transport_1_1sync__io_1_1Native__socket__stream_1_1Impl.html#ab824da16816893b2ffe2e778a7169b62">More...</a><br /></td></tr>
<tr class="separator:ab824da16816893b2ffe2e778a7169b62"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ada7f2368dc0591f7a903946201c83636"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespaceipc_1_1util.html#ac66141280c3b7295a86b65209f31cc58">util::Fine_duration</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classipc_1_1transport_1_1sync__io_1_1Native__socket__stream_1_1Impl.html#ada7f2368dc0591f7a903946201c83636">m_rcv_idle_timeout</a></td></tr>
<tr class="memdesc:ada7f2368dc0591f7a903946201c83636"><td class="mdescLeft">&#160;</td><td class="mdescRight"><code>timeout</code> from <a class="el" href="classipc_1_1transport_1_1sync__io_1_1Native__socket__stream_1_1Impl.html#abedd0db5a5ae04e47085728ae548d07c" title="See Native_socket_stream counterpart.">idle_timer_run()</a> args; or <code>zero()</code> if not yet called.  <a href="classipc_1_1transport_1_1sync__io_1_1Native__socket__stream_1_1Impl.html#ada7f2368dc0591f7a903946201c83636">More...</a><br /></td></tr>
<tr class="separator:ada7f2368dc0591f7a903946201c83636"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab65c4574a9a084030a9a66a8340c94b2"><td class="memItemLeft" align="right" valign="top">flow::util::Timer&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classipc_1_1transport_1_1sync__io_1_1Native__socket__stream_1_1Impl.html#ab65c4574a9a084030a9a66a8340c94b2">m_rcv_idle_timer</a></td></tr>
<tr class="memdesc:ab65c4574a9a084030a9a66a8340c94b2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Timer that fires <a class="el" href="classipc_1_1transport_1_1sync__io_1_1Native__socket__stream_1_1Impl.html#a53b356e756923271fbb9b7a7beb8f54a" title="Handler for the async-wait, via util::sync_io::Timer_event_emitter, of the idle timer firing; if stil...">rcv_on_ev_idle_timer_fired()</a> (which hoses the in-pipe with idle timeour error) and is (re)scheduled to fire in <a class="el" href="classipc_1_1transport_1_1sync__io_1_1Native__socket__stream_1_1Impl.html#ada7f2368dc0591f7a903946201c83636" title="timeout from idle_timer_run() args; or zero() if not yet called.">m_rcv_idle_timeout</a> each time <code>*this</code> receives a complete message on <a class="el" href="classipc_1_1transport_1_1sync__io_1_1Native__socket__stream_1_1Impl.html#a42aab631e9c70bfaa53764309adfe37c" title="The peer stream-type Unix domain socket; or null pointer if we&#39;ve detected the connection has become ...">m_peer_socket</a>.  <a href="classipc_1_1transport_1_1sync__io_1_1Native__socket__stream_1_1Impl.html#ab65c4574a9a084030a9a66a8340c94b2">More...</a><br /></td></tr>
<tr class="separator:ab65c4574a9a084030a9a66a8340c94b2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa94400dd47704098beffe37b07b75472"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classipc_1_1util_1_1sync__io_1_1Timer__event__emitter.html#a1533a54927a64579fda02c61ec94b735">util::sync_io::Timer_event_emitter::Timer_fired_read_end</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classipc_1_1transport_1_1sync__io_1_1Native__socket__stream_1_1Impl.html#aa94400dd47704098beffe37b07b75472">m_rcv_idle_timer_fired_peer</a></td></tr>
<tr class="memdesc:aa94400dd47704098beffe37b07b75472"><td class="mdescLeft">&#160;</td><td class="mdescRight">Read-end of IPC-mechanism used by <a class="el" href="classipc_1_1transport_1_1sync__io_1_1Native__socket__stream_1_1Impl.html#a54c3fdde2cf99fda314ee3387f70a02e" title="As typical in timer-needing sync_io-pattern-implementing objects, maintains a thread exclusively for ...">m_timer_worker</a> to ferry timer-fired events from <a class="el" href="classipc_1_1transport_1_1sync__io_1_1Native__socket__stream_1_1Impl.html#ab65c4574a9a084030a9a66a8340c94b2" title="Timer that fires rcv_on_ev_idle_timer_fired() (which hoses the in-pipe with idle timeour error) and i...">m_rcv_idle_timer</a> to <code><a class="el" href="namespaceipc_1_1transport_1_1sync__io.html" title="sync_io-pattern counterparts to async-I/O-pattern object types in parent namespace ipc::transport.">sync_io</a></code> outside async-wait to our actual on-timer-fired handler logic.  <a href="classipc_1_1transport_1_1sync__io_1_1Native__socket__stream_1_1Impl.html#aa94400dd47704098beffe37b07b75472">More...</a><br /></td></tr>
<tr class="separator:aa94400dd47704098beffe37b07b75472"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3540ba657d9d7c95e755d1b348c88b8f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classipc_1_1util_1_1sync__io_1_1Asio__waitable__native__handle.html">util::sync_io::Asio_waitable_native_handle</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classipc_1_1transport_1_1sync__io_1_1Native__socket__stream_1_1Impl.html#a3540ba657d9d7c95e755d1b348c88b8f">m_rcv_ev_wait_hndl_idle_timer_fired_peer</a></td></tr>
<tr class="memdesc:a3540ba657d9d7c95e755d1b348c88b8f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Descriptor waitable by outside event loop async-waits &ndash; storing the same <code>Native_handle</code> as (and thus being used to wait on events from) <a class="el" href="classipc_1_1transport_1_1sync__io_1_1Native__socket__stream_1_1Impl.html#aa94400dd47704098beffe37b07b75472" title="Read-end of IPC-mechanism used by m_timer_worker to ferry timer-fired events from m_rcv_idle_timer to...">m_rcv_idle_timer_fired_peer</a>.  <a href="classipc_1_1transport_1_1sync__io_1_1Native__socket__stream_1_1Impl.html#a3540ba657d9d7c95e755d1b348c88b8f">More...</a><br /></td></tr>
<tr class="separator:a3540ba657d9d7c95e755d1b348c88b8f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5e1051f460cddb73d3cbc48afbac18a9"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespaceipc_1_1util_1_1sync__io.html#aa0b9a3cc6bdc7dedbef4f9e06851aa24">util::sync_io::Event_wait_func</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classipc_1_1transport_1_1sync__io_1_1Native__socket__stream_1_1Impl.html#a5e1051f460cddb73d3cbc48afbac18a9">m_rcv_ev_wait_func</a></td></tr>
<tr class="memdesc:a5e1051f460cddb73d3cbc48afbac18a9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function (set forever in <code>start_receive_*_ops()</code>) through which we invoke the outside event loop's async-wait facility for descriptors/events relevant to receive-ops.  <a href="classipc_1_1transport_1_1sync__io_1_1Native__socket__stream_1_1Impl.html#a5e1051f460cddb73d3cbc48afbac18a9">More...</a><br /></td></tr>
<tr class="separator:a5e1051f460cddb73d3cbc48afbac18a9"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pri-static-attribs" name="pri-static-attribs"></a>
Static Private Attributes</h2></td></tr>
<tr class="memitem:ad5e487595e2a58f7ff25b4f4c91fe4bc"><td class="memItemLeft" align="right" valign="top">static const <a class="el" href="classipc_1_1transport_1_1sync__io_1_1Native__socket__stream_1_1Impl.html#a881c376f1ee37f9b1a20f770824f55d9">low_lvl_payload_blob_length_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classipc_1_1transport_1_1sync__io_1_1Native__socket__stream_1_1Impl.html#ad5e487595e2a58f7ff25b4f4c91fe4bc">S_META_BLOB_LENGTH_PING_SENTINEL</a> = std::numeric_limits&lt;<a class="el" href="classipc_1_1transport_1_1sync__io_1_1Native__socket__stream_1_1Impl.html#a881c376f1ee37f9b1a20f770824f55d9">low_lvl_payload_blob_length_t</a>&gt;::max()</td></tr>
<tr class="memdesc:ad5e487595e2a58f7ff25b4f4c91fe4bc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Value for the length field in payload 1 that means "not a length; indicating this is a ping message." The other special values is 0 which indicates graceful close.  <a href="classipc_1_1transport_1_1sync__io_1_1Native__socket__stream_1_1Impl.html#ad5e487595e2a58f7ff25b4f4c91fe4bc">More...</a><br /></td></tr>
<tr class="separator:ad5e487595e2a58f7ff25b4f4c91fe4bc"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="related" name="related"></a>
Related Functions</h2></td></tr>
<tr><td class="ititle" colspan="2"><p >(Note that these are not member functions.) </p>
</td></tr>
<tr class="memitem:a33231b969171a9103cd0a319ea10278b"><td class="memItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classipc_1_1transport_1_1sync__io_1_1Native__socket__stream_1_1Impl.html#a33231b969171a9103cd0a319ea10278b">operator&lt;&lt;</a> (std::ostream &amp;os, const <a class="el" href="classipc_1_1transport_1_1sync__io_1_1Native__socket__stream_1_1Impl.html">Native_socket_stream::Impl</a> &amp;val)</td></tr>
<tr class="memdesc:a33231b969171a9103cd0a319ea10278b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Prints string representation of the given <a class="el" href="classipc_1_1transport_1_1sync__io_1_1Native__socket__stream_1_1Impl.html" title="Internal, non-movable pImpl implementation of sync_io::Native_socket_stream class.">Native_socket_stream::Impl</a> to the given <code>ostream</code>.  <a href="classipc_1_1transport_1_1sync__io_1_1Native__socket__stream_1_1Impl.html#a33231b969171a9103cd0a319ea10278b">More...</a><br /></td></tr>
<tr class="separator:a33231b969171a9103cd0a319ea10278b"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p >Internal, non-movable pImpl implementation of <a class="el" href="classipc_1_1transport_1_1sync__io_1_1Native__socket__stream.html" title="Implements both sync_io::Native_handle_sender and sync_io::Native_handle_receiver concepts by using a...">sync_io::Native_socket_stream</a> class. </p>
<p >In and of itself it would have been directly and publicly usable; however <a class="el" href="classipc_1_1transport_1_1sync__io_1_1Native__socket__stream.html" title="Implements both sync_io::Native_handle_sender and sync_io::Native_handle_receiver concepts by using a...">Native_socket_stream</a> adds move semantics which are essential to cooperation with <a class="el" href="classipc_1_1transport_1_1sync__io_1_1Native__socket__stream__acceptor.html" title="sync_io-pattern counterpart to async-I/O-pattern transport::Native_socket_stream_acceptor.">sync_io::Native_socket_stream_acceptor</a> and overall consistency with the rest of <a class="el" href="namespaceipc_1_1transport.html" title="Flow-IPC module providing transmission of structured messages and/or low-level blobs (and more) betwe...">ipc::transport</a> API and, arguably, boost.asio API design.</p>
<dl class="section see"><dt>See also</dt><dd>All discussion of the public API is in <a class="el" href="classipc_1_1transport_1_1sync__io_1_1Native__socket__stream.html" title="Implements both sync_io::Native_handle_sender and sync_io::Native_handle_receiver concepts by using a...">sync_io::Native_socket_stream</a> doc header; that class forwards to this one. All discussion of pImpl-related notions is also there. See that doc header first please. Then come back here.</dd></dl>
<h2><a class="el" href="classipc_1_1transport_1_1sync__io_1_1Native__socket__stream_1_1Impl.html" title="Internal, non-movable pImpl implementation of sync_io::Native_socket_stream class.">Impl</a> design </h2>
<h3>Intro / history</h3>
<p >In the past <a class="el" href="classipc_1_1transport_1_1Native__socket__stream.html" title="Implements both Native_handle_sender and Native_handle_receiver concepts by using a stream-oriented U...">transport::Native_socket_stream</a> was one monolithic thing and therefore was was not exactly easy to understand as a unit. It has since been split into this <code><a class="el" href="namespaceipc_1_1transport_1_1sync__io.html" title="sync_io-pattern counterparts to async-I/O-pattern object types in parent namespace ipc::transport.">sync_io</a></code>-pattern core (which, to be clear, may well be useful in and of itself) and <a class="el" href="classipc_1_1transport_1_1Native__socket__stream.html" title="Implements both Native_handle_sender and Native_handle_receiver concepts by using a stream-oriented U...">transport::Native_socket_stream</a> built around it. Due to this split, the complexity is split too, and each part is really quite manageable.</p>
<p >To understand <code>*this</code>, the only real obstacle is grokking the <code><a class="el" href="namespaceipc_1_1transport_1_1sync__io.html" title="sync_io-pattern counterparts to async-I/O-pattern object types in parent namespace ipc::transport.">sync_io</a></code> pattern (see <a class="el" href="namespaceipc_1_1util_1_1sync__io.html" title="Contains common code, as well as important explanatory documentation in the following text,...">util::sync_io</a> doc header). We will not recap it here in any depth. The essential idea, though, is that when <code>*this</code> internally needs to</p><ul>
<li>async-read or async-write over <code>m_peer_socket</code> (the low-level transport); or</li>
<li>schedule a timer to fire in T time</li>
</ul>
<p >we must express either operation in terms of an async-wait (outsourced to the <code>*this</code> user). Namely:</p><ul>
<li>async-read/write = async-wait on FD for readable/writable (outsourced) + on active event, we nb-read/write.</li>
<li>scheduling timer = with the help of <a class="el" href="classipc_1_1util_1_1sync__io_1_1Timer__event__emitter.html" title="An object of this type, used internally to implement sync_io-pattern objects that require timer event...">util::sync_io::Timer_event_emitter</a>, make it so that when it does fire, a certain FD is made readable; async-wait on FD for readable (outsourced) + on active event, we read to the firing.</li>
</ul>
<p >Those are the building blocks. Other than that, it's a matter of designating our 2 pipes and how each one's algorithm works. Both are async algorithms but expressed in terms of the above building blocks (in the <code><a class="el" href="namespaceipc_1_1transport_1_1sync__io.html" title="sync_io-pattern counterparts to async-I/O-pattern object types in parent namespace ipc::transport.">sync_io</a></code> pattern).</p>
<p >Reminder: we do not deal with threads. To summarize our thread safety guarantees:</p><ul>
<li>there are none, on a given <code>*this</code>; except</li>
<li>once in PEER state, send-ops (including <code>(*on_active_ev_func)()</code> from <code>start_send_*_ops()</code>) are allowed to be invoked concurrently to receive-ops (including <code>(*on_active_ev_func)()</code> from <code>start_receive_*_ops()</code>).</li>
</ul>
<p >To allow for the latter, the design is carefully split into 2 op-types; and the only data they ever touch in common comprise <code>m_*peer_socket</code>. This makes makes perfect sense: a Unix domain socket connection is full-duplex but done over a single FD. See <a class="el" href="classipc_1_1transport_1_1sync__io_1_1Native__socket__stream_1_1Impl.html#a42aab631e9c70bfaa53764309adfe37c" title="The peer stream-type Unix domain socket; or null pointer if we&#39;ve detected the connection has become ...">Impl::m_peer_socket</a> doc header regarding how we ensure safe concurrency without sacrificing perf. (Spoiler alert: a tiny and simple critical section w/r/t <code>m_*peer_socket</code> only.)</p>
<p >There is, also, NULL state, wherein one can <a class="el" href="classipc_1_1transport_1_1sync__io_1_1Native__socket__stream_1_1Impl.html#a3c5187e34876a0419ff70734ec0fbf14" title="See Native_socket_stream counterpart.">sync_connect()</a> et al. This is separate from the other 2, in this case preceding them entirely. We will soon discuss each algorithm: connect-ops, send-ops, receive-ops (though connect-ops is treated more as an afterthought at the end). Before we can speak of send-ops and receive-ops algorithms, we have to establish the substrate over which they operate: the protocol they speak. Don't worry; it is a simple protocol.</p>
<p >Before even speaking of <em>that</em> more generally, there was this specific question to settle:</p>
<h3>Shutting down individual-direction pipes</h3>
<p >As required by the concepts, the out-pipe can be (arbitrarily preceding dtor call) ended via APIs <code>*end_sending()</code>. How is this internally implemented? I (ygoldfel) faced a dilemma in answering this question. Initially I was tempted to use the <code>shutdown()</code> native/boost.asio <code>Peer_socket</code> call which takes an argument <code>int how</code>, specifying which-direction pipe to shut down. Eventually I decided against it, because the exact semantics of <code>shutdown()</code> for stream UDS are rather unclear; vaguely speaking how they act is documented mostly w/r/t to TCP sockets, not local (UDS) ones, and even assuming UDS act the same isn't great, since TCP involves an unreliable medium with FIN/ACK/etc., while stream UDS internally just reliably shuffles around bytes in kernel memory. It's possible to get straight answers by reading kernel code, but how portable/maintainable is that? Lastly, when using <code>shutdown()</code>, the signaling-other-side semantics are particularly unclear; e.g., if I <code>shutdown(how=WRITE)</code>, will opposing peer get an "EOF" (connection gracefully closed)? Possibly but does that imply the other side was also closed? <code>EPIPE</code> is also involved (if closing reader &ndash; N/A for us but...)... it's just low-level-obscure and hairy. (Color commentary: POSIX and Linux documented behavior doesn't have the formal completeness that Boost docs do; and if it did it'd still IMO (ygoldfel) be arguably less formally considered in its design.)</p>
<p >Therefore I (ygoldfel) decided to instead to take full control of it by <em>not</em> using <code>shutdown()</code> and instead using the following semantics/impl. The semantics = inspired both by common sense and <code>man</code> page references to similar behavior when using actual <code>shutdown()</code> on native stream UDS; but really the latter is a sanity-check on the former; and the former is king.</p><ul>
<li>Two local flags, <a class="el" href="classipc_1_1transport_1_1sync__io_1_1Native__socket__stream_1_1Impl.html#acfefc83c990b1b6cd903f5ad323e5dfa" title="false at start; set to true forever on the first *end_sending() invocation; true will prevent any sub...">m_snd_finished</a> and a conceptual rcv_finished, which start <code>false</code> and can only be set to <code>true</code> (1x). (rcv_finished is really just for exposition; it is represented by the general condition wherein <a class="el" href="classipc_1_1transport_1_1sync__io_1_1Native__socket__stream_1_1Impl.html#ab824da16816893b2ffe2e778a7169b62" title="The first and only connection-hosing error condition detected when attempting to low-level-read on m_...">m_rcv_pending_err_code</a> stores a truthy <code>Error_code</code>.)</li>
<li>If side A user does <code>*end_sending()</code>, this sets <a class="el" href="classipc_1_1transport_1_1sync__io_1_1Native__socket__stream_1_1Impl.html#acfefc83c990b1b6cd903f5ad323e5dfa" title="false at start; set to true forever on the first *end_sending() invocation; true will prevent any sub...">m_snd_finished</a> and sends a special very-short "graceful half-duplex close" message &ndash; albeit in order after any actual user messages from preceding <code>send_*()</code> calls; side B receives this and sets its rcv_finished (assigns a particular receives-finished <code>Error_code</code> to <a class="el" href="classipc_1_1transport_1_1sync__io_1_1Native__socket__stream_1_1Impl.html#ab824da16816893b2ffe2e778a7169b62" title="The first and only connection-hosing error condition detected when attempting to low-level-read on m_...">m_rcv_pending_err_code</a>).<ul>
<li><a class="el" href="classipc_1_1transport_1_1sync__io_1_1Native__socket__stream_1_1Impl.html#acfefc83c990b1b6cd903f5ad323e5dfa" title="false at start; set to true forever on the first *end_sending() invocation; true will prevent any sub...">m_snd_finished</a> means: Send-through any pending-to-be-sent user messages from <code>send_*()</code>; then the graceful-close message; and any <code>send_*()</code> calls after <code>*end_sending()</code> are an immediate <a class="el" href="namespaceipc_1_1transport_1_1error.html#adfef15ef4e76cc55d652fbd9c2797297a42d41c622e92e9053177ba73e75633fe" title="Will not send message: local user already ended sending via API marking this.">error::Code::S_SENDS_FINISHED_CANNOT_SEND</a> at best (though could be another error, if something else is detected... but to the user error=error and is probably to be treated the same).</li>
</ul>
</li>
<li>If rcv_finished became true (due to the other side sending a graceful-close):<ul>
<li>There will be no subsequent low-level data after that, by definition of how the protocol is designed, meaning the other peer shouldn't send any more (as said a few bullet points ago). On our side, though, we don't rely on that and simply stop reading, as on socket error.</li>
<li>This condition will be emitted via the <code>async_receive_*()</code> completion handler like any other connection-ending error (in this case, via error::code::S_RECEIVES_FINISHED_CANNOT_RECEIVE; but for example <code>boost::asio::error::eof</code> is a graceful-UDS-close "error" and is conceptually very similar).</li>
</ul>
</li>
</ul>
<p >The required internal code does require some care; but the resulting semantic certainty and control are IMO (ygoldfel) worth it. Using <code>shutdown()</code> instead might seem easy, but I strongly suspect the pain of semantic uncertainty would make up for that many times over.</p>
<p >OK; we've decided how to deal with pipe ending &ndash; basically, graceful-close is a message we explicitly need to encode when sending and understand when receiving &ndash; so now we can get into the topic of the protocol.</p>
<h3>Internal protocol design</h3>
<p >This is most natural to discuss from the sending perspective; the receiving perspective will flow naturally from that. (We'll talk about <a class="el" href="classipc_1_1transport_1_1sync__io_1_1Native__socket__stream_1_1Impl.html#a59e9935bdd704c40173a40e87b5db131" title="See Native_socket_stream counterpart.">send_native_handle()</a> and <a class="el" href="classipc_1_1transport_1_1sync__io_1_1Native__socket__stream_1_1Impl.html#aa3b06f1d59f5635c81a99e4ae8f7b8c7" title="See Native_socket_stream counterpart.">async_receive_native_handle()</a>; the <code>*_blob()</code> variants are mere degenerate versions of those. We'll also talk of <a class="el" href="classipc_1_1transport_1_1sync__io_1_1Native__socket__stream_1_1Impl.html#aef7a604a32db50eaf5fc501e5a205dd3" title="See Native_socket_stream counterpart.">end_sending()</a> as opposed to <a class="el" href="classipc_1_1transport_1_1sync__io_1_1Native__socket__stream_1_1Impl.html#a0aca995c7150e72219b422c188d9bc23" title="See Native_socket_stream counterpart.">async_end_sending()</a>, as the latter involves the same protocol &ndash; only adding a way of signaling the local user about completion which is irrelevant here.)</p>
<p >To summarize, overall, <a class="el" href="classipc_1_1transport_1_1sync__io_1_1Native__socket__stream_1_1Impl.html#a59e9935bdd704c40173a40e87b5db131" title="See Native_socket_stream counterpart.">send_native_handle()</a> takes a non-<code>null()</code> <a class="el" href="namespaceipc_1_1transport.html#a7ee4551983d9df16ec16a3139bac50e8" title="Convenience alias for the commonly used type util::Native_handle.">Native_handle</a>, a non-empty <a class="el" href="namespaceipc_1_1util.html#ae0be7edba7e30ffa3f8b742af621f2ab" title="Short-hand for an immutable blob somewhere in memory, stored as exactly a void const * and a size_t.">util::Blob_const</a> (buffer), or both; call the two together (one of which may be null/empty) a <em>user message</em>. The other side is to receive the entire <em>user message</em> unchanged and without re-ordering w/r/t other user messages from preceding or succeeding calls. In addition, if user invokes <a class="el" href="classipc_1_1transport_1_1sync__io_1_1Native__socket__stream_1_1Impl.html#aef7a604a32db50eaf5fc501e5a205dd3" title="See Native_socket_stream counterpart.">end_sending()</a>, the effect on the other side should be as if a special (safely distinguished from normal user messages) user message was received indicating sending-direction pipe closing by the user (via a particular <a class="el" href="namespaceipc.html#aa3192e586cc45d3e7c22463bf2760f89" title="Short-hand for flow::Error_code which is very common.">Error_code</a> emitted to <a class="el" href="classipc_1_1transport_1_1sync__io_1_1Native__socket__stream_1_1Impl.html#aa3b06f1d59f5635c81a99e4ae8f7b8c7" title="See Native_socket_stream counterpart.">async_receive_native_handle()</a> completion handler).</p>
<p >Lastly <a class="el" href="classipc_1_1transport_1_1sync__io_1_1Native__socket__stream_1_1Impl.html#ab7b382067804495cbae180a5bc1a2757" title="See Native_socket_stream counterpart.">auto_ping()</a> mandates some kind of internal ping message which is to be ignored by the receiver other than resetting any idle time engaged via <a class="el" href="classipc_1_1transport_1_1sync__io_1_1Native__socket__stream_1_1Impl.html#abedd0db5a5ae04e47085728ae548d07c" title="See Native_socket_stream counterpart.">idle_timer_run()</a>.</p>
<p >That describes the top layer on either side. At the bottom (the low-level transport mechanism) is a local (Unix domain) peer socket through which we can send things. Briefly summarizing, it is capable of all of the above essentially directly with the following important exceptions or caveats:</p><ol type="1">
<li>Stream UDS don't usually# implement message boundary preservation &ndash; hence messages must be encoded somehow in such a way as to indicate message boundaries (and decoded on the other side). This is further complicated by the case when a native handle must also be sent together with the boundary-preserved blob.<ul>
<li>(#) <code>SOCK_STREAM</code> does not preserve message boundaries. <code>SEQ_PACKET</code> is very similar, apparently, but <em>does</em>. I (ygoldfel) decided against it due to a subjective feeling of "baggage": it's Linux-only (not POSIX), rarely used, lightly documented, and apparently spiritually associated with the obscure SCTP protocol. None of this is fatal (that I know of) but does not seem worth it given that, ultimately, a couple of bytes to encode a length over <code>SOCK_STREAM</code> = both easy and of low perf cost. (<code>SOCK_DGRAM</code> is not suitable, because we require a connection-based model.)</li>
</ul>
</li>
<li>There is no# equivalent to the <a class="el" href="classipc_1_1transport_1_1sync__io_1_1Native__socket__stream_1_1Impl.html#aef7a604a32db50eaf5fc501e5a205dd3" title="See Native_socket_stream counterpart.">end_sending()</a> (close-one-direction-but-not-the-other) feature natively &ndash; hence it must be encoded somehow yet without accidentally clashing with a normal user message (some kind "escaping" or equivalent is needed).<ul>
<li>(#) We avoid <code>shutdown(int how)</code> for the reasons detailed above.</li>
</ul>
</li>
<li>There is no built-in ping message either.</li>
</ol>
<p >Here's the protocol to handle these:</p><ul>
<li>Each user message (<a class="el" href="classipc_1_1transport_1_1sync__io_1_1Native__socket__stream_1_1Impl.html#a59e9935bdd704c40173a40e87b5db131" title="See Native_socket_stream counterpart.">send_native_handle()</a>) is represented, in the same order, by 1+ bytes and optionally a handle: all sent over stream UDS. Suppose (at least for exposition) we support blobs of size up to 64KiB. The user message is then encoded as 1-2 <em>payloads</em> in this order:<ul>
<li>Payload 1 (required): The <em>meta-length</em>, encoded as a native-endianness 2-byte number, indicating size of the meta-blob provided by the user; 0x0000 indicates no meta-blob. Plus, byte 1 may be paired with a native handle; or no such handle if user provided no handle. Note that meta-length=0 means there <em>must</em> be a handle; otherwise the user's sending nothing (not allowed by API).</li>
<li>Payload 2 (present unless meta-length=0x0000): The user-provided meta-blob, with given meta-length, verbatim.</li>
</ul>
</li>
<li>Graceful-close message (from <a class="el" href="classipc_1_1transport_1_1sync__io_1_1Native__socket__stream_1_1Impl.html#aef7a604a32db50eaf5fc501e5a205dd3" title="See Native_socket_stream counterpart.">end_sending()</a>) is encoded as 1 <em>payload</em>:<ul>
<li>Payload 1 (required): 2-byte number 0x0000; no native handle. Note this doesn't conflict with the above, since there 0x0000 implies there is a handle too.</li>
</ul>
</li>
<li>Auto-ping message (from <a class="el" href="classipc_1_1transport_1_1sync__io_1_1Native__socket__stream_1_1Impl.html#ab7b382067804495cbae180a5bc1a2757" title="See Native_socket_stream counterpart.">auto_ping()</a>) is encoded as 1 <em>payload</em>:<ul>
<li>Payload 1 (required): 2-byte number 0xFFFF; no native handle. Note this doesn't conflict with the above, since the length 0xFFFF is not allowed (due to <a class="el" href="classipc_1_1transport_1_1sync__io_1_1Native__socket__stream_1_1Impl.html#a7b825476c04ea53eccea862d34f830c6" title="See Native_socket_stream counterpart.">S_MAX_META_BLOB_LENGTH</a> excluding it).</li>
</ul>
</li>
</ul>
<p >Naturally if user doesn't <a class="el" href="classipc_1_1transport_1_1sync__io_1_1Native__socket__stream_1_1Impl.html#aef7a604a32db50eaf5fc501e5a205dd3" title="See Native_socket_stream counterpart.">end_sending()</a> before the whole thing is destroyed, then there is no graceful-close message either.</p>
<h3>Outgoing-direction impl design</h3>
<p >At construction, or entry to PEER state, we get a connected <a class="el" href="classipc_1_1transport_1_1sync__io_1_1Native__socket__stream_1_1Impl.html#a42aab631e9c70bfaa53764309adfe37c" title="The peer stream-type Unix domain socket; or null pointer if we&#39;ve detected the connection has become ...">m_peer_socket</a>; and then it's off to the races. Every message, whether from <code>send_*()</code>, the periodic <a class="el" href="classipc_1_1transport_1_1sync__io_1_1Native__socket__stream_1_1Impl.html#ab7b382067804495cbae180a5bc1a2757" title="See Native_socket_stream counterpart.">auto_ping()</a> timer firing, or <code>*end_sending()</code>, translates into a series of 1+ <em>low-level payloads</em>: each low-level payload containing: 0-1 <code>Native_handle</code>s associated with the 1st byte of the following; and ("the following") a contiguous location in memory (pointer + length) to send. At steady state, we can simply attempt to nb-send each payload, in sequence. Unless would-block is encountered &ndash; which should not occur often assuming good opposing-side behavior &ndash; this will simply work.</p>
<p >If it does not &ndash; would-block does occur &ndash; then:</p><ul>
<li>Any unsent payload(s), headed potentially by a fragment of one of them (if one was partially sent), have to be <em>copied</em> and <em>enqueued</em> on a pending-payloads queue. This is <a class="el" href="classipc_1_1transport_1_1sync__io_1_1Native__socket__stream_1_1Impl.html#a1af9eb83b9afee25ba153a2ca066858d" title="Queue storing (at head) the currently in-progress async write-op of a Snd_low_lvl_payload; followed b...">Impl::m_snd_pending_payloads_q</a>.</li>
<li>We initiate an async-wait on <a class="el" href="classipc_1_1transport_1_1sync__io_1_1Native__socket__stream_1_1Impl.html#a42aab631e9c70bfaa53764309adfe37c" title="The peer stream-type Unix domain socket; or null pointer if we&#39;ve detected the connection has become ...">Impl::m_peer_socket</a> becoming writable, executed via <code><a class="el" href="namespaceipc_1_1transport_1_1sync__io.html" title="sync_io-pattern counterparts to async-I/O-pattern object types in parent namespace ipc::transport.">sync_io</a></code> pattern.</li>
</ul>
<p >While this queue is not empty, any additional payloads (from the aforementioned sources &ndash; <code>send_*()</code>, etc.) that might be built go to the back of <code>m_snd_pending_payloads_q</code>.</p>
<p >While in this would-block state (where that queue is not empty), we await the async-wait's completion. Once it does come in we just try to send off the payloads again, this time off the queue. The sent stuff gets dequeued, if anything is left another async-wait is in order; etc.</p>
<h3>Incoming-direction impl design</h3>
<p >It is dealing with the in-pipe, which is independent of the out-pipe, with the exception of sharing the same handle (FD), <code>m_peer_socket</code>. (We've spoke of this already. Just see <code>m_peer_socket</code> doc header.) To deal with it, operate based on what we know of our own out-pipe:</p>
<p >The outgoing-direction algorithm is written to be agnostic as to what each low-level payload means: user messages (including graceful-close and auto-ping) are simply translated into "1+" payloads each, and then <code>m_snd_pending_payloads_q</code> just treats them as a sequence of payloads (it no longer matters how they came to be). However the incoming-direction algorithm does need to decode them back into the user messages that they originally meant. To see how, just go back to the "Internal protocol design" above. Each message starts with "payload 1," which is also the only one that might contain a <a class="el" href="namespaceipc_1_1transport.html#a7ee4551983d9df16ec16a3139bac50e8" title="Convenience alias for the commonly used type util::Native_handle.">Native_handle</a>. The payload 1 blob, always of length 2, is the "meta-length" field. In exactly 1 scenario &ndash; where it's neither 0 nor 0xFFFF &ndash; is there payload 2 to read; and that one's length is the meta-length, and it is simply the entire meta-blob the sender sent. In all other scenarios, there is no payload 2 &ndash; the message is finalized; and it's off to the next one again.</p>
<p >So it's a state machine; not too exotic. Read payload 1; if that's the whole message back to the start; otherwise read payload 2; back to the start; if error (including idle-timeout or graceful-close) then stop algorithm.</p>
<p >As in the Native_handle_receiver/Blob_receiver concepts at most 1 <code>async_receive_*()</code> is outstanding at a time, that's all there is to the algorithm. That said the code can get somewhat hairy, due to the difficulty of expressing things that would've been pretty simple with boost.asio, such as <code>boost::asio::async_read()</code> free function (which will read exactly N bytes, no less, unless error occurs). We cannot do that stuff, as we have to issue async-waits to the user via <code><a class="el" href="namespaceipc_1_1transport_1_1sync__io.html" title="sync_io-pattern counterparts to async-I/O-pattern object types in parent namespace ipc::transport.">sync_io</a></code> pattern. <a class="el" href="namespaceipc_1_1transport.html#a7ee4551983d9df16ec16a3139bac50e8" title="Convenience alias for the commonly used type util::Native_handle.">Native_handle</a> complicates it a bit more too. That said all that stuff is tactical really. Just see the code.</p>
<h3>Connect-ops impl design</h3>
<p >The algorithm itself is easy enough to just follow in the code. What is subtle however, we think, is why it is structured the way it is. As per the public API of <a class="el" href="classipc_1_1transport_1_1sync__io_1_1Native__socket__stream.html" title="Implements both sync_io::Native_handle_sender and sync_io::Native_handle_receiver concepts by using a...">sync_io::Native_socket_stream</a> (and the async-I/O-pattern counterpart <a class="el" href="classipc_1_1transport_1_1Native__socket__stream.html" title="Implements both Native_handle_sender and Native_handle_receiver concepts by using a stream-oriented U...">transport::Native_socket_stream</a> for that matter), there is only the one public API, <a class="el" href="classipc_1_1transport_1_1sync__io_1_1Native__socket__stream_1_1Impl.html#a3c5187e34876a0419ff70734ec0fbf14" title="See Native_socket_stream counterpart.">sync_connect()</a>: it is non-blocking and synchronous, meaning it totally succeeds or fails immediately. <a class="el" href="classipc_1_1transport_1_1sync__io_1_1Native__socket__stream_1_1Impl.html#ad6443fb49be059dbe76c75d86a18197e" title="The core of sync_connect(), written in the sync_io-pattern style.">async_connect()</a> and <a class="el" href="classipc_1_1transport_1_1sync__io_1_1Native__socket__stream_1_1Impl.html#a3c6214376ab8bc59823635d405f9704a" title="It is start_ops&lt;Op::S_CONN&gt;().">start_connect_ops()</a> are <code>private</code>; <a class="el" href="classipc_1_1transport_1_1sync__io_1_1Native__socket__stream_1_1Impl.html#a8b9839bb39e95a51ed7c920137438a21" title="See Native_socket_stream counterpart.">replace_event_wait_handles()</a> does not affect connect-ops. Yet <a class="el" href="classipc_1_1transport_1_1sync__io_1_1Native__socket__stream_1_1Impl.html#a3c5187e34876a0419ff70734ec0fbf14" title="See Native_socket_stream counterpart.">sync_connect()</a> is written around those <code>private</code> facilities. One, how is this even possible &ndash; if there's (even internally) an async step, how can <a class="el" href="classipc_1_1transport_1_1sync__io_1_1Native__socket__stream_1_1Impl.html#a3c5187e34876a0419ff70734ec0fbf14" title="See Native_socket_stream counterpart.">sync_connect()</a> be synchronous yet non-blocking? And two, supposing that is fine, then why write it this way &ndash; as if following the <code><a class="el" href="namespaceipc_1_1transport_1_1sync__io.html" title="sync_io-pattern counterparts to async-I/O-pattern object types in parent namespace ipc::transport.">sync_io</a></code> pattern but entirely within the internal code of a <code>*this</code>?</p>
<p >For the 1st question: First we quote the <a class="el" href="classipc_1_1transport_1_1Native__socket__stream.html" title="Implements both Native_handle_sender and Native_handle_receiver concepts by using a stream-oriented U...">transport::Native_socket_stream</a> public doc header which explains why there is only <code><a class="el" href="classipc_1_1transport_1_1sync__io_1_1Native__socket__stream_1_1Impl.html#a3c5187e34876a0419ff70734ec0fbf14" title="See Native_socket_stream counterpart.">sync_connect()</a></code> but no <code><a class="el" href="classipc_1_1transport_1_1sync__io_1_1Native__socket__stream_1_1Impl.html#ad6443fb49be059dbe76c75d86a18197e" title="The core of sync_connect(), written in the sync_io-pattern style.">async_connect()</a></code>: "Without networking, the other side (Native_stream_socket_acceptor) either exists/is listening; or no.
Connecting is a synchronous, non-blocking operation; so an &lt;tt&gt;async_connect()&lt;/tt&gt; API in this context only makes
life harder for the user.  (However, there are some serious plans to add a networking-capable counterpart
(probably via TCP at least) to Native_socket_stream; that one will almost certainly have an &lt;tt&gt;async_connect()&lt;/tt&gt;,
while its &lt;tt&gt;sync_connect()&lt;/tt&gt; will probably become potentially blocking.)" So that is why it works: internally with a Unix domain stream socket async-connect either immediately succeeds or fails in all situations, at least in Linux (as of this writing all that's supported). (There are some further details inline in <code><a class="el" href="classipc_1_1transport_1_1sync__io_1_1Native__socket__stream_1_1Impl.html#ad6443fb49be059dbe76c75d86a18197e" title="The core of sync_connect(), written in the sync_io-pattern style.">async_connect()</a></code> impl.) So internally it's simple to do a non-blocking sync-connect; return success/failure if not would-block; or async-wait for writability in the rare would-block situation; this too is resolved quickly, and we can internally use a future-promise pair to briefly-await that resolution inside <a class="el" href="classipc_1_1transport_1_1sync__io_1_1Native__socket__stream_1_1Impl.html#a3c5187e34876a0419ff70734ec0fbf14" title="See Native_socket_stream counterpart.">sync_connect()</a>.</p>
<p >That doesn't answer the 2nd question: Why is it written like this? It would seem the code could be more compact if it were not written in the <code><a class="el" href="namespaceipc_1_1transport_1_1sync__io.html" title="sync_io-pattern counterparts to async-I/O-pattern object types in parent namespace ipc::transport.">sync_io</a></code>-pattern fashion, wherein we have a (<code>private</code>) <a class="el" href="classipc_1_1transport_1_1sync__io_1_1Native__socket__stream_1_1Impl.html#a3c6214376ab8bc59823635d405f9704a" title="It is start_ops&lt;Op::S_CONN&gt;().">start_connect_ops()</a> and call it as-if we're an outside connect-ops user of sorts. Answer: Truthfully, historically, I (ygoldfel) originally wrote it that way not really contemplating closely whether a local-socket connect-op can really take a blocking amount of time; and <a class="el" href="classipc_1_1transport_1_1sync__io_1_1Native__socket__stream_1_1Impl.html#ad6443fb49be059dbe76c75d86a18197e" title="The core of sync_connect(), written in the sync_io-pattern style.">async_connect()</a> <em>was</em> public. Once I looked into it however, it became clear that it's always quick, which allowed various APIs &ndash; all the way up to <a class="el" href="classipc_1_1session_1_1Session.html" title="A documentation-only concept defining the local side of an IPC conversation (session) with another en...">ipc::session::Session</a> connect API &ndash; quite a bit more convenient to use. At that point making only a public <code><a class="el" href="classipc_1_1transport_1_1sync__io_1_1Native__socket__stream_1_1Impl.html#a3c5187e34876a0419ff70734ec0fbf14" title="See Native_socket_stream counterpart.">sync_connect()</a></code> became a no-brainer. However, while I did contemplate then cutting down that code to get rid of the <code><a class="el" href="namespaceipc_1_1transport_1_1sync__io.html" title="sync_io-pattern counterparts to async-I/O-pattern object types in parent namespace ipc::transport.">sync_io</a></code>-pattern structuring, I realized that over time this would only hurt us. Why? Answer: As we said publicly in the quote above, there probably <em>will</em> be a networked public <code><a class="el" href="classipc_1_1transport_1_1sync__io_1_1Native__socket__stream_1_1Impl.html#ad6443fb49be059dbe76c75d86a18197e" title="The core of sync_connect(), written in the sync_io-pattern style.">async_connect()</a></code>, and a huge % of the code in the networked-socket-stream class containing it will be reused from <a class="el" href="classipc_1_1transport_1_1sync__io_1_1Native__socket__stream.html" title="Implements both sync_io::Native_handle_sender and sync_io::Native_handle_receiver concepts by using a...">Native_socket_stream</a>. At that point the <code><a class="el" href="namespaceipc_1_1transport_1_1sync__io.html" title="sync_io-pattern counterparts to async-I/O-pattern object types in parent namespace ipc::transport.">sync_io</a></code>-pattern-based structuring will come in quite handy. It's a subjective decision, undoubtedly, but I feel pretty good about it. Also, it's really not all that much complex; after all the <code><a class="el" href="namespaceipc_1_1transport_1_1sync__io.html" title="sync_io-pattern counterparts to async-I/O-pattern object types in parent namespace ipc::transport.">sync_io</a></code> pattern is used all over the place including our own <code>*this</code> send-ops and receive-ops.</p>
<h3>Error handling</h3>
<p >See <a class="el" href="classipc_1_1transport_1_1sync__io_1_1Native__socket__stream_1_1Impl.html#a0257a7903bff120aa1523f8de04bccf7" title="The first and only connection-hosing error condition detected when attempting to low-level-write on m...">Impl::m_snd_pending_err_code</a> and <a class="el" href="classipc_1_1transport_1_1sync__io_1_1Native__socket__stream_1_1Impl.html#ab824da16816893b2ffe2e778a7169b62" title="The first and only connection-hosing error condition detected when attempting to low-level-read on m_...">Impl::m_rcv_pending_err_code</a> doc headers. It's pretty simple: one that pipe is hosed, the appropriate one is set to truthy. Now any user sending or receiving (whichever is applicable to the pipe) immediately yields that error.</p>
<dl class="todo"><dt><b><a class="el" href="todo.html#_todo000015">Todo:</a></b></dt><dd>Internal <a class="el" href="classipc_1_1transport_1_1sync__io_1_1Native__socket__stream.html" title="Implements both sync_io::Native_handle_sender and sync_io::Native_handle_receiver concepts by using a...">Native_socket_stream</a> and <a class="el" href="classipc_1_1transport_1_1sync__io_1_1Native__socket__stream__acceptor.html" title="sync_io-pattern counterpart to async-I/O-pattern transport::Native_socket_stream_acceptor.">Native_socket_stream_acceptor</a> queue algorithms and data structures should be checked for RAM use; perhaps something should be periodically shrunk if applicable. Look for <code>vector</code>s, <code>deque</code>s (including inside <code>queue</code>s).</dd></dl>
<h3>Protocol negotiation</h3>
<p >This adds a bit of stuff onto the above protocol. It is very simple; please see <a class="el" href="classipc_1_1transport_1_1Protocol__negotiator.html" title="A simple state machine that, assuming the opposide side of a comm pathway uses an equivalent state ma...">Protocol_negotiator</a> doc header; we use that convention. Moreover, since this is the init version (version 1) of the protocol, we need not worry about speaking more than one version. On the send side: All we do is send the version ahead of the first payload that would otherwise be sent for any reason (user message from <code>send_*()</code>, end-sending token from <code>*end_sending()</code>, or ping from <a class="el" href="classipc_1_1transport_1_1sync__io_1_1Native__socket__stream_1_1Impl.html#ab7b382067804495cbae180a5bc1a2757" title="See Native_socket_stream counterpart.">auto_ping()</a>, as of this writing), as a special message that is identical to a normal payload 1 (see above) whose contents are (instead of the usual length) the protocol version, namely the value <code>1</code>, meaning version 1. Conversely on the receive side: we expect the first message received to be a native-handle-free paylod 1 with contents encoding a version number; then we let <a class="el" href="classipc_1_1transport_1_1Protocol__negotiator.html" title="A simple state machine that, assuming the opposide side of a comm pathway uses an equivalent state ma...">Protocol_negotiator</a> do its thing in determining the protocol version spoken.</p>
<dl class="section note"><dt>Note</dt><dd>It is very tempting to do that initial send in lazy fashion: meaning, about to send the first "real" payload? OK, then pre-pend the negotiation message. However this can create trouble in the future, if a future protocol wants to be backwards-compatible (support more than 2 protocol versions): we'll need to have received the opposing guy's preferred version, and thus determined which version to speak, before sending further (non-negotiation) messages. Bottom line... the initial send shall occur as soon as we are operational (<a class="el" href="classipc_1_1transport_1_1sync__io_1_1Native__socket__stream_1_1Impl.html#a6a01d2df2772ee72e4386e84684394e3" title="See Native_socket_stream counterpart.">start_send_blob_ops()</a>).</dd></dl>
<p>After that, we just speak what we speak... which is the protocol's initial version &ndash; as there is no other version for us. (The opposing-side peer is responsible for closing the stream, if it is unable to speak version 1.)</p>
<p >If we do add protocol version 2, etc., in the future, then things <em>might</em> become somewhat more complex (but even then not necessarily so). This is discussed in the <code><a class="el" href="classipc_1_1transport_1_1Protocol__negotiator.html" title="A simple state machine that, assuming the opposide side of a comm pathway uses an equivalent state ma...">Protocol_negotiator</a> m_protocol_negotiator</code> member doc header.</p>
<dl class="section note"><dt>Note</dt><dd>We suggest that if version 2, etc., is/are added, then the above notes be kept more or less intact; then add updates to show changes. This will provide a good overview of how the protocol evolved; and our backwards-compatibility story (even if we decide to have no backwards-compatibility). </dd></dl>

<p class="definition">Definition at line <a class="el" href="sync__io_2detail_2native__socket__stream__impl_8hpp_source.html#l00314">314</a> of file <a class="el" href="sync__io_2detail_2native__socket__stream__impl_8hpp_source.html">native_socket_stream_impl.hpp</a>.</p>
</div><h2 class="groupheader">Member Typedef Documentation</h2>
<a id="a881c376f1ee37f9b1a20f770824f55d9" name="a881c376f1ee37f9b1a20f770824f55d9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a881c376f1ee37f9b1a20f770824f55d9">&#9670;&nbsp;</a></span>low_lvl_payload_blob_length_t</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classipc_1_1transport_1_1sync__io_1_1Native__socket__stream_1_1Impl.html#a881c376f1ee37f9b1a20f770824f55d9">ipc::transport::sync_io::Native_socket_stream::Impl::low_lvl_payload_blob_length_t</a> =  uint16_t</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>The type used to encode the meta-blob length; this puts a cap on how long the meta-blobs can be. </p>

<p class="definition">Definition at line <a class="el" href="sync__io_2detail_2native__socket__stream__impl_8hpp_source.html#l00685">685</a> of file <a class="el" href="sync__io_2detail_2native__socket__stream__impl_8hpp_source.html">native_socket_stream_impl.hpp</a>.</p>

</div>
</div>
<h2 class="groupheader">Member Enumeration Documentation</h2>
<a id="ac5471d1f4f7cad2aeb239b5f458f12f2" name="ac5471d1f4f7cad2aeb239b5f458f12f2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac5471d1f4f7cad2aeb239b5f458f12f2">&#9670;&nbsp;</a></span>Op</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">enum class <a class="el" href="classipc_1_1transport_1_1sync__io_1_1Native__socket__stream_1_1Impl.html#ac5471d1f4f7cad2aeb239b5f458f12f2">ipc::transport::sync_io::Native_socket_stream::Impl::Op</a></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">strong</span><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compile-time tagging enumeration identifying the op-type of a given <code><a class="el" href="namespaceipc_1_1transport_1_1sync__io.html" title="sync_io-pattern counterparts to async-I/O-pattern object types in parent namespace ipc::transport.">sync_io</a></code> activity. </p>
<p >We use it to save on boiler-plate code which is almost identical regardless of the op-type in question. <code>if constexpr()</code>, etc. </p>

<p class="definition">Definition at line <a class="el" href="sync__io_2detail_2native__socket__stream__impl_8hpp_source.html#l00674">674</a> of file <a class="el" href="sync__io_2detail_2native__socket__stream__impl_8hpp_source.html">native_socket_stream_impl.hpp</a>.</p>

</div>
</div>
<a id="a0e765fbfee2c76293b572b01c9be5680" name="a0e765fbfee2c76293b572b01c9be5680"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0e765fbfee2c76293b572b01c9be5680">&#9670;&nbsp;</a></span>Rcv_msg_state</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">enum class <a class="el" href="classipc_1_1transport_1_1sync__io_1_1Native__socket__stream_1_1Impl.html#a0e765fbfee2c76293b572b01c9be5680">ipc::transport::sync_io::Native_socket_stream::Impl::Rcv_msg_state</a></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">strong</span><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Used to organize tje incoming-direction state machine tactically, this indicates what part of payload 1 ("head payload," mandatory) or payload 2 ("meta-blob payload," optional) we are currently reading, based on the next byte to be read. </p>
<p >Relevant only if <a class="el" href="classipc_1_1transport_1_1sync__io_1_1Native__socket__stream_1_1Impl.html#a9098de978da64572c419019597274d68" title="Null if no async_receive_*() is currently pending; else describes the arguments to that pending async...">m_rcv_user_request</a> is not null (an async-receive is in progress). </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="a0e765fbfee2c76293b572b01c9be5680a89db9d0c66e2aa217b6106106d0e95a2" name="a0e765fbfee2c76293b572b01c9be5680a89db9d0c66e2aa217b6106106d0e95a2"></a>S_MSG_START&#160;</td><td class="fielddoc"><p >Reading start of payload 1: already have nothing &ndash; no <a class="el" href="namespaceipc_1_1transport.html#a7ee4551983d9df16ec16a3139bac50e8" title="Convenience alias for the commonly used type util::Native_handle.">Native_handle</a>; no 1st byte. </p>
</td></tr>
<tr><td class="fieldname"><a id="a0e765fbfee2c76293b572b01c9be5680a3249b7cad0ab1d3cc8e9960568a412ae" name="a0e765fbfee2c76293b572b01c9be5680a3249b7cad0ab1d3cc8e9960568a412ae"></a>S_HEAD_PAYLOAD&#160;</td><td class="fielddoc"><p >Reading payload 1, but at least byte 2: alreadu have at least byte 1 and either the <a class="el" href="namespaceipc_1_1transport.html#a7ee4551983d9df16ec16a3139bac50e8" title="Convenience alias for the commonly used type util::Native_handle.">Native_handle</a> or its lack. </p>
<p >At least 1 more byte, of <code>sizeof(m_rcv_target_meta_length)</code>, is remaining. (As of this writing &ndash; that <code>sizeof()</code> is 2... so in fact in this state exactly 1 byte remains. No need to rely on that in code though.) </p>
</td></tr>
<tr><td class="fieldname"><a id="a0e765fbfee2c76293b572b01c9be5680afd393481cb76843d8c7ab099451efaf1" name="a0e765fbfee2c76293b572b01c9be5680afd393481cb76843d8c7ab099451efaf1"></a>S_META_BLOB_PAYLOAD&#160;</td><td class="fielddoc"><p >Reading payload 2; M bytes remain, where M is in [1, N], and N is the meta-length encoded in preceding payload 1. </p>
</td></tr>
</table>

<p class="definition">Definition at line <a class="el" href="sync__io_2detail_2native__socket__stream__impl_8hpp_source.html#l00650">650</a> of file <a class="el" href="sync__io_2detail_2native__socket__stream__impl_8hpp_source.html">native_socket_stream_impl.hpp</a>.</p>

</div>
</div>
<a id="a9c9825f74472868eb1397c33edf78fb4" name="a9c9825f74472868eb1397c33edf78fb4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9c9825f74472868eb1397c33edf78fb4">&#9670;&nbsp;</a></span>State</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">enum class <a class="el" href="classipc_1_1transport_1_1sync__io_1_1Native__socket__stream_1_1Impl.html#a9c9825f74472868eb1397c33edf78fb4">ipc::transport::sync_io::Native_socket_stream::Impl::State</a></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">strong</span><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Overall state of a <a class="el" href="classipc_1_1transport_1_1sync__io_1_1Native__socket__stream_1_1Impl.html" title="Internal, non-movable pImpl implementation of sync_io::Native_socket_stream class.">Native_socket_stream::Impl</a>. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="a9c9825f74472868eb1397c33edf78fb4ac6bd7568063494695099321f427efcb2" name="a9c9825f74472868eb1397c33edf78fb4ac6bd7568063494695099321f427efcb2"></a>S_NULL&#160;</td><td class="fielddoc"><p >Not a peer. </p>
<p >Barring moves-from/moves-to: Possible initial state (via certain ctors); goes to CONNECTING (via <a class="el" href="classipc_1_1transport_1_1sync__io_1_1Native__socket__stream_1_1Impl.html#ad6443fb49be059dbe76c75d86a18197e" title="The core of sync_connect(), written in the sync_io-pattern style.">async_connect()</a>). Only <a class="el" href="classipc_1_1transport_1_1sync__io_1_1Native__socket__stream_1_1Impl.html#ad6443fb49be059dbe76c75d86a18197e" title="The core of sync_connect(), written in the sync_io-pattern style.">async_connect()</a> (via public <a class="el" href="classipc_1_1transport_1_1sync__io_1_1Native__socket__stream_1_1Impl.html#a3c5187e34876a0419ff70734ec0fbf14" title="See Native_socket_stream counterpart.">sync_connect()</a>) is possible in this state (other public methods tend to return immediately). </p>
</td></tr>
<tr><td class="fieldname"><a id="a9c9825f74472868eb1397c33edf78fb4aae585d03fce4ac2011967830bf0ffbfb" name="a9c9825f74472868eb1397c33edf78fb4aae585d03fce4ac2011967830bf0ffbfb"></a>S_CONNECTING&#160;</td><td class="fielddoc"><p >Not a peer but <a class="el" href="classipc_1_1transport_1_1sync__io_1_1Native__socket__stream_1_1Impl.html#ad6443fb49be059dbe76c75d86a18197e" title="The core of sync_connect(), written in the sync_io-pattern style.">async_connect()</a> in progress to try to make it a peer. </p>
<p >Barring moves-from/moves-to: Entry from NULL; goes to PEER or NULL. </p>
</td></tr>
<tr><td class="fieldname"><a id="a9c9825f74472868eb1397c33edf78fb4ad9a05d721258c584cd559c56fd035887" name="a9c9825f74472868eb1397c33edf78fb4ad9a05d721258c584cd559c56fd035887"></a>S_PEER&#160;</td><td class="fielddoc"><p >Is or was a connected peer. </p>
<p >Barring moves-from/moves-to: Possible initial state (via certain ctors); entry from CONNECTING; does not transition to any other state (once a PEER, always a PEER). <a class="el" href="classipc_1_1transport_1_1sync__io_1_1Native__socket__stream_1_1Impl.html#ad6443fb49be059dbe76c75d86a18197e" title="The core of sync_connect(), written in the sync_io-pattern style.">async_connect()</a> is not possible in this state (it returns immediately); other public methods are possible. </p>
</td></tr>
</table>

<p class="definition">Definition at line <a class="el" href="sync__io_2detail_2native__socket__stream__impl_8hpp_source.html#l00576">576</a> of file <a class="el" href="sync__io_2detail_2native__socket__stream__impl_8hpp_source.html">native_socket_stream_impl.hpp</a>.</p>

</div>
</div>
<h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="ae9194e2eefe81185d1bf067b1f934657" name="ae9194e2eefe81185d1bf067b1f934657"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae9194e2eefe81185d1bf067b1f934657">&#9670;&nbsp;</a></span>Impl() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">ipc::transport::sync_io::Native_socket_stream::Impl::Impl </td>
          <td>(</td>
          <td class="paramtype">flow::log::Logger *&#160;</td>
          <td class="paramname"><em>logger_ptr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceipc_1_1util.html#ae6ac47812a90d1287c61e0b7de7bc4f5">util::String_view</a>&#160;</td>
          <td class="paramname"><em>nickname_str</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">explicit</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>See <a class="el" href="classipc_1_1transport_1_1sync__io_1_1Native__socket__stream.html" title="Implements both sync_io::Native_handle_sender and sync_io::Native_handle_receiver concepts by using a...">Native_socket_stream</a> counterpart. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">logger_ptr</td><td>See <a class="el" href="classipc_1_1transport_1_1sync__io_1_1Native__socket__stream.html" title="Implements both sync_io::Native_handle_sender and sync_io::Native_handle_receiver concepts by using a...">Native_socket_stream</a> counterpart. </td></tr>
    <tr><td class="paramname">nickname_str</td><td>See <a class="el" href="classipc_1_1transport_1_1sync__io_1_1Native__socket__stream.html" title="Implements both sync_io::Native_handle_sender and sync_io::Native_handle_receiver concepts by using a...">Native_socket_stream</a> counterpart. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="sync__io_2detail_2native__socket__stream__impl_8cpp_source.html#l00069">69</a> of file <a class="el" href="sync__io_2detail_2native__socket__stream__impl_8cpp_source.html">native_socket_stream_impl.cpp</a>.</p>

<p class="reference">References <a class="el" href="asio__waitable__native__hndl_8cpp_source.html#l00065">ipc::util::sync_io::Asio_waitable_native_handle::assign()</a>, <a class="el" href="sync__io_2native__socket__stream_8cpp_source.html#l00148">ipc::transport::sync_io::Native_socket_stream::get_logger()</a>, <a class="el" href="sync__io_2detail_2native__socket__stream__impl_8hpp_source.html#l01379">m_conn_async_worker</a>, <a class="el" href="sync__io_2detail_2native__socket__stream__impl_8hpp_source.html#l01409">m_conn_ev_wait_hndl_peer_socket</a>, <a class="el" href="sync__io_2detail_2native__socket__stream__impl_8hpp_source.html#l01355">m_ev_wait_hndl_peer_socket</a>, <a class="el" href="sync__io_2detail_2native__socket__stream__impl_8hpp_source.html#l01182">m_nb_task_engine</a>, <a class="el" href="sync__io_2detail_2native__socket__stream__impl_8hpp_source.html#l01299">m_peer_socket</a>, <a class="el" href="sync__io_2detail_2native__socket__stream__impl_8cpp_source.html#l00499">nickname()</a>, and <a class="el" href="sync__io_2detail_2native__socket__stream__impl_8cpp_source.html#l00181">start_connect_ops()</a>.</p>
<div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="classipc_1_1transport_1_1sync__io_1_1Native__socket__stream_1_1Impl_ae9194e2eefe81185d1bf067b1f934657_cgraph.svg" width="630" height="275"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe>
</div>
</div>

</div>
</div>
<a id="a90f29990e2e88052232c218c076414c7" name="a90f29990e2e88052232c218c076414c7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a90f29990e2e88052232c218c076414c7">&#9670;&nbsp;</a></span>Impl() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">ipc::transport::sync_io::Native_socket_stream::Impl::Impl </td>
          <td>(</td>
          <td class="paramtype">flow::log::Logger *&#160;</td>
          <td class="paramname"><em>logger_ptr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceipc_1_1util.html#ae6ac47812a90d1287c61e0b7de7bc4f5">util::String_view</a>&#160;</td>
          <td class="paramname"><em>nickname_str</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceipc_1_1transport.html#a7ee4551983d9df16ec16a3139bac50e8">Native_handle</a> &amp;&amp;&#160;</td>
          <td class="paramname"><em>native_peer_socket_moved</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">explicit</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>See <a class="el" href="classipc_1_1transport_1_1sync__io_1_1Native__socket__stream.html" title="Implements both sync_io::Native_handle_sender and sync_io::Native_handle_receiver concepts by using a...">Native_socket_stream</a> counterpart. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">logger_ptr</td><td>See <a class="el" href="classipc_1_1transport_1_1sync__io_1_1Native__socket__stream.html" title="Implements both sync_io::Native_handle_sender and sync_io::Native_handle_receiver concepts by using a...">Native_socket_stream</a> counterpart. </td></tr>
    <tr><td class="paramname">native_peer_socket_moved</td><td>See <a class="el" href="classipc_1_1transport_1_1sync__io_1_1Native__socket__stream.html" title="Implements both sync_io::Native_handle_sender and sync_io::Native_handle_receiver concepts by using a...">Native_socket_stream</a> counterpart. </td></tr>
    <tr><td class="paramname">nickname_str</td><td>See <a class="el" href="classipc_1_1transport_1_1sync__io_1_1Native__socket__stream.html" title="Implements both sync_io::Native_handle_sender and sync_io::Native_handle_receiver concepts by using a...">Native_socket_stream</a> counterpart. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="sync__io_2detail_2native__socket__stream__impl_8cpp_source.html#l00147">147</a> of file <a class="el" href="sync__io_2detail_2native__socket__stream__impl_8cpp_source.html">native_socket_stream_impl.cpp</a>.</p>

<p class="reference">References <a class="el" href="asio__waitable__native__hndl_8cpp_source.html#l00065">ipc::util::sync_io::Asio_waitable_native_handle::assign()</a>, <a class="el" href="sync__io_2detail_2native__socket__stream__impl_8hpp_source.html#l01355">m_ev_wait_hndl_peer_socket</a>, <a class="el" href="sync__io_2detail_2native__socket__stream__impl_8hpp_source.html#l01182">m_nb_task_engine</a>, <a class="el" href="sync__io_2detail_2native__socket__stream__impl_8hpp_source.html#l01299">m_peer_socket</a>, <a class="el" href="sync__io_2detail_2native__socket__stream__impl_8hpp_source.html#l01145">m_state</a>, and <a class="el" href="classipc_1_1transport_1_1sync__io_1_1Native__socket__stream_1_1Impl.html#a9c9825f74472868eb1397c33edf78fb4ad9a05d721258c584cd559c56fd035887">S_PEER</a>.</p>
<div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="classipc_1_1transport_1_1sync__io_1_1Native__socket__stream_1_1Impl_a90f29990e2e88052232c218c076414c7_cgraph.svg" width="564" height="59"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe>
</div>
</div>

</div>
</div>
<a id="adeb067b178e7688dde0ca7c5eb877b1d" name="adeb067b178e7688dde0ca7c5eb877b1d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adeb067b178e7688dde0ca7c5eb877b1d">&#9670;&nbsp;</a></span>~Impl()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ipc::transport::sync_io::Native_socket_stream::Impl::~Impl </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>See <a class="el" href="classipc_1_1transport_1_1sync__io_1_1Native__socket__stream.html" title="Implements both sync_io::Native_handle_sender and sync_io::Native_handle_receiver concepts by using a...">Native_socket_stream</a> counterpart. </p>

<p class="definition">Definition at line <a class="el" href="sync__io_2detail_2native__socket__stream__impl_8cpp_source.html#l00174">174</a> of file <a class="el" href="sync__io_2detail_2native__socket__stream__impl_8cpp_source.html">native_socket_stream_impl.cpp</a>.</p>

</div>
</div>
<a id="ae43a7982c98b4eb6501e7f74f3f6fa04" name="ae43a7982c98b4eb6501e7f74f3f6fa04"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae43a7982c98b4eb6501e7f74f3f6fa04">&#9670;&nbsp;</a></span>Impl() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">ipc::transport::sync_io::Native_socket_stream::Impl::Impl </td>
          <td>(</td>
          <td class="paramtype">flow::log::Logger *&#160;</td>
          <td class="paramname"><em>logger_ptr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceipc_1_1util.html#ae6ac47812a90d1287c61e0b7de7bc4f5">util::String_view</a>&#160;</td>
          <td class="paramname"><em>nickname_str</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::nullptr_t&#160;</td>
          <td class="paramname"><em>tag</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Helper delegated-to ctor that sets up everything except <a class="el" href="classipc_1_1transport_1_1sync__io_1_1Native__socket__stream_1_1Impl.html#a42aab631e9c70bfaa53764309adfe37c" title="The peer stream-type Unix domain socket; or null pointer if we&#39;ve detected the connection has become ...">m_peer_socket</a> (left null) and <a class="el" href="classipc_1_1transport_1_1sync__io_1_1Native__socket__stream_1_1Impl.html#a0ac6a82eda9256cba45f3b5365d79355" title="Descriptor waitable by outside event loop async-waits â€“ storing the same Native_handle as (and thus b...">m_ev_wait_hndl_peer_socket</a> (left holding no native handle); and sets NULL <a class="el" href="classipc_1_1transport_1_1sync__io_1_1Native__socket__stream_1_1Impl.html#a64e47a38b3ed59e37295336114918142" title="The current state of *this.">m_state</a>; the real ctor shall set both of them to their real initial values. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">logger_ptr</td><td>See other ctors. </td></tr>
    <tr><td class="paramname">nickname_str</td><td>See other ctors. </td></tr>
    <tr><td class="paramname">tag</td><td>Ctor-selecting tag. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="sync__io_2detail_2native__socket__stream__impl_8cpp_source.html#l00038">38</a> of file <a class="el" href="sync__io_2detail_2native__socket__stream__impl_8cpp_source.html">native_socket_stream_impl.cpp</a>.</p>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="ad6443fb49be059dbe76c75d86a18197e" name="ad6443fb49be059dbe76c75d86a18197e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad6443fb49be059dbe76c75d86a18197e">&#9670;&nbsp;</a></span>async_connect()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void ipc::transport::sync_io::Native_socket_stream::Impl::async_connect </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespaceipc_1_1transport.html#a33de1c256addb3964b839dc2dd407d24">Shared_name</a> &amp;&#160;</td>
          <td class="paramname"><em>absolute_name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceipc.html#aa3192e586cc45d3e7c22463bf2760f89">Error_code</a> *&#160;</td>
          <td class="paramname"><em>sync_err_code</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">flow::async::Task_asio_err &amp;&amp;&#160;</td>
          <td class="paramname"><em>on_done_func</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>The core of <a class="el" href="classipc_1_1transport_1_1sync__io_1_1Native__socket__stream_1_1Impl.html#a3c5187e34876a0419ff70734ec0fbf14" title="See Native_socket_stream counterpart.">sync_connect()</a>, written in the <code><a class="el" href="namespaceipc_1_1transport_1_1sync__io.html" title="sync_io-pattern counterparts to async-I/O-pattern object types in parent namespace ipc::transport.">sync_io</a></code>-pattern style. </p>
<p >See "Connect-ops impl design" in class doc header. This guy (in slightly modified form, likely returning <code>bool</code> for example) could someday become public, if we extend <code>*this</code> in some form to networked socket streams. Until then: this must be called in NULL state; otherwise behavior undefined (assertion may trip).</p>
<p >As of this writing &ndash; until it is networked &ndash; this will always complete in a non-blocking amount of time, even if the call yields would-block (<a class="el" href="namespaceipc_1_1transport_1_1error.html#adfef15ef4e76cc55d652fbd9c2797297aa667487757f9d6300f6888bac40bcc24" title="A sync_io operation could not immediately complete; it will complete contingent on active async-wait ...">error::Code::S_SYNC_IO_WOULD_BLOCK</a>). So in the latter case it is still guaranteed that the internally-triggered async-wait via <a class="el" href="classipc_1_1transport_1_1sync__io_1_1Native__socket__stream_1_1Impl.html#a3c6214376ab8bc59823635d405f9704a" title="It is start_ops&lt;Op::S_CONN&gt;().">start_connect_ops()</a> machinery shall be satisfied immediately. (See inside the code for OS-dependent subtleties, but the bottom line is as written.)</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">absolute_name</td><td>See <a class="el" href="classipc_1_1transport_1_1sync__io_1_1Native__socket__stream_1_1Impl.html#a3c5187e34876a0419ff70734ec0fbf14" title="See Native_socket_stream counterpart.">sync_connect()</a>. </td></tr>
    <tr><td class="paramname">sync_err_code</td><td>Must not be null (assertion may trip otherwise; but if this becomes public null would be allowed). That aside: Usual <code><a class="el" href="namespaceipc_1_1transport_1_1sync__io.html" title="sync_io-pattern counterparts to async-I/O-pattern object types in parent namespace ipc::transport.">sync_io</a></code>-pattern meaning: If connect succeded or failed synchronously, this is set to the result (falsy indicating reaching PEER state); otherwise set to the usual would-block value. In the latter case, per <code><a class="el" href="namespaceipc_1_1transport_1_1sync__io.html" title="sync_io-pattern counterparts to async-I/O-pattern object types in parent namespace ipc::transport.">sync_io</a></code>-pattern the <code><a class="el" href="classipc_1_1transport_1_1sync__io_1_1Native__socket__stream_1_1Impl.html#a3c6214376ab8bc59823635d405f9704a" title="It is start_ops&lt;Op::S_CONN&gt;().">start_connect_ops()</a></code>-passed async-wait function shall be invoked to await a native-handle event condition; and once the async op does complete, <code>on_done_func(E)</code> is invoked, where <code>E</code> is the async equivalent of <code>*sync_err_code</code>. </td></tr>
    <tr><td class="paramname">on_done_func</td><td>See <code>sync_err_code</code>. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="sync__io_2detail_2native__socket__stream__impl_8cpp_source.html#l00280">280</a> of file <a class="el" href="sync__io_2detail_2native__socket__stream__impl_8cpp_source.html">native_socket_stream_impl.cpp</a>.</p>

<p class="reference">References <a class="el" href="detail_2asio__local__stream__socket_8cpp_source.html#l00028">ipc::transport::asio_local_stream_socket::endpoint_at_shared_name()</a>, <a class="el" href="sync__io_2native__socket__stream_8cpp_source.html#l00148">ipc::transport::sync_io::Native_socket_stream::get_logger()</a>, and <a class="el" href="namespaceipc_1_1transport_1_1error.html#adfef15ef4e76cc55d652fbd9c2797297aa667487757f9d6300f6888bac40bcc24">ipc::transport::error::S_SYNC_IO_WOULD_BLOCK</a>.</p>
<div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="classipc_1_1transport_1_1sync__io_1_1Native__socket__stream_1_1Impl_ad6443fb49be059dbe76c75d86a18197e_cgraph.svg" width="640" height="171"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe>
</div>
</div>

</div>
</div>
<a id="a0aca995c7150e72219b422c188d9bc23" name="a0aca995c7150e72219b422c188d9bc23"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0aca995c7150e72219b422c188d9bc23">&#9670;&nbsp;</a></span>async_end_sending()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool ipc::transport::sync_io::Native_socket_stream::Impl::async_end_sending </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespaceipc.html#aa3192e586cc45d3e7c22463bf2760f89">Error_code</a> *&#160;</td>
          <td class="paramname"><em>sync_err_code</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">flow::async::Task_asio_err &amp;&amp;&#160;</td>
          <td class="paramname"><em>on_done_func</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>See <a class="el" href="classipc_1_1transport_1_1sync__io_1_1Native__socket__stream.html" title="Implements both sync_io::Native_handle_sender and sync_io::Native_handle_receiver concepts by using a...">Native_socket_stream</a> counterpart. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">sync_err_code</td><td>See <a class="el" href="classipc_1_1transport_1_1sync__io_1_1Native__socket__stream.html" title="Implements both sync_io::Native_handle_sender and sync_io::Native_handle_receiver concepts by using a...">Native_socket_stream</a> counterpart. </td></tr>
    <tr><td class="paramname">on_done_func</td><td>See <a class="el" href="classipc_1_1transport_1_1sync__io_1_1Native__socket__stream.html" title="Implements both sync_io::Native_handle_sender and sync_io::Native_handle_receiver concepts by using a...">Native_socket_stream</a> counterpart. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>See <a class="el" href="classipc_1_1transport_1_1sync__io_1_1Native__socket__stream.html" title="Implements both sync_io::Native_handle_sender and sync_io::Native_handle_receiver concepts by using a...">Native_socket_stream</a> counterpart. </dd></dl>

<p class="definition">Definition at line <a class="el" href="native__socket__stream__impl__snd_8cpp_source.html#l00276">276</a> of file <a class="el" href="native__socket__stream__impl__snd_8cpp_source.html">native_socket_stream_impl_snd.cpp</a>.</p>

</div>
</div>
<a id="a6337b0d5d703f124def66853e36b62e5" name="a6337b0d5d703f124def66853e36b62e5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6337b0d5d703f124def66853e36b62e5">&#9670;&nbsp;</a></span>async_end_sending_impl()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool ipc::transport::sync_io::Native_socket_stream::Impl::async_end_sending_impl </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespaceipc.html#aa3192e586cc45d3e7c22463bf2760f89">Error_code</a> *&#160;</td>
          <td class="paramname"><em>sync_err_code_ptr_or_null</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">flow::async::Task_asio_err &amp;&amp;&#160;</td>
          <td class="paramname"><em>on_done_func_or_empty</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><code>*end_sending()</code> body. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">sync_err_code_ptr_or_null</td><td>See <a class="el" href="classipc_1_1transport_1_1sync__io_1_1Native__socket__stream_1_1Impl.html#a0aca995c7150e72219b422c188d9bc23" title="See Native_socket_stream counterpart.">async_end_sending()</a>. Null if and only if invoked from the no-arg <a class="el" href="classipc_1_1transport_1_1sync__io_1_1Native__socket__stream_1_1Impl.html#aef7a604a32db50eaf5fc501e5a205dd3" title="See Native_socket_stream counterpart.">end_sending()</a>. Note well: even if <code>async_end_sending(sync_err_code = nullptr)</code> was used, this must not be null. </td></tr>
    <tr><td class="paramname">on_done_func_or_empty</td><td>See <a class="el" href="classipc_1_1transport_1_1sync__io_1_1Native__socket__stream_1_1Impl.html#a0aca995c7150e72219b422c188d9bc23" title="See Native_socket_stream counterpart.">async_end_sending()</a>. <code>.empty() == true</code> if and only if invoked from the no-arg <a class="el" href="classipc_1_1transport_1_1sync__io_1_1Native__socket__stream_1_1Impl.html#aef7a604a32db50eaf5fc501e5a205dd3" title="See Native_socket_stream counterpart.">end_sending()</a>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>See <a class="el" href="classipc_1_1transport_1_1sync__io_1_1Native__socket__stream_1_1Impl.html#a0aca995c7150e72219b422c188d9bc23" title="See Native_socket_stream counterpart.">async_end_sending()</a> and <a class="el" href="classipc_1_1transport_1_1sync__io_1_1Native__socket__stream_1_1Impl.html#aef7a604a32db50eaf5fc501e5a205dd3" title="See Native_socket_stream counterpart.">end_sending()</a>. </dd></dl>

<p class="definition">Definition at line <a class="el" href="native__socket__stream__impl__snd_8cpp_source.html#l00301">301</a> of file <a class="el" href="native__socket__stream__impl__snd_8cpp_source.html">native_socket_stream_impl_snd.cpp</a>.</p>

<p class="reference">References <a class="el" href="namespaceipc_1_1transport_1_1error.html#adfef15ef4e76cc55d652fbd9c2797297aa667487757f9d6300f6888bac40bcc24">ipc::transport::error::S_SYNC_IO_WOULD_BLOCK</a>.</p>

</div>
</div>
<a id="a4c3d1ba7c70649898a7893daf076c7ae" name="a4c3d1ba7c70649898a7893daf076c7ae"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4c3d1ba7c70649898a7893daf076c7ae">&#9670;&nbsp;</a></span>async_receive_blob()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool ipc::transport::sync_io::Native_socket_stream::Impl::async_receive_blob </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespaceipc_1_1util.html#a6cb62ae434900f3a8915b33ec5d61a96">util::Blob_mutable</a> &amp;&#160;</td>
          <td class="paramname"><em>target_blob</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceipc.html#aa3192e586cc45d3e7c22463bf2760f89">Error_code</a> *&#160;</td>
          <td class="paramname"><em>sync_err_code</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t *&#160;</td>
          <td class="paramname"><em>sync_sz</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">flow::async::Task_asio_err_sz &amp;&amp;&#160;</td>
          <td class="paramname"><em>on_done_func</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>See <a class="el" href="classipc_1_1transport_1_1sync__io_1_1Native__socket__stream.html" title="Implements both sync_io::Native_handle_sender and sync_io::Native_handle_receiver concepts by using a...">Native_socket_stream</a> counterpart. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">target_blob</td><td>See <a class="el" href="classipc_1_1transport_1_1sync__io_1_1Native__socket__stream.html" title="Implements both sync_io::Native_handle_sender and sync_io::Native_handle_receiver concepts by using a...">Native_socket_stream</a> counterpart. </td></tr>
    <tr><td class="paramname">sync_err_code</td><td>See <a class="el" href="classipc_1_1transport_1_1sync__io_1_1Native__socket__stream.html" title="Implements both sync_io::Native_handle_sender and sync_io::Native_handle_receiver concepts by using a...">Native_socket_stream</a> counterpart. </td></tr>
    <tr><td class="paramname">sync_sz</td><td>See <a class="el" href="classipc_1_1transport_1_1sync__io_1_1Native__socket__stream.html" title="Implements both sync_io::Native_handle_sender and sync_io::Native_handle_receiver concepts by using a...">Native_socket_stream</a> counterpart. </td></tr>
    <tr><td class="paramname">on_done_func</td><td>See <a class="el" href="classipc_1_1transport_1_1sync__io_1_1Native__socket__stream.html" title="Implements both sync_io::Native_handle_sender and sync_io::Native_handle_receiver concepts by using a...">Native_socket_stream</a> counterpart. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>See <a class="el" href="classipc_1_1transport_1_1sync__io_1_1Native__socket__stream.html" title="Implements both sync_io::Native_handle_sender and sync_io::Native_handle_receiver concepts by using a...">Native_socket_stream</a> counterpart. </dd></dl>

<p class="definition">Definition at line <a class="el" href="native__socket__stream__impl__rcv_8cpp_source.html#l00054">54</a> of file <a class="el" href="native__socket__stream__impl__rcv_8cpp_source.html">native_socket_stream_impl_rcv.cpp</a>.</p>

</div>
</div>
<a id="aa3b06f1d59f5635c81a99e4ae8f7b8c7" name="aa3b06f1d59f5635c81a99e4ae8f7b8c7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa3b06f1d59f5635c81a99e4ae8f7b8c7">&#9670;&nbsp;</a></span>async_receive_native_handle()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool ipc::transport::sync_io::Native_socket_stream::Impl::async_receive_native_handle </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespaceipc_1_1transport.html#a7ee4551983d9df16ec16a3139bac50e8">Native_handle</a> *&#160;</td>
          <td class="paramname"><em>target_hndl</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespaceipc_1_1util.html#a6cb62ae434900f3a8915b33ec5d61a96">util::Blob_mutable</a> &amp;&#160;</td>
          <td class="paramname"><em>target_meta_blob</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceipc.html#aa3192e586cc45d3e7c22463bf2760f89">Error_code</a> *&#160;</td>
          <td class="paramname"><em>sync_err_code</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t *&#160;</td>
          <td class="paramname"><em>sync_sz</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">flow::async::Task_asio_err_sz &amp;&amp;&#160;</td>
          <td class="paramname"><em>on_done_func</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>See <a class="el" href="classipc_1_1transport_1_1sync__io_1_1Native__socket__stream.html" title="Implements both sync_io::Native_handle_sender and sync_io::Native_handle_receiver concepts by using a...">Native_socket_stream</a> counterpart. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">target_hndl</td><td>See <a class="el" href="classipc_1_1transport_1_1sync__io_1_1Native__socket__stream.html" title="Implements both sync_io::Native_handle_sender and sync_io::Native_handle_receiver concepts by using a...">Native_socket_stream</a> counterpart. </td></tr>
    <tr><td class="paramname">target_meta_blob</td><td>See <a class="el" href="classipc_1_1transport_1_1sync__io_1_1Native__socket__stream.html" title="Implements both sync_io::Native_handle_sender and sync_io::Native_handle_receiver concepts by using a...">Native_socket_stream</a> counterpart. </td></tr>
    <tr><td class="paramname">sync_err_code</td><td>See <a class="el" href="classipc_1_1transport_1_1sync__io_1_1Native__socket__stream.html" title="Implements both sync_io::Native_handle_sender and sync_io::Native_handle_receiver concepts by using a...">Native_socket_stream</a> counterpart. </td></tr>
    <tr><td class="paramname">sync_sz</td><td>See <a class="el" href="classipc_1_1transport_1_1sync__io_1_1Native__socket__stream.html" title="Implements both sync_io::Native_handle_sender and sync_io::Native_handle_receiver concepts by using a...">Native_socket_stream</a> counterpart. </td></tr>
    <tr><td class="paramname">on_done_func</td><td>See <a class="el" href="classipc_1_1transport_1_1sync__io_1_1Native__socket__stream.html" title="Implements both sync_io::Native_handle_sender and sync_io::Native_handle_receiver concepts by using a...">Native_socket_stream</a> counterpart. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>See <a class="el" href="classipc_1_1transport_1_1sync__io_1_1Native__socket__stream.html" title="Implements both sync_io::Native_handle_sender and sync_io::Native_handle_receiver concepts by using a...">Native_socket_stream</a> counterpart. </dd></dl>

<p class="definition">Definition at line <a class="el" href="native__socket__stream__impl__rcv_8cpp_source.html#l00037">37</a> of file <a class="el" href="native__socket__stream__impl__rcv_8cpp_source.html">native_socket_stream_impl_rcv.cpp</a>.</p>

</div>
</div>
<a id="ae16d560bf3c4eccfa975d47af71cb145" name="ae16d560bf3c4eccfa975d47af71cb145"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae16d560bf3c4eccfa975d47af71cb145">&#9670;&nbsp;</a></span>async_receive_native_handle_impl()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool ipc::transport::sync_io::Native_socket_stream::Impl::async_receive_native_handle_impl </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespaceipc_1_1transport.html#a7ee4551983d9df16ec16a3139bac50e8">Native_handle</a> *&#160;</td>
          <td class="paramname"><em>target_hndl_or_null</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespaceipc_1_1util.html#a6cb62ae434900f3a8915b33ec5d61a96">util::Blob_mutable</a> &amp;&#160;</td>
          <td class="paramname"><em>target_meta_blob</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceipc.html#aa3192e586cc45d3e7c22463bf2760f89">Error_code</a> *&#160;</td>
          <td class="paramname"><em>sync_err_code</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t *&#160;</td>
          <td class="paramname"><em>sync_sz</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">flow::async::Task_asio_err_sz &amp;&amp;&#160;</td>
          <td class="paramname"><em>on_done_func</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Body of both <a class="el" href="classipc_1_1transport_1_1sync__io_1_1Native__socket__stream_1_1Impl.html#aa3b06f1d59f5635c81a99e4ae8f7b8c7" title="See Native_socket_stream counterpart.">async_receive_native_handle()</a> and <a class="el" href="classipc_1_1transport_1_1sync__io_1_1Native__socket__stream_1_1Impl.html#a4c3d1ba7c70649898a7893daf076c7ae" title="See Native_socket_stream counterpart.">async_receive_blob()</a>. </p>
<p >In the latter case <code>target_hndl_or_null</code> shall be null (otherwise it shall not).</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">target_hndl_or_null</td><td>See <a class="el" href="classipc_1_1transport_1_1sync__io_1_1Native__socket__stream_1_1Impl.html#aa3b06f1d59f5635c81a99e4ae8f7b8c7" title="See Native_socket_stream counterpart.">async_receive_native_handle()</a>; or null if <a class="el" href="classipc_1_1transport_1_1sync__io_1_1Native__socket__stream_1_1Impl.html#a4c3d1ba7c70649898a7893daf076c7ae" title="See Native_socket_stream counterpart.">async_receive_blob()</a>. </td></tr>
    <tr><td class="paramname">target_meta_blob</td><td>See <a class="el" href="classipc_1_1transport_1_1sync__io_1_1Native__socket__stream_1_1Impl.html#aa3b06f1d59f5635c81a99e4ae8f7b8c7" title="See Native_socket_stream counterpart.">async_receive_native_handle()</a>. </td></tr>
    <tr><td class="paramname">sync_err_code</td><td>See <a class="el" href="classipc_1_1transport_1_1sync__io_1_1Native__socket__stream_1_1Impl.html#aa3b06f1d59f5635c81a99e4ae8f7b8c7" title="See Native_socket_stream counterpart.">async_receive_native_handle()</a>. </td></tr>
    <tr><td class="paramname">sync_sz</td><td>See <a class="el" href="classipc_1_1transport_1_1sync__io_1_1Native__socket__stream_1_1Impl.html#aa3b06f1d59f5635c81a99e4ae8f7b8c7" title="See Native_socket_stream counterpart.">async_receive_native_handle()</a>. </td></tr>
    <tr><td class="paramname">on_done_func</td><td>See <a class="el" href="classipc_1_1transport_1_1sync__io_1_1Native__socket__stream_1_1Impl.html#aa3b06f1d59f5635c81a99e4ae8f7b8c7" title="See Native_socket_stream counterpart.">async_receive_native_handle()</a>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>See <a class="el" href="classipc_1_1transport_1_1sync__io_1_1Native__socket__stream_1_1Impl.html#aa3b06f1d59f5635c81a99e4ae8f7b8c7" title="See Native_socket_stream counterpart.">async_receive_native_handle()</a>. </dd></dl>

<p class="definition">Definition at line <a class="el" href="native__socket__stream__impl__rcv_8cpp_source.html#l00061">61</a> of file <a class="el" href="native__socket__stream__impl__rcv_8cpp_source.html">native_socket_stream_impl_rcv.cpp</a>.</p>

<p class="reference">References <a class="el" href="sync__io_2native__socket__stream_8hpp_source.html#l00179">ipc::transport::sync_io::Native_socket_stream::S_BLOB_UNDERFLOW_ALLOWED</a>, and <a class="el" href="namespaceipc_1_1transport_1_1error.html#adfef15ef4e76cc55d652fbd9c2797297aa667487757f9d6300f6888bac40bcc24">ipc::transport::error::S_SYNC_IO_WOULD_BLOCK</a>.</p>

</div>
</div>
<a id="ab7b382067804495cbae180a5bc1a2757" name="ab7b382067804495cbae180a5bc1a2757"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab7b382067804495cbae180a5bc1a2757">&#9670;&nbsp;</a></span>auto_ping()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool ipc::transport::sync_io::Native_socket_stream::Impl::auto_ping </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespaceipc_1_1util.html#ac66141280c3b7295a86b65209f31cc58">util::Fine_duration</a>&#160;</td>
          <td class="paramname"><em>period</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>See <a class="el" href="classipc_1_1transport_1_1sync__io_1_1Native__socket__stream.html" title="Implements both sync_io::Native_handle_sender and sync_io::Native_handle_receiver concepts by using a...">Native_socket_stream</a> counterpart. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">period</td><td>See <a class="el" href="classipc_1_1transport_1_1sync__io_1_1Native__socket__stream.html" title="Implements both sync_io::Native_handle_sender and sync_io::Native_handle_receiver concepts by using a...">Native_socket_stream</a> counterpart. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>See <a class="el" href="classipc_1_1transport_1_1sync__io_1_1Native__socket__stream.html" title="Implements both sync_io::Native_handle_sender and sync_io::Native_handle_receiver concepts by using a...">Native_socket_stream</a> counterpart. </dd></dl>

<p class="definition">Definition at line <a class="el" href="native__socket__stream__impl__snd_8cpp_source.html#l00439">439</a> of file <a class="el" href="native__socket__stream__impl__snd_8cpp_source.html">native_socket_stream_impl_snd.cpp</a>.</p>

</div>
</div>
<a id="aaf965dc1eea3bee807c2fb6c4a937bb5" name="aaf965dc1eea3bee807c2fb6c4a937bb5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaf965dc1eea3bee807c2fb6c4a937bb5">&#9670;&nbsp;</a></span>conn_on_ev_peer_socket_writable()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void ipc::transport::sync_io::Native_socket_stream::Impl::conn_on_ev_peer_socket_writable </td>
          <td>(</td>
          <td class="paramtype">flow::async::Task_asio_err &amp;&amp;&#160;</td>
          <td class="paramname"><em>on_done_func</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Handler for the async-wait in case <a class="el" href="classipc_1_1transport_1_1sync__io_1_1Native__socket__stream_1_1Impl.html#ad6443fb49be059dbe76c75d86a18197e" title="The core of sync_connect(), written in the sync_io-pattern style.">async_connect()</a> cannot synchronously complete the <a class="el" href="classipc_1_1transport_1_1sync__io_1_1Native__socket__stream_1_1Impl.html#a42aab631e9c70bfaa53764309adfe37c" title="The peer stream-type Unix domain socket; or null pointer if we&#39;ve detected the connection has become ...">m_peer_socket</a> connect (boost.asio yields would-block). </p>
<p >Post-condition: <code>on_done_func()</code> has finished. Note that this situation is unlikely, this being a Unix domain socket (details commented inside <a class="el" href="classipc_1_1transport_1_1sync__io_1_1Native__socket__stream_1_1Impl.html#ad6443fb49be059dbe76c75d86a18197e" title="The core of sync_connect(), written in the sync_io-pattern style.">async_connect()</a>). (That comment says that in Linux as of this writing it is impossible.) Moreover if we did get here, then we have to assume it's writable &ndash; connected &ndash; and can't (or at least don't) try to see if the connect really failed. That said, trying to use it will expose any error shortly (in PEER state).</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">on_done_func</td><td>See <a class="el" href="classipc_1_1transport_1_1sync__io_1_1Native__socket__stream_1_1Impl.html#ad6443fb49be059dbe76c75d86a18197e" title="The core of sync_connect(), written in the sync_io-pattern style.">async_connect()</a>. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="sync__io_2detail_2native__socket__stream__impl_8cpp_source.html#l00418">418</a> of file <a class="el" href="sync__io_2detail_2native__socket__stream__impl_8cpp_source.html">native_socket_stream_impl.cpp</a>.</p>

</div>
</div>
<a id="aef7a604a32db50eaf5fc501e5a205dd3" name="aef7a604a32db50eaf5fc501e5a205dd3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aef7a604a32db50eaf5fc501e5a205dd3">&#9670;&nbsp;</a></span>end_sending()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool ipc::transport::sync_io::Native_socket_stream::Impl::end_sending </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>See <a class="el" href="classipc_1_1transport_1_1sync__io_1_1Native__socket__stream.html" title="Implements both sync_io::Native_handle_sender and sync_io::Native_handle_receiver concepts by using a...">Native_socket_stream</a> counterpart. </p>
<dl class="section return"><dt>Returns</dt><dd>Ditto. </dd></dl>

<p class="definition">Definition at line <a class="el" href="native__socket__stream__impl__snd_8cpp_source.html#l00271">271</a> of file <a class="el" href="native__socket__stream__impl__snd_8cpp_source.html">native_socket_stream_impl_snd.cpp</a>.</p>

</div>
</div>
<a id="abedd0db5a5ae04e47085728ae548d07c" name="abedd0db5a5ae04e47085728ae548d07c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abedd0db5a5ae04e47085728ae548d07c">&#9670;&nbsp;</a></span>idle_timer_run()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool ipc::transport::sync_io::Native_socket_stream::Impl::idle_timer_run </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespaceipc_1_1util.html#ac66141280c3b7295a86b65209f31cc58">util::Fine_duration</a>&#160;</td>
          <td class="paramname"><em>timeout</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>See <a class="el" href="classipc_1_1transport_1_1sync__io_1_1Native__socket__stream.html" title="Implements both sync_io::Native_handle_sender and sync_io::Native_handle_receiver concepts by using a...">Native_socket_stream</a> counterpart. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">timeout</td><td>See <a class="el" href="classipc_1_1transport_1_1sync__io_1_1Native__socket__stream.html" title="Implements both sync_io::Native_handle_sender and sync_io::Native_handle_receiver concepts by using a...">Native_socket_stream</a> counterpart. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>See <a class="el" href="classipc_1_1transport_1_1sync__io_1_1Native__socket__stream.html" title="Implements both sync_io::Native_handle_sender and sync_io::Native_handle_receiver concepts by using a...">Native_socket_stream</a> counterpart. </dd></dl>

<p class="definition">Definition at line <a class="el" href="native__socket__stream__impl__rcv_8cpp_source.html#l00154">154</a> of file <a class="el" href="native__socket__stream__impl__rcv_8cpp_source.html">native_socket_stream_impl_rcv.cpp</a>.</p>

</div>
</div>
<a id="a0ddd1b1e57bc61827d457e16e3db8600" name="a0ddd1b1e57bc61827d457e16e3db8600"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0ddd1b1e57bc61827d457e16e3db8600">&#9670;&nbsp;</a></span>nickname()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const std::string &amp; ipc::transport::sync_io::Native_socket_stream::Impl::nickname </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>See <a class="el" href="classipc_1_1transport_1_1sync__io_1_1Native__socket__stream.html" title="Implements both sync_io::Native_handle_sender and sync_io::Native_handle_receiver concepts by using a...">Native_socket_stream</a> counterpart. </p>
<dl class="section return"><dt>Returns</dt><dd>See <a class="el" href="classipc_1_1transport_1_1sync__io_1_1Native__socket__stream.html" title="Implements both sync_io::Native_handle_sender and sync_io::Native_handle_receiver concepts by using a...">Native_socket_stream</a> counterpart. </dd></dl>

<p class="definition">Definition at line <a class="el" href="sync__io_2detail_2native__socket__stream__impl_8cpp_source.html#l00499">499</a> of file <a class="el" href="sync__io_2detail_2native__socket__stream__impl_8cpp_source.html">native_socket_stream_impl.cpp</a>.</p>

<p class="reference">Referenced by <a class="el" href="sync__io_2detail_2native__socket__stream__impl_8cpp_source.html#l00069">Impl()</a>.</p>
<div class="dynheader">
Here is the caller graph for this function:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="classipc_1_1transport_1_1sync__io_1_1Native__socket__stream_1_1Impl_a0ddd1b1e57bc61827d457e16e3db8600_icgraph.svg" width="387" height="59"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe>
</div>
</div>

</div>
</div>
<a id="a7457705b8f6e8fc6c73dd758e593c7a9" name="a7457705b8f6e8fc6c73dd758e593c7a9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7457705b8f6e8fc6c73dd758e593c7a9">&#9670;&nbsp;</a></span>op_started()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="classipc_1_1transport_1_1sync__io_1_1Native__socket__stream_1_1Impl.html#ac5471d1f4f7cad2aeb239b5f458f12f2">Op</a> OP&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool ipc::transport::sync_io::Native_socket_stream::Impl::op_started </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespaceipc_1_1util.html#ae6ac47812a90d1287c61e0b7de7bc4f5">util::String_view</a>&#160;</td>
          <td class="paramname"><em>context</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Helper that returns <code>true</code> silently if the given Op <code>start_*_ops()</code> has been called; else logs WARNING and returns <code>false</code>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">context</td><td>For logging: the algorithmic context (function name or whatever). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>See <code>start_*_ops()</code>. </dd></dl>

<p class="definition">Definition at line <a class="el" href="sync__io_2detail_2native__socket__stream__impl_8hpp_source.html#l01619">1619</a> of file <a class="el" href="sync__io_2detail_2native__socket__stream__impl_8hpp_source.html">native_socket_stream_impl.hpp</a>.</p>

</div>
</div>
<a id="a25e051170a8eb568745f809bb186f980" name="a25e051170a8eb568745f809bb186f980"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a25e051170a8eb568745f809bb186f980">&#9670;&nbsp;</a></span>rcv_nb_read_low_lvl_payload()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_t ipc::transport::sync_io::Native_socket_stream::Impl::rcv_nb_read_low_lvl_payload </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespaceipc_1_1transport.html#a7ee4551983d9df16ec16a3139bac50e8">Native_handle</a> *&#160;</td>
          <td class="paramname"><em>target_payload_hndl_or_null</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespaceipc_1_1util.html#a6cb62ae434900f3a8915b33ec5d61a96">util::Blob_mutable</a> &amp;&#160;</td>
          <td class="paramname"><em>target_payload_blob</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceipc.html#aa3192e586cc45d3e7c22463bf2760f89">Error_code</a> *&#160;</td>
          <td class="paramname"><em>err_code</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Utility that synchronously, non-blockingly attempts to read over <a class="el" href="classipc_1_1transport_1_1sync__io_1_1Native__socket__stream_1_1Impl.html#a42aab631e9c70bfaa53764309adfe37c" title="The peer stream-type Unix domain socket; or null pointer if we&#39;ve detected the connection has become ...">m_peer_socket</a> into the target blob and (optionally) <code>Native_handle</code> (nullifying it if not present), reporting error or would-block if encountered. </p>
<p >This is used for all sync-reads in this class. Note the result semantics are slightly different from boost.asio and its extensions, so watch out about would-block and such:</p>
<p ><code>*err_code</code> shall be set to success unless <a class="el" href="classipc_1_1transport_1_1sync__io_1_1Native__socket__stream_1_1Impl.html#a42aab631e9c70bfaa53764309adfe37c" title="The peer stream-type Unix domain socket; or null pointer if we&#39;ve detected the connection has become ...">m_peer_socket</a> connection is found to be hosed at any point throughout the operation. In particular neither would-block nor would-block after non-zero amount of data had been read are considered errors; 0 or a value <code>&lt; target_payload_blob.size()</code> are returned in those situations respectively. If <code>*err_code</code> is made truthy, <a class="el" href="classipc_1_1transport_1_1sync__io_1_1Native__socket__stream_1_1Impl.html#a42aab631e9c70bfaa53764309adfe37c" title="The peer stream-type Unix domain socket; or null pointer if we&#39;ve detected the connection has become ...">m_peer_socket</a> shall not be used (in either direction) subsequently.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">target_payload_hndl_or_null</td><td>If null, we will use a plain-read (even if there is a <code>Native_handle</code>, we will be none-the-wiser &ndash; we are not expecting it, so only pass null at the proper points in the protocol stream). Otherwise, if and only if 1+ bytes are read OK, then the pointee is set to either null (byte 1 not accompanied by a handle) or non-null (it was-too accompanied by a handle). </td></tr>
    <tr><td class="paramname">target_payload_blob</td><td>Target buffer (its size indicating how many bytes we want if possible). </td></tr>
    <tr><td class="paramname">err_code</td><td>See above: would-block is not an error. Return value should be ignored if <code>*err_code</code> has been made truthy. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>If <code>*err_code</code> is falsy at return time: 0 meaning<code>*target_payload_hndl_or_null</code> is indeterminate (if ptr was not null), and no bytes were received + would-block; [1, <code>blob.size()</code>] if <code>*target_payload_hndl_or_null</code> has been finalized (if ptr was not null), and that many bytes were indeed read into the start of <code>target_payload_blob</code>. <code>*err_code</code> shall be truthy only if (but not necessarily if) <code>&lt; blob.size()</code> is returned. </dd></dl>

<p class="definition">Definition at line <a class="el" href="native__socket__stream__impl__rcv_8cpp_source.html#l00683">683</a> of file <a class="el" href="native__socket__stream__impl__rcv_8cpp_source.html">native_socket_stream_impl_rcv.cpp</a>.</p>

<p class="reference">References <a class="el" href="sync__io_2native__socket__stream_8cpp_source.html#l00148">ipc::transport::sync_io::Native_socket_stream::get_logger()</a>, <a class="el" href="asio__local__stream__socket_8cpp_source.html#l00201">ipc::transport::asio_local_stream_socket::nb_read_some_with_native_handle()</a>, <a class="el" href="native__handle_8cpp_source.html#l00061">ipc::util::Native_handle::null()</a>, and <a class="el" href="namespaceipc_1_1transport_1_1error.html#adfef15ef4e76cc55d652fbd9c2797297a1fba28e335d4189cbb25f382582efcc1">ipc::transport::error::S_LOW_LVL_TRANSPORT_HOSED_CANNOT_RECEIVE</a>.</p>
<div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="classipc_1_1transport_1_1sync__io_1_1Native__socket__stream_1_1Impl_a25e051170a8eb568745f809bb186f980_cgraph.svg" width="642" height="228"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe>
</div>
</div>

</div>
</div>
<a id="adff873e21beee6c31a552293d8b0004c" name="adff873e21beee6c31a552293d8b0004c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adff873e21beee6c31a552293d8b0004c">&#9670;&nbsp;</a></span>rcv_not_idle()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void ipc::transport::sync_io::Native_socket_stream::Impl::rcv_not_idle </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>No-ops if <a class="el" href="classipc_1_1transport_1_1sync__io_1_1Native__socket__stream_1_1Impl.html#abedd0db5a5ae04e47085728ae548d07c" title="See Native_socket_stream counterpart.">idle_timer_run()</a> is not engaged; otherwise reacts to non-idleness of the in-pipe by rescheduling idle timer to occur in <a class="el" href="classipc_1_1transport_1_1sync__io_1_1Native__socket__stream_1_1Impl.html#ada7f2368dc0591f7a903946201c83636" title="timeout from idle_timer_run() args; or zero() if not yet called.">m_rcv_idle_timeout</a> again. </p>
<p >(Other code calls this, as of this writing, on receipt of a complete message.)</p>
<p >Note that this can only occur while an <a class="el" href="classipc_1_1transport_1_1sync__io_1_1Native__socket__stream_1_1Impl.html#ae16d560bf3c4eccfa975d47af71cb145" title="Body of both async_receive_native_handle() and async_receive_blob().">async_receive_native_handle_impl()</a> is in progress; as otherwise we will not be reading the low-level in-pipe at all. This is a requirement for using <a class="el" href="classipc_1_1transport_1_1sync__io_1_1Native__socket__stream_1_1Impl.html#abedd0db5a5ae04e47085728ae548d07c" title="See Native_socket_stream counterpart.">idle_timer_run()</a>, so it's not our fault, if they don't do it and get timed-out. </p>

<p class="definition">Definition at line <a class="el" href="native__socket__stream__impl__rcv_8cpp_source.html#l00244">244</a> of file <a class="el" href="native__socket__stream__impl__rcv_8cpp_source.html">native_socket_stream_impl_rcv.cpp</a>.</p>

</div>
</div>
<a id="a53b356e756923271fbb9b7a7beb8f54a" name="a53b356e756923271fbb9b7a7beb8f54a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a53b356e756923271fbb9b7a7beb8f54a">&#9670;&nbsp;</a></span>rcv_on_ev_idle_timer_fired()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void ipc::transport::sync_io::Native_socket_stream::Impl::rcv_on_ev_idle_timer_fired </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Handler for the async-wait, via <a class="el" href="classipc_1_1util_1_1sync__io_1_1Timer__event__emitter.html" title="An object of this type, used internally to implement sync_io-pattern objects that require timer event...">util::sync_io::Timer_event_emitter</a>, of the idle timer firing; if still relevant it records the idle-timeout error in <a class="el" href="classipc_1_1transport_1_1sync__io_1_1Native__socket__stream_1_1Impl.html#ab824da16816893b2ffe2e778a7169b62" title="The first and only connection-hosing error condition detected when attempting to low-level-read on m_...">m_rcv_pending_err_code</a>; and if an <a class="el" href="classipc_1_1transport_1_1sync__io_1_1Native__socket__stream_1_1Impl.html#ae16d560bf3c4eccfa975d47af71cb145" title="Body of both async_receive_native_handle() and async_receive_blob().">async_receive_native_handle_impl()</a> is in progress (awaiting data via async-wait), it completes that operation with the appropriate idle-timeout error (completion handler in <a class="el" href="classipc_1_1transport_1_1sync__io_1_1Native__socket__stream_1_1Impl.html#a9098de978da64572c419019597274d68" title="Null if no async_receive_*() is currently pending; else describes the arguments to that pending async...">m_rcv_user_request</a> runs synchronously). </p>
<p >If not still relevant &ndash; <a class="el" href="classipc_1_1transport_1_1sync__io_1_1Native__socket__stream_1_1Impl.html#ab824da16816893b2ffe2e778a7169b62" title="The first and only connection-hosing error condition detected when attempting to low-level-read on m_...">m_rcv_pending_err_code</a> already is truthy &ndash; then no-ops. </p>

<p class="definition">Definition at line <a class="el" href="native__socket__stream__impl__rcv_8cpp_source.html#l00210">210</a> of file <a class="el" href="native__socket__stream__impl__rcv_8cpp_source.html">native_socket_stream_impl_rcv.cpp</a>.</p>

<p class="reference">References <a class="el" href="namespaceipc_1_1transport_1_1error.html#adfef15ef4e76cc55d652fbd9c2797297aba920b52e9801e4927dd346ad83ce815">ipc::transport::error::S_RECEIVER_IDLE_TIMEOUT</a>.</p>

</div>
</div>
<a id="af324ad8945ab79d74e937e9c38c2fbb5" name="af324ad8945ab79d74e937e9c38c2fbb5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af324ad8945ab79d74e937e9c38c2fbb5">&#9670;&nbsp;</a></span>rcv_on_ev_peer_socket_readable_or_error()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void ipc::transport::sync_io::Native_socket_stream::Impl::rcv_on_ev_peer_socket_readable_or_error </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classipc_1_1transport_1_1sync__io_1_1Native__socket__stream_1_1Impl.html#a0e765fbfee2c76293b572b01c9be5680">Rcv_msg_state</a>&#160;</td>
          <td class="paramname"><em>msg_state</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>n_left</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Completion handler, from outside event loop via <code><a class="el" href="namespaceipc_1_1transport_1_1sync__io.html" title="sync_io-pattern counterparts to async-I/O-pattern object types in parent namespace ipc::transport.">sync_io</a></code> pattern, for the async-wait initiated by various <code>rcv_*()</code> methods trying to get to the goal of obtaining a complete in-message. </p>
<p >It tries to resume from whatever point in that algorithm we were at, when an <a class="el" href="classipc_1_1transport_1_1sync__io_1_1Native__socket__stream_1_1Impl.html#a25e051170a8eb568745f809bb186f980" title="Utility that synchronously, non-blockingly attempts to read over m_peer_socket into the target blob a...">rcv_nb_read_low_lvl_payload()</a> indicated would-block, precipitating the async-wait that has now completed. That point is indicated by the args, which were memorized (captured) at the time the async-wait was started.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">msg_state</td><td>Communicates where we're at in the in-message: the very start; or at byte 2+ of payload 1; or in payload 2. </td></tr>
    <tr><td class="paramname">n_left</td><td>How many bytes are left to read within payload 1 or payload 2 (depending on <code>msg_state</code>). Ignored for <a class="el" href="classipc_1_1transport_1_1sync__io_1_1Native__socket__stream_1_1Impl.html#a0e765fbfee2c76293b572b01c9be5680a89db9d0c66e2aa217b6106106d0e95a2" title="Reading start of payload 1: already have nothing â€“ no Native_handle; no 1st byte.">Rcv_msg_state::S_MSG_START</a> (by definition all of payload 1 remains then). </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="native__socket__stream__impl__rcv_8cpp_source.html#l00542">542</a> of file <a class="el" href="native__socket__stream__impl__rcv_8cpp_source.html">native_socket_stream_impl_rcv.cpp</a>.</p>

<p class="reference">References <a class="el" href="namespaceipc_1_1transport_1_1error.html#adfef15ef4e76cc55d652fbd9c2797297aa667487757f9d6300f6888bac40bcc24">ipc::transport::error::S_SYNC_IO_WOULD_BLOCK</a>.</p>

</div>
</div>
<a id="aa342b6f0c7e2015517a5c465e4963fc7" name="aa342b6f0c7e2015517a5c465e4963fc7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa342b6f0c7e2015517a5c465e4963fc7">&#9670;&nbsp;</a></span>rcv_on_handle_finalized()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void ipc::transport::sync_io::Native_socket_stream::Impl::rcv_on_handle_finalized </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespaceipc_1_1transport.html#a7ee4551983d9df16ec16a3139bac50e8">Native_handle</a>&#160;</td>
          <td class="paramname"><em>hndl_or_null</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>n_rcvd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceipc.html#aa3192e586cc45d3e7c22463bf2760f89">Error_code</a> *&#160;</td>
          <td class="paramname"><em>sync_err_code</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t *&#160;</td>
          <td class="paramname"><em>sync_sz</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Helper of <a class="el" href="classipc_1_1transport_1_1sync__io_1_1Native__socket__stream_1_1Impl.html#aa8c4ec6715dc5c437ed285cfea600b46" title="Begins read chain (completing it as synchronously as possible, async-completing the rest) for the nex...">rcv_read_msg()</a> &ndash; it could have been inlined instead of a method but for readability concerns &ndash; that reacts to that guy's initial nb-read (into <code>Native_handle</code> + leading bytes of payload 1 blob) getting at least 1 byte (and therefore the <code>Native_handle</code> if any). </p>
<p >A number of things can happen depending on <code>n_rcvd</code>; and if <code>n_rcvd</code> = all of payload 1, it's <a class="el" href="classipc_1_1transport_1_1sync__io_1_1Native__socket__stream_1_1Impl.html#a3b6b76dfbddc562ece4f64742ff6d2c7" title="Reacts to payload 1 having been completely received.">rcv_on_head_payload()</a> time.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">hndl_or_null</td><td>The handle, or none, received with byte 1 of payload 1. </td></tr>
    <tr><td class="paramname">n_rcvd</td><td>How many bytes of payload 1 were received. Must be at least 1, or behavior undefined (assertion may trip). </td></tr>
    <tr><td class="paramname">sync_err_code</td><td>Outcome out-arg: <a class="el" href="namespaceipc_1_1transport_1_1error.html#adfef15ef4e76cc55d652fbd9c2797297aa667487757f9d6300f6888bac40bcc24" title="A sync_io operation could not immediately complete; it will complete contingent on active async-wait ...">error::Code::S_SYNC_IO_WOULD_BLOCK</a> if async-wait triggered, as message could not be fully read synchronously; falsy if message fully read synchronously; non-would-block truthy value, if pipe-hosing condition encountered. </td></tr>
    <tr><td class="paramname">sync_sz</td><td>Outcome out-arg: If <code>*sync_err_code</code> truthy then zero; else size of completed in-message. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="native__socket__stream__impl__rcv_8cpp_source.html#l00348">348</a> of file <a class="el" href="native__socket__stream__impl__rcv_8cpp_source.html">native_socket_stream_impl_rcv.cpp</a>.</p>

<p class="reference">References <a class="el" href="native__handle_8cpp_source.html#l00061">ipc::util::Native_handle::null()</a>, <a class="el" href="namespaceipc_1_1transport_1_1error.html#adfef15ef4e76cc55d652fbd9c2797297ae3753569086cc66c6165480bd8d2f937">ipc::transport::error::S_BLOB_RECEIVER_GOT_NON_BLOB</a>, <a class="el" href="namespaceipc_1_1transport_1_1error.html#adfef15ef4e76cc55d652fbd9c2797297a1fba28e335d4189cbb25f382582efcc1">ipc::transport::error::S_LOW_LVL_TRANSPORT_HOSED_CANNOT_RECEIVE</a>, <a class="el" href="namespaceipc_1_1transport_1_1error.html#adfef15ef4e76cc55d652fbd9c2797297aa667487757f9d6300f6888bac40bcc24">ipc::transport::error::S_SYNC_IO_WOULD_BLOCK</a>, and <a class="el" href="protocol__negotiator_8hpp_source.html#l00215">ipc::transport::Protocol_negotiator::S_VER_UNKNOWN</a>.</p>
<div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="classipc_1_1transport_1_1sync__io_1_1Native__socket__stream_1_1Impl_aa342b6f0c7e2015517a5c465e4963fc7_cgraph.svg" width="399" height="59"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe>
</div>
</div>

</div>
</div>
<a id="a3b6b76dfbddc562ece4f64742ff6d2c7" name="a3b6b76dfbddc562ece4f64742ff6d2c7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3b6b76dfbddc562ece4f64742ff6d2c7">&#9670;&nbsp;</a></span>rcv_on_head_payload()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void ipc::transport::sync_io::Native_socket_stream::Impl::rcv_on_head_payload </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespaceipc.html#aa3192e586cc45d3e7c22463bf2760f89">Error_code</a> *&#160;</td>
          <td class="paramname"><em>sync_err_code</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t *&#160;</td>
          <td class="paramname"><em>sync_sz</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Reacts to payload 1 having been completely received. </p>
<p >At this point <a class="el" href="classipc_1_1transport_1_1sync__io_1_1Native__socket__stream_1_1Impl.html#a6676379057415274d2c6f2f096828cf9" title="Direct-write target, storing the length in bytes of the next meta-blob; 0 meaning the current user me...">m_rcv_target_meta_length</a> is ready, and <a class="el" href="classipc_1_1transport_1_1sync__io_1_1Native__socket__stream_1_1Impl.html#a42aab631e9c70bfaa53764309adfe37c" title="The peer stream-type Unix domain socket; or null pointer if we&#39;ve detected the connection has become ...">m_peer_socket</a> is not known to be in would-block state (which isn't to say it's <em>not</em> in would-block state).</p><ul>
<li>So if that value contains auto-ping marker, then it's <a class="el" href="classipc_1_1transport_1_1sync__io_1_1Native__socket__stream_1_1Impl.html#aa8c4ec6715dc5c437ed285cfea600b46" title="Begins read chain (completing it as synchronously as possible, async-completing the rest) for the nex...">rcv_read_msg()</a> all over again.</li>
<li>If it's the graceful-close marker, then the in-pipe (but not out-pipe necessarily) is hosed with graceful-close "error"; hence the completion handler in <a class="el" href="classipc_1_1transport_1_1sync__io_1_1Native__socket__stream_1_1Impl.html#a9098de978da64572c419019597274d68" title="Null if no async_receive_*() is currently pending; else describes the arguments to that pending async...">m_rcv_user_request</a> is readied for execution; the read-chain stops until the next <a class="el" href="classipc_1_1transport_1_1sync__io_1_1Native__socket__stream_1_1Impl.html#ae16d560bf3c4eccfa975d47af71cb145" title="Body of both async_receive_native_handle() and async_receive_blob().">async_receive_native_handle_impl()</a>.</li>
<li>Otherwise we need payload 2; <a class="el" href="classipc_1_1transport_1_1sync__io_1_1Native__socket__stream_1_1Impl.html#a0ba676425c97ae496255a155f41943f8" title="A somewhat-general utility that continues read chain with the aim to complete the present in-message,...">rcv_read_blob()</a> is initiated (with <a class="el" href="classipc_1_1transport_1_1sync__io_1_1Native__socket__stream_1_1Impl.html#a0e765fbfee2c76293b572b01c9be5680afd393481cb76843d8c7ab099451efaf1" title="Reading payload 2; M bytes remain, where M is in [1, N], and N is the meta-length encoded in precedin...">Rcv_msg_state::S_META_BLOB_PAYLOAD</a>) to read all of it.</li>
</ul>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">sync_err_code</td><td>Outcome out-arg: <a class="el" href="namespaceipc_1_1transport_1_1error.html#adfef15ef4e76cc55d652fbd9c2797297aa667487757f9d6300f6888bac40bcc24" title="A sync_io operation could not immediately complete; it will complete contingent on active async-wait ...">error::Code::S_SYNC_IO_WOULD_BLOCK</a> if async-wait triggered, as message could not be fully read synchronously; falsy if message fully read synchronously; non-would-block truthy value, if pipe-hosing condition encountered. </td></tr>
    <tr><td class="paramname">sync_sz</td><td>Outcome out-arg: If <code>*sync_err_code</code> truthy then zero; else size of completed in-message. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="native__socket__stream__impl__rcv_8cpp_source.html#l00440">440</a> of file <a class="el" href="native__socket__stream__impl__rcv_8cpp_source.html">native_socket_stream_impl_rcv.cpp</a>.</p>

<p class="reference">References <a class="el" href="namespaceipc_1_1transport_1_1error.html#adfef15ef4e76cc55d652fbd9c2797297adde24987f30a92b953297207ce935210">ipc::transport::error::S_MESSAGE_SIZE_EXCEEDS_USER_STORAGE</a>, <a class="el" href="namespaceipc_1_1transport_1_1error.html#adfef15ef4e76cc55d652fbd9c2797297aad44f87d53255ba573d57086dfeab805">ipc::transport::error::S_RECEIVES_FINISHED_CANNOT_RECEIVE</a>, and <a class="el" href="protocol__negotiator_8hpp_source.html#l00215">ipc::transport::Protocol_negotiator::S_VER_UNKNOWN</a>.</p>

</div>
</div>
<a id="a0ba676425c97ae496255a155f41943f8" name="a0ba676425c97ae496255a155f41943f8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0ba676425c97ae496255a155f41943f8">&#9670;&nbsp;</a></span>rcv_read_blob()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void ipc::transport::sync_io::Native_socket_stream::Impl::rcv_read_blob </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classipc_1_1transport_1_1sync__io_1_1Native__socket__stream_1_1Impl.html#a0e765fbfee2c76293b572b01c9be5680">Rcv_msg_state</a>&#160;</td>
          <td class="paramname"><em>msg_state</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespaceipc_1_1util.html#a6cb62ae434900f3a8915b33ec5d61a96">util::Blob_mutable</a> &amp;&#160;</td>
          <td class="paramname"><em>target_blob</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceipc.html#aa3192e586cc45d3e7c22463bf2760f89">Error_code</a> *&#160;</td>
          <td class="paramname"><em>sync_err_code</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t *&#160;</td>
          <td class="paramname"><em>sync_sz</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>A somewhat-general utility that continues read chain with the aim to complete the present in-message, with the pre-condition (among others) that (1) there is no known would-block condition on the in-pipe, and (2) at least byte 1 + the handle-or-not within payload 1 have already been acquired. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">msg_state</td><td><a class="el" href="classipc_1_1transport_1_1sync__io_1_1Native__socket__stream_1_1Impl.html#a0e765fbfee2c76293b572b01c9be5680a3249b7cad0ab1d3cc8e9960568a412ae" title="Reading payload 1, but at least byte 2: alreadu have at least byte 1 and either the Native_handle or ...">Rcv_msg_state::S_HEAD_PAYLOAD</a> or <a class="el" href="classipc_1_1transport_1_1sync__io_1_1Native__socket__stream_1_1Impl.html#a0e765fbfee2c76293b572b01c9be5680afd393481cb76843d8c7ab099451efaf1" title="Reading payload 2; M bytes remain, where M is in [1, N], and N is the meta-length encoded in precedin...">Rcv_msg_state::S_META_BLOB_PAYLOAD</a>, indicating which thing is being read: trailing bytes (not including byte 1) of payload 1; or all or trailing bytes of payload 2 (the meta-blob). </td></tr>
    <tr><td class="paramname">target_blob</td><td>The target buffer: its size indicates the bytes necessary to complete the payload <code>msg_state</code>. E.g., if META_BLOB_PAYLOAD and 3 of (whatever m_rcv_target_meta_length indicates, from payload 1) bytes are still needed, then <code>target_blob.size() == 3</code>, and <code>target_blob.data()</code> points to the end of the meta-blob (in <a class="el" href="classipc_1_1transport_1_1sync__io_1_1Native__socket__stream_1_1Impl.html#a9098de978da64572c419019597274d68" title="Null if no async_receive_*() is currently pending; else describes the arguments to that pending async...">m_rcv_user_request</a>) minus 3. </td></tr>
    <tr><td class="paramname">sync_err_code</td><td>Outcome out-arg: <a class="el" href="namespaceipc_1_1transport_1_1error.html#adfef15ef4e76cc55d652fbd9c2797297aa667487757f9d6300f6888bac40bcc24" title="A sync_io operation could not immediately complete; it will complete contingent on active async-wait ...">error::Code::S_SYNC_IO_WOULD_BLOCK</a> if async-wait triggered, as message could not be fully read synchronously; falsy if message fully read synchronously; non-would-block truthy value, if pipe-hosing condition encountered. </td></tr>
    <tr><td class="paramname">sync_sz</td><td>Outcome out-arg: If <code>*sync_err_code</code> truthy then zero; else size of completed in-message. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="native__socket__stream__impl__rcv_8cpp_source.html#l00611">611</a> of file <a class="el" href="native__socket__stream__impl__rcv_8cpp_source.html">native_socket_stream_impl_rcv.cpp</a>.</p>

<p class="reference">References <a class="el" href="namespaceipc_1_1transport_1_1error.html#adfef15ef4e76cc55d652fbd9c2797297a1fba28e335d4189cbb25f382582efcc1">ipc::transport::error::S_LOW_LVL_TRANSPORT_HOSED_CANNOT_RECEIVE</a>, and <a class="el" href="namespaceipc_1_1transport_1_1error.html#adfef15ef4e76cc55d652fbd9c2797297aa667487757f9d6300f6888bac40bcc24">ipc::transport::error::S_SYNC_IO_WOULD_BLOCK</a>.</p>

</div>
</div>
<a id="aa8c4ec6715dc5c437ed285cfea600b46" name="aa8c4ec6715dc5c437ed285cfea600b46"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa8c4ec6715dc5c437ed285cfea600b46">&#9670;&nbsp;</a></span>rcv_read_msg()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void ipc::transport::sync_io::Native_socket_stream::Impl::rcv_read_msg </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespaceipc.html#aa3192e586cc45d3e7c22463bf2760f89">Error_code</a> *&#160;</td>
          <td class="paramname"><em>sync_err_code</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t *&#160;</td>
          <td class="paramname"><em>sync_sz</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Begins read chain (completing it as synchronously as possible, async-completing the rest) for the next in-message. </p>
<p >Given the pre-condition that (1) <a class="el" href="classipc_1_1transport_1_1sync__io_1_1Native__socket__stream_1_1Impl.html#ae16d560bf3c4eccfa975d47af71cb145" title="Body of both async_receive_native_handle() and async_receive_blob().">async_receive_native_handle_impl()</a> is oustanding (<a class="el" href="classipc_1_1transport_1_1sync__io_1_1Native__socket__stream_1_1Impl.html#a9098de978da64572c419019597274d68" title="Null if no async_receive_*() is currently pending; else describes the arguments to that pending async...">m_rcv_user_request</a> not null), (2) in the in-pipe we expect byte 1 of the next in-message next, (3) there is no known in-pipe error already detected, and (4) there is no known would-block condition on the in-pipe: this reads (asynchronously if would-block is encountered at some point in there) the next message.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">sync_err_code</td><td>Outcome out-arg: <a class="el" href="namespaceipc_1_1transport_1_1error.html#adfef15ef4e76cc55d652fbd9c2797297aa667487757f9d6300f6888bac40bcc24" title="A sync_io operation could not immediately complete; it will complete contingent on active async-wait ...">error::Code::S_SYNC_IO_WOULD_BLOCK</a> if async-wait triggered, as message could not be fully read synchronously; falsy if message fully read synchronously; non-would-block truthy value, if pipe-hosing condition encountered. </td></tr>
    <tr><td class="paramname">sync_sz</td><td>Outcome out-arg: If <code>*sync_err_code</code> truthy then zero; else size of completed in-message. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="native__socket__stream__impl__rcv_8cpp_source.html#l00279">279</a> of file <a class="el" href="native__socket__stream__impl__rcv_8cpp_source.html">native_socket_stream_impl_rcv.cpp</a>.</p>

<p class="reference">References <a class="el" href="namespaceipc_1_1transport_1_1error.html#adfef15ef4e76cc55d652fbd9c2797297a1fba28e335d4189cbb25f382582efcc1">ipc::transport::error::S_LOW_LVL_TRANSPORT_HOSED_CANNOT_RECEIVE</a>, and <a class="el" href="namespaceipc_1_1transport_1_1error.html#adfef15ef4e76cc55d652fbd9c2797297aa667487757f9d6300f6888bac40bcc24">ipc::transport::error::S_SYNC_IO_WOULD_BLOCK</a>.</p>

</div>
</div>
<a id="ace12ebbb258f933e517255294f372795" name="ace12ebbb258f933e517255294f372795"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ace12ebbb258f933e517255294f372795">&#9670;&nbsp;</a></span>receive_blob_max_size()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t ipc::transport::sync_io::Native_socket_stream::Impl::receive_blob_max_size </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>See <a class="el" href="classipc_1_1transport_1_1sync__io_1_1Native__socket__stream.html" title="Implements both sync_io::Native_handle_sender and sync_io::Native_handle_receiver concepts by using a...">Native_socket_stream</a> counterpart. </p>
<dl class="section return"><dt>Returns</dt><dd>See <a class="el" href="classipc_1_1transport_1_1sync__io_1_1Native__socket__stream.html" title="Implements both sync_io::Native_handle_sender and sync_io::Native_handle_receiver concepts by using a...">Native_socket_stream</a> counterpart. </dd></dl>

<p class="definition">Definition at line <a class="el" href="native__socket__stream__impl__rcv_8cpp_source.html#l00806">806</a> of file <a class="el" href="native__socket__stream__impl__rcv_8cpp_source.html">native_socket_stream_impl_rcv.cpp</a>.</p>

<p class="reference">References <a class="el" href="sync__io_2native__socket__stream_8cpp_source.html#l00133">ipc::transport::sync_io::Native_socket_stream::receive_meta_blob_max_size()</a>.</p>
<div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="classipc_1_1transport_1_1sync__io_1_1Native__socket__stream_1_1Impl_ace12ebbb258f933e517255294f372795_cgraph.svg" width="674" height="59"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe>
</div>
</div>

</div>
</div>
<a id="af5d6e9275386dfefddb7a97248b039a7" name="af5d6e9275386dfefddb7a97248b039a7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af5d6e9275386dfefddb7a97248b039a7">&#9670;&nbsp;</a></span>receive_meta_blob_max_size()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t ipc::transport::sync_io::Native_socket_stream::Impl::receive_meta_blob_max_size </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>See <a class="el" href="classipc_1_1transport_1_1sync__io_1_1Native__socket__stream.html" title="Implements both sync_io::Native_handle_sender and sync_io::Native_handle_receiver concepts by using a...">Native_socket_stream</a> counterpart. </p>
<dl class="section return"><dt>Returns</dt><dd>See <a class="el" href="classipc_1_1transport_1_1sync__io_1_1Native__socket__stream.html" title="Implements both sync_io::Native_handle_sender and sync_io::Native_handle_receiver concepts by using a...">Native_socket_stream</a> counterpart. </dd></dl>

<p class="definition">Definition at line <a class="el" href="native__socket__stream__impl__rcv_8cpp_source.html#l00801">801</a> of file <a class="el" href="native__socket__stream__impl__rcv_8cpp_source.html">native_socket_stream_impl_rcv.cpp</a>.</p>

<p class="reference">References <a class="el" href="sync__io_2native__socket__stream_8hpp_source.html#l00197">ipc::transport::sync_io::Native_socket_stream::S_MAX_META_BLOB_LENGTH</a>.</p>

</div>
</div>
<a id="a6600090ca22c9b940155f7920b1465e4" name="a6600090ca22c9b940155f7920b1465e4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6600090ca22c9b940155f7920b1465e4">&#9670;&nbsp;</a></span>remote_peer_process_credentials()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classipc_1_1util_1_1Process__credentials.html">util::Process_credentials</a> ipc::transport::sync_io::Native_socket_stream::Impl::remote_peer_process_credentials </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespaceipc.html#aa3192e586cc45d3e7c22463bf2760f89">Error_code</a> *&#160;</td>
          <td class="paramname"><em>err_code</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>See <a class="el" href="classipc_1_1transport_1_1sync__io_1_1Native__socket__stream.html" title="Implements both sync_io::Native_handle_sender and sync_io::Native_handle_receiver concepts by using a...">Native_socket_stream</a> counterpart. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">err_code</td><td>See <a class="el" href="classipc_1_1transport_1_1sync__io_1_1Native__socket__stream.html" title="Implements both sync_io::Native_handle_sender and sync_io::Native_handle_receiver concepts by using a...">Native_socket_stream</a> counterpart. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>See <a class="el" href="classipc_1_1transport_1_1sync__io_1_1Native__socket__stream.html" title="Implements both sync_io::Native_handle_sender and sync_io::Native_handle_receiver concepts by using a...">Native_socket_stream</a> counterpart. </dd></dl>

<p class="definition">Definition at line <a class="el" href="sync__io_2detail_2native__socket__stream__impl_8cpp_source.html#l00471">471</a> of file <a class="el" href="sync__io_2detail_2native__socket__stream__impl_8cpp_source.html">native_socket_stream_impl.cpp</a>.</p>

<p class="reference">References <a class="el" href="sync__io_2native__socket__stream_8cpp_source.html#l00097">ipc::transport::sync_io::Native_socket_stream::remote_peer_process_credentials()</a>, and <a class="el" href="namespaceipc_1_1transport_1_1error.html#adfef15ef4e76cc55d652fbd9c2797297acb14cace6f75d915cd800113c37721e7">ipc::transport::error::S_LOW_LVL_TRANSPORT_HOSED</a>.</p>
<div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="classipc_1_1transport_1_1sync__io_1_1Native__socket__stream_1_1Impl_a6600090ca22c9b940155f7920b1465e4_cgraph.svg" width="694" height="71"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe>
</div>
</div>

</div>
</div>
<a id="a8b9839bb39e95a51ed7c920137438a21" name="a8b9839bb39e95a51ed7c920137438a21"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8b9839bb39e95a51ed7c920137438a21">&#9670;&nbsp;</a></span>replace_event_wait_handles()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool ipc::transport::sync_io::Native_socket_stream::Impl::replace_event_wait_handles </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespaceipc.html#aa455c7f045059736578ca275fc1a851f">Function</a>&lt; <a class="el" href="classipc_1_1util_1_1sync__io_1_1Asio__waitable__native__handle.html">util::sync_io::Asio_waitable_native_handle</a>()&gt; &amp;&#160;</td>
          <td class="paramname"><em>create_ev_wait_hndl_func</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>See <a class="el" href="classipc_1_1transport_1_1sync__io_1_1Native__socket__stream.html" title="Implements both sync_io::Native_handle_sender and sync_io::Native_handle_receiver concepts by using a...">Native_socket_stream</a> counterpart. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">create_ev_wait_hndl_func</td><td>See <a class="el" href="classipc_1_1transport_1_1sync__io_1_1Native__socket__stream.html" title="Implements both sync_io::Native_handle_sender and sync_io::Native_handle_receiver concepts by using a...">Native_socket_stream</a> counterpart. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>See <a class="el" href="classipc_1_1transport_1_1sync__io_1_1Native__socket__stream.html" title="Implements both sync_io::Native_handle_sender and sync_io::Native_handle_receiver concepts by using a...">Native_socket_stream</a> counterpart. </dd></dl>

<p class="definition">Definition at line <a class="el" href="sync__io_2detail_2native__socket__stream__impl_8cpp_source.html#l00437">437</a> of file <a class="el" href="sync__io_2detail_2native__socket__stream__impl_8cpp_source.html">native_socket_stream_impl.cpp</a>.</p>

<p class="reference">References <a class="el" href="native__handle_8hpp_source.html#l00085">ipc::util::Native_handle::m_native_handle</a>.</p>

</div>
</div>
<a id="aaef639c110a0e3d6804da84f9458ae78" name="aaef639c110a0e3d6804da84f9458ae78"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaef639c110a0e3d6804da84f9458ae78">&#9670;&nbsp;</a></span>send_blob()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool ipc::transport::sync_io::Native_socket_stream::Impl::send_blob </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespaceipc_1_1util.html#ae0be7edba7e30ffa3f8b742af621f2ab">util::Blob_const</a> &amp;&#160;</td>
          <td class="paramname"><em>blob</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceipc.html#aa3192e586cc45d3e7c22463bf2760f89">Error_code</a> *&#160;</td>
          <td class="paramname"><em>err_code</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>See <a class="el" href="classipc_1_1transport_1_1sync__io_1_1Native__socket__stream.html" title="Implements both sync_io::Native_handle_sender and sync_io::Native_handle_receiver concepts by using a...">Native_socket_stream</a> counterpart. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">blob</td><td>See <a class="el" href="classipc_1_1transport_1_1sync__io_1_1Native__socket__stream.html" title="Implements both sync_io::Native_handle_sender and sync_io::Native_handle_receiver concepts by using a...">Native_socket_stream</a> counterpart. </td></tr>
    <tr><td class="paramname">err_code</td><td>See <a class="el" href="classipc_1_1transport_1_1sync__io_1_1Native__socket__stream.html" title="Implements both sync_io::Native_handle_sender and sync_io::Native_handle_receiver concepts by using a...">Native_socket_stream</a> counterpart. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>See <a class="el" href="classipc_1_1transport_1_1sync__io_1_1Native__socket__stream.html" title="Implements both sync_io::Native_handle_sender and sync_io::Native_handle_receiver concepts by using a...">Native_socket_stream</a> counterpart. </dd></dl>

<p class="definition">Definition at line <a class="el" href="native__socket__stream__impl__snd_8cpp_source.html#l00088">88</a> of file <a class="el" href="native__socket__stream__impl__snd_8cpp_source.html">native_socket_stream_impl_snd.cpp</a>.</p>

<p class="reference">References <a class="el" href="sync__io_2native__socket__stream_8cpp_source.html#l00112">ipc::transport::sync_io::Native_socket_stream::send_native_handle()</a>.</p>
<div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="classipc_1_1transport_1_1sync__io_1_1Native__socket__stream_1_1Impl_aaef639c110a0e3d6804da84f9458ae78_cgraph.svg" width="630" height="59"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe>
</div>
</div>

</div>
</div>
<a id="afa6b6e1be0f00add0b53b3263c412c76" name="afa6b6e1be0f00add0b53b3263c412c76"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afa6b6e1be0f00add0b53b3263c412c76">&#9670;&nbsp;</a></span>send_blob_max_size()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t ipc::transport::sync_io::Native_socket_stream::Impl::send_blob_max_size </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>See <a class="el" href="classipc_1_1transport_1_1sync__io_1_1Native__socket__stream.html" title="Implements both sync_io::Native_handle_sender and sync_io::Native_handle_receiver concepts by using a...">Native_socket_stream</a> counterpart. </p>
<dl class="section return"><dt>Returns</dt><dd>See <a class="el" href="classipc_1_1transport_1_1sync__io_1_1Native__socket__stream.html" title="Implements both sync_io::Native_handle_sender and sync_io::Native_handle_receiver concepts by using a...">Native_socket_stream</a> counterpart. </dd></dl>

<p class="definition">Definition at line <a class="el" href="native__socket__stream__impl__snd_8cpp_source.html#l01024">1024</a> of file <a class="el" href="native__socket__stream__impl__snd_8cpp_source.html">native_socket_stream_impl_snd.cpp</a>.</p>

<p class="reference">References <a class="el" href="sync__io_2native__socket__stream_8cpp_source.html#l00102">ipc::transport::sync_io::Native_socket_stream::send_meta_blob_max_size()</a>.</p>
<div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="classipc_1_1transport_1_1sync__io_1_1Native__socket__stream_1_1Impl_afa6b6e1be0f00add0b53b3263c412c76_cgraph.svg" width="648" height="59"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe>
</div>
</div>

</div>
</div>
<a id="a5fe9845081e656642a8b9f82f82228f6" name="a5fe9845081e656642a8b9f82f82228f6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5fe9845081e656642a8b9f82f82228f6">&#9670;&nbsp;</a></span>send_meta_blob_max_size()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t ipc::transport::sync_io::Native_socket_stream::Impl::send_meta_blob_max_size </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>See <a class="el" href="classipc_1_1transport_1_1sync__io_1_1Native__socket__stream.html" title="Implements both sync_io::Native_handle_sender and sync_io::Native_handle_receiver concepts by using a...">Native_socket_stream</a> counterpart. </p>
<dl class="section return"><dt>Returns</dt><dd>See <a class="el" href="classipc_1_1transport_1_1sync__io_1_1Native__socket__stream.html" title="Implements both sync_io::Native_handle_sender and sync_io::Native_handle_receiver concepts by using a...">Native_socket_stream</a> counterpart. </dd></dl>

<p class="definition">Definition at line <a class="el" href="native__socket__stream__impl__snd_8cpp_source.html#l01019">1019</a> of file <a class="el" href="native__socket__stream__impl__snd_8cpp_source.html">native_socket_stream_impl_snd.cpp</a>.</p>

<p class="reference">References <a class="el" href="sync__io_2native__socket__stream_8hpp_source.html#l00197">ipc::transport::sync_io::Native_socket_stream::S_MAX_META_BLOB_LENGTH</a>.</p>

</div>
</div>
<a id="a59e9935bdd704c40173a40e87b5db131" name="a59e9935bdd704c40173a40e87b5db131"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a59e9935bdd704c40173a40e87b5db131">&#9670;&nbsp;</a></span>send_native_handle()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool ipc::transport::sync_io::Native_socket_stream::Impl::send_native_handle </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespaceipc_1_1transport.html#a7ee4551983d9df16ec16a3139bac50e8">Native_handle</a>&#160;</td>
          <td class="paramname"><em>hndl_or_null</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespaceipc_1_1util.html#ae0be7edba7e30ffa3f8b742af621f2ab">util::Blob_const</a> &amp;&#160;</td>
          <td class="paramname"><em>meta_blob</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceipc.html#aa3192e586cc45d3e7c22463bf2760f89">Error_code</a> *&#160;</td>
          <td class="paramname"><em>err_code</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>See <a class="el" href="classipc_1_1transport_1_1sync__io_1_1Native__socket__stream.html" title="Implements both sync_io::Native_handle_sender and sync_io::Native_handle_receiver concepts by using a...">Native_socket_stream</a> counterpart. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">hndl_or_null</td><td>See <a class="el" href="classipc_1_1transport_1_1sync__io_1_1Native__socket__stream.html" title="Implements both sync_io::Native_handle_sender and sync_io::Native_handle_receiver concepts by using a...">Native_socket_stream</a> counterpart. </td></tr>
    <tr><td class="paramname">meta_blob</td><td>See <a class="el" href="classipc_1_1transport_1_1sync__io_1_1Native__socket__stream.html" title="Implements both sync_io::Native_handle_sender and sync_io::Native_handle_receiver concepts by using a...">Native_socket_stream</a> counterpart. </td></tr>
    <tr><td class="paramname">err_code</td><td>See <a class="el" href="classipc_1_1transport_1_1sync__io_1_1Native__socket__stream.html" title="Implements both sync_io::Native_handle_sender and sync_io::Native_handle_receiver concepts by using a...">Native_socket_stream</a> counterpart. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>See <a class="el" href="classipc_1_1transport_1_1sync__io_1_1Native__socket__stream.html" title="Implements both sync_io::Native_handle_sender and sync_io::Native_handle_receiver concepts by using a...">Native_socket_stream</a> counterpart. </dd></dl>

<p class="definition">Definition at line <a class="el" href="native__socket__stream__impl__snd_8cpp_source.html#l00094">94</a> of file <a class="el" href="native__socket__stream__impl__snd_8cpp_source.html">native_socket_stream_impl_snd.cpp</a>.</p>

<p class="reference">References <a class="el" href="native__handle_8cpp_source.html#l00061">ipc::util::Native_handle::null()</a>, <a class="el" href="namespaceipc_1_1transport_1_1error.html#adfef15ef4e76cc55d652fbd9c2797297ac416e988563e44bf15fc6a81743eef53">ipc::transport::error::S_INVALID_ARGUMENT</a>, <a class="el" href="sync__io_2native__socket__stream_8hpp_source.html#l00197">ipc::transport::sync_io::Native_socket_stream::S_MAX_META_BLOB_LENGTH</a>, <a class="el" href="namespaceipc_1_1transport_1_1error.html#adfef15ef4e76cc55d652fbd9c2797297a42d41c622e92e9053177ba73e75633fe">ipc::transport::error::S_SENDS_FINISHED_CANNOT_SEND</a>, and <a class="el" href="sync__io_2native__socket__stream_8cpp_source.html#l00112">ipc::transport::sync_io::Native_socket_stream::send_native_handle()</a>.</p>
<div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="classipc_1_1transport_1_1sync__io_1_1Native__socket__stream_1_1Impl_a59e9935bdd704c40173a40e87b5db131_cgraph.svg" width="636" height="120"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe>
</div>
</div>

</div>
</div>
<a id="a5e9ed53ef25f4413c8da315f8dbcff2c" name="a5e9ed53ef25f4413c8da315f8dbcff2c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5e9ed53ef25f4413c8da315f8dbcff2c">&#9670;&nbsp;</a></span>snd_async_write_q_head_payload()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void ipc::transport::sync_io::Native_socket_stream::Impl::snd_async_write_q_head_payload </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Initiates async-write over <a class="el" href="classipc_1_1transport_1_1sync__io_1_1Native__socket__stream_1_1Impl.html#a42aab631e9c70bfaa53764309adfe37c" title="The peer stream-type Unix domain socket; or null pointer if we&#39;ve detected the connection has become ...">m_peer_socket</a> of the low-level payload at the head of out-queue <a class="el" href="classipc_1_1transport_1_1sync__io_1_1Native__socket__stream_1_1Impl.html#a1af9eb83b9afee25ba153a2ca066858d" title="Queue storing (at head) the currently in-progress async write-op of a Snd_low_lvl_payload; followed b...">m_snd_pending_payloads_q</a>, with completion handler <a class="el" href="classipc_1_1transport_1_1sync__io_1_1Native__socket__stream_1_1Impl.html#a2c2b11477fb5089af7608c45dec939c0" title="Completion handler, from outside event loop via sync_io pattern, for the async-wait initiated by snd_...">snd_on_ev_peer_socket_writable_or_error()</a>. </p>
<p >The first step of this is an async-wait via <code><a class="el" href="namespaceipc_1_1transport_1_1sync__io.html" title="sync_io-pattern counterparts to async-I/O-pattern object types in parent namespace ipc::transport.">sync_io</a></code> pattern.</p>
<p >Behavior w/r/t <a class="el" href="classipc_1_1transport_1_1sync__io_1_1Native__socket__stream_1_1Impl.html#a0257a7903bff120aa1523f8de04bccf7" title="The first and only connection-hosing error condition detected when attempting to low-level-write on m...">m_snd_pending_err_code</a> is the same semantics as described for <a class="el" href="classipc_1_1transport_1_1sync__io_1_1Native__socket__stream_1_1Impl.html#a3c1c949f345f0ceef5eeca3c2edec291" title="Either synchronously sends hndl_or_null handle (if any) and orig_blob low-level blob over m_peer_sock...">snd_sync_write_or_q_payload()</a> (must be falsy as pre-condition, is set to truthy &lt;=&gt; outgoing-pipe-hosing condition is encountered). </p>

<p class="definition">Definition at line <a class="el" href="native__socket__stream__impl__snd_8cpp_source.html#l00849">849</a> of file <a class="el" href="native__socket__stream__impl__snd_8cpp_source.html">native_socket_stream_impl_snd.cpp</a>.</p>

<p class="reference">References <a class="el" href="asio__local__stream__socket_8hpp_source.html#l00171">ipc::transport::asio_local_stream_socket::async_write_with_native_handle()</a>, and <a class="el" href="namespaceipc_1_1transport_1_1error.html#adfef15ef4e76cc55d652fbd9c2797297adc5d7b9dbaa8c76c6835e3c9a7942410">ipc::transport::error::S_LOW_LVL_TRANSPORT_HOSED_CANNOT_SEND</a>.</p>
<div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="classipc_1_1transport_1_1sync__io_1_1Native__socket__stream_1_1Impl_a5e9ed53ef25f4413c8da315f8dbcff2c_cgraph.svg" width="827" height="172"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe>
</div>
</div>

</div>
</div>
<a id="af321a9b3ed8dc21f23988bf79c7c33f0" name="af321a9b3ed8dc21f23988bf79c7c33f0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af321a9b3ed8dc21f23988bf79c7c33f0">&#9670;&nbsp;</a></span>snd_nb_write_low_lvl_payload()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_t ipc::transport::sync_io::Native_socket_stream::Impl::snd_nb_write_low_lvl_payload </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespaceipc_1_1transport.html#a7ee4551983d9df16ec16a3139bac50e8">Native_handle</a>&#160;</td>
          <td class="paramname"><em>hndl_or_null</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespaceipc_1_1util.html#ae0be7edba7e30ffa3f8b742af621f2ab">util::Blob_const</a> &amp;&#160;</td>
          <td class="paramname"><em>blob</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceipc.html#aa3192e586cc45d3e7c22463bf2760f89">Error_code</a> *&#160;</td>
          <td class="paramname"><em>err_code</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Utility that sends non-empty <code>blob</code>, and (unless null) <code>hndl_or_null</code> associated with its 1st byte, synchronously to the maximum extent possible without blocking, over <a class="el" href="classipc_1_1transport_1_1sync__io_1_1Native__socket__stream_1_1Impl.html#a42aab631e9c70bfaa53764309adfe37c" title="The peer stream-type Unix domain socket; or null pointer if we&#39;ve detected the connection has become ...">m_peer_socket</a>. </p>
<p >This is used for all sync-writes in this class. Note the result semantics are slightly different from boost.asio and its extensions, so watch out about would-block and such:</p>
<p ><code>*err_code</code> shall be set to success unless <a class="el" href="classipc_1_1transport_1_1sync__io_1_1Native__socket__stream_1_1Impl.html#a42aab631e9c70bfaa53764309adfe37c" title="The peer stream-type Unix domain socket; or null pointer if we&#39;ve detected the connection has become ...">m_peer_socket</a> connection is found to be hosed at any point throughout the operation. In particular neither would-block nor would-block after non-zero amount of data had been sent are considered errors; 0 or a value <code>&lt; blob.size()</code> are returned in those situations respectively. If <code>*err_code</code> is made truthy, <a class="el" href="classipc_1_1transport_1_1sync__io_1_1Native__socket__stream_1_1Impl.html#a42aab631e9c70bfaa53764309adfe37c" title="The peer stream-type Unix domain socket; or null pointer if we&#39;ve detected the connection has become ...">m_peer_socket</a> shall not be used (in either direction) subsequently.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">hndl_or_null</td><td>Same as <a class="el" href="classipc_1_1transport_1_1sync__io_1_1Native__socket__stream_1_1Impl.html#a3c1c949f345f0ceef5eeca3c2edec291" title="Either synchronously sends hndl_or_null handle (if any) and orig_blob low-level blob over m_peer_sock...">snd_sync_write_or_q_payload()</a>. </td></tr>
    <tr><td class="paramname">blob</td><td>Same as <a class="el" href="classipc_1_1transport_1_1sync__io_1_1Native__socket__stream_1_1Impl.html#a3c1c949f345f0ceef5eeca3c2edec291" title="Either synchronously sends hndl_or_null handle (if any) and orig_blob low-level blob over m_peer_sock...">snd_sync_write_or_q_payload()</a>. </td></tr>
    <tr><td class="paramname">err_code</td><td>Same as <a class="el" href="classipc_1_1transport_1_1sync__io_1_1Native__socket__stream_1_1Impl.html#a3c1c949f345f0ceef5eeca3c2edec291" title="Either synchronously sends hndl_or_null handle (if any) and orig_blob low-level blob over m_peer_sock...">snd_sync_write_or_q_payload()</a> is w/r/t <a class="el" href="classipc_1_1transport_1_1sync__io_1_1Native__socket__stream_1_1Impl.html#a0257a7903bff120aa1523f8de04bccf7" title="The first and only connection-hosing error condition detected when attempting to low-level-write on m...">m_snd_pending_err_code</a>, essentially, with the small difference that it does not require <code>*err_code</code> to be falsy as pre-condition, and will make it truthy or falsy depending on success or failure. (Minor possible to-do: just have it act on <code>m_snd_pending_err_code</code> like <a class="el" href="classipc_1_1transport_1_1sync__io_1_1Native__socket__stream_1_1Impl.html#a3c1c949f345f0ceef5eeca3c2edec291" title="Either synchronously sends hndl_or_null handle (if any) and orig_blob low-level blob over m_peer_sock...">snd_sync_write_or_q_payload()</a> et al? It is the way it is now arguably for maintenability/reusability, and/or for minor historical reasons.) Also see above: would-block is not an error. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 meaning neither <code>hndl_or_null</code> (if any) nor any <code>blob</code> bytes were sent; [1, <code>blob.size()</code>] if <code>hndl_or_null</code> (if any) and that number of <code>blob</code> bytes were sent. <code>*err_code</code> shall be truthy only if (but not necessarily if) <code>&lt; blob.size()</code> is returned. </dd></dl>

<p class="definition">Definition at line <a class="el" href="native__socket__stream__impl__snd_8cpp_source.html#l00739">739</a> of file <a class="el" href="native__socket__stream__impl__snd_8cpp_source.html">native_socket_stream_impl_snd.cpp</a>.</p>

<p class="reference">References <a class="el" href="sync__io_2native__socket__stream_8cpp_source.html#l00148">ipc::transport::sync_io::Native_socket_stream::get_logger()</a>, <a class="el" href="asio__local__stream__socket_8cpp_source.html#l00036">ipc::transport::asio_local_stream_socket::nb_write_some_with_native_handle()</a>, <a class="el" href="native__handle_8cpp_source.html#l00061">ipc::util::Native_handle::null()</a>, and <a class="el" href="namespaceipc_1_1transport_1_1error.html#adfef15ef4e76cc55d652fbd9c2797297adc5d7b9dbaa8c76c6835e3c9a7942410">ipc::transport::error::S_LOW_LVL_TRANSPORT_HOSED_CANNOT_SEND</a>.</p>
<div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="classipc_1_1transport_1_1sync__io_1_1Native__socket__stream_1_1Impl_af321a9b3ed8dc21f23988bf79c7c33f0_cgraph.svg" width="644" height="228"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe>
</div>
</div>

</div>
</div>
<a id="a4b31da3a7ff63f307bd08e288c391556" name="a4b31da3a7ff63f307bd08e288c391556"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4b31da3a7ff63f307bd08e288c391556">&#9670;&nbsp;</a></span>snd_on_ev_auto_ping_now_timer_fired()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void ipc::transport::sync_io::Native_socket_stream::Impl::snd_on_ev_auto_ping_now_timer_fired </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Handler for the async-wait, via <a class="el" href="classipc_1_1util_1_1sync__io_1_1Timer__event__emitter.html" title="An object of this type, used internally to implement sync_io-pattern objects that require timer event...">util::sync_io::Timer_event_emitter</a>, of the auto-ping timer firing; if all is cool, sends auto-ping and schedules the next such async-wait. </p>
<p >That wait itself can be rescheduled when non-idleness (other send attempts) occurs. If all is not cool &ndash; sends finished via <code>*end_sending()</code>, out-pipe hosed &ndash; then neither sends auto-ping nor schedules another. </p>

<p class="definition">Definition at line <a class="el" href="native__socket__stream__impl__snd_8cpp_source.html#l00543">543</a> of file <a class="el" href="native__socket__stream__impl__snd_8cpp_source.html">native_socket_stream_impl_snd.cpp</a>.</p>

</div>
</div>
<a id="a2c2b11477fb5089af7608c45dec939c0" name="a2c2b11477fb5089af7608c45dec939c0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2c2b11477fb5089af7608c45dec939c0">&#9670;&nbsp;</a></span>snd_on_ev_peer_socket_writable_or_error()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void ipc::transport::sync_io::Native_socket_stream::Impl::snd_on_ev_peer_socket_writable_or_error </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Completion handler, from outside event loop via <code><a class="el" href="namespaceipc_1_1transport_1_1sync__io.html" title="sync_io-pattern counterparts to async-I/O-pattern object types in parent namespace ipc::transport.">sync_io</a></code> pattern, for the async-wait initiated by <a class="el" href="classipc_1_1transport_1_1sync__io_1_1Native__socket__stream_1_1Impl.html#a5e9ed53ef25f4413c8da315f8dbcff2c" title="Initiates async-write over m_peer_socket of the low-level payload at the head of out-queue m_snd_pend...">snd_async_write_q_head_payload()</a>. </p>
<p >Continues the async-send chain by trying to <a class="el" href="classipc_1_1transport_1_1sync__io_1_1Native__socket__stream_1_1Impl.html#af321a9b3ed8dc21f23988bf79c7c33f0" title="Utility that sends non-empty blob, and (unless null) hndl_or_null associated with its 1st byte,...">snd_nb_write_low_lvl_payload()</a> as much of <a class="el" href="classipc_1_1transport_1_1sync__io_1_1Native__socket__stream_1_1Impl.html#a1af9eb83b9afee25ba153a2ca066858d" title="Queue storing (at head) the currently in-progress async write-op of a Snd_low_lvl_payload; followed b...">m_snd_pending_payloads_q</a> as it can synchronously; invokes <a class="el" href="classipc_1_1transport_1_1sync__io_1_1Native__socket__stream_1_1Impl.html#a5e9ed53ef25f4413c8da315f8dbcff2c" title="Initiates async-write over m_peer_socket of the low-level payload at the head of out-queue m_snd_pend...">snd_async_write_q_head_payload()</a> again if not all could be so sent. Lastly, if indeed it sends-out everything, or encounters out-pipe being hosed, and <a class="el" href="classipc_1_1transport_1_1sync__io_1_1Native__socket__stream_1_1Impl.html#a0aca995c7150e72219b422c188d9bc23" title="See Native_socket_stream counterpart.">async_end_sending()</a> completion handler is pending to be called &ndash; it ensures that occurs (synchronously inside). </p>

<p class="definition">Definition at line <a class="el" href="native__socket__stream__impl__snd_8cpp_source.html#l00903">903</a> of file <a class="el" href="native__socket__stream__impl__snd_8cpp_source.html">native_socket_stream_impl_snd.cpp</a>.</p>

</div>
</div>
<a id="a3c1c949f345f0ceef5eeca3c2edec291" name="a3c1c949f345f0ceef5eeca3c2edec291"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3c1c949f345f0ceef5eeca3c2edec291">&#9670;&nbsp;</a></span>snd_sync_write_or_q_payload()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool ipc::transport::sync_io::Native_socket_stream::Impl::snd_sync_write_or_q_payload </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespaceipc_1_1transport.html#a7ee4551983d9df16ec16a3139bac50e8">Native_handle</a>&#160;</td>
          <td class="paramname"><em>hndl_or_null</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespaceipc_1_1util.html#ae0be7edba7e30ffa3f8b742af621f2ab">util::Blob_const</a> &amp;&#160;</td>
          <td class="paramname"><em>orig_blob</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>avoid_qing</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Either synchronously sends <code>hndl_or_null</code> handle (if any) and <code>orig_blob</code> low-level blob over <a class="el" href="classipc_1_1transport_1_1sync__io_1_1Native__socket__stream_1_1Impl.html#a42aab631e9c70bfaa53764309adfe37c" title="The peer stream-type Unix domain socket; or null pointer if we&#39;ve detected the connection has become ...">m_peer_socket</a>, or if an async-send is in progress queues both to be sent later; in the former case any unsent trailing portion of the payload is queued and async-sent via <a class="el" href="classipc_1_1transport_1_1sync__io_1_1Native__socket__stream_1_1Impl.html#a5e9ed53ef25f4413c8da315f8dbcff2c" title="Initiates async-write over m_peer_socket of the low-level payload at the head of out-queue m_snd_pend...">snd_async_write_q_head_payload()</a>, with dropping-sans-queuing allowed under certain circumstances in <code>avoid_qing</code> mode. </p>
<p >For details on the latter see below.</p>
<p ><a class="el" href="classipc_1_1transport_1_1sync__io_1_1Native__socket__stream_1_1Impl.html#a0257a7903bff120aa1523f8de04bccf7" title="The first and only connection-hosing error condition detected when attempting to low-level-write on m...">m_snd_pending_err_code</a>, which as a pre-condition must be falsy, is set to truthy if and only if an outgoing-pipe-hosing condition is synchronously encountered. In particular, if it remains falsy upon return, you may call this again to send the next low-level payload. Otherwise <a class="el" href="classipc_1_1transport_1_1sync__io_1_1Native__socket__stream_1_1Impl.html#a42aab631e9c70bfaa53764309adfe37c" title="The peer stream-type Unix domain socket; or null pointer if we&#39;ve detected the connection has become ...">m_peer_socket</a> cannot be subsequently used in either direction (connection is hosed).</p>
<h3><code>avoid_qing</code> mode for auto-ping</h3>
<p >Setting this arg to <code>true</code> slightly modifies the above behavior as follows. Suppose <code>orig_blob</code> encodes an auto-ping message (see <a class="el" href="classipc_1_1transport_1_1sync__io_1_1Native__socket__stream_1_1Impl.html#ab7b382067804495cbae180a5bc1a2757" title="See Native_socket_stream counterpart.">auto_ping()</a>). (So <code>handle_or_null</code> must be <code>.null()</code>.) Its purpose is to inform the opposing side that we are alive/not idle. So suppose this method is unable to send <em>any</em> of <code>orig_blob</code>, either because there are already-queued bytes waiting to be sent pending writability (due to earlier would-block), or because the kernel out-buffer has already-queued bytes waiting to be popped by receiver, and there is no space there to enqueue any of <code>orig_blob</code>. Then the receiver must not be keeping up with us, and the next pop of the kernel buffer will get <em>some</em> message, even if it's not the auto-ping we wanted to send; hence they'll know we are not-idle without the auto-ping. So in that case this method shall:</p><ul>
<li>disregard <code>orig_blob</code> (do not queue it &ndash; drop it, as it would be redundant anyway);</li>
<li>return <code>true</code> if and only if the size of the out-queue is 0 (though as of this writing the caller should not care: auto-ping is a fire-and-forget operation, as long as it does not detect a pipe-hosing error).</li>
</ul>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">hndl_or_null</td><td>Similar to <a class="el" href="classipc_1_1transport_1_1sync__io_1_1Native__socket__stream_1_1Impl.html#a59e9935bdd704c40173a40e87b5db131" title="See Native_socket_stream counterpart.">send_native_handle()</a>. However it must be <code>.null()</code> if <code>avoid_qing == true</code>. </td></tr>
    <tr><td class="paramname">orig_blob</td><td>Blob to send, with <code>hndl_or_null</code> associated with byte 1 of this. It must have size 1 or greater, or behavior is undefined. </td></tr>
    <tr><td class="paramname">avoid_qing</td><td>See above. <code>true</code> &lt;=&gt; will return success (act as-if all of <code>orig_blob</code> was sent) if no bytes of <code>orig_blob</code> could be immediately sent. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>false</code> if outgoing-direction pipe still has queued stuff in it that must be sent once transport becomes writable; <code>true</code> otherwise. If <code>true</code> is returned, but <code>avoid_qing == true</code>, then possibly <code>orig_blob</code> was not sent (at all); was dropped. </dd></dl>

<p class="definition">Definition at line <a class="el" href="native__socket__stream__impl__snd_8cpp_source.html#l00605">605</a> of file <a class="el" href="native__socket__stream__impl__snd_8cpp_source.html">native_socket_stream_impl_snd.cpp</a>.</p>

<p class="reference">References <a class="el" href="sync__io_2native__socket__stream_8cpp_source.html#l00148">ipc::transport::sync_io::Native_socket_stream::get_logger()</a>, and <a class="el" href="native__handle_8cpp_source.html#l00061">ipc::util::Native_handle::null()</a>.</p>

<p class="reference">Referenced by <a class="el" href="native__socket__stream__impl__snd_8cpp_source.html#l00028">start_send_native_handle_ops()</a>.</p>
<div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="classipc_1_1transport_1_1sync__io_1_1Native__socket__stream_1_1Impl_a3c1c949f345f0ceef5eeca3c2edec291_cgraph.svg" width="630" height="120"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe>
</div>
</div>
<div class="dynheader">
Here is the caller graph for this function:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="classipc_1_1transport_1_1sync__io_1_1Native__socket__stream_1_1Impl_a3c1c949f345f0ceef5eeca3c2edec291_icgraph.svg" width="387" height="71"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe>
</div>
</div>

</div>
</div>
<a id="a3c6214376ab8bc59823635d405f9704a" name="a3c6214376ab8bc59823635d405f9704a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3c6214376ab8bc59823635d405f9704a">&#9670;&nbsp;</a></span>start_connect_ops()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool ipc::transport::sync_io::Native_socket_stream::Impl::start_connect_ops </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespaceipc_1_1util_1_1sync__io.html#aa0b9a3cc6bdc7dedbef4f9e06851aa24">util::sync_io::Event_wait_func</a> &amp;&amp;&#160;</td>
          <td class="paramname"><em>ev_wait_func</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>It is <code>start_ops&lt;Op::S_CONN&gt;()</code>. </p>
<p >See "Connect-ops impl design" in class doc header. This guy could someday become public if and only if <a class="el" href="classipc_1_1transport_1_1sync__io_1_1Native__socket__stream_1_1Impl.html#ad6443fb49be059dbe76c75d86a18197e" title="The core of sync_connect(), written in the sync_io-pattern style.">async_connect()</a> became public.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ev_wait_func</td><td>Usual <code><a class="el" href="namespaceipc_1_1transport_1_1sync__io.html" title="sync_io-pattern counterparts to async-I/O-pattern object types in parent namespace ipc::transport.">sync_io</a></code>-pattern meaning. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>What <a class="el" href="classipc_1_1transport_1_1sync__io_1_1Native__socket__stream_1_1Impl.html#a7065a2f2c759cc9e66d46c613e628a96" title="Boiler-plate-reducing body of start_*_ops() for the given Op.">start_ops()</a> returns. </dd></dl>

<p class="definition">Definition at line <a class="el" href="sync__io_2detail_2native__socket__stream__impl_8cpp_source.html#l00181">181</a> of file <a class="el" href="sync__io_2detail_2native__socket__stream__impl_8cpp_source.html">native_socket_stream_impl.cpp</a>.</p>

<p class="reference">Referenced by <a class="el" href="sync__io_2detail_2native__socket__stream__impl_8cpp_source.html#l00069">Impl()</a>.</p>
<div class="dynheader">
Here is the caller graph for this function:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="classipc_1_1transport_1_1sync__io_1_1Native__socket__stream_1_1Impl_a3c6214376ab8bc59823635d405f9704a_icgraph.svg" width="387" height="59"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe>
</div>
</div>

</div>
</div>
<a id="a7065a2f2c759cc9e66d46c613e628a96" name="a7065a2f2c759cc9e66d46c613e628a96"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7065a2f2c759cc9e66d46c613e628a96">&#9670;&nbsp;</a></span>start_ops()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="classipc_1_1transport_1_1sync__io_1_1Native__socket__stream_1_1Impl.html#ac5471d1f4f7cad2aeb239b5f458f12f2">Op</a> OP&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool ipc::transport::sync_io::Native_socket_stream::Impl::start_ops </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespaceipc_1_1util_1_1sync__io.html#aa0b9a3cc6bdc7dedbef4f9e06851aa24">util::sync_io::Event_wait_func</a> &amp;&amp;&#160;</td>
          <td class="paramname"><em>ev_wait_func</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Boiler-plate-reducing body of <code>start_*_ops()</code> for the given Op. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">OP</td><td>See Op. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ev_wait_func</td><td>See <code>start_*_ops()</code>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>See <code>start_*_ops()</code>. Note that <a class="el" href="classipc_1_1transport_1_1sync__io_1_1Native__socket__stream_1_1Impl.html#a3c6214376ab8bc59823635d405f9704a" title="It is start_ops&lt;Op::S_CONN&gt;().">start_connect_ops()</a>, as a special case, no-ops and returns <code>false</code> if <a class="el" href="classipc_1_1transport_1_1sync__io_1_1Native__socket__stream_1_1Impl.html#a64e47a38b3ed59e37295336114918142" title="The current state of *this.">m_state</a> is not NULL. </dd></dl>

<p class="definition">Definition at line <a class="el" href="sync__io_2detail_2native__socket__stream__impl_8hpp_source.html#l01633">1633</a> of file <a class="el" href="sync__io_2detail_2native__socket__stream__impl_8hpp_source.html">native_socket_stream_impl.hpp</a>.</p>

</div>
</div>
<a id="a12e99a2479fbf08b2fa32a2f17ed1ca7" name="a12e99a2479fbf08b2fa32a2f17ed1ca7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a12e99a2479fbf08b2fa32a2f17ed1ca7">&#9670;&nbsp;</a></span>start_receive_blob_ops()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool ipc::transport::sync_io::Native_socket_stream::Impl::start_receive_blob_ops </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespaceipc_1_1util_1_1sync__io.html#aa0b9a3cc6bdc7dedbef4f9e06851aa24">util::sync_io::Event_wait_func</a> &amp;&amp;&#160;</td>
          <td class="paramname"><em>ev_wait_func</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>See <a class="el" href="classipc_1_1transport_1_1sync__io_1_1Native__socket__stream.html" title="Implements both sync_io::Native_handle_sender and sync_io::Native_handle_receiver concepts by using a...">Native_socket_stream</a> counterpart. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ev_wait_func</td><td>See <a class="el" href="classipc_1_1transport_1_1sync__io_1_1Native__socket__stream.html" title="Implements both sync_io::Native_handle_sender and sync_io::Native_handle_receiver concepts by using a...">Native_socket_stream</a> counterpart. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>See <a class="el" href="classipc_1_1transport_1_1sync__io_1_1Native__socket__stream.html" title="Implements both sync_io::Native_handle_sender and sync_io::Native_handle_receiver concepts by using a...">Native_socket_stream</a> counterpart. </dd></dl>

<p class="definition">Definition at line <a class="el" href="native__socket__stream__impl__rcv_8cpp_source.html#l00032">32</a> of file <a class="el" href="native__socket__stream__impl__rcv_8cpp_source.html">native_socket_stream_impl_rcv.cpp</a>.</p>

<p class="reference">References <a class="el" href="sync__io_2native__socket__stream_8hpp_source.html#l00807">ipc::transport::sync_io::Native_socket_stream::start_receive_native_handle_ops()</a>.</p>
<div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="classipc_1_1transport_1_1sync__io_1_1Native__socket__stream_1_1Impl_a12e99a2479fbf08b2fa32a2f17ed1ca7_cgraph.svg" width="924" height="71"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe>
</div>
</div>

</div>
</div>
<a id="a4a94088b9f00288ae7e2cf3c7b49c444" name="a4a94088b9f00288ae7e2cf3c7b49c444"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4a94088b9f00288ae7e2cf3c7b49c444">&#9670;&nbsp;</a></span>start_receive_native_handle_ops()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool ipc::transport::sync_io::Native_socket_stream::Impl::start_receive_native_handle_ops </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespaceipc_1_1util_1_1sync__io.html#aa0b9a3cc6bdc7dedbef4f9e06851aa24">util::sync_io::Event_wait_func</a> &amp;&amp;&#160;</td>
          <td class="paramname"><em>ev_wait_func</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>See <a class="el" href="classipc_1_1transport_1_1sync__io_1_1Native__socket__stream.html" title="Implements both sync_io::Native_handle_sender and sync_io::Native_handle_receiver concepts by using a...">Native_socket_stream</a> counterpart. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ev_wait_func</td><td>See <a class="el" href="classipc_1_1transport_1_1sync__io_1_1Native__socket__stream.html" title="Implements both sync_io::Native_handle_sender and sync_io::Native_handle_receiver concepts by using a...">Native_socket_stream</a> counterpart. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>See <a class="el" href="classipc_1_1transport_1_1sync__io_1_1Native__socket__stream.html" title="Implements both sync_io::Native_handle_sender and sync_io::Native_handle_receiver concepts by using a...">Native_socket_stream</a> counterpart. </dd></dl>

<p class="definition">Definition at line <a class="el" href="native__socket__stream__impl__rcv_8cpp_source.html#l00027">27</a> of file <a class="el" href="native__socket__stream__impl__rcv_8cpp_source.html">native_socket_stream_impl_rcv.cpp</a>.</p>

</div>
</div>
<a id="a6a01d2df2772ee72e4386e84684394e3" name="a6a01d2df2772ee72e4386e84684394e3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6a01d2df2772ee72e4386e84684394e3">&#9670;&nbsp;</a></span>start_send_blob_ops()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool ipc::transport::sync_io::Native_socket_stream::Impl::start_send_blob_ops </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespaceipc_1_1util_1_1sync__io.html#aa0b9a3cc6bdc7dedbef4f9e06851aa24">util::sync_io::Event_wait_func</a> &amp;&amp;&#160;</td>
          <td class="paramname"><em>ev_wait_func</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>See <a class="el" href="classipc_1_1transport_1_1sync__io_1_1Native__socket__stream.html" title="Implements both sync_io::Native_handle_sender and sync_io::Native_handle_receiver concepts by using a...">Native_socket_stream</a> counterpart. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ev_wait_func</td><td>See <a class="el" href="classipc_1_1transport_1_1sync__io_1_1Native__socket__stream.html" title="Implements both sync_io::Native_handle_sender and sync_io::Native_handle_receiver concepts by using a...">Native_socket_stream</a> counterpart. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>See <a class="el" href="classipc_1_1transport_1_1sync__io_1_1Native__socket__stream.html" title="Implements both sync_io::Native_handle_sender and sync_io::Native_handle_receiver concepts by using a...">Native_socket_stream</a> counterpart. </dd></dl>

<p class="definition">Definition at line <a class="el" href="native__socket__stream__impl__snd_8cpp_source.html#l00083">83</a> of file <a class="el" href="native__socket__stream__impl__snd_8cpp_source.html">native_socket_stream_impl_snd.cpp</a>.</p>

<p class="reference">References <a class="el" href="sync__io_2native__socket__stream_8hpp_source.html#l00779">ipc::transport::sync_io::Native_socket_stream::start_send_native_handle_ops()</a>.</p>
<div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="classipc_1_1transport_1_1sync__io_1_1Native__socket__stream_1_1Impl_a6a01d2df2772ee72e4386e84684394e3_cgraph.svg" width="886" height="71"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe>
</div>
</div>

</div>
</div>
<a id="a65eea0cec146df598fce1d9ab5ce7e15" name="a65eea0cec146df598fce1d9ab5ce7e15"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a65eea0cec146df598fce1d9ab5ce7e15">&#9670;&nbsp;</a></span>start_send_native_handle_ops()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool ipc::transport::sync_io::Native_socket_stream::Impl::start_send_native_handle_ops </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespaceipc_1_1util_1_1sync__io.html#aa0b9a3cc6bdc7dedbef4f9e06851aa24">util::sync_io::Event_wait_func</a> &amp;&amp;&#160;</td>
          <td class="paramname"><em>ev_wait_func</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>See <a class="el" href="classipc_1_1transport_1_1sync__io_1_1Native__socket__stream.html" title="Implements both sync_io::Native_handle_sender and sync_io::Native_handle_receiver concepts by using a...">Native_socket_stream</a> counterpart. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ev_wait_func</td><td>See <a class="el" href="classipc_1_1transport_1_1sync__io_1_1Native__socket__stream.html" title="Implements both sync_io::Native_handle_sender and sync_io::Native_handle_receiver concepts by using a...">Native_socket_stream</a> counterpart. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>See <a class="el" href="classipc_1_1transport_1_1sync__io_1_1Native__socket__stream.html" title="Implements both sync_io::Native_handle_sender and sync_io::Native_handle_receiver concepts by using a...">Native_socket_stream</a> counterpart. </dd></dl>

<p class="definition">Definition at line <a class="el" href="native__socket__stream__impl__snd_8cpp_source.html#l00028">28</a> of file <a class="el" href="native__socket__stream__impl__snd_8cpp_source.html">native_socket_stream_impl_snd.cpp</a>.</p>

<p class="reference">References <a class="el" href="protocol__negotiator_8cpp_source.html#l00130">ipc::transport::Protocol_negotiator::local_max_proto_ver_for_sending()</a>, <a class="el" href="sync__io_2detail_2native__socket__stream__impl_8hpp_source.html#l01171">m_protocol_negotiator</a>, <a class="el" href="sync__io_2detail_2native__socket__stream__impl_8hpp_source.html#l01436">m_snd_pending_err_code</a>, <a class="el" href="protocol__negotiator_8hpp_source.html#l00215">ipc::transport::Protocol_negotiator::S_VER_UNKNOWN</a>, and <a class="el" href="native__socket__stream__impl__snd_8cpp_source.html#l00605">snd_sync_write_or_q_payload()</a>.</p>
<div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="classipc_1_1transport_1_1sync__io_1_1Native__socket__stream_1_1Impl_a65eea0cec146df598fce1d9ab5ce7e15_cgraph.svg" width="842" height="166"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe>
</div>
</div>

</div>
</div>
<a id="a18de125ad318ba69cee7d8cb8204ad12" name="a18de125ad318ba69cee7d8cb8204ad12"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a18de125ad318ba69cee7d8cb8204ad12">&#9670;&nbsp;</a></span>state_peer()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool ipc::transport::sync_io::Native_socket_stream::Impl::state_peer </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespaceipc_1_1util.html#ae6ac47812a90d1287c61e0b7de7bc4f5">util::String_view</a>&#160;</td>
          <td class="paramname"><em>context</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Checks whether <a class="el" href="classipc_1_1transport_1_1sync__io_1_1Native__socket__stream_1_1Impl.html#a64e47a38b3ed59e37295336114918142" title="The current state of *this.">m_state</a> has reached <a class="el" href="classipc_1_1transport_1_1sync__io_1_1Native__socket__stream_1_1Impl.html#a9c9825f74472868eb1397c33edf78fb4ad9a05d721258c584cd559c56fd035887" title="Is or was a connected peer.">State::S_PEER</a>; if so returns <code>true</code>; if not logs WARNING and returns <code>false</code>. </p>
<p >In the latter case the caller should immediately return; in the former it should continue.</p>
<p >Intended use: All public APIs that require PEER state shall do this ~first-thing.</p>
<h3>Rationale</h3>
<p >In the context of reaching PEER state, <a class="el" href="classipc_1_1transport_1_1sync__io_1_1Native__socket__stream_1_1Impl.html#a64e47a38b3ed59e37295336114918142" title="The current state of *this.">m_state</a> is essentially a barrier of sorts: PEER is the terminal state (one cannot exit it until dtor), and connected-state operations all promise to immediately return <code>false</code> (or equivalent) unless PEER has been reached.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">context</td><td>Description of caller (probably <code>"...func_name...(...more-info-maybe...)"</code>) for logging. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>See above. </dd></dl>

<p class="definition">Definition at line <a class="el" href="sync__io_2detail_2native__socket__stream__impl_8cpp_source.html#l00504">504</a> of file <a class="el" href="sync__io_2detail_2native__socket__stream__impl_8cpp_source.html">native_socket_stream_impl.cpp</a>.</p>

</div>
</div>
<a id="a3c5187e34876a0419ff70734ec0fbf14" name="a3c5187e34876a0419ff70734ec0fbf14"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3c5187e34876a0419ff70734ec0fbf14">&#9670;&nbsp;</a></span>sync_connect()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool ipc::transport::sync_io::Native_socket_stream::Impl::sync_connect </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespaceipc_1_1transport.html#a33de1c256addb3964b839dc2dd407d24">Shared_name</a> &amp;&#160;</td>
          <td class="paramname"><em>absolute_name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceipc.html#aa3192e586cc45d3e7c22463bf2760f89">Error_code</a> *&#160;</td>
          <td class="paramname"><em>err_code</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>See <a class="el" href="classipc_1_1transport_1_1sync__io_1_1Native__socket__stream.html" title="Implements both sync_io::Native_handle_sender and sync_io::Native_handle_receiver concepts by using a...">Native_socket_stream</a> counterpart. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">absolute_name</td><td>See <a class="el" href="classipc_1_1transport_1_1sync__io_1_1Native__socket__stream.html" title="Implements both sync_io::Native_handle_sender and sync_io::Native_handle_receiver concepts by using a...">Native_socket_stream</a> counterpart. </td></tr>
    <tr><td class="paramname">err_code</td><td>See <a class="el" href="classipc_1_1transport_1_1sync__io_1_1Native__socket__stream.html" title="Implements both sync_io::Native_handle_sender and sync_io::Native_handle_receiver concepts by using a...">Native_socket_stream</a> counterpart. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>See <a class="el" href="classipc_1_1transport_1_1sync__io_1_1Native__socket__stream.html" title="Implements both sync_io::Native_handle_sender and sync_io::Native_handle_receiver concepts by using a...">Native_socket_stream</a> counterpart. </dd></dl>

<p class="definition">Definition at line <a class="el" href="sync__io_2detail_2native__socket__stream__impl_8cpp_source.html#l00186">186</a> of file <a class="el" href="sync__io_2detail_2native__socket__stream__impl_8cpp_source.html">native_socket_stream_impl.cpp</a>.</p>

<p class="reference">References <a class="el" href="namespaceipc_1_1transport_1_1error.html#adfef15ef4e76cc55d652fbd9c2797297aa667487757f9d6300f6888bac40bcc24">ipc::transport::error::S_SYNC_IO_WOULD_BLOCK</a>, and <a class="el" href="sync__io_2native__socket__stream_8cpp_source.html#l00083">ipc::transport::sync_io::Native_socket_stream::sync_connect()</a>.</p>
<div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="classipc_1_1transport_1_1sync__io_1_1Native__socket__stream_1_1Impl_a3c5187e34876a0419ff70734ec0fbf14_cgraph.svg" width="630" height="59"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe>
</div>
</div>

</div>
</div>
<a id="a6c55ac2f7dad90d23bbd878e753ff791" name="a6c55ac2f7dad90d23bbd878e753ff791"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6c55ac2f7dad90d23bbd878e753ff791">&#9670;&nbsp;</a></span>sync_io_ev_wait_func() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="classipc_1_1transport_1_1sync__io_1_1Native__socket__stream_1_1Impl.html#ac5471d1f4f7cad2aeb239b5f458f12f2">Op</a> OP&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespaceipc_1_1util_1_1sync__io.html#aa0b9a3cc6bdc7dedbef4f9e06851aa24">util::sync_io::Event_wait_func</a> * ipc::transport::sync_io::Native_socket_stream::Impl::sync_io_ev_wait_func </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><code>const</code> version of the other overload. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">OP</td><td>See above. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>See above. </dd></dl>

<p class="definition">Definition at line <a class="el" href="sync__io_2detail_2native__socket__stream__impl_8hpp_source.html#l01595">1595</a> of file <a class="el" href="sync__io_2detail_2native__socket__stream__impl_8hpp_source.html">native_socket_stream_impl.hpp</a>.</p>

<p class="reference">References <a class="el" href="sync__io_2detail_2native__socket__stream__impl_8hpp_source.html#l01416">m_conn_ev_wait_func</a>, <a class="el" href="sync__io_2detail_2native__socket__stream__impl_8hpp_source.html#l01589">m_rcv_ev_wait_func</a>, and <a class="el" href="sync__io_2detail_2native__socket__stream__impl_8hpp_source.html#l01500">m_snd_ev_wait_func</a>.</p>

</div>
</div>
<a id="a3c1ea07348e9e1cd7ff6c8dbdca290d9" name="a3c1ea07348e9e1cd7ff6c8dbdca290d9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3c1ea07348e9e1cd7ff6c8dbdca290d9">&#9670;&nbsp;</a></span>sync_io_ev_wait_func() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="classipc_1_1transport_1_1sync__io_1_1Native__socket__stream_1_1Impl.html#ac5471d1f4f7cad2aeb239b5f458f12f2">Op</a> OP&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="namespaceipc_1_1util_1_1sync__io.html#aa0b9a3cc6bdc7dedbef4f9e06851aa24">util::sync_io::Event_wait_func</a> * ipc::transport::sync_io::Native_socket_stream::Impl::sync_io_ev_wait_func </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>For boiler-plate-reducing generic code: Returns the <code>m_*_ev_wait_func</code> corresponding to the given Op. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">OP</td><td>See Op. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>See above. </dd></dl>

<p class="definition">Definition at line <a class="el" href="sync__io_2detail_2native__socket__stream__impl_8hpp_source.html#l01613">1613</a> of file <a class="el" href="sync__io_2detail_2native__socket__stream__impl_8hpp_source.html">native_socket_stream_impl.hpp</a>.</p>

</div>
</div>
<h2 class="groupheader">Friends And Related Function Documentation</h2>
<a id="a33231b969171a9103cd0a319ea10278b" name="a33231b969171a9103cd0a319ea10278b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a33231b969171a9103cd0a319ea10278b">&#9670;&nbsp;</a></span>operator&lt;&lt;()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::ostream &amp; operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>os</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classipc_1_1transport_1_1sync__io_1_1Native__socket__stream_1_1Impl.html">Native_socket_stream::Impl</a> &amp;&#160;</td>
          <td class="paramname"><em>val</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Prints string representation of the given <a class="el" href="classipc_1_1transport_1_1sync__io_1_1Native__socket__stream_1_1Impl.html" title="Internal, non-movable pImpl implementation of sync_io::Native_socket_stream class.">Native_socket_stream::Impl</a> to the given <code>ostream</code>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">os</td><td>Stream to which to write. </td></tr>
    <tr><td class="paramname">val</td><td>Object to serialize. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>os</code>. </dd></dl>

<p class="definition">Definition at line <a class="el" href="sync__io_2detail_2native__socket__stream__impl_8cpp_source.html#l00516">516</a> of file <a class="el" href="sync__io_2detail_2native__socket__stream__impl_8cpp_source.html">native_socket_stream_impl.cpp</a>.</p>

</div>
</div>
<h2 class="groupheader">Member Data Documentation</h2>
<a id="ae094bf64dda8f6c6e013400a77fd1343" name="ae094bf64dda8f6c6e013400a77fd1343"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae094bf64dda8f6c6e013400a77fd1343">&#9670;&nbsp;</a></span>m_conn_async_worker</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::optional&lt;flow::async::Single_thread_task_loop&gt; ipc::transport::sync_io::Native_socket_stream::Impl::m_conn_async_worker</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Event loop used exclusively by <a class="el" href="classipc_1_1transport_1_1sync__io_1_1Native__socket__stream_1_1Impl.html#a3c5187e34876a0419ff70734ec0fbf14" title="See Native_socket_stream counterpart.">sync_connect()</a> which as needed <code>-&gt;start()</code>s a short-lived thread and <code>-&gt;stop()</code>s it before returning, in case <a class="el" href="classipc_1_1transport_1_1sync__io_1_1Native__socket__stream_1_1Impl.html#ad6443fb49be059dbe76c75d86a18197e" title="The core of sync_connect(), written in the sync_io-pattern style.">async_connect()</a> does not complete synchronously. </p>
<p >Null in PEER state; non-null in NULL state (when <a class="el" href="classipc_1_1transport_1_1sync__io_1_1Native__socket__stream_1_1Impl.html#a3c5187e34876a0419ff70734ec0fbf14" title="See Native_socket_stream counterpart.">sync_connect()</a> might be called and not no-op).</p>
<p >See "Connect-ops impl design" in class doc header for key background discussion of <a class="el" href="classipc_1_1transport_1_1sync__io_1_1Native__socket__stream_1_1Impl.html#a3c5187e34876a0419ff70734ec0fbf14" title="See Native_socket_stream counterpart.">sync_connect()</a> et al. </p>

<p class="definition">Definition at line <a class="el" href="sync__io_2detail_2native__socket__stream__impl_8hpp_source.html#l01379">1379</a> of file <a class="el" href="sync__io_2detail_2native__socket__stream__impl_8hpp_source.html">native_socket_stream_impl.hpp</a>.</p>

<p class="reference">Referenced by <a class="el" href="sync__io_2detail_2native__socket__stream__impl_8cpp_source.html#l00069">Impl()</a>.</p>

</div>
</div>
<a id="aa020c49ecb9fb12fb554342f096b9822" name="aa020c49ecb9fb12fb554342f096b9822"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa020c49ecb9fb12fb554342f096b9822">&#9670;&nbsp;</a></span>m_conn_ev_wait_func</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespaceipc_1_1util_1_1sync__io.html#aa0b9a3cc6bdc7dedbef4f9e06851aa24">util::sync_io::Event_wait_func</a> ipc::transport::sync_io::Native_socket_stream::Impl::m_conn_ev_wait_func</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Function (set forever in <a class="el" href="classipc_1_1transport_1_1sync__io_1_1Native__socket__stream_1_1Impl.html#a3c6214376ab8bc59823635d405f9704a" title="It is start_ops&lt;Op::S_CONN&gt;().">start_connect_ops()</a>) through which we invoke the outside event loop's async-wait facility for descriptors/events relevant to connect-ops. </p>
<p >See <a class="el" href="namespaceipc_1_1util_1_1sync__io.html#aa0b9a3cc6bdc7dedbef4f9e06851aa24" title="In sync_io pattern, concrete type storing user-supplied function invoked by pattern-implementing ipc:...">util::sync_io::Event_wait_func</a> doc header for a refresher on this mechanic. </p>

<p class="definition">Definition at line <a class="el" href="sync__io_2detail_2native__socket__stream__impl_8hpp_source.html#l01416">1416</a> of file <a class="el" href="sync__io_2detail_2native__socket__stream__impl_8hpp_source.html">native_socket_stream_impl.hpp</a>.</p>

<p class="reference">Referenced by <a class="el" href="sync__io_2detail_2native__socket__stream__impl_8hpp_source.html#l01595">sync_io_ev_wait_func()</a>.</p>

</div>
</div>
<a id="aa2d79438a470aa94feb2fbbcd72dc629" name="aa2d79438a470aa94feb2fbbcd72dc629"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa2d79438a470aa94feb2fbbcd72dc629">&#9670;&nbsp;</a></span>m_conn_ev_wait_hndl_peer_socket</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::optional&lt;<a class="el" href="classipc_1_1util_1_1sync__io_1_1Asio__waitable__native__handle.html">util::sync_io::Asio_waitable_native_handle</a>&gt; ipc::transport::sync_io::Native_socket_stream::Impl::m_conn_ev_wait_hndl_peer_socket</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>This is to (<a class="el" href="classipc_1_1transport_1_1sync__io_1_1Native__socket__stream_1_1Impl.html#a42aab631e9c70bfaa53764309adfe37c" title="The peer stream-type Unix domain socket; or null pointer if we&#39;ve detected the connection has become ...">m_peer_socket</a>, <a class="el" href="classipc_1_1transport_1_1sync__io_1_1Native__socket__stream_1_1Impl.html#ae094bf64dda8f6c6e013400a77fd1343" title="Event loop used exclusively by sync_connect() which as needed -&gt;start()s a short-lived thread and -&gt;s...">m_conn_async_worker</a>) what <a class="el" href="classipc_1_1transport_1_1sync__io_1_1Native__socket__stream_1_1Impl.html#a0ac6a82eda9256cba45f3b5365d79355" title="Descriptor waitable by outside event loop async-waits â€“ storing the same Native_handle as (and thus b...">m_ev_wait_hndl_peer_socket</a> is to (<a class="el" href="classipc_1_1transport_1_1sync__io_1_1Native__socket__stream_1_1Impl.html#a42aab631e9c70bfaa53764309adfe37c" title="The peer stream-type Unix domain socket; or null pointer if we&#39;ve detected the connection has become ...">m_peer_socket</a>, <a class="el" href="classipc_1_1transport_1_1Native__socket__stream_1_1Impl.html#a4a7ab0a981614724b559b38634634d8a" title="Single-thread worker pool for all internal async work in both directions.">transport::Native_socket_stream::Impl::m_worker</a>), respectively. </p>
<p >Thus it stores yet another copy of <code>m_peer_socket-&gt;native_handle()</code> but associated with <code>m_conn_async_worker-&gt;task_engine()</code>; so that <a class="el" href="classipc_1_1transport_1_1sync__io_1_1Native__socket__stream_1_1Impl.html#ad6443fb49be059dbe76c75d86a18197e" title="The core of sync_connect(), written in the sync_io-pattern style.">async_connect()</a> &ndash; if it needs to execute an async-wait &ndash; can (via <code><a class="el" href="namespaceipc_1_1transport_1_1sync__io.html" title="sync_io-pattern counterparts to async-I/O-pattern object types in parent namespace ipc::transport.">sync_io</a></code> pattern) make use of <code>m_conn_ev_wait_hndl_peer_socket-&gt;async_wait(F)</code>, and completion handler <code>F()</code> shall be posted onto the short-lived thread resulting from <code>m_conn_async_worker-&gt;start()</code> in <a class="el" href="classipc_1_1transport_1_1sync__io_1_1Native__socket__stream_1_1Impl.html#a3c5187e34876a0419ff70734ec0fbf14" title="See Native_socket_stream counterpart.">sync_connect()</a>.</p>
<p >Null if and only if <a class="el" href="classipc_1_1transport_1_1sync__io_1_1Native__socket__stream_1_1Impl.html#ae094bf64dda8f6c6e013400a77fd1343" title="Event loop used exclusively by sync_connect() which as needed -&gt;start()s a short-lived thread and -&gt;s...">m_conn_async_worker</a> is null.</p>
<p >See "Connect-ops impl design" in class doc header for key background discussion of <a class="el" href="classipc_1_1transport_1_1sync__io_1_1Native__socket__stream_1_1Impl.html#a3c5187e34876a0419ff70734ec0fbf14" title="See Native_socket_stream counterpart.">sync_connect()</a> et al.</p>
<h3>Rationale</h3>
<p >It is also possible to instead just use <a class="el" href="classipc_1_1transport_1_1sync__io_1_1Native__socket__stream_1_1Impl.html#a0ac6a82eda9256cba45f3b5365d79355" title="Descriptor waitable by outside event loop async-waits â€“ storing the same Native_handle as (and thus b...">m_ev_wait_hndl_peer_socket</a> for the connect-ops <code><a class="el" href="namespaceipc_1_1transport_1_1sync__io.html" title="sync_io-pattern counterparts to async-I/O-pattern object types in parent namespace ipc::transport.">sync_io</a></code>-pattern setup, along with using it for send-ops and receive-ops. However, while storing marginally less state, it is pretty annoying in other ways: <a class="el" href="classipc_1_1transport_1_1sync__io_1_1Native__socket__stream_1_1Impl.html#a8b9839bb39e95a51ed7c920137438a21" title="See Native_socket_stream counterpart.">replace_event_wait_handles()</a> to set up future send-ops and receive-ops can happen at any time, including before <a class="el" href="classipc_1_1transport_1_1sync__io_1_1Native__socket__stream_1_1Impl.html#a3c5187e34876a0419ff70734ec0fbf14" title="See Native_socket_stream counterpart.">sync_connect()</a>; so <a class="el" href="classipc_1_1transport_1_1sync__io_1_1Native__socket__stream_1_1Impl.html#a3c5187e34876a0419ff70734ec0fbf14" title="See Native_socket_stream counterpart.">sync_connect()</a> would need to save <a class="el" href="classipc_1_1transport_1_1sync__io_1_1Native__socket__stream_1_1Impl.html#a0ac6a82eda9256cba45f3b5365d79355" title="Descriptor waitable by outside event loop async-waits â€“ storing the same Native_handle as (and thus b...">m_ev_wait_hndl_peer_socket</a>, then re-associate it with <a class="el" href="classipc_1_1transport_1_1sync__io_1_1Native__socket__stream_1_1Impl.html#ae094bf64dda8f6c6e013400a77fd1343" title="Event loop used exclusively by sync_connect() which as needed -&gt;start()s a short-lived thread and -&gt;s...">m_conn_async_worker</a>, then restore it. Whereas by decoupling as we do here, we separate the NULL-state and PEER-state algorithms cleanly and need to worry about that stuff.</p>
<p >(Maintenance note: If/when &ndash; as speculated in class doc header section "Connect-ops impl design" &ndash; we make <a class="el" href="classipc_1_1transport_1_1sync__io_1_1Native__socket__stream_1_1Impl.html#a3c6214376ab8bc59823635d405f9704a" title="It is start_ops&lt;Op::S_CONN&gt;().">start_connect_ops()</a> and <a class="el" href="classipc_1_1transport_1_1sync__io_1_1Native__socket__stream_1_1Impl.html#ad6443fb49be059dbe76c75d86a18197e" title="The core of sync_connect(), written in the sync_io-pattern style.">async_connect()</a> public at some point, then probably it'll be best to indeed eliminate <code>m_conn_ev_wait_hndl_peer_socket</code> and use <code>m_ev_wait_hndl_peer_socket</code> for all the ops, including having <a class="el" href="classipc_1_1transport_1_1sync__io_1_1Native__socket__stream_1_1Impl.html#a8b9839bb39e95a51ed7c920137438a21" title="See Native_socket_stream counterpart.">replace_event_wait_handles()</a> handle connect-ops stuff in addition to send-ops and receive-ops. Now the user will be in charge of providing async-waiting machinery for connect-ops per normal <code>sync_op</code> pattern, as opposed to the existing situation where we manage that internally to <code>*this</code>.) </p>

<p class="definition">Definition at line <a class="el" href="sync__io_2detail_2native__socket__stream__impl_8hpp_source.html#l01409">1409</a> of file <a class="el" href="sync__io_2detail_2native__socket__stream__impl_8hpp_source.html">native_socket_stream_impl.hpp</a>.</p>

<p class="reference">Referenced by <a class="el" href="sync__io_2detail_2native__socket__stream__impl_8cpp_source.html#l00069">Impl()</a>.</p>

</div>
</div>
<a id="a0900c54fc01d0d67b94208b47fff7469" name="a0900c54fc01d0d67b94208b47fff7469"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0900c54fc01d0d67b94208b47fff7469">&#9670;&nbsp;</a></span>m_ev_hndl_task_engine_unused</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">flow::util::Task_engine ipc::transport::sync_io::Native_socket_stream::Impl::m_ev_hndl_task_engine_unused</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>The <code>Task_engine</code> for <code>m_*ev_wait_hndl_*</code>, unless it is replaced via <a class="el" href="classipc_1_1transport_1_1sync__io_1_1Native__socket__stream_1_1Impl.html#a8b9839bb39e95a51ed7c920137438a21" title="See Native_socket_stream counterpart.">replace_event_wait_handles()</a>. </p>
<p >There are 2 possibilities:</p><ul>
<li>They leave this guy associated with <code>m_*ev_wait_hndl_*</code>. Then no one shall be doing <code>.async_wait()</code> on them, and instead the user aims to perhaps use raw <code>[e]poll*()</code> on their <code>.native_handle()</code>s. We still need some <code>Task_engine</code> to construct them though, so we use this.</li>
<li>They use <a class="el" href="classipc_1_1transport_1_1sync__io_1_1Native__socket__stream_1_1Impl.html#a8b9839bb39e95a51ed7c920137438a21" title="See Native_socket_stream counterpart.">replace_event_wait_handles()</a>, and therefore this becomes dissociated with <code>m_*ev_wait_hndl_*</code> and becomes completely unused in any fashion, period. Then they shall probably be doing their own <code>.async_wait()</code> &ndash; associated with their own <code>Task_engine</code> &ndash; on <code>m_*ev_wait_hndl_*</code>.</li>
</ul>
<p >This is all to fulfill the <code><a class="el" href="namespaceipc_1_1transport_1_1sync__io.html" title="sync_io-pattern counterparts to async-I/O-pattern object types in parent namespace ipc::transport.">sync_io</a></code> pattern. </p>

<p class="definition">Definition at line <a class="el" href="sync__io_2detail_2native__socket__stream__impl_8hpp_source.html#l01196">1196</a> of file <a class="el" href="sync__io_2detail_2native__socket__stream__impl_8hpp_source.html">native_socket_stream_impl.hpp</a>.</p>

</div>
</div>
<a id="a0ac6a82eda9256cba45f3b5365d79355" name="a0ac6a82eda9256cba45f3b5365d79355"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0ac6a82eda9256cba45f3b5365d79355">&#9670;&nbsp;</a></span>m_ev_wait_hndl_peer_socket</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classipc_1_1util_1_1sync__io_1_1Asio__waitable__native__handle.html">util::sync_io::Asio_waitable_native_handle</a> ipc::transport::sync_io::Native_socket_stream::Impl::m_ev_wait_hndl_peer_socket</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Descriptor waitable by outside event loop async-waits &ndash; storing the same <code>Native_handle</code> as (and thus being used to wait on events from) <a class="el" href="classipc_1_1transport_1_1sync__io_1_1Native__socket__stream_1_1Impl.html#a42aab631e9c70bfaa53764309adfe37c" title="The peer stream-type Unix domain socket; or null pointer if we&#39;ve detected the connection has become ...">m_peer_socket</a>. </p>
<p >Protected by <a class="el" href="classipc_1_1transport_1_1sync__io_1_1Native__socket__stream_1_1Impl.html#abc7d2b14208ed2b8c0add0c26f7fbf27" title="Protects m_peer_socket and its bros m_ev_wait_hndl_peer_socket and m_peer_socket_hosed.">m_peer_socket_mutex</a>, along with <a class="el" href="classipc_1_1transport_1_1sync__io_1_1Native__socket__stream_1_1Impl.html#a42aab631e9c70bfaa53764309adfe37c" title="The peer stream-type Unix domain socket; or null pointer if we&#39;ve detected the connection has become ...">m_peer_socket</a>. To be accessed only if an error hasn't nullified <a class="el" href="classipc_1_1transport_1_1sync__io_1_1Native__socket__stream_1_1Impl.html#a42aab631e9c70bfaa53764309adfe37c" title="The peer stream-type Unix domain socket; or null pointer if we&#39;ve detected the connection has become ...">m_peer_socket</a> since the last critical section. Now, "accessed" <em>always</em> (once set up) means calling <code>m_*_ev_wait_wait_func</code> with this guy as the 1st arg; it can be pictured as a <code><a class="el" href="namespaceipc_1_1transport_1_1sync__io.html" title="sync_io-pattern counterparts to async-I/O-pattern object types in parent namespace ipc::transport.">sync_io</a></code> equivalent of <code>m_peer_socket-&gt;async_wait()</code>. However it does mean the <code>*this</code> user must be careful not to lock something in that function that is already locked when they call <code>(*on_active_ev_func)()</code> &ndash; that would cause a deadlock &ndash; and if it's a recursive mutex, then they risk an AB/BA deadlock.</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classipc_1_1transport_1_1sync__io_1_1Native__socket__stream_1_1Impl.html#a54c3fdde2cf99fda314ee3387f70a02e" title="As typical in timer-needing sync_io-pattern-implementing objects, maintains a thread exclusively for ...">m_timer_worker</a> for more info. </dd></dl>

<p class="definition">Definition at line <a class="el" href="sync__io_2detail_2native__socket__stream__impl_8hpp_source.html#l01355">1355</a> of file <a class="el" href="sync__io_2detail_2native__socket__stream__impl_8hpp_source.html">native_socket_stream_impl.hpp</a>.</p>

<p class="reference">Referenced by <a class="el" href="sync__io_2detail_2native__socket__stream__impl_8cpp_source.html#l00069">Impl()</a>.</p>

</div>
</div>
<a id="a1caa342f726a273deb64317cbec8b5ea" name="a1caa342f726a273deb64317cbec8b5ea"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1caa342f726a273deb64317cbec8b5ea">&#9670;&nbsp;</a></span>m_nb_task_engine</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">flow::util::Task_engine ipc::transport::sync_io::Native_socket_stream::Impl::m_nb_task_engine</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>The <code>Task_engine</code> for <a class="el" href="classipc_1_1transport_1_1sync__io_1_1Native__socket__stream_1_1Impl.html#a42aab631e9c70bfaa53764309adfe37c" title="The peer stream-type Unix domain socket; or null pointer if we&#39;ve detected the connection has become ...">m_peer_socket</a>. </p>
<p >It is necessary to construct the <code>Peer_socket</code>, but we never use that guy's <code>-&gt;async_*()</code> APIs &ndash; only non-blocking operations, essentially leveraging boost.asio's portable transmission APIs but not its actual, um, async-I/O abilities in this case. Accordingly we never load any tasks onto <a class="el" href="classipc_1_1transport_1_1sync__io_1_1Native__socket__stream_1_1Impl.html#a1caa342f726a273deb64317cbec8b5ea" title="The Task_engine for m_peer_socket.">m_nb_task_engine</a> and certainly never <code>.run()</code> (or <code>.poll()</code> or ...) it.</p>
<p >In the <code><a class="el" href="namespaceipc_1_1transport_1_1sync__io.html" title="sync_io-pattern counterparts to async-I/O-pattern object types in parent namespace ipc::transport.">sync_io</a></code> pattern the user's outside event loop is responsible for awaiting readability/writability of a guy like <a class="el" href="classipc_1_1transport_1_1sync__io_1_1Native__socket__stream_1_1Impl.html#a42aab631e9c70bfaa53764309adfe37c" title="The peer stream-type Unix domain socket; or null pointer if we&#39;ve detected the connection has become ...">m_peer_socket</a> via our exporting of its <code>.native_handle()</code>. </p>

<p class="definition">Definition at line <a class="el" href="sync__io_2detail_2native__socket__stream__impl_8hpp_source.html#l01182">1182</a> of file <a class="el" href="sync__io_2detail_2native__socket__stream__impl_8hpp_source.html">native_socket_stream_impl.hpp</a>.</p>

<p class="reference">Referenced by <a class="el" href="sync__io_2detail_2native__socket__stream__impl_8cpp_source.html#l00069">Impl()</a>.</p>

</div>
</div>
<a id="a1374593e1cecd44ccb07d939f3673a35" name="a1374593e1cecd44ccb07d939f3673a35"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1374593e1cecd44ccb07d939f3673a35">&#9670;&nbsp;</a></span>m_nickname</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::string ipc::transport::sync_io::Native_socket_stream::Impl::m_nickname</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>See <a class="el" href="classipc_1_1transport_1_1sync__io_1_1Native__socket__stream_1_1Impl.html#a0ddd1b1e57bc61827d457e16e3db8600" title="See Native_socket_stream counterpart.">nickname()</a>. </p>

<p class="definition">Definition at line <a class="el" href="sync__io_2detail_2native__socket__stream__impl_8hpp_source.html#l01120">1120</a> of file <a class="el" href="sync__io_2detail_2native__socket__stream__impl_8hpp_source.html">native_socket_stream_impl.hpp</a>.</p>

</div>
</div>
<a id="a42aab631e9c70bfaa53764309adfe37c" name="a42aab631e9c70bfaa53764309adfe37c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a42aab631e9c70bfaa53764309adfe37c">&#9670;&nbsp;</a></span>m_peer_socket</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">boost::movelib::unique_ptr&lt;<a class="el" href="namespaceipc_1_1transport_1_1asio__local__stream__socket.html#a1788f9dbd896bb71b3693f9ae25b40ae">asio_local_stream_socket::Peer_socket</a>&gt; ipc::transport::sync_io::Native_socket_stream::Impl::m_peer_socket</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>The peer stream-type Unix domain socket; or null pointer if we've detected the connection has become hosed and hence have ceased all all work on the boost.asio <code>Peer_socket</code> short of its destruction. </p>
<p >Note that (1) it starts non-null (see also related <a class="el" href="classipc_1_1transport_1_1sync__io_1_1Native__socket__stream_1_1Impl.html#a2a389318796d7386b114649a61c7d4f9" title="Null to start, this takes on the value from m_peer_socket when and only when m_peer_socket is nullifi...">m_peer_socket_hosed</a>), and is in "open" (FD-bearing) state from the start &ndash; even if the NULL-state ctor was used; and (2) can only become null (irreversibly so) when in PEER state, only on error.</p><ul>
<li>In <a class="el" href="classipc_1_1transport_1_1sync__io_1_1Native__socket__stream_1_1Impl.html#a9c9825f74472868eb1397c33edf78fb4ac6bd7568063494695099321f427efcb2" title="Not a peer.">State::S_NULL</a> <a class="el" href="classipc_1_1transport_1_1sync__io_1_1Native__socket__stream_1_1Impl.html#a64e47a38b3ed59e37295336114918142" title="The current state of *this.">m_state</a>, this is an "open" (FD-bearing) but unconnected socket.</li>
<li>In <a class="el" href="classipc_1_1transport_1_1sync__io_1_1Native__socket__stream_1_1Impl.html#a9c9825f74472868eb1397c33edf78fb4aae585d03fce4ac2011967830bf0ffbfb" title="Not a peer but async_connect() in progress to try to make it a peer.">State::S_CONNECTING</a> <a class="el" href="classipc_1_1transport_1_1sync__io_1_1Native__socket__stream_1_1Impl.html#a64e47a38b3ed59e37295336114918142" title="The current state of *this.">m_state</a>, this is the same socket, in the process of connecting. (If connect fails, the FD persists but goes back to just a steady-state "open" unconnected state.)</li>
<li>In <a class="el" href="classipc_1_1transport_1_1sync__io_1_1Native__socket__stream_1_1Impl.html#a9c9825f74472868eb1397c33edf78fb4ad9a05d721258c584cd559c56fd035887" title="Is or was a connected peer.">State::S_PEER</a> <a class="el" href="classipc_1_1transport_1_1sync__io_1_1Native__socket__stream_1_1Impl.html#a64e47a38b3ed59e37295336114918142" title="The current state of *this.">m_state</a>, this is either the same socket, now connected; or, upon a detected error in either direction, a null pointer.</li>
</ul>
<p >Moreover the FD cannot be replaced with another FD: if PEER-state ctor is used, then that FD is connected from the start; if NULL-state ctor is used, then that FD is unconnected but may become connected (if/when) <a class="el" href="classipc_1_1transport_1_1sync__io_1_1Native__socket__stream_1_1Impl.html#a9c9825f74472868eb1397c33edf78fb4ad9a05d721258c584cd559c56fd035887" title="Is or was a connected peer.">State::S_PEER</a> is reached (via <a class="el" href="classipc_1_1transport_1_1sync__io_1_1Native__socket__stream_1_1Impl.html#ad6443fb49be059dbe76c75d86a18197e" title="The core of sync_connect(), written in the sync_io-pattern style.">async_connect()</a>).</p>
<p ><code>*m_peer_socket</code> is used <em>exclusively</em> for non-blocking calls; <em>never</em> <code>.async_*()</code>. That conforms to the <code><a class="el" href="namespaceipc_1_1transport_1_1sync__io.html" title="sync_io-pattern counterparts to async-I/O-pattern object types in parent namespace ipc::transport.">sync_io</a></code> pattern. See <a class="el" href="classipc_1_1transport_1_1sync__io_1_1Native__socket__stream_1_1Impl.html#a1caa342f726a273deb64317cbec8b5ea" title="The Task_engine for m_peer_socket.">m_nb_task_engine</a> doc header.</p>
<h3>Rationale</h3>
<p >The above facts are important &ndash; namely that from the very start (up to an error) the FD is loaded and never changes &ndash; because the watcher FD-wrappers used in the <code><a class="el" href="namespaceipc_1_1transport_1_1sync__io.html" title="sync_io-pattern counterparts to async-I/O-pattern object types in parent namespace ipc::transport.">sync_io</a></code> pattern can be simply and correctly initialized at any time and not change thereafter ( in terms what FD they wrap).</p>
<p >As for the null-pointer state, it exists for 2 reasons which are somewhat in synergy:</p><ul>
<li>It is a way of giving back the FD-resource to the kernel as early as possible. (Destroying <code>Peer_socket</code> closes the contained FD/socket.)<ul>
<li>Update: Unfortunately another, more important consideration has obsoleted this reason. It no longer applies. See <a class="el" href="classipc_1_1transport_1_1sync__io_1_1Native__socket__stream_1_1Impl.html#a2a389318796d7386b114649a61c7d4f9" title="Null to start, this takes on the value from m_peer_socket when and only when m_peer_socket is nullifi...">m_peer_socket_hosed</a> for more (but it's not that interesting here).</li>
</ul>
</li>
<li>It is a way for the incoming-direction processing logic to inform the outgoing-direction counterpart logic that it has detected the socket is entirely hosed, in both directions (and hence no need to even try further operations on it); and vice versa.</li>
</ul>
<p >As to that 2nd reason: a couple of other approaches would work:</p><ul>
<li>We could simply let the 2nd-to-detect-failure processing direction discover the hosedness by naively trying an operation and getting the inevitable error from the kernel (probably the same one).<ul>
<li>This is actually a pretty good alternative approach; it might even be better: As written direction 2 will get a catch-all <code>S_LOW_LVL_TRANSPORT_HOSED_CANNOT_SEND</code> or <code>S_LOW_LVL_TRANSPORT_HOSED_CANNOT_RECEIVE</code> error; while with the alternative approach we could get the "real" error in both directions. There are benefits to each approach; the alternative one provides more info when looking at just one direction, while the existing one is quicker and less entropy-laden (arguably), returns the FD/socket resource sooner, and still makes the true error available. See to-do at the end of this doc header, as the alternative approach may carry another benefit.</li>
</ul>
</li>
<li>We could have incoming-direction logic check <a class="el" href="classipc_1_1transport_1_1sync__io_1_1Native__socket__stream_1_1Impl.html#a0257a7903bff120aa1523f8de04bccf7" title="The first and only connection-hosing error condition detected when attempting to low-level-write on m...">m_snd_pending_err_code</a>/outgoing-direction check <a class="el" href="classipc_1_1transport_1_1sync__io_1_1Native__socket__stream_1_1Impl.html#ab824da16816893b2ffe2e778a7169b62" title="The first and only connection-hosing error condition detected when attempting to low-level-read on m_...">m_rcv_pending_err_code</a> ahead of accessing <a class="el" href="classipc_1_1transport_1_1sync__io_1_1Native__socket__stream_1_1Impl.html#a42aab631e9c70bfaa53764309adfe37c" title="The peer stream-type Unix domain socket; or null pointer if we&#39;ve detected the connection has become ...">m_peer_socket</a>.<ul>
<li>This idea sucks. It breaks the intentional and important (for perf) guarantee under "Thread safety" in the <a class="el" href="classipc_1_1transport_1_1sync__io_1_1Native__socket__stream.html" title="Implements both sync_io::Native_handle_sender and sync_io::Native_handle_receiver concepts by using a...">sync_io::Native_socket_stream</a> doc header, wherein receive-ops logic and send-ops logic may execute concurrently (as now the latter accesses some of the former's data and vice versa).</li>
</ul>
</li>
</ul>
<h3>Concurrency, synchronization</h3>
<p >That brings us to the key discussion of concurrency protection: <a class="el" href="classipc_1_1transport_1_1sync__io_1_1Native__socket__stream_1_1Impl.html#a42aab631e9c70bfaa53764309adfe37c" title="The peer stream-type Unix domain socket; or null pointer if we&#39;ve detected the connection has become ...">m_peer_socket</a> is the <em>only</em> non-<code>const</code>-accessed datum in <code>*this</code> that may be accessed concurrently by receive-ops methods and send-ops methods. Namely: send-ops are started by <code>start_send_*_ops()</code>; receive-ops are started by <code>start_receive_*_ops()</code>; in PEER state all logic to do with sending can occur entirely concurrently with all logic to do with receiving. Except, however, they both use <a class="el" href="classipc_1_1transport_1_1sync__io_1_1Native__socket__stream_1_1Impl.html#a42aab631e9c70bfaa53764309adfe37c" title="The peer stream-type Unix domain socket; or null pointer if we&#39;ve detected the connection has become ...">m_peer_socket</a> &ndash; for <em>non-blocking calls only!</em> &ndash; as <a class="el" href="classipc_1_1transport_1_1sync__io_1_1Native__socket__stream_1_1Impl.html#a42aab631e9c70bfaa53764309adfe37c" title="The peer stream-type Unix domain socket; or null pointer if we&#39;ve detected the connection has become ...">m_peer_socket</a> is bidirectional. In particular, for example, <code>m_peer_socket-&gt;read_some()</code> might execute concurrently to <code>m_peer_socket-&gt;write_some()</code>. In addition, <a class="el" href="classipc_1_1transport_1_1sync__io_1_1Native__socket__stream_1_1Impl.html#a42aab631e9c70bfaa53764309adfe37c" title="The peer stream-type Unix domain socket; or null pointer if we&#39;ve detected the connection has become ...">m_peer_socket</a> pointer might be nullified (due to error) by one direction's logic, while the other is trying to dereference it and execute a method.</p>
<p >This is resolved by our locking <a class="el" href="classipc_1_1transport_1_1sync__io_1_1Native__socket__stream_1_1Impl.html#abc7d2b14208ed2b8c0add0c26f7fbf27" title="Protects m_peer_socket and its bros m_ev_wait_hndl_peer_socket and m_peer_socket_hosed.">m_peer_socket_mutex</a>, albeit in a very tight critical section that always looks like:</p><ol type="1">
<li>Lock mutex.</li>
<li>Check if it's null; if so unlock/exit algorithm. Else:</li>
<li>Attempt synchronous, non-blocking operation on dereferenced pointer.</li>
<li>If it exposed socket error, nullify pointer.</li>
<li>Unlock mutex.</li>
</ol>
<p >It's tight, so lock contention should be minimal. Also no other mutex is locked inside such a critical section, so deadlock chance is nil. However see the following to-do for an alternative approach.</p>
<dl class="todo"><dt><b><a class="el" href="todo.html#_todo000016">Todo:</a></b></dt><dd><code>Peer_socket m_peer_socket</code> synchronous-read ops (<code>read_some()</code>) are actually documented in boost::asio to be thread-safe against concurrently invoked synchronous-write ops (<code>write_some()</code>), as are OS calls <code>"::recvmsg()"</code>, <code>"::sendmsg()"</code>; therefore for possible perf bump consider never nullifying <a class="el" href="classipc_1_1transport_1_1sync__io_1_1Native__socket__stream_1_1Impl.html#a42aab631e9c70bfaa53764309adfe37c" title="The peer stream-type Unix domain socket; or null pointer if we&#39;ve detected the connection has become ...">Impl::m_peer_socket</a>; eliminating <a class="el" href="classipc_1_1transport_1_1sync__io_1_1Native__socket__stream_1_1Impl.html#abc7d2b14208ed2b8c0add0c26f7fbf27" title="Protects m_peer_socket and its bros m_ev_wait_hndl_peer_socket and m_peer_socket_hosed.">Impl::m_peer_socket_mutex</a>; and letting each direction's logic discover any socket-error independently. (But, at the moment, <code>m_peer_socket_mutex</code> also covers mirror-guy <a class="el" href="classipc_1_1transport_1_1sync__io_1_1Native__socket__stream_1_1Impl.html#a0ac6a82eda9256cba45f3b5365d79355" title="Descriptor waitable by outside event loop async-waits â€“ storing the same Native_handle as (and thus b...">m_ev_wait_hndl_peer_socket</a>, so that must be worked out.)</dd></dl>
<p >To be clear, the text above w/r/t concurrency/synchronization says <code>-&gt;write_some()</code> and <code>-&gt;read_some()</code> might execute concurrently &ndash; but boost.asio docs (<code>basic_stream_socket</code> page) indicate that is actually okay; and implies the same about underlying OS calls (which includes <code>readmsg()</code> and <code>writemsg()</code> which we use when <code>Native_handle</code> transmission is needed). Now, the nullification versus dereferencing of the <code>unique_ptr</code> wrapping <code>m_peer_socket</code>: that is indeed not thread-safe, which is why we'd need to also get rid of that method of communicating socket-hosed state from one direction to the other. However, as we wrote above, the alternate approach, where each direction discovers the socket error independently, would be compatible with <code>m_peer_socket</code> not needing to be a <code>unique_ptr</code> at all. That said the socket would not be given back to the system as early (potentially) &ndash; note that boost.asio <code>close()</code> is noted to not be safe against concurrent reads/writes &ndash; and in general the approach "feels" more entropy-laden. I (ygoldfel) must say, though; it does sound entirely viable nevertheless; and it would be a limited change that would also eliminate <a class="el" href="namespaceipc_1_1transport_1_1error.html#adfef15ef4e76cc55d652fbd9c2797297adc5d7b9dbaa8c76c6835e3c9a7942410" title="Unable to send outgoing traffic: an earlier-reported, or at least logged, system error had hosed the ...">error::Code::S_LOW_LVL_TRANSPORT_HOSED_CANNOT_SEND</a> and <a class="el" href="namespaceipc_1_1transport_1_1error.html#adfef15ef4e76cc55d652fbd9c2797297a1fba28e335d4189cbb25f382582efcc1" title="Unable to receive incoming traffic: an earlier-reported, or at least logged, system error had hosed t...">error::Code::S_LOW_LVL_TRANSPORT_HOSED_CANNOT_RECEIVE</a>. One could even argue it is elegant, in that it decouples the 2 directions as much as humanly possible, to the point of even using the kernel's support for it. (Last note: the boost.asio docs single out <code>connect()</code>, <code>shutdown()</code>, <code>send()</code>, <code>receive()</code> as okay to invoke concurrently; not <code>read_some()</code> and <code>write_some()</code>; but I very strongly suspect this is only an omission, perhaps due to <code>*_some()</code> appearing for uniformity in a boost.asio overhaul after those docs were written; in the source it is clear they invoke the same exact stuff. Googling shows, generally, the underlying OS calls including <code>*msg()</code> are thread-safe to use in this manner also.) </p>

<p class="definition">Definition at line <a class="el" href="sync__io_2detail_2native__socket__stream__impl_8hpp_source.html#l01299">1299</a> of file <a class="el" href="sync__io_2detail_2native__socket__stream__impl_8hpp_source.html">native_socket_stream_impl.hpp</a>.</p>

<p class="reference">Referenced by <a class="el" href="sync__io_2detail_2native__socket__stream__impl_8cpp_source.html#l00069">Impl()</a>.</p>

</div>
</div>
<a id="a2a389318796d7386b114649a61c7d4f9" name="a2a389318796d7386b114649a61c7d4f9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2a389318796d7386b114649a61c7d4f9">&#9670;&nbsp;</a></span>m_peer_socket_hosed</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">boost::movelib::unique_ptr&lt;<a class="el" href="namespaceipc_1_1transport_1_1asio__local__stream__socket.html#a1788f9dbd896bb71b3693f9ae25b40ae">asio_local_stream_socket::Peer_socket</a>&gt; ipc::transport::sync_io::Native_socket_stream::Impl::m_peer_socket_hosed</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Null to start, this takes on the value from <a class="el" href="classipc_1_1transport_1_1sync__io_1_1Native__socket__stream_1_1Impl.html#a42aab631e9c70bfaa53764309adfe37c" title="The peer stream-type Unix domain socket; or null pointer if we&#39;ve detected the connection has become ...">m_peer_socket</a> when and only when <a class="el" href="classipc_1_1transport_1_1sync__io_1_1Native__socket__stream_1_1Impl.html#a42aab631e9c70bfaa53764309adfe37c" title="The peer stream-type Unix domain socket; or null pointer if we&#39;ve detected the connection has become ...">m_peer_socket</a> is nullified (which occurs when and only when an error is detected on it). </p>
<p >Protected (along with <a class="el" href="classipc_1_1transport_1_1sync__io_1_1Native__socket__stream_1_1Impl.html#a42aab631e9c70bfaa53764309adfe37c" title="The peer stream-type Unix domain socket; or null pointer if we&#39;ve detected the connection has become ...">m_peer_socket</a>) by <a class="el" href="classipc_1_1transport_1_1sync__io_1_1Native__socket__stream_1_1Impl.html#abc7d2b14208ed2b8c0add0c26f7fbf27" title="Protects m_peer_socket and its bros m_ev_wait_hndl_peer_socket and m_peer_socket_hosed.">m_peer_socket_mutex</a>.</p>
<p >So, at steady state, either <a class="el" href="classipc_1_1transport_1_1sync__io_1_1Native__socket__stream_1_1Impl.html#a42aab631e9c70bfaa53764309adfe37c" title="The peer stream-type Unix domain socket; or null pointer if we&#39;ve detected the connection has become ...">m_peer_socket</a> is null, or <a class="el" href="classipc_1_1transport_1_1sync__io_1_1Native__socket__stream_1_1Impl.html#a2a389318796d7386b114649a61c7d4f9" title="Null to start, this takes on the value from m_peer_socket when and only when m_peer_socket is nullifi...">m_peer_socket_hosed</a> is null, but never both null or both non-null.</p><ul>
<li><code>m_peer_socket</code> begins as non-null, <code>m_peer_socket_hosed</code> null.</li>
<li><code>m_peer_socket_hosed = std::move(m_peer_socket</code> may execute (or never execute), swapping them.</li>
<li>In destructor, the non-null one gets destroyed; which internally closes the contained native-socket (FD).</li>
</ul>
<h3>Rationale</h3>
<p >Why do this? Why not simply nullify <code>m_peer_socket</code>, both to mark it (as explained in its doc header) for algorithmic purposes and to return the FD resource to the OS? The answer is subtle but very real: Suppose an error is detected on the socket, and we simply destroy it &ndash; thus closing the native socket. In most cases this is okay; the user code will be informed of the error and not do further work on the socket. What work does it do with it anyway? Answer: it is allowed to, at most, "watch" it: await readability and/or writability, so as to report it to <code>*this</code> as part of the <code><a class="el" href="namespaceipc_1_1transport_1_1sync__io.html" title="sync_io-pattern counterparts to async-I/O-pattern object types in parent namespace ipc::transport.">sync_io</a></code> pattern. Once <code>*this</code> is hosed, there's no need to watch it, right? Right... so consider they might be using a native mechanism, most notably Linux's <code>epoll_ctl()</code> and <code>epoll_wait()</code>, to do so. With such a stateful mechanism the right thing to do would be to unregister the now-worthless native-socket-handle on which they might currently be registered to detect active events (as asked by us via <code><a class="el" href="namespaceipc_1_1transport_1_1sync__io.html" title="sync_io-pattern counterparts to async-I/O-pattern object types in parent namespace ipc::transport.">sync_io</a></code> pattern). So with <code>epoll</code> they'd do perhaps <code>epoll_ctl(EPOLL_CTL_DEL)</code> to remove the FD from an epoll-set FD... but we just closed (<code>"::close()"</code>) it! That's bad. (In reality &ndash; subtleties/details omitted &ndash; we might be able to get away without catastrophic events... but at absolute best, this is entropy-laden and ugly and really just merely fortunate.)</p>
<p >In short, we should not invalidate a native-handle that we may have asked the <code>*this</code> user to be watching for activity, until we are sure they are no longer doing that. We can only be sure of that &ndash; particularly in light of the potential desire to unregister it from watch-set(s) &ndash; once our dtor begins execution, at which point they're contractually obligated to not touch the native-handle any longer.</p>
<p >Okay... in that case... why not simply <em>not</em> nullify <a class="el" href="classipc_1_1transport_1_1sync__io_1_1Native__socket__stream_1_1Impl.html#a42aab631e9c70bfaa53764309adfe37c" title="The peer stream-type Unix domain socket; or null pointer if we&#39;ve detected the connection has become ...">m_peer_socket</a> but use some other marker (a separate flag, <code>bool m_peer_socket_hosed</code> maybe)? Answer: Sure, we could. It's not necessarily better or worse. In truth it's arguably a historic artifact of how the code was written before considering the aforementioned problematic scenario. That said, the present approach is reasonably elegant. If <a class="el" href="classipc_1_1transport_1_1sync__io_1_1Native__socket__stream_1_1Impl.html#a42aab631e9c70bfaa53764309adfe37c" title="The peer stream-type Unix domain socket; or null pointer if we&#39;ve detected the connection has become ...">m_peer_socket</a> is null, there's no temptation to try to do something with it, and for all practical intents and purposes no more work is possible on <a class="el" href="classipc_1_1transport_1_1sync__io_1_1Native__socket__stream_1_1Impl.html#a42aab631e9c70bfaa53764309adfe37c" title="The peer stream-type Unix domain socket; or null pointer if we&#39;ve detected the connection has become ...">m_peer_socket</a>, once an error is detected. So it's nice to nullify it. Then this <code>m_peer_socket_hosed</code> just lives in peace, on death row, until it is safe to really close (in dtor). </p>

<p class="definition">Definition at line <a class="el" href="sync__io_2detail_2native__socket__stream__impl_8hpp_source.html#l01340">1340</a> of file <a class="el" href="sync__io_2detail_2native__socket__stream__impl_8hpp_source.html">native_socket_stream_impl.hpp</a>.</p>

</div>
</div>
<a id="abc7d2b14208ed2b8c0add0c26f7fbf27" name="abc7d2b14208ed2b8c0add0c26f7fbf27"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abc7d2b14208ed2b8c0add0c26f7fbf27">&#9670;&nbsp;</a></span>m_peer_socket_mutex</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">flow::util::Mutex_non_recursive ipc::transport::sync_io::Native_socket_stream::Impl::m_peer_socket_mutex</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Protects <a class="el" href="classipc_1_1transport_1_1sync__io_1_1Native__socket__stream_1_1Impl.html#a42aab631e9c70bfaa53764309adfe37c" title="The peer stream-type Unix domain socket; or null pointer if we&#39;ve detected the connection has become ...">m_peer_socket</a> and its bros <a class="el" href="classipc_1_1transport_1_1sync__io_1_1Native__socket__stream_1_1Impl.html#a0ac6a82eda9256cba45f3b5365d79355" title="Descriptor waitable by outside event loop async-waits â€“ storing the same Native_handle as (and thus b...">m_ev_wait_hndl_peer_socket</a> and <a class="el" href="classipc_1_1transport_1_1sync__io_1_1Native__socket__stream_1_1Impl.html#a2a389318796d7386b114649a61c7d4f9" title="Null to start, this takes on the value from m_peer_socket when and only when m_peer_socket is nullifi...">m_peer_socket_hosed</a>. </p>

<p class="definition">Definition at line <a class="el" href="sync__io_2detail_2native__socket__stream__impl_8hpp_source.html#l01358">1358</a> of file <a class="el" href="sync__io_2detail_2native__socket__stream__impl_8hpp_source.html">native_socket_stream_impl.hpp</a>.</p>

</div>
</div>
<a id="a393316703a666a9b022f2b879337b920" name="a393316703a666a9b022f2b879337b920"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a393316703a666a9b022f2b879337b920">&#9670;&nbsp;</a></span>m_protocol_negotiator</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classipc_1_1transport_1_1Protocol__negotiator.html">Protocol_negotiator</a> ipc::transport::sync_io::Native_socket_stream::Impl::m_protocol_negotiator</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Handles the protocol negotiation at the start of the pipe. </p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classipc_1_1transport_1_1Protocol__negotiator.html" title="A simple state machine that, assuming the opposide side of a comm pathway uses an equivalent state ma...">Protocol_negotiator</a> doc header for key background on the topic. In particular check out the discussion "Key tip: Coding for version-1 versus one version versus multiple versions."</dd></dl>
<h3>Maintenace/future</h3>
<p >See doc header for <a class="el" href="classipc_1_1transport_1_1sync__io_1_1Blob__stream__mq__sender__impl.html" title="Internal, non-movable pImpl-lite implementation of sync_io::Blob_stream_mq_sender class template.">sync_io::Blob_stream_mq_sender_impl</a>. Similar logic applies here. The only thing that does not apply, and is arguably simpler in our case, is that we <em>are</em> a bidirectional comm pathway; there is no such thing as being a sender end without a corresponding receiver end. So the stuff about needing an API for telling us what protocol version to speak of multiple possibilities (in the hypothetical future in which we'd support such a thing).</p>
<p >To restate: These are decisions and work for another day, though; it is not relevant until version 2 of this protocol at the earliest. That might not even happen.</p>
<h3>Thread safety</h3>
<p >Firstly this it only touched in PEER state (and one cannot exit PEER state). Once in PEER state: First take a look at "Thread safety" in <a class="el" href="classipc_1_1transport_1_1sync__io_1_1Native__socket__stream.html" title="Implements both sync_io::Native_handle_sender and sync_io::Native_handle_receiver concepts by using a...">sync_io::Native_socket_stream</a> class public doc header. Long story short, it says that the only relevant concurrency we must allow is a receive-op being invoked concurrently with a send-op while in PEER state. Happily, <a class="el" href="classipc_1_1transport_1_1Protocol__negotiator.html" title="A simple state machine that, assuming the opposide side of a comm pathway uses an equivalent state ma...">Protocol_negotiator</a> doc header specifically allows the outgoing-direction APIs to be invoked concurrently with incoming-direction APIs. Therefore no locking is needed. </p>

<p class="definition">Definition at line <a class="el" href="sync__io_2detail_2native__socket__stream__impl_8hpp_source.html#l01171">1171</a> of file <a class="el" href="sync__io_2detail_2native__socket__stream__impl_8hpp_source.html">native_socket_stream_impl.hpp</a>.</p>

<p class="reference">Referenced by <a class="el" href="native__socket__stream__impl__snd_8cpp_source.html#l00028">start_send_native_handle_ops()</a>.</p>

</div>
</div>
<a id="a5e1051f460cddb73d3cbc48afbac18a9" name="a5e1051f460cddb73d3cbc48afbac18a9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5e1051f460cddb73d3cbc48afbac18a9">&#9670;&nbsp;</a></span>m_rcv_ev_wait_func</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespaceipc_1_1util_1_1sync__io.html#aa0b9a3cc6bdc7dedbef4f9e06851aa24">util::sync_io::Event_wait_func</a> ipc::transport::sync_io::Native_socket_stream::Impl::m_rcv_ev_wait_func</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Function (set forever in <code>start_receive_*_ops()</code>) through which we invoke the outside event loop's async-wait facility for descriptors/events relevant to receive-ops. </p>
<p >See <a class="el" href="namespaceipc_1_1util_1_1sync__io.html#aa0b9a3cc6bdc7dedbef4f9e06851aa24" title="In sync_io pattern, concrete type storing user-supplied function invoked by pattern-implementing ipc:...">util::sync_io::Event_wait_func</a> doc header for a refresher on this mechanic. </p>

<p class="definition">Definition at line <a class="el" href="sync__io_2detail_2native__socket__stream__impl_8hpp_source.html#l01589">1589</a> of file <a class="el" href="sync__io_2detail_2native__socket__stream__impl_8hpp_source.html">native_socket_stream_impl.hpp</a>.</p>

<p class="reference">Referenced by <a class="el" href="sync__io_2detail_2native__socket__stream__impl_8hpp_source.html#l01595">sync_io_ev_wait_func()</a>.</p>

</div>
</div>
<a id="a3540ba657d9d7c95e755d1b348c88b8f" name="a3540ba657d9d7c95e755d1b348c88b8f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3540ba657d9d7c95e755d1b348c88b8f">&#9670;&nbsp;</a></span>m_rcv_ev_wait_hndl_idle_timer_fired_peer</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classipc_1_1util_1_1sync__io_1_1Asio__waitable__native__handle.html">util::sync_io::Asio_waitable_native_handle</a> ipc::transport::sync_io::Native_socket_stream::Impl::m_rcv_ev_wait_hndl_idle_timer_fired_peer</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Descriptor waitable by outside event loop async-waits &ndash; storing the same <code>Native_handle</code> as (and thus being used to wait on events from) <a class="el" href="classipc_1_1transport_1_1sync__io_1_1Native__socket__stream_1_1Impl.html#aa94400dd47704098beffe37b07b75472" title="Read-end of IPC-mechanism used by m_timer_worker to ferry timer-fired events from m_rcv_idle_timer to...">m_rcv_idle_timer_fired_peer</a>. </p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classipc_1_1transport_1_1sync__io_1_1Native__socket__stream_1_1Impl.html#a54c3fdde2cf99fda314ee3387f70a02e" title="As typical in timer-needing sync_io-pattern-implementing objects, maintains a thread exclusively for ...">m_timer_worker</a> for more info. </dd></dl>

<p class="definition">Definition at line <a class="el" href="sync__io_2detail_2native__socket__stream__impl_8hpp_source.html#l01582">1582</a> of file <a class="el" href="sync__io_2detail_2native__socket__stream__impl_8hpp_source.html">native_socket_stream_impl.hpp</a>.</p>

</div>
</div>
<a id="ada7f2368dc0591f7a903946201c83636" name="ada7f2368dc0591f7a903946201c83636"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ada7f2368dc0591f7a903946201c83636">&#9670;&nbsp;</a></span>m_rcv_idle_timeout</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespaceipc_1_1util.html#ac66141280c3b7295a86b65209f31cc58">util::Fine_duration</a> ipc::transport::sync_io::Native_socket_stream::Impl::m_rcv_idle_timeout</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><code>timeout</code> from <a class="el" href="classipc_1_1transport_1_1sync__io_1_1Native__socket__stream_1_1Impl.html#abedd0db5a5ae04e47085728ae548d07c" title="See Native_socket_stream counterpart.">idle_timer_run()</a> args; or <code>zero()</code> if not yet called. </p>
<p ><a class="el" href="classipc_1_1transport_1_1sync__io_1_1Native__socket__stream_1_1Impl.html#ab65c4574a9a084030a9a66a8340c94b2" title="Timer that fires rcv_on_ev_idle_timer_fired() (which hoses the in-pipe with idle timeour error) and i...">m_rcv_idle_timer</a> stays inactive until this becomes not-<code>zero()</code>.</p>
<p >Relevant only once terminal <a class="el" href="classipc_1_1transport_1_1sync__io_1_1Native__socket__stream_1_1Impl.html#a9c9825f74472868eb1397c33edf78fb4ad9a05d721258c584cd559c56fd035887" title="Is or was a connected peer.">State::S_PEER</a> is reached. </p>

<p class="definition">Definition at line <a class="el" href="sync__io_2detail_2native__socket__stream__impl_8hpp_source.html#l01552">1552</a> of file <a class="el" href="sync__io_2detail_2native__socket__stream__impl_8hpp_source.html">native_socket_stream_impl.hpp</a>.</p>

</div>
</div>
<a id="ab65c4574a9a084030a9a66a8340c94b2" name="ab65c4574a9a084030a9a66a8340c94b2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab65c4574a9a084030a9a66a8340c94b2">&#9670;&nbsp;</a></span>m_rcv_idle_timer</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">flow::util::Timer ipc::transport::sync_io::Native_socket_stream::Impl::m_rcv_idle_timer</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Timer that fires <a class="el" href="classipc_1_1transport_1_1sync__io_1_1Native__socket__stream_1_1Impl.html#a53b356e756923271fbb9b7a7beb8f54a" title="Handler for the async-wait, via util::sync_io::Timer_event_emitter, of the idle timer firing; if stil...">rcv_on_ev_idle_timer_fired()</a> (which hoses the in-pipe with idle timeour error) and is (re)scheduled to fire in <a class="el" href="classipc_1_1transport_1_1sync__io_1_1Native__socket__stream_1_1Impl.html#ada7f2368dc0591f7a903946201c83636" title="timeout from idle_timer_run() args; or zero() if not yet called.">m_rcv_idle_timeout</a> each time <code>*this</code> receives a complete message on <a class="el" href="classipc_1_1transport_1_1sync__io_1_1Native__socket__stream_1_1Impl.html#a42aab631e9c70bfaa53764309adfe37c" title="The peer stream-type Unix domain socket; or null pointer if we&#39;ve detected the connection has become ...">m_peer_socket</a>. </p>
<p >If it does fire, without being preempted by some error to have occurred since then, the in-pipe is hosed with a particular error indicating idle-timeout (so that <code>Error_code</code> is saved to <a class="el" href="classipc_1_1transport_1_1sync__io_1_1Native__socket__stream_1_1Impl.html#ab824da16816893b2ffe2e778a7169b62" title="The first and only connection-hosing error condition detected when attempting to low-level-read on m_...">m_rcv_pending_err_code</a>), while the out-pipe continues (<a class="el" href="classipc_1_1transport_1_1sync__io_1_1Native__socket__stream_1_1Impl.html#a42aab631e9c70bfaa53764309adfe37c" title="The peer stream-type Unix domain socket; or null pointer if we&#39;ve detected the connection has become ...">m_peer_socket</a> lives).</p>
<p >Since we implement <code><a class="el" href="namespaceipc_1_1transport_1_1sync__io.html" title="sync_io-pattern counterparts to async-I/O-pattern object types in parent namespace ipc::transport.">sync_io</a></code> pattern, the timer is obtained from, and used via, <a class="el" href="classipc_1_1util_1_1sync__io_1_1Timer__event__emitter.html" title="An object of this type, used internally to implement sync_io-pattern objects that require timer event...">util::sync_io::Timer_event_emitter</a> <a class="el" href="classipc_1_1transport_1_1sync__io_1_1Native__socket__stream_1_1Impl.html#a54c3fdde2cf99fda314ee3387f70a02e" title="As typical in timer-needing sync_io-pattern-implementing objects, maintains a thread exclusively for ...">m_timer_worker</a>. See that member's doc header for more info.</p>
<p >Relevant only once terminal <a class="el" href="classipc_1_1transport_1_1sync__io_1_1Native__socket__stream_1_1Impl.html#a9c9825f74472868eb1397c33edf78fb4ad9a05d721258c584cd559c56fd035887" title="Is or was a connected peer.">State::S_PEER</a> is reached. </p>

<p class="definition">Definition at line <a class="el" href="sync__io_2detail_2native__socket__stream__impl_8hpp_source.html#l01566">1566</a> of file <a class="el" href="sync__io_2detail_2native__socket__stream__impl_8hpp_source.html">native_socket_stream_impl.hpp</a>.</p>

</div>
</div>
<a id="aa94400dd47704098beffe37b07b75472" name="aa94400dd47704098beffe37b07b75472"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa94400dd47704098beffe37b07b75472">&#9670;&nbsp;</a></span>m_rcv_idle_timer_fired_peer</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classipc_1_1util_1_1sync__io_1_1Timer__event__emitter.html#a1533a54927a64579fda02c61ec94b735">util::sync_io::Timer_event_emitter::Timer_fired_read_end</a>* ipc::transport::sync_io::Native_socket_stream::Impl::m_rcv_idle_timer_fired_peer</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Read-end of IPC-mechanism used by <a class="el" href="classipc_1_1transport_1_1sync__io_1_1Native__socket__stream_1_1Impl.html#a54c3fdde2cf99fda314ee3387f70a02e" title="As typical in timer-needing sync_io-pattern-implementing objects, maintains a thread exclusively for ...">m_timer_worker</a> to ferry timer-fired events from <a class="el" href="classipc_1_1transport_1_1sync__io_1_1Native__socket__stream_1_1Impl.html#ab65c4574a9a084030a9a66a8340c94b2" title="Timer that fires rcv_on_ev_idle_timer_fired() (which hoses the in-pipe with idle timeour error) and i...">m_rcv_idle_timer</a> to <code><a class="el" href="namespaceipc_1_1transport_1_1sync__io.html" title="sync_io-pattern counterparts to async-I/O-pattern object types in parent namespace ipc::transport.">sync_io</a></code> outside async-wait to our actual on-timer-fired handler logic. </p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classipc_1_1transport_1_1sync__io_1_1Native__socket__stream_1_1Impl.html#a54c3fdde2cf99fda314ee3387f70a02e" title="As typical in timer-needing sync_io-pattern-implementing objects, maintains a thread exclusively for ...">m_timer_worker</a> for more info. </dd></dl>

<p class="definition">Definition at line <a class="el" href="sync__io_2detail_2native__socket__stream__impl_8hpp_source.html#l01574">1574</a> of file <a class="el" href="sync__io_2detail_2native__socket__stream__impl_8hpp_source.html">native_socket_stream_impl.hpp</a>.</p>

</div>
</div>
<a id="ab824da16816893b2ffe2e778a7169b62" name="ab824da16816893b2ffe2e778a7169b62"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab824da16816893b2ffe2e778a7169b62">&#9670;&nbsp;</a></span>m_rcv_pending_err_code</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespaceipc.html#aa3192e586cc45d3e7c22463bf2760f89">Error_code</a> ipc::transport::sync_io::Native_socket_stream::Impl::m_rcv_pending_err_code</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>The first and only connection-hosing error condition detected when attempting to low-level-read on <a class="el" href="classipc_1_1transport_1_1sync__io_1_1Native__socket__stream_1_1Impl.html#a42aab631e9c70bfaa53764309adfe37c" title="The peer stream-type Unix domain socket; or null pointer if we&#39;ve detected the connection has become ...">m_peer_socket</a>; or falsy if no such error has yet been detected. </p>
<p >Among possible other uses, it is emitted to the ongoing-at-the-time <code>async_receive_*()</code>'s completion handler (if one is indeed outstanding) and immediately to any subsequent <code>async_receive_*()</code>.</p>
<p >Relevant only once terminal <a class="el" href="classipc_1_1transport_1_1sync__io_1_1Native__socket__stream_1_1Impl.html#a9c9825f74472868eb1397c33edf78fb4ad9a05d721258c584cd559c56fd035887" title="Is or was a connected peer.">State::S_PEER</a> is reached. </p>

<p class="definition">Definition at line <a class="el" href="sync__io_2detail_2native__socket__stream__impl_8hpp_source.html#l01544">1544</a> of file <a class="el" href="sync__io_2detail_2native__socket__stream__impl_8hpp_source.html">native_socket_stream_impl.hpp</a>.</p>

</div>
</div>
<a id="a6676379057415274d2c6f2f096828cf9" name="a6676379057415274d2c6f2f096828cf9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6676379057415274d2c6f2f096828cf9">&#9670;&nbsp;</a></span>m_rcv_target_meta_length</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classipc_1_1transport_1_1sync__io_1_1Native__socket__stream_1_1Impl.html#a881c376f1ee37f9b1a20f770824f55d9">low_lvl_payload_blob_length_t</a> ipc::transport::sync_io::Native_socket_stream::Impl::m_rcv_target_meta_length</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Direct-write target, storing the length in bytes of the next meta-blob; 0 meaning the current user message contains no meta-blob but only a native handle (or represents graceful-close if that is also not present); and 0xFF... (<a class="el" href="classipc_1_1transport_1_1sync__io_1_1Native__socket__stream_1_1Impl.html#ad5e487595e2a58f7ff25b4f4c91fe4bc" title="Value for the length field in payload 1 that means &quot;not a length; indicating this is a ping message....">S_META_BLOB_LENGTH_PING_SENTINEL</a>) meaning it's a mere ping. </p>
<p >This plus a <code>Native_handle</code> is payload 1 received for each message; if, after successful read, this is neither 0 nor <a class="el" href="classipc_1_1transport_1_1sync__io_1_1Native__socket__stream_1_1Impl.html#ad5e487595e2a58f7ff25b4f4c91fe4bc" title="Value for the length field in payload 1 that means &quot;not a length; indicating this is a ping message....">S_META_BLOB_LENGTH_PING_SENTINEL</a>, then payload 2 &ndash; the non-zero-sized meta-blob &ndash; is also read directly into the location specified by <code>m_rcv_user_request-&gt;m_target_meta_blob</code>.</p>
<p >Relevant only once terminal <a class="el" href="classipc_1_1transport_1_1sync__io_1_1Native__socket__stream_1_1Impl.html#a9c9825f74472868eb1397c33edf78fb4ad9a05d721258c584cd559c56fd035887" title="Is or was a connected peer.">State::S_PEER</a> is reached. </p>

<p class="definition">Definition at line <a class="el" href="sync__io_2detail_2native__socket__stream__impl_8hpp_source.html#l01534">1534</a> of file <a class="el" href="sync__io_2detail_2native__socket__stream__impl_8hpp_source.html">native_socket_stream_impl.hpp</a>.</p>

</div>
</div>
<a id="a9098de978da64572c419019597274d68" name="a9098de978da64572c419019597274d68"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9098de978da64572c419019597274d68">&#9670;&nbsp;</a></span>m_rcv_user_request</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::optional&lt;<a class="el" href="structipc_1_1transport_1_1sync__io_1_1Native__socket__stream_1_1Impl_1_1Rcv__user__request.html">Rcv_user_request</a>&gt; ipc::transport::sync_io::Native_socket_stream::Impl::m_rcv_user_request</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Null if no <code>async_receive_*()</code> is currently pending; else describes the arguments to that pending <code>async_receive_*()</code>. </p>
<p >Relevant only once terminal <a class="el" href="classipc_1_1transport_1_1sync__io_1_1Native__socket__stream_1_1Impl.html#a9c9825f74472868eb1397c33edf78fb4ad9a05d721258c584cd559c56fd035887" title="Is or was a connected peer.">State::S_PEER</a> is reached.</p>
<h3>Rationale</h3>
<p >It exists for a hopefully obvious reasons: At least a non-immediately-completed <code>async_receive_*()</code> needs to keep track of the request so as to know where to place results and what completion handler to invoke.</p>
<p >As for it being nullable: this is used to guard against <code>async_receive_*()</code> being invoked while another is already outstanding. We do not queue pending requests per <a class="el" href="classipc_1_1transport_1_1sync__io_1_1Blob__receiver.html" title="A documentation-only concept: what transport::Blob_receiver is to transport::Native_handle_receiver (...">sync_io::Blob_receiver</a> / <a class="el" href="classipc_1_1transport_1_1sync__io_1_1Native__handle__receiver.html" title="A documentation-only concept defining the behavior of an object that is the sync_io-pattern counterpa...">sync_io::Native_handle_receiver</a> concept. (However the non-<code><a class="el" href="namespaceipc_1_1transport_1_1sync__io.html" title="sync_io-pattern counterparts to async-I/O-pattern object types in parent namespace ipc::transport.">sync_io</a></code> a/k/a async-I/O <a class="el" href="classipc_1_1transport_1_1sync__io_1_1Blob__receiver.html" title="A documentation-only concept: what transport::Blob_receiver is to transport::Native_handle_receiver (...">Blob_receiver</a> + <a class="el" href="classipc_1_1transport_1_1sync__io_1_1Native__handle__receiver.html" title="A documentation-only concept defining the behavior of an object that is the sync_io-pattern counterpa...">Native_handle_receiver</a> <a class="el" href="classipc_1_1transport_1_1Native__socket__stream.html" title="Implements both Native_handle_sender and Native_handle_receiver concepts by using a stream-oriented U...">transport::Native_socket_stream</a> does. Therefore the latter class does internally implement a <code>User_request</code> queue. Rather <a class="el" href="classipc_1_1transport_1_1sync__io_1_1Async__adapter__receiver.html" title="Internal-use type that adapts a given PEER-state sync_io::Native_handle_receiver or sync_io::Blob_rec...">sync_io::Async_adapter_receiver</a> does.) </p>

<p class="definition">Definition at line <a class="el" href="sync__io_2detail_2native__socket__stream__impl_8hpp_source.html#l01521">1521</a> of file <a class="el" href="sync__io_2detail_2native__socket__stream__impl_8hpp_source.html">native_socket_stream_impl.hpp</a>.</p>

</div>
</div>
<a id="a4cb5d8ce6fa402c2cbaf27ec9654277c" name="a4cb5d8ce6fa402c2cbaf27ec9654277c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4cb5d8ce6fa402c2cbaf27ec9654277c">&#9670;&nbsp;</a></span>m_snd_auto_ping_period</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespaceipc_1_1util.html#ac66141280c3b7295a86b65209f31cc58">util::Fine_duration</a> ipc::transport::sync_io::Native_socket_stream::Impl::m_snd_auto_ping_period</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Equals <code>zero()</code> before <a class="el" href="classipc_1_1transport_1_1sync__io_1_1Native__socket__stream_1_1Impl.html#ab7b382067804495cbae180a5bc1a2757" title="See Native_socket_stream counterpart.">auto_ping()</a>; immutably equals <code>period</code> (<a class="el" href="classipc_1_1transport_1_1sync__io_1_1Native__socket__stream_1_1Impl.html#ab7b382067804495cbae180a5bc1a2757" title="See Native_socket_stream counterpart.">auto_ping()</a> arg) subsequently to that first successful call (if any). </p>
<p >Relevant only once terminal <a class="el" href="classipc_1_1transport_1_1sync__io_1_1Native__socket__stream_1_1Impl.html#a9c9825f74472868eb1397c33edf78fb4ad9a05d721258c584cd559c56fd035887" title="Is or was a connected peer.">State::S_PEER</a> is reached. </p>

<p class="definition">Definition at line <a class="el" href="sync__io_2detail_2native__socket__stream__impl_8hpp_source.html#l01462">1462</a> of file <a class="el" href="sync__io_2detail_2native__socket__stream__impl_8hpp_source.html">native_socket_stream_impl.hpp</a>.</p>

</div>
</div>
<a id="a311a0641a1da83530311e16845105c2c" name="a311a0641a1da83530311e16845105c2c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a311a0641a1da83530311e16845105c2c">&#9670;&nbsp;</a></span>m_snd_auto_ping_timer</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">flow::util::Timer ipc::transport::sync_io::Native_socket_stream::Impl::m_snd_auto_ping_timer</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Timer that fires <a class="el" href="classipc_1_1transport_1_1sync__io_1_1Native__socket__stream_1_1Impl.html#a4b31da3a7ff63f307bd08e288c391556" title="Handler for the async-wait, via util::sync_io::Timer_event_emitter, of the auto-ping timer firing; if...">snd_on_ev_auto_ping_now_timer_fired()</a> (which sends an auto-ping) and is always scheduled to fire <a class="el" href="classipc_1_1transport_1_1sync__io_1_1Native__socket__stream_1_1Impl.html#a4cb5d8ce6fa402c2cbaf27ec9654277c" title="Equals zero() before auto_ping(); immutably equals period (auto_ping() arg) subsequently to that firs...">m_snd_auto_ping_period</a> after the last send (<a class="el" href="classipc_1_1transport_1_1sync__io_1_1Native__socket__stream_1_1Impl.html#a59e9935bdd704c40173a40e87b5db131" title="See Native_socket_stream counterpart.">send_native_handle()</a>, <a class="el" href="classipc_1_1transport_1_1sync__io_1_1Native__socket__stream_1_1Impl.html#ab7b382067804495cbae180a5bc1a2757" title="See Native_socket_stream counterpart.">auto_ping()</a>, <a class="el" href="classipc_1_1transport_1_1sync__io_1_1Native__socket__stream_1_1Impl.html#a4b31da3a7ff63f307bd08e288c391556" title="Handler for the async-wait, via util::sync_io::Timer_event_emitter, of the auto-ping timer firing; if...">snd_on_ev_auto_ping_now_timer_fired()</a> itself). </p>
<p >Each of these calls indicates a send occurs, hence at worst the pipe will be idle (in need of auto-ping) in <a class="el" href="classipc_1_1transport_1_1sync__io_1_1Native__socket__stream_1_1Impl.html#a4cb5d8ce6fa402c2cbaf27ec9654277c" title="Equals zero() before auto_ping(); immutably equals period (auto_ping() arg) subsequently to that firs...">m_snd_auto_ping_period</a>. Note that <code>*end_sending()</code>, while also sending bytes, does not schedule <a class="el" href="classipc_1_1transport_1_1sync__io_1_1Native__socket__stream_1_1Impl.html#a311a0641a1da83530311e16845105c2c" title="Timer that fires snd_on_ev_auto_ping_now_timer_fired() (which sends an auto-ping) and is always sched...">m_snd_auto_ping_timer</a>, as <code>*end_sending()</code> closes the conceptual pipe, and there is no need for auto-pinging (see <a class="el" href="classipc_1_1transport_1_1sync__io_1_1Native__handle__receiver.html#a57ec0f2a9c1b8bfbaaf88975433a1354" title="In PEER state: Irreversibly enables a conceptual idle timer whose potential side effect is,...">Native_handle_receiver::idle_timer_run()</a>).</p>
<p >Since we implement <code><a class="el" href="namespaceipc_1_1transport_1_1sync__io.html" title="sync_io-pattern counterparts to async-I/O-pattern object types in parent namespace ipc::transport.">sync_io</a></code> pattern, the timer is obtained from, and used via, <a class="el" href="classipc_1_1util_1_1sync__io_1_1Timer__event__emitter.html" title="An object of this type, used internally to implement sync_io-pattern objects that require timer event...">util::sync_io::Timer_event_emitter</a> <a class="el" href="classipc_1_1transport_1_1sync__io_1_1Native__socket__stream_1_1Impl.html#a54c3fdde2cf99fda314ee3387f70a02e" title="As typical in timer-needing sync_io-pattern-implementing objects, maintains a thread exclusively for ...">m_timer_worker</a>. See that member's doc header for more info.</p>
<p >Relevant only once terminal <a class="el" href="classipc_1_1transport_1_1sync__io_1_1Native__socket__stream_1_1Impl.html#a9c9825f74472868eb1397c33edf78fb4ad9a05d721258c584cd559c56fd035887" title="Is or was a connected peer.">State::S_PEER</a> is reached. </p>

<p class="definition">Definition at line <a class="el" href="sync__io_2detail_2native__socket__stream__impl_8hpp_source.html#l01477">1477</a> of file <a class="el" href="sync__io_2detail_2native__socket__stream__impl_8hpp_source.html">native_socket_stream_impl.hpp</a>.</p>

</div>
</div>
<a id="a3116d5b66bf35bec158905bbde4f6854" name="a3116d5b66bf35bec158905bbde4f6854"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3116d5b66bf35bec158905bbde4f6854">&#9670;&nbsp;</a></span>m_snd_auto_ping_timer_fired_peer</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classipc_1_1util_1_1sync__io_1_1Timer__event__emitter.html#a1533a54927a64579fda02c61ec94b735">util::sync_io::Timer_event_emitter::Timer_fired_read_end</a>* ipc::transport::sync_io::Native_socket_stream::Impl::m_snd_auto_ping_timer_fired_peer</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Read-end of IPC-mechanism used by <a class="el" href="classipc_1_1transport_1_1sync__io_1_1Native__socket__stream_1_1Impl.html#a54c3fdde2cf99fda314ee3387f70a02e" title="As typical in timer-needing sync_io-pattern-implementing objects, maintains a thread exclusively for ...">m_timer_worker</a> to ferry timer-fired events from <a class="el" href="classipc_1_1transport_1_1sync__io_1_1Native__socket__stream_1_1Impl.html#a311a0641a1da83530311e16845105c2c" title="Timer that fires snd_on_ev_auto_ping_now_timer_fired() (which sends an auto-ping) and is always sched...">m_snd_auto_ping_timer</a> to <code><a class="el" href="namespaceipc_1_1transport_1_1sync__io.html" title="sync_io-pattern counterparts to async-I/O-pattern object types in parent namespace ipc::transport.">sync_io</a></code> outside async-wait to our actual on-timer-fired handler logic. </p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classipc_1_1transport_1_1sync__io_1_1Native__socket__stream_1_1Impl.html#a54c3fdde2cf99fda314ee3387f70a02e" title="As typical in timer-needing sync_io-pattern-implementing objects, maintains a thread exclusively for ...">m_timer_worker</a> for more info. </dd></dl>

<p class="definition">Definition at line <a class="el" href="sync__io_2detail_2native__socket__stream__impl_8hpp_source.html#l01485">1485</a> of file <a class="el" href="sync__io_2detail_2native__socket__stream__impl_8hpp_source.html">native_socket_stream_impl.hpp</a>.</p>

</div>
</div>
<a id="abd4d8d43776c3956c6896ca721e95dab" name="abd4d8d43776c3956c6896ca721e95dab"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abd4d8d43776c3956c6896ca721e95dab">&#9670;&nbsp;</a></span>m_snd_ev_wait_func</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespaceipc_1_1util_1_1sync__io.html#aa0b9a3cc6bdc7dedbef4f9e06851aa24">util::sync_io::Event_wait_func</a> ipc::transport::sync_io::Native_socket_stream::Impl::m_snd_ev_wait_func</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Function (set forever in <code>start_send_*_ops()</code>) through which we invoke the outside event loop's async-wait facility for descriptors/events relevant to send-ops. </p>
<p >See <a class="el" href="namespaceipc_1_1util_1_1sync__io.html#aa0b9a3cc6bdc7dedbef4f9e06851aa24" title="In sync_io pattern, concrete type storing user-supplied function invoked by pattern-implementing ipc:...">util::sync_io::Event_wait_func</a> doc header for a refresher on this mechanic. </p>

<p class="definition">Definition at line <a class="el" href="sync__io_2detail_2native__socket__stream__impl_8hpp_source.html#l01500">1500</a> of file <a class="el" href="sync__io_2detail_2native__socket__stream__impl_8hpp_source.html">native_socket_stream_impl.hpp</a>.</p>

<p class="reference">Referenced by <a class="el" href="sync__io_2detail_2native__socket__stream__impl_8hpp_source.html#l01595">sync_io_ev_wait_func()</a>.</p>

</div>
</div>
<a id="a459618a64d769ba8798a6380e9292181" name="a459618a64d769ba8798a6380e9292181"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a459618a64d769ba8798a6380e9292181">&#9670;&nbsp;</a></span>m_snd_ev_wait_hndl_auto_ping_timer_fired_peer</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classipc_1_1util_1_1sync__io_1_1Asio__waitable__native__handle.html">util::sync_io::Asio_waitable_native_handle</a> ipc::transport::sync_io::Native_socket_stream::Impl::m_snd_ev_wait_hndl_auto_ping_timer_fired_peer</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Descriptor waitable by outside event loop async-waits &ndash; storing the same <code>Native_handle</code> as (and thus being used to wait on events from) <a class="el" href="classipc_1_1transport_1_1sync__io_1_1Native__socket__stream_1_1Impl.html#a3116d5b66bf35bec158905bbde4f6854" title="Read-end of IPC-mechanism used by m_timer_worker to ferry timer-fired events from m_snd_auto_ping_tim...">m_snd_auto_ping_timer_fired_peer</a>. </p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classipc_1_1transport_1_1sync__io_1_1Native__socket__stream_1_1Impl.html#a54c3fdde2cf99fda314ee3387f70a02e" title="As typical in timer-needing sync_io-pattern-implementing objects, maintains a thread exclusively for ...">m_timer_worker</a> for more info. </dd></dl>

<p class="definition">Definition at line <a class="el" href="sync__io_2detail_2native__socket__stream__impl_8hpp_source.html#l01493">1493</a> of file <a class="el" href="sync__io_2detail_2native__socket__stream__impl_8hpp_source.html">native_socket_stream_impl.hpp</a>.</p>

</div>
</div>
<a id="acfefc83c990b1b6cd903f5ad323e5dfa" name="acfefc83c990b1b6cd903f5ad323e5dfa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acfefc83c990b1b6cd903f5ad323e5dfa">&#9670;&nbsp;</a></span>m_snd_finished</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool ipc::transport::sync_io::Native_socket_stream::Impl::m_snd_finished</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><code>false</code> at start; set to <code>true</code> forever on the first <code>*end_sending()</code> invocation; <code>true</code> will prevent any subsequent <a class="el" href="classipc_1_1transport_1_1sync__io_1_1Native__socket__stream_1_1Impl.html#a59e9935bdd704c40173a40e87b5db131" title="See Native_socket_stream counterpart.">send_native_handle()</a>/send_blob() calls from proceeding. </p>
<p >See class doc header impl section for design discussion.</p>
<p >Relevant only once terminal <a class="el" href="classipc_1_1transport_1_1sync__io_1_1Native__socket__stream_1_1Impl.html#a9c9825f74472868eb1397c33edf78fb4ad9a05d721258c584cd559c56fd035887" title="Is or was a connected peer.">State::S_PEER</a> is reached. </p>

<p class="definition">Definition at line <a class="el" href="sync__io_2detail_2native__socket__stream__impl_8hpp_source.html#l01445">1445</a> of file <a class="el" href="sync__io_2detail_2native__socket__stream__impl_8hpp_source.html">native_socket_stream_impl.hpp</a>.</p>

</div>
</div>
<a id="a0257a7903bff120aa1523f8de04bccf7" name="a0257a7903bff120aa1523f8de04bccf7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0257a7903bff120aa1523f8de04bccf7">&#9670;&nbsp;</a></span>m_snd_pending_err_code</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespaceipc.html#aa3192e586cc45d3e7c22463bf2760f89">Error_code</a> ipc::transport::sync_io::Native_socket_stream::Impl::m_snd_pending_err_code</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>The first and only connection-hosing error condition detected when attempting to low-level-write on <a class="el" href="classipc_1_1transport_1_1sync__io_1_1Native__socket__stream_1_1Impl.html#a42aab631e9c70bfaa53764309adfe37c" title="The peer stream-type Unix domain socket; or null pointer if we&#39;ve detected the connection has become ...">m_peer_socket</a>; or falsy if no such error has yet been detected. </p>
<p >Among possible other uses, it is returned by <a class="el" href="classipc_1_1transport_1_1sync__io_1_1Native__socket__stream_1_1Impl.html#a59e9935bdd704c40173a40e87b5db131" title="See Native_socket_stream counterpart.">send_native_handle()</a> and the completion handler of <a class="el" href="classipc_1_1transport_1_1sync__io_1_1Native__socket__stream_1_1Impl.html#a0aca995c7150e72219b422c188d9bc23" title="See Native_socket_stream counterpart.">async_end_sending()</a>.</p>
<p >Relevant only once terminal <a class="el" href="classipc_1_1transport_1_1sync__io_1_1Native__socket__stream_1_1Impl.html#a9c9825f74472868eb1397c33edf78fb4ad9a05d721258c584cd559c56fd035887" title="Is or was a connected peer.">State::S_PEER</a> is reached. </p>

<p class="definition">Definition at line <a class="el" href="sync__io_2detail_2native__socket__stream__impl_8hpp_source.html#l01436">1436</a> of file <a class="el" href="sync__io_2detail_2native__socket__stream__impl_8hpp_source.html">native_socket_stream_impl.hpp</a>.</p>

<p class="reference">Referenced by <a class="el" href="native__socket__stream__impl__snd_8cpp_source.html#l00028">start_send_native_handle_ops()</a>.</p>

</div>
</div>
<a id="a92372b2da3a4bdccda23b27b2865f01d" name="a92372b2da3a4bdccda23b27b2865f01d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a92372b2da3a4bdccda23b27b2865f01d">&#9670;&nbsp;</a></span>m_snd_pending_on_last_send_done_func_or_empty</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">flow::async::Task_asio_err ipc::transport::sync_io::Native_socket_stream::Impl::m_snd_pending_on_last_send_done_func_or_empty</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Function passed to <a class="el" href="classipc_1_1transport_1_1sync__io_1_1Native__socket__stream_1_1Impl.html#a0aca995c7150e72219b422c188d9bc23" title="See Native_socket_stream counterpart.">async_end_sending()</a>, if it returned <code>true</code> and was unable to synchronously flush everything including the graceful-close itself (synchronously detecting new or previous pipe-hosing error <em>does</em> entail flushing everything); otherwise <code>.empty()</code>. </p>
<p >It's the completion handler of that graceful-close-send API.</p>
<p >Relevant only once terminal <a class="el" href="classipc_1_1transport_1_1sync__io_1_1Native__socket__stream_1_1Impl.html#a9c9825f74472868eb1397c33edf78fb4ad9a05d721258c584cd559c56fd035887" title="Is or was a connected peer.">State::S_PEER</a> is reached. </p>

<p class="definition">Definition at line <a class="el" href="sync__io_2detail_2native__socket__stream__impl_8hpp_source.html#l01454">1454</a> of file <a class="el" href="sync__io_2detail_2native__socket__stream__impl_8hpp_source.html">native_socket_stream_impl.hpp</a>.</p>

</div>
</div>
<a id="a1af9eb83b9afee25ba153a2ca066858d" name="a1af9eb83b9afee25ba153a2ca066858d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1af9eb83b9afee25ba153a2ca066858d">&#9670;&nbsp;</a></span>m_snd_pending_payloads_q</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::queue&lt;<a class="el" href="structipc_1_1transport_1_1sync__io_1_1Native__socket__stream_1_1Impl_1_1Snd__low__lvl__payload.html#a2d3a01b00a000c3f40b3d580cd3b1c35">Snd_low_lvl_payload::Ptr</a>&gt; ipc::transport::sync_io::Native_socket_stream::Impl::m_snd_pending_payloads_q</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Queue storing (at head) the currently in-progress async write-op of a <a class="el" href="structipc_1_1transport_1_1sync__io_1_1Native__socket__stream_1_1Impl_1_1Snd__low__lvl__payload.html" title="Data store representing a payload corresponding to exactly one attempted async write-op,...">Snd_low_lvl_payload</a>; followed by the payloads that should be written after that completes, in order. </p>
<p >Relevant only once terminal <a class="el" href="classipc_1_1transport_1_1sync__io_1_1Native__socket__stream_1_1Impl.html#a9c9825f74472868eb1397c33edf78fb4ad9a05d721258c584cd559c56fd035887" title="Is or was a connected peer.">State::S_PEER</a> is reached. In that state only touched if would-block is encountered in... well, see <a class="el" href="structipc_1_1transport_1_1sync__io_1_1Native__socket__stream_1_1Impl_1_1Snd__low__lvl__payload.html" title="Data store representing a payload corresponding to exactly one attempted async write-op,...">Snd_low_lvl_payload</a> doc header. </p>

<p class="definition">Definition at line <a class="el" href="sync__io_2detail_2native__socket__stream__impl_8hpp_source.html#l01427">1427</a> of file <a class="el" href="sync__io_2detail_2native__socket__stream__impl_8hpp_source.html">native_socket_stream_impl.hpp</a>.</p>

</div>
</div>
<a id="a64e47a38b3ed59e37295336114918142" name="a64e47a38b3ed59e37295336114918142"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a64e47a38b3ed59e37295336114918142">&#9670;&nbsp;</a></span>m_state</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classipc_1_1transport_1_1sync__io_1_1Native__socket__stream_1_1Impl.html#a9c9825f74472868eb1397c33edf78fb4">State</a> ipc::transport::sync_io::Native_socket_stream::Impl::m_state</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>The current state of <code>*this</code>. </p>
<dl class="section see"><dt>See also</dt><dd><code><a class="el" href="classipc_1_1transport_1_1sync__io_1_1Native__socket__stream_1_1Impl.html#a9c9825f74472868eb1397c33edf78fb4" title="Overall state of a Native_socket_stream::Impl.">State</a></code> doc header for details about transitions, initial and terminal states, etc.</dd></dl>
<h3>Rationale</h3>
<p >Long story short this exists purely to ensure (1) the user only attempts transmission-related public ops once in the (terminal) PEER state; and (2) the user only attempts <a class="el" href="classipc_1_1transport_1_1sync__io_1_1Native__socket__stream_1_1Impl.html#ad6443fb49be059dbe76c75d86a18197e" title="The core of sync_connect(), written in the sync_io-pattern style.">async_connect()</a> while in the (initial) NULL state (and not, say, while already CONNECTING; or already connected (PEER)).</p>
<p ><a class="el" href="classipc_1_1transport_1_1sync__io_1_1Native__socket__stream_1_1Impl.html#a18de125ad318ba69cee7d8cb8204ad12" title="Checks whether m_state has reached State::S_PEER; if so returns true; if not logs WARNING and returns...">state_peer()</a> handles the check for PEER.</p>
<p ><a class="el" href="classipc_1_1transport_1_1sync__io_1_1Native__socket__stream_1_1Impl.html#ad6443fb49be059dbe76c75d86a18197e" title="The core of sync_connect(), written in the sync_io-pattern style.">async_connect()</a> and its completion handler conn_on_async_connect_or_error() handle all transitions (NULL -&gt; CONNECTING, CONNECTING -&gt; NULL, CONNECTING -&gt; PEER).</p>
<h3>Thread safety</h3>
<p >First take a look at "Thread safety" in <a class="el" href="classipc_1_1transport_1_1sync__io_1_1Native__socket__stream.html" title="Implements both sync_io::Native_handle_sender and sync_io::Native_handle_receiver concepts by using a...">sync_io::Native_socket_stream</a> class public doc header. Long story short, it says that the only relevant concurrency we must allow is a receive-op being invoked concurrently with a send-op while in PEER state. And indeed most such methods do check <a class="el" href="classipc_1_1transport_1_1sync__io_1_1Native__socket__stream_1_1Impl.html#a64e47a38b3ed59e37295336114918142" title="The current state of *this.">m_state</a> near the top. However, by definition, in PEER state, <a class="el" href="classipc_1_1transport_1_1sync__io_1_1Native__socket__stream_1_1Impl.html#a64e47a38b3ed59e37295336114918142" title="The current state of *this.">m_state</a> is constant. Therefore no locking is needed. (Contrast, potentially, with <code>m_*peer_socket</code> &ndash; the only other mutable datum accessed by both directions' algorithms.) </p>

<p class="definition">Definition at line <a class="el" href="sync__io_2detail_2native__socket__stream__impl_8hpp_source.html#l01145">1145</a> of file <a class="el" href="sync__io_2detail_2native__socket__stream__impl_8hpp_source.html">native_socket_stream_impl.hpp</a>.</p>

<p class="reference">Referenced by <a class="el" href="sync__io_2detail_2native__socket__stream__impl_8cpp_source.html#l00147">Impl()</a>.</p>

</div>
</div>
<a id="a54c3fdde2cf99fda314ee3387f70a02e" name="a54c3fdde2cf99fda314ee3387f70a02e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a54c3fdde2cf99fda314ee3387f70a02e">&#9670;&nbsp;</a></span>m_timer_worker</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classipc_1_1util_1_1sync__io_1_1Timer__event__emitter.html">util::sync_io::Timer_event_emitter</a> ipc::transport::sync_io::Native_socket_stream::Impl::m_timer_worker</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>As typical in timer-needing <code><a class="el" href="namespaceipc_1_1transport_1_1sync__io.html" title="sync_io-pattern counterparts to async-I/O-pattern object types in parent namespace ipc::transport.">sync_io</a></code>-pattern-implementing objects, maintains a thread exclusively for <code>Timer</code> wait completion handlers which ferry timer-fired events to internal IPC-mechanisms waitable by the <code><a class="el" href="namespaceipc_1_1transport_1_1sync__io.html" title="sync_io-pattern counterparts to async-I/O-pattern object types in parent namespace ipc::transport.">sync_io</a></code>-pattern-using outside event loop. </p>
<p >In our case we (optionally) maintain the auto-ping timer (send direction) and idle timer (receive direction).</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classipc_1_1util_1_1sync__io_1_1Timer__event__emitter.html" title="An object of this type, used internally to implement sync_io-pattern objects that require timer event...">util::sync_io::Timer_event_emitter</a> doc header for design/rationale discussion. </dd></dl>

<p class="definition">Definition at line <a class="el" href="sync__io_2detail_2native__socket__stream__impl_8hpp_source.html#l01368">1368</a> of file <a class="el" href="sync__io_2detail_2native__socket__stream__impl_8hpp_source.html">native_socket_stream_impl.hpp</a>.</p>

</div>
</div>
<a id="a7b825476c04ea53eccea862d34f830c6" name="a7b825476c04ea53eccea862d34f830c6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7b825476c04ea53eccea862d34f830c6">&#9670;&nbsp;</a></span>S_MAX_META_BLOB_LENGTH</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const size_t ipc::transport::sync_io::Native_socket_stream::Impl::S_MAX_META_BLOB_LENGTH = <a class="el" href="classipc_1_1transport_1_1sync__io_1_1Native__socket__stream_1_1Impl.html#ad5e487595e2a58f7ff25b4f4c91fe4bc">S_META_BLOB_LENGTH_PING_SENTINEL</a> - 1</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>See <a class="el" href="classipc_1_1transport_1_1sync__io_1_1Native__socket__stream.html" title="Implements both sync_io::Native_handle_sender and sync_io::Native_handle_receiver concepts by using a...">Native_socket_stream</a> counterpart. </p>

<p class="definition">Definition at line <a class="el" href="sync__io_2detail_2native__socket__stream__impl_8hpp_source.html#l00322">322</a> of file <a class="el" href="sync__io_2detail_2native__socket__stream__impl_8hpp_source.html">native_socket_stream_impl.hpp</a>.</p>

</div>
</div>
<a id="ad5e487595e2a58f7ff25b4f4c91fe4bc" name="ad5e487595e2a58f7ff25b4f4c91fe4bc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad5e487595e2a58f7ff25b4f4c91fe4bc">&#9670;&nbsp;</a></span>S_META_BLOB_LENGTH_PING_SENTINEL</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classipc_1_1transport_1_1sync__io_1_1Native__socket__stream_1_1Impl.html#a881c376f1ee37f9b1a20f770824f55d9">Native_socket_stream::Impl::low_lvl_payload_blob_length_t</a> ipc::transport::sync_io::Native_socket_stream::Impl::S_META_BLOB_LENGTH_PING_SENTINEL = std::numeric_limits&lt;<a class="el" href="classipc_1_1transport_1_1sync__io_1_1Native__socket__stream_1_1Impl.html#a881c376f1ee37f9b1a20f770824f55d9">low_lvl_payload_blob_length_t</a>&gt;::max()</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Value for the length field in payload 1 that means "not a length; indicating this is a ping message." The other special values is 0 which indicates graceful close. </p>
<p >Also <a class="el" href="classipc_1_1transport_1_1sync__io_1_1Native__socket__stream_1_1Impl.html#a7b825476c04ea53eccea862d34f830c6" title="See Native_socket_stream counterpart.">S_MAX_META_BLOB_LENGTH</a> must be adjusted accordingly; S_META_BLOB_LENGTH_PING_SENTINEL being 0xFF.... </p>

<p class="definition">Definition at line <a class="el" href="sync__io_2detail_2native__socket__stream__impl_8hpp_source.html#l00697">697</a> of file <a class="el" href="sync__io_2detail_2native__socket__stream__impl_8hpp_source.html">native_socket_stream_impl.hpp</a>.</p>

</div>
</div>
<hr/>The documentation for this class was generated from the following files:<ul>
<li>transport/sync_io/detail/<a class="el" href="sync__io_2detail_2native__socket__stream__impl_8hpp_source.html">native_socket_stream_impl.hpp</a></li>
<li>transport/sync_io/detail/<a class="el" href="sync__io_2detail_2native__socket__stream__impl_8cpp_source.html">native_socket_stream_impl.cpp</a></li>
<li>transport/sync_io/detail/<a class="el" href="native__socket__stream__impl__rcv_8cpp_source.html">native_socket_stream_impl_rcv.cpp</a></li>
<li>transport/sync_io/detail/<a class="el" href="native__socket__stream__impl__snd_8cpp_source.html">native_socket_stream_impl_snd.cpp</a></li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Sat Mar 8 2025 06:36:17 for Flow-IPC by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.4
</small></address>
</body>
</html>
