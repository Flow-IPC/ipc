<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.9.4"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Flow-IPC: ipc::session::Session_base&lt; S_MQ_TYPE_OR_NONE, S_TRANSMIT_NATIVE_HANDLES, Mdt_payload &gt; Class Template Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">Flow-IPC<span id="projectnumber">&#160;1.0.0</span>
   </div>
   <div id="projectbrief">Flow-IPC project: Full implementation reference.</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.4 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search",'Search','.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespaceipc.html">ipc</a></li><li class="navelem"><a class="el" href="namespaceipc_1_1session.html">session</a></li><li class="navelem"><a class="el" href="classipc_1_1session_1_1Session__base.html">Session_base</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#pub-types">Public Types</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pub-static-methods">Static Public Member Functions</a> &#124;
<a href="#pub-attribs">Public Attributes</a> &#124;
<a href="#pub-static-attribs">Static Public Attributes</a> &#124;
<a href="#pro-types">Protected Types</a> &#124;
<a href="#pro-methods">Protected Member Functions</a> &#124;
<a href="#pro-static-attribs">Static Protected Attributes</a> &#124;
<a href="#pri-attribs">Private Attributes</a> &#124;
<a href="classipc_1_1session_1_1Session__base-members.html">List of all members</a>  </div>
  <div class="headertitle"><div class="title">ipc::session::Session_base&lt; S_MQ_TYPE_OR_NONE, S_TRANSMIT_NATIVE_HANDLES, Mdt_payload &gt; Class Template Reference</div></div>
</div><!--header-->
<div class="contents">

<p>Internal type containing data and types common to internal types <a class="el" href="classipc_1_1session_1_1Server__session__impl.html" title="Internal, non-movable pImpl-lite implementation of Server_session_mv class template.">Server_session_impl</a> and <a class="el" href="classipc_1_1session_1_1Client__session__impl.html" title="Internal, non-movable pImpl-lite implementation of Client_session_mv class template.">Client_session_impl</a> which are the respective true cores of <a class="el" href="namespaceipc_1_1session.html#ab01d5bce0ab2f3435ca9dd88d27609dc" title="A vanilla Server_session with no optional capabilities.">Server_session</a> and <a class="el" href="namespaceipc_1_1session.html#a77d8fda00e1e17f595a6a5d4c44375e7" title="A vanilla Client_session with no optional capabilities.">Client_session</a> respectively.  
 <a href="classipc_1_1session_1_1Session__base.html#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="session__base_8hpp_source.html">session_base.hpp</a>&gt;</code></p>
<div class="dynheader">
Inheritance diagram for ipc::session::Session_base&lt; S_MQ_TYPE_OR_NONE, S_TRANSMIT_NATIVE_HANDLES, Mdt_payload &gt;:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="classipc_1_1session_1_1Session__base__inherit__graph.svg" width="1296" height="702"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe>
</div>
<center><span class="legend">[<a href="graph_legend.html">legend</a>]</span></center></div>
<div class="dynheader">
Collaboration diagram for ipc::session::Session_base&lt; S_MQ_TYPE_OR_NONE, S_TRANSMIT_NATIVE_HANDLES, Mdt_payload &gt;:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="classipc_1_1session_1_1Session__base__coll__graph.svg" width="1678" height="560"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe>
</div>
<center><span class="legend">[<a href="graph_legend.html">legend</a>]</span></center></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="nested-classes" name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classipc_1_1session_1_1Session__base_1_1Graceful__finisher.html">Graceful_finisher</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Optional to use by subclasses, this operates a simple state machine that carries out a graceful-session-end handshake procedure.  <a href="classipc_1_1session_1_1Session__base_1_1Graceful__finisher.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-types" name="pub-types"></a>
Public Types</h2></td></tr>
<tr class="memitem:a848c0f5247644ada0f8b0ab816eedda8"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classipc_1_1session_1_1Session__base.html#a848c0f5247644ada0f8b0ab816eedda8">Persistent_mq_handle_from_cfg</a> = std::conditional_t&lt;!<a class="el" href="classipc_1_1session_1_1Session__base.html#a27a5731a648effb6b4b42f0312affa74">S_MQS_ENABLED</a>, <a class="el" href="classipc_1_1transport_1_1Null__peer.html">transport::Null_peer</a>, std::conditional_t&lt; S_MQ_TYPE_OR_NONE==schema::MqType::POSIX, <a class="el" href="classipc_1_1transport_1_1Posix__mq__handle.html">transport::Posix_mq_handle</a>, <a class="el" href="classipc_1_1transport_1_1Bipc__mq__handle.html">transport::Bipc_mq_handle</a> &gt; &gt;</td></tr>
<tr class="memdesc:a848c0f5247644ada0f8b0ab816eedda8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Relevant only if <a class="el" href="classipc_1_1session_1_1Session__base.html#a27a5731a648effb6b4b42f0312affa74" title="See Session_mv.">S_MQS_ENABLED</a>, this is the Persistent_mq_handle-concept impl type specified by the user via <code>S_MQ_TYPE_OR_NONE</code>.  <a href="classipc_1_1session_1_1Session__base.html#a848c0f5247644ada0f8b0ab816eedda8">More...</a><br /></td></tr>
<tr class="separator:a848c0f5247644ada0f8b0ab816eedda8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a71f02a809d667c23ff8af29a96940bd1"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classipc_1_1session_1_1Session__base.html#a71f02a809d667c23ff8af29a96940bd1">Channel_obj</a> = std::conditional_t&lt; <a class="el" href="classipc_1_1session_1_1Session__base.html#a27a5731a648effb6b4b42f0312affa74">S_MQS_ENABLED</a>, std::conditional_t&lt; S_TRANSMIT_NATIVE_HANDLES, <a class="el" href="classipc_1_1transport_1_1Mqs__socket__stream__channel.html">transport::Mqs_socket_stream_channel</a>&lt; true, <a class="el" href="classipc_1_1session_1_1Session__base.html#a848c0f5247644ada0f8b0ab816eedda8">Persistent_mq_handle_from_cfg</a> &gt;, <a class="el" href="classipc_1_1transport_1_1Mqs__channel.html">transport::Mqs_channel</a>&lt; true, <a class="el" href="classipc_1_1session_1_1Session__base.html#a848c0f5247644ada0f8b0ab816eedda8">Persistent_mq_handle_from_cfg</a> &gt; &gt;, std::conditional_t&lt; S_TRANSMIT_NATIVE_HANDLES, <a class="el" href="classipc_1_1transport_1_1Socket__stream__channel.html">transport::Socket_stream_channel</a>&lt; true &gt;, <a class="el" href="classipc_1_1transport_1_1Socket__stream__channel__of__blobs.html">transport::Socket_stream_channel_of_blobs</a>&lt; true &gt; &gt; &gt;</td></tr>
<tr class="memdesc:a71f02a809d667c23ff8af29a96940bd1"><td class="mdescLeft">&#160;</td><td class="mdescRight">See <a class="el" href="classipc_1_1session_1_1Session__mv.html" title="Implements the Session concept when it is in PEER state.">Session_mv</a> (or <a class="el" href="classipc_1_1session_1_1Session.html" title="A documentation-only concept defining the local side of an IPC conversation (session) with another en...">Session</a> concept).  <a href="classipc_1_1session_1_1Session__base.html#a71f02a809d667c23ff8af29a96940bd1">More...</a><br /></td></tr>
<tr class="separator:a71f02a809d667c23ff8af29a96940bd1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a638232ef74a0eb80aeb4f027ee06f9bf"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classipc_1_1session_1_1Session__base.html#a638232ef74a0eb80aeb4f027ee06f9bf">Channels</a> = std::vector&lt; <a class="el" href="classipc_1_1session_1_1Session__base.html#a71f02a809d667c23ff8af29a96940bd1">Channel_obj</a> &gt;</td></tr>
<tr class="memdesc:a638232ef74a0eb80aeb4f027ee06f9bf"><td class="mdescLeft">&#160;</td><td class="mdescRight">See <a class="el" href="classipc_1_1session_1_1Session__mv.html" title="Implements the Session concept when it is in PEER state.">Session_mv</a>. Note: If changed from <code>vector</code> please update those doc headers too.  <a href="classipc_1_1session_1_1Session__base.html#a638232ef74a0eb80aeb4f027ee06f9bf">More...</a><br /></td></tr>
<tr class="separator:a638232ef74a0eb80aeb4f027ee06f9bf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a35234981ca87cc2f6b118b3e52452ea8"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classipc_1_1session_1_1Session__base.html#a35234981ca87cc2f6b118b3e52452ea8">Mdt_payload_obj</a> = Mdt_payload</td></tr>
<tr class="memdesc:a35234981ca87cc2f6b118b3e52452ea8"><td class="mdescLeft">&#160;</td><td class="mdescRight">See <a class="el" href="classipc_1_1session_1_1Session__mv.html" title="Implements the Session concept when it is in PEER state.">Session_mv</a> (or <a class="el" href="classipc_1_1session_1_1Session.html" title="A documentation-only concept defining the local side of an IPC conversation (session) with another en...">Session</a> concept).  <a href="classipc_1_1session_1_1Session__base.html#a35234981ca87cc2f6b118b3e52452ea8">More...</a><br /></td></tr>
<tr class="separator:a35234981ca87cc2f6b118b3e52452ea8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ace4dab42adec6354cc66081dd218ac71"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classipc_1_1session_1_1Session__base.html#ace4dab42adec6354cc66081dd218ac71">Mdt_reader_ptr</a> = boost::shared_ptr&lt; typename transport::struc::schema::Metadata&lt; <a class="el" href="classipc_1_1session_1_1Session__base.html#a35234981ca87cc2f6b118b3e52452ea8">Mdt_payload_obj</a> &gt;::Reader &gt;</td></tr>
<tr class="memdesc:ace4dab42adec6354cc66081dd218ac71"><td class="mdescLeft">&#160;</td><td class="mdescRight">See <a class="el" href="classipc_1_1session_1_1Session__mv.html" title="Implements the Session concept when it is in PEER state.">Session_mv</a> (or <a class="el" href="classipc_1_1session_1_1Session.html" title="A documentation-only concept defining the local side of an IPC conversation (session) with another en...">Session</a> concept).  <a href="classipc_1_1session_1_1Session__base.html#ace4dab42adec6354cc66081dd218ac71">More...</a><br /></td></tr>
<tr class="separator:ace4dab42adec6354cc66081dd218ac71"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7d68bbb8c0c09983619d563bca30bd45"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classipc_1_1session_1_1Session__base.html#a7d68bbb8c0c09983619d563bca30bd45">Mdt_builder</a> = typename transport::struc::schema::Metadata&lt; <a class="el" href="classipc_1_1session_1_1Session__base.html#a35234981ca87cc2f6b118b3e52452ea8">Mdt_payload_obj</a> &gt;<a class="el" href="classStruct__builder__config_1_1Builder.html">::Builder</a></td></tr>
<tr class="memdesc:a7d68bbb8c0c09983619d563bca30bd45"><td class="mdescLeft">&#160;</td><td class="mdescRight">See <a class="el" href="classipc_1_1session_1_1Session__mv.html" title="Implements the Session concept when it is in PEER state.">Session_mv</a> (or <a class="el" href="classipc_1_1session_1_1Session.html" title="A documentation-only concept defining the local side of an IPC conversation (session) with another en...">Session</a> concept).  <a href="classipc_1_1session_1_1Session__base.html#a7d68bbb8c0c09983619d563bca30bd45">More...</a><br /></td></tr>
<tr class="separator:a7d68bbb8c0c09983619d563bca30bd45"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4a7a5b83f6ba8bd505685636eabc012b"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classipc_1_1session_1_1Session__base.html#a4a7a5b83f6ba8bd505685636eabc012b">Mdt_builder_ptr</a> = boost::shared_ptr&lt; <a class="el" href="classipc_1_1session_1_1Session__base.html#a7d68bbb8c0c09983619d563bca30bd45">Mdt_builder</a> &gt;</td></tr>
<tr class="memdesc:a4a7a5b83f6ba8bd505685636eabc012b"><td class="mdescLeft">&#160;</td><td class="mdescRight">See <a class="el" href="classipc_1_1session_1_1Session__mv.html" title="Implements the Session concept when it is in PEER state.">Session_mv</a> (or <a class="el" href="classipc_1_1session_1_1Session.html" title="A documentation-only concept defining the local side of an IPC conversation (session) with another en...">Session</a> concept).  <a href="classipc_1_1session_1_1Session__base.html#a4a7a5b83f6ba8bd505685636eabc012b">More...</a><br /></td></tr>
<tr class="separator:a4a7a5b83f6ba8bd505685636eabc012b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aee0db48505c84d3553b7110a9a815036"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classipc_1_1session_1_1Session__base.html#aee0db48505c84d3553b7110a9a815036">Structured_msg_builder_config</a> = <a class="el" href="structipc_1_1transport_1_1struc_1_1Heap__fixed__builder_1_1Config.html">transport::struc::Heap_fixed_builder::Config</a></td></tr>
<tr class="memdesc:aee0db48505c84d3553b7110a9a815036"><td class="mdescLeft">&#160;</td><td class="mdescRight">See <a class="el" href="classipc_1_1session_1_1Session__mv.html" title="Implements the Session concept when it is in PEER state.">Session_mv</a> (or <a class="el" href="classipc_1_1session_1_1Session.html" title="A documentation-only concept defining the local side of an IPC conversation (session) with another en...">Session</a> concept).  <a href="classipc_1_1session_1_1Session__base.html#aee0db48505c84d3553b7110a9a815036">More...</a><br /></td></tr>
<tr class="separator:aee0db48505c84d3553b7110a9a815036"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abd854f2b9316361ef18f15610c242d4b"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classipc_1_1session_1_1Session__base.html#abd854f2b9316361ef18f15610c242d4b">Structured_msg_reader_config</a> = <a class="el" href="structipc_1_1transport_1_1struc_1_1Heap__reader_1_1Config.html">transport::struc::Heap_reader::Config</a></td></tr>
<tr class="memdesc:abd854f2b9316361ef18f15610c242d4b"><td class="mdescLeft">&#160;</td><td class="mdescRight">See <a class="el" href="classipc_1_1session_1_1Session__mv.html" title="Implements the Session concept when it is in PEER state.">Session_mv</a> (or <a class="el" href="classipc_1_1session_1_1Session.html" title="A documentation-only concept defining the local side of an IPC conversation (session) with another en...">Session</a> concept).  <a href="classipc_1_1session_1_1Session__base.html#abd854f2b9316361ef18f15610c242d4b">More...</a><br /></td></tr>
<tr class="separator:abd854f2b9316361ef18f15610c242d4b"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-methods" name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a4d1327608d6067ed6690bd4efa323c6f"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="namespaceipc_1_1session.html#a6d07d9996af19e57eb42416e914110ea">Shared_name</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classipc_1_1session_1_1Session__base.html#a4d1327608d6067ed6690bd4efa323c6f">srv_namespace</a> () const</td></tr>
<tr class="memdesc:a4d1327608d6067ed6690bd4efa323c6f"><td class="mdescLeft">&#160;</td><td class="mdescRight">See <a class="el" href="classipc_1_1session_1_1Server__session__impl.html" title="Internal, non-movable pImpl-lite implementation of Server_session_mv class template.">Server_session_impl</a>, <a class="el" href="classipc_1_1session_1_1Client__session__impl.html" title="Internal, non-movable pImpl-lite implementation of Client_session_mv class template.">Client_session_impl</a>.  <a href="classipc_1_1session_1_1Session__base.html#a4d1327608d6067ed6690bd4efa323c6f">More...</a><br /></td></tr>
<tr class="separator:a4d1327608d6067ed6690bd4efa323c6f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abd1e814b3b640f4bdaa2553352405f26"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="namespaceipc_1_1session.html#a6d07d9996af19e57eb42416e914110ea">Shared_name</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classipc_1_1session_1_1Session__base.html#abd1e814b3b640f4bdaa2553352405f26">cli_namespace</a> () const</td></tr>
<tr class="memdesc:abd1e814b3b640f4bdaa2553352405f26"><td class="mdescLeft">&#160;</td><td class="mdescRight">See <a class="el" href="classipc_1_1session_1_1Server__session__impl.html" title="Internal, non-movable pImpl-lite implementation of Server_session_mv class template.">Server_session_impl</a>, <a class="el" href="classipc_1_1session_1_1Client__session__impl.html" title="Internal, non-movable pImpl-lite implementation of Client_session_mv class template.">Client_session_impl</a>.  <a href="classipc_1_1session_1_1Session__base.html#abd1e814b3b640f4bdaa2553352405f26">More...</a><br /></td></tr>
<tr class="separator:abd1e814b3b640f4bdaa2553352405f26"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3ebdafe7e70719e6d12dd0b15ae85106"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="structipc_1_1session_1_1Client__app.html">Client_app</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classipc_1_1session_1_1Session__base.html#a3ebdafe7e70719e6d12dd0b15ae85106">cli_app_ptr</a> () const</td></tr>
<tr class="memdesc:a3ebdafe7e70719e6d12dd0b15ae85106"><td class="mdescLeft">&#160;</td><td class="mdescRight">See <a class="el" href="classipc_1_1session_1_1Server__session__impl.html" title="Internal, non-movable pImpl-lite implementation of Server_session_mv class template.">Server_session_impl</a>, <a class="el" href="classipc_1_1session_1_1Client__session__impl.html" title="Internal, non-movable pImpl-lite implementation of Client_session_mv class template.">Client_session_impl</a>.  <a href="classipc_1_1session_1_1Session__base.html#a3ebdafe7e70719e6d12dd0b15ae85106">More...</a><br /></td></tr>
<tr class="separator:a3ebdafe7e70719e6d12dd0b15ae85106"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a09cbe99083616bae00928f8e37c8373b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespaceipc_1_1session.html#a6d07d9996af19e57eb42416e914110ea">Shared_name</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classipc_1_1session_1_1Session__base.html#a09cbe99083616bae00928f8e37c8373b">cur_ns_store_mutex_absolute_name</a> () const</td></tr>
<tr class="memdesc:a09cbe99083616bae00928f8e37c8373b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the name of the interprocess named-mutex used to control reading/writing to the file storing (written by server, read by client) the value for <a class="el" href="classipc_1_1session_1_1Session__base.html#a4d1327608d6067ed6690bd4efa323c6f" title="See Server_session_impl, Client_session_impl.">srv_namespace()</a>.  <a href="classipc_1_1session_1_1Session__base.html#a09cbe99083616bae00928f8e37c8373b">More...</a><br /></td></tr>
<tr class="separator:a09cbe99083616bae00928f8e37c8373b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af059faab56cdf384873f9f2aba8f79cf"><td class="memItemLeft" align="right" valign="top">fs::path&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classipc_1_1session_1_1Session__base.html#af059faab56cdf384873f9f2aba8f79cf">cur_ns_store_absolute_path</a> () const</td></tr>
<tr class="memdesc:af059faab56cdf384873f9f2aba8f79cf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the absolute path to file storing (written by server, read by client) the value for <a class="el" href="classipc_1_1session_1_1Session__base.html#a4d1327608d6067ed6690bd4efa323c6f" title="See Server_session_impl, Client_session_impl.">srv_namespace()</a>.  <a href="classipc_1_1session_1_1Session__base.html#af059faab56cdf384873f9f2aba8f79cf">More...</a><br /></td></tr>
<tr class="separator:af059faab56cdf384873f9f2aba8f79cf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3d34c5a9c283a6b7c8ab943f344cdd28"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespaceipc_1_1session.html#a6d07d9996af19e57eb42416e914110ea">Shared_name</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classipc_1_1session_1_1Session__base.html#a3d34c5a9c283a6b7c8ab943f344cdd28">session_master_socket_stream_acceptor_absolute_name</a> () const</td></tr>
<tr class="memdesc:a3d34c5a9c283a6b7c8ab943f344cdd28"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the absolute name at which the server shall set up a <a class="el" href="classipc_1_1transport_1_1Native__socket__stream__acceptor.html" title="A server object that binds to a Shared_name and listens for incoming Native_socket_stream connect att...">transport::Native_socket_stream_acceptor</a> to which client shall <a class="el" href="classipc_1_1transport_1_1Native__socket__stream.html#a89d591db714e83dcb55a52738fed1ebb" title="To be invoked in NULL state only, it synchronously and non-blockingly attempts to connect to an oppos...">transport::Native_socket_stream::sync_connect()</a> in order to establish a PEER-state session.  <a href="classipc_1_1session_1_1Session__base.html#a3d34c5a9c283a6b7c8ab943f344cdd28">More...</a><br /></td></tr>
<tr class="separator:a3d34c5a9c283a6b7c8ab943f344cdd28"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-static-methods" name="pub-static-methods"></a>
Static Public Member Functions</h2></td></tr>
<tr class="memitem:a08b3d69a6707dcbb233076b7a48de285"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classipc_1_1session_1_1Session__base.html#aee0db48505c84d3553b7110a9a815036">Structured_msg_builder_config</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classipc_1_1session_1_1Session__base.html#a08b3d69a6707dcbb233076b7a48de285">heap_fixed_builder_config</a> (flow::log::Logger *logger_ptr)</td></tr>
<tr class="memdesc:a08b3d69a6707dcbb233076b7a48de285"><td class="mdescLeft">&#160;</td><td class="mdescRight">See <a class="el" href="classipc_1_1session_1_1Session__mv.html#a107684fdd5d233549c6daac26a81a542" title="Utility that obtains a heap-based (non-zero-copy) Struct_builder::Config, constructed with the most e...">Session_mv::heap_fixed_builder_config()</a> (1-arg).  <a href="classipc_1_1session_1_1Session__base.html#a08b3d69a6707dcbb233076b7a48de285">More...</a><br /></td></tr>
<tr class="separator:a08b3d69a6707dcbb233076b7a48de285"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a489bb6ec7726e39e78dcd4dd2fe3de75"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classipc_1_1session_1_1Session__base.html#abd854f2b9316361ef18f15610c242d4b">Structured_msg_reader_config</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classipc_1_1session_1_1Session__base.html#a489bb6ec7726e39e78dcd4dd2fe3de75">heap_reader_config</a> (flow::log::Logger *logger_ptr)</td></tr>
<tr class="memdesc:a489bb6ec7726e39e78dcd4dd2fe3de75"><td class="mdescLeft">&#160;</td><td class="mdescRight">See <a class="el" href="classipc_1_1session_1_1Session__mv.html#ab3c69e3f8ccbd70d315bed86d697255d" title="Deserializing counterpart to non-static heap_fixed_builder_config().">Session_mv::heap_reader_config()</a> (1-arg).  <a href="classipc_1_1session_1_1Session__base.html#a489bb6ec7726e39e78dcd4dd2fe3de75">More...</a><br /></td></tr>
<tr class="separator:a489bb6ec7726e39e78dcd4dd2fe3de75"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-attribs" name="pub-attribs"></a>
Public Attributes</h2></td></tr>
<tr class="memitem:afd32d90b86d699263a0f02637dd7c6c6"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="structipc_1_1session_1_1Server__app.html">Server_app</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classipc_1_1session_1_1Session__base.html#afd32d90b86d699263a0f02637dd7c6c6">m_srv_app_ref</a></td></tr>
<tr class="memdesc:afd32d90b86d699263a0f02637dd7c6c6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reference to <a class="el" href="structipc_1_1session_1_1Server__app.html" title="An App that is used as a server in at least one client-server IPC split.">Server_app</a> (referring to local process in <a class="el" href="classipc_1_1session_1_1Server__session__impl.html" title="Internal, non-movable pImpl-lite implementation of Server_session_mv class template.">Server_session_impl</a>, opposing process in <a class="el" href="classipc_1_1session_1_1Client__session__impl.html" title="Internal, non-movable pImpl-lite implementation of Client_session_mv class template.">Client_session_impl</a>).  <a href="classipc_1_1session_1_1Session__base.html#afd32d90b86d699263a0f02637dd7c6c6">More...</a><br /></td></tr>
<tr class="separator:afd32d90b86d699263a0f02637dd7c6c6"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-static-attribs" name="pub-static-attribs"></a>
Static Public Attributes</h2></td></tr>
<tr class="memitem:a27a5731a648effb6b4b42f0312affa74"><td class="memItemLeft" align="right" valign="top">static constexpr bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classipc_1_1session_1_1Session__base.html#a27a5731a648effb6b4b42f0312affa74">S_MQS_ENABLED</a> = S_MQ_TYPE_OR_NONE != schema::MqType::NONE</td></tr>
<tr class="memdesc:a27a5731a648effb6b4b42f0312affa74"><td class="mdescLeft">&#160;</td><td class="mdescRight">See <a class="el" href="classipc_1_1session_1_1Session__mv.html" title="Implements the Session concept when it is in PEER state.">Session_mv</a>.  <a href="classipc_1_1session_1_1Session__base.html#a27a5731a648effb6b4b42f0312affa74">More...</a><br /></td></tr>
<tr class="separator:a27a5731a648effb6b4b42f0312affa74"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1f7c4243c8bd55930f51a568884c8aaf"><td class="memItemLeft" align="right" valign="top">static constexpr bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classipc_1_1session_1_1Session__base.html#a1f7c4243c8bd55930f51a568884c8aaf">S_SOCKET_STREAM_ENABLED</a> = (!<a class="el" href="classipc_1_1session_1_1Session__base.html#a27a5731a648effb6b4b42f0312affa74">S_MQS_ENABLED</a>) || S_TRANSMIT_NATIVE_HANDLES</td></tr>
<tr class="memdesc:a1f7c4243c8bd55930f51a568884c8aaf"><td class="mdescLeft">&#160;</td><td class="mdescRight">See <a class="el" href="classipc_1_1session_1_1Session__mv.html" title="Implements the Session concept when it is in PEER state.">Session_mv</a>.  <a href="classipc_1_1session_1_1Session__base.html#a1f7c4243c8bd55930f51a568884c8aaf">More...</a><br /></td></tr>
<tr class="separator:a1f7c4243c8bd55930f51a568884c8aaf"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pro-types" name="pro-types"></a>
Protected Types</h2></td></tr>
<tr class="memitem:a26d038e14e3c0e461e76de88c4ce76c5"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classipc_1_1session_1_1Session__base.html#a26d038e14e3c0e461e76de88c4ce76c5">Master_structured_channel</a> = <a class="el" href="namespaceipc_1_1transport_1_1struc.html#aca041b0efd4a9ae18e10088b2ee3c052">transport::struc::Channel_via_heap</a>&lt; <a class="el" href="classipc_1_1transport_1_1Socket__stream__channel.html">transport::Socket_stream_channel</a>&lt; true &gt;, schema::detail::SessionMasterChannelMessageBody&lt; <a class="el" href="classipc_1_1session_1_1Session__base.html#a35234981ca87cc2f6b118b3e52452ea8">Mdt_payload_obj</a> &gt; &gt;</td></tr>
<tr class="memdesc:a26d038e14e3c0e461e76de88c4ce76c5"><td class="mdescLeft">&#160;</td><td class="mdescRight">The (internally used) session master channel is a <a class="el" href="classipc_1_1transport_1_1struc_1_1Channel.html" title="Owning and wrapping a pre-connected transport::Channel peer (an endpoint of an established channel ov...">transport::struc::Channel</a> of this concrete type.  <a href="classipc_1_1session_1_1Session__base.html#a26d038e14e3c0e461e76de88c4ce76c5">More...</a><br /></td></tr>
<tr class="separator:a26d038e14e3c0e461e76de88c4ce76c5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af0ca2a01d7d0d92038aae56fc1cdd505"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classipc_1_1session_1_1Session__base.html#af0ca2a01d7d0d92038aae56fc1cdd505">Master_structured_channel_ptr</a> = boost::shared_ptr&lt; <a class="el" href="classipc_1_1session_1_1Session__base.html#a26d038e14e3c0e461e76de88c4ce76c5">Master_structured_channel</a> &gt;</td></tr>
<tr class="memdesc:af0ca2a01d7d0d92038aae56fc1cdd505"><td class="mdescLeft">&#160;</td><td class="mdescRight">Handle to <a class="el" href="classipc_1_1session_1_1Session__base.html#a26d038e14e3c0e461e76de88c4ce76c5" title="The (internally used) session master channel is a transport::struc::Channel of this concrete type.">Master_structured_channel</a>.  <a href="classipc_1_1session_1_1Session__base.html#af0ca2a01d7d0d92038aae56fc1cdd505">More...</a><br /></td></tr>
<tr class="separator:af0ca2a01d7d0d92038aae56fc1cdd505"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae2a123b29dd044a638e94d1f294c8f28"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classipc_1_1session_1_1Session__base.html#ae2a123b29dd044a638e94d1f294c8f28">Master_structured_channel_observer</a> = boost::weak_ptr&lt; <a class="el" href="classipc_1_1session_1_1Session__base.html#a26d038e14e3c0e461e76de88c4ce76c5">Master_structured_channel</a> &gt;</td></tr>
<tr class="memdesc:ae2a123b29dd044a638e94d1f294c8f28"><td class="mdescLeft">&#160;</td><td class="mdescRight">Observer of <a class="el" href="classipc_1_1session_1_1Session__base.html#af0ca2a01d7d0d92038aae56fc1cdd505" title="Handle to Master_structured_channel.">Master_structured_channel_ptr</a>. See its doc header.  <a href="classipc_1_1session_1_1Session__base.html#ae2a123b29dd044a638e94d1f294c8f28">More...</a><br /></td></tr>
<tr class="separator:ae2a123b29dd044a638e94d1f294c8f28"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3c0824a54ef32915c5c5ea76481f2409"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classipc_1_1session_1_1Session__base.html#a3c0824a54ef32915c5c5ea76481f2409">On_passive_open_channel_func</a> = <a class="el" href="namespaceipc.html#aa455c7f045059736578ca275fc1a851f">Function</a>&lt; void(<a class="el" href="classipc_1_1session_1_1Session__base.html#a71f02a809d667c23ff8af29a96940bd1">Channel_obj</a> &amp;&amp;new_channel, <a class="el" href="classipc_1_1session_1_1Session__base.html#ace4dab42adec6354cc66081dd218ac71">Mdt_reader_ptr</a> &amp;&amp;new_channel_mdt)&gt;</td></tr>
<tr class="memdesc:a3c0824a54ef32915c5c5ea76481f2409"><td class="mdescLeft">&#160;</td><td class="mdescRight">Concrete function type for the on-passive-open handler (if any), used for storage.  <a href="classipc_1_1session_1_1Session__base.html#a3c0824a54ef32915c5c5ea76481f2409">More...</a><br /></td></tr>
<tr class="separator:a3c0824a54ef32915c5c5ea76481f2409"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pro-methods" name="pro-methods"></a>
Protected Member Functions</h2></td></tr>
<tr class="memitem:aab2db8b2cdb3d8189c1cc497aed7b2b1"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classipc_1_1session_1_1Session__base.html#aab2db8b2cdb3d8189c1cc497aed7b2b1">Session_base</a> (const <a class="el" href="structipc_1_1session_1_1Client__app.html">Client_app</a> &amp;cli_app_ref, const <a class="el" href="structipc_1_1session_1_1Server__app.html">Server_app</a> &amp;srv_app_ref, flow::async::Task_asio_err &amp;&amp;on_err_func, <a class="el" href="classipc_1_1session_1_1Session__base.html#a3c0824a54ef32915c5c5ea76481f2409">On_passive_open_channel_func</a> &amp;&amp;on_passive_open_channel_func_or_empty_arg)</td></tr>
<tr class="memdesc:aab2db8b2cdb3d8189c1cc497aed7b2b1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructs: <a class="el" href="classipc_1_1session_1_1Client__session__impl.html" title="Internal, non-movable pImpl-lite implementation of Client_session_mv class template.">Client_session_impl</a> form (the user is the one constructing the object, though in NULL state).  <a href="classipc_1_1session_1_1Session__base.html#aab2db8b2cdb3d8189c1cc497aed7b2b1">More...</a><br /></td></tr>
<tr class="separator:aab2db8b2cdb3d8189c1cc497aed7b2b1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8d323ca75006777b3fc929bd0720f7df"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classipc_1_1session_1_1Session__base.html#a8d323ca75006777b3fc929bd0720f7df">Session_base</a> (const <a class="el" href="structipc_1_1session_1_1Server__app.html">Server_app</a> &amp;srv_app_ref)</td></tr>
<tr class="memdesc:a8d323ca75006777b3fc929bd0720f7df"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructs: <a class="el" href="classipc_1_1session_1_1Server__session__impl.html" title="Internal, non-movable pImpl-lite implementation of Server_session_mv class template.">Server_session_impl</a> form (<a class="el" href="classipc_1_1session_1_1Session__server.html" title="To be instantiated typically once in a given process, an object of this type asynchronously listens f...">Session_server</a> is the one constructing the object, though in NULL state, before log-in has completed, but after the socket-stream connection has been established).  <a href="classipc_1_1session_1_1Session__base.html#a8d323ca75006777b3fc929bd0720f7df">More...</a><br /></td></tr>
<tr class="separator:a8d323ca75006777b3fc929bd0720f7df"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a28825fcdeaf1249a7bf810a3b2ca7c38"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classipc_1_1session_1_1Session__base.html#a28825fcdeaf1249a7bf810a3b2ca7c38">set_srv_namespace</a> (<a class="el" href="namespaceipc_1_1session.html#a6d07d9996af19e57eb42416e914110ea">Shared_name</a> &amp;&amp;srv_namespace_new)</td></tr>
<tr class="memdesc:a28825fcdeaf1249a7bf810a3b2ca7c38"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets <a class="el" href="classipc_1_1session_1_1Session__base.html#a4d1327608d6067ed6690bd4efa323c6f" title="See Server_session_impl, Client_session_impl.">srv_namespace()</a> (do not call if already set).  <a href="classipc_1_1session_1_1Session__base.html#a28825fcdeaf1249a7bf810a3b2ca7c38">More...</a><br /></td></tr>
<tr class="separator:a28825fcdeaf1249a7bf810a3b2ca7c38"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8cc7a4faa098e0f71c737f44c34d593c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classipc_1_1session_1_1Session__base.html#a8cc7a4faa098e0f71c737f44c34d593c">set_cli_namespace</a> (<a class="el" href="namespaceipc_1_1session.html#a6d07d9996af19e57eb42416e914110ea">Shared_name</a> &amp;&amp;cli_namespace_new)</td></tr>
<tr class="memdesc:a8cc7a4faa098e0f71c737f44c34d593c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets <a class="el" href="classipc_1_1session_1_1Session__base.html#abd1e814b3b640f4bdaa2553352405f26" title="See Server_session_impl, Client_session_impl.">cli_namespace()</a> (do not call if already set).  <a href="classipc_1_1session_1_1Session__base.html#a8cc7a4faa098e0f71c737f44c34d593c">More...</a><br /></td></tr>
<tr class="separator:a8cc7a4faa098e0f71c737f44c34d593c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a60a081ce0f85651202d23b4d543d093c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classipc_1_1session_1_1Session__base.html#a60a081ce0f85651202d23b4d543d093c">set_cli_app_ptr</a> (const <a class="el" href="structipc_1_1session_1_1Client__app.html">Client_app</a> *cli_app_ptr_new)</td></tr>
<tr class="memdesc:a60a081ce0f85651202d23b4d543d093c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets <a class="el" href="classipc_1_1session_1_1Session__base.html#a3ebdafe7e70719e6d12dd0b15ae85106" title="See Server_session_impl, Client_session_impl.">cli_app_ptr()</a> (do not call if already set).  <a href="classipc_1_1session_1_1Session__base.html#a60a081ce0f85651202d23b4d543d093c">More...</a><br /></td></tr>
<tr class="separator:a60a081ce0f85651202d23b4d543d093c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3be1a385c905404621b58c23332b0b96"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classipc_1_1session_1_1Session__base.html#a3be1a385c905404621b58c23332b0b96">set_on_passive_open_channel_func</a> (<a class="el" href="classipc_1_1session_1_1Session__base.html#a3c0824a54ef32915c5c5ea76481f2409">On_passive_open_channel_func</a> &amp;&amp;on_passive_open_channel_func)</td></tr>
<tr class="memdesc:a3be1a385c905404621b58c23332b0b96"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets <a class="el" href="classipc_1_1session_1_1Session__base.html#a21b146b02d257d95f4aaeaca12b8d320" title="The on-passive-open handler (may be empty even in final state, meaning user wants passive-opens disab...">on_passive_open_channel_func_or_empty()</a> (do not call if already set; do not call if user intends for passive-opens to be disabled on this side).  <a href="classipc_1_1session_1_1Session__base.html#a3be1a385c905404621b58c23332b0b96">More...</a><br /></td></tr>
<tr class="separator:a3be1a385c905404621b58c23332b0b96"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae769a82bdec0d16702111ad06716faae"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classipc_1_1session_1_1Session__base.html#ae769a82bdec0d16702111ad06716faae">set_on_err_func</a> (flow::async::Task_asio_err &amp;&amp;on_err_func_arg)</td></tr>
<tr class="memdesc:ae769a82bdec0d16702111ad06716faae"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets on_err_func() (do not call if already set).  <a href="classipc_1_1session_1_1Session__base.html#ae769a82bdec0d16702111ad06716faae">More...</a><br /></td></tr>
<tr class="separator:ae769a82bdec0d16702111ad06716faae"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aca82817beaac36d0006c44012f9fef03"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classipc_1_1session_1_1Session__base.html#aca82817beaac36d0006c44012f9fef03">on_err_func_set</a> () const</td></tr>
<tr class="memdesc:aca82817beaac36d0006c44012f9fef03"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns <code>true</code> if and only if <a class="el" href="classipc_1_1session_1_1Session__base.html#ae769a82bdec0d16702111ad06716faae" title="Sets on_err_func() (do not call if already set).">set_on_err_func()</a> has been called.  <a href="classipc_1_1session_1_1Session__base.html#aca82817beaac36d0006c44012f9fef03">More...</a><br /></td></tr>
<tr class="separator:aca82817beaac36d0006c44012f9fef03"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a21b146b02d257d95f4aaeaca12b8d320"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classipc_1_1session_1_1Session__base.html#a3c0824a54ef32915c5c5ea76481f2409">On_passive_open_channel_func</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classipc_1_1session_1_1Session__base.html#a21b146b02d257d95f4aaeaca12b8d320">on_passive_open_channel_func_or_empty</a> () const</td></tr>
<tr class="memdesc:a21b146b02d257d95f4aaeaca12b8d320"><td class="mdescLeft">&#160;</td><td class="mdescRight">The on-passive-open handler (may be empty even in final state, meaning user wants passive-opens disabled on this side).  <a href="classipc_1_1session_1_1Session__base.html#a21b146b02d257d95f4aaeaca12b8d320">More...</a><br /></td></tr>
<tr class="separator:a21b146b02d257d95f4aaeaca12b8d320"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7f9e67dccbab4f3191734c2834bafb63"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classipc_1_1session_1_1Session__base.html#a7f9e67dccbab4f3191734c2834bafb63">hose</a> (const <a class="el" href="namespaceipc.html#aa3192e586cc45d3e7c22463bf2760f89">Error_code</a> &amp;err_code)</td></tr>
<tr class="memdesc:a7f9e67dccbab4f3191734c2834bafb63"><td class="mdescLeft">&#160;</td><td class="mdescRight">Marks this session as hosed for (truthy) reason <code>err_code</code>; and <em>synchronously</em> invokes on-error handler; only invoke if not already <a class="el" href="classipc_1_1session_1_1Session__base.html#a398f3e6a30b3fae8e110af9fd1ff75e3" title="Returns true if and only if hose() has been called.">hosed()</a>.  <a href="classipc_1_1session_1_1Session__base.html#a7f9e67dccbab4f3191734c2834bafb63">More...</a><br /></td></tr>
<tr class="separator:a7f9e67dccbab4f3191734c2834bafb63"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a398f3e6a30b3fae8e110af9fd1ff75e3"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classipc_1_1session_1_1Session__base.html#a398f3e6a30b3fae8e110af9fd1ff75e3">hosed</a> () const</td></tr>
<tr class="memdesc:a398f3e6a30b3fae8e110af9fd1ff75e3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns <code>true</code> if and only if <a class="el" href="classipc_1_1session_1_1Session__base.html#a7f9e67dccbab4f3191734c2834bafb63" title="Marks this session as hosed for (truthy) reason err_code; and synchronously invokes on-error handler;...">hose()</a> has been called.  <a href="classipc_1_1session_1_1Session__base.html#a398f3e6a30b3fae8e110af9fd1ff75e3">More...</a><br /></td></tr>
<tr class="separator:a398f3e6a30b3fae8e110af9fd1ff75e3"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pro-static-attribs" name="pro-static-attribs"></a>
Static Protected Attributes</h2></td></tr>
<tr class="memitem:ae68b7b80ff82ba5cde28a53fa52a5095"><td class="memItemLeft" align="right" valign="top">static constexpr <a class="el" href="namespaceipc_1_1util.html#ac66141280c3b7295a86b65209f31cc58">util::Fine_duration</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classipc_1_1session_1_1Session__base.html#ae68b7b80ff82ba5cde28a53fa52a5095">S_OPEN_CHANNEL_TIMEOUT</a> = boost::chrono::seconds(60)</td></tr>
<tr class="memdesc:ae68b7b80ff82ba5cde28a53fa52a5095"><td class="mdescLeft">&#160;</td><td class="mdescRight">Internal timeout for <code>open_channel()</code>.  <a href="classipc_1_1session_1_1Session__base.html#ae68b7b80ff82ba5cde28a53fa52a5095">More...</a><br /></td></tr>
<tr class="separator:ae68b7b80ff82ba5cde28a53fa52a5095"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af0b52934c6b1204cb3ba676480727d27"><td class="memItemLeft" align="right" valign="top">static constexpr size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classipc_1_1session_1_1Session__base.html#af0b52934c6b1204cb3ba676480727d27">S_MQS_MAX_MSG_SZ</a> = 8 * 1024</td></tr>
<tr class="memdesc:af0b52934c6b1204cb3ba676480727d27"><td class="mdescLeft">&#160;</td><td class="mdescRight">The max sendable MQ message size as decided by <a class="el" href="classipc_1_1session_1_1Server__session__impl.html#a84d54a57d3e06c064cde737d1f4be472" title="Helper for create_channel_and_resources(), invoked and compiled if and only if S_MQS_ENABLED,...">Server_session_impl::make_channel_mqs()</a> (and imposed on both sides, both directions), if <a class="el" href="classipc_1_1session_1_1Session__base.html#a27a5731a648effb6b4b42f0312affa74" title="See Session_mv.">S_MQS_ENABLED</a> <em>and</em> <a class="el" href="classipc_1_1session_1_1Server__session__impl.html#a1ded7990451b90f29e11f8fa7ce0e80b" title="See Session_mv counterpart.">Server_session_impl::S_SHM_ENABLED</a> is <code>false</code>, when a channel is opened (regardless of which side did the active-open or requested pre-opening at session start).  <a href="classipc_1_1session_1_1Session__base.html#af0b52934c6b1204cb3ba676480727d27">More...</a><br /></td></tr>
<tr class="separator:af0b52934c6b1204cb3ba676480727d27"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pri-attribs" name="pri-attribs"></a>
Private Attributes</h2></td></tr>
<tr class="memitem:aa8cccc9369af1dff6b59dee1a12f72d8"><td class="memItemLeft" align="right" valign="top">std::atomic&lt; const <a class="el" href="structipc_1_1session_1_1Client__app.html">Client_app</a> * &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classipc_1_1session_1_1Session__base.html#aa8cccc9369af1dff6b59dee1a12f72d8">m_cli_app_ptr</a></td></tr>
<tr class="memdesc:aa8cccc9369af1dff6b59dee1a12f72d8"><td class="mdescLeft">&#160;</td><td class="mdescRight">See <a class="el" href="classipc_1_1session_1_1Session__base.html#a3ebdafe7e70719e6d12dd0b15ae85106" title="See Server_session_impl, Client_session_impl.">cli_app_ptr()</a>.  <a href="classipc_1_1session_1_1Session__base.html#aa8cccc9369af1dff6b59dee1a12f72d8">More...</a><br /></td></tr>
<tr class="separator:aa8cccc9369af1dff6b59dee1a12f72d8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a60a30526bad0c8db6ad05ede618a22bd"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespaceipc_1_1session.html#a6d07d9996af19e57eb42416e914110ea">Shared_name</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classipc_1_1session_1_1Session__base.html#a60a30526bad0c8db6ad05ede618a22bd">m_srv_namespace</a></td></tr>
<tr class="memdesc:a60a30526bad0c8db6ad05ede618a22bd"><td class="mdescLeft">&#160;</td><td class="mdescRight">See <a class="el" href="classipc_1_1session_1_1Session__base.html#a4d1327608d6067ed6690bd4efa323c6f" title="See Server_session_impl, Client_session_impl.">srv_namespace()</a>.  <a href="classipc_1_1session_1_1Session__base.html#a60a30526bad0c8db6ad05ede618a22bd">More...</a><br /></td></tr>
<tr class="separator:a60a30526bad0c8db6ad05ede618a22bd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2985006a6526c86ce3ed5497cb7f5b64"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespaceipc_1_1session.html#a6d07d9996af19e57eb42416e914110ea">Shared_name</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classipc_1_1session_1_1Session__base.html#a2985006a6526c86ce3ed5497cb7f5b64">m_cli_namespace</a></td></tr>
<tr class="memdesc:a2985006a6526c86ce3ed5497cb7f5b64"><td class="mdescLeft">&#160;</td><td class="mdescRight">See <a class="el" href="classipc_1_1session_1_1Session__base.html#abd1e814b3b640f4bdaa2553352405f26" title="See Server_session_impl, Client_session_impl.">cli_namespace()</a>.  <a href="classipc_1_1session_1_1Session__base.html#a2985006a6526c86ce3ed5497cb7f5b64">More...</a><br /></td></tr>
<tr class="separator:a2985006a6526c86ce3ed5497cb7f5b64"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7d25e45d33beb8af9ae03b05d676b0e4"><td class="memItemLeft" align="right" valign="top">flow::async::Task_asio_err&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classipc_1_1session_1_1Session__base.html#a7d25e45d33beb8af9ae03b05d676b0e4">m_on_err_func</a></td></tr>
<tr class="memdesc:a7d25e45d33beb8af9ae03b05d676b0e4"><td class="mdescLeft">&#160;</td><td class="mdescRight">See <a class="el" href="classipc_1_1session_1_1Session__base.html#ae769a82bdec0d16702111ad06716faae" title="Sets on_err_func() (do not call if already set).">set_on_err_func()</a>.  <a href="classipc_1_1session_1_1Session__base.html#a7d25e45d33beb8af9ae03b05d676b0e4">More...</a><br /></td></tr>
<tr class="separator:a7d25e45d33beb8af9ae03b05d676b0e4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad28de3ad7ea872adb52e3a826602d333"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classipc_1_1session_1_1Session__base.html#a3c0824a54ef32915c5c5ea76481f2409">On_passive_open_channel_func</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classipc_1_1session_1_1Session__base.html#ad28de3ad7ea872adb52e3a826602d333">m_on_passive_open_channel_func_or_empty</a></td></tr>
<tr class="memdesc:ad28de3ad7ea872adb52e3a826602d333"><td class="mdescLeft">&#160;</td><td class="mdescRight">See <a class="el" href="classipc_1_1session_1_1Session__base.html#a21b146b02d257d95f4aaeaca12b8d320" title="The on-passive-open handler (may be empty even in final state, meaning user wants passive-opens disab...">on_passive_open_channel_func_or_empty()</a>.  <a href="classipc_1_1session_1_1Session__base.html#ad28de3ad7ea872adb52e3a826602d333">More...</a><br /></td></tr>
<tr class="separator:ad28de3ad7ea872adb52e3a826602d333"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0d7926326671d05679c53e5e3991603e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespaceipc.html#aa3192e586cc45d3e7c22463bf2760f89">Error_code</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classipc_1_1session_1_1Session__base.html#a0d7926326671d05679c53e5e3991603e">m_peer_state_err_code_or_ok</a></td></tr>
<tr class="memdesc:a0d7926326671d05679c53e5e3991603e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Starts falsy; becomes forever truthy (with a specific <a class="el" href="namespaceipc.html#aa3192e586cc45d3e7c22463bf2760f89" title="Short-hand for flow::Error_code which is very common.">Error_code</a> that will not change thereafter) once <a class="el" href="classipc_1_1session_1_1Session__base.html#a7f9e67dccbab4f3191734c2834bafb63" title="Marks this session as hosed for (truthy) reason err_code; and synchronously invokes on-error handler;...">hose()</a> is called (with that truthy value).  <a href="classipc_1_1session_1_1Session__base.html#a0d7926326671d05679c53e5e3991603e">More...</a><br /></td></tr>
<tr class="separator:a0d7926326671d05679c53e5e3991603e"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><div class="compoundTemplParams">template&lt;schema::MqType S_MQ_TYPE_OR_NONE, bool S_TRANSMIT_NATIVE_HANDLES, typename Mdt_payload&gt;<br />
class ipc::session::Session_base&lt; S_MQ_TYPE_OR_NONE, S_TRANSMIT_NATIVE_HANDLES, Mdt_payload &gt;</div><p >Internal type containing data and types common to internal types <a class="el" href="classipc_1_1session_1_1Server__session__impl.html" title="Internal, non-movable pImpl-lite implementation of Server_session_mv class template.">Server_session_impl</a> and <a class="el" href="classipc_1_1session_1_1Client__session__impl.html" title="Internal, non-movable pImpl-lite implementation of Client_session_mv class template.">Client_session_impl</a> which are the respective true cores of <a class="el" href="namespaceipc_1_1session.html#ab01d5bce0ab2f3435ca9dd88d27609dc" title="A vanilla Server_session with no optional capabilities.">Server_session</a> and <a class="el" href="namespaceipc_1_1session.html#a77d8fda00e1e17f595a6a5d4c44375e7" title="A vanilla Client_session with no optional capabilities.">Client_session</a> respectively. </p>
<p >A <a class="el" href="classipc_1_1session_1_1Server__session__impl.html" title="Internal, non-movable pImpl-lite implementation of Server_session_mv class template.">Server_session_impl</a> and <a class="el" href="classipc_1_1session_1_1Client__session__impl.html" title="Internal, non-movable pImpl-lite implementation of Client_session_mv class template.">Client_session_impl</a> share many basic properties, some public. For example consider that a <a class="el" href="classipc_1_1session_1_1Server__session__impl.html" title="Internal, non-movable pImpl-lite implementation of Server_session_mv class template.">Server_session_impl</a> on this side has 1 counterpart <a class="el" href="classipc_1_1session_1_1Client__session__impl.html" title="Internal, non-movable pImpl-lite implementation of Client_session_mv class template.">Client_session_impl</a> on the other side (or vice versa); for both it is salient which <a class="el" href="structipc_1_1session_1_1Server__app.html" title="An App that is used as a server in at least one client-server IPC split.">Server_app</a> is on the server side and which <a class="el" href="structipc_1_1session_1_1Client__app.html" title="An App that is used as a client in at least one client-server IPC split.">Client_app</a> is on the client side. In terms of types/constants, on each side the two <a class="el" href="classipc_1_1session_1_1Session.html" title="A documentation-only concept defining the local side of an IPC conversation (session) with another en...">Session</a> objects must be identically configured via various template params which results in non-trivial type aliases like the highly significant <a class="el" href="classipc_1_1session_1_1Session__base.html#a71f02a809d667c23ff8af29a96940bd1" title="See Session_mv (or Session concept).">Channel_obj</a>, exposed in the <a class="el" href="classipc_1_1session_1_1Session.html" title="A documentation-only concept defining the local side of an IPC conversation (session) with another en...">Session</a> concept, and constants like <a class="el" href="classipc_1_1session_1_1Session__base.html#a1f7c4243c8bd55930f51a568884c8aaf" title="See Session_mv.">S_SOCKET_STREAM_ENABLED</a>.</p>
<p >Regarding data: an operational (PEER-state) <a class="el" href="classipc_1_1session_1_1Session.html" title="A documentation-only concept defining the local side of an IPC conversation (session) with another en...">Session</a> (on either end) will need various members to be set before it is indeed in PEER state. This object stores such data, usually unset at first, and features <code>protected</code> setters to invoke once each, until all are set permanently for PEER state.</p>
<p ><a class="el" href="classipc_1_1session_1_1Session__base.html" title="Internal type containing data and types common to internal types Server_session_impl and Client_sessi...">Session_base</a> also has a <code>protected</code> inner class, <a class="el" href="classipc_1_1session_1_1Session__base_1_1Graceful__finisher.html" title="Optional to use by subclasses, this operates a simple state machine that carries out a graceful-sessi...">Session_base::Graceful_finisher</a> which certain variations (for which this is necessary) of <a class="el" href="classipc_1_1session_1_1Server__session__impl.html" title="Internal, non-movable pImpl-lite implementation of Server_session_mv class template.">Server_session_impl</a> and <a class="el" href="classipc_1_1session_1_1Client__session__impl.html" title="Internal, non-movable pImpl-lite implementation of Client_session_mv class template.">Client_session_impl</a> use to carry out a graceful-session-end handshake procedure. This is here in <a class="el" href="classipc_1_1session_1_1Session__base.html" title="Internal type containing data and types common to internal types Server_session_impl and Client_sessi...">Session_base</a> &ndash; despite being somewhat more algorithmic/stateful than the other stuff here &ndash; essentially because the <a class="el" href="classipc_1_1session_1_1Session__base_1_1Graceful__finisher.html" title="Optional to use by subclasses, this operates a simple state machine that carries out a graceful-sessi...">Graceful_finisher</a> (if needed at all) on each side acts completely symmetrically. Other items tend to be (internally) asymmetrical in behavior between <a class="el" href="classipc_1_1session_1_1Server__session__impl.html" title="Internal, non-movable pImpl-lite implementation of Server_session_mv class template.">Server_session_impl</a> and <a class="el" href="classipc_1_1session_1_1Client__session__impl.html" title="Internal, non-movable pImpl-lite implementation of Client_session_mv class template.">Client_session_impl</a> (and variants). More info on <a class="el" href="classipc_1_1session_1_1Session__base_1_1Graceful__finisher.html" title="Optional to use by subclasses, this operates a simple state machine that carries out a graceful-sessi...">Session_base::Graceful_finisher</a> in its own doc header.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Mdt_payload</td><td>See <a class="el" href="namespaceipc_1_1session.html#ab01d5bce0ab2f3435ca9dd88d27609dc" title="A vanilla Server_session with no optional capabilities.">Server_session</a>, <a class="el" href="namespaceipc_1_1session.html#a77d8fda00e1e17f595a6a5d4c44375e7" title="A vanilla Client_session with no optional capabilities.">Client_session</a> (or <a class="el" href="classipc_1_1session_1_1Session.html" title="A documentation-only concept defining the local side of an IPC conversation (session) with another en...">Session</a> concept). </td></tr>
    <tr><td class="paramname">S_MQ_TYPE_OR_NONE</td><td>See <a class="el" href="namespaceipc_1_1session.html#ab01d5bce0ab2f3435ca9dd88d27609dc" title="A vanilla Server_session with no optional capabilities.">Server_session</a>, <a class="el" href="namespaceipc_1_1session.html#a77d8fda00e1e17f595a6a5d4c44375e7" title="A vanilla Client_session with no optional capabilities.">Client_session</a>. </td></tr>
    <tr><td class="paramname">S_TRANSMIT_NATIVE_HANDLES</td><td>See <a class="el" href="namespaceipc_1_1session.html#ab01d5bce0ab2f3435ca9dd88d27609dc" title="A vanilla Server_session with no optional capabilities.">Server_session</a>, <a class="el" href="namespaceipc_1_1session.html#a77d8fda00e1e17f595a6a5d4c44375e7" title="A vanilla Client_session with no optional capabilities.">Client_session</a>. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="session__base_8hpp_source.html#l00067">67</a> of file <a class="el" href="session__base_8hpp_source.html">session_base.hpp</a>.</p>
</div><h2 class="groupheader">Member Typedef Documentation</h2>
<a id="a71f02a809d667c23ff8af29a96940bd1" name="a71f02a809d667c23ff8af29a96940bd1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a71f02a809d667c23ff8af29a96940bd1">&#9670;&nbsp;</a></span>Channel_obj</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;schema::MqType S_MQ_TYPE_OR_NONE, bool S_TRANSMIT_NATIVE_HANDLES, typename Mdt_payload &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classipc_1_1session_1_1Session__base.html">ipc::session::Session_base</a>&lt; S_MQ_TYPE_OR_NONE, S_TRANSMIT_NATIVE_HANDLES, Mdt_payload &gt;::Channel_obj =  std::conditional_t&lt;<a class="el" href="classipc_1_1session_1_1Session__base.html#a27a5731a648effb6b4b42f0312affa74">S_MQS_ENABLED</a>, std::conditional_t &lt;S_TRANSMIT_NATIVE_HANDLES, <a class="el" href="classipc_1_1transport_1_1Mqs__socket__stream__channel.html">transport::Mqs_socket_stream_channel</a>&lt;true, <a class="el" href="classipc_1_1session_1_1Session__base.html#a848c0f5247644ada0f8b0ab816eedda8">Persistent_mq_handle_from_cfg</a>&gt;, <a class="el" href="classipc_1_1transport_1_1Mqs__channel.html">transport::Mqs_channel</a>&lt;true, <a class="el" href="classipc_1_1session_1_1Session__base.html#a848c0f5247644ada0f8b0ab816eedda8">Persistent_mq_handle_from_cfg</a>&gt; &gt;, std::conditional_t &lt;S_TRANSMIT_NATIVE_HANDLES, <a class="el" href="classipc_1_1transport_1_1Socket__stream__channel.html">transport::Socket_stream_channel</a>&lt;true&gt;, <a class="el" href="classipc_1_1transport_1_1Socket__stream__channel__of__blobs.html">transport::Socket_stream_channel_of_blobs</a>&lt;true&gt; &gt;&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>See <a class="el" href="classipc_1_1session_1_1Session__mv.html" title="Implements the Session concept when it is in PEER state.">Session_mv</a> (or <a class="el" href="classipc_1_1session_1_1Session.html" title="A documentation-only concept defining the local side of an IPC conversation (session) with another en...">Session</a> concept). </p>

<p class="definition">Definition at line <a class="el" href="session__base_8hpp_source.html#l00111">111</a> of file <a class="el" href="session__base_8hpp_source.html">session_base.hpp</a>.</p>

</div>
</div>
<a id="a638232ef74a0eb80aeb4f027ee06f9bf" name="a638232ef74a0eb80aeb4f027ee06f9bf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a638232ef74a0eb80aeb4f027ee06f9bf">&#9670;&nbsp;</a></span>Channels</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;schema::MqType S_MQ_TYPE_OR_NONE, bool S_TRANSMIT_NATIVE_HANDLES, typename Mdt_payload &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classipc_1_1session_1_1Session__base.html">ipc::session::Session_base</a>&lt; S_MQ_TYPE_OR_NONE, S_TRANSMIT_NATIVE_HANDLES, Mdt_payload &gt;::Channels =  std::vector&lt;<a class="el" href="classipc_1_1session_1_1Session__base.html#a71f02a809d667c23ff8af29a96940bd1">Channel_obj</a>&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>See <a class="el" href="classipc_1_1session_1_1Session__mv.html" title="Implements the Session concept when it is in PEER state.">Session_mv</a>. Note: If changed from <code>vector</code> please update those doc headers too. </p>

<p class="definition">Definition at line <a class="el" href="session__base_8hpp_source.html#l00122">122</a> of file <a class="el" href="session__base_8hpp_source.html">session_base.hpp</a>.</p>

</div>
</div>
<a id="a26d038e14e3c0e461e76de88c4ce76c5" name="a26d038e14e3c0e461e76de88c4ce76c5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a26d038e14e3c0e461e76de88c4ce76c5">&#9670;&nbsp;</a></span>Master_structured_channel</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;schema::MqType S_MQ_TYPE_OR_NONE, bool S_TRANSMIT_NATIVE_HANDLES, typename Mdt_payload &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classipc_1_1session_1_1Session__base.html">ipc::session::Session_base</a>&lt; S_MQ_TYPE_OR_NONE, S_TRANSMIT_NATIVE_HANDLES, Mdt_payload &gt;::Master_structured_channel =  <a class="el" href="namespaceipc_1_1transport_1_1struc.html#aca041b0efd4a9ae18e10088b2ee3c052">transport::struc::Channel_via_heap</a>&lt;<a class="el" href="classipc_1_1transport_1_1Socket__stream__channel.html">transport::Socket_stream_channel</a>&lt;true&gt;, schema::detail::SessionMasterChannelMessageBody &lt;<a class="el" href="classipc_1_1session_1_1Session__base.html#a35234981ca87cc2f6b118b3e52452ea8">Mdt_payload_obj</a>&gt; &gt;</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>The (internally used) session master channel is a <a class="el" href="classipc_1_1transport_1_1struc_1_1Channel.html" title="Owning and wrapping a pre-connected transport::Channel peer (an endpoint of an established channel ov...">transport::struc::Channel</a> of this concrete type. </p>
<p >Rationale for the chosen knob values:</p><ul>
<li>To be able to open_channel() (and hence passive-open) a <a class="el" href="classipc_1_1session_1_1Session__base.html#a71f02a809d667c23ff8af29a96940bd1" title="See Session_mv (or Session concept).">Channel_obj</a> that can transmit native handles, certainly a handles pipe is required to transmit half of each socket-pair. That said, an <code>Mqs_channel</code> would work fine if <a class="el" href="classipc_1_1session_1_1Session__base.html#a1f7c4243c8bd55930f51a568884c8aaf" title="See Session_mv.">S_SOCKET_STREAM_ENABLED</a> is <code>false</code>. The real reason at least a handles pipe is required is that to establish this channel &ndash; unlike subsequent channels in the session &ndash; a client-server flow is required. This connection establishment is not possible with MQs, so of the available options only a socket stream would work.<ul>
<li>There is no bulky data transfers over this channel, so adding a parallel MQ-based blobs pipe is overkill even if it could help performance; more so since the master channel is unlikely to be used frequently (open_channel() on either side shouldn't be that frequent). Since, again, the minute differences in perf versus a Unix-domain-socket-based transport are unlikely to be significant in this use case, it is easier to use a socket stream which lacks any kernel-persistent cleanup considerations &ndash; or even just distinct naming considerations for that matter.</li>
<li>So: use a <a class="el" href="classipc_1_1transport_1_1Socket__stream__channel.html" title="A Channel with a handles pipe only (no blobs pipe) that uses a Unix domain socket connection as the u...">transport::Socket_stream_channel</a>.</li>
</ul>
</li>
<li>Use the specially tailored (internal) session master channel capnp schema, whose key messages cover (at least):<ul>
<li>session log-in at the start;</li>
<li>open-channel request/response.</li>
</ul>
</li>
<li>As of this writing, for serializing/deserializing, it's either the heap-allocating engine on either side, or it's something SHM-based (which could be faster). However at least some SHM-based builders/readers themselves (internally) require a <a class="el" href="classipc_1_1transport_1_1Channel.html" title="Peer to a bundle of 1-2 full-duplex pipe(s), one for transmitting unstructured binary blobs; the othe...">transport::Channel</a> to function, which would require a <a class="el" href="classipc_1_1session_1_1Session.html" title="A documentation-only concept defining the local side of an IPC conversation (session) with another en...">Session</a> typically, creating a cyclical feature dependency. Plus, SHM has cleanup considerations. So a heap-based engine on either side is the natural choice. The cost is some perf: one copies from heap into the session master transport; and from there into heap on the other side. In this context that's not a significant perf loss. </li>
</ul>

<p class="definition">Definition at line <a class="el" href="session__base_8hpp_source.html#l00352">352</a> of file <a class="el" href="session__base_8hpp_source.html">session_base.hpp</a>.</p>

</div>
</div>
<a id="ae2a123b29dd044a638e94d1f294c8f28" name="ae2a123b29dd044a638e94d1f294c8f28"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae2a123b29dd044a638e94d1f294c8f28">&#9670;&nbsp;</a></span>Master_structured_channel_observer</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;schema::MqType S_MQ_TYPE_OR_NONE, bool S_TRANSMIT_NATIVE_HANDLES, typename Mdt_payload &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classipc_1_1session_1_1Session__base.html">ipc::session::Session_base</a>&lt; S_MQ_TYPE_OR_NONE, S_TRANSMIT_NATIVE_HANDLES, Mdt_payload &gt;::Master_structured_channel_observer =  boost::weak_ptr&lt;<a class="el" href="classipc_1_1session_1_1Session__base.html#a26d038e14e3c0e461e76de88c4ce76c5">Master_structured_channel</a>&gt;</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Observer of <a class="el" href="classipc_1_1session_1_1Session__base.html#af0ca2a01d7d0d92038aae56fc1cdd505" title="Handle to Master_structured_channel.">Master_structured_channel_ptr</a>. See its doc header. </p>

<p class="definition">Definition at line <a class="el" href="session__base_8hpp_source.html#l00369">369</a> of file <a class="el" href="session__base_8hpp_source.html">session_base.hpp</a>.</p>

</div>
</div>
<a id="af0ca2a01d7d0d92038aae56fc1cdd505" name="af0ca2a01d7d0d92038aae56fc1cdd505"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af0ca2a01d7d0d92038aae56fc1cdd505">&#9670;&nbsp;</a></span>Master_structured_channel_ptr</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;schema::MqType S_MQ_TYPE_OR_NONE, bool S_TRANSMIT_NATIVE_HANDLES, typename Mdt_payload &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classipc_1_1session_1_1Session__base.html">ipc::session::Session_base</a>&lt; S_MQ_TYPE_OR_NONE, S_TRANSMIT_NATIVE_HANDLES, Mdt_payload &gt;::Master_structured_channel_ptr =  boost::shared_ptr&lt;<a class="el" href="classipc_1_1session_1_1Session__base.html#a26d038e14e3c0e461e76de88c4ce76c5">Master_structured_channel</a>&gt;</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Handle to <a class="el" href="classipc_1_1session_1_1Session__base.html#a26d038e14e3c0e461e76de88c4ce76c5" title="The (internally used) session master channel is a transport::struc::Channel of this concrete type.">Master_structured_channel</a>. </p>
<h3>Rationale for type chosen</h3>
<p >It's a handle at all, because at first and possibly later there may be no session master channel, so a null value is useful. (Though, <code>std::optional</code> could be used instead.) It's a ref-counted pointer as opposed to <code>unique_ptr</code> so that it can be observed via <a class="el" href="classipc_1_1session_1_1Session__base.html#ae2a123b29dd044a638e94d1f294c8f28" title="Observer of Master_structured_channel_ptr. See its doc header.">Master_structured_channel_observer</a> (<code>weak_ptr</code>) which is not (and cannot) be available for <code>unique_ptr</code>. The observing is needed tactically for certain async lambda needs. </p>

<p class="definition">Definition at line <a class="el" href="session__base_8hpp_source.html#l00366">366</a> of file <a class="el" href="session__base_8hpp_source.html">session_base.hpp</a>.</p>

</div>
</div>
<a id="a7d68bbb8c0c09983619d563bca30bd45" name="a7d68bbb8c0c09983619d563bca30bd45"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7d68bbb8c0c09983619d563bca30bd45">&#9670;&nbsp;</a></span>Mdt_builder</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;schema::MqType S_MQ_TYPE_OR_NONE, bool S_TRANSMIT_NATIVE_HANDLES, typename Mdt_payload &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classipc_1_1session_1_1Session__base.html">ipc::session::Session_base</a>&lt; S_MQ_TYPE_OR_NONE, S_TRANSMIT_NATIVE_HANDLES, Mdt_payload &gt;::Mdt_builder =  typename transport::struc::schema::Metadata&lt;<a class="el" href="classipc_1_1session_1_1Session__base.html#a35234981ca87cc2f6b118b3e52452ea8">Mdt_payload_obj</a>&gt;<a class="el" href="classStruct__builder__config_1_1Builder.html">::Builder</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>See <a class="el" href="classipc_1_1session_1_1Session__mv.html" title="Implements the Session concept when it is in PEER state.">Session_mv</a> (or <a class="el" href="classipc_1_1session_1_1Session.html" title="A documentation-only concept defining the local side of an IPC conversation (session) with another en...">Session</a> concept). </p>

<p class="definition">Definition at line <a class="el" href="session__base_8hpp_source.html#l00132">132</a> of file <a class="el" href="session__base_8hpp_source.html">session_base.hpp</a>.</p>

</div>
</div>
<a id="a4a7a5b83f6ba8bd505685636eabc012b" name="a4a7a5b83f6ba8bd505685636eabc012b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4a7a5b83f6ba8bd505685636eabc012b">&#9670;&nbsp;</a></span>Mdt_builder_ptr</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;schema::MqType S_MQ_TYPE_OR_NONE, bool S_TRANSMIT_NATIVE_HANDLES, typename Mdt_payload &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classipc_1_1session_1_1Session__base.html">ipc::session::Session_base</a>&lt; S_MQ_TYPE_OR_NONE, S_TRANSMIT_NATIVE_HANDLES, Mdt_payload &gt;::Mdt_builder_ptr =  boost::shared_ptr&lt;<a class="el" href="classipc_1_1session_1_1Session__base.html#a7d68bbb8c0c09983619d563bca30bd45">Mdt_builder</a>&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>See <a class="el" href="classipc_1_1session_1_1Session__mv.html" title="Implements the Session concept when it is in PEER state.">Session_mv</a> (or <a class="el" href="classipc_1_1session_1_1Session.html" title="A documentation-only concept defining the local side of an IPC conversation (session) with another en...">Session</a> concept). </p>

<p class="definition">Definition at line <a class="el" href="session__base_8hpp_source.html#l00136">136</a> of file <a class="el" href="session__base_8hpp_source.html">session_base.hpp</a>.</p>

</div>
</div>
<a id="a35234981ca87cc2f6b118b3e52452ea8" name="a35234981ca87cc2f6b118b3e52452ea8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a35234981ca87cc2f6b118b3e52452ea8">&#9670;&nbsp;</a></span>Mdt_payload_obj</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;schema::MqType S_MQ_TYPE_OR_NONE, bool S_TRANSMIT_NATIVE_HANDLES, typename Mdt_payload &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classipc_1_1session_1_1Session__base.html">ipc::session::Session_base</a>&lt; S_MQ_TYPE_OR_NONE, S_TRANSMIT_NATIVE_HANDLES, Mdt_payload &gt;::Mdt_payload_obj =  Mdt_payload</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>See <a class="el" href="classipc_1_1session_1_1Session__mv.html" title="Implements the Session concept when it is in PEER state.">Session_mv</a> (or <a class="el" href="classipc_1_1session_1_1Session.html" title="A documentation-only concept defining the local side of an IPC conversation (session) with another en...">Session</a> concept). </p>

<p class="definition">Definition at line <a class="el" href="session__base_8hpp_source.html#l00125">125</a> of file <a class="el" href="session__base_8hpp_source.html">session_base.hpp</a>.</p>

</div>
</div>
<a id="ace4dab42adec6354cc66081dd218ac71" name="ace4dab42adec6354cc66081dd218ac71"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ace4dab42adec6354cc66081dd218ac71">&#9670;&nbsp;</a></span>Mdt_reader_ptr</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;schema::MqType S_MQ_TYPE_OR_NONE, bool S_TRANSMIT_NATIVE_HANDLES, typename Mdt_payload &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classipc_1_1session_1_1Session__base.html">ipc::session::Session_base</a>&lt; S_MQ_TYPE_OR_NONE, S_TRANSMIT_NATIVE_HANDLES, Mdt_payload &gt;::Mdt_reader_ptr =  boost::shared_ptr&lt;typename transport::struc::schema::Metadata&lt;<a class="el" href="classipc_1_1session_1_1Session__base.html#a35234981ca87cc2f6b118b3e52452ea8">Mdt_payload_obj</a>&gt;::Reader&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>See <a class="el" href="classipc_1_1session_1_1Session__mv.html" title="Implements the Session concept when it is in PEER state.">Session_mv</a> (or <a class="el" href="classipc_1_1session_1_1Session.html" title="A documentation-only concept defining the local side of an IPC conversation (session) with another en...">Session</a> concept). </p>

<p class="definition">Definition at line <a class="el" href="session__base_8hpp_source.html#l00128">128</a> of file <a class="el" href="session__base_8hpp_source.html">session_base.hpp</a>.</p>

</div>
</div>
<a id="a3c0824a54ef32915c5c5ea76481f2409" name="a3c0824a54ef32915c5c5ea76481f2409"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3c0824a54ef32915c5c5ea76481f2409">&#9670;&nbsp;</a></span>On_passive_open_channel_func</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;schema::MqType S_MQ_TYPE_OR_NONE, bool S_TRANSMIT_NATIVE_HANDLES, typename Mdt_payload &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classipc_1_1session_1_1Session__base.html">ipc::session::Session_base</a>&lt; S_MQ_TYPE_OR_NONE, S_TRANSMIT_NATIVE_HANDLES, Mdt_payload &gt;::On_passive_open_channel_func =  <a class="el" href="namespaceipc.html#aa455c7f045059736578ca275fc1a851f">Function</a>&lt;void (<a class="el" href="classipc_1_1session_1_1Session__base.html#a71f02a809d667c23ff8af29a96940bd1">Channel_obj</a>&amp;&amp; new_channel, <a class="el" href="classipc_1_1session_1_1Session__base.html#ace4dab42adec6354cc66081dd218ac71">Mdt_reader_ptr</a>&amp;&amp; new_channel_mdt)&gt;</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Concrete function type for the on-passive-open handler (if any), used for storage. </p>

<p class="definition">Definition at line <a class="el" href="session__base_8hpp_source.html#l00372">372</a> of file <a class="el" href="session__base_8hpp_source.html">session_base.hpp</a>.</p>

</div>
</div>
<a id="a848c0f5247644ada0f8b0ab816eedda8" name="a848c0f5247644ada0f8b0ab816eedda8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a848c0f5247644ada0f8b0ab816eedda8">&#9670;&nbsp;</a></span>Persistent_mq_handle_from_cfg</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;schema::MqType S_MQ_TYPE_OR_NONE, bool S_TRANSMIT_NATIVE_HANDLES, typename Mdt_payload &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classipc_1_1session_1_1Session__base.html">ipc::session::Session_base</a>&lt; S_MQ_TYPE_OR_NONE, S_TRANSMIT_NATIVE_HANDLES, Mdt_payload &gt;::Persistent_mq_handle_from_cfg =  std::conditional_t&lt;!<a class="el" href="classipc_1_1session_1_1Session__base.html#a27a5731a648effb6b4b42f0312affa74">S_MQS_ENABLED</a>, <a class="el" href="classipc_1_1transport_1_1Null__peer.html">transport::Null_peer</a>, std::conditional_t&lt;S_MQ_TYPE_OR_NONE == schema::MqType::POSIX, <a class="el" href="classipc_1_1transport_1_1Posix__mq__handle.html">transport::Posix_mq_handle</a>, <a class="el" href="classipc_1_1transport_1_1Bipc__mq__handle.html">transport::Bipc_mq_handle</a>&gt; &gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Relevant only if <a class="el" href="classipc_1_1session_1_1Session__base.html#a27a5731a648effb6b4b42f0312affa74" title="See Session_mv.">S_MQS_ENABLED</a>, this is the Persistent_mq_handle-concept impl type specified by the user via <code>S_MQ_TYPE_OR_NONE</code>. </p>

<p class="definition">Definition at line <a class="el" href="session__base_8hpp_source.html#l00103">103</a> of file <a class="el" href="session__base_8hpp_source.html">session_base.hpp</a>.</p>

</div>
</div>
<a id="aee0db48505c84d3553b7110a9a815036" name="aee0db48505c84d3553b7110a9a815036"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aee0db48505c84d3553b7110a9a815036">&#9670;&nbsp;</a></span>Structured_msg_builder_config</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;schema::MqType S_MQ_TYPE_OR_NONE, bool S_TRANSMIT_NATIVE_HANDLES, typename Mdt_payload &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classipc_1_1session_1_1Session__base.html">ipc::session::Session_base</a>&lt; S_MQ_TYPE_OR_NONE, S_TRANSMIT_NATIVE_HANDLES, Mdt_payload &gt;::Structured_msg_builder_config =  <a class="el" href="structipc_1_1transport_1_1struc_1_1Heap__fixed__builder_1_1Config.html">transport::struc::Heap_fixed_builder::Config</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>See <a class="el" href="classipc_1_1session_1_1Session__mv.html" title="Implements the Session concept when it is in PEER state.">Session_mv</a> (or <a class="el" href="classipc_1_1session_1_1Session.html" title="A documentation-only concept defining the local side of an IPC conversation (session) with another en...">Session</a> concept). </p>

<p class="definition">Definition at line <a class="el" href="session__base_8hpp_source.html#l00139">139</a> of file <a class="el" href="session__base_8hpp_source.html">session_base.hpp</a>.</p>

</div>
</div>
<a id="abd854f2b9316361ef18f15610c242d4b" name="abd854f2b9316361ef18f15610c242d4b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abd854f2b9316361ef18f15610c242d4b">&#9670;&nbsp;</a></span>Structured_msg_reader_config</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;schema::MqType S_MQ_TYPE_OR_NONE, bool S_TRANSMIT_NATIVE_HANDLES, typename Mdt_payload &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classipc_1_1session_1_1Session__base.html">ipc::session::Session_base</a>&lt; S_MQ_TYPE_OR_NONE, S_TRANSMIT_NATIVE_HANDLES, Mdt_payload &gt;::Structured_msg_reader_config =  <a class="el" href="structipc_1_1transport_1_1struc_1_1Heap__reader_1_1Config.html">transport::struc::Heap_reader::Config</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>See <a class="el" href="classipc_1_1session_1_1Session__mv.html" title="Implements the Session concept when it is in PEER state.">Session_mv</a> (or <a class="el" href="classipc_1_1session_1_1Session.html" title="A documentation-only concept defining the local side of an IPC conversation (session) with another en...">Session</a> concept). </p>

<p class="definition">Definition at line <a class="el" href="session__base_8hpp_source.html#l00142">142</a> of file <a class="el" href="session__base_8hpp_source.html">session_base.hpp</a>.</p>

</div>
</div>
<h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="aab2db8b2cdb3d8189c1cc497aed7b2b1" name="aab2db8b2cdb3d8189c1cc497aed7b2b1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aab2db8b2cdb3d8189c1cc497aed7b2b1">&#9670;&nbsp;</a></span>Session_base() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;schema::MqType S_MQ_TYPE_OR_NONE, bool S_TRANSMIT_NATIVE_HANDLES, typename Mdt_payload &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classipc_1_1session_1_1Session__base.html">ipc::session::Session_base</a>&lt; S_MQ_TYPE_OR_NONE, S_TRANSMIT_NATIVE_HANDLES, Mdt_payload &gt;::Session_base </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structipc_1_1session_1_1Client__app.html">Client_app</a> &amp;&#160;</td>
          <td class="paramname"><em>cli_app_ref</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structipc_1_1session_1_1Server__app.html">Server_app</a> &amp;&#160;</td>
          <td class="paramname"><em>srv_app_ref</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">flow::async::Task_asio_err &amp;&amp;&#160;</td>
          <td class="paramname"><em>on_err_func</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classipc_1_1session_1_1Session__base.html#a3c0824a54ef32915c5c5ea76481f2409">On_passive_open_channel_func</a> &amp;&amp;&#160;</td>
          <td class="paramname"><em>on_passive_open_channel_func_or_empty_arg</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">explicit</span><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Constructs: <a class="el" href="classipc_1_1session_1_1Client__session__impl.html" title="Internal, non-movable pImpl-lite implementation of Client_session_mv class template.">Client_session_impl</a> form (the user is the one constructing the object, though in NULL state). </p>
<p >The values taken as args are set permanently (undefined behavior/assertion may trip if an attempt is made to modify one via mutator). The remaining values must be set via mutator before PEER state.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">cli_app_ref</td><td>See <a class="el" href="classipc_1_1session_1_1Session__base.html#a3ebdafe7e70719e6d12dd0b15ae85106" title="See Server_session_impl, Client_session_impl.">cli_app_ptr()</a>. </td></tr>
    <tr><td class="paramname">srv_app_ref</td><td>See <a class="el" href="classipc_1_1session_1_1Session__base.html#afd32d90b86d699263a0f02637dd7c6c6" title="Reference to Server_app (referring to local process in Server_session_impl, opposing process in Clien...">m_srv_app_ref</a>. </td></tr>
    <tr><td class="paramname">on_err_func</td><td>On-error handler from user. </td></tr>
    <tr><td class="paramname">on_passive_open_channel_func_or_empty_arg</td><td>On-passive-open handler from user (empty if user wishes the disable passive-opens on this side). </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="session__base_8hpp_source.html#l00819">819</a> of file <a class="el" href="session__base_8hpp_source.html">session_base.hpp</a>.</p>

</div>
</div>
<a id="a8d323ca75006777b3fc929bd0720f7df" name="a8d323ca75006777b3fc929bd0720f7df"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8d323ca75006777b3fc929bd0720f7df">&#9670;&nbsp;</a></span>Session_base() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;schema::MqType S_MQ_TYPE_OR_NONE, bool S_TRANSMIT_NATIVE_HANDLES, typename Mdt_payload &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classipc_1_1session_1_1Session__base.html">ipc::session::Session_base</a>&lt; S_MQ_TYPE_OR_NONE, S_TRANSMIT_NATIVE_HANDLES, Mdt_payload &gt;::Session_base </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structipc_1_1session_1_1Server__app.html">Server_app</a> &amp;&#160;</td>
          <td class="paramname"><em>srv_app_ref</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">explicit</span><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Constructs: <a class="el" href="classipc_1_1session_1_1Server__session__impl.html" title="Internal, non-movable pImpl-lite implementation of Server_session_mv class template.">Server_session_impl</a> form (<a class="el" href="classipc_1_1session_1_1Session__server.html" title="To be instantiated typically once in a given process, an object of this type asynchronously listens f...">Session_server</a> is the one constructing the object, though in NULL state, before log-in has completed, but after the socket-stream connection has been established). </p>
<p >The values taken as args are set permanently (undefined behavior/assertion may trip if an attempt is made to modify one via mutator). The remaining values must be set via mutator before PEER state.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">srv_app_ref</td><td>See <a class="el" href="classipc_1_1session_1_1Session__base.html#afd32d90b86d699263a0f02637dd7c6c6" title="Reference to Server_app (referring to local process in Server_session_impl, opposing process in Clien...">m_srv_app_ref</a>. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="session__base_8hpp_source.html#l00838">838</a> of file <a class="el" href="session__base_8hpp_source.html">session_base.hpp</a>.</p>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="a3ebdafe7e70719e6d12dd0b15ae85106" name="a3ebdafe7e70719e6d12dd0b15ae85106"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3ebdafe7e70719e6d12dd0b15ae85106">&#9670;&nbsp;</a></span>cli_app_ptr()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;schema::MqType S_MQ_TYPE_OR_NONE, bool S_TRANSMIT_NATIVE_HANDLES, typename Mdt_payload &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="structipc_1_1session_1_1Client__app.html">Client_app</a> * <a class="el" href="classipc_1_1session_1_1Session__base.html">ipc::session::Session_base</a>&lt; S_MQ_TYPE_OR_NONE, S_TRANSMIT_NATIVE_HANDLES, Mdt_payload &gt;::cli_app_ptr</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>See <a class="el" href="classipc_1_1session_1_1Server__session__impl.html" title="Internal, non-movable pImpl-lite implementation of Server_session_mv class template.">Server_session_impl</a>, <a class="el" href="classipc_1_1session_1_1Client__session__impl.html" title="Internal, non-movable pImpl-lite implementation of Client_session_mv class template.">Client_session_impl</a>. </p>
<p >However in <a class="el" href="classipc_1_1session_1_1Session__base.html" title="Internal type containing data and types common to internal types Server_session_impl and Client_sessi...">Session_base</a> this value may be not-yet-set (null), or set (and immutable from then on). Note the value to which we refer is the actual pointer. (The <a class="el" href="structipc_1_1session_1_1Client__app.html" title="An App that is used as a client in at least one client-server IPC split.">Client_app</a> that is pointed-to, itself, is certainly immutable too.)</p>
<p >This value shall be set from the start in a <a class="el" href="classipc_1_1session_1_1Client__session__impl.html" title="Internal, non-movable pImpl-lite implementation of Client_session_mv class template.">Client_session_impl</a> but determined during a given <a class="el" href="classipc_1_1session_1_1Server__session__impl.html" title="Internal, non-movable pImpl-lite implementation of Server_session_mv class template.">Server_session_impl</a>'s log-in (the opposing <a class="el" href="classipc_1_1session_1_1Client__session__impl.html" title="Internal, non-movable pImpl-lite implementation of Client_session_mv class template.">Client_session_impl</a> will transmit the <a class="el" href="structipc_1_1session_1_1App.html#a8e67b57829fe43a122a23c699b5de8fd" title="Brief application name, readable to humans and unique across all other applications&#39; names; used both...">Client_app::m_name</a>). The log-in shall complete the <code>Server_session</code>'s entry to PEER state.</p>
<dl class="section return"><dt>Returns</dt><dd>See above. </dd></dl>

<p class="definition">Definition at line <a class="el" href="session__base_8hpp_source.html#l00906">906</a> of file <a class="el" href="session__base_8hpp_source.html">session_base.hpp</a>.</p>

</div>
</div>
<a id="abd1e814b3b640f4bdaa2553352405f26" name="abd1e814b3b640f4bdaa2553352405f26"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abd1e814b3b640f4bdaa2553352405f26">&#9670;&nbsp;</a></span>cli_namespace()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;schema::MqType S_MQ_TYPE_OR_NONE, bool S_TRANSMIT_NATIVE_HANDLES, typename Mdt_payload &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="namespaceipc_1_1session.html#a6d07d9996af19e57eb42416e914110ea">Shared_name</a> &amp; <a class="el" href="classipc_1_1session_1_1Session__base.html">ipc::session::Session_base</a>&lt; S_MQ_TYPE_OR_NONE, S_TRANSMIT_NATIVE_HANDLES, Mdt_payload &gt;::cli_namespace</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>See <a class="el" href="classipc_1_1session_1_1Server__session__impl.html" title="Internal, non-movable pImpl-lite implementation of Server_session_mv class template.">Server_session_impl</a>, <a class="el" href="classipc_1_1session_1_1Client__session__impl.html" title="Internal, non-movable pImpl-lite implementation of Client_session_mv class template.">Client_session_impl</a>. </p>
<p >However in <a class="el" href="classipc_1_1session_1_1Session__base.html" title="Internal type containing data and types common to internal types Server_session_impl and Client_sessi...">Session_base</a> this value may be not-yet-set (empty), or set (and immutable from then on).</p>
<p >This value shall be generated uniquely (within some context) for each new <code>Server_session</code> produced by <a class="el" href="classipc_1_1session_1_1Session__server.html" title="To be instantiated typically once in a given process, an object of this type asynchronously listens f...">Session_server</a>; and <a class="el" href="classipc_1_1session_1_1Client__session__impl.html" title="Internal, non-movable pImpl-lite implementation of Client_session_mv class template.">Client_session_impl</a> shall find that out while logging in (last part of entering PEER state).</p>
<dl class="section return"><dt>Returns</dt><dd>See above. </dd></dl>

<p class="definition">Definition at line <a class="el" href="session__base_8hpp_source.html#l00918">918</a> of file <a class="el" href="session__base_8hpp_source.html">session_base.hpp</a>.</p>

</div>
</div>
<a id="af059faab56cdf384873f9f2aba8f79cf" name="af059faab56cdf384873f9f2aba8f79cf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af059faab56cdf384873f9f2aba8f79cf">&#9670;&nbsp;</a></span>cur_ns_store_absolute_path()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;schema::MqType S_MQ_TYPE_OR_NONE, bool S_TRANSMIT_NATIVE_HANDLES, typename Mdt_payload &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">fs::path <a class="el" href="classipc_1_1session_1_1Session__base.html">ipc::session::Session_base</a>&lt; S_MQ_TYPE_OR_NONE, S_TRANSMIT_NATIVE_HANDLES, Mdt_payload &gt;::cur_ns_store_absolute_path</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Computes the absolute path to file storing (written by server, read by client) the value for <a class="el" href="classipc_1_1session_1_1Session__base.html#a4d1327608d6067ed6690bd4efa323c6f" title="See Server_session_impl, Client_session_impl.">srv_namespace()</a>. </p>
<p >The file is located as <a class="el" href="classipc_1_1session_1_1Session__base.html#af059faab56cdf384873f9f2aba8f79cf" title="Computes the absolute path to file storing (written by server, read by client) the value for srv_name...">cur_ns_store_absolute_path()</a>.</p>
<p >This may be called anytime.</p>
<dl class="section return"><dt>Returns</dt><dd>See above. </dd></dl>

<p class="definition">Definition at line <a class="el" href="session__base_8hpp_source.html#l00986">986</a> of file <a class="el" href="session__base_8hpp_source.html">session_base.hpp</a>.</p>

<p class="reference">References <a class="el" href="ipc__core_2src_2ipc_2util_2detail_2util_8cpp_source.html#l00063">ipc::util::IPC_KERNEL_PERSISTENT_RUN_DIR</a>.</p>

</div>
</div>
<a id="a09cbe99083616bae00928f8e37c8373b" name="a09cbe99083616bae00928f8e37c8373b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a09cbe99083616bae00928f8e37c8373b">&#9670;&nbsp;</a></span>cur_ns_store_mutex_absolute_name()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;schema::MqType S_MQ_TYPE_OR_NONE, bool S_TRANSMIT_NATIVE_HANDLES, typename Mdt_payload &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespaceipc_1_1session.html#a6d07d9996af19e57eb42416e914110ea">Shared_name</a> <a class="el" href="classipc_1_1session_1_1Session__base.html">ipc::session::Session_base</a>&lt; S_MQ_TYPE_OR_NONE, S_TRANSMIT_NATIVE_HANDLES, Mdt_payload &gt;::cur_ns_store_mutex_absolute_name</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Computes the name of the interprocess named-mutex used to control reading/writing to the file storing (written by server, read by client) the value for <a class="el" href="classipc_1_1session_1_1Session__base.html#a4d1327608d6067ed6690bd4efa323c6f" title="See Server_session_impl, Client_session_impl.">srv_namespace()</a>. </p>
<p >The file is located as <a class="el" href="classipc_1_1session_1_1Session__base.html#af059faab56cdf384873f9f2aba8f79cf" title="Computes the absolute path to file storing (written by server, read by client) the value for srv_name...">cur_ns_store_absolute_path()</a>.</p>
<p >This may be called anytime.</p>
<dl class="section return"><dt>Returns</dt><dd>See above. </dd></dl>

<p class="definition">Definition at line <a class="el" href="session__base_8hpp_source.html#l00953">953</a> of file <a class="el" href="session__base_8hpp_source.html">session_base.hpp</a>.</p>

<p class="reference">References <a class="el" href="ipc__session_2src_2ipc_2session_2detail_2session__shared__name_8cpp_source.html#l00044">ipc::session::build_conventional_shared_name()</a>, <a class="el" href="shared__name_8hpp_source.html#l00674">ipc::util::Shared_name::ct()</a>, <a class="el" href="shared__name_8hpp_source.html#l00315">ipc::util::Shared_name::S_RESOURCE_TYPE_ID_MUTEX</a>, and <a class="el" href="shared__name_8hpp_source.html#l00280">ipc::util::Shared_name::S_SENTINEL</a>.</p>
<div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="classipc_1_1session_1_1Session__base_a09cbe99083616bae00928f8e37c8373b_cgraph.svg" width="788" height="132"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe>
</div>
</div>

</div>
</div>
<a id="a08b3d69a6707dcbb233076b7a48de285" name="a08b3d69a6707dcbb233076b7a48de285"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a08b3d69a6707dcbb233076b7a48de285">&#9670;&nbsp;</a></span>heap_fixed_builder_config()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;schema::MqType S_MQ_TYPE_OR_NONE, bool S_TRANSMIT_NATIVE_HANDLES, typename Mdt_payload &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classipc_1_1session_1_1Session__base.html">Session_base</a>&lt; S_MQ_TYPE_OR_NONE, S_TRANSMIT_NATIVE_HANDLES, Mdt_payload &gt;<a class="el" href="classipc_1_1session_1_1Session__base.html#aee0db48505c84d3553b7110a9a815036">::Structured_msg_builder_config</a> <a class="el" href="classipc_1_1session_1_1Session__base.html">ipc::session::Session_base</a>&lt; S_MQ_TYPE_OR_NONE, S_TRANSMIT_NATIVE_HANDLES, Mdt_payload &gt;::heap_fixed_builder_config </td>
          <td>(</td>
          <td class="paramtype">flow::log::Logger *&#160;</td>
          <td class="paramname"><em>logger_ptr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>See <a class="el" href="classipc_1_1session_1_1Session__mv.html#a107684fdd5d233549c6daac26a81a542" title="Utility that obtains a heap-based (non-zero-copy) Struct_builder::Config, constructed with the most e...">Session_mv::heap_fixed_builder_config()</a> (1-arg). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">logger_ptr</td><td>See above. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>See above. </dd></dl>

<p class="definition">Definition at line <a class="el" href="session__base_8hpp_source.html#l01020">1020</a> of file <a class="el" href="session__base_8hpp_source.html">session_base.hpp</a>.</p>

</div>
</div>
<a id="a489bb6ec7726e39e78dcd4dd2fe3de75" name="a489bb6ec7726e39e78dcd4dd2fe3de75"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a489bb6ec7726e39e78dcd4dd2fe3de75">&#9670;&nbsp;</a></span>heap_reader_config()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;schema::MqType S_MQ_TYPE_OR_NONE, bool S_TRANSMIT_NATIVE_HANDLES, typename Mdt_payload &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classipc_1_1session_1_1Session__base.html">Session_base</a>&lt; S_MQ_TYPE_OR_NONE, S_TRANSMIT_NATIVE_HANDLES, Mdt_payload &gt;<a class="el" href="classipc_1_1session_1_1Session__base.html#abd854f2b9316361ef18f15610c242d4b">::Structured_msg_reader_config</a> <a class="el" href="classipc_1_1session_1_1Session__base.html">ipc::session::Session_base</a>&lt; S_MQ_TYPE_OR_NONE, S_TRANSMIT_NATIVE_HANDLES, Mdt_payload &gt;::heap_reader_config </td>
          <td>(</td>
          <td class="paramtype">flow::log::Logger *&#160;</td>
          <td class="paramname"><em>logger_ptr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>See <a class="el" href="classipc_1_1session_1_1Session__mv.html#ab3c69e3f8ccbd70d315bed86d697255d" title="Deserializing counterpart to non-static heap_fixed_builder_config().">Session_mv::heap_reader_config()</a> (1-arg). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">logger_ptr</td><td>See above. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>See above. </dd></dl>

<p class="definition">Definition at line <a class="el" href="session__base_8hpp_source.html#l01165">1165</a> of file <a class="el" href="session__base_8hpp_source.html">session_base.hpp</a>.</p>

</div>
</div>
<a id="a7f9e67dccbab4f3191734c2834bafb63" name="a7f9e67dccbab4f3191734c2834bafb63"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7f9e67dccbab4f3191734c2834bafb63">&#9670;&nbsp;</a></span>hose()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;schema::MqType S_MQ_TYPE_OR_NONE, bool S_TRANSMIT_NATIVE_HANDLES, typename Mdt_payload &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classipc_1_1session_1_1Session__base.html">ipc::session::Session_base</a>&lt; S_MQ_TYPE_OR_NONE, S_TRANSMIT_NATIVE_HANDLES, Mdt_payload &gt;::hose </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespaceipc.html#aa3192e586cc45d3e7c22463bf2760f89">Error_code</a> &amp;&#160;</td>
          <td class="paramname"><em>err_code</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Marks this session as hosed for (truthy) reason <code>err_code</code>; and <em>synchronously</em> invokes on-error handler; only invoke if not already <a class="el" href="classipc_1_1session_1_1Session__base.html#a398f3e6a30b3fae8e110af9fd1ff75e3" title="Returns true if and only if hose() has been called.">hosed()</a>. </p>
<p >This utility is important and has certain pre-conditions (behavior undefined if not met; assertion may trip):</p><ul>
<li><code>*this</code> must be in PEER state. In particular <a class="el" href="classipc_1_1session_1_1Session__base.html#aca82817beaac36d0006c44012f9fef03" title="Returns true if and only if set_on_err_func() has been called.">on_err_func_set()</a> must return <code>true</code>.</li>
<li><a class="el" href="classipc_1_1session_1_1Session__base.html#a398f3e6a30b3fae8e110af9fd1ff75e3" title="Returns true if and only if hose() has been called.">hosed()</a> must return <code>false</code>.</li>
<li><code>err_code</code> must be truthy (non-success).</li>
<li>This must be invoked from a thread such that it is OK to <em>synchronously</em> invoke on-error handler. As of this writing this is <a class="el" href="classipc_1_1session_1_1Server__session__impl.html" title="Internal, non-movable pImpl-lite implementation of Server_session_mv class template.">Server_session_impl</a>'s or <a class="el" href="classipc_1_1session_1_1Client__session__impl.html" title="Internal, non-movable pImpl-lite implementation of Client_session_mv class template.">Client_session_impl</a>'s thread W in practice, which is how thread safety of <a class="el" href="classipc_1_1session_1_1Session__base.html#a7f9e67dccbab4f3191734c2834bafb63" title="Marks this session as hosed for (truthy) reason err_code; and synchronously invokes on-error handler;...">hose()</a> versus <a class="el" href="classipc_1_1session_1_1Session__base.html#a398f3e6a30b3fae8e110af9fd1ff75e3" title="Returns true if and only if hose() has been called.">hosed()</a> is also guaranteed by those users.</li>
</ul>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">err_code</td><td>Truthy error. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="session__base_8hpp_source.html#l00937">937</a> of file <a class="el" href="session__base_8hpp_source.html">session_base.hpp</a>.</p>

<p class="reference">Referenced by <a class="el" href="session__base_8hpp_source.html#l01070">ipc::session::Session_base&lt; S_MQ_TYPE_OR_NONE, S_TRANSMIT_NATIVE_HANDLES, Mdt_payload &gt;::Graceful_finisher::Graceful_finisher()</a>.</p>
<div class="dynheader">
Here is the caller graph for this function:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="classipc_1_1session_1_1Session__base_a7f9e67dccbab4f3191734c2834bafb63_icgraph.svg" width="352" height="59"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe>
</div>
</div>

</div>
</div>
<a id="a398f3e6a30b3fae8e110af9fd1ff75e3" name="a398f3e6a30b3fae8e110af9fd1ff75e3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a398f3e6a30b3fae8e110af9fd1ff75e3">&#9670;&nbsp;</a></span>hosed()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;schema::MqType S_MQ_TYPE_OR_NONE, bool S_TRANSMIT_NATIVE_HANDLES, typename Mdt_payload &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classipc_1_1session_1_1Session__base.html">ipc::session::Session_base</a>&lt; S_MQ_TYPE_OR_NONE, S_TRANSMIT_NATIVE_HANDLES, Mdt_payload &gt;::hosed</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns <code>true</code> if and only if <a class="el" href="classipc_1_1session_1_1Session__base.html#a7f9e67dccbab4f3191734c2834bafb63" title="Marks this session as hosed for (truthy) reason err_code; and synchronously invokes on-error handler;...">hose()</a> has been called. </p>
<p >If so then <a class="el" href="classipc_1_1session_1_1Session__base.html#a7d25e45d33beb8af9ae03b05d676b0e4" title="See set_on_err_func().">m_on_err_func</a> has been executed already. <code>*this</code> must be in PEER state. In particular <a class="el" href="classipc_1_1session_1_1Session__base.html#aca82817beaac36d0006c44012f9fef03" title="Returns true if and only if set_on_err_func() has been called.">on_err_func_set()</a> must return <code>true</code>.</p>
<dl class="section return"><dt>Returns</dt><dd>Ditto. </dd></dl>

<p class="definition">Definition at line <a class="el" href="session__base_8hpp_source.html#l00946">946</a> of file <a class="el" href="session__base_8hpp_source.html">session_base.hpp</a>.</p>

<p class="reference">Referenced by <a class="el" href="session__base_8hpp_source.html#l01070">ipc::session::Session_base&lt; S_MQ_TYPE_OR_NONE, S_TRANSMIT_NATIVE_HANDLES, Mdt_payload &gt;::Graceful_finisher::Graceful_finisher()</a>.</p>
<div class="dynheader">
Here is the caller graph for this function:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="classipc_1_1session_1_1Session__base_a398f3e6a30b3fae8e110af9fd1ff75e3_icgraph.svg" width="352" height="59"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe>
</div>
</div>

</div>
</div>
<a id="aca82817beaac36d0006c44012f9fef03" name="aca82817beaac36d0006c44012f9fef03"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aca82817beaac36d0006c44012f9fef03">&#9670;&nbsp;</a></span>on_err_func_set()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;schema::MqType S_MQ_TYPE_OR_NONE, bool S_TRANSMIT_NATIVE_HANDLES, typename Mdt_payload &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classipc_1_1session_1_1Session__base.html">ipc::session::Session_base</a>&lt; S_MQ_TYPE_OR_NONE, S_TRANSMIT_NATIVE_HANDLES, Mdt_payload &gt;::on_err_func_set</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns <code>true</code> if and only if <a class="el" href="classipc_1_1session_1_1Session__base.html#ae769a82bdec0d16702111ad06716faae" title="Sets on_err_func() (do not call if already set).">set_on_err_func()</a> has been called. </p>
<dl class="section return"><dt>Returns</dt><dd>See above. </dd></dl>

<p class="definition">Definition at line <a class="el" href="session__base_8hpp_source.html#l00931">931</a> of file <a class="el" href="session__base_8hpp_source.html">session_base.hpp</a>.</p>

</div>
</div>
<a id="a21b146b02d257d95f4aaeaca12b8d320" name="a21b146b02d257d95f4aaeaca12b8d320"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a21b146b02d257d95f4aaeaca12b8d320">&#9670;&nbsp;</a></span>on_passive_open_channel_func_or_empty()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;schema::MqType S_MQ_TYPE_OR_NONE, bool S_TRANSMIT_NATIVE_HANDLES, typename Mdt_payload &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classipc_1_1session_1_1Session__base.html">Session_base</a>&lt; S_MQ_TYPE_OR_NONE, S_TRANSMIT_NATIVE_HANDLES, Mdt_payload &gt;<a class="el" href="classipc_1_1session_1_1Session__base.html#a3c0824a54ef32915c5c5ea76481f2409">::On_passive_open_channel_func</a> &amp; <a class="el" href="classipc_1_1session_1_1Session__base.html">ipc::session::Session_base</a>&lt; S_MQ_TYPE_OR_NONE, S_TRANSMIT_NATIVE_HANDLES, Mdt_payload &gt;::on_passive_open_channel_func_or_empty</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>The on-passive-open handler (may be empty even in final state, meaning user wants passive-opens disabled on this side). </p>
<dl class="section return"><dt>Returns</dt><dd>See above. </dd></dl>

<p class="definition">Definition at line <a class="el" href="session__base_8hpp_source.html#l00925">925</a> of file <a class="el" href="session__base_8hpp_source.html">session_base.hpp</a>.</p>

</div>
</div>
<a id="a3d34c5a9c283a6b7c8ab943f344cdd28" name="a3d34c5a9c283a6b7c8ab943f344cdd28"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3d34c5a9c283a6b7c8ab943f344cdd28">&#9670;&nbsp;</a></span>session_master_socket_stream_acceptor_absolute_name()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;schema::MqType S_MQ_TYPE_OR_NONE, bool S_TRANSMIT_NATIVE_HANDLES, typename Mdt_payload &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespaceipc_1_1session.html#a6d07d9996af19e57eb42416e914110ea">Shared_name</a> <a class="el" href="classipc_1_1session_1_1Session__base.html">ipc::session::Session_base</a>&lt; S_MQ_TYPE_OR_NONE, S_TRANSMIT_NATIVE_HANDLES, Mdt_payload &gt;::session_master_socket_stream_acceptor_absolute_name</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Computes the absolute name at which the server shall set up a <a class="el" href="classipc_1_1transport_1_1Native__socket__stream__acceptor.html" title="A server object that binds to a Shared_name and listens for incoming Native_socket_stream connect att...">transport::Native_socket_stream_acceptor</a> to which client shall <a class="el" href="classipc_1_1transport_1_1Native__socket__stream.html#a89d591db714e83dcb55a52738fed1ebb" title="To be invoked in NULL state only, it synchronously and non-blockingly attempts to connect to an oppos...">transport::Native_socket_stream::sync_connect()</a> in order to establish a PEER-state session. </p>
<p >This must be called no earlier than <a class="el" href="classipc_1_1session_1_1Session__base.html#a28825fcdeaf1249a7bf810a3b2ca7c38" title="Sets srv_namespace() (do not call if already set).">set_srv_namespace()</a>; otherwise behavior undefined (assertion may trip).</p>
<dl class="section return"><dt>Returns</dt><dd>See above. </dd></dl>

<p class="definition">Definition at line <a class="el" href="session__base_8hpp_source.html#l00999">999</a> of file <a class="el" href="session__base_8hpp_source.html">session_base.hpp</a>.</p>

<p class="reference">References <a class="el" href="ipc__session_2src_2ipc_2session_2detail_2session__shared__name_8cpp_source.html#l00044">ipc::session::build_conventional_shared_name()</a>, <a class="el" href="shared__name_8hpp_source.html#l00674">ipc::util::Shared_name::ct()</a>, <a class="el" href="native__socket__stream__acceptor_8hpp_source.html#l00120">ipc::transport::Native_socket_stream_acceptor::S_RESOURCE_TYPE_ID</a>, and <a class="el" href="shared__name_8hpp_source.html#l00280">ipc::util::Shared_name::S_SENTINEL</a>.</p>
<div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="classipc_1_1session_1_1Session__base_a3d34c5a9c283a6b7c8ab943f344cdd28_cgraph.svg" width="779" height="132"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe>
</div>
</div>

</div>
</div>
<a id="a60a081ce0f85651202d23b4d543d093c" name="a60a081ce0f85651202d23b4d543d093c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a60a081ce0f85651202d23b4d543d093c">&#9670;&nbsp;</a></span>set_cli_app_ptr()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;schema::MqType S_MQ_TYPE_OR_NONE, bool S_TRANSMIT_NATIVE_HANDLES, typename Mdt_payload &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classipc_1_1session_1_1Session__base.html">ipc::session::Session_base</a>&lt; S_MQ_TYPE_OR_NONE, S_TRANSMIT_NATIVE_HANDLES, Mdt_payload &gt;::set_cli_app_ptr </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structipc_1_1session_1_1Client__app.html">Client_app</a> *&#160;</td>
          <td class="paramname"><em>cli_app_ptr_new</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sets <a class="el" href="classipc_1_1session_1_1Session__base.html#a3ebdafe7e70719e6d12dd0b15ae85106" title="See Server_session_impl, Client_session_impl.">cli_app_ptr()</a> (do not call if already set). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">cli_app_ptr_new</td><td>Value. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="session__base_8hpp_source.html#l00857">857</a> of file <a class="el" href="session__base_8hpp_source.html">session_base.hpp</a>.</p>

</div>
</div>
<a id="a8cc7a4faa098e0f71c737f44c34d593c" name="a8cc7a4faa098e0f71c737f44c34d593c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8cc7a4faa098e0f71c737f44c34d593c">&#9670;&nbsp;</a></span>set_cli_namespace()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;schema::MqType S_MQ_TYPE_OR_NONE, bool S_TRANSMIT_NATIVE_HANDLES, typename Mdt_payload &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classipc_1_1session_1_1Session__base.html">ipc::session::Session_base</a>&lt; S_MQ_TYPE_OR_NONE, S_TRANSMIT_NATIVE_HANDLES, Mdt_payload &gt;::set_cli_namespace </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespaceipc_1_1session.html#a6d07d9996af19e57eb42416e914110ea">Shared_name</a> &amp;&amp;&#160;</td>
          <td class="paramname"><em>cli_namespace_new</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sets <a class="el" href="classipc_1_1session_1_1Session__base.html#abd1e814b3b640f4bdaa2553352405f26" title="See Server_session_impl, Client_session_impl.">cli_namespace()</a> (do not call if already set). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">cli_namespace_new</td><td>Value. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="session__base_8hpp_source.html#l00880">880</a> of file <a class="el" href="session__base_8hpp_source.html">session_base.hpp</a>.</p>

<p class="reference">References <a class="el" href="shared__name_8hpp_source.html#l00280">ipc::util::Shared_name::S_SENTINEL</a>.</p>

</div>
</div>
<a id="ae769a82bdec0d16702111ad06716faae" name="ae769a82bdec0d16702111ad06716faae"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae769a82bdec0d16702111ad06716faae">&#9670;&nbsp;</a></span>set_on_err_func()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;schema::MqType S_MQ_TYPE_OR_NONE, bool S_TRANSMIT_NATIVE_HANDLES, typename Mdt_payload &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classipc_1_1session_1_1Session__base.html">ipc::session::Session_base</a>&lt; S_MQ_TYPE_OR_NONE, S_TRANSMIT_NATIVE_HANDLES, Mdt_payload &gt;::set_on_err_func </td>
          <td>(</td>
          <td class="paramtype">flow::async::Task_asio_err &amp;&amp;&#160;</td>
          <td class="paramname"><em>on_err_func_arg</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sets on_err_func() (do not call if already set). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">on_err_func_arg</td><td>Value. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="session__base_8hpp_source.html#l00897">897</a> of file <a class="el" href="session__base_8hpp_source.html">session_base.hpp</a>.</p>

</div>
</div>
<a id="a3be1a385c905404621b58c23332b0b96" name="a3be1a385c905404621b58c23332b0b96"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3be1a385c905404621b58c23332b0b96">&#9670;&nbsp;</a></span>set_on_passive_open_channel_func()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;schema::MqType S_MQ_TYPE_OR_NONE, bool S_TRANSMIT_NATIVE_HANDLES, typename Mdt_payload &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classipc_1_1session_1_1Session__base.html">ipc::session::Session_base</a>&lt; S_MQ_TYPE_OR_NONE, S_TRANSMIT_NATIVE_HANDLES, Mdt_payload &gt;::set_on_passive_open_channel_func </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classipc_1_1session_1_1Session__base.html#a3c0824a54ef32915c5c5ea76481f2409">On_passive_open_channel_func</a> &amp;&amp;&#160;</td>
          <td class="paramname"><em>on_passive_open_channel_func</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sets <a class="el" href="classipc_1_1session_1_1Session__base.html#a21b146b02d257d95f4aaeaca12b8d320" title="The on-passive-open handler (may be empty even in final state, meaning user wants passive-opens disab...">on_passive_open_channel_func_or_empty()</a> (do not call if already set; do not call if user intends for passive-opens to be disabled on this side). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">on_passive_open_channel_func</td><td>Value. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="session__base_8hpp_source.html#l00890">890</a> of file <a class="el" href="session__base_8hpp_source.html">session_base.hpp</a>.</p>

</div>
</div>
<a id="a28825fcdeaf1249a7bf810a3b2ca7c38" name="a28825fcdeaf1249a7bf810a3b2ca7c38"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a28825fcdeaf1249a7bf810a3b2ca7c38">&#9670;&nbsp;</a></span>set_srv_namespace()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;schema::MqType S_MQ_TYPE_OR_NONE, bool S_TRANSMIT_NATIVE_HANDLES, typename Mdt_payload &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classipc_1_1session_1_1Session__base.html">ipc::session::Session_base</a>&lt; S_MQ_TYPE_OR_NONE, S_TRANSMIT_NATIVE_HANDLES, Mdt_payload &gt;::set_srv_namespace </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespaceipc_1_1session.html#a6d07d9996af19e57eb42416e914110ea">Shared_name</a> &amp;&amp;&#160;</td>
          <td class="paramname"><em>srv_namespace_new</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sets <a class="el" href="classipc_1_1session_1_1Session__base.html#a4d1327608d6067ed6690bd4efa323c6f" title="See Server_session_impl, Client_session_impl.">srv_namespace()</a> (do not call if already set). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">srv_namespace_new</td><td>Value. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="session__base_8hpp_source.html#l00870">870</a> of file <a class="el" href="session__base_8hpp_source.html">session_base.hpp</a>.</p>

<p class="reference">References <a class="el" href="shared__name_8hpp_source.html#l00280">ipc::util::Shared_name::S_SENTINEL</a>.</p>

</div>
</div>
<a id="a4d1327608d6067ed6690bd4efa323c6f" name="a4d1327608d6067ed6690bd4efa323c6f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4d1327608d6067ed6690bd4efa323c6f">&#9670;&nbsp;</a></span>srv_namespace()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;schema::MqType S_MQ_TYPE_OR_NONE, bool S_TRANSMIT_NATIVE_HANDLES, typename Mdt_payload &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="namespaceipc_1_1session.html#a6d07d9996af19e57eb42416e914110ea">Shared_name</a> &amp; <a class="el" href="classipc_1_1session_1_1Session__base.html">ipc::session::Session_base</a>&lt; S_MQ_TYPE_OR_NONE, S_TRANSMIT_NATIVE_HANDLES, Mdt_payload &gt;::srv_namespace</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>See <a class="el" href="classipc_1_1session_1_1Server__session__impl.html" title="Internal, non-movable pImpl-lite implementation of Server_session_mv class template.">Server_session_impl</a>, <a class="el" href="classipc_1_1session_1_1Client__session__impl.html" title="Internal, non-movable pImpl-lite implementation of Client_session_mv class template.">Client_session_impl</a>. </p>
<p >However in <a class="el" href="classipc_1_1session_1_1Session__base.html" title="Internal type containing data and types common to internal types Server_session_impl and Client_sessi...">Session_base</a> this value may be not-yet-set (empty), or set (and immutable from then on).</p>
<p >This value shall be known and immutable from construction for <a class="el" href="classipc_1_1session_1_1Server__session__impl.html" title="Internal, non-movable pImpl-lite implementation of Server_session_mv class template.">Server_session_impl</a>, since server namespace &ndash; PID as of this writing &ndash; can be determined from the start on the server side and applies to every server session that <a class="el" href="classipc_1_1session_1_1Session__server.html" title="To be instantiated typically once in a given process, an object of this type asynchronously listens f...">Session_server</a> produces. <a class="el" href="classipc_1_1session_1_1Client__session__impl.html" title="Internal, non-movable pImpl-lite implementation of Client_session_mv class template.">Client_session_impl</a>, however, determines it at the latest possible moment which is at <a class="el" href="classipc_1_1session_1_1Client__session__impl.html#a56c0d2b0ff082d1f7b0738e2528b4a92" title="Core implementation of sync_connect().">Client_session_impl::async_connect()</a> time, at which point it needs to determine the PID via PID file.</p>
<dl class="section return"><dt>Returns</dt><dd>See above. </dd></dl>

<p class="definition">Definition at line <a class="el" href="session__base_8hpp_source.html#l00912">912</a> of file <a class="el" href="session__base_8hpp_source.html">session_base.hpp</a>.</p>

</div>
</div>
<h2 class="groupheader">Member Data Documentation</h2>
<a id="aa8cccc9369af1dff6b59dee1a12f72d8" name="aa8cccc9369af1dff6b59dee1a12f72d8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa8cccc9369af1dff6b59dee1a12f72d8">&#9670;&nbsp;</a></span>m_cli_app_ptr</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;schema::MqType S_MQ_TYPE_OR_NONE, bool S_TRANSMIT_NATIVE_HANDLES, typename Mdt_payload &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::atomic&lt;const <a class="el" href="structipc_1_1session_1_1Client__app.html">Client_app</a>*&gt; <a class="el" href="classipc_1_1session_1_1Session__base.html">ipc::session::Session_base</a>&lt; S_MQ_TYPE_OR_NONE, S_TRANSMIT_NATIVE_HANDLES, Mdt_payload &gt;::m_cli_app_ptr</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>See <a class="el" href="classipc_1_1session_1_1Session__base.html#a3ebdafe7e70719e6d12dd0b15ae85106" title="See Server_session_impl, Client_session_impl.">cli_app_ptr()</a>. </p>
<h3>Rationale for it being <code>atomic&lt;&gt;</code></h3>
<p >It is for the following specific reason. Consider <code>ostream&lt;&lt;</code> of <code>*this</code>. <code>*this</code> is really either in <a class="el" href="classipc_1_1session_1_1Client__session__impl.html" title="Internal, non-movable pImpl-lite implementation of Client_session_mv class template.">Client_session_impl</a> or <a class="el" href="classipc_1_1session_1_1Server__session__impl.html" title="Internal, non-movable pImpl-lite implementation of Server_session_mv class template.">Server_session_impl</a>. In both cases these <code>ostream&lt;&lt;</code>s access only <a class="el" href="classipc_1_1session_1_1Session__base.html#afd32d90b86d699263a0f02637dd7c6c6" title="Reference to Server_app (referring to local process in Server_session_impl, opposing process in Clien...">m_srv_app_ref</a>, which is immutable throughout (so no problem there) and <a class="el" href="classipc_1_1session_1_1Session__base.html#aa8cccc9369af1dff6b59dee1a12f72d8" title="See cli_app_ptr().">m_cli_app_ptr</a>. For <a class="el" href="classipc_1_1session_1_1Client__session__impl.html" title="Internal, non-movable pImpl-lite implementation of Client_session_mv class template.">Client_session_impl</a> <a class="el" href="classipc_1_1session_1_1Session__base.html#aa8cccc9369af1dff6b59dee1a12f72d8" title="See cli_app_ptr().">m_cli_app_ptr</a> is also immutable throughout (so no problem there). For <a class="el" href="classipc_1_1session_1_1Server__session__impl.html" title="Internal, non-movable pImpl-lite implementation of Server_session_mv class template.">Server_session_impl</a> however it does change in one spot: <a class="el" href="classipc_1_1session_1_1Server__session__impl.html#aee35d521d9997d48f6b5565730e60e93" title="For use by internal user Session_server: See Server_session_mv counterpart.">Server_session_impl::async_accept_log_in()</a> internal async handler for the log-in request shall, on success, call <a class="el" href="classipc_1_1session_1_1Session__base.html#a60a081ce0f85651202d23b4d543d093c" title="Sets cli_app_ptr() (do not call if already set).">set_cli_app_ptr()</a> and change it from null to non-null. This could cause concurrent access to the data member, even though it's a mere pointer (but we don't count on the alleged "atomicity" of this; it is generally considered not safe).</p>
<p >Now, as of this writing, there's exactly one spot where <code>ostream&lt;&lt;</code> could be invoked from thread U while it is being assigned in thread W: <code>async_accept_log_in()</code> is called by our internal code in <a class="el" href="classipc_1_1session_1_1Session__server.html" title="To be instantiated typically once in a given process, an object of this type asynchronously listens f...">Session_server</a> and only once; the only thing that can occur in thread U until the log-in response handler is executed is that <a class="el" href="classipc_1_1session_1_1Server__session__impl.html" title="Internal, non-movable pImpl-lite implementation of Server_session_mv class template.">Server_session_impl</a> dtor is called. Before that dtor stops that thread W, it does print the <a class="el" href="classipc_1_1session_1_1Server__session__impl.html" title="Internal, non-movable pImpl-lite implementation of Server_session_mv class template.">Server_session_impl</a> once as of this writing. Therefore, out of sheer caution, this guy is <code>atomic&lt;&gt;</code>. That said there could be other such invocations, as code might change during maintenance in the future, in which case this <code>atomic&lt;&gt;</code>ness will quietly come in handy. </p>

<p class="definition">Definition at line <a class="el" href="session__base_8hpp_source.html#l00783">783</a> of file <a class="el" href="session__base_8hpp_source.html">session_base.hpp</a>.</p>

</div>
</div>
<a id="a2985006a6526c86ce3ed5497cb7f5b64" name="a2985006a6526c86ce3ed5497cb7f5b64"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2985006a6526c86ce3ed5497cb7f5b64">&#9670;&nbsp;</a></span>m_cli_namespace</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;schema::MqType S_MQ_TYPE_OR_NONE, bool S_TRANSMIT_NATIVE_HANDLES, typename Mdt_payload &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespaceipc_1_1session.html#a6d07d9996af19e57eb42416e914110ea">Shared_name</a> <a class="el" href="classipc_1_1session_1_1Session__base.html">ipc::session::Session_base</a>&lt; S_MQ_TYPE_OR_NONE, S_TRANSMIT_NATIVE_HANDLES, Mdt_payload &gt;::m_cli_namespace</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>See <a class="el" href="classipc_1_1session_1_1Session__base.html#abd1e814b3b640f4bdaa2553352405f26" title="See Server_session_impl, Client_session_impl.">cli_namespace()</a>. </p>

<p class="definition">Definition at line <a class="el" href="session__base_8hpp_source.html#l00789">789</a> of file <a class="el" href="session__base_8hpp_source.html">session_base.hpp</a>.</p>

</div>
</div>
<a id="a7d25e45d33beb8af9ae03b05d676b0e4" name="a7d25e45d33beb8af9ae03b05d676b0e4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7d25e45d33beb8af9ae03b05d676b0e4">&#9670;&nbsp;</a></span>m_on_err_func</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;schema::MqType S_MQ_TYPE_OR_NONE, bool S_TRANSMIT_NATIVE_HANDLES, typename Mdt_payload &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">flow::async::Task_asio_err <a class="el" href="classipc_1_1session_1_1Session__base.html">ipc::session::Session_base</a>&lt; S_MQ_TYPE_OR_NONE, S_TRANSMIT_NATIVE_HANDLES, Mdt_payload &gt;::m_on_err_func</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>See <a class="el" href="classipc_1_1session_1_1Session__base.html#ae769a82bdec0d16702111ad06716faae" title="Sets on_err_func() (do not call if already set).">set_on_err_func()</a>. </p>

<p class="definition">Definition at line <a class="el" href="session__base_8hpp_source.html#l00792">792</a> of file <a class="el" href="session__base_8hpp_source.html">session_base.hpp</a>.</p>

</div>
</div>
<a id="ad28de3ad7ea872adb52e3a826602d333" name="ad28de3ad7ea872adb52e3a826602d333"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad28de3ad7ea872adb52e3a826602d333">&#9670;&nbsp;</a></span>m_on_passive_open_channel_func_or_empty</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;schema::MqType S_MQ_TYPE_OR_NONE, bool S_TRANSMIT_NATIVE_HANDLES, typename Mdt_payload &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classipc_1_1session_1_1Session__base.html#a3c0824a54ef32915c5c5ea76481f2409">On_passive_open_channel_func</a> <a class="el" href="classipc_1_1session_1_1Session__base.html">ipc::session::Session_base</a>&lt; S_MQ_TYPE_OR_NONE, S_TRANSMIT_NATIVE_HANDLES, Mdt_payload &gt;::m_on_passive_open_channel_func_or_empty</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>See <a class="el" href="classipc_1_1session_1_1Session__base.html#a21b146b02d257d95f4aaeaca12b8d320" title="The on-passive-open handler (may be empty even in final state, meaning user wants passive-opens disab...">on_passive_open_channel_func_or_empty()</a>. </p>

<p class="definition">Definition at line <a class="el" href="session__base_8hpp_source.html#l00795">795</a> of file <a class="el" href="session__base_8hpp_source.html">session_base.hpp</a>.</p>

</div>
</div>
<a id="a0d7926326671d05679c53e5e3991603e" name="a0d7926326671d05679c53e5e3991603e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0d7926326671d05679c53e5e3991603e">&#9670;&nbsp;</a></span>m_peer_state_err_code_or_ok</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;schema::MqType S_MQ_TYPE_OR_NONE, bool S_TRANSMIT_NATIVE_HANDLES, typename Mdt_payload &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespaceipc.html#aa3192e586cc45d3e7c22463bf2760f89">Error_code</a> <a class="el" href="classipc_1_1session_1_1Session__base.html">ipc::session::Session_base</a>&lt; S_MQ_TYPE_OR_NONE, S_TRANSMIT_NATIVE_HANDLES, Mdt_payload &gt;::m_peer_state_err_code_or_ok</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Starts falsy; becomes forever truthy (with a specific <a class="el" href="namespaceipc.html#aa3192e586cc45d3e7c22463bf2760f89" title="Short-hand for flow::Error_code which is very common.">Error_code</a> that will not change thereafter) once <a class="el" href="classipc_1_1session_1_1Session__base.html#a7f9e67dccbab4f3191734c2834bafb63" title="Marks this session as hosed for (truthy) reason err_code; and synchronously invokes on-error handler;...">hose()</a> is called (with that truthy value). </p>
<p >Note <a class="el" href="classipc_1_1session_1_1Session__base.html#a7f9e67dccbab4f3191734c2834bafb63" title="Marks this session as hosed for (truthy) reason err_code; and synchronously invokes on-error handler;...">hose()</a> may not be called before PEER state, which implies <a class="el" href="classipc_1_1session_1_1Session__base.html#a7d25e45d33beb8af9ae03b05d676b0e4" title="See set_on_err_func().">m_on_err_func</a> is non-empty.</p>
<h3>Concurrency</h3>
<p >See <a class="el" href="classipc_1_1session_1_1Session__base.html#a7f9e67dccbab4f3191734c2834bafb63" title="Marks this session as hosed for (truthy) reason err_code; and synchronously invokes on-error handler;...">hose()</a> and <a class="el" href="classipc_1_1session_1_1Session__base.html#a398f3e6a30b3fae8e110af9fd1ff75e3" title="Returns true if and only if hose() has been called.">hosed()</a> doc headers. TL;DR: It is up to the caller to only call those, basically, from thread W only. </p>

<p class="definition">Definition at line <a class="el" href="session__base_8hpp_source.html#l00806">806</a> of file <a class="el" href="session__base_8hpp_source.html">session_base.hpp</a>.</p>

</div>
</div>
<a id="afd32d90b86d699263a0f02637dd7c6c6" name="afd32d90b86d699263a0f02637dd7c6c6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afd32d90b86d699263a0f02637dd7c6c6">&#9670;&nbsp;</a></span>m_srv_app_ref</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;schema::MqType S_MQ_TYPE_OR_NONE, bool S_TRANSMIT_NATIVE_HANDLES, typename Mdt_payload &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="structipc_1_1session_1_1Server__app.html">Server_app</a>&amp; <a class="el" href="classipc_1_1session_1_1Session__base.html">ipc::session::Session_base</a>&lt; S_MQ_TYPE_OR_NONE, S_TRANSMIT_NATIVE_HANDLES, Mdt_payload &gt;::m_srv_app_ref</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Reference to <a class="el" href="structipc_1_1session_1_1Server__app.html" title="An App that is used as a server in at least one client-server IPC split.">Server_app</a> (referring to local process in <a class="el" href="classipc_1_1session_1_1Server__session__impl.html" title="Internal, non-movable pImpl-lite implementation of Server_session_mv class template.">Server_session_impl</a>, opposing process in <a class="el" href="classipc_1_1session_1_1Client__session__impl.html" title="Internal, non-movable pImpl-lite implementation of Client_session_mv class template.">Client_session_impl</a>). </p>
<p >This is known from construction and immutable (both the reference, of course, and the <a class="el" href="structipc_1_1session_1_1Server__app.html" title="An App that is used as a server in at least one client-server IPC split.">Server_app</a> itself). </p>

<p class="definition">Definition at line <a class="el" href="session__base_8hpp_source.html#l00243">243</a> of file <a class="el" href="session__base_8hpp_source.html">session_base.hpp</a>.</p>

</div>
</div>
<a id="a60a30526bad0c8db6ad05ede618a22bd" name="a60a30526bad0c8db6ad05ede618a22bd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a60a30526bad0c8db6ad05ede618a22bd">&#9670;&nbsp;</a></span>m_srv_namespace</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;schema::MqType S_MQ_TYPE_OR_NONE, bool S_TRANSMIT_NATIVE_HANDLES, typename Mdt_payload &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespaceipc_1_1session.html#a6d07d9996af19e57eb42416e914110ea">Shared_name</a> <a class="el" href="classipc_1_1session_1_1Session__base.html">ipc::session::Session_base</a>&lt; S_MQ_TYPE_OR_NONE, S_TRANSMIT_NATIVE_HANDLES, Mdt_payload &gt;::m_srv_namespace</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>See <a class="el" href="classipc_1_1session_1_1Session__base.html#a4d1327608d6067ed6690bd4efa323c6f" title="See Server_session_impl, Client_session_impl.">srv_namespace()</a>. </p>

<p class="definition">Definition at line <a class="el" href="session__base_8hpp_source.html#l00786">786</a> of file <a class="el" href="session__base_8hpp_source.html">session_base.hpp</a>.</p>

</div>
</div>
<a id="a27a5731a648effb6b4b42f0312affa74" name="a27a5731a648effb6b4b42f0312affa74"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a27a5731a648effb6b4b42f0312affa74">&#9670;&nbsp;</a></span>S_MQS_ENABLED</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;schema::MqType S_MQ_TYPE_OR_NONE, bool S_TRANSMIT_NATIVE_HANDLES, typename Mdt_payload &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr bool <a class="el" href="classipc_1_1session_1_1Session__base.html">ipc::session::Session_base</a>&lt; S_MQ_TYPE_OR_NONE, S_TRANSMIT_NATIVE_HANDLES, Mdt_payload &gt;::S_MQS_ENABLED = S_MQ_TYPE_OR_NONE != schema::MqType::NONE</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>See <a class="el" href="classipc_1_1session_1_1Session__mv.html" title="Implements the Session concept when it is in PEER state.">Session_mv</a>. </p>

<p class="definition">Definition at line <a class="el" href="session__base_8hpp_source.html#l00074">74</a> of file <a class="el" href="session__base_8hpp_source.html">session_base.hpp</a>.</p>

</div>
</div>
<a id="af0b52934c6b1204cb3ba676480727d27" name="af0b52934c6b1204cb3ba676480727d27"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af0b52934c6b1204cb3ba676480727d27">&#9670;&nbsp;</a></span>S_MQS_MAX_MSG_SZ</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;schema::MqType S_MQ_TYPE_OR_NONE, bool S_TRANSMIT_NATIVE_HANDLES, typename Mdt_payload &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr size_t <a class="el" href="classipc_1_1session_1_1Session__base.html">ipc::session::Session_base</a>&lt; S_MQ_TYPE_OR_NONE, S_TRANSMIT_NATIVE_HANDLES, Mdt_payload &gt;::S_MQS_MAX_MSG_SZ = 8 * 1024</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span><span class="mlabel">constexpr</span><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>The max sendable MQ message size as decided by <a class="el" href="classipc_1_1session_1_1Server__session__impl.html#a84d54a57d3e06c064cde737d1f4be472" title="Helper for create_channel_and_resources(), invoked and compiled if and only if S_MQS_ENABLED,...">Server_session_impl::make_channel_mqs()</a> (and imposed on both sides, both directions), if <a class="el" href="classipc_1_1session_1_1Session__base.html#a27a5731a648effb6b4b42f0312affa74" title="See Session_mv.">S_MQS_ENABLED</a> <em>and</em> <a class="el" href="classipc_1_1session_1_1Server__session__impl.html#a1ded7990451b90f29e11f8fa7ce0e80b" title="See Session_mv counterpart.">Server_session_impl::S_SHM_ENABLED</a> is <code>false</code>, when a channel is opened (regardless of which side did the active-open or requested pre-opening at session start). </p>
<p >If <code>*this</code> belongs to <a class="el" href="classipc_1_1session_1_1Server__session__impl.html" title="Internal, non-movable pImpl-lite implementation of Server_session_mv class template.">Server_session_impl</a>, that's what this is. If it belongs to <a class="el" href="classipc_1_1session_1_1Client__session__impl.html" title="Internal, non-movable pImpl-lite implementation of Client_session_mv class template.">Client_session_impl</a>, then this is what the opposing process &ndash; if they're using the same code! &ndash; will have decided.</p>
<p >Our own <a class="el" href="classipc_1_1session_1_1Session__base.html#a08b3d69a6707dcbb233076b7a48de285" title="See Session_mv::heap_fixed_builder_config() (1-arg).">heap_fixed_builder_config()</a>, forwarded to <a class="el" href="classipc_1_1session_1_1Session__mv.html#a107684fdd5d233549c6daac26a81a542" title="Utility that obtains a heap-based (non-zero-copy) Struct_builder::Config, constructed with the most e...">Session_mv::heap_fixed_builder_config()</a>, similarly uses this constant in a matching way.</p>
<dl class="section note"><dt>Note</dt><dd>If <a class="el" href="classipc_1_1session_1_1Server__session__impl.html#a1ded7990451b90f29e11f8fa7ce0e80b" title="See Session_mv counterpart.">Server_session_impl::S_SHM_ENABLED</a> is <code>true</code>, then a different (much smaller) MQ message size limit is configured. In that case, also, <a class="el" href="classipc_1_1session_1_1Session__base.html#a08b3d69a6707dcbb233076b7a48de285" title="See Session_mv::heap_fixed_builder_config() (1-arg).">heap_fixed_builder_config()</a> is not relevant and should not be used.</dd></dl>
<p>While it looks simple, there is a number of subtleties one must understand if <em>ever</em> considering changing it.</p>
<h3>bipc versus POSIX MQs</h3>
<p >As of this writing the same constant value is used for both types of MQ configurable. The actual value is chosen due to a certain aspect of POSIX MQs (discussed just below); and we reuse it for bipc, though we absolutely do not have to, for simplicity/for lack of better ideas at the moment. It would be possible to bifurcate those two cases if really desired.</p>
<h3>Why 8Ki?</h3>
<p >By default in Linux POSIX MQs this happens to be the actual limit for # of unread messages &ndash; visible in /proc/sys/fs/mqueue/msgsize_max &ndash; so we cannot go higher typically. However that file can be modified. For now we assume a typical environment; or at least that it will not go <em>below</em> this typical default. If did try a higher number here, opening of MQs by server will likely emit an error and refuse (<a class="el" href="classipc_1_1session_1_1Server__session__impl.html#a84d54a57d3e06c064cde737d1f4be472" title="Helper for create_channel_and_resources(), invoked and compiled if and only if S_MQS_ENABLED,...">Server_session_impl::make_channel_mqs()</a>).</p>
<h3>Things to consider if changing the value away from the above</h3>
<ul>
<li>Contemplate why you're doing it. bipc MQs are seen (in Boost source) to be a simple zero-copy data structure in an internally maintained kernel-persistent SHM pool; while I (ygoldfel) haven't verified via kernal source, likely Linux POSIX MQ impl is something very similar (reasoning omitted but trust me). So copy perf should not be a factor; only RAM use and the functional ability to transmit messages of a certain size.<ul>
<li>If the plan is to use <code><a class="el" href="classipc_1_1transport_1_1struc_1_1Heap__fixed__builder.html" title="Implements Struct_builder concept by straightforwardly allocating fixed-size segments on-demand in th...">transport::struc::Heap_fixed_builder</a></code>-backed for structured messages (via <a class="el" href="classipc_1_1transport_1_1struc_1_1Channel.html" title="Owning and wrapping a pre-connected transport::Channel peer (an endpoint of an established channel ov...">transport::struc::Channel</a>), then the max size is quite important: if a <em>leaf</em> in your message exceeds this size when serialized, it is a fatal error.</li>
<li>If, however, the plan is to use SHM-backing (e.g., via <code><a class="el" href="namespaceipc_1_1session_1_1shm_1_1classic.html" title="Support for SHM-backed ipc::session sessions and session-servers with the SHM-classic (ipc::shm::clas...">shm::classic</a>::*_session</code>), then this constant does not get used (a much smaller value does &ndash; so small it would be ~meaningless to decrease it).</li>
</ul>
</li>
<li>Suppose you have changed this value, and suppose the <code>Heap_fixed_builder</code>-based use case <em>does</em> matter. If <a class="el" href="namespaceipc.html" title="Catch-all namespace for the Flow-IPC project: A library/API in modern C++17 providing high-performanc...">ipc</a> has not yet been released in production, ever, then it's fine (assuming, that is, it'll work in the first place given the aforementioned <code>/proc/sys/...</code> limit for POSIX MQs). If it <em>has</em> been released then there is an annoying subtlety to consider:<ul>
<li>If you can guarantee (via release process) that the client and server will always use the same <a class="el" href="namespaceipc.html" title="Catch-all namespace for the Flow-IPC project: A library/API in modern C++17 providing high-performanc...">ipc</a> software, then you're still fine. Just change this value; done. Otherwise though:</li>
<li>There's the unfortunate caveat that is <a class="el" href="classipc_1_1session_1_1Session__base.html#a08b3d69a6707dcbb233076b7a48de285" title="See Session_mv::heap_fixed_builder_config() (1-arg).">Session_base::heap_fixed_builder_config()</a>. There you will note it says that the <em>server</em> decides (for both sides) what this value is. In that case that method will be correct in the server process; but if the client process is speaking to a different version of the server, with a different value for <a class="el" href="classipc_1_1session_1_1Session__base.html#af0b52934c6b1204cb3ba676480727d27" title="The max sendable MQ message size as decided by Server_session_impl::make_channel_mqs() (and imposed o...">S_MQS_MAX_MSG_SZ</a>, then that is a potential bug.<ul>
<li>Therefore it would be advisable to not mess with it (again... once a production version is out there). If you <em>do</em> mess with it, there are ways to ensure it all works out anyway: logic could be added wherein the client specifies its own <a class="el" href="classipc_1_1session_1_1Session__base.html#af0b52934c6b1204cb3ba676480727d27" title="The max sendable MQ message size as decided by Server_session_impl::make_channel_mqs() (and imposed o...">S_MQS_MAX_MSG_SZ</a> when issuing an open-channel request, and the server must honor it in its <a class="el" href="classipc_1_1session_1_1Server__session__impl.html#a84d54a57d3e06c064cde737d1f4be472" title="Helper for create_channel_and_resources(), invoked and compiled if and only if S_MQS_ENABLED,...">Server_session_impl::make_channel_mqs()</a>. So it can be done &ndash; just know that in that case you'll have to actually add such logic; or somewhat break <a class="el" href="classipc_1_1session_1_1Session__base.html#a08b3d69a6707dcbb233076b7a48de285" title="See Session_mv::heap_fixed_builder_config() (1-arg).">heap_fixed_builder_config()</a>. The reason I (ygoldfel) have not done this already is it seems unlikely (for various reasons listed above) that tweaking this value is of much practical value. </li>
</ul>
</li>
</ul>
</li>
</ul>

<p class="definition">Definition at line <a class="el" href="session__base_8hpp_source.html#l00321">321</a> of file <a class="el" href="session__base_8hpp_source.html">session_base.hpp</a>.</p>

</div>
</div>
<a id="ae68b7b80ff82ba5cde28a53fa52a5095" name="ae68b7b80ff82ba5cde28a53fa52a5095"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae68b7b80ff82ba5cde28a53fa52a5095">&#9670;&nbsp;</a></span>S_OPEN_CHANNEL_TIMEOUT</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;schema::MqType S_MQ_TYPE_OR_NONE, bool S_TRANSMIT_NATIVE_HANDLES, typename Mdt_payload &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr <a class="el" href="namespaceipc_1_1util.html#ac66141280c3b7295a86b65209f31cc58">util::Fine_duration</a> <a class="el" href="classipc_1_1session_1_1Session__base.html">ipc::session::Session_base</a>&lt; S_MQ_TYPE_OR_NONE, S_TRANSMIT_NATIVE_HANDLES, Mdt_payload &gt;::S_OPEN_CHANNEL_TIMEOUT = boost::chrono::seconds(60)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span><span class="mlabel">constexpr</span><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Internal timeout for <code>open_channel()</code>. </p>
<h3>The value</h3>
<p >We initially tried something much less generous, 500ms. It worked fine, but some people encountered the timeout due to unrelated reasons, and it was natural to blame it on the timeout. This much longer timeout should make it obvious, in such a situation, that it's not about some slowness inside Flow-IPC but a pathological application problem &ndash; particularly around session-open time. For example not calling <a class="el" href="classipc_1_1session_1_1Server__session__impl.html#ac93040ccdaf5a261a053a8b55bd2e14e" title="See Server_session_mv counterpart.">Server_session_impl::init_handlers()</a>, or calling it late, as of this writing can cause issues with this.</p>
<p >The downside is it makes <a class="el" href="classipc_1_1session_1_1Session.html#aab01aefa0243abf84c7cc36d3ab2d852" title="Synchronously active-opens a new channel which, on success, is moved-to *target_channel.">Session::open_channel()</a> potentially blocking formally speaking, whereas 500ms could still claim to be non-blocking. It's a matter of perspective really. This value just seems to cause less confusion. We might reconsider the whole thing however. </p>

<p class="definition">Definition at line <a class="el" href="session__base_8hpp_source.html#l00262">262</a> of file <a class="el" href="session__base_8hpp_source.html">session_base.hpp</a>.</p>

</div>
</div>
<a id="a1f7c4243c8bd55930f51a568884c8aaf" name="a1f7c4243c8bd55930f51a568884c8aaf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1f7c4243c8bd55930f51a568884c8aaf">&#9670;&nbsp;</a></span>S_SOCKET_STREAM_ENABLED</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;schema::MqType S_MQ_TYPE_OR_NONE, bool S_TRANSMIT_NATIVE_HANDLES, typename Mdt_payload &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr bool <a class="el" href="classipc_1_1session_1_1Session__base.html">ipc::session::Session_base</a>&lt; S_MQ_TYPE_OR_NONE, S_TRANSMIT_NATIVE_HANDLES, Mdt_payload &gt;::S_SOCKET_STREAM_ENABLED = (!<a class="el" href="classipc_1_1session_1_1Session__base.html#a27a5731a648effb6b4b42f0312affa74">S_MQS_ENABLED</a>) || S_TRANSMIT_NATIVE_HANDLES</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>See <a class="el" href="classipc_1_1session_1_1Session__mv.html" title="Implements the Session concept when it is in PEER state.">Session_mv</a>. </p>

<p class="definition">Definition at line <a class="el" href="session__base_8hpp_source.html#l00077">77</a> of file <a class="el" href="session__base_8hpp_source.html">session_base.hpp</a>.</p>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li>session/detail/<a class="el" href="session__base_8hpp_source.html">session_base.hpp</a></li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Thu Mar 7 2024 03:45:24 for Flow-IPC by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.4
</small></address>
</body>
</html>
