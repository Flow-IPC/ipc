<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.9.4"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Flow-IPC: ipc::transport::Native_socket_stream_acceptor Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">Flow-IPC<span id="projectnumber">&#160;1.0</span>
   </div>
   <div id="projectbrief">Flow-IPC project: Full implementation reference.</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.4 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search",'Search','.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespaceipc.html">ipc</a></li><li class="navelem"><a class="el" href="namespaceipc_1_1transport.html">transport</a></li><li class="navelem"><a class="el" href="classipc_1_1transport_1_1Native__socket__stream__acceptor.html">Native_socket_stream_acceptor</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#pub-types">Public Types</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pub-static-attribs">Static Public Attributes</a> &#124;
<a href="#pri-types">Private Types</a> &#124;
<a href="#pri-methods">Private Member Functions</a> &#124;
<a href="#pri-attribs">Private Attributes</a> &#124;
<a href="#related">Related Functions</a> &#124;
<a href="classipc_1_1transport_1_1Native__socket__stream__acceptor-members.html">List of all members</a>  </div>
  <div class="headertitle"><div class="title">ipc::transport::Native_socket_stream_acceptor Class Reference</div></div>
</div><!--header-->
<div class="contents">

<p>A server object that binds to a Shared_name and listens for incoming <code><a class="el" href="classipc_1_1transport_1_1Native__socket__stream.html" title="Implements both Native_handle_sender and Native_handle_receiver concepts by using a stream-oriented U...">Native_socket_stream</a>::*_connect()</code> attempts to that name; and yields connected-peer <a class="el" href="classipc_1_1transport_1_1sync__io_1_1Native__socket__stream.html" title="Implements both sync_io::Native_handle_sender and sync_io::Native_handle_receiver concepts by using a...">sync_io::Native_socket_stream</a> objects, one per counterpart opposing <code>*_connect()</code>.  
 <a href="classipc_1_1transport_1_1Native__socket__stream__acceptor.html#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="native__socket__stream__acceptor_8hpp_source.html">native_socket_stream_acceptor.hpp</a>&gt;</code></p>
<div class="dynheader">
Inheritance diagram for ipc::transport::Native_socket_stream_acceptor:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="classipc_1_1transport_1_1Native__socket__stream__acceptor__inherit__graph.svg" width="310" height="119"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe>
</div>
<center><span class="legend">[<a href="graph_legend.html">legend</a>]</span></center></div>
<div class="dynheader">
Collaboration diagram for ipc::transport::Native_socket_stream_acceptor:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="classipc_1_1transport_1_1Native__socket__stream__acceptor__coll__graph.svg" width="975" height="530"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe>
</div>
<center><span class="legend">[<a href="graph_legend.html">legend</a>]</span></center></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="nested-classes" name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structipc_1_1transport_1_1Native__socket__stream__acceptor_1_1User__request.html">User_request</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Data store representing a deficit user async-accept request that had to be saved due to lacking surplus of finalized peer socket handles.  <a href="structipc_1_1transport_1_1Native__socket__stream__acceptor_1_1User__request.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-types" name="pub-types"></a>
Public Types</h2></td></tr>
<tr class="memitem:a3707eaee28b6bacded15ba4cdab3da48"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classipc_1_1transport_1_1Native__socket__stream__acceptor.html#a3707eaee28b6bacded15ba4cdab3da48">Peer</a> = <a class="el" href="classipc_1_1transport_1_1Native__socket__stream.html#a850af22a95f27d8696b9b5bca15454b5">Native_socket_stream::Sync_io_obj</a></td></tr>
<tr class="memdesc:a3707eaee28b6bacded15ba4cdab3da48"><td class="mdescLeft">&#160;</td><td class="mdescRight">Short-hand for type of target peer-socket objects targeted by <a class="el" href="classipc_1_1transport_1_1Native__socket__stream__acceptor.html#a81426af495ba5a9c832d1ba35fe23ba5" title="Asynchronously awaits for a peer connection to be established and calls on_done_func(),...">async_accept()</a>.  <a href="classipc_1_1transport_1_1Native__socket__stream__acceptor.html#a3707eaee28b6bacded15ba4cdab3da48">More...</a><br /></td></tr>
<tr class="separator:a3707eaee28b6bacded15ba4cdab3da48"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac0e1478364d940f243acece27ece5a7c"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classipc_1_1transport_1_1Native__socket__stream__acceptor.html#ac0e1478364d940f243acece27ece5a7c">Sync_io_obj</a> = <a class="el" href="classipc_1_1transport_1_1sync__io_1_1Native__socket__stream__acceptor.html">sync_io::Native_socket_stream_acceptor</a></td></tr>
<tr class="memdesc:ac0e1478364d940f243acece27ece5a7c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Useful for generic programming, the <code><a class="el" href="namespaceipc_1_1transport_1_1sync__io.html" title="sync_io-pattern counterparts to async-I/O-pattern object types in parent namespace ipc::transport.">sync_io</a></code>-pattern counterpart to <code>*this</code> type.  <a href="classipc_1_1transport_1_1Native__socket__stream__acceptor.html#ac0e1478364d940f243acece27ece5a7c">More...</a><br /></td></tr>
<tr class="separator:ac0e1478364d940f243acece27ece5a7c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a863aa3fe53c71e3b33814f7caecbb193"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classipc_1_1transport_1_1Native__socket__stream__acceptor.html#a863aa3fe53c71e3b33814f7caecbb193">Async_io_obj</a> = <a class="el" href="classipc_1_1transport_1_1Null__peer.html">Null_peer</a></td></tr>
<tr class="memdesc:a863aa3fe53c71e3b33814f7caecbb193"><td class="mdescLeft">&#160;</td><td class="mdescRight">You may disregard.  <a href="classipc_1_1transport_1_1Native__socket__stream__acceptor.html#a863aa3fe53c71e3b33814f7caecbb193">More...</a><br /></td></tr>
<tr class="separator:a863aa3fe53c71e3b33814f7caecbb193"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-methods" name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a77795acb028a95a4804f9b3ef18d99b0"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classipc_1_1transport_1_1Native__socket__stream__acceptor.html#a77795acb028a95a4804f9b3ef18d99b0">Native_socket_stream_acceptor</a> (flow::log::Logger *logger_ptr, const <a class="el" href="namespaceipc_1_1transport.html#a33de1c256addb3964b839dc2dd407d24">Shared_name</a> &amp;<a class="el" href="classipc_1_1transport_1_1Native__socket__stream__acceptor.html#ac5b70ff8230fa49c99ccb6954db71c75">absolute_name</a>, <a class="el" href="namespaceipc.html#aa3192e586cc45d3e7c22463bf2760f89">Error_code</a> *err_code=0)</td></tr>
<tr class="memdesc:a77795acb028a95a4804f9b3ef18d99b0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates the <a class="el" href="classipc_1_1transport_1_1Native__socket__stream__acceptor.html" title="A server object that binds to a Shared_name and listens for incoming Native_socket_stream::*_connect(...">Native_socket_stream_acceptor</a> and immediately begins listening in the background, so that other process(es) can connect to it &ndash; at the specified name &ndash; once the constructor returns successfully.  <a href="classipc_1_1transport_1_1Native__socket__stream__acceptor.html#a77795acb028a95a4804f9b3ef18d99b0">More...</a><br /></td></tr>
<tr class="separator:a77795acb028a95a4804f9b3ef18d99b0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a71e907b904bcc8aff0042ca7efcc783b"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classipc_1_1transport_1_1Native__socket__stream__acceptor.html#a71e907b904bcc8aff0042ca7efcc783b">~Native_socket_stream_acceptor</a> ()</td></tr>
<tr class="memdesc:a71e907b904bcc8aff0042ca7efcc783b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Destroys this acceptor which will stop listening in the background and cancel any pending completion handlers by invoking them ASAP with <a class="el" href="namespaceipc_1_1transport_1_1error.html#adfef15ef4e76cc55d652fbd9c2797297afe29343445a7bf167cc186a44bd2c6ed" title="Async completion handler is being called prematurely, because underlying object is shutting down,...">error::Code::S_OBJECT_SHUTDOWN_ABORTED_COMPLETION_HANDLER</a>.  <a href="classipc_1_1transport_1_1Native__socket__stream__acceptor.html#a71e907b904bcc8aff0042ca7efcc783b">More...</a><br /></td></tr>
<tr class="separator:a71e907b904bcc8aff0042ca7efcc783b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac5b70ff8230fa49c99ccb6954db71c75"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="namespaceipc_1_1transport.html#a33de1c256addb3964b839dc2dd407d24">Shared_name</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classipc_1_1transport_1_1Native__socket__stream__acceptor.html#ac5b70ff8230fa49c99ccb6954db71c75">absolute_name</a> () const</td></tr>
<tr class="memdesc:ac5b70ff8230fa49c99ccb6954db71c75"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the full name/address to which the constructor bound, or attempted to bind, the listening socket.  <a href="classipc_1_1transport_1_1Native__socket__stream__acceptor.html#ac5b70ff8230fa49c99ccb6954db71c75">More...</a><br /></td></tr>
<tr class="separator:ac5b70ff8230fa49c99ccb6954db71c75"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a81426af495ba5a9c832d1ba35fe23ba5"><td class="memTemplParams" colspan="2">template&lt;typename Task_err &gt; </td></tr>
<tr class="memitem:a81426af495ba5a9c832d1ba35fe23ba5"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classipc_1_1transport_1_1Native__socket__stream__acceptor.html#a81426af495ba5a9c832d1ba35fe23ba5">async_accept</a> (<a class="el" href="classipc_1_1transport_1_1Native__socket__stream__acceptor.html#a3707eaee28b6bacded15ba4cdab3da48">Peer</a> *target_peer, Task_err &amp;&amp;on_done_func)</td></tr>
<tr class="memdesc:a81426af495ba5a9c832d1ba35fe23ba5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Asynchronously awaits for a peer connection to be established and calls <code>on_done_func()</code>, once the connection occurs, or an error occurs, in the former case move-assigning a PEER-state <a class="el" href="classipc_1_1transport_1_1Native__socket__stream.html" title="Implements both Native_handle_sender and Native_handle_receiver concepts by using a stream-oriented U...">Native_socket_stream</a> object to the passed-in <a class="el" href="classipc_1_1transport_1_1Native__socket__stream.html" title="Implements both Native_handle_sender and Native_handle_receiver concepts by using a stream-oriented U...">Native_socket_stream</a> <code>*target_peer</code>.  <a href="classipc_1_1transport_1_1Native__socket__stream__acceptor.html#a81426af495ba5a9c832d1ba35fe23ba5">More...</a><br /></td></tr>
<tr class="separator:a81426af495ba5a9c832d1ba35fe23ba5"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-static-attribs" name="pub-static-attribs"></a>
Static Public Attributes</h2></td></tr>
<tr class="memitem:a0de2b6072026584ff1d46538533ed68b"><td class="memItemLeft" align="right" valign="top">static const <a class="el" href="namespaceipc_1_1transport.html#a33de1c256addb3964b839dc2dd407d24">Shared_name</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classipc_1_1transport_1_1Native__socket__stream__acceptor.html#a0de2b6072026584ff1d46538533ed68b">S_RESOURCE_TYPE_ID</a> = Sync_io_obj::S_RESOURCE_TYPE_ID</td></tr>
<tr class="memdesc:a0de2b6072026584ff1d46538533ed68b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Shared_name relative-folder fragment (no separators) identifying this resource type.  <a href="classipc_1_1transport_1_1Native__socket__stream__acceptor.html#a0de2b6072026584ff1d46538533ed68b">More...</a><br /></td></tr>
<tr class="separator:a0de2b6072026584ff1d46538533ed68b"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pri-types" name="pri-types"></a>
Private Types</h2></td></tr>
<tr class="memitem:ab5fa8c28eb4dbe2ae2e4f1b25d520857"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classipc_1_1transport_1_1Native__socket__stream__acceptor.html#ab5fa8c28eb4dbe2ae2e4f1b25d520857">On_peer_accepted_func</a> = flow::async::Task_asio_err</td></tr>
<tr class="memdesc:ab5fa8c28eb4dbe2ae2e4f1b25d520857"><td class="mdescLeft">&#160;</td><td class="mdescRight">Short-hand for callback called on new peer-to-peer connection; or on unrecoverable error.  <a href="classipc_1_1transport_1_1Native__socket__stream__acceptor.html#ab5fa8c28eb4dbe2ae2e4f1b25d520857">More...</a><br /></td></tr>
<tr class="separator:ab5fa8c28eb4dbe2ae2e4f1b25d520857"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a476652737140b761264000ffa4204e4a"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classipc_1_1transport_1_1Native__socket__stream__acceptor.html#a476652737140b761264000ffa4204e4a">Peer_ptr</a> = boost::movelib::unique_ptr&lt; <a class="el" href="classipc_1_1transport_1_1Native__socket__stream__acceptor.html#a3707eaee28b6bacded15ba4cdab3da48">Peer</a> &gt;</td></tr>
<tr class="memdesc:a476652737140b761264000ffa4204e4a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Short-hand for internally stored PEER-state <a class="el" href="classipc_1_1transport_1_1sync__io_1_1Native__socket__stream.html" title="Implements both sync_io::Native_handle_sender and sync_io::Native_handle_receiver concepts by using a...">sync_io::Native_socket_stream</a> in <a class="el" href="classipc_1_1transport_1_1Native__socket__stream__acceptor.html#ac04049d9b4c38f2a46d7f26192b17b69" title="Queue storing surplus finalized async-accept results queued up due to lacking async_accept() requests...">m_pending_results_q</a>.  <a href="classipc_1_1transport_1_1Native__socket__stream__acceptor.html#a476652737140b761264000ffa4204e4a">More...</a><br /></td></tr>
<tr class="separator:a476652737140b761264000ffa4204e4a"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pri-methods" name="pri-methods"></a>
Private Member Functions</h2></td></tr>
<tr class="memitem:a2063fff89b58cc5b07ee7651f9e42366"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classipc_1_1transport_1_1Native__socket__stream__acceptor.html#a2063fff89b58cc5b07ee7651f9e42366">async_accept_impl</a> (<a class="el" href="classipc_1_1transport_1_1Native__socket__stream__acceptor.html#a3707eaee28b6bacded15ba4cdab3da48">Peer</a> *target_peer, <a class="el" href="classipc_1_1transport_1_1Native__socket__stream__acceptor.html#ab5fa8c28eb4dbe2ae2e4f1b25d520857">On_peer_accepted_func</a> &amp;&amp;on_done_func)</td></tr>
<tr class="memdesc:a2063fff89b58cc5b07ee7651f9e42366"><td class="mdescLeft">&#160;</td><td class="mdescRight">Non-template impl of <a class="el" href="classipc_1_1transport_1_1Native__socket__stream__acceptor.html#a81426af495ba5a9c832d1ba35fe23ba5" title="Asynchronously awaits for a peer connection to be established and calls on_done_func(),...">async_accept()</a>.  <a href="classipc_1_1transport_1_1Native__socket__stream__acceptor.html#a2063fff89b58cc5b07ee7651f9e42366">More...</a><br /></td></tr>
<tr class="separator:a2063fff89b58cc5b07ee7651f9e42366"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af52346c8df9efc457efaec35bc6c0807"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classipc_1_1transport_1_1Native__socket__stream__acceptor.html#af52346c8df9efc457efaec35bc6c0807">on_next_peer_socket_or_error</a> (const <a class="el" href="namespaceipc.html#aa3192e586cc45d3e7c22463bf2760f89">Error_code</a> &amp;sys_err_code)</td></tr>
<tr class="memdesc:af52346c8df9efc457efaec35bc6c0807"><td class="mdescLeft">&#160;</td><td class="mdescRight">Handler for incoming connection on <a class="el" href="classipc_1_1transport_1_1Native__socket__stream__acceptor.html#a946663a2ab4070babdc80091f5adfb28" title="Unix domain socket acceptor.">m_acceptor</a>.  <a href="classipc_1_1transport_1_1Native__socket__stream__acceptor.html#af52346c8df9efc457efaec35bc6c0807">More...</a><br /></td></tr>
<tr class="separator:af52346c8df9efc457efaec35bc6c0807"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab9744191a6b5d7d05b7b2b96fcda84d6"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classipc_1_1transport_1_1Native__socket__stream__acceptor.html#ab9744191a6b5d7d05b7b2b96fcda84d6">finalize_q_surplus_on_success</a> ()</td></tr>
<tr class="memdesc:ab9744191a6b5d7d05b7b2b96fcda84d6"><td class="mdescLeft">&#160;</td><td class="mdescRight">In thread W, in steady state, introduces the just-established peer socket handle into the state machine and synchronously advances the state machine into steady state again, with the possible side effect of synchronously invoking the head waiting async-accept user request, if any.  <a href="classipc_1_1transport_1_1Native__socket__stream__acceptor.html#ab9744191a6b5d7d05b7b2b96fcda84d6">More...</a><br /></td></tr>
<tr class="separator:ab9744191a6b5d7d05b7b2b96fcda84d6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6c7c14574c041bcfd1ccb45137b486b4"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classipc_1_1transport_1_1Native__socket__stream__acceptor.html#a6c7c14574c041bcfd1ccb45137b486b4">finalize_q_surplus_on_error</a> ()</td></tr>
<tr class="memdesc:a6c7c14574c041bcfd1ccb45137b486b4"><td class="mdescLeft">&#160;</td><td class="mdescRight">In thread W, in steady state <em>except</em> for an <code>Error_code</code> just pushed to the back of <a class="el" href="classipc_1_1transport_1_1Native__socket__stream__acceptor.html#ac04049d9b4c38f2a46d7f26192b17b69" title="Queue storing surplus finalized async-accept results queued up due to lacking async_accept() requests...">m_pending_results_q</a> and thus introduced into the state machine, synchronously advances the state machine into steady state again, with the possible side effect of synchronously invoking <em>all</em> waiting async-accept user requests, if any.  <a href="classipc_1_1transport_1_1Native__socket__stream__acceptor.html#a6c7c14574c041bcfd1ccb45137b486b4">More...</a><br /></td></tr>
<tr class="separator:a6c7c14574c041bcfd1ccb45137b486b4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8ff2e85b30532cb9778aa43c01931955"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classipc_1_1transport_1_1Native__socket__stream__acceptor.html#a8ff2e85b30532cb9778aa43c01931955">feed_error_result_to_deficit</a> (const <a class="el" href="namespaceipc.html#aa3192e586cc45d3e7c22463bf2760f89">Error_code</a> &amp;err_code)</td></tr>
<tr class="memdesc:a8ff2e85b30532cb9778aa43c01931955"><td class="mdescLeft">&#160;</td><td class="mdescRight">In thread W, gets back to steady state by feeding the given <a class="el" href="namespaceipc.html#aa3192e586cc45d3e7c22463bf2760f89" title="Short-hand for flow::Error_code which is very common.">Error_code</a> (which must be the sole element in <a class="el" href="classipc_1_1transport_1_1Native__socket__stream__acceptor.html#ac04049d9b4c38f2a46d7f26192b17b69" title="Queue storing surplus finalized async-accept results queued up due to lacking async_accept() requests...">m_pending_results_q</a>) to all queued user requests, popping them all.  <a href="classipc_1_1transport_1_1Native__socket__stream__acceptor.html#a8ff2e85b30532cb9778aa43c01931955">More...</a><br /></td></tr>
<tr class="separator:a8ff2e85b30532cb9778aa43c01931955"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af1ca26531b9dd649046086e4e17f0ba3"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classipc_1_1transport_1_1Native__socket__stream__acceptor.html#af1ca26531b9dd649046086e4e17f0ba3">feed_success_result_to_deficit</a> (<a class="el" href="classipc_1_1transport_1_1Native__socket__stream__acceptor.html#a476652737140b761264000ffa4204e4a">Peer_ptr</a> &amp;&amp;peer)</td></tr>
<tr class="memdesc:af1ca26531b9dd649046086e4e17f0ba3"><td class="mdescLeft">&#160;</td><td class="mdescRight">In thread W, gets back to steady state by feeding the given just-connected peer socket (which must have just been popped from <a class="el" href="classipc_1_1transport_1_1Native__socket__stream__acceptor.html#ac04049d9b4c38f2a46d7f26192b17b69" title="Queue storing surplus finalized async-accept results queued up due to lacking async_accept() requests...">m_pending_results_q</a>) to the first queued user request, popping it.  <a href="classipc_1_1transport_1_1Native__socket__stream__acceptor.html#af1ca26531b9dd649046086e4e17f0ba3">More...</a><br /></td></tr>
<tr class="separator:af1ca26531b9dd649046086e4e17f0ba3"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pri-attribs" name="pri-attribs"></a>
Private Attributes</h2></td></tr>
<tr class="memitem:a35785c842d668ee13f556580d0045511"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="namespaceipc_1_1transport.html#a33de1c256addb3964b839dc2dd407d24">Shared_name</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classipc_1_1transport_1_1Native__socket__stream__acceptor.html#a35785c842d668ee13f556580d0045511">m_absolute_name</a></td></tr>
<tr class="memdesc:a35785c842d668ee13f556580d0045511"><td class="mdescLeft">&#160;</td><td class="mdescRight">See <a class="el" href="classipc_1_1transport_1_1Native__socket__stream__acceptor.html#ac5b70ff8230fa49c99ccb6954db71c75" title="Returns the full name/address to which the constructor bound, or attempted to bind,...">absolute_name()</a>.  <a href="classipc_1_1transport_1_1Native__socket__stream__acceptor.html#a35785c842d668ee13f556580d0045511">More...</a><br /></td></tr>
<tr class="separator:a35785c842d668ee13f556580d0045511"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5d2e731d023d9c6465e01fa84a6e5138"><td class="memItemLeft" align="right" valign="top">std::queue&lt; <a class="el" href="structipc_1_1transport_1_1Native__socket__stream__acceptor_1_1User__request.html#a79784f3221898aee3ab977186565b5d2">User_request::Ptr</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classipc_1_1transport_1_1Native__socket__stream__acceptor.html#a5d2e731d023d9c6465e01fa84a6e5138">m_pending_user_requests_q</a></td></tr>
<tr class="memdesc:a5d2e731d023d9c6465e01fa84a6e5138"><td class="mdescLeft">&#160;</td><td class="mdescRight">Queue storing deficit async-accept requests queued up due to lacking pending ready peer socket handles in <a class="el" href="classipc_1_1transport_1_1Native__socket__stream__acceptor.html#ac04049d9b4c38f2a46d7f26192b17b69" title="Queue storing surplus finalized async-accept results queued up due to lacking async_accept() requests...">m_pending_results_q</a> at <a class="el" href="classipc_1_1transport_1_1Native__socket__stream__acceptor.html#a81426af495ba5a9c832d1ba35fe23ba5" title="Asynchronously awaits for a peer connection to be established and calls on_done_func(),...">async_accept()</a> time.  <a href="classipc_1_1transport_1_1Native__socket__stream__acceptor.html#a5d2e731d023d9c6465e01fa84a6e5138">More...</a><br /></td></tr>
<tr class="separator:a5d2e731d023d9c6465e01fa84a6e5138"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac04049d9b4c38f2a46d7f26192b17b69"><td class="memItemLeft" align="right" valign="top">std::queue&lt; std::variant&lt; <a class="el" href="classipc_1_1transport_1_1Native__socket__stream__acceptor.html#a476652737140b761264000ffa4204e4a">Peer_ptr</a>, <a class="el" href="namespaceipc.html#aa3192e586cc45d3e7c22463bf2760f89">Error_code</a> &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classipc_1_1transport_1_1Native__socket__stream__acceptor.html#ac04049d9b4c38f2a46d7f26192b17b69">m_pending_results_q</a></td></tr>
<tr class="memdesc:ac04049d9b4c38f2a46d7f26192b17b69"><td class="mdescLeft">&#160;</td><td class="mdescRight">Queue storing surplus finalized async-accept results queued up due to lacking <a class="el" href="classipc_1_1transport_1_1Native__socket__stream__acceptor.html#a81426af495ba5a9c832d1ba35fe23ba5" title="Asynchronously awaits for a peer connection to be established and calls on_done_func(),...">async_accept()</a> requests in <a class="el" href="classipc_1_1transport_1_1Native__socket__stream__acceptor.html#a5d2e731d023d9c6465e01fa84a6e5138" title="Queue storing deficit async-accept requests queued up due to lacking pending ready peer socket handle...">m_pending_user_requests_q</a> at connection finalization time.  <a href="classipc_1_1transport_1_1Native__socket__stream__acceptor.html#ac04049d9b4c38f2a46d7f26192b17b69">More...</a><br /></td></tr>
<tr class="separator:ac04049d9b4c38f2a46d7f26192b17b69"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2d397e09f2cfa198313ff5c31334080b"><td class="memItemLeft" align="right" valign="top">flow::async::Single_thread_task_loop&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classipc_1_1transport_1_1Native__socket__stream__acceptor.html#a2d397e09f2cfa198313ff5c31334080b">m_worker</a></td></tr>
<tr class="memdesc:a2d397e09f2cfa198313ff5c31334080b"><td class="mdescLeft">&#160;</td><td class="mdescRight">A single-threaded async task loop that starts in constructor and ends in destructor.  <a href="classipc_1_1transport_1_1Native__socket__stream__acceptor.html#a2d397e09f2cfa198313ff5c31334080b">More...</a><br /></td></tr>
<tr class="separator:a2d397e09f2cfa198313ff5c31334080b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a946663a2ab4070babdc80091f5adfb28"><td class="memItemLeft" align="right" valign="top">boost::movelib::unique_ptr&lt; <a class="el" href="namespaceipc_1_1transport_1_1asio__local__stream__socket.html#a154986f10d30d850de86fc3924766e66">asio_local_stream_socket::Acceptor</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classipc_1_1transport_1_1Native__socket__stream__acceptor.html#a946663a2ab4070babdc80091f5adfb28">m_acceptor</a></td></tr>
<tr class="memdesc:a946663a2ab4070babdc80091f5adfb28"><td class="mdescLeft">&#160;</td><td class="mdescRight">Unix domain socket acceptor.  <a href="classipc_1_1transport_1_1Native__socket__stream__acceptor.html#a946663a2ab4070babdc80091f5adfb28">More...</a><br /></td></tr>
<tr class="separator:a946663a2ab4070babdc80091f5adfb28"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7928656e82682f101af9a2fd6d4019cc"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespaceipc_1_1transport_1_1asio__local__stream__socket.html#a1788f9dbd896bb71b3693f9ae25b40ae">asio_local_stream_socket::Peer_socket</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classipc_1_1transport_1_1Native__socket__stream__acceptor.html#a7928656e82682f101af9a2fd6d4019cc">m_next_peer_socket</a></td></tr>
<tr class="memdesc:a7928656e82682f101af9a2fd6d4019cc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Unix domain peer socket, always empty/unconnected while a background <code>m_acceptor.async_accept()</code> is proceeding; then (assuming a successful accept op) connected at the start to the <code><a class="el" href="classipc_1_1transport_1_1Native__socket__stream__acceptor.html#a81426af495ba5a9c832d1ba35fe23ba5" title="Asynchronously awaits for a peer connection to be established and calls on_done_func(),...">async_accept()</a></code> callback; then back to empty/unconnected again just before the next <code><a class="el" href="classipc_1_1transport_1_1Native__socket__stream__acceptor.html#a81426af495ba5a9c832d1ba35fe23ba5" title="Asynchronously awaits for a peer connection to be established and calls on_done_func(),...">async_accept()</a></code> call; and so on.  <a href="classipc_1_1transport_1_1Native__socket__stream__acceptor.html#a7928656e82682f101af9a2fd6d4019cc">More...</a><br /></td></tr>
<tr class="separator:a7928656e82682f101af9a2fd6d4019cc"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="related" name="related"></a>
Related Functions</h2></td></tr>
<tr><td class="ititle" colspan="2"><p >(Note that these are not member functions.) </p>
</td></tr>
<tr class="memitem:a03f0ad84b5d21920a58be5e95f12e69f"><td class="memItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classipc_1_1transport_1_1Native__socket__stream__acceptor.html#a03f0ad84b5d21920a58be5e95f12e69f">operator&lt;&lt;</a> (std::ostream &amp;os, const <a class="el" href="classipc_1_1transport_1_1Native__socket__stream__acceptor.html">Native_socket_stream_acceptor</a> &amp;val)</td></tr>
<tr class="memdesc:a03f0ad84b5d21920a58be5e95f12e69f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Prints string representation of the given <code><a class="el" href="classipc_1_1transport_1_1Native__socket__stream__acceptor.html" title="A server object that binds to a Shared_name and listens for incoming Native_socket_stream::*_connect(...">Native_socket_stream_acceptor</a></code> to the given <code>ostream</code>.  <a href="classipc_1_1transport_1_1Native__socket__stream__acceptor.html#a03f0ad84b5d21920a58be5e95f12e69f">More...</a><br /></td></tr>
<tr class="separator:a03f0ad84b5d21920a58be5e95f12e69f"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p >A server object that binds to a Shared_name and listens for incoming <code><a class="el" href="classipc_1_1transport_1_1Native__socket__stream.html" title="Implements both Native_handle_sender and Native_handle_receiver concepts by using a stream-oriented U...">Native_socket_stream</a>::*_connect()</code> attempts to that name; and yields connected-peer <a class="el" href="classipc_1_1transport_1_1sync__io_1_1Native__socket__stream.html" title="Implements both sync_io::Native_handle_sender and sync_io::Native_handle_receiver concepts by using a...">sync_io::Native_socket_stream</a> objects, one per counterpart opposing <code>*_connect()</code>. </p>
<dl class="section note"><dt>Note</dt><dd>The method is <a class="el" href="classipc_1_1transport_1_1Native__socket__stream__acceptor.html#a81426af495ba5a9c832d1ba35fe23ba5" title="Asynchronously awaits for a peer connection to be established and calls on_done_func(),...">async_accept()</a>; and it yields a PEER-state <a class="el" href="classipc_1_1transport_1_1sync__io_1_1Native__socket__stream.html" title="Implements both sync_io::Native_handle_sender and sync_io::Native_handle_receiver concepts by using a...">sync_io::Native_socket_stream</a> object. Such an object is called a <code><a class="el" href="namespaceipc_1_1transport_1_1sync__io.html" title="sync_io-pattern counterparts to async-I/O-pattern object types in parent namespace ipc::transport.">sync_io</a></code> <em>core</em>. It is often more convenient to work with an async-I/O-pattern object of type <a class="el" href="classipc_1_1transport_1_1Native__socket__stream.html" title="Implements both Native_handle_sender and Native_handle_receiver concepts by using a stream-oriented U...">Native_socket_stream</a> &ndash; it'll perform work in the background without intervention, etc. To get this simply do: <code><a class="el" href="classipc_1_1transport_1_1Native__socket__stream.html" title="Implements both Native_handle_sender and Native_handle_receiver concepts by using a stream-oriented U...">Native_socket_stream</a> async_x(std::move(sync_x))</code>, where <code>sync_x</code> is the aforementioned PEER-state object of type <code><a class="el" href="classipc_1_1transport_1_1sync__io_1_1Native__socket__stream.html" title="Implements both sync_io::Native_handle_sender and sync_io::Native_handle_receiver concepts by using a...">sync_io::Native_socket_stream</a></code>. (<code>sync_x</code> then becomes as-if-default-constructed again. You can even <a class="el" href="classipc_1_1transport_1_1Native__socket__stream__acceptor.html#a81426af495ba5a9c832d1ba35fe23ba5" title="Asynchronously awaits for a peer connection to be established and calls on_done_func(),...">async_accept()</a> into it again.) </dd>
<dd>
Depending on your context you may also bundle <code>sync_x</code> into <a class="el" href="classipc_1_1transport_1_1Channel.html" title="Peer to a bundle of 1-2 full-duplex pipe(s), one for transmitting unstructured binary blobs; the othe...">Channel</a> <code>sync_c</code> &ndash; then create an async-I/O-pattern <a class="el" href="classipc_1_1transport_1_1Channel.html" title="Peer to a bundle of 1-2 full-duplex pipe(s), one for transmitting unstructured binary blobs; the othe...">Channel</a> via: <code>auto async_c = sync_c.async_io_obj()</code>.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classipc_1_1transport_1_1Native__socket__stream.html" title="Implements both Native_handle_sender and Native_handle_receiver concepts by using a stream-oriented U...">Native_socket_stream</a> doc header. </dd>
<dd>
<a class="el" href="classipc_1_1transport_1_1Native__socket__stream.html#a3614a9677c1a203090b97ac935093390" title="To be invoked in NULL state only, it asynchronously attempts to connect to an opposing Native_socket_...">Native_socket_stream::async_connect()</a> doc header.</dd></dl>
<p>This object is straightforward to use, and really the only difficulty comes from (1) choosing a Shared_name and (2) the other side knowing that name. Before deciding to use it and how to use it, it is essential to read the "How to use" section of <a class="el" href="classipc_1_1transport_1_1Native__socket__stream.html" title="Implements both Native_handle_sender and Native_handle_receiver concepts by using a stream-oriented U...">Native_socket_stream</a> doc header. It discusses when to use this, versus an easier (name-free) way to yield a connected-peer <a class="el" href="classipc_1_1transport_1_1Native__socket__stream.html" title="Implements both Native_handle_sender and Native_handle_receiver concepts by using a stream-oriented U...">Native_socket_stream</a>. As you'll see, the only difficulty in using the latter is that it does require a <em>one</em>-time use of <a class="el" href="classipc_1_1transport_1_1Native__socket__stream__acceptor.html" title="A server object that binds to a Shared_name and listens for incoming Native_socket_stream::*_connect(...">Native_socket_stream_acceptor</a> after all. However <a class="el" href="namespaceipc_1_1session.html" title="Flow-IPC module providing the broad lifecycle and shared-resource organization – via the session conc...">ipc::session</a> takes care of that internally &ndash; so you would not need to set up a <a class="el" href="classipc_1_1transport_1_1Native__socket__stream__acceptor.html" title="A server object that binds to a Shared_name and listens for incoming Native_socket_stream::*_connect(...">Native_socket_stream_acceptor</a> after all.</p>
<p >So all in all:</p><ul>
<li>If you've got <a class="el" href="namespaceipc_1_1session.html" title="Flow-IPC module providing the broad lifecycle and shared-resource organization – via the session conc...">ipc::session</a> stuff, you don't need <a class="el" href="classipc_1_1transport_1_1Native__socket__stream__acceptor.html" title="A server object that binds to a Shared_name and listens for incoming Native_socket_stream::*_connect(...">Native_socket_stream_acceptor</a>: you can just open a <a class="el" href="classipc_1_1transport_1_1Channel.html" title="Peer to a bundle of 1-2 full-duplex pipe(s), one for transmitting unstructured binary blobs; the othe...">Channel</a> with a native-handles pipe; it'll contain a PEER-state <a class="el" href="classipc_1_1transport_1_1Native__socket__stream.html" title="Implements both Native_handle_sender and Native_handle_receiver concepts by using a stream-oriented U...">Native_socket_stream</a>.</li>
<li>If you are operating outside <a class="el" href="namespaceipc_1_1session.html" title="Flow-IPC module providing the broad lifecycle and shared-resource organization – via the session conc...">ipc::session</a> then this guy here will let you set up a client/server mechanism for <code><a class="el" href="classipc_1_1transport_1_1Native__socket__stream.html" title="Implements both Native_handle_sender and Native_handle_receiver concepts by using a stream-oriented U...">Native_socket_stream</a></code>s.</li>
</ul>
<dl class="todo"><dt><b><a class="el" href="todo.html#_todo000009">Todo:</a></b></dt><dd>At the moment, <em>if</em> one decides to use a <a class="el" href="classipc_1_1transport_1_1Native__socket__stream__acceptor.html" title="A server object that binds to a Shared_name and listens for incoming Native_socket_stream::*_connect(...">Native_socket_stream_acceptor</a> directly &ndash; not really necessary given <a class="el" href="namespaceipc_1_1session.html" title="Flow-IPC module providing the broad lifecycle and shared-resource organization – via the session conc...">ipc::session</a> <code><a class="el" href="classipc_1_1transport_1_1Channel.html" title="Peer to a bundle of 1-2 full-duplex pipe(s), one for transmitting unstructured binary blobs; the othe...">Channel</a></code>-opening capabilities &ndash; the the user must come up with their own naming scheme that avoids name clashes; we could supply an <a class="el" href="namespaceipc_1_1session.html" title="Flow-IPC module providing the broad lifecycle and shared-resource organization – via the session conc...">ipc::session</a>-facilitated system for providing this service instead. I.e., <a class="el" href="namespaceipc_1_1session.html" title="Flow-IPC module providing the broad lifecycle and shared-resource organization – via the session conc...">ipc::session</a> could either expose a facilities for generating the <code>Shared_name absolute_name</code> arg to the <a class="el" href="classipc_1_1transport_1_1Native__socket__stream__acceptor.html" title="A server object that binds to a Shared_name and listens for incoming Native_socket_stream::*_connect(...">Native_socket_stream_acceptor</a> ctor (and opposing <a class="el" href="classipc_1_1transport_1_1Native__socket__stream.html#a3614a9677c1a203090b97ac935093390" title="To be invoked in NULL state only, it asynchronously attempts to connect to an opposing Native_socket_...">Native_socket_stream::async_connect()</a> call). Alternatively it could provide some kind of <a class="el" href="classipc_1_1transport_1_1Native__socket__stream__acceptor.html" title="A server object that binds to a Shared_name and listens for incoming Native_socket_stream::*_connect(...">Native_socket_stream_acceptor</a> factory and corresponding opposing facility. Long story short, within the <a class="el" href="namespaceipc_1_1session.html" title="Flow-IPC module providing the broad lifecycle and shared-resource organization – via the session conc...">ipc::session</a> way of life literally only one acceptor exists, and it is set up (and named) internally to <a class="el" href="namespaceipc_1_1session.html" title="Flow-IPC module providing the broad lifecycle and shared-resource organization – via the session conc...">ipc::session</a>. We could provide a way to facilitate the creation of more acceptors if desired by helping to choose their <code>Shared_name</code>s. (The original "paper" design did specify a naming scheme for this.)</dd></dl>
<h3>Implementation</h3>
<p >It is fairly self-explanatory. Historic note: I (ygoldfel) wrote this after the far more complex <a class="el" href="classipc_1_1transport_1_1Native__socket__stream.html" title="Implements both Native_handle_sender and Native_handle_receiver concepts by using a stream-oriented U...">Native_socket_stream</a>. We do use the same concepts here: The ctor immediately starts a thread that reads off all incoming connects ASAP. There is a surplus queue of such connects; and a deficit queue of pending <a class="el" href="classipc_1_1transport_1_1Native__socket__stream__acceptor.html#a81426af495ba5a9c832d1ba35fe23ba5" title="Asynchronously awaits for a peer connection to be established and calls on_done_func(),...">async_accept()</a> requests from user. A steady state is maintained of either an empty surplus and possibly non-empty deficit; or vice versa. However there are no heavy-weight buffers involved, so copy avoidance is not a factor &ndash; it is pretty simple. Also there is no outgoing-direction pipe which further cuts complexity in at least half.</p>
<p >Later, after the <code><a class="el" href="namespaceipc_1_1transport_1_1sync__io.html" title="sync_io-pattern counterparts to async-I/O-pattern object types in parent namespace ipc::transport.">sync_io</a></code> pattern was introduced, <a class="el" href="classipc_1_1transport_1_1Native__socket__stream.html" title="Implements both Native_handle_sender and Native_handle_receiver concepts by using a stream-oriented U...">Native_socket_stream</a> was split into <a class="el" href="classipc_1_1transport_1_1Native__socket__stream.html" title="Implements both Native_handle_sender and Native_handle_receiver concepts by using a stream-oriented U...">Native_socket_stream</a> (identical API and semantics) and <code><a class="el" href="namespaceipc_1_1transport_1_1sync__io.html" title="sync_io-pattern counterparts to async-I/O-pattern object types in parent namespace ipc::transport.">sync_io</a></code> core <a class="el" href="classipc_1_1transport_1_1sync__io_1_1Native__socket__stream.html" title="Implements both sync_io::Native_handle_sender and sync_io::Native_handle_receiver concepts by using a...">sync_io::Native_socket_stream</a>; and the latter's core logic was moved to reused-elsewhere sync-to-async adapters <a class="el" href="classipc_1_1transport_1_1sync__io_1_1Async__adapter__sender.html" title="Internal-use type that adapts a given PEER-state sync_io::Native_handle_sender or sync_io::Blob_sende...">sync_io::Async_adapter_sender</a> and <a class="el" href="classipc_1_1transport_1_1sync__io_1_1Async__adapter__receiver.html" title="Internal-use type that adapts a given PEER-state sync_io::Native_handle_receiver or sync_io::Blob_rec...">sync_io::Async_adapter_receiver</a>. Furthermore (and this is more relevant here) internally the latter guy was changed <em>away</em> from reading as many in-messages as were available in the kernel receive buffer &ndash; even when no <code>async_receive_*()</code> user requests were pending. (Before the change: Such "cached" messages would need to be copied and stored until the user requests came &ndash; a/k/a the <em>surplus</em> was resolved.) So that was changed; it would only read enough messages to satisfy the currently outstanding <code>async_receive_*()</code>s. The rest would be left in the kernel buffer. In other words there could be a <em>deficit</em> still; but there could never be a <em>surplus</em> in that changed (internal) design.</p>
<p >Now, despite that change, <a class="el" href="classipc_1_1transport_1_1Native__socket__stream__acceptor.html" title="A server object that binds to a Shared_name and listens for incoming Native_socket_stream::*_connect(...">Native_socket_stream_acceptor</a> was left unchanged. It still, internally, accepts as many as are available; and caches a surplus internally if one occurs (until <a class="el" href="classipc_1_1transport_1_1Native__socket__stream__acceptor.html#a81426af495ba5a9c832d1ba35fe23ba5" title="Asynchronously awaits for a peer connection to be established and calls on_done_func(),...">async_accept()</a> x N come in to balance it iout). The rationale? Well, it was just a good feature. There's no copying (of anything sizable) involved, and it seemed like a decent idea to not leave handles languishing in some kernel queue. Essentially the reasoning for that change inside <a class="el" href="classipc_1_1transport_1_1Native__socket__stream.html" title="Implements both Native_handle_sender and Native_handle_receiver concepts by using a stream-oriented U...">Native_socket_stream</a> (and <a class="el" href="classipc_1_1transport_1_1Blob__stream__mq__receiver.html" title="Implements Blob_receiver concept by using an adopted Persistent_mq_handle MQ handle to an MQ (message...">Blob_stream_mq_receiver</a>) &ndash; well outside our scope here &ndash; simply did not apply to <a class="el" href="classipc_1_1transport_1_1Native__socket__stream__acceptor.html" title="A server object that binds to a Shared_name and listens for incoming Native_socket_stream::*_connect(...">Native_socket_stream_acceptor</a>. </p>

<p class="definition">Definition at line <a class="el" href="native__socket__stream__acceptor_8hpp_source.html#l00102">102</a> of file <a class="el" href="native__socket__stream__acceptor_8hpp_source.html">native_socket_stream_acceptor.hpp</a>.</p>
</div><h2 class="groupheader">Member Typedef Documentation</h2>
<a id="a863aa3fe53c71e3b33814f7caecbb193" name="a863aa3fe53c71e3b33814f7caecbb193"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a863aa3fe53c71e3b33814f7caecbb193">&#9670;&nbsp;</a></span>Async_io_obj</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classipc_1_1transport_1_1Native__socket__stream__acceptor.html#a863aa3fe53c71e3b33814f7caecbb193">ipc::transport::Native_socket_stream_acceptor::Async_io_obj</a> =  <a class="el" href="classipc_1_1transport_1_1Null__peer.html">Null_peer</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>You may disregard. </p>

<p class="definition">Definition at line <a class="el" href="native__socket__stream__acceptor_8hpp_source.html#l00115">115</a> of file <a class="el" href="native__socket__stream__acceptor_8hpp_source.html">native_socket_stream_acceptor.hpp</a>.</p>

</div>
</div>
<a id="ab5fa8c28eb4dbe2ae2e4f1b25d520857" name="ab5fa8c28eb4dbe2ae2e4f1b25d520857"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab5fa8c28eb4dbe2ae2e4f1b25d520857">&#9670;&nbsp;</a></span>On_peer_accepted_func</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classipc_1_1transport_1_1Native__socket__stream__acceptor.html#ab5fa8c28eb4dbe2ae2e4f1b25d520857">ipc::transport::Native_socket_stream_acceptor::On_peer_accepted_func</a> =  flow::async::Task_asio_err</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Short-hand for callback called on new peer-to-peer connection; or on unrecoverable error. </p>

<p class="definition">Definition at line <a class="el" href="native__socket__stream__acceptor_8hpp_source.html#l00241">241</a> of file <a class="el" href="native__socket__stream__acceptor_8hpp_source.html">native_socket_stream_acceptor.hpp</a>.</p>

</div>
</div>
<a id="a3707eaee28b6bacded15ba4cdab3da48" name="a3707eaee28b6bacded15ba4cdab3da48"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3707eaee28b6bacded15ba4cdab3da48">&#9670;&nbsp;</a></span>Peer</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classipc_1_1transport_1_1Native__socket__stream__acceptor.html#a3707eaee28b6bacded15ba4cdab3da48">ipc::transport::Native_socket_stream_acceptor::Peer</a> =  <a class="el" href="classipc_1_1transport_1_1Native__socket__stream.html#a850af22a95f27d8696b9b5bca15454b5">Native_socket_stream::Sync_io_obj</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Short-hand for type of target peer-socket objects targeted by <a class="el" href="classipc_1_1transport_1_1Native__socket__stream__acceptor.html#a81426af495ba5a9c832d1ba35fe23ba5" title="Asynchronously awaits for a peer connection to be established and calls on_done_func(),...">async_accept()</a>. </p>

<p class="definition">Definition at line <a class="el" href="native__socket__stream__acceptor_8hpp_source.html#l00110">110</a> of file <a class="el" href="native__socket__stream__acceptor_8hpp_source.html">native_socket_stream_acceptor.hpp</a>.</p>

</div>
</div>
<a id="a476652737140b761264000ffa4204e4a" name="a476652737140b761264000ffa4204e4a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a476652737140b761264000ffa4204e4a">&#9670;&nbsp;</a></span>Peer_ptr</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classipc_1_1transport_1_1Native__socket__stream__acceptor.html#a476652737140b761264000ffa4204e4a">ipc::transport::Native_socket_stream_acceptor::Peer_ptr</a> =  boost::movelib::unique_ptr&lt;<a class="el" href="classipc_1_1transport_1_1Native__socket__stream__acceptor.html#a3707eaee28b6bacded15ba4cdab3da48">Peer</a>&gt;</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Short-hand for internally stored PEER-state <a class="el" href="classipc_1_1transport_1_1sync__io_1_1Native__socket__stream.html" title="Implements both sync_io::Native_handle_sender and sync_io::Native_handle_receiver concepts by using a...">sync_io::Native_socket_stream</a> in <a class="el" href="classipc_1_1transport_1_1Native__socket__stream__acceptor.html#ac04049d9b4c38f2a46d7f26192b17b69" title="Queue storing surplus finalized async-accept results queued up due to lacking async_accept() requests...">m_pending_results_q</a>. </p>

<p class="definition">Definition at line <a class="el" href="native__socket__stream__acceptor_8hpp_source.html#l00244">244</a> of file <a class="el" href="native__socket__stream__acceptor_8hpp_source.html">native_socket_stream_acceptor.hpp</a>.</p>

</div>
</div>
<a id="ac0e1478364d940f243acece27ece5a7c" name="ac0e1478364d940f243acece27ece5a7c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac0e1478364d940f243acece27ece5a7c">&#9670;&nbsp;</a></span>Sync_io_obj</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classipc_1_1transport_1_1Native__socket__stream__acceptor.html#ac0e1478364d940f243acece27ece5a7c">ipc::transport::Native_socket_stream_acceptor::Sync_io_obj</a> =  <a class="el" href="classipc_1_1transport_1_1sync__io_1_1Native__socket__stream__acceptor.html">sync_io::Native_socket_stream_acceptor</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Useful for generic programming, the <code><a class="el" href="namespaceipc_1_1transport_1_1sync__io.html" title="sync_io-pattern counterparts to async-I/O-pattern object types in parent namespace ipc::transport.">sync_io</a></code>-pattern counterpart to <code>*this</code> type. </p>

<p class="definition">Definition at line <a class="el" href="native__socket__stream__acceptor_8hpp_source.html#l00113">113</a> of file <a class="el" href="native__socket__stream__acceptor_8hpp_source.html">native_socket_stream_acceptor.hpp</a>.</p>

</div>
</div>
<h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="a77795acb028a95a4804f9b3ef18d99b0" name="a77795acb028a95a4804f9b3ef18d99b0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a77795acb028a95a4804f9b3ef18d99b0">&#9670;&nbsp;</a></span>Native_socket_stream_acceptor()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">ipc::transport::Native_socket_stream_acceptor::Native_socket_stream_acceptor </td>
          <td>(</td>
          <td class="paramtype">flow::log::Logger *&#160;</td>
          <td class="paramname"><em>logger_ptr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespaceipc_1_1transport.html#a33de1c256addb3964b839dc2dd407d24">Shared_name</a> &amp;&#160;</td>
          <td class="paramname"><em>absolute_name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceipc.html#aa3192e586cc45d3e7c22463bf2760f89">Error_code</a> *&#160;</td>
          <td class="paramname"><em>err_code</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">explicit</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Creates the <a class="el" href="classipc_1_1transport_1_1Native__socket__stream__acceptor.html" title="A server object that binds to a Shared_name and listens for incoming Native_socket_stream::*_connect(...">Native_socket_stream_acceptor</a> and immediately begins listening in the background, so that other process(es) can connect to it &ndash; at the specified name &ndash; once the constructor returns successfully. </p>
<p >The operation may fail; see <code>err_code</code> arg for how to detect this (either exception or via code return; your choice). An error will be logged on failure.</p>
<p >On success, opposing processes can attempt <a class="el" href="classipc_1_1transport_1_1Native__socket__stream.html#a3614a9677c1a203090b97ac935093390" title="To be invoked in NULL state only, it asynchronously attempts to connect to an opposing Native_socket_...">Native_socket_stream::async_connect()</a> (or <a class="el" href="classipc_1_1transport_1_1sync__io_1_1Native__socket__stream.html#a3fed4817936af7f23d2beb8f75999d8d" title="See Async_io_obj counterpart for the essential semantics; however here according to sync_io pattern t...">sync_io::Native_socket_stream::async_connect()</a>) which will quickly succeed yielding an opposing <a class="el" href="classipc_1_1transport_1_1Native__socket__stream__acceptor.html#a3707eaee28b6bacded15ba4cdab3da48" title="Short-hand for type of target peer-socket objects targeted by async_accept().">Peer</a> which will be connected. On this side, <a class="el" href="classipc_1_1transport_1_1Native__socket__stream__acceptor.html#a81426af495ba5a9c832d1ba35fe23ba5" title="Asynchronously awaits for a peer connection to be established and calls on_done_func(),...">async_accept()</a> is used to grab local peer <a class="el" href="classipc_1_1transport_1_1Native__socket__stream__acceptor.html#a3707eaee28b6bacded15ba4cdab3da48" title="Short-hand for type of target peer-socket objects targeted by async_accept().">Peer</a>. The connection need not have an <a class="el" href="classipc_1_1transport_1_1Native__socket__stream__acceptor.html#a81426af495ba5a9c832d1ba35fe23ba5" title="Asynchronously awaits for a peer connection to be established and calls on_done_func(),...">async_accept()</a> pending to complete connection as observed by the opposing process.</p>
<p >Assuming this ctor succeeds, further background operation may detect an unrecoverable error. If this occurs, it will occur exactly once, and it is guaranteed no connections will be accepted subsequently; <code><a class="el" href="classipc_1_1transport_1_1Native__socket__stream__acceptor.html#a81426af495ba5a9c832d1ba35fe23ba5" title="Asynchronously awaits for a peer connection to be established and calls on_done_func(),...">async_accept()</a></code>s beyond that point (once all successfully queued-up connects, if any, are exhausted) will fail with that error.</p>
<p ><code>absolute_name</code> should be considered carefully. It cannot clash with another acceptor in existence, and it might even be a mediocre idea to clash with one that <em>has</em> recently existed. Plus the opposing <a class="el" href="classipc_1_1transport_1_1Native__socket__stream.html" title="Implements both Native_handle_sender and Native_handle_receiver concepts by using a stream-oriented U...">Native_socket_stream</a> (or <a class="el" href="classipc_1_1transport_1_1sync__io_1_1Native__socket__stream.html" title="Implements both sync_io::Native_handle_sender and sync_io::Native_handle_receiver concepts by using a...">sync_io::Native_socket_stream</a>) needs to know <code>absolute_name</code>.</p>
<h3>Rationale/context</h3>
<p >An <a class="el" href="classipc_1_1transport_1_1Native__socket__stream__acceptor.html" title="A server object that binds to a Shared_name and listens for incoming Native_socket_stream::*_connect(...">Native_socket_stream_acceptor</a> is unlikely to be used except by <a class="el" href="namespaceipc_1_1session.html" title="Flow-IPC module providing the broad lifecycle and shared-resource organization – via the session conc...">ipc::session</a>, internally, in any case. Once a session is established, one is ~certain to use <a class="el" href="classipc_1_1transport_1_1Channel.html" title="Peer to a bundle of 1-2 full-duplex pipe(s), one for transmitting unstructured binary blobs; the othe...">ipc::transport::Channel</a> to establish connections, and that intentionally avoids <a class="el" href="classipc_1_1transport_1_1Native__socket__stream__acceptor.html" title="A server object that binds to a Shared_name and listens for incoming Native_socket_stream::*_connect(...">Native_socket_stream_acceptor</a>, because then one need not worry about this thorny naming issue. Nevertheless we provide <a class="el" href="classipc_1_1transport_1_1Native__socket__stream__acceptor.html" title="A server object that binds to a Shared_name and listens for incoming Native_socket_stream::*_connect(...">Native_socket_stream_acceptor</a> as a public API, in case it's generally useful.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">logger_ptr</td><td>Logger to use for subsequently logging. </td></tr>
    <tr><td class="paramname">absolute_name</td><td>The absolute name at which to bind and listen for connections. </td></tr>
    <tr><td class="paramname">err_code</td><td>See <code>flow::Error_code</code> docs for error reporting semantics. <a class="el" href="namespaceipc.html#aa3192e586cc45d3e7c22463bf2760f89" title="Short-hand for flow::Error_code which is very common.">Error_code</a> generated: <code>boost::asio::error::invalid_argument</code> (<a class="el" href="classipc_1_1transport_1_1Native__socket__stream__acceptor.html" title="A server object that binds to a Shared_name and listens for incoming Native_socket_stream::*_connect(...">Native_socket_stream_acceptor</a> failed to initialize specifically: because the given or computed address/name ended up too long to fit into natively-mandated data structures; or because there are invalid characters therein, most likely forward-slash), <code>boost::asio::error::address_in_use</code> (<a class="el" href="classipc_1_1transport_1_1Native__socket__stream__acceptor.html" title="A server object that binds to a Shared_name and listens for incoming Native_socket_stream::*_connect(...">Native_socket_stream_acceptor</a> failed to initialize due to a name clash), possibly other system codes (<a class="el" href="classipc_1_1transport_1_1Native__socket__stream__acceptor.html" title="A server object that binds to a Shared_name and listens for incoming Native_socket_stream::*_connect(...">Native_socket_stream_acceptor</a> failed to initialize for some other reason we could not predict here, but whatever it was was logged). </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="native__socket__stream__acceptor_8cpp_source.html#l00037">37</a> of file <a class="el" href="native__socket__stream__acceptor_8cpp_source.html">native_socket_stream_acceptor.cpp</a>.</p>

<p class="reference">References <a class="el" href="detail_2asio__local__stream__socket_8cpp_source.html#l00028">ipc::transport::asio_local_stream_socket::endpoint_at_shared_name()</a>, <a class="el" href="native__socket__stream__acceptor_8hpp_source.html#l00335">m_absolute_name</a>, <a class="el" href="native__socket__stream__acceptor_8hpp_source.html#l00369">m_acceptor</a>, <a class="el" href="native__socket__stream__acceptor_8hpp_source.html#l00388">m_next_peer_socket</a>, <a class="el" href="native__socket__stream__acceptor_8hpp_source.html#l00363">m_worker</a>, and <a class="el" href="native__socket__stream__acceptor_8cpp_source.html#l00181">on_next_peer_socket_or_error()</a>.</p>
<div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="classipc_1_1transport_1_1Native__socket__stream__acceptor_a77795acb028a95a4804f9b3ef18d99b0_cgraph.svg" width="903" height="312"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe>
</div>
</div>

</div>
</div>
<a id="a71e907b904bcc8aff0042ca7efcc783b" name="a71e907b904bcc8aff0042ca7efcc783b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a71e907b904bcc8aff0042ca7efcc783b">&#9670;&nbsp;</a></span>~Native_socket_stream_acceptor()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ipc::transport::Native_socket_stream_acceptor::~Native_socket_stream_acceptor </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Destroys this acceptor which will stop listening in the background and cancel any pending completion handlers by invoking them ASAP with <a class="el" href="namespaceipc_1_1transport_1_1error.html#adfef15ef4e76cc55d652fbd9c2797297afe29343445a7bf167cc186a44bd2c6ed" title="Async completion handler is being called prematurely, because underlying object is shutting down,...">error::Code::S_OBJECT_SHUTDOWN_ABORTED_COMPLETION_HANDLER</a>. </p>
<p >You must not call this from directly within a completion handler; else undefined behavior.</p>
<p >Each pending completion handler will be called from an unspecified thread that is not the calling thread. Any associated captured state for that handler will be freed shortly after the handler returns.</p>
<p >We informally but very strongly recommend that your completion handler immediately return if the <code>Error_code</code> passed to it is <a class="el" href="namespaceipc_1_1transport_1_1error.html#adfef15ef4e76cc55d652fbd9c2797297afe29343445a7bf167cc186a44bd2c6ed" title="Async completion handler is being called prematurely, because underlying object is shutting down,...">error::Code::S_OBJECT_SHUTDOWN_ABORTED_COMPLETION_HANDLER</a>. This is similar to what one should do when using boost.asio and receiving the conceptually identical <code>operation_aborted</code> error code to an <code>async_...()</code> completion handler. In both cases, this condition means, "we have decided to shut this thing down,
so the completion handlers are simply being informed of this." </p>

<p class="definition">Definition at line <a class="el" href="native__socket__stream__acceptor_8cpp_source.html#l00131">131</a> of file <a class="el" href="native__socket__stream__acceptor_8cpp_source.html">native_socket_stream_acceptor.cpp</a>.</p>

<p class="reference">References <a class="el" href="native__socket__stream__acceptor_8hpp_source.html#l00346">m_pending_user_requests_q</a>, <a class="el" href="native__socket__stream__acceptor_8hpp_source.html#l00363">m_worker</a>, and <a class="el" href="namespaceipc_1_1transport_1_1error.html#adfef15ef4e76cc55d652fbd9c2797297afe29343445a7bf167cc186a44bd2c6ed">ipc::transport::error::S_OBJECT_SHUTDOWN_ABORTED_COMPLETION_HANDLER</a>.</p>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="ac5b70ff8230fa49c99ccb6954db71c75" name="ac5b70ff8230fa49c99ccb6954db71c75"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac5b70ff8230fa49c99ccb6954db71c75">&#9670;&nbsp;</a></span>absolute_name()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="namespaceipc_1_1transport.html#a33de1c256addb3964b839dc2dd407d24">Shared_name</a> &amp; ipc::transport::Native_socket_stream_acceptor::absolute_name </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the full name/address to which the constructor bound, or attempted to bind, the listening socket. </p>
<dl class="section return"><dt>Returns</dt><dd>See above. </dd></dl>

<p class="definition">Definition at line <a class="el" href="native__socket__stream__acceptor_8cpp_source.html#l00464">464</a> of file <a class="el" href="native__socket__stream__acceptor_8cpp_source.html">native_socket_stream_acceptor.cpp</a>.</p>

<p class="reference">References <a class="el" href="native__socket__stream__acceptor_8hpp_source.html#l00335">m_absolute_name</a>.</p>

<p class="reference">Referenced by <a class="el" href="sync__io_2native__socket__stream__acceptor_8cpp_source.html#l00076">ipc::transport::sync_io::Native_socket_stream_acceptor::absolute_name()</a>, and <a class="el" href="native__socket__stream__acceptor_8cpp_source.html#l00469">operator&lt;&lt;()</a>.</p>
<div class="dynheader">
Here is the caller graph for this function:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="classipc_1_1transport_1_1Native__socket__stream__acceptor_ac5b70ff8230fa49c99ccb6954db71c75_icgraph.svg" width="596" height="131"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe>
</div>
</div>

</div>
</div>
<a id="a81426af495ba5a9c832d1ba35fe23ba5" name="a81426af495ba5a9c832d1ba35fe23ba5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a81426af495ba5a9c832d1ba35fe23ba5">&#9670;&nbsp;</a></span>async_accept()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Task_err &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void ipc::transport::Native_socket_stream_acceptor::async_accept </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classipc_1_1transport_1_1Native__socket__stream__acceptor.html#a3707eaee28b6bacded15ba4cdab3da48">Peer</a> *&#160;</td>
          <td class="paramname"><em>target_peer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Task_err &amp;&amp;&#160;</td>
          <td class="paramname"><em>on_done_func</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Asynchronously awaits for a peer connection to be established and calls <code>on_done_func()</code>, once the connection occurs, or an error occurs, in the former case move-assigning a PEER-state <a class="el" href="classipc_1_1transport_1_1Native__socket__stream.html" title="Implements both Native_handle_sender and Native_handle_receiver concepts by using a stream-oriented U...">Native_socket_stream</a> object to the passed-in <a class="el" href="classipc_1_1transport_1_1Native__socket__stream.html" title="Implements both Native_handle_sender and Native_handle_receiver concepts by using a stream-oriented U...">Native_socket_stream</a> <code>*target_peer</code>. </p>
<p ><code>on_done_func(Error_code())</code> is called on success. <code>on_done_func(E)</code>, where <code>E</code> is a non-success error code, is called otherwise. In the latter case <code>*this</code> has met an unrecoverable error and should be shut down via the destructor, as no further <code><a class="el" href="classipc_1_1transport_1_1Native__socket__stream__acceptor.html#a81426af495ba5a9c832d1ba35fe23ba5" title="Asynchronously awaits for a peer connection to be established and calls on_done_func(),...">async_accept()</a></code>s will succeed (they'll quickly yield the same error).</p>
<p >Multiple <a class="el" href="classipc_1_1transport_1_1Native__socket__stream__acceptor.html#a81426af495ba5a9c832d1ba35fe23ba5" title="Asynchronously awaits for a peer connection to be established and calls on_done_func(),...">async_accept()</a> calls can be queued while no connection is pending; they will grab incoming connections in FIFO fashion as they arrive.</p>
<p >The aforementioned <a class="el" href="classipc_1_1transport_1_1Native__socket__stream__acceptor.html#a3707eaee28b6bacded15ba4cdab3da48" title="Short-hand for type of target peer-socket objects targeted by async_accept().">Peer</a> generated and move-assigned to <code>*target_peer</code> on success shall inherit <code>this-&gt;get_logger()</code> as its <code>-&gt;get_logger()</code>; and its sync_op::Native_socket_stream::nickname() shall be something descriptive.</p>
<p ><code>on_done_func()</code> shall be called from some unspecified thread, not the calling thread, but never concurrently with other such completion handlers. Your implementation must be non-blocking. Informally we recommend it place the true on-event logic onto some task loop of your own; so ideally it would consist of essentially a single <code>post(F)</code> statement of some kind. There are certainly reasons to not follow this recommendation, though, in some use cases.</p>
<p ><code>on_done_func()</code> <em>will</em> be called; at the latest when the destructor is invoked (see below).</p>
<p >You may call this from directly within a completion handler. Handlers will still always be called non-concurrently, and a handler will never be called from within a handler (so it is safe, e.g., to bracket your handler with a non-recursive mutex lock).</p>
<p ><a class="el" href="namespaceipc.html#aa3192e586cc45d3e7c22463bf2760f89" title="Short-hand for flow::Error_code which is very common.">Error_code</a> generated and passed to <code>on_done_func()</code>: <a class="el" href="namespaceipc_1_1transport_1_1error.html#adfef15ef4e76cc55d652fbd9c2797297afe29343445a7bf167cc186a44bd2c6ed" title="Async completion handler is being called prematurely, because underlying object is shutting down,...">error::Code::S_OBJECT_SHUTDOWN_ABORTED_COMPLETION_HANDLER</a> (destructor called, canceling all pending ops; spiritually identical to <code>boost::asio::error::operation_aborted</code>), other system codes most likely from <code>boost::asio::error</code> or <code>boost::system::errc</code> (but never would-block), indicating the underlying transport is hosed for that specific reason.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Task_err</td><td>Handler type matching signature of <code>flow::async::Task_asio_err</code>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">target_peer</td><td>Pointer to <a class="el" href="classipc_1_1transport_1_1sync__io_1_1Native__socket__stream.html" title="Implements both sync_io::Native_handle_sender and sync_io::Native_handle_receiver concepts by using a...">sync_io::Native_socket_stream</a> which shall be assigned a PEER-state (connected) as <code>on_done_func()</code> is called. Not touched on error. </td></tr>
    <tr><td class="paramname">on_done_func</td><td>Completion handler. See above. The captured state in this function object shall be freed shortly upon its completed execution from the unspecified thread. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="native__socket__stream__acceptor_8hpp_source.html#l00396">396</a> of file <a class="el" href="native__socket__stream__acceptor_8hpp_source.html">native_socket_stream_acceptor.hpp</a>.</p>

<p class="reference">References <a class="el" href="native__socket__stream__acceptor_8cpp_source.html#l00309">async_accept_impl()</a>.</p>

<p class="reference">Referenced by <a class="el" href="sync__io_2native__socket__stream__acceptor_8hpp_source.html#l00249">ipc::transport::sync_io::Native_socket_stream_acceptor::async_accept()</a>.</p>
<div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="classipc_1_1transport_1_1Native__socket__stream__acceptor_a81426af495ba5a9c832d1ba35fe23ba5_cgraph.svg" width="602" height="144"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe>
</div>
</div>
<div class="dynheader">
Here is the caller graph for this function:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="classipc_1_1transport_1_1Native__socket__stream__acceptor_a81426af495ba5a9c832d1ba35fe23ba5_icgraph.svg" width="382" height="59"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe>
</div>
</div>

</div>
</div>
<a id="a2063fff89b58cc5b07ee7651f9e42366" name="a2063fff89b58cc5b07ee7651f9e42366"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2063fff89b58cc5b07ee7651f9e42366">&#9670;&nbsp;</a></span>async_accept_impl()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void ipc::transport::Native_socket_stream_acceptor::async_accept_impl </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classipc_1_1transport_1_1Native__socket__stream__acceptor.html#a3707eaee28b6bacded15ba4cdab3da48">Peer</a> *&#160;</td>
          <td class="paramname"><em>target_peer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classipc_1_1transport_1_1Native__socket__stream__acceptor.html#ab5fa8c28eb4dbe2ae2e4f1b25d520857">On_peer_accepted_func</a> &amp;&amp;&#160;</td>
          <td class="paramname"><em>on_done_func</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Non-template impl of <a class="el" href="classipc_1_1transport_1_1Native__socket__stream__acceptor.html#a81426af495ba5a9c832d1ba35fe23ba5" title="Asynchronously awaits for a peer connection to be established and calls on_done_func(),...">async_accept()</a>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">target_peer</td><td>See <a class="el" href="classipc_1_1transport_1_1Native__socket__stream__acceptor.html#a81426af495ba5a9c832d1ba35fe23ba5" title="Asynchronously awaits for a peer connection to be established and calls on_done_func(),...">async_accept()</a>. </td></tr>
    <tr><td class="paramname">on_done_func</td><td>See <a class="el" href="classipc_1_1transport_1_1Native__socket__stream__acceptor.html#a81426af495ba5a9c832d1ba35fe23ba5" title="Asynchronously awaits for a peer connection to be established and calls on_done_func(),...">async_accept()</a>. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="native__socket__stream__acceptor_8cpp_source.html#l00309">309</a> of file <a class="el" href="native__socket__stream__acceptor_8cpp_source.html">native_socket_stream_acceptor.cpp</a>.</p>

<p class="reference">References <a class="el" href="native__socket__stream__acceptor_8cpp_source.html#l00434">feed_error_result_to_deficit()</a>, <a class="el" href="native__socket__stream__acceptor_8cpp_source.html#l00451">feed_success_result_to_deficit()</a>, <a class="el" href="native__socket__stream__acceptor_8hpp_source.html#l00355">m_pending_results_q</a>, <a class="el" href="native__socket__stream__acceptor_8hpp_source.html#l00346">m_pending_user_requests_q</a>, and <a class="el" href="native__socket__stream__acceptor_8hpp_source.html#l00363">m_worker</a>.</p>

<p class="reference">Referenced by <a class="el" href="native__socket__stream__acceptor_8hpp_source.html#l00396">async_accept()</a>.</p>
<div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="classipc_1_1transport_1_1Native__socket__stream__acceptor_a2063fff89b58cc5b07ee7651f9e42366_cgraph.svg" width="395" height="144"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe>
</div>
</div>
<div class="dynheader">
Here is the caller graph for this function:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="classipc_1_1transport_1_1Native__socket__stream__acceptor_a2063fff89b58cc5b07ee7651f9e42366_icgraph.svg" width="588" height="59"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe>
</div>
</div>

</div>
</div>
<a id="a8ff2e85b30532cb9778aa43c01931955" name="a8ff2e85b30532cb9778aa43c01931955"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8ff2e85b30532cb9778aa43c01931955">&#9670;&nbsp;</a></span>feed_error_result_to_deficit()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void ipc::transport::Native_socket_stream_acceptor::feed_error_result_to_deficit </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespaceipc.html#aa3192e586cc45d3e7c22463bf2760f89">Error_code</a> &amp;&#160;</td>
          <td class="paramname"><em>err_code</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>In thread W, gets back to steady state by feeding the given <a class="el" href="namespaceipc.html#aa3192e586cc45d3e7c22463bf2760f89" title="Short-hand for flow::Error_code which is very common.">Error_code</a> (which must be the sole element in <a class="el" href="classipc_1_1transport_1_1Native__socket__stream__acceptor.html#ac04049d9b4c38f2a46d7f26192b17b69" title="Queue storing surplus finalized async-accept results queued up due to lacking async_accept() requests...">m_pending_results_q</a>) to all queued user requests, popping them all. </p>
<p >The pre-condition is that doing so <em>would</em> in fact get the deficit and surplus queues collectively to steady state; and also that there <em>is</em> in fact a deficit (at least one request in <a class="el" href="classipc_1_1transport_1_1Native__socket__stream__acceptor.html#a5d2e731d023d9c6465e01fa84a6e5138" title="Queue storing deficit async-accept requests queued up due to lacking pending ready peer socket handle...">m_pending_user_requests_q</a>).</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">err_code</td><td>The code to feed (must be at top of <a class="el" href="classipc_1_1transport_1_1Native__socket__stream__acceptor.html#ac04049d9b4c38f2a46d7f26192b17b69" title="Queue storing surplus finalized async-accept results queued up due to lacking async_accept() requests...">m_pending_results_q</a>). This is supplied as an arg for perf at most. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="native__socket__stream__acceptor_8cpp_source.html#l00434">434</a> of file <a class="el" href="native__socket__stream__acceptor_8cpp_source.html">native_socket_stream_acceptor.cpp</a>.</p>

<p class="reference">References <a class="el" href="native__socket__stream__acceptor_8hpp_source.html#l00346">m_pending_user_requests_q</a>.</p>

<p class="reference">Referenced by <a class="el" href="native__socket__stream__acceptor_8cpp_source.html#l00309">async_accept_impl()</a>, and <a class="el" href="native__socket__stream__acceptor_8cpp_source.html#l00377">finalize_q_surplus_on_error()</a>.</p>
<div class="dynheader">
Here is the caller graph for this function:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="classipc_1_1transport_1_1Native__socket__stream__acceptor_a8ff2e85b30532cb9778aa43c01931955_icgraph.svg" width="903" height="155"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe>
</div>
</div>

</div>
</div>
<a id="af1ca26531b9dd649046086e4e17f0ba3" name="af1ca26531b9dd649046086e4e17f0ba3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af1ca26531b9dd649046086e4e17f0ba3">&#9670;&nbsp;</a></span>feed_success_result_to_deficit()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void ipc::transport::Native_socket_stream_acceptor::feed_success_result_to_deficit </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classipc_1_1transport_1_1Native__socket__stream__acceptor.html#a476652737140b761264000ffa4204e4a">Peer_ptr</a> &amp;&amp;&#160;</td>
          <td class="paramname"><em>peer</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>In thread W, gets back to steady state by feeding the given just-connected peer socket (which must have just been popped from <a class="el" href="classipc_1_1transport_1_1Native__socket__stream__acceptor.html#ac04049d9b4c38f2a46d7f26192b17b69" title="Queue storing surplus finalized async-accept results queued up due to lacking async_accept() requests...">m_pending_results_q</a>) to the first queued user request, popping it. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">peer</td><td>The peer stream handle to feed (must have just been popped from <a class="el" href="classipc_1_1transport_1_1Native__socket__stream__acceptor.html#ac04049d9b4c38f2a46d7f26192b17b69" title="Queue storing surplus finalized async-accept results queued up due to lacking async_accept() requests...">m_pending_results_q</a>). </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="native__socket__stream__acceptor_8cpp_source.html#l00451">451</a> of file <a class="el" href="native__socket__stream__acceptor_8cpp_source.html">native_socket_stream_acceptor.cpp</a>.</p>

<p class="reference">References <a class="el" href="native__socket__stream__acceptor_8hpp_source.html#l00346">m_pending_user_requests_q</a>.</p>

<p class="reference">Referenced by <a class="el" href="native__socket__stream__acceptor_8cpp_source.html#l00309">async_accept_impl()</a>, and <a class="el" href="native__socket__stream__acceptor_8cpp_source.html#l00405">finalize_q_surplus_on_success()</a>.</p>
<div class="dynheader">
Here is the caller graph for this function:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="classipc_1_1transport_1_1Native__socket__stream__acceptor_af1ca26531b9dd649046086e4e17f0ba3_icgraph.svg" width="866" height="155"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe>
</div>
</div>

</div>
</div>
<a id="a6c7c14574c041bcfd1ccb45137b486b4" name="a6c7c14574c041bcfd1ccb45137b486b4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6c7c14574c041bcfd1ccb45137b486b4">&#9670;&nbsp;</a></span>finalize_q_surplus_on_error()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void ipc::transport::Native_socket_stream_acceptor::finalize_q_surplus_on_error </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>In thread W, in steady state <em>except</em> for an <code>Error_code</code> just pushed to the back of <a class="el" href="classipc_1_1transport_1_1Native__socket__stream__acceptor.html#ac04049d9b4c38f2a46d7f26192b17b69" title="Queue storing surplus finalized async-accept results queued up due to lacking async_accept() requests...">m_pending_results_q</a> and thus introduced into the state machine, synchronously advances the state machine into steady state again, with the possible side effect of synchronously invoking <em>all</em> waiting async-accept user requests, if any. </p>
<p >In particular, <a class="el" href="classipc_1_1transport_1_1Native__socket__stream__acceptor.html#a5d2e731d023d9c6465e01fa84a6e5138" title="Queue storing deficit async-accept requests queued up due to lacking pending ready peer socket handle...">m_pending_user_requests_q</a> becomes empty if it was not, while <a class="el" href="classipc_1_1transport_1_1Native__socket__stream__acceptor.html#ac04049d9b4c38f2a46d7f26192b17b69" title="Queue storing surplus finalized async-accept results queued up due to lacking async_accept() requests...">m_pending_results_q</a> is not changed; in particular the just-pushed <code>Error_code</code> remains saved to be emitted to any future async-accept user requests.</p>
<p >It is essential to understand the pre-condition that the state machine must be in steady state, followed by exactly one modification to it: namely <code>Error_code</code> being pushed onto <a class="el" href="classipc_1_1transport_1_1Native__socket__stream__acceptor.html#ac04049d9b4c38f2a46d7f26192b17b69" title="Queue storing surplus finalized async-accept results queued up due to lacking async_accept() requests...">m_pending_results_q</a>. For example it is a bug for <a class="el" href="classipc_1_1transport_1_1Native__socket__stream__acceptor.html#a5d2e731d023d9c6465e01fa84a6e5138" title="Queue storing deficit async-accept requests queued up due to lacking pending ready peer socket handle...">m_pending_user_requests_q</a> to be non-empty, if the pre-push <a class="el" href="classipc_1_1transport_1_1Native__socket__stream__acceptor.html#ac04049d9b4c38f2a46d7f26192b17b69" title="Queue storing surplus finalized async-accept results queued up due to lacking async_accept() requests...">m_pending_results_q</a> is non-empty also; that isn't steady state since both a deficit and a surplus were in effect before the <code>Error_code</code> was pushed. In other words: this method takes an inductive step only; it doesn't "flush" the state machine. </p>

<p class="definition">Definition at line <a class="el" href="native__socket__stream__acceptor_8cpp_source.html#l00377">377</a> of file <a class="el" href="native__socket__stream__acceptor_8cpp_source.html">native_socket_stream_acceptor.cpp</a>.</p>

<p class="reference">References <a class="el" href="native__socket__stream__acceptor_8cpp_source.html#l00434">feed_error_result_to_deficit()</a>, <a class="el" href="native__socket__stream__acceptor_8hpp_source.html#l00355">m_pending_results_q</a>, and <a class="el" href="native__socket__stream__acceptor_8hpp_source.html#l00346">m_pending_user_requests_q</a>.</p>

<p class="reference">Referenced by <a class="el" href="native__socket__stream__acceptor_8cpp_source.html#l00181">on_next_peer_socket_or_error()</a>.</p>
<div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="classipc_1_1transport_1_1Native__socket__stream__acceptor_a6c7c14574c041bcfd1ccb45137b486b4_cgraph.svg" width="414" height="59"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe>
</div>
</div>
<div class="dynheader">
Here is the caller graph for this function:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="classipc_1_1transport_1_1Native__socket__stream__acceptor_a6c7c14574c041bcfd1ccb45137b486b4_icgraph.svg" width="678" height="83"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe>
</div>
</div>

</div>
</div>
<a id="ab9744191a6b5d7d05b7b2b96fcda84d6" name="ab9744191a6b5d7d05b7b2b96fcda84d6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab9744191a6b5d7d05b7b2b96fcda84d6">&#9670;&nbsp;</a></span>finalize_q_surplus_on_success()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void ipc::transport::Native_socket_stream_acceptor::finalize_q_surplus_on_success </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>In thread W, in steady state, introduces the just-established peer socket handle into the state machine and synchronously advances the state machine into steady state again, with the possible side effect of synchronously invoking the head waiting async-accept user request, if any. </p>
<p >The result, if not emitted, is enqueued to <a class="el" href="classipc_1_1transport_1_1Native__socket__stream__acceptor.html#ac04049d9b4c38f2a46d7f26192b17b69" title="Queue storing surplus finalized async-accept results queued up due to lacking async_accept() requests...">m_pending_results_q</a> for emission to the next request if any.</p>
<p >Pre-condition: Incoming-direction state machine is in steady state; we are in thread W; <a class="el" href="classipc_1_1transport_1_1Native__socket__stream__acceptor.html#a7928656e82682f101af9a2fd6d4019cc" title="Unix domain peer socket, always empty/unconnected while a background m_acceptor.async_accept() is pro...">m_next_peer_socket</a> is finalized and not empty. </p>

<p class="definition">Definition at line <a class="el" href="native__socket__stream__acceptor_8cpp_source.html#l00405">405</a> of file <a class="el" href="native__socket__stream__acceptor_8cpp_source.html">native_socket_stream_acceptor.cpp</a>.</p>

<p class="reference">References <a class="el" href="native__socket__stream__acceptor_8cpp_source.html#l00451">feed_success_result_to_deficit()</a>, <a class="el" href="native__socket__stream__acceptor_8hpp_source.html#l00355">m_pending_results_q</a>, and <a class="el" href="native__socket__stream__acceptor_8hpp_source.html#l00346">m_pending_user_requests_q</a>.</p>

<p class="reference">Referenced by <a class="el" href="native__socket__stream__acceptor_8cpp_source.html#l00181">on_next_peer_socket_or_error()</a>.</p>
<div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="classipc_1_1transport_1_1Native__socket__stream__acceptor_ab9744191a6b5d7d05b7b2b96fcda84d6_cgraph.svg" width="376" height="71"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe>
</div>
</div>
<div class="dynheader">
Here is the caller graph for this function:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="classipc_1_1transport_1_1Native__socket__stream__acceptor_ab9744191a6b5d7d05b7b2b96fcda84d6_icgraph.svg" width="659" height="90"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe>
</div>
</div>

</div>
</div>
<a id="af52346c8df9efc457efaec35bc6c0807" name="af52346c8df9efc457efaec35bc6c0807"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af52346c8df9efc457efaec35bc6c0807">&#9670;&nbsp;</a></span>on_next_peer_socket_or_error()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void ipc::transport::Native_socket_stream_acceptor::on_next_peer_socket_or_error </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespaceipc.html#aa3192e586cc45d3e7c22463bf2760f89">Error_code</a> &amp;&#160;</td>
          <td class="paramname"><em>sys_err_code</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Handler for incoming connection on <a class="el" href="classipc_1_1transport_1_1Native__socket__stream__acceptor.html#a946663a2ab4070babdc80091f5adfb28" title="Unix domain socket acceptor.">m_acceptor</a>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">sys_err_code</td><td>Result code from boost.asio. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="native__socket__stream__acceptor_8cpp_source.html#l00181">181</a> of file <a class="el" href="native__socket__stream__acceptor_8cpp_source.html">native_socket_stream_acceptor.cpp</a>.</p>

<p class="reference">References <a class="el" href="native__socket__stream__acceptor_8cpp_source.html#l00377">finalize_q_surplus_on_error()</a>, <a class="el" href="native__socket__stream__acceptor_8cpp_source.html#l00405">finalize_q_surplus_on_success()</a>, <a class="el" href="native__socket__stream__acceptor_8hpp_source.html#l00335">m_absolute_name</a>, <a class="el" href="native__socket__stream__acceptor_8hpp_source.html#l00369">m_acceptor</a>, <a class="el" href="native__socket__stream__acceptor_8hpp_source.html#l00388">m_next_peer_socket</a>, <a class="el" href="native__socket__stream__acceptor_8hpp_source.html#l00355">m_pending_results_q</a>, <a class="el" href="native__handle_8cpp_source.html#l00060">ipc::util::Native_handle::null()</a>, <a class="el" href="native__socket__stream__acceptor_8cpp_source.html#l00181">on_next_peer_socket_or_error()</a>, and <a class="el" href="shared__name_8cpp_source.html#l00140">ipc::util::Shared_name::str()</a>.</p>

<p class="reference">Referenced by <a class="el" href="native__socket__stream__acceptor_8cpp_source.html#l00037">Native_socket_stream_acceptor()</a>, and <a class="el" href="native__socket__stream__acceptor_8cpp_source.html#l00181">on_next_peer_socket_or_error()</a>.</p>
<div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="classipc_1_1transport_1_1Native__socket__stream__acceptor_af52346c8df9efc457efaec35bc6c0807_cgraph.svg" width="652" height="252"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe>
</div>
</div>
<div class="dynheader">
Here is the caller graph for this function:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="classipc_1_1transport_1_1Native__socket__stream__acceptor_af52346c8df9efc457efaec35bc6c0807_icgraph.svg" width="452" height="83"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe>
</div>
</div>

</div>
</div>
<h2 class="groupheader">Friends And Related Function Documentation</h2>
<a id="a03f0ad84b5d21920a58be5e95f12e69f" name="a03f0ad84b5d21920a58be5e95f12e69f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a03f0ad84b5d21920a58be5e95f12e69f">&#9670;&nbsp;</a></span>operator&lt;&lt;()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::ostream &amp; operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>os</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classipc_1_1transport_1_1Native__socket__stream__acceptor.html">Native_socket_stream_acceptor</a> &amp;&#160;</td>
          <td class="paramname"><em>val</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Prints string representation of the given <code><a class="el" href="classipc_1_1transport_1_1Native__socket__stream__acceptor.html" title="A server object that binds to a Shared_name and listens for incoming Native_socket_stream::*_connect(...">Native_socket_stream_acceptor</a></code> to the given <code>ostream</code>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">os</td><td>Stream to which to write. </td></tr>
    <tr><td class="paramname">val</td><td>Object to serialize. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>os</code>. </dd></dl>

<p class="definition">Definition at line <a class="el" href="native__socket__stream__acceptor_8cpp_source.html#l00469">469</a> of file <a class="el" href="native__socket__stream__acceptor_8cpp_source.html">native_socket_stream_acceptor.cpp</a>.</p>

<p class="reference">References <a class="el" href="native__socket__stream__acceptor_8cpp_source.html#l00464">absolute_name()</a>.</p>
<div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="classipc_1_1transport_1_1Native__socket__stream__acceptor_a03f0ad84b5d21920a58be5e95f12e69f_cgraph.svg" width="376" height="59"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe>
</div>
</div>

</div>
</div>
<h2 class="groupheader">Member Data Documentation</h2>
<a id="a35785c842d668ee13f556580d0045511" name="a35785c842d668ee13f556580d0045511"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a35785c842d668ee13f556580d0045511">&#9670;&nbsp;</a></span>m_absolute_name</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="namespaceipc_1_1transport.html#a33de1c256addb3964b839dc2dd407d24">Shared_name</a> ipc::transport::Native_socket_stream_acceptor::m_absolute_name</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>See <a class="el" href="classipc_1_1transport_1_1Native__socket__stream__acceptor.html#ac5b70ff8230fa49c99ccb6954db71c75" title="Returns the full name/address to which the constructor bound, or attempted to bind,...">absolute_name()</a>. </p>

<p class="definition">Definition at line <a class="el" href="native__socket__stream__acceptor_8hpp_source.html#l00335">335</a> of file <a class="el" href="native__socket__stream__acceptor_8hpp_source.html">native_socket_stream_acceptor.hpp</a>.</p>

<p class="reference">Referenced by <a class="el" href="native__socket__stream__acceptor_8cpp_source.html#l00464">absolute_name()</a>, <a class="el" href="native__socket__stream__acceptor_8cpp_source.html#l00037">Native_socket_stream_acceptor()</a>, and <a class="el" href="native__socket__stream__acceptor_8cpp_source.html#l00181">on_next_peer_socket_or_error()</a>.</p>

</div>
</div>
<a id="a946663a2ab4070babdc80091f5adfb28" name="a946663a2ab4070babdc80091f5adfb28"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a946663a2ab4070babdc80091f5adfb28">&#9670;&nbsp;</a></span>m_acceptor</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">boost::movelib::unique_ptr&lt;<a class="el" href="namespaceipc_1_1transport_1_1asio__local__stream__socket.html#a154986f10d30d850de86fc3924766e66">asio_local_stream_socket::Acceptor</a>&gt; ipc::transport::Native_socket_stream_acceptor::m_acceptor</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Unix domain socket acceptor. </p>
<p >It is only accessed in thread W. Assuming successful setup, it's listening continuously in thread W, via async loop <a class="el" href="classipc_1_1transport_1_1Native__socket__stream__acceptor.html#a2d397e09f2cfa198313ff5c31334080b" title="A single-threaded async task loop that starts in constructor and ends in destructor.">m_worker</a>. </p>

<p class="definition">Definition at line <a class="el" href="native__socket__stream__acceptor_8hpp_source.html#l00369">369</a> of file <a class="el" href="native__socket__stream__acceptor_8hpp_source.html">native_socket_stream_acceptor.hpp</a>.</p>

<p class="reference">Referenced by <a class="el" href="native__socket__stream__acceptor_8cpp_source.html#l00037">Native_socket_stream_acceptor()</a>, and <a class="el" href="native__socket__stream__acceptor_8cpp_source.html#l00181">on_next_peer_socket_or_error()</a>.</p>

</div>
</div>
<a id="a7928656e82682f101af9a2fd6d4019cc" name="a7928656e82682f101af9a2fd6d4019cc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7928656e82682f101af9a2fd6d4019cc">&#9670;&nbsp;</a></span>m_next_peer_socket</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespaceipc_1_1transport_1_1asio__local__stream__socket.html#a1788f9dbd896bb71b3693f9ae25b40ae">asio_local_stream_socket::Peer_socket</a> ipc::transport::Native_socket_stream_acceptor::m_next_peer_socket</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Unix domain peer socket, always empty/unconnected while a background <code>m_acceptor.async_accept()</code> is proceeding; then (assuming a successful accept op) connected at the start to the <code><a class="el" href="classipc_1_1transport_1_1Native__socket__stream__acceptor.html#a81426af495ba5a9c832d1ba35fe23ba5" title="Asynchronously awaits for a peer connection to be established and calls on_done_func(),...">async_accept()</a></code> callback; then back to empty/unconnected again just before the next <code><a class="el" href="classipc_1_1transport_1_1Native__socket__stream__acceptor.html#a81426af495ba5a9c832d1ba35fe23ba5" title="Asynchronously awaits for a peer connection to be established and calls on_done_func(),...">async_accept()</a></code> call; and so on. </p>
<p >Only accessed in thread W.</p>
<p >Since there's only one thread, we can keep reusing this one target socket. When the time comes (in the callback) to pass it to the rest of the program, a "new" socket is move-constructed from it, thus making it empty/unconnected again.</p>
<h3>Rationale/notes</h3>
<p >As noted, this setup relies on move-construction. Alternatively we could have used a <code>shared_ptr</code> pattern. Stylistically it should be at least as simple/elegant. Perf-wise, as of this writing, I (ygoldfel) have not rigorously compared the two; but by definition move constructions should be close to optimal perf-wise, unless boost.asio guys willfully made theirs slow.</p>
<dl class="todo"><dt><b><a class="el" href="todo.html#_todo000010">Todo:</a></b></dt><dd>Perform a rigorous analysis of the perf and style trade-offs between move-construction-based patterns versus <code>shared_ptr</code>-based ones, possibly focusing on boost.asio socket objects in particular. </dd></dl>

<p class="definition">Definition at line <a class="el" href="native__socket__stream__acceptor_8hpp_source.html#l00388">388</a> of file <a class="el" href="native__socket__stream__acceptor_8hpp_source.html">native_socket_stream_acceptor.hpp</a>.</p>

<p class="reference">Referenced by <a class="el" href="native__socket__stream__acceptor_8cpp_source.html#l00037">Native_socket_stream_acceptor()</a>, and <a class="el" href="native__socket__stream__acceptor_8cpp_source.html#l00181">on_next_peer_socket_or_error()</a>.</p>

</div>
</div>
<a id="ac04049d9b4c38f2a46d7f26192b17b69" name="ac04049d9b4c38f2a46d7f26192b17b69"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac04049d9b4c38f2a46d7f26192b17b69">&#9670;&nbsp;</a></span>m_pending_results_q</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::queue&lt;std::variant&lt;<a class="el" href="classipc_1_1transport_1_1Native__socket__stream__acceptor.html#a476652737140b761264000ffa4204e4a">Peer_ptr</a>, <a class="el" href="namespaceipc.html#aa3192e586cc45d3e7c22463bf2760f89">Error_code</a>&gt; &gt; ipc::transport::Native_socket_stream_acceptor::m_pending_results_q</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Queue storing surplus finalized async-accept results queued up due to lacking <a class="el" href="classipc_1_1transport_1_1Native__socket__stream__acceptor.html#a81426af495ba5a9c832d1ba35fe23ba5" title="Asynchronously awaits for a peer connection to be established and calls on_done_func(),...">async_accept()</a> requests in <a class="el" href="classipc_1_1transport_1_1Native__socket__stream__acceptor.html#a5d2e731d023d9c6465e01fa84a6e5138" title="Queue storing deficit async-accept requests queued up due to lacking pending ready peer socket handle...">m_pending_user_requests_q</a> at connection finalization time. </p>
<p >There are 0+ peer socket handles, capped by 0 or 1 <code>Error_code</code>.</p>
<p >Accessed from thread W only; hence needs no locking. </p>

<p class="definition">Definition at line <a class="el" href="native__socket__stream__acceptor_8hpp_source.html#l00355">355</a> of file <a class="el" href="native__socket__stream__acceptor_8hpp_source.html">native_socket_stream_acceptor.hpp</a>.</p>

<p class="reference">Referenced by <a class="el" href="native__socket__stream__acceptor_8cpp_source.html#l00309">async_accept_impl()</a>, <a class="el" href="native__socket__stream__acceptor_8cpp_source.html#l00377">finalize_q_surplus_on_error()</a>, <a class="el" href="native__socket__stream__acceptor_8cpp_source.html#l00405">finalize_q_surplus_on_success()</a>, and <a class="el" href="native__socket__stream__acceptor_8cpp_source.html#l00181">on_next_peer_socket_or_error()</a>.</p>

</div>
</div>
<a id="a5d2e731d023d9c6465e01fa84a6e5138" name="a5d2e731d023d9c6465e01fa84a6e5138"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5d2e731d023d9c6465e01fa84a6e5138">&#9670;&nbsp;</a></span>m_pending_user_requests_q</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::queue&lt;<a class="el" href="structipc_1_1transport_1_1Native__socket__stream__acceptor_1_1User__request.html#a79784f3221898aee3ab977186565b5d2">User_request::Ptr</a>&gt; ipc::transport::Native_socket_stream_acceptor::m_pending_user_requests_q</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Queue storing deficit async-accept requests queued up due to lacking pending ready peer socket handles in <a class="el" href="classipc_1_1transport_1_1Native__socket__stream__acceptor.html#ac04049d9b4c38f2a46d7f26192b17b69" title="Queue storing surplus finalized async-accept results queued up due to lacking async_accept() requests...">m_pending_results_q</a> at <a class="el" href="classipc_1_1transport_1_1Native__socket__stream__acceptor.html#a81426af495ba5a9c832d1ba35fe23ba5" title="Asynchronously awaits for a peer connection to be established and calls on_done_func(),...">async_accept()</a> time. </p>
<p >In steady state the invariant is: either <a class="el" href="classipc_1_1transport_1_1Native__socket__stream__acceptor.html#a5d2e731d023d9c6465e01fa84a6e5138" title="Queue storing deficit async-accept requests queued up due to lacking pending ready peer socket handle...">m_pending_user_requests_q</a> is empty, or <a class="el" href="classipc_1_1transport_1_1Native__socket__stream__acceptor.html#ac04049d9b4c38f2a46d7f26192b17b69" title="Queue storing surplus finalized async-accept results queued up due to lacking async_accept() requests...">m_pending_results_q</a> is empty, or both are empty. If in non-steady state each has at least one handle, then any handles in <a class="el" href="classipc_1_1transport_1_1Native__socket__stream__acceptor.html#ac04049d9b4c38f2a46d7f26192b17b69" title="Queue storing surplus finalized async-accept results queued up due to lacking async_accept() requests...">m_pending_results_q</a> are "fed" to the callbacks in <a class="el" href="classipc_1_1transport_1_1Native__socket__stream__acceptor.html#a5d2e731d023d9c6465e01fa84a6e5138" title="Queue storing deficit async-accept requests queued up due to lacking pending ready peer socket handle...">m_pending_user_requests_q</a>, thus removing that number of entries in each queue and emptying <a class="el" href="classipc_1_1transport_1_1Native__socket__stream__acceptor.html#ac04049d9b4c38f2a46d7f26192b17b69" title="Queue storing surplus finalized async-accept results queued up due to lacking async_accept() requests...">m_pending_results_q</a>.</p>
<p >Accessed from thread W only; hence needs no locking. </p>

<p class="definition">Definition at line <a class="el" href="native__socket__stream__acceptor_8hpp_source.html#l00346">346</a> of file <a class="el" href="native__socket__stream__acceptor_8hpp_source.html">native_socket_stream_acceptor.hpp</a>.</p>

<p class="reference">Referenced by <a class="el" href="native__socket__stream__acceptor_8cpp_source.html#l00309">async_accept_impl()</a>, <a class="el" href="native__socket__stream__acceptor_8cpp_source.html#l00434">feed_error_result_to_deficit()</a>, <a class="el" href="native__socket__stream__acceptor_8cpp_source.html#l00451">feed_success_result_to_deficit()</a>, <a class="el" href="native__socket__stream__acceptor_8cpp_source.html#l00377">finalize_q_surplus_on_error()</a>, <a class="el" href="native__socket__stream__acceptor_8cpp_source.html#l00405">finalize_q_surplus_on_success()</a>, and <a class="el" href="native__socket__stream__acceptor_8cpp_source.html#l00131">~Native_socket_stream_acceptor()</a>.</p>

</div>
</div>
<a id="a2d397e09f2cfa198313ff5c31334080b" name="a2d397e09f2cfa198313ff5c31334080b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2d397e09f2cfa198313ff5c31334080b">&#9670;&nbsp;</a></span>m_worker</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">flow::async::Single_thread_task_loop ipc::transport::Native_socket_stream_acceptor::m_worker</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>A single-threaded async task loop that starts in constructor and ends in destructor. </p>
<p >We refer to this informally as thread W in comments.</p>
<p >Ordering: Should be declared before <a class="el" href="classipc_1_1transport_1_1Native__socket__stream__acceptor.html#a946663a2ab4070babdc80091f5adfb28" title="Unix domain socket acceptor.">m_acceptor</a>: It should destruct before its attached <code>Task_engine</code> does. </p>

<p class="definition">Definition at line <a class="el" href="native__socket__stream__acceptor_8hpp_source.html#l00363">363</a> of file <a class="el" href="native__socket__stream__acceptor_8hpp_source.html">native_socket_stream_acceptor.hpp</a>.</p>

<p class="reference">Referenced by <a class="el" href="native__socket__stream__acceptor_8cpp_source.html#l00309">async_accept_impl()</a>, <a class="el" href="native__socket__stream__acceptor_8cpp_source.html#l00037">Native_socket_stream_acceptor()</a>, and <a class="el" href="native__socket__stream__acceptor_8cpp_source.html#l00131">~Native_socket_stream_acceptor()</a>.</p>

</div>
</div>
<a id="a0de2b6072026584ff1d46538533ed68b" name="a0de2b6072026584ff1d46538533ed68b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0de2b6072026584ff1d46538533ed68b">&#9670;&nbsp;</a></span>S_RESOURCE_TYPE_ID</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="namespaceipc_1_1transport.html#a33de1c256addb3964b839dc2dd407d24">Shared_name</a> &amp; ipc::transport::Native_socket_stream_acceptor::S_RESOURCE_TYPE_ID = Sync_io_obj::S_RESOURCE_TYPE_ID</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Shared_name relative-folder fragment (no separators) identifying this resource type. </p>

<p class="definition">Definition at line <a class="el" href="native__socket__stream__acceptor_8hpp_source.html#l00120">120</a> of file <a class="el" href="native__socket__stream__acceptor_8hpp_source.html">native_socket_stream_acceptor.hpp</a>.</p>

<p class="reference">Referenced by <a class="el" href="session__base_8hpp_source.html#l00713">ipc::session::Session_base&lt; S_MQ_TYPE_OR_NONE, S_TRANSMIT_NATIVE_HANDLES, Mdt_payload &gt;::session_master_socket_stream_acceptor_absolute_name()</a>.</p>

</div>
</div>
<hr/>The documentation for this class was generated from the following files:<ul>
<li>transport/<a class="el" href="native__socket__stream__acceptor_8hpp_source.html">native_socket_stream_acceptor.hpp</a></li>
<li>transport/<a class="el" href="native__socket__stream__acceptor_8cpp_source.html">native_socket_stream_acceptor.cpp</a></li>
<li>transport/<a class="el" href="transport__fwd_8hpp_source.html">transport_fwd.hpp</a></li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Thu Feb 15 2024 03:43:08 for Flow-IPC by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.4
</small></address>
</body>
</html>
