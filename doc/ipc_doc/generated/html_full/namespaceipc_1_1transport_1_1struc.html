<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.9.4"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Flow-IPC: ipc::transport::struc Namespace Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">Flow-IPC<span id="projectnumber">&#160;1.0.0</span>
   </div>
   <div id="projectbrief">Flow-IPC project: Full implementation reference.</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.4 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search",'Search','.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespaceipc.html">ipc</a></li><li class="navelem"><a class="el" href="namespaceipc_1_1transport.html">transport</a></li><li class="navelem"><a class="el" href="namespaceipc_1_1transport_1_1struc.html">struc</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#namespaces">Namespaces</a> &#124;
<a href="#nested-classes">Classes</a> &#124;
<a href="#typedef-members">Typedefs</a> &#124;
<a href="#func-members">Functions</a> &#124;
<a href="#var-members">Variables</a>  </div>
  <div class="headertitle"><div class="title">ipc::transport::struc Namespace Reference</div></div>
</div><!--header-->
<div class="contents">

<p>Sub-module of Flow-IPC module <a class="el" href="namespaceipc_1_1transport.html" title="Flow-IPC module providing transmission of structured messages and/or low-level blobs (and more) betwe...">ipc::transport</a> providing transmission of structured messages specifically.  
<a href="namespaceipc_1_1transport_1_1struc.html#details">More...</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="namespaces" name="namespaces"></a>
Namespaces</h2></td></tr>
<tr class="memitem:namespaceipc_1_1transport_1_1struc_1_1error"><td class="memItemLeft" align="right" valign="top">namespace &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceipc_1_1transport_1_1struc_1_1error.html">error</a></td></tr>
<tr class="memdesc:namespaceipc_1_1transport_1_1struc_1_1error"><td class="mdescLeft">&#160;</td><td class="mdescRight">Analogous to <a class="el" href="namespaceipc_1_1transport_1_1error.html" title="Namespace containing the ipc::transport module&#39;s extension of boost.system error conventions,...">ipc::transport::error</a> but applies to the sub-namespace <a class="el" href="namespaceipc_1_1transport_1_1struc.html" title="Sub-module of Flow-IPC module ipc::transport providing transmission of structured messages specifical...">ipc::transport::struc</a> &ndash; errors having to do with structured messaging. <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespaceipc_1_1transport_1_1struc_1_1shm"><td class="memItemLeft" align="right" valign="top">namespace &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceipc_1_1transport_1_1struc_1_1shm.html">shm</a></td></tr>
<tr class="memdesc:namespaceipc_1_1transport_1_1struc_1_1shm"><td class="mdescLeft">&#160;</td><td class="mdescRight">Segregates zero-copy/SHM implementations of concepts residing in parent namespace <a class="el" href="namespaceipc_1_1transport_1_1struc.html" title="Sub-module of Flow-IPC module ipc::transport providing transmission of structured messages specifical...">ipc::transport::struc</a> proper &ndash; most notably the concepts <a class="el" href="classipc_1_1transport_1_1struc_1_1Struct__builder.html" title="A documentation-only concept defining the behavior of an object capable of zero-copy-serializing,...">ipc::transport::struc::Struct_builder</a> and <a class="el" href="classipc_1_1transport_1_1struc_1_1Struct__reader.html" title="A documentation-only concept that is, conceptually, roughly what capnp::MessageReader is to capnp::Me...">ipc::transport::struc::Struct_reader</a> &ndash; and items related to them. <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespaceipc_1_1transport_1_1struc_1_1sync__io"><td class="memItemLeft" align="right" valign="top">namespace &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceipc_1_1transport_1_1struc_1_1sync__io.html">sync_io</a></td></tr>
<tr class="memdesc:namespaceipc_1_1transport_1_1struc_1_1sync__io"><td class="mdescLeft">&#160;</td><td class="mdescRight"><code><a class="el" href="namespaceipc_1_1transport_1_1struc_1_1sync__io.html" title="sync_io-pattern counterparts to async-I/O-pattern object types in parent namespace ipc::transport::st...">sync_io</a></code>-pattern counterparts to async-I/O-pattern object types in parent namespace <a class="el" href="namespaceipc_1_1transport_1_1struc.html" title="Sub-module of Flow-IPC module ipc::transport providing transmission of structured messages specifical...">ipc::transport::struc</a>. <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="nested-classes" name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classipc_1_1transport_1_1struc_1_1Channel.html">Channel</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Owning and wrapping a pre-connected <a class="el" href="classipc_1_1transport_1_1Channel.html" title="Peer to a bundle of 1-2 full-duplex pipe(s), one for transmitting unstructured binary blobs; the othe...">transport::Channel</a> peer (an endpoint of an established channel over which <em>unstructured</em> messages and optionally native handles can be transported), this template is the central pillar of the <a class="el" href="namespaceipc_1_1transport_1_1struc.html" title="Sub-module of Flow-IPC module ipc::transport providing transmission of structured messages specifical...">ipc::transport::struc</a> (<em>structured layer</em>), capable of communicating structured capnp-schema-based messages (and native handles).  <a href="classipc_1_1transport_1_1struc_1_1Channel.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classipc_1_1transport_1_1struc_1_1Channel__base.html">Channel_base</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><code><a class="el" href="classipc_1_1transport_1_1struc_1_1Channel.html" title="Owning and wrapping a pre-connected transport::Channel peer (an endpoint of an established channel ov...">Channel</a></code> base that contains non-parameterized <code>public</code> items such as tag types and constants.  <a href="classipc_1_1transport_1_1struc_1_1Channel__base.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classipc_1_1transport_1_1struc_1_1Heap__fixed__builder.html">Heap_fixed_builder</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Implements <a class="el" href="classipc_1_1transport_1_1struc_1_1Struct__builder.html" title="A documentation-only concept defining the behavior of an object capable of zero-copy-serializing,...">Struct_builder</a> concept by straightforwardly allocating fixed-size segments on-demand in the regular heap and serializing directly inside those segments.  <a href="classipc_1_1transport_1_1struc_1_1Heap__fixed__builder.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classipc_1_1transport_1_1struc_1_1Heap__fixed__builder__capnp__message__builder.html">Heap_fixed_builder_capnp_message_builder</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A <code>capnp::MessageBuilder</code> used by <a class="el" href="classipc_1_1transport_1_1struc_1_1Heap__fixed__builder.html" title="Implements Struct_builder concept by straightforwardly allocating fixed-size segments on-demand in th...">Heap_fixed_builder</a>: similar to a <code>capnp::MallocMessageBuilder</code> with the FIXED_SIZE alloc-strategy but with framing space around the allocated segment(s).  <a href="classipc_1_1transport_1_1struc_1_1Heap__fixed__builder__capnp__message__builder.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classipc_1_1transport_1_1struc_1_1Heap__reader.html">Heap_reader</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Implements <a class="el" href="classipc_1_1transport_1_1struc_1_1Struct__reader.html" title="A documentation-only concept that is, conceptually, roughly what capnp::MessageReader is to capnp::Me...">Struct_reader</a> concept by straightforwardly interpreting a serialization by <a class="el" href="classipc_1_1transport_1_1struc_1_1Heap__fixed__builder.html" title="Implements Struct_builder concept by straightforwardly allocating fixed-size segments on-demand in th...">Heap_fixed_builder</a> or any other builder that produces segments directly readable via <code>SegmentArrayMessageReader</code>.  <a href="classipc_1_1transport_1_1struc_1_1Heap__reader.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classipc_1_1transport_1_1struc_1_1Msg__in.html">Msg_in</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A structured in-message <em>instance</em> suitable as received and emittable (to user) by <a class="el" href="classipc_1_1transport_1_1struc_1_1Channel.html" title="Owning and wrapping a pre-connected transport::Channel peer (an endpoint of an established channel ov...">struc::Channel</a>.  <a href="classipc_1_1transport_1_1struc_1_1Msg__in.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classipc_1_1transport_1_1struc_1_1Msg__in__impl.html">Msg_in_impl</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Internally used (data-free) addendum on-top of <a class="el" href="classipc_1_1transport_1_1struc_1_1Msg__in.html" title="A structured in-message instance suitable as received and emittable (to user) by struc::Channel.">Msg_in</a> which makes the <code>protected</code> API public instead.  <a href="classipc_1_1transport_1_1struc_1_1Msg__in__impl.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classipc_1_1transport_1_1struc_1_1Msg__mdt__out.html">Msg_mdt_out</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Internally used (data-free) addendum on-top of <a class="el" href="classipc_1_1transport_1_1struc_1_1Msg__out.html" title="A structured out-message suitable to be sent via struc::Channel::send().">Msg_out</a>; really an alias to <code><a class="el" href="classipc_1_1transport_1_1struc_1_1Msg__out.html" title="A structured out-message suitable to be sent via struc::Channel::send().">Msg_out</a>&lt;schema::detail::StructuredMessage&gt;</code>, where the latter is the internal-use set of metadata schema, with a convenience public mutating API wrapping around capnp-generated mutator API for things like message ID.  <a href="classipc_1_1transport_1_1struc_1_1Msg__mdt__out.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classipc_1_1transport_1_1struc_1_1Msg__out.html">Msg_out</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A structured out-message suitable to be sent via <a class="el" href="classipc_1_1transport_1_1struc_1_1Channel.html#ae645cb58ad9ea6374970f1f32c5da448" title="In the synchronous/non-blocking manner of Blob_sender::send_blob() or Native_handle_sender::send_nati...">struc::Channel::send()</a>.  <a href="classipc_1_1transport_1_1struc_1_1Msg__out.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classipc_1_1transport_1_1struc_1_1Msg__out__impl.html">Msg_out_impl</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Internally used (data-free) addendum on-top of <a class="el" href="classipc_1_1transport_1_1struc_1_1Msg__out.html" title="A structured out-message suitable to be sent via struc::Channel::send().">Msg_out</a> which makes the <code>protected</code> API public instead.  <a href="classipc_1_1transport_1_1struc_1_1Msg__out__impl.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structipc_1_1transport_1_1struc_1_1Null__session.html">Null_session</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Value for <a class="el" href="classipc_1_1transport_1_1struc_1_1Struct__builder.html#ab90424897efed06ffc6b0884761fb31f" title="Type objects of which specify to emit_serialization() the opposing recipient for which the serializat...">Struct_builder::Session</a> when no extra information is needed when serializing <a class="el" href="classipc_1_1transport_1_1struc_1_1Struct__builder.html" title="A documentation-only concept defining the behavior of an object capable of zero-copy-serializing,...">Struct_builder</a> for subsequent sending to another process.  <a href="structipc_1_1transport_1_1struc_1_1Null__session.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classipc_1_1transport_1_1struc_1_1Struct__builder.html">Struct_builder</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A documentation-only <em>concept</em> defining the behavior of an object capable of zero-copy-serializing, similar to <code>capnp::MessageBuilder</code> but geared to transmission over pipe-like IPC transports.  <a href="classipc_1_1transport_1_1struc_1_1Struct__builder.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classipc_1_1transport_1_1struc_1_1Struct__reader.html">Struct_reader</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A documentation-only <em>concept</em> that is, conceptually, roughly what <code>capnp::MessageReader</code> is to <code>capnp::MessageBuilder</code>, to be used on an in-message serialized by a counterpart <a class="el" href="classipc_1_1transport_1_1struc_1_1Struct__builder.html" title="A documentation-only concept defining the behavior of an object capable of zero-copy-serializing,...">Struct_builder</a>, having been transmitted over an IPC transmitter of blobs.  <a href="classipc_1_1transport_1_1struc_1_1Struct__reader.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="typedef-members" name="typedef-members"></a>
Typedefs</h2></td></tr>
<tr class="memitem:aca041b0efd4a9ae18e10088b2ee3c052"><td class="memTemplParams" colspan="2">template&lt;typename Channel_obj , typename Message_body &gt; </td></tr>
<tr class="memitem:aca041b0efd4a9ae18e10088b2ee3c052"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceipc_1_1transport_1_1struc.html#aca041b0efd4a9ae18e10088b2ee3c052">Channel_via_heap</a> = <a class="el" href="classipc_1_1transport_1_1struc_1_1Channel.html">Channel</a>&lt; Channel_obj, Message_body, <a class="el" href="structipc_1_1transport_1_1struc_1_1Heap__fixed__builder_1_1Config.html">Heap_fixed_builder::Config</a>, <a class="el" href="structipc_1_1transport_1_1struc_1_1Heap__reader_1_1Config.html">Heap_reader::Config</a> &gt;</td></tr>
<tr class="memdesc:aca041b0efd4a9ae18e10088b2ee3c052"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convenience alias: Use this when constructing a <a class="el" href="classipc_1_1transport_1_1struc_1_1Channel.html" title="Owning and wrapping a pre-connected transport::Channel peer (an endpoint of an established channel ov...">struc::Channel</a> with tag <a class="el" href="classipc_1_1transport_1_1struc_1_1Channel__base.html#ab0eb05b5fb52364c99868a8535aaf26e" title="The sole value of the tag type Serialize_via_heap.">Channel_base::S_SERIALIZE_VIA_HEAP</a>.  <a href="namespaceipc_1_1transport_1_1struc.html#aca041b0efd4a9ae18e10088b2ee3c052">More...</a><br /></td></tr>
<tr class="separator:aca041b0efd4a9ae18e10088b2ee3c052"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a52405569bf63eaef55f3c2435c885abc"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceipc_1_1transport_1_1struc.html#a52405569bf63eaef55f3c2435c885abc">Capnp_msg_builder_interface</a> = ::capnp::MessageBuilder</td></tr>
<tr class="memdesc:a52405569bf63eaef55f3c2435c885abc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Alias for capnp's MessageBuilder interface. Rationale: as part of our API, we use our identifier style.  <a href="namespaceipc_1_1transport_1_1struc.html#a52405569bf63eaef55f3c2435c885abc">More...</a><br /></td></tr>
<tr class="separator:a52405569bf63eaef55f3c2435c885abc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6751c05fb6582a34c7c47ac470c4a48b"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceipc_1_1transport_1_1struc.html#a6751c05fb6582a34c7c47ac470c4a48b">Session_token</a> = boost::uuids::uuid</td></tr>
<tr class="memdesc:a6751c05fb6582a34c7c47ac470c4a48b"><td class="mdescLeft">&#160;</td><td class="mdescRight">A type used by <a class="el" href="classipc_1_1transport_1_1struc_1_1Channel.html" title="Owning and wrapping a pre-connected transport::Channel peer (an endpoint of an established channel ov...">struc::Channel</a> for internal safety/security/auth needs.  <a href="namespaceipc_1_1transport_1_1struc.html#a6751c05fb6582a34c7c47ac470c4a48b">More...</a><br /></td></tr>
<tr class="separator:a6751c05fb6582a34c7c47ac470c4a48b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a82a69eaa39cbe8a002de1266f1cbb5cb"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceipc_1_1transport_1_1struc.html#a82a69eaa39cbe8a002de1266f1cbb5cb">Segment_ptrs</a> = std::vector&lt; flow::util::Blob * &gt;</td></tr>
<tr class="memdesc:a82a69eaa39cbe8a002de1266f1cbb5cb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sequence of 1+ <code>Blob</code> <em>pointers</em> to blobs which must stay alive while these pointers may be dereferenced, intended here to refer to a capnp serialization of a capnp-<code>struct</code>.  <a href="namespaceipc_1_1transport_1_1struc.html#a82a69eaa39cbe8a002de1266f1cbb5cb">More...</a><br /></td></tr>
<tr class="separator:a82a69eaa39cbe8a002de1266f1cbb5cb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af7f35fc7588d97a838274fa25700ead9"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceipc_1_1transport_1_1struc.html#af7f35fc7588d97a838274fa25700ead9">msg_id_t</a> = uint64_t</td></tr>
<tr class="memdesc:af7f35fc7588d97a838274fa25700ead9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Message ID uniquely identifying outgoing message (<a class="el" href="classipc_1_1transport_1_1struc_1_1Msg__out.html" title="A structured out-message suitable to be sent via struc::Channel::send().">Msg_out</a>, among all other <code><a class="el" href="classipc_1_1transport_1_1struc_1_1Msg__out.html" title="A structured out-message suitable to be sent via struc::Channel::send().">Msg_out</a></code>s), per channel; and similarly incoming message (<a class="el" href="classipc_1_1transport_1_1struc_1_1Msg__in.html" title="A structured in-message instance suitable as received and emittable (to user) by struc::Channel.">Msg_in</a>, among <code><a class="el" href="classipc_1_1transport_1_1struc_1_1Msg__in.html" title="A structured in-message instance suitable as received and emittable (to user) by struc::Channel.">Msg_in</a></code>s), per channel.  <a href="namespaceipc_1_1transport_1_1struc.html#af7f35fc7588d97a838274fa25700ead9">More...</a><br /></td></tr>
<tr class="separator:af7f35fc7588d97a838274fa25700ead9"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="func-members" name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:ae272f248d74db0486c4d9411715db15d"><td class="memItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceipc_1_1transport_1_1struc.html#ae272f248d74db0486c4d9411715db15d">operator&lt;&lt;</a> (std::ostream &amp;os, const <a class="el" href="classipc_1_1transport_1_1struc_1_1Heap__fixed__builder.html">Heap_fixed_builder</a> &amp;val)</td></tr>
<tr class="memdesc:ae272f248d74db0486c4d9411715db15d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Prints string representation of the given <code><a class="el" href="classipc_1_1transport_1_1struc_1_1Heap__fixed__builder.html" title="Implements Struct_builder concept by straightforwardly allocating fixed-size segments on-demand in th...">Heap_fixed_builder</a></code> to the given <code>ostream</code>.  <a href="namespaceipc_1_1transport_1_1struc.html#ae272f248d74db0486c4d9411715db15d">More...</a><br /></td></tr>
<tr class="separator:ae272f248d74db0486c4d9411715db15d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8b1483d548bd56b3bf1e73bc46419e7a"><td class="memItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceipc_1_1transport_1_1struc.html#a8b1483d548bd56b3bf1e73bc46419e7a">operator&lt;&lt;</a> (std::ostream &amp;os, const <a class="el" href="classipc_1_1transport_1_1struc_1_1Heap__reader.html">Heap_reader</a> &amp;val)</td></tr>
<tr class="memdesc:a8b1483d548bd56b3bf1e73bc46419e7a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Prints string representation of the given <code><a class="el" href="classipc_1_1transport_1_1struc_1_1Heap__reader.html" title="Implements Struct_reader concept by straightforwardly interpreting a serialization by Heap_fixed_buil...">Heap_reader</a></code> to the given <code>ostream</code>.  <a href="namespaceipc_1_1transport_1_1struc.html#a8b1483d548bd56b3bf1e73bc46419e7a">More...</a><br /></td></tr>
<tr class="separator:a8b1483d548bd56b3bf1e73bc46419e7a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a134e737e55ae825527efd6a9e68bf37e"><td class="memTemplParams" colspan="2">template&lt;typename Message_body , typename Struct_builder_t &gt; </td></tr>
<tr class="memitem:a134e737e55ae825527efd6a9e68bf37e"><td class="memTemplItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceipc_1_1transport_1_1struc.html#a134e737e55ae825527efd6a9e68bf37e">operator&lt;&lt;</a> (std::ostream &amp;os, const <a class="el" href="classipc_1_1transport_1_1struc_1_1Msg__out.html">Msg_out</a>&lt; Message_body, Struct_builder_t &gt; &amp;val)</td></tr>
<tr class="memdesc:a134e737e55ae825527efd6a9e68bf37e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Prints string representation of the given <code><a class="el" href="classipc_1_1transport_1_1struc_1_1Msg__out.html" title="A structured out-message suitable to be sent via struc::Channel::send().">Msg_out</a></code> to the given <code>ostream</code>.  <a href="namespaceipc_1_1transport_1_1struc.html#a134e737e55ae825527efd6a9e68bf37e">More...</a><br /></td></tr>
<tr class="separator:a134e737e55ae825527efd6a9e68bf37e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aad52996a4d66f74e21e4f2e74c93c763"><td class="memTemplParams" colspan="2">template&lt;typename Message_body , typename Struct_reader_config &gt; </td></tr>
<tr class="memitem:aad52996a4d66f74e21e4f2e74c93c763"><td class="memTemplItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceipc_1_1transport_1_1struc.html#aad52996a4d66f74e21e4f2e74c93c763">operator&lt;&lt;</a> (std::ostream &amp;os, const <a class="el" href="classipc_1_1transport_1_1struc_1_1Msg__in.html">Msg_in</a>&lt; Message_body, Struct_reader_config &gt; &amp;val)</td></tr>
<tr class="memdesc:aad52996a4d66f74e21e4f2e74c93c763"><td class="mdescLeft">&#160;</td><td class="mdescRight">Prints string representation of the given <code><a class="el" href="classipc_1_1transport_1_1struc_1_1Msg__in.html" title="A structured in-message instance suitable as received and emittable (to user) by struc::Channel.">Msg_in</a></code> to the given <code>ostream</code>.  <a href="namespaceipc_1_1transport_1_1struc.html#aad52996a4d66f74e21e4f2e74c93c763">More...</a><br /></td></tr>
<tr class="separator:aad52996a4d66f74e21e4f2e74c93c763"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0351bb14f40312b30e6cae4927f3373b"><td class="memTemplParams" colspan="2">template&lt;typename Channel_obj , typename Message_body , typename Struct_builder_config , typename Struct_reader_config &gt; </td></tr>
<tr class="memitem:a0351bb14f40312b30e6cae4927f3373b"><td class="memTemplItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceipc_1_1transport_1_1struc.html#a0351bb14f40312b30e6cae4927f3373b">operator&lt;&lt;</a> (std::ostream &amp;os, const <a class="el" href="classipc_1_1transport_1_1struc_1_1Channel.html">Channel</a>&lt; Channel_obj, Message_body, Struct_builder_config, Struct_reader_config &gt; &amp;val)</td></tr>
<tr class="memdesc:a0351bb14f40312b30e6cae4927f3373b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Prints string representation of the given <a class="el" href="classipc_1_1transport_1_1struc_1_1Channel.html" title="Owning and wrapping a pre-connected transport::Channel peer (an endpoint of an established channel ov...">struc::Channel</a> to the given <code>ostream</code>.  <a href="namespaceipc_1_1transport_1_1struc.html#a0351bb14f40312b30e6cae4927f3373b">More...</a><br /></td></tr>
<tr class="separator:a0351bb14f40312b30e6cae4927f3373b"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="var-members" name="var-members"></a>
Variables</h2></td></tr>
<tr class="memitem:ad556d20a2aa2d52b83c7afb73951d47d"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="namespaceipc_1_1transport_1_1struc.html#a6751c05fb6582a34c7c47ac470c4a48b">Session_token</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceipc_1_1transport_1_1struc.html#ad556d20a2aa2d52b83c7afb73951d47d">NULL_SESSION_TOKEN</a> = boost::uuids::nil_uuid()</td></tr>
<tr class="memdesc:ad556d20a2aa2d52b83c7afb73951d47d"><td class="mdescLeft">&#160;</td><td class="mdescRight">A value for which <code>.is_nil()</code> is true.  <a href="namespaceipc_1_1transport_1_1struc.html#ad556d20a2aa2d52b83c7afb73951d47d">More...</a><br /></td></tr>
<tr class="separator:ad556d20a2aa2d52b83c7afb73951d47d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac70446757444f864afa21a5062bc5b0d"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="structipc_1_1transport_1_1struc_1_1Null__session.html">Null_session</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceipc_1_1transport_1_1struc.html#ac70446757444f864afa21a5062bc5b0d">NULL_SESSION</a></td></tr>
<tr class="memdesc:ac70446757444f864afa21a5062bc5b0d"><td class="mdescLeft">&#160;</td><td class="mdescRight">The only necessary value of empty-type <a class="el" href="structipc_1_1transport_1_1struc_1_1Null__session.html" title="Value for Struct_builder::Session when no extra information is needed when serializing Struct_builder...">Null_session</a>.  <a href="namespaceipc_1_1transport_1_1struc.html#ac70446757444f864afa21a5062bc5b0d">More...</a><br /></td></tr>
<tr class="separator:ac70446757444f864afa21a5062bc5b0d"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p >Sub-module of Flow-IPC module <a class="el" href="namespaceipc_1_1transport.html" title="Flow-IPC module providing transmission of structured messages and/or low-level blobs (and more) betwe...">ipc::transport</a> providing transmission of structured messages specifically. </p>
<p >See <a class="el" href="namespaceipc_1_1transport.html" title="Flow-IPC module providing transmission of structured messages and/or low-level blobs (and more) betwe...">ipc::transport</a> doc header. As that notes, the big daddy here is <a class="el" href="classipc_1_1transport_1_1struc_1_1Channel.html" title="Owning and wrapping a pre-connected transport::Channel peer (an endpoint of an established channel ov...">struc::Channel</a>.</p>
<p >Be aware of sub-namespace <a class="el" href="namespaceipc_1_1transport_1_1struc_1_1shm.html" title="Segregates zero-copy/SHM implementations of concepts residing in parent namespace ipc::transport::str...">ipc::transport::struc::shm</a> which concerns itself with end-to-end-zero-copyable messages leveraging in-SHM storage. Normally there's no need for the user to know or worry about it, but for advanced applications, particularly extensions and customizations, one might delve into this area of the code. Otherwise it'll be used silently as important glue between various systems. Your journey would like start with the struc::Builder concept doc header which would then lead you to <a class="el" href="classipc_1_1transport_1_1struc_1_1shm_1_1Builder.html" title="Implements Struct_builder concept with maximal zero-copy perf by (1) storing the actual user-schema-c...">struc::shm::Builder</a> impl. That might lead you to specific SHM-providers like <a class="el" href="namespaceipc_1_1shm_1_1classic.html" title="ipc::shm sub-module with the SHM-classic SHM-provider. See ipc::shm doc header for introduction.">ipc::shm::classic</a>. </p>
</div><h2 class="groupheader">Typedef Documentation</h2>
<a id="a52405569bf63eaef55f3c2435c885abc" name="a52405569bf63eaef55f3c2435c885abc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a52405569bf63eaef55f3c2435c885abc">&#9670;&nbsp;</a></span>Capnp_msg_builder_interface</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespaceipc_1_1transport_1_1struc.html#a52405569bf63eaef55f3c2435c885abc">ipc::transport::struc::Capnp_msg_builder_interface</a> = typedef ::capnp::MessageBuilder</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Alias for capnp's MessageBuilder interface. Rationale: as part of our API, we use our identifier style. </p>

<p class="definition">Definition at line <a class="el" href="struc__fwd_8hpp_source.html#l00067">67</a> of file <a class="el" href="struc__fwd_8hpp_source.html">struc_fwd.hpp</a>.</p>

</div>
</div>
<a id="aca041b0efd4a9ae18e10088b2ee3c052" name="aca041b0efd4a9ae18e10088b2ee3c052"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aca041b0efd4a9ae18e10088b2ee3c052">&#9670;&nbsp;</a></span>Channel_via_heap</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Channel_obj , typename Message_body &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespaceipc_1_1transport_1_1struc.html#aca041b0efd4a9ae18e10088b2ee3c052">ipc::transport::struc::Channel_via_heap</a> = typedef <a class="el" href="classipc_1_1transport_1_1struc_1_1Channel.html">Channel</a>&lt;Channel_obj, Message_body, <a class="el" href="structipc_1_1transport_1_1struc_1_1Heap__fixed__builder_1_1Config.html">Heap_fixed_builder::Config</a>, <a class="el" href="structipc_1_1transport_1_1struc_1_1Heap__reader_1_1Config.html">Heap_reader::Config</a>&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Convenience alias: Use this when constructing a <a class="el" href="classipc_1_1transport_1_1struc_1_1Channel.html" title="Owning and wrapping a pre-connected transport::Channel peer (an endpoint of an established channel ov...">struc::Channel</a> with tag <a class="el" href="classipc_1_1transport_1_1struc_1_1Channel__base.html#ab0eb05b5fb52364c99868a8535aaf26e" title="The sole value of the tag type Serialize_via_heap.">Channel_base::S_SERIALIZE_VIA_HEAP</a>. </p>
<p >See <a class="el" href="structipc_1_1transport_1_1struc_1_1Channel__base_1_1Serialize__via__heap.html" title="Tag type for ctor selection: Backing memory for serialization comes from fixed-size segment allocatio...">Channel_base::Serialize_via_heap</a> doc header for when/how to use.</p>
<p >Tip: <code>Sync_io_obj</code> member alias will get you the <code><a class="el" href="namespaceipc_1_1transport_1_1struc_1_1sync__io.html" title="sync_io-pattern counterparts to async-I/O-pattern object types in parent namespace ipc::transport::st...">sync_io</a></code>-pattern counterpart.</p>
<p >Unable to put it in ..._fwd.hpp, because it relies on nested class inside incomplete type. </p>

<p class="definition">Definition at line <a class="el" href="heap__serializer_8hpp_source.html#l00460">460</a> of file <a class="el" href="heap__serializer_8hpp_source.html">heap_serializer.hpp</a>.</p>

</div>
</div>
<a id="af7f35fc7588d97a838274fa25700ead9" name="af7f35fc7588d97a838274fa25700ead9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af7f35fc7588d97a838274fa25700ead9">&#9670;&nbsp;</a></span>msg_id_t</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespaceipc_1_1transport_1_1struc.html#af7f35fc7588d97a838274fa25700ead9">ipc::transport::struc::msg_id_t</a> = typedef uint64_t</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Message ID uniquely identifying outgoing message (<a class="el" href="classipc_1_1transport_1_1struc_1_1Msg__out.html" title="A structured out-message suitable to be sent via struc::Channel::send().">Msg_out</a>, among all other <code><a class="el" href="classipc_1_1transport_1_1struc_1_1Msg__out.html" title="A structured out-message suitable to be sent via struc::Channel::send().">Msg_out</a></code>s), per channel; and similarly incoming message (<a class="el" href="classipc_1_1transport_1_1struc_1_1Msg__in.html" title="A structured in-message instance suitable as received and emittable (to user) by struc::Channel.">Msg_in</a>, among <code><a class="el" href="classipc_1_1transport_1_1struc_1_1Msg__in.html" title="A structured in-message instance suitable as received and emittable (to user) by struc::Channel.">Msg_in</a></code>s), per channel. </p>
<p >0 is a sentinel value and not a valid user message ID. A message ID pertains to a <em>sent</em> or <em>received</em> <em>instance</em> of a user-created <a class="el" href="classipc_1_1transport_1_1struc_1_1Msg__out.html" title="A structured out-message suitable to be sent via struc::Channel::send().">Msg_out</a> (and its in-message countrepart <a class="el" href="classipc_1_1transport_1_1struc_1_1Msg__in.html" title="A structured in-message instance suitable as received and emittable (to user) by struc::Channel.">Msg_in</a>). A given <a class="el" href="classipc_1_1transport_1_1struc_1_1Msg__out.html" title="A structured out-message suitable to be sent via struc::Channel::send().">Msg_out</a> can be sent 2+ times through a given <a class="el" href="classipc_1_1transport_1_1struc_1_1Channel.html" title="Owning and wrapping a pre-connected transport::Channel peer (an endpoint of an established channel ov...">struc::Channel</a> and even a <em>different</em> <a class="el" href="classipc_1_1transport_1_1struc_1_1Channel.html" title="Owning and wrapping a pre-connected transport::Channel peer (an endpoint of an established channel ov...">struc::Channel</a>; a different message ID will pertain to each of those times for a given <a class="el" href="classipc_1_1transport_1_1struc_1_1Channel.html" title="Owning and wrapping a pre-connected transport::Channel peer (an endpoint of an established channel ov...">struc::Channel</a>. Therefore there is no <a class="el" href="namespaceipc_1_1transport_1_1struc.html#af7f35fc7588d97a838274fa25700ead9" title="Message ID uniquely identifying outgoing message (Msg_out, among all other Msg_outs),...">msg_id_t</a> <em>inside</em> a user <a class="el" href="classipc_1_1transport_1_1struc_1_1Msg__out.html" title="A structured out-message suitable to be sent via struc::Channel::send().">Msg_out</a>.</p>
<p >This type is in the public API, as the message ID is made available in certain contexts for:</p><ul>
<li>referring to an earlier-sent message, such as in <a class="el" href="classipc_1_1transport_1_1struc_1_1Channel.html#a34780bd3507a571cb719ce1d59e5d56f" title="Unregisters the expectation earlier-registered with the id_unless_one_off != nullptr form of async_re...">struc::Channel::undo_expect_responses()</a>; and</li>
<li>logging/reporting.</li>
</ul>
<p >It can also be used as a sequence number and is therefore assigned from sequence 1, 2, ... (0 is sentinel).</p>
<h3>Rationale for type used</h3>
<p >Needs to be big enough to where there's no chance it overflows in a given channel for a given direction. Assume 1 billion messages per second, or about 2^30 msg/s. That would take 2^(64-30), or 2^34, seconds, or over 500 years, to overflow. So this should be fine. Moreover overflow is fine in that case, in practice, if this is used only as a unique ID; it would however in theory present problems if used as a sequence number. </p>

<p class="definition">Definition at line <a class="el" href="struc__fwd_8hpp_source.html#l00145">145</a> of file <a class="el" href="struc__fwd_8hpp_source.html">struc_fwd.hpp</a>.</p>

</div>
</div>
<a id="a82a69eaa39cbe8a002de1266f1cbb5cb" name="a82a69eaa39cbe8a002de1266f1cbb5cb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a82a69eaa39cbe8a002de1266f1cbb5cb">&#9670;&nbsp;</a></span>Segment_ptrs</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespaceipc_1_1transport_1_1struc.html#a82a69eaa39cbe8a002de1266f1cbb5cb">ipc::transport::struc::Segment_ptrs</a> = typedef std::vector&lt;flow::util::Blob*&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sequence of 1+ <code>Blob</code> <em>pointers</em> to blobs which must stay alive while these pointers may be dereferenced, intended here to refer to a capnp serialization of a capnp-<code>struct</code>. </p>
<p >In each <code>Blob</code> [<code>begin()</code>, <code>end()</code>) is the serialization itself; and space before <code>begin()</code> and starting with <code>end()</code> may be reserved for framing prefix/postfix to preserve zero-copy when transmitting such serializations over an IPC "wire." </p>

<p class="definition">Definition at line <a class="el" href="struc__fwd_8hpp_source.html#l00122">122</a> of file <a class="el" href="struc__fwd_8hpp_source.html">struc_fwd.hpp</a>.</p>

</div>
</div>
<a id="a6751c05fb6582a34c7c47ac470c4a48b" name="a6751c05fb6582a34c7c47ac470c4a48b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6751c05fb6582a34c7c47ac470c4a48b">&#9670;&nbsp;</a></span>Session_token</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespaceipc_1_1transport_1_1struc.html#a6751c05fb6582a34c7c47ac470c4a48b">ipc::transport::struc::Session_token</a> = typedef boost::uuids::uuid</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>A type used by <a class="el" href="classipc_1_1transport_1_1struc_1_1Channel.html" title="Owning and wrapping a pre-connected transport::Channel peer (an endpoint of an established channel ov...">struc::Channel</a> for internal safety/security/auth needs. </p>
<p >See in particular <a class="el" href="classipc_1_1transport_1_1struc_1_1Channel.html" title="Owning and wrapping a pre-connected transport::Channel peer (an endpoint of an established channel ov...">struc::Channel</a> constructors, both the regular-channel one and the session-master-channel one. That said: The user of <a class="el" href="namespaceipc_1_1transport.html" title="Flow-IPC module providing transmission of structured messages and/or low-level blobs (and more) betwe...">ipc::transport</a> (aided by <a class="el" href="namespaceipc_1_1session.html" title="Flow-IPC module providing the broad lifecycle and shared-resource organization – via the session conc...">ipc::session</a>) structured layer shall generally be unconcerned with this, in practice, as <a class="el" href="namespaceipc_1_1session.html" title="Flow-IPC module providing the broad lifecycle and shared-resource organization – via the session conc...">ipc::session</a> machinery will take care of:</p><ul>
<li>setting up the session master <a class="el" href="classipc_1_1transport_1_1struc_1_1Channel.html" title="Owning and wrapping a pre-connected transport::Channel peer (an endpoint of an established channel ov...">struc::Channel</a> which will generate this token during initial setup (log-in); and</li>
<li>setting up further <code><a class="el" href="classipc_1_1transport_1_1struc_1_1Channel.html" title="Owning and wrapping a pre-connected transport::Channel peer (an endpoint of an established channel ov...">struc::Channel</a></code>s as requested by the user (the preceding bullet's token shall be passed to each new <a class="el" href="classipc_1_1transport_1_1struc_1_1Channel.html" title="Owning and wrapping a pre-connected transport::Channel peer (an endpoint of an established channel ov...">struc::Channel</a> and expected internally in all messages).</li>
</ul>
<p >However, if one plans to <em>create</em> a <a class="el" href="classipc_1_1transport_1_1struc_1_1Channel.html" title="Owning and wrapping a pre-connected transport::Channel peer (an endpoint of an established channel ov...">struc::Channel</a> directly (as <a class="el" href="namespaceipc_1_1session.html" title="Flow-IPC module providing the broad lifecycle and shared-resource organization – via the session conc...">ipc::session</a> does), then one must have some limited understanding of this guy's existence (if not the internal details).</p>
<p >As you can see: internally it is a UUID (RFC 4122 Universally Unique IDentifier) which is 128 bits (16 bytes) in size. It's also a POD (Plain Old Data object), meaning it's ctor-free (direct-initialized) and can be <code>memcpy()</code>d around and such. See boost.uuid docs (which are simple).</p>
<h3>Use and rationale thereof</h3>
<p >A session master channel <a class="el" href="classipc_1_1transport_1_1struc_1_1Channel.html" title="Owning and wrapping a pre-connected transport::Channel peer (an endpoint of an established channel ov...">struc::Channel</a>, operating in server mode during the log-in phase, will (as of this writing anyway) generate this using the boost.uuid random UUID generator. From that point on all channels spawned through that guy (by <a class="el" href="namespaceipc_1_1session.html" title="Flow-IPC module providing the broad lifecycle and shared-resource organization – via the session conc...">ipc::session</a>) will be cted with that token value; and all messages both in those channels and the original master channel (after the log-in message exchange) will send this value and ensure any in-message has that value (or immediately hose the channel &ndash; auth failure). This is a safety (not really security, due to the lack of token invalidation at least) measure. It will reduce chances that "wires get crossed," and a message goes into the wrong channel somehow.</p>
<p >That's how it's used. Is the random-generator method of UUID generation acceptable for this use?</p>
<p >A bit of research (starting in the RFC perhaps; or Wikipedia) shows that collisions are so cosmically rare as to make it, quite officially, a non-concern. Even if one does not accept that, however, suppose a collision does occur: two channels happen to generate the same UUID on the same machine around the same time. This (essentially impossible) scenario would not cause either channel to break; it would only allow (in theory) a token check to succeed where it shouldn't, if the fabled wires-crossed scenario occurred. This is an acceptable level of risk.</p>
<p >Conversely, perhaps using UUIDs for this is overkill. 128 bits isn't heavy, but perhaps something smaller &ndash; maybe even much smaller, like 32 bits or even 16 &ndash; would improve perf without really reducing effectiveness given the above rationale. Indeed that's worth considering but only in the phase where perf optimization is the explicit goal. Until then (if that even happens) the ability to use the nice boost.uuid library instead of rolling our own jankier/smaller UUID-like thing (or whatever) is well worth the alleged perf cost.</p>
<dl class="todo"><dt><b><a class="el" href="todo.html#_todo000029">Todo:</a></b></dt><dd>Look into whether something smaller that RFC 4122 UUIDs can and should be used for <a class="el" href="namespaceipc_1_1transport_1_1struc.html#a6751c05fb6582a34c7c47ac470c4a48b" title="A type used by struc::Channel for internal safety/security/auth needs.">Session_token</a>. This would be for perf but may well be unnecessary. See discussion near this to-do. </dd></dl>

<p class="definition">Definition at line <a class="el" href="struc__fwd_8hpp_source.html#l00113">113</a> of file <a class="el" href="struc__fwd_8hpp_source.html">struc_fwd.hpp</a>.</p>

</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a id="a0351bb14f40312b30e6cae4927f3373b" name="a0351bb14f40312b30e6cae4927f3373b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0351bb14f40312b30e6cae4927f3373b">&#9670;&nbsp;</a></span>operator&lt;&lt;() <span class="overload">[1/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Channel_obj , typename Message_body , typename Struct_builder_config , typename Struct_reader_config &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::ostream &amp; operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>os</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classipc_1_1transport_1_1struc_1_1Channel.html">Channel</a>&lt; Channel_obj, Message_body, Struct_builder_config, Struct_reader_config &gt; &amp;&#160;</td>
          <td class="paramname"><em>val</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Prints string representation of the given <a class="el" href="classipc_1_1transport_1_1struc_1_1Channel.html" title="Owning and wrapping a pre-connected transport::Channel peer (an endpoint of an established channel ov...">struc::Channel</a> to the given <code>ostream</code>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">os</td><td>Stream to which to write. </td></tr>
    <tr><td class="paramname">val</td><td>Object to serialize. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>os</code>. </dd></dl>

</div>
</div>
<a id="ae272f248d74db0486c4d9411715db15d" name="ae272f248d74db0486c4d9411715db15d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae272f248d74db0486c4d9411715db15d">&#9670;&nbsp;</a></span>operator&lt;&lt;() <span class="overload">[2/5]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::ostream &amp; operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>os</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classipc_1_1transport_1_1struc_1_1Heap__fixed__builder.html">Heap_fixed_builder</a> &amp;&#160;</td>
          <td class="paramname"><em>val</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Prints string representation of the given <code><a class="el" href="classipc_1_1transport_1_1struc_1_1Heap__fixed__builder.html" title="Implements Struct_builder concept by straightforwardly allocating fixed-size segments on-demand in th...">Heap_fixed_builder</a></code> to the given <code>ostream</code>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">os</td><td>Stream to which to write. </td></tr>
    <tr><td class="paramname">val</td><td>Object to serialize. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>os</code>. </dd></dl>

<p class="definition">Definition at line <a class="el" href="heap__serializer_8cpp_source.html#l00132">132</a> of file <a class="el" href="heap__serializer_8cpp_source.html">heap_serializer.cpp</a>.</p>

</div>
</div>
<a id="a8b1483d548bd56b3bf1e73bc46419e7a" name="a8b1483d548bd56b3bf1e73bc46419e7a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8b1483d548bd56b3bf1e73bc46419e7a">&#9670;&nbsp;</a></span>operator&lt;&lt;() <span class="overload">[3/5]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::ostream &amp; operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>os</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classipc_1_1transport_1_1struc_1_1Heap__reader.html">Heap_reader</a> &amp;&#160;</td>
          <td class="paramname"><em>val</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Prints string representation of the given <code><a class="el" href="classipc_1_1transport_1_1struc_1_1Heap__reader.html" title="Implements Struct_reader concept by straightforwardly interpreting a serialization by Heap_fixed_buil...">Heap_reader</a></code> to the given <code>ostream</code>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">os</td><td>Stream to which to write. </td></tr>
    <tr><td class="paramname">val</td><td>Object to serialize. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>os</code>. </dd></dl>

<p class="definition">Definition at line <a class="el" href="heap__serializer_8cpp_source.html#l00180">180</a> of file <a class="el" href="heap__serializer_8cpp_source.html">heap_serializer.cpp</a>.</p>

</div>
</div>
<a id="aad52996a4d66f74e21e4f2e74c93c763" name="aad52996a4d66f74e21e4f2e74c93c763"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aad52996a4d66f74e21e4f2e74c93c763">&#9670;&nbsp;</a></span>operator&lt;&lt;() <span class="overload">[4/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Message_body , typename Struct_reader_config &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::ostream &amp; operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>os</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classipc_1_1transport_1_1struc_1_1Msg__in.html">Msg_in</a>&lt; Message_body, Struct_reader_config &gt; &amp;&#160;</td>
          <td class="paramname"><em>val</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Prints string representation of the given <code><a class="el" href="classipc_1_1transport_1_1struc_1_1Msg__in.html" title="A structured in-message instance suitable as received and emittable (to user) by struc::Channel.">Msg_in</a></code> to the given <code>ostream</code>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">os</td><td>Stream to which to write. </td></tr>
    <tr><td class="paramname">val</td><td>Object to serialize. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>os</code>. </dd></dl>

<p class="definition">Definition at line <a class="el" href="msg_8hpp_source.html#l01407">1407</a> of file <a class="el" href="msg_8hpp_source.html">msg.hpp</a>.</p>

</div>
</div>
<a id="a134e737e55ae825527efd6a9e68bf37e" name="a134e737e55ae825527efd6a9e68bf37e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a134e737e55ae825527efd6a9e68bf37e">&#9670;&nbsp;</a></span>operator&lt;&lt;() <span class="overload">[5/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Message_body , typename Struct_builder_t &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::ostream &amp; operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>os</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classipc_1_1transport_1_1struc_1_1Msg__out.html">Msg_out</a>&lt; Message_body, Struct_builder_t &gt; &amp;&#160;</td>
          <td class="paramname"><em>val</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Prints string representation of the given <code><a class="el" href="classipc_1_1transport_1_1struc_1_1Msg__out.html" title="A structured out-message suitable to be sent via struc::Channel::send().">Msg_out</a></code> to the given <code>ostream</code>. </p>
<p >Namely it prints via <a class="el" href="classipc_1_1transport_1_1struc_1_1Msg__out.html#a754e0f025f471105d52b3b090c27f1c0" title="Prints string representation to the given ostream.">Msg_out::to_ostream()</a>`; be sure to read perf notes on that!</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">os</td><td>Stream to which to write. </td></tr>
    <tr><td class="paramname">val</td><td>Object to serialize. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>os</code>. </dd></dl>

<p class="definition">Definition at line <a class="el" href="msg_8hpp_source.html#l01108">1108</a> of file <a class="el" href="msg_8hpp_source.html">msg.hpp</a>.</p>

</div>
</div>
<h2 class="groupheader">Variable Documentation</h2>
<a id="ac70446757444f864afa21a5062bc5b0d" name="ac70446757444f864afa21a5062bc5b0d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac70446757444f864afa21a5062bc5b0d">&#9670;&nbsp;</a></span>NULL_SESSION</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="structipc_1_1transport_1_1struc_1_1Null__session.html">Null_session</a> ipc::transport::struc::NULL_SESSION</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The only necessary value of empty-type <a class="el" href="structipc_1_1transport_1_1struc_1_1Null__session.html" title="Value for Struct_builder::Session when no extra information is needed when serializing Struct_builder...">Null_session</a>. </p>

<p class="definition">Definition at line <a class="el" href="heap__serializer_8cpp_source.html#l00035">35</a> of file <a class="el" href="heap__serializer_8cpp_source.html">heap_serializer.cpp</a>.</p>

<p class="reference">Referenced by <a class="el" href="ipc__shm_2src_2ipc_2transport_2struc_2shm_2serializer_8hpp_source.html#l00554">ipc::transport::struc::shm::Builder&lt; Shm_arena &gt;::emit_serialization()</a>, and <a class="el" href="ipc__transport__structured_2src_2ipc_2transport_2struc_2sync__io_2channel_8hpp_source.html#l04573">ipc::transport::struc::sync_io::Channel&lt; Channel_obj, Message_body, Struct_builder_config, Struct_reader_config &gt;::send_proto_neg()</a>.</p>

</div>
</div>
<a id="ad556d20a2aa2d52b83c7afb73951d47d" name="ad556d20a2aa2d52b83c7afb73951d47d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad556d20a2aa2d52b83c7afb73951d47d">&#9670;&nbsp;</a></span>NULL_SESSION_TOKEN</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="namespaceipc_1_1transport_1_1struc.html#a6751c05fb6582a34c7c47ac470c4a48b">Session_token</a> ipc::transport::struc::NULL_SESSION_TOKEN = boost::uuids::nil_uuid()</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>A value for which <code>.is_nil()</code> is true. </p>

<p class="definition">Definition at line <a class="el" href="ipc__transport__structured_2src_2ipc_2transport_2struc_2channel_8cpp_source.html#l00035">35</a> of file <a class="el" href="ipc__transport__structured_2src_2ipc_2transport_2struc_2channel_8cpp_source.html">channel.cpp</a>.</p>

<p class="reference">Referenced by <a class="el" href="ipc__session_2src_2ipc_2session_2detail_2client__session__impl_8hpp_source.html#l01926">ipc::session::Client_session_impl&lt; S_MQ_TYPE_OR_NONE, S_TRANSMIT_NATIVE_HANDLES, Mdt_payload, S_SHM_TYPE_OR_NONE &gt;::session_token()</a>, <a class="el" href="ipc__session_2src_2ipc_2session_2detail_2server__session__impl_8hpp_source.html#l00897">ipc::session::Server_session_impl&lt; S_MQ_TYPE_OR_NONE, S_TRANSMIT_NATIVE_HANDLES, Mdt_payload, S_SHM_TYPE_OR_NONE, S_SHM_MAX_HNDL_SZ &gt;::session_token()</a>, <a class="el" href="ipc__session_2src_2ipc_2session_2session_8hpp_source.html#l00879">ipc::session::Session_mv&lt; Session_impl_t &gt;::session_token()</a>, and <a class="el" href="ipc__transport__structured_2src_2ipc_2transport_2struc_2sync__io_2channel_8hpp_source.html#l05061">ipc::transport::struc::sync_io::Channel&lt; Channel_obj, Message_body, Struct_builder_config, Struct_reader_config &gt;::session_token()</a>.</p>

</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Tue Mar 5 2024 06:04:44 for Flow-IPC by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.4
</small></address>
</body>
</html>
