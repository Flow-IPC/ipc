<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.9.4"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Flow-IPC: ipc::session::Client_session_impl&lt; S_MQ_TYPE_OR_NONE, S_TRANSMIT_NATIVE_HANDLES, Mdt_payload, S_SHM_TYPE_OR_NONE &gt; Class Template Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">Flow-IPC<span id="projectnumber">&#160;1.0</span>
   </div>
   <div id="projectbrief">Flow-IPC project: Full implementation reference.</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.4 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search",'Search','.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespaceipc.html">ipc</a></li><li class="navelem"><a class="el" href="namespaceipc_1_1session.html">session</a></li><li class="navelem"><a class="el" href="classipc_1_1session_1_1Client__session__impl.html">Client_session_impl</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#pub-types">Public Types</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pub-static-attribs">Static Public Attributes</a> &#124;
<a href="#pro-types">Protected Types</a> &#124;
<a href="#pro-methods">Protected Member Functions</a> &#124;
<a href="#pri-types">Private Types</a> &#124;
<a href="#pri-methods">Private Member Functions</a> &#124;
<a href="#pri-attribs">Private Attributes</a> &#124;
<a href="#related">Related Functions</a> &#124;
<a href="classipc_1_1session_1_1Client__session__impl-members.html">List of all members</a>  </div>
  <div class="headertitle"><div class="title">ipc::session::Client_session_impl&lt; S_MQ_TYPE_OR_NONE, S_TRANSMIT_NATIVE_HANDLES, Mdt_payload, S_SHM_TYPE_OR_NONE &gt; Class Template Reference</div></div>
</div><!--header-->
<div class="contents">

<p>Internal, non-movable pImpl-lite implementation of <a class="el" href="classipc_1_1session_1_1Client__session__mv.html" title="Implements Session concept on the Client_app end: a Session_mv that first achieves PEER state by conn...">Client_session_mv</a> class template.  
 <a href="classipc_1_1session_1_1Client__session__impl.html#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="ipc__session_2src_2ipc_2session_2detail_2client__session__impl_8hpp_source.html">client_session_impl.hpp</a>&gt;</code></p>
<div class="dynheader">
Inheritance diagram for ipc::session::Client_session_impl&lt; S_MQ_TYPE_OR_NONE, S_TRANSMIT_NATIVE_HANDLES, Mdt_payload, S_SHM_TYPE_OR_NONE &gt;:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="classipc_1_1session_1_1Client__session__impl__inherit__graph.svg" width="628" height="120"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe>
</div>
<center><span class="legend">[<a href="graph_legend.html">legend</a>]</span></center></div>
<div class="dynheader">
Collaboration diagram for ipc::session::Client_session_impl&lt; S_MQ_TYPE_OR_NONE, S_TRANSMIT_NATIVE_HANDLES, Mdt_payload, S_SHM_TYPE_OR_NONE &gt;:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="classipc_1_1session_1_1Client__session__impl__coll__graph.svg" width="1888" height="866"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe>
</div>
<center><span class="legend">[<a href="graph_legend.html">legend</a>]</span></center></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="nested-classes" name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structipc_1_1session_1_1Client__session__impl_1_1Master__channel__req.html">Master_channel_req</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">An open-channel/log-in request out-message.  <a href="structipc_1_1session_1_1Client__session__impl_1_1Master__channel__req.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-types" name="pub-types"></a>
Public Types</h2></td></tr>
<tr class="memitem:a1bc8c5b0a277261799062827992efbea"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classipc_1_1session_1_1Client__session__impl.html#a1bc8c5b0a277261799062827992efbea">Base</a> = <a class="el" href="classipc_1_1session_1_1Session__base.html">Session_base</a>&lt; S_MQ_TYPE_OR_NONE, S_TRANSMIT_NATIVE_HANDLES, Mdt_payload &gt;</td></tr>
<tr class="memdesc:a1bc8c5b0a277261799062827992efbea"><td class="mdescLeft">&#160;</td><td class="mdescRight">Short-hand for base type.  <a href="classipc_1_1session_1_1Client__session__impl.html#a1bc8c5b0a277261799062827992efbea">More...</a><br /></td></tr>
<tr class="separator:a1bc8c5b0a277261799062827992efbea"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8942fcefa7654708f863946fc467f875"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classipc_1_1session_1_1Client__session__impl.html#a8942fcefa7654708f863946fc467f875">Session_base_obj</a> = <a class="el" href="classipc_1_1session_1_1Client__session__impl.html#a1bc8c5b0a277261799062827992efbea">Base</a></td></tr>
<tr class="memdesc:a8942fcefa7654708f863946fc467f875"><td class="mdescLeft">&#160;</td><td class="mdescRight">Short-hand for <a class="el" href="classipc_1_1session_1_1Session__base.html" title="Internal type containing data and types common to internal types Server_session_impl and Client_sessi...">Session_base</a> super-class.  <a href="classipc_1_1session_1_1Client__session__impl.html#a8942fcefa7654708f863946fc467f875">More...</a><br /></td></tr>
<tr class="separator:a8942fcefa7654708f863946fc467f875"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a418a1e70b7b51833cc9d24d1046e3526"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classipc_1_1session_1_1Client__session__impl.html#a418a1e70b7b51833cc9d24d1046e3526">Channel_obj</a> = typename <a class="el" href="classipc_1_1session_1_1Session__base.html#a71f02a809d667c23ff8af29a96940bd1">Base::Channel_obj</a></td></tr>
<tr class="memdesc:a418a1e70b7b51833cc9d24d1046e3526"><td class="mdescLeft">&#160;</td><td class="mdescRight">See <a class="el" href="classipc_1_1session_1_1Client__session__mv.html" title="Implements Session concept on the Client_app end: a Session_mv that first achieves PEER state by conn...">Client_session_mv</a> counterpart.  <a href="classipc_1_1session_1_1Client__session__impl.html#a418a1e70b7b51833cc9d24d1046e3526">More...</a><br /></td></tr>
<tr class="separator:a418a1e70b7b51833cc9d24d1046e3526"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a48487e4c98ae3a82ef344269742c8057"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classipc_1_1session_1_1Client__session__impl.html#a48487e4c98ae3a82ef344269742c8057">Channels</a> = typename <a class="el" href="classipc_1_1session_1_1Session__base.html#a638232ef74a0eb80aeb4f027ee06f9bf">Base::Channels</a></td></tr>
<tr class="memdesc:a48487e4c98ae3a82ef344269742c8057"><td class="mdescLeft">&#160;</td><td class="mdescRight">See <a class="el" href="classipc_1_1session_1_1Session__mv.html" title="Implements the Session concept when it is in PEER state.">Session_mv</a> counterpart.  <a href="classipc_1_1session_1_1Client__session__impl.html#a48487e4c98ae3a82ef344269742c8057">More...</a><br /></td></tr>
<tr class="separator:a48487e4c98ae3a82ef344269742c8057"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3e6259ce0f762ce44f161818640db0c6"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classipc_1_1session_1_1Client__session__impl.html#a3e6259ce0f762ce44f161818640db0c6">Mdt_payload_obj</a> = typename <a class="el" href="classipc_1_1session_1_1Session__base.html#a35234981ca87cc2f6b118b3e52452ea8">Base::Mdt_payload_obj</a></td></tr>
<tr class="memdesc:a3e6259ce0f762ce44f161818640db0c6"><td class="mdescLeft">&#160;</td><td class="mdescRight">See <a class="el" href="classipc_1_1session_1_1Client__session__mv.html" title="Implements Session concept on the Client_app end: a Session_mv that first achieves PEER state by conn...">Client_session_mv</a> counterpart.  <a href="classipc_1_1session_1_1Client__session__impl.html#a3e6259ce0f762ce44f161818640db0c6">More...</a><br /></td></tr>
<tr class="separator:a3e6259ce0f762ce44f161818640db0c6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2cc5b77dd2367cc8e821fdcab7f6c109"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classipc_1_1session_1_1Client__session__impl.html#a2cc5b77dd2367cc8e821fdcab7f6c109">Mdt_reader_ptr</a> = typename <a class="el" href="classipc_1_1session_1_1Session__base.html#ace4dab42adec6354cc66081dd218ac71">Base::Mdt_reader_ptr</a></td></tr>
<tr class="memdesc:a2cc5b77dd2367cc8e821fdcab7f6c109"><td class="mdescLeft">&#160;</td><td class="mdescRight">See <a class="el" href="classipc_1_1session_1_1Client__session__mv.html" title="Implements Session concept on the Client_app end: a Session_mv that first achieves PEER state by conn...">Client_session_mv</a> counterpart.  <a href="classipc_1_1session_1_1Client__session__impl.html#a2cc5b77dd2367cc8e821fdcab7f6c109">More...</a><br /></td></tr>
<tr class="separator:a2cc5b77dd2367cc8e821fdcab7f6c109"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aec1f6670627bf8fc5b148b19a6faa9cf"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classipc_1_1session_1_1Client__session__impl.html#aec1f6670627bf8fc5b148b19a6faa9cf">Mdt_builder</a> = typename <a class="el" href="classipc_1_1session_1_1Session__base.html#a7d68bbb8c0c09983619d563bca30bd45">Base::Mdt_builder</a></td></tr>
<tr class="memdesc:aec1f6670627bf8fc5b148b19a6faa9cf"><td class="mdescLeft">&#160;</td><td class="mdescRight">See <a class="el" href="classipc_1_1session_1_1Client__session__mv.html" title="Implements Session concept on the Client_app end: a Session_mv that first achieves PEER state by conn...">Client_session_mv</a> counterpart.  <a href="classipc_1_1session_1_1Client__session__impl.html#aec1f6670627bf8fc5b148b19a6faa9cf">More...</a><br /></td></tr>
<tr class="separator:aec1f6670627bf8fc5b148b19a6faa9cf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5d391e86ccc1153b4975efdc8e5401e4"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classipc_1_1session_1_1Client__session__impl.html#a5d391e86ccc1153b4975efdc8e5401e4">Mdt_builder_ptr</a> = typename <a class="el" href="classipc_1_1session_1_1Session__base.html#a4a7a5b83f6ba8bd505685636eabc012b">Base::Mdt_builder_ptr</a></td></tr>
<tr class="memdesc:a5d391e86ccc1153b4975efdc8e5401e4"><td class="mdescLeft">&#160;</td><td class="mdescRight">See <a class="el" href="classipc_1_1session_1_1Client__session__mv.html" title="Implements Session concept on the Client_app end: a Session_mv that first achieves PEER state by conn...">Client_session_mv</a> counterpart.  <a href="classipc_1_1session_1_1Client__session__impl.html#a5d391e86ccc1153b4975efdc8e5401e4">More...</a><br /></td></tr>
<tr class="separator:a5d391e86ccc1153b4975efdc8e5401e4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae93393f13b3f9f05179d3334a607b26e"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classipc_1_1session_1_1Client__session__impl.html#ae93393f13b3f9f05179d3334a607b26e">Structured_msg_builder_config</a> = typename <a class="el" href="classipc_1_1session_1_1Session__base.html#aee0db48505c84d3553b7110a9a815036">Base::Structured_msg_builder_config</a></td></tr>
<tr class="memdesc:ae93393f13b3f9f05179d3334a607b26e"><td class="mdescLeft">&#160;</td><td class="mdescRight">See <a class="el" href="classipc_1_1session_1_1Session__mv.html" title="Implements the Session concept when it is in PEER state.">Session_mv</a> counterpart.  <a href="classipc_1_1session_1_1Client__session__impl.html#ae93393f13b3f9f05179d3334a607b26e">More...</a><br /></td></tr>
<tr class="separator:ae93393f13b3f9f05179d3334a607b26e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae3d2416929234a32dd7d1f5532af549f"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classipc_1_1session_1_1Client__session__impl.html#ae3d2416929234a32dd7d1f5532af549f">Structured_msg_reader_config</a> = typename <a class="el" href="classipc_1_1session_1_1Session__base.html#abd854f2b9316361ef18f15610c242d4b">Base::Structured_msg_reader_config</a></td></tr>
<tr class="memdesc:ae3d2416929234a32dd7d1f5532af549f"><td class="mdescLeft">&#160;</td><td class="mdescRight">See <a class="el" href="classipc_1_1session_1_1Session__mv.html" title="Implements the Session concept when it is in PEER state.">Session_mv</a> counterpart.  <a href="classipc_1_1session_1_1Client__session__impl.html#ae3d2416929234a32dd7d1f5532af549f">More...</a><br /></td></tr>
<tr class="separator:ae3d2416929234a32dd7d1f5532af549f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pub_types_classipc_1_1session_1_1Session__base"><td colspan="2" onclick="javascript:toggleInherit('pub_types_classipc_1_1session_1_1Session__base')"><img src="closed.png" alt="-"/>&#160;Public Types inherited from <a class="el" href="classipc_1_1session_1_1Session__base.html">ipc::session::Session_base&lt; S_MQ_TYPE_OR_NONE, S_TRANSMIT_NATIVE_HANDLES, Mdt_payload &gt;</a></td></tr>
<tr class="memitem:a848c0f5247644ada0f8b0ab816eedda8 inherit pub_types_classipc_1_1session_1_1Session__base"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classipc_1_1session_1_1Session__base.html#a848c0f5247644ada0f8b0ab816eedda8">Persistent_mq_handle_from_cfg</a> = std::conditional_t&lt;!<a class="el" href="classipc_1_1session_1_1Session__base.html#a27a5731a648effb6b4b42f0312affa74">S_MQS_ENABLED</a>, <a class="el" href="classipc_1_1transport_1_1Null__peer.html">transport::Null_peer</a>, std::conditional_t&lt; S_MQ_TYPE_OR_NONE==schema::MqType::POSIX, <a class="el" href="classipc_1_1transport_1_1Posix__mq__handle.html">transport::Posix_mq_handle</a>, <a class="el" href="classipc_1_1transport_1_1Bipc__mq__handle.html">transport::Bipc_mq_handle</a> &gt; &gt;</td></tr>
<tr class="memdesc:a848c0f5247644ada0f8b0ab816eedda8 inherit pub_types_classipc_1_1session_1_1Session__base"><td class="mdescLeft">&#160;</td><td class="mdescRight">Relevant only if <a class="el" href="classipc_1_1session_1_1Session__base.html#a27a5731a648effb6b4b42f0312affa74" title="See Session_mv.">S_MQS_ENABLED</a>, this is the Persistent_mq_handle-concept impl type specified by the user via <code>S_MQ_TYPE_OR_NONE</code>.  <a href="classipc_1_1session_1_1Session__base.html#a848c0f5247644ada0f8b0ab816eedda8">More...</a><br /></td></tr>
<tr class="separator:a848c0f5247644ada0f8b0ab816eedda8 inherit pub_types_classipc_1_1session_1_1Session__base"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a71f02a809d667c23ff8af29a96940bd1 inherit pub_types_classipc_1_1session_1_1Session__base"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classipc_1_1session_1_1Session__base.html#a71f02a809d667c23ff8af29a96940bd1">Channel_obj</a> = std::conditional_t&lt; <a class="el" href="classipc_1_1session_1_1Session__base.html#a27a5731a648effb6b4b42f0312affa74">S_MQS_ENABLED</a>, std::conditional_t&lt; S_TRANSMIT_NATIVE_HANDLES, <a class="el" href="classipc_1_1transport_1_1Mqs__socket__stream__channel.html">transport::Mqs_socket_stream_channel</a>&lt; true, <a class="el" href="classipc_1_1session_1_1Session__base.html#a848c0f5247644ada0f8b0ab816eedda8">Persistent_mq_handle_from_cfg</a> &gt;, <a class="el" href="classipc_1_1transport_1_1Mqs__channel.html">transport::Mqs_channel</a>&lt; true, <a class="el" href="classipc_1_1session_1_1Session__base.html#a848c0f5247644ada0f8b0ab816eedda8">Persistent_mq_handle_from_cfg</a> &gt; &gt;, std::conditional_t&lt; S_TRANSMIT_NATIVE_HANDLES, <a class="el" href="classipc_1_1transport_1_1Socket__stream__channel.html">transport::Socket_stream_channel</a>&lt; true &gt;, <a class="el" href="classipc_1_1transport_1_1Socket__stream__channel__of__blobs.html">transport::Socket_stream_channel_of_blobs</a>&lt; true &gt; &gt; &gt;</td></tr>
<tr class="memdesc:a71f02a809d667c23ff8af29a96940bd1 inherit pub_types_classipc_1_1session_1_1Session__base"><td class="mdescLeft">&#160;</td><td class="mdescRight">See <a class="el" href="classipc_1_1session_1_1Session__mv.html" title="Implements the Session concept when it is in PEER state.">Session_mv</a> (or <a class="el" href="classipc_1_1session_1_1Session.html" title="A documentation-only concept defining the local side of an IPC conversation (session) with another en...">Session</a> concept).  <a href="classipc_1_1session_1_1Session__base.html#a71f02a809d667c23ff8af29a96940bd1">More...</a><br /></td></tr>
<tr class="separator:a71f02a809d667c23ff8af29a96940bd1 inherit pub_types_classipc_1_1session_1_1Session__base"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a638232ef74a0eb80aeb4f027ee06f9bf inherit pub_types_classipc_1_1session_1_1Session__base"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classipc_1_1session_1_1Session__base.html#a638232ef74a0eb80aeb4f027ee06f9bf">Channels</a> = std::vector&lt; <a class="el" href="classipc_1_1session_1_1Session__base.html#a71f02a809d667c23ff8af29a96940bd1">Channel_obj</a> &gt;</td></tr>
<tr class="memdesc:a638232ef74a0eb80aeb4f027ee06f9bf inherit pub_types_classipc_1_1session_1_1Session__base"><td class="mdescLeft">&#160;</td><td class="mdescRight">See <a class="el" href="classipc_1_1session_1_1Session__mv.html" title="Implements the Session concept when it is in PEER state.">Session_mv</a>. Note: If changed from <code>vector</code> please update those doc headers too.  <a href="classipc_1_1session_1_1Session__base.html#a638232ef74a0eb80aeb4f027ee06f9bf">More...</a><br /></td></tr>
<tr class="separator:a638232ef74a0eb80aeb4f027ee06f9bf inherit pub_types_classipc_1_1session_1_1Session__base"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a35234981ca87cc2f6b118b3e52452ea8 inherit pub_types_classipc_1_1session_1_1Session__base"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classipc_1_1session_1_1Session__base.html#a35234981ca87cc2f6b118b3e52452ea8">Mdt_payload_obj</a> = Mdt_payload</td></tr>
<tr class="memdesc:a35234981ca87cc2f6b118b3e52452ea8 inherit pub_types_classipc_1_1session_1_1Session__base"><td class="mdescLeft">&#160;</td><td class="mdescRight">See <a class="el" href="classipc_1_1session_1_1Session__mv.html" title="Implements the Session concept when it is in PEER state.">Session_mv</a> (or <a class="el" href="classipc_1_1session_1_1Session.html" title="A documentation-only concept defining the local side of an IPC conversation (session) with another en...">Session</a> concept).  <a href="classipc_1_1session_1_1Session__base.html#a35234981ca87cc2f6b118b3e52452ea8">More...</a><br /></td></tr>
<tr class="separator:a35234981ca87cc2f6b118b3e52452ea8 inherit pub_types_classipc_1_1session_1_1Session__base"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ace4dab42adec6354cc66081dd218ac71 inherit pub_types_classipc_1_1session_1_1Session__base"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classipc_1_1session_1_1Session__base.html#ace4dab42adec6354cc66081dd218ac71">Mdt_reader_ptr</a> = boost::shared_ptr&lt; typename transport::struc::schema::Metadata&lt; <a class="el" href="classipc_1_1session_1_1Session__base.html#a35234981ca87cc2f6b118b3e52452ea8">Mdt_payload_obj</a> &gt;::Reader &gt;</td></tr>
<tr class="memdesc:ace4dab42adec6354cc66081dd218ac71 inherit pub_types_classipc_1_1session_1_1Session__base"><td class="mdescLeft">&#160;</td><td class="mdescRight">See <a class="el" href="classipc_1_1session_1_1Session__mv.html" title="Implements the Session concept when it is in PEER state.">Session_mv</a> (or <a class="el" href="classipc_1_1session_1_1Session.html" title="A documentation-only concept defining the local side of an IPC conversation (session) with another en...">Session</a> concept).  <a href="classipc_1_1session_1_1Session__base.html#ace4dab42adec6354cc66081dd218ac71">More...</a><br /></td></tr>
<tr class="separator:ace4dab42adec6354cc66081dd218ac71 inherit pub_types_classipc_1_1session_1_1Session__base"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7d68bbb8c0c09983619d563bca30bd45 inherit pub_types_classipc_1_1session_1_1Session__base"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classipc_1_1session_1_1Session__base.html#a7d68bbb8c0c09983619d563bca30bd45">Mdt_builder</a> = typename transport::struc::schema::Metadata&lt; <a class="el" href="classipc_1_1session_1_1Session__base.html#a35234981ca87cc2f6b118b3e52452ea8">Mdt_payload_obj</a> &gt;<a class="el" href="classStruct__builder__config_1_1Builder.html">::Builder</a></td></tr>
<tr class="memdesc:a7d68bbb8c0c09983619d563bca30bd45 inherit pub_types_classipc_1_1session_1_1Session__base"><td class="mdescLeft">&#160;</td><td class="mdescRight">See <a class="el" href="classipc_1_1session_1_1Session__mv.html" title="Implements the Session concept when it is in PEER state.">Session_mv</a> (or <a class="el" href="classipc_1_1session_1_1Session.html" title="A documentation-only concept defining the local side of an IPC conversation (session) with another en...">Session</a> concept).  <a href="classipc_1_1session_1_1Session__base.html#a7d68bbb8c0c09983619d563bca30bd45">More...</a><br /></td></tr>
<tr class="separator:a7d68bbb8c0c09983619d563bca30bd45 inherit pub_types_classipc_1_1session_1_1Session__base"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4a7a5b83f6ba8bd505685636eabc012b inherit pub_types_classipc_1_1session_1_1Session__base"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classipc_1_1session_1_1Session__base.html#a4a7a5b83f6ba8bd505685636eabc012b">Mdt_builder_ptr</a> = boost::shared_ptr&lt; <a class="el" href="classipc_1_1session_1_1Session__base.html#a7d68bbb8c0c09983619d563bca30bd45">Mdt_builder</a> &gt;</td></tr>
<tr class="memdesc:a4a7a5b83f6ba8bd505685636eabc012b inherit pub_types_classipc_1_1session_1_1Session__base"><td class="mdescLeft">&#160;</td><td class="mdescRight">See <a class="el" href="classipc_1_1session_1_1Session__mv.html" title="Implements the Session concept when it is in PEER state.">Session_mv</a> (or <a class="el" href="classipc_1_1session_1_1Session.html" title="A documentation-only concept defining the local side of an IPC conversation (session) with another en...">Session</a> concept).  <a href="classipc_1_1session_1_1Session__base.html#a4a7a5b83f6ba8bd505685636eabc012b">More...</a><br /></td></tr>
<tr class="separator:a4a7a5b83f6ba8bd505685636eabc012b inherit pub_types_classipc_1_1session_1_1Session__base"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aee0db48505c84d3553b7110a9a815036 inherit pub_types_classipc_1_1session_1_1Session__base"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classipc_1_1session_1_1Session__base.html#aee0db48505c84d3553b7110a9a815036">Structured_msg_builder_config</a> = <a class="el" href="structipc_1_1transport_1_1struc_1_1Heap__fixed__builder_1_1Config.html">transport::struc::Heap_fixed_builder::Config</a></td></tr>
<tr class="memdesc:aee0db48505c84d3553b7110a9a815036 inherit pub_types_classipc_1_1session_1_1Session__base"><td class="mdescLeft">&#160;</td><td class="mdescRight">See <a class="el" href="classipc_1_1session_1_1Session__mv.html" title="Implements the Session concept when it is in PEER state.">Session_mv</a> (or <a class="el" href="classipc_1_1session_1_1Session.html" title="A documentation-only concept defining the local side of an IPC conversation (session) with another en...">Session</a> concept).  <a href="classipc_1_1session_1_1Session__base.html#aee0db48505c84d3553b7110a9a815036">More...</a><br /></td></tr>
<tr class="separator:aee0db48505c84d3553b7110a9a815036 inherit pub_types_classipc_1_1session_1_1Session__base"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abd854f2b9316361ef18f15610c242d4b inherit pub_types_classipc_1_1session_1_1Session__base"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classipc_1_1session_1_1Session__base.html#abd854f2b9316361ef18f15610c242d4b">Structured_msg_reader_config</a> = <a class="el" href="structipc_1_1transport_1_1struc_1_1Heap__reader_1_1Config.html">transport::struc::Heap_reader::Config</a></td></tr>
<tr class="memdesc:abd854f2b9316361ef18f15610c242d4b inherit pub_types_classipc_1_1session_1_1Session__base"><td class="mdescLeft">&#160;</td><td class="mdescRight">See <a class="el" href="classipc_1_1session_1_1Session__mv.html" title="Implements the Session concept when it is in PEER state.">Session_mv</a> (or <a class="el" href="classipc_1_1session_1_1Session.html" title="A documentation-only concept defining the local side of an IPC conversation (session) with another en...">Session</a> concept).  <a href="classipc_1_1session_1_1Session__base.html#abd854f2b9316361ef18f15610c242d4b">More...</a><br /></td></tr>
<tr class="separator:abd854f2b9316361ef18f15610c242d4b inherit pub_types_classipc_1_1session_1_1Session__base"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-methods" name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:ae43a93e3a573beb5f66f12420393b857"><td class="memTemplParams" colspan="2">template&lt;typename On_passive_open_channel_handler , typename Task_err &gt; </td></tr>
<tr class="memitem:ae43a93e3a573beb5f66f12420393b857"><td class="memTemplItemLeft" align="right" valign="top">&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classipc_1_1session_1_1Client__session__impl.html#ae43a93e3a573beb5f66f12420393b857">Client_session_impl</a> (flow::log::Logger *logger_ptr, const <a class="el" href="structipc_1_1session_1_1Client__app.html">Client_app</a> &amp;cli_app_ref, const <a class="el" href="structipc_1_1session_1_1Server__app.html">Server_app</a> &amp;srv_app_ref, Task_err &amp;&amp;on_err_func, On_passive_open_channel_handler &amp;&amp;on_passive_open_channel_func)</td></tr>
<tr class="memdesc:ae43a93e3a573beb5f66f12420393b857"><td class="mdescLeft">&#160;</td><td class="mdescRight">See <a class="el" href="classipc_1_1session_1_1Client__session__mv.html" title="Implements Session concept on the Client_app end: a Session_mv that first achieves PEER state by conn...">Client_session_mv</a> counterpart.  <a href="classipc_1_1session_1_1Client__session__impl.html#ae43a93e3a573beb5f66f12420393b857">More...</a><br /></td></tr>
<tr class="separator:ae43a93e3a573beb5f66f12420393b857"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a44e1af36f971cb682ca52bc569204b80"><td class="memTemplParams" colspan="2">template&lt;typename Task_err &gt; </td></tr>
<tr class="memitem:a44e1af36f971cb682ca52bc569204b80"><td class="memTemplItemLeft" align="right" valign="top">&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classipc_1_1session_1_1Client__session__impl.html#a44e1af36f971cb682ca52bc569204b80">Client_session_impl</a> (flow::log::Logger *logger_ptr, const <a class="el" href="structipc_1_1session_1_1Client__app.html">Client_app</a> &amp;cli_app_ref, const <a class="el" href="structipc_1_1session_1_1Server__app.html">Server_app</a> &amp;srv_app_ref, Task_err &amp;&amp;on_err_func)</td></tr>
<tr class="memdesc:a44e1af36f971cb682ca52bc569204b80"><td class="mdescLeft">&#160;</td><td class="mdescRight">See <a class="el" href="classipc_1_1session_1_1Client__session__mv.html" title="Implements Session concept on the Client_app end: a Session_mv that first achieves PEER state by conn...">Client_session_mv</a> counterpart.  <a href="classipc_1_1session_1_1Client__session__impl.html#a44e1af36f971cb682ca52bc569204b80">More...</a><br /></td></tr>
<tr class="separator:a44e1af36f971cb682ca52bc569204b80"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a45c22f131543ca25adc0cdcb608ddb1f"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classipc_1_1session_1_1Client__session__impl.html#a45c22f131543ca25adc0cdcb608ddb1f">~Client_session_impl</a> ()</td></tr>
<tr class="memdesc:a45c22f131543ca25adc0cdcb608ddb1f"><td class="mdescLeft">&#160;</td><td class="mdescRight">See <a class="el" href="classipc_1_1session_1_1Client__session__mv.html" title="Implements Session concept on the Client_app end: a Session_mv that first achieves PEER state by conn...">Client_session_mv</a> counterpart.  <a href="classipc_1_1session_1_1Client__session__impl.html#a45c22f131543ca25adc0cdcb608ddb1f">More...</a><br /></td></tr>
<tr class="separator:a45c22f131543ca25adc0cdcb608ddb1f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae37fe210e9809b4670b49e0d5b727d31"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classipc_1_1session_1_1Client__session__impl.html#a5d391e86ccc1153b4975efdc8e5401e4">Mdt_builder_ptr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classipc_1_1session_1_1Client__session__impl.html#ae37fe210e9809b4670b49e0d5b727d31">mdt_builder</a> () const</td></tr>
<tr class="memdesc:ae37fe210e9809b4670b49e0d5b727d31"><td class="mdescLeft">&#160;</td><td class="mdescRight">See <a class="el" href="classipc_1_1session_1_1Client__session__mv.html" title="Implements Session concept on the Client_app end: a Session_mv that first achieves PEER state by conn...">Client_session_mv</a> counterpart.  <a href="classipc_1_1session_1_1Client__session__impl.html#ae37fe210e9809b4670b49e0d5b727d31">More...</a><br /></td></tr>
<tr class="separator:ae37fe210e9809b4670b49e0d5b727d31"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af03a9fca2006fba2cc522efa1178e83e"><td class="memTemplParams" colspan="2">template&lt;typename Task_err &gt; </td></tr>
<tr class="memitem:af03a9fca2006fba2cc522efa1178e83e"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classipc_1_1session_1_1Client__session__impl.html#af03a9fca2006fba2cc522efa1178e83e">async_connect</a> (Task_err &amp;&amp;on_done_func)</td></tr>
<tr class="memdesc:af03a9fca2006fba2cc522efa1178e83e"><td class="mdescLeft">&#160;</td><td class="mdescRight">See <a class="el" href="classipc_1_1session_1_1Client__session__mv.html" title="Implements Session concept on the Client_app end: a Session_mv that first achieves PEER state by conn...">Client_session_mv</a> counterpart.  <a href="classipc_1_1session_1_1Client__session__impl.html#af03a9fca2006fba2cc522efa1178e83e">More...</a><br /></td></tr>
<tr class="separator:af03a9fca2006fba2cc522efa1178e83e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adebedf1cbe09067a8f785a524e146b2f"><td class="memTemplParams" colspan="2">template&lt;typename Task_err &gt; </td></tr>
<tr class="memitem:adebedf1cbe09067a8f785a524e146b2f"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classipc_1_1session_1_1Client__session__impl.html#adebedf1cbe09067a8f785a524e146b2f">async_connect</a> (const <a class="el" href="classipc_1_1session_1_1Client__session__impl.html#a5d391e86ccc1153b4975efdc8e5401e4">Mdt_builder_ptr</a> &amp;mdt, <a class="el" href="classipc_1_1session_1_1Client__session__impl.html#a48487e4c98ae3a82ef344269742c8057">Channels</a> *init_channels_by_cli_req_pre_sized, <a class="el" href="classipc_1_1session_1_1Client__session__impl.html#a2cc5b77dd2367cc8e821fdcab7f6c109">Mdt_reader_ptr</a> *mdt_from_srv_or_null, <a class="el" href="classipc_1_1session_1_1Client__session__impl.html#a48487e4c98ae3a82ef344269742c8057">Channels</a> *init_channels_by_srv_req, Task_err &amp;&amp;on_done_func)</td></tr>
<tr class="memdesc:adebedf1cbe09067a8f785a524e146b2f"><td class="mdescLeft">&#160;</td><td class="mdescRight">See <a class="el" href="classipc_1_1session_1_1Client__session__mv.html" title="Implements Session concept on the Client_app end: a Session_mv that first achieves PEER state by conn...">Client_session_mv</a> counterpart.  <a href="classipc_1_1session_1_1Client__session__impl.html#adebedf1cbe09067a8f785a524e146b2f">More...</a><br /></td></tr>
<tr class="separator:adebedf1cbe09067a8f785a524e146b2f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4229549db1093aaa1e7e84c6e6467e80"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classipc_1_1session_1_1Client__session__impl.html#a4229549db1093aaa1e7e84c6e6467e80">open_channel</a> (<a class="el" href="classipc_1_1session_1_1Client__session__impl.html#a418a1e70b7b51833cc9d24d1046e3526">Channel_obj</a> *target_channel, const <a class="el" href="classipc_1_1session_1_1Client__session__impl.html#a5d391e86ccc1153b4975efdc8e5401e4">Mdt_builder_ptr</a> &amp;mdt, <a class="el" href="namespaceipc.html#aa3192e586cc45d3e7c22463bf2760f89">Error_code</a> *err_code)</td></tr>
<tr class="memdesc:a4229549db1093aaa1e7e84c6e6467e80"><td class="mdescLeft">&#160;</td><td class="mdescRight">See <a class="el" href="classipc_1_1session_1_1Client__session__mv.html" title="Implements Session concept on the Client_app end: a Session_mv that first achieves PEER state by conn...">Client_session_mv</a> counterpart.  <a href="classipc_1_1session_1_1Client__session__impl.html#a4229549db1093aaa1e7e84c6e6467e80">More...</a><br /></td></tr>
<tr class="separator:a4229549db1093aaa1e7e84c6e6467e80"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7bfdeb2c55e656f8ec9acb147ef14194"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classipc_1_1session_1_1Client__session__impl.html#a7bfdeb2c55e656f8ec9acb147ef14194">open_channel</a> (<a class="el" href="classipc_1_1session_1_1Client__session__impl.html#a418a1e70b7b51833cc9d24d1046e3526">Channel_obj</a> *target_channel, <a class="el" href="namespaceipc.html#aa3192e586cc45d3e7c22463bf2760f89">Error_code</a> *err_code)</td></tr>
<tr class="memdesc:a7bfdeb2c55e656f8ec9acb147ef14194"><td class="mdescLeft">&#160;</td><td class="mdescRight">See <a class="el" href="classipc_1_1session_1_1Client__session__mv.html" title="Implements Session concept on the Client_app end: a Session_mv that first achieves PEER state by conn...">Client_session_mv</a> counterpart.  <a href="classipc_1_1session_1_1Client__session__impl.html#a7bfdeb2c55e656f8ec9acb147ef14194">More...</a><br /></td></tr>
<tr class="separator:a7bfdeb2c55e656f8ec9acb147ef14194"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adf14fe1ec27560741d35cf1d554c4933"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="namespaceipc_1_1session.html#ade2b302f1a3623e8adc9694568d94d2c">Session_token</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classipc_1_1session_1_1Client__session__impl.html#adf14fe1ec27560741d35cf1d554c4933">session_token</a> () const</td></tr>
<tr class="memdesc:adf14fe1ec27560741d35cf1d554c4933"><td class="mdescLeft">&#160;</td><td class="mdescRight">See <a class="el" href="classipc_1_1session_1_1Client__session__mv.html" title="Implements Session concept on the Client_app end: a Session_mv that first achieves PEER state by conn...">Client_session_mv</a> counterpart.  <a href="classipc_1_1session_1_1Client__session__impl.html#adf14fe1ec27560741d35cf1d554c4933">More...</a><br /></td></tr>
<tr class="separator:adf14fe1ec27560741d35cf1d554c4933"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pub_methods_classipc_1_1session_1_1Session__base"><td colspan="2" onclick="javascript:toggleInherit('pub_methods_classipc_1_1session_1_1Session__base')"><img src="closed.png" alt="-"/>&#160;Public Member Functions inherited from <a class="el" href="classipc_1_1session_1_1Session__base.html">ipc::session::Session_base&lt; S_MQ_TYPE_OR_NONE, S_TRANSMIT_NATIVE_HANDLES, Mdt_payload &gt;</a></td></tr>
<tr class="memitem:a4d1327608d6067ed6690bd4efa323c6f inherit pub_methods_classipc_1_1session_1_1Session__base"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="namespaceipc_1_1session.html#a6d07d9996af19e57eb42416e914110ea">Shared_name</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classipc_1_1session_1_1Session__base.html#a4d1327608d6067ed6690bd4efa323c6f">srv_namespace</a> () const</td></tr>
<tr class="memdesc:a4d1327608d6067ed6690bd4efa323c6f inherit pub_methods_classipc_1_1session_1_1Session__base"><td class="mdescLeft">&#160;</td><td class="mdescRight">See <a class="el" href="classipc_1_1session_1_1Server__session__impl.html" title="Internal, non-movable pImpl-lite implementation of Server_session_mv class template.">Server_session_impl</a>, <a class="el" href="classipc_1_1session_1_1Client__session__impl.html" title="Internal, non-movable pImpl-lite implementation of Client_session_mv class template.">Client_session_impl</a>.  <a href="classipc_1_1session_1_1Session__base.html#a4d1327608d6067ed6690bd4efa323c6f">More...</a><br /></td></tr>
<tr class="separator:a4d1327608d6067ed6690bd4efa323c6f inherit pub_methods_classipc_1_1session_1_1Session__base"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abd1e814b3b640f4bdaa2553352405f26 inherit pub_methods_classipc_1_1session_1_1Session__base"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="namespaceipc_1_1session.html#a6d07d9996af19e57eb42416e914110ea">Shared_name</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classipc_1_1session_1_1Session__base.html#abd1e814b3b640f4bdaa2553352405f26">cli_namespace</a> () const</td></tr>
<tr class="memdesc:abd1e814b3b640f4bdaa2553352405f26 inherit pub_methods_classipc_1_1session_1_1Session__base"><td class="mdescLeft">&#160;</td><td class="mdescRight">See <a class="el" href="classipc_1_1session_1_1Server__session__impl.html" title="Internal, non-movable pImpl-lite implementation of Server_session_mv class template.">Server_session_impl</a>, <a class="el" href="classipc_1_1session_1_1Client__session__impl.html" title="Internal, non-movable pImpl-lite implementation of Client_session_mv class template.">Client_session_impl</a>.  <a href="classipc_1_1session_1_1Session__base.html#abd1e814b3b640f4bdaa2553352405f26">More...</a><br /></td></tr>
<tr class="separator:abd1e814b3b640f4bdaa2553352405f26 inherit pub_methods_classipc_1_1session_1_1Session__base"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3ebdafe7e70719e6d12dd0b15ae85106 inherit pub_methods_classipc_1_1session_1_1Session__base"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="structipc_1_1session_1_1Client__app.html">Client_app</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classipc_1_1session_1_1Session__base.html#a3ebdafe7e70719e6d12dd0b15ae85106">cli_app_ptr</a> () const</td></tr>
<tr class="memdesc:a3ebdafe7e70719e6d12dd0b15ae85106 inherit pub_methods_classipc_1_1session_1_1Session__base"><td class="mdescLeft">&#160;</td><td class="mdescRight">See <a class="el" href="classipc_1_1session_1_1Server__session__impl.html" title="Internal, non-movable pImpl-lite implementation of Server_session_mv class template.">Server_session_impl</a>, <a class="el" href="classipc_1_1session_1_1Client__session__impl.html" title="Internal, non-movable pImpl-lite implementation of Client_session_mv class template.">Client_session_impl</a>.  <a href="classipc_1_1session_1_1Session__base.html#a3ebdafe7e70719e6d12dd0b15ae85106">More...</a><br /></td></tr>
<tr class="separator:a3ebdafe7e70719e6d12dd0b15ae85106 inherit pub_methods_classipc_1_1session_1_1Session__base"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a09cbe99083616bae00928f8e37c8373b inherit pub_methods_classipc_1_1session_1_1Session__base"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespaceipc_1_1session.html#a6d07d9996af19e57eb42416e914110ea">Shared_name</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classipc_1_1session_1_1Session__base.html#a09cbe99083616bae00928f8e37c8373b">cur_ns_store_mutex_absolute_name</a> () const</td></tr>
<tr class="memdesc:a09cbe99083616bae00928f8e37c8373b inherit pub_methods_classipc_1_1session_1_1Session__base"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the name of the interprocess named-mutex used to control reading/writing to the file storing (written by server, read by client) the value for <a class="el" href="classipc_1_1session_1_1Session__base.html#a4d1327608d6067ed6690bd4efa323c6f" title="See Server_session_impl, Client_session_impl.">srv_namespace()</a>.  <a href="classipc_1_1session_1_1Session__base.html#a09cbe99083616bae00928f8e37c8373b">More...</a><br /></td></tr>
<tr class="separator:a09cbe99083616bae00928f8e37c8373b inherit pub_methods_classipc_1_1session_1_1Session__base"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af059faab56cdf384873f9f2aba8f79cf inherit pub_methods_classipc_1_1session_1_1Session__base"><td class="memItemLeft" align="right" valign="top">fs::path&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classipc_1_1session_1_1Session__base.html#af059faab56cdf384873f9f2aba8f79cf">cur_ns_store_absolute_path</a> () const</td></tr>
<tr class="memdesc:af059faab56cdf384873f9f2aba8f79cf inherit pub_methods_classipc_1_1session_1_1Session__base"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the absolute path to file storing (written by server, read by client) the value for <a class="el" href="classipc_1_1session_1_1Session__base.html#a4d1327608d6067ed6690bd4efa323c6f" title="See Server_session_impl, Client_session_impl.">srv_namespace()</a>.  <a href="classipc_1_1session_1_1Session__base.html#af059faab56cdf384873f9f2aba8f79cf">More...</a><br /></td></tr>
<tr class="separator:af059faab56cdf384873f9f2aba8f79cf inherit pub_methods_classipc_1_1session_1_1Session__base"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3d34c5a9c283a6b7c8ab943f344cdd28 inherit pub_methods_classipc_1_1session_1_1Session__base"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespaceipc_1_1session.html#a6d07d9996af19e57eb42416e914110ea">Shared_name</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classipc_1_1session_1_1Session__base.html#a3d34c5a9c283a6b7c8ab943f344cdd28">session_master_socket_stream_acceptor_absolute_name</a> () const</td></tr>
<tr class="memdesc:a3d34c5a9c283a6b7c8ab943f344cdd28 inherit pub_methods_classipc_1_1session_1_1Session__base"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the absolute name at which the server shall set up a <a class="el" href="classipc_1_1transport_1_1Native__socket__stream__acceptor.html" title="A server object that binds to a Shared_name and listens for incoming Native_socket_stream::*_connect(...">transport::Native_socket_stream_acceptor</a> to which client shall <a class="el" href="classipc_1_1transport_1_1Native__socket__stream.html#a3614a9677c1a203090b97ac935093390" title="To be invoked in NULL state only, it asynchronously attempts to connect to an opposing Native_socket_...">transport::Native_socket_stream::async_connect()</a> in order to establish a PEER-state session.  <a href="classipc_1_1session_1_1Session__base.html#a3d34c5a9c283a6b7c8ab943f344cdd28">More...</a><br /></td></tr>
<tr class="separator:a3d34c5a9c283a6b7c8ab943f344cdd28 inherit pub_methods_classipc_1_1session_1_1Session__base"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-static-attribs" name="pub-static-attribs"></a>
Static Public Attributes</h2></td></tr>
<tr class="memitem:aeb8590957bbc0dfac64fec8a703985ae"><td class="memItemLeft" align="right" valign="top">static constexpr schema::ShmType&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classipc_1_1session_1_1Client__session__impl.html#aeb8590957bbc0dfac64fec8a703985ae">S_SHM_TYPE</a> = S_SHM_TYPE_OR_NONE</td></tr>
<tr class="memdesc:aeb8590957bbc0dfac64fec8a703985ae"><td class="mdescLeft">&#160;</td><td class="mdescRight">See <a class="el" href="classipc_1_1session_1_1Session__mv.html" title="Implements the Session concept when it is in PEER state.">Session_mv</a> counterpart.  <a href="classipc_1_1session_1_1Client__session__impl.html#aeb8590957bbc0dfac64fec8a703985ae">More...</a><br /></td></tr>
<tr class="separator:aeb8590957bbc0dfac64fec8a703985ae"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afd118867d8628d18363f877dea8d601a"><td class="memItemLeft" align="right" valign="top">static constexpr bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classipc_1_1session_1_1Client__session__impl.html#afd118867d8628d18363f877dea8d601a">S_SHM_ENABLED</a> = <a class="el" href="classipc_1_1session_1_1Client__session__impl.html#aeb8590957bbc0dfac64fec8a703985ae">S_SHM_TYPE</a> != schema::ShmType::NONE</td></tr>
<tr class="memdesc:afd118867d8628d18363f877dea8d601a"><td class="mdescLeft">&#160;</td><td class="mdescRight">See <a class="el" href="classipc_1_1session_1_1Session__mv.html" title="Implements the Session concept when it is in PEER state.">Session_mv</a> counterpart.  <a href="classipc_1_1session_1_1Client__session__impl.html#afd118867d8628d18363f877dea8d601a">More...</a><br /></td></tr>
<tr class="separator:afd118867d8628d18363f877dea8d601a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3541a8e1f4192c3fd6647827507440dd"><td class="memItemLeft" align="right" valign="top">static constexpr bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classipc_1_1session_1_1Client__session__impl.html#a3541a8e1f4192c3fd6647827507440dd">S_MQS_ENABLED</a> = Base::S_MQS_ENABLED</td></tr>
<tr class="memdesc:a3541a8e1f4192c3fd6647827507440dd"><td class="mdescLeft">&#160;</td><td class="mdescRight">See <a class="el" href="classipc_1_1session_1_1Client__session__mv.html" title="Implements Session concept on the Client_app end: a Session_mv that first achieves PEER state by conn...">Client_session_mv</a> counterpart.  <a href="classipc_1_1session_1_1Client__session__impl.html#a3541a8e1f4192c3fd6647827507440dd">More...</a><br /></td></tr>
<tr class="separator:a3541a8e1f4192c3fd6647827507440dd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a921264bb66a3c1c2da679399f0bd59aa"><td class="memItemLeft" align="right" valign="top">static constexpr bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classipc_1_1session_1_1Client__session__impl.html#a921264bb66a3c1c2da679399f0bd59aa">S_SOCKET_STREAM_ENABLED</a> = Base::S_SOCKET_STREAM_ENABLED</td></tr>
<tr class="memdesc:a921264bb66a3c1c2da679399f0bd59aa"><td class="mdescLeft">&#160;</td><td class="mdescRight">See <a class="el" href="classipc_1_1session_1_1Client__session__mv.html" title="Implements Session concept on the Client_app end: a Session_mv that first achieves PEER state by conn...">Client_session_mv</a> counterpart.  <a href="classipc_1_1session_1_1Client__session__impl.html#a921264bb66a3c1c2da679399f0bd59aa">More...</a><br /></td></tr>
<tr class="separator:a921264bb66a3c1c2da679399f0bd59aa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pub_static_attribs_classipc_1_1session_1_1Session__base"><td colspan="2" onclick="javascript:toggleInherit('pub_static_attribs_classipc_1_1session_1_1Session__base')"><img src="closed.png" alt="-"/>&#160;Static Public Attributes inherited from <a class="el" href="classipc_1_1session_1_1Session__base.html">ipc::session::Session_base&lt; S_MQ_TYPE_OR_NONE, S_TRANSMIT_NATIVE_HANDLES, Mdt_payload &gt;</a></td></tr>
<tr class="memitem:a27a5731a648effb6b4b42f0312affa74 inherit pub_static_attribs_classipc_1_1session_1_1Session__base"><td class="memItemLeft" align="right" valign="top">static constexpr bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classipc_1_1session_1_1Session__base.html#a27a5731a648effb6b4b42f0312affa74">S_MQS_ENABLED</a> = S_MQ_TYPE_OR_NONE != schema::MqType::NONE</td></tr>
<tr class="memdesc:a27a5731a648effb6b4b42f0312affa74 inherit pub_static_attribs_classipc_1_1session_1_1Session__base"><td class="mdescLeft">&#160;</td><td class="mdescRight">See <a class="el" href="classipc_1_1session_1_1Session__mv.html" title="Implements the Session concept when it is in PEER state.">Session_mv</a>.  <a href="classipc_1_1session_1_1Session__base.html#a27a5731a648effb6b4b42f0312affa74">More...</a><br /></td></tr>
<tr class="separator:a27a5731a648effb6b4b42f0312affa74 inherit pub_static_attribs_classipc_1_1session_1_1Session__base"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1f7c4243c8bd55930f51a568884c8aaf inherit pub_static_attribs_classipc_1_1session_1_1Session__base"><td class="memItemLeft" align="right" valign="top">static constexpr bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classipc_1_1session_1_1Session__base.html#a1f7c4243c8bd55930f51a568884c8aaf">S_SOCKET_STREAM_ENABLED</a> = (!<a class="el" href="classipc_1_1session_1_1Session__base.html#a27a5731a648effb6b4b42f0312affa74">S_MQS_ENABLED</a>) || S_TRANSMIT_NATIVE_HANDLES</td></tr>
<tr class="memdesc:a1f7c4243c8bd55930f51a568884c8aaf inherit pub_static_attribs_classipc_1_1session_1_1Session__base"><td class="mdescLeft">&#160;</td><td class="mdescRight">See <a class="el" href="classipc_1_1session_1_1Session__mv.html" title="Implements the Session concept when it is in PEER state.">Session_mv</a>.  <a href="classipc_1_1session_1_1Session__base.html#a1f7c4243c8bd55930f51a568884c8aaf">More...</a><br /></td></tr>
<tr class="separator:a1f7c4243c8bd55930f51a568884c8aaf inherit pub_static_attribs_classipc_1_1session_1_1Session__base"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pro-types" name="pro-types"></a>
Protected Types</h2></td></tr>
<tr class="memitem:adf598b765af3aa2fe0a2f3ead176477b"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classipc_1_1session_1_1Client__session__impl.html#adf598b765af3aa2fe0a2f3ead176477b">Master_structured_channel</a> = typename <a class="el" href="classipc_1_1session_1_1Session__base.html#a26d038e14e3c0e461e76de88c4ce76c5">Base::Master_structured_channel</a></td></tr>
<tr class="memdesc:adf598b765af3aa2fe0a2f3ead176477b"><td class="mdescLeft">&#160;</td><td class="mdescRight">See <a class="el" href="classipc_1_1session_1_1Session__base.html" title="Internal type containing data and types common to internal types Server_session_impl and Client_sessi...">Session_base</a>.  <a href="classipc_1_1session_1_1Client__session__impl.html#adf598b765af3aa2fe0a2f3ead176477b">More...</a><br /></td></tr>
<tr class="separator:adf598b765af3aa2fe0a2f3ead176477b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pro_types_classipc_1_1session_1_1Session__base"><td colspan="2" onclick="javascript:toggleInherit('pro_types_classipc_1_1session_1_1Session__base')"><img src="closed.png" alt="-"/>&#160;Protected Types inherited from <a class="el" href="classipc_1_1session_1_1Session__base.html">ipc::session::Session_base&lt; S_MQ_TYPE_OR_NONE, S_TRANSMIT_NATIVE_HANDLES, Mdt_payload &gt;</a></td></tr>
<tr class="memitem:a26d038e14e3c0e461e76de88c4ce76c5 inherit pro_types_classipc_1_1session_1_1Session__base"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classipc_1_1session_1_1Session__base.html#a26d038e14e3c0e461e76de88c4ce76c5">Master_structured_channel</a> = <a class="el" href="namespaceipc_1_1transport_1_1struc.html#aca041b0efd4a9ae18e10088b2ee3c052">transport::struc::Channel_via_heap</a>&lt; <a class="el" href="classipc_1_1transport_1_1Socket__stream__channel.html">transport::Socket_stream_channel</a>&lt; true &gt;, schema::detail::SessionMasterChannelMessageBody&lt; <a class="el" href="classipc_1_1session_1_1Session__base.html#a35234981ca87cc2f6b118b3e52452ea8">Mdt_payload_obj</a> &gt; &gt;</td></tr>
<tr class="memdesc:a26d038e14e3c0e461e76de88c4ce76c5 inherit pro_types_classipc_1_1session_1_1Session__base"><td class="mdescLeft">&#160;</td><td class="mdescRight">The (internally used) session master channel is a <a class="el" href="classipc_1_1transport_1_1struc_1_1Channel.html" title="Owning and wrapping a pre-connected transport::Channel peer (an endpoint of an established channel ov...">transport::struc::Channel</a> of this concrete type.  <a href="classipc_1_1session_1_1Session__base.html#a26d038e14e3c0e461e76de88c4ce76c5">More...</a><br /></td></tr>
<tr class="separator:a26d038e14e3c0e461e76de88c4ce76c5 inherit pro_types_classipc_1_1session_1_1Session__base"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af0ca2a01d7d0d92038aae56fc1cdd505 inherit pro_types_classipc_1_1session_1_1Session__base"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classipc_1_1session_1_1Session__base.html#af0ca2a01d7d0d92038aae56fc1cdd505">Master_structured_channel_ptr</a> = boost::shared_ptr&lt; <a class="el" href="classipc_1_1session_1_1Session__base.html#a26d038e14e3c0e461e76de88c4ce76c5">Master_structured_channel</a> &gt;</td></tr>
<tr class="memdesc:af0ca2a01d7d0d92038aae56fc1cdd505 inherit pro_types_classipc_1_1session_1_1Session__base"><td class="mdescLeft">&#160;</td><td class="mdescRight">Handle to <a class="el" href="classipc_1_1session_1_1Session__base.html#a26d038e14e3c0e461e76de88c4ce76c5" title="The (internally used) session master channel is a transport::struc::Channel of this concrete type.">Master_structured_channel</a>.  <a href="classipc_1_1session_1_1Session__base.html#af0ca2a01d7d0d92038aae56fc1cdd505">More...</a><br /></td></tr>
<tr class="separator:af0ca2a01d7d0d92038aae56fc1cdd505 inherit pro_types_classipc_1_1session_1_1Session__base"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae2a123b29dd044a638e94d1f294c8f28 inherit pro_types_classipc_1_1session_1_1Session__base"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classipc_1_1session_1_1Session__base.html#ae2a123b29dd044a638e94d1f294c8f28">Master_structured_channel_observer</a> = boost::weak_ptr&lt; <a class="el" href="classipc_1_1session_1_1Session__base.html#a26d038e14e3c0e461e76de88c4ce76c5">Master_structured_channel</a> &gt;</td></tr>
<tr class="memdesc:ae2a123b29dd044a638e94d1f294c8f28 inherit pro_types_classipc_1_1session_1_1Session__base"><td class="mdescLeft">&#160;</td><td class="mdescRight">Observer of <a class="el" href="classipc_1_1session_1_1Session__base.html#af0ca2a01d7d0d92038aae56fc1cdd505" title="Handle to Master_structured_channel.">Master_structured_channel_ptr</a>. See its doc header.  <a href="classipc_1_1session_1_1Session__base.html#ae2a123b29dd044a638e94d1f294c8f28">More...</a><br /></td></tr>
<tr class="separator:ae2a123b29dd044a638e94d1f294c8f28 inherit pro_types_classipc_1_1session_1_1Session__base"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3c0824a54ef32915c5c5ea76481f2409 inherit pro_types_classipc_1_1session_1_1Session__base"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classipc_1_1session_1_1Session__base.html#a3c0824a54ef32915c5c5ea76481f2409">On_passive_open_channel_func</a> = <a class="el" href="namespaceipc.html#aa455c7f045059736578ca275fc1a851f">Function</a>&lt; void(<a class="el" href="classipc_1_1session_1_1Session__base.html#a71f02a809d667c23ff8af29a96940bd1">Channel_obj</a> &amp;&amp;new_channel, <a class="el" href="classipc_1_1session_1_1Session__base.html#ace4dab42adec6354cc66081dd218ac71">Mdt_reader_ptr</a> &amp;&amp;new_channel_mdt)&gt;</td></tr>
<tr class="memdesc:a3c0824a54ef32915c5c5ea76481f2409 inherit pro_types_classipc_1_1session_1_1Session__base"><td class="mdescLeft">&#160;</td><td class="mdescRight">Concrete function type for the on-passive-open handler (if any), used for storage.  <a href="classipc_1_1session_1_1Session__base.html#a3c0824a54ef32915c5c5ea76481f2409">More...</a><br /></td></tr>
<tr class="separator:a3c0824a54ef32915c5c5ea76481f2409 inherit pro_types_classipc_1_1session_1_1Session__base"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pro-methods" name="pro-methods"></a>
Protected Member Functions</h2></td></tr>
<tr class="memitem:ad84c75d7233fcaaab287ed405a267df2"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classipc_1_1session_1_1Client__session__impl.html#ad84c75d7233fcaaab287ed405a267df2">cancel_peer_state_to_null</a> ()</td></tr>
<tr class="memdesc:ad84c75d7233fcaaab287ed405a267df2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Utility for sub-classes: executed from <a class="el" href="classipc_1_1session_1_1Client__session__impl.html#af03a9fca2006fba2cc522efa1178e83e" title="See Client_session_mv counterpart.">async_connect()</a>'s <code>on_done_func(Error_code())</code> (i.e., directly from handler invoked on success) &ndash; hence from thread W &ndash; this instead goes back to NULL state, essentially indicating "never mind -- this successful async_connect() actually failed.".  <a href="classipc_1_1session_1_1Client__session__impl.html#ad84c75d7233fcaaab287ed405a267df2">More...</a><br /></td></tr>
<tr class="separator:ad84c75d7233fcaaab287ed405a267df2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:addcd3cf7a3c21221bf032686782feb03"><td class="memTemplParams" colspan="2">template&lt;typename Task_err &gt; </td></tr>
<tr class="memitem:addcd3cf7a3c21221bf032686782feb03"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classipc_1_1session_1_1Client__session__impl.html#adf598b765af3aa2fe0a2f3ead176477b">Master_structured_channel</a> *&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classipc_1_1session_1_1Client__session__impl.html#addcd3cf7a3c21221bf032686782feb03">cancel_peer_state_to_connecting</a> (Task_err &amp;&amp;on_done_func)</td></tr>
<tr class="memdesc:addcd3cf7a3c21221bf032686782feb03"><td class="mdescLeft">&#160;</td><td class="mdescRight">Utility for sub-classes: executed from <a class="el" href="classipc_1_1session_1_1Client__session__impl.html#af03a9fca2006fba2cc522efa1178e83e" title="See Client_session_mv counterpart.">async_connect()</a>'s <code>on_done_func(Error_code())</code> (i.e., directly from handler invoked on success) &ndash; hence from thread W &ndash; this instead goes back to CONNECTING state, essentially indicating "yes, the vanilla <a class="el" href="classipc_1_1session_1_1Client__session__impl.html#af03a9fca2006fba2cc522efa1178e83e" title="See Client_session_mv counterpart.">async_connect()</a> succeeded, but the true user-called <a class="el" href="classipc_1_1session_1_1Client__session__impl.html#af03a9fca2006fba2cc522efa1178e83e" title="See Client_session_mv counterpart.">async_connect()</a> that piggybacked on the vanilla one will now do some more async stuff before reaching PEER state (or NULL on error).  <a href="classipc_1_1session_1_1Client__session__impl.html#addcd3cf7a3c21221bf032686782feb03">More...</a><br /></td></tr>
<tr class="separator:addcd3cf7a3c21221bf032686782feb03"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2e871ae9e633e48bc02dd62600722c15"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classipc_1_1session_1_1Client__session__impl.html#a2e871ae9e633e48bc02dd62600722c15">complete_async_connect_after_canceling_peer_state</a> (const <a class="el" href="namespaceipc.html#aa3192e586cc45d3e7c22463bf2760f89">Error_code</a> &amp;err_code_or_success)</td></tr>
<tr class="memdesc:a2e871ae9e633e48bc02dd62600722c15"><td class="mdescLeft">&#160;</td><td class="mdescRight">Utility for sub-classes: to be invoked, only from thread W and asynchronously at that, after <a class="el" href="classipc_1_1session_1_1Client__session__impl.html#addcd3cf7a3c21221bf032686782feb03" title="Utility for sub-classes: executed from async_connect()&#39;s on_done_func(Error_code()) (i....">cancel_peer_state_to_connecting()</a>, this indicates the completion of the sub-class's additional async-connect steps, setting state to either NULL or PEER.  <a href="classipc_1_1session_1_1Client__session__impl.html#a2e871ae9e633e48bc02dd62600722c15">More...</a><br /></td></tr>
<tr class="separator:a2e871ae9e633e48bc02dd62600722c15"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a01deaa0719df7e73e205dd1bfba35abf"><td class="memItemLeft" align="right" valign="top">flow::async::Single_thread_task_loop *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classipc_1_1session_1_1Client__session__impl.html#a01deaa0719df7e73e205dd1bfba35abf">async_worker</a> ()</td></tr>
<tr class="memdesc:a01deaa0719df7e73e205dd1bfba35abf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Utility for sub-classes: provides ability to schedule or post tasks onto thread W.  <a href="classipc_1_1session_1_1Client__session__impl.html#a01deaa0719df7e73e205dd1bfba35abf">More...</a><br /></td></tr>
<tr class="separator:a01deaa0719df7e73e205dd1bfba35abf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae2780708c51943c873d7054fcd91c451"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classipc_1_1session_1_1Client__session__impl.html#adf598b765af3aa2fe0a2f3ead176477b">Master_structured_channel</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classipc_1_1session_1_1Client__session__impl.html#ae2780708c51943c873d7054fcd91c451">master_channel_const</a> () const</td></tr>
<tr class="memdesc:ae2780708c51943c873d7054fcd91c451"><td class="mdescLeft">&#160;</td><td class="mdescRight">Utility for sub-classes: provides ability to <em>immutably query</em> the session master channel, particularly after our async_accept_log_in() succeeds, but before the sub-classed wrapper of its on-done handler succeeds.  <a href="classipc_1_1session_1_1Client__session__impl.html#ae2780708c51943c873d7054fcd91c451">More...</a><br /></td></tr>
<tr class="separator:ae2780708c51943c873d7054fcd91c451"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad6e279dc528e995d735611fedc26b347"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classipc_1_1session_1_1Client__session__impl.html#ad6e279dc528e995d735611fedc26b347">dtor_async_worker_stop</a> ()</td></tr>
<tr class="memdesc:ad6e279dc528e995d735611fedc26b347"><td class="mdescLeft">&#160;</td><td class="mdescRight">Synchronously stops <a class="el" href="classipc_1_1session_1_1Client__session__impl.html#a01deaa0719df7e73e205dd1bfba35abf" title="Utility for sub-classes: provides ability to schedule or post tasks onto thread W.">async_worker()</a> loop, the post-condition being that thread W has been joined; no tasks <code>post()</code>ed onto it by <code>*this</code> or subclass shall execute after this returns.  <a href="classipc_1_1session_1_1Client__session__impl.html#ad6e279dc528e995d735611fedc26b347">More...</a><br /></td></tr>
<tr class="separator:ad6e279dc528e995d735611fedc26b347"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pro_methods_classipc_1_1session_1_1Session__base"><td colspan="2" onclick="javascript:toggleInherit('pro_methods_classipc_1_1session_1_1Session__base')"><img src="closed.png" alt="-"/>&#160;Protected Member Functions inherited from <a class="el" href="classipc_1_1session_1_1Session__base.html">ipc::session::Session_base&lt; S_MQ_TYPE_OR_NONE, S_TRANSMIT_NATIVE_HANDLES, Mdt_payload &gt;</a></td></tr>
<tr class="memitem:aab2db8b2cdb3d8189c1cc497aed7b2b1 inherit pro_methods_classipc_1_1session_1_1Session__base"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classipc_1_1session_1_1Session__base.html#aab2db8b2cdb3d8189c1cc497aed7b2b1">Session_base</a> (const <a class="el" href="structipc_1_1session_1_1Client__app.html">Client_app</a> &amp;cli_app_ref, const <a class="el" href="structipc_1_1session_1_1Server__app.html">Server_app</a> &amp;srv_app_ref, flow::async::Task_asio_err &amp;&amp;on_err_func, <a class="el" href="classipc_1_1session_1_1Session__base.html#a3c0824a54ef32915c5c5ea76481f2409">On_passive_open_channel_func</a> &amp;&amp;on_passive_open_channel_func_or_empty_arg)</td></tr>
<tr class="memdesc:aab2db8b2cdb3d8189c1cc497aed7b2b1 inherit pro_methods_classipc_1_1session_1_1Session__base"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructs: Client_session form (the user is the one constructing the object, though in NULL state).  <a href="classipc_1_1session_1_1Session__base.html#aab2db8b2cdb3d8189c1cc497aed7b2b1">More...</a><br /></td></tr>
<tr class="separator:aab2db8b2cdb3d8189c1cc497aed7b2b1 inherit pro_methods_classipc_1_1session_1_1Session__base"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8d323ca75006777b3fc929bd0720f7df inherit pro_methods_classipc_1_1session_1_1Session__base"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classipc_1_1session_1_1Session__base.html#a8d323ca75006777b3fc929bd0720f7df">Session_base</a> (const <a class="el" href="structipc_1_1session_1_1Server__app.html">Server_app</a> &amp;srv_app_ref)</td></tr>
<tr class="memdesc:a8d323ca75006777b3fc929bd0720f7df inherit pro_methods_classipc_1_1session_1_1Session__base"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructs: Server_session form (<a class="el" href="classipc_1_1session_1_1Session__server.html" title="To be instantiated typically once in a given process, an object of this type asynchronously listens f...">Session_server</a> is the one constructing the object, though in NULL state, before log-in has completed, but after the socket-stream connection has been established).  <a href="classipc_1_1session_1_1Session__base.html#a8d323ca75006777b3fc929bd0720f7df">More...</a><br /></td></tr>
<tr class="separator:a8d323ca75006777b3fc929bd0720f7df inherit pro_methods_classipc_1_1session_1_1Session__base"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a28825fcdeaf1249a7bf810a3b2ca7c38 inherit pro_methods_classipc_1_1session_1_1Session__base"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classipc_1_1session_1_1Session__base.html#a28825fcdeaf1249a7bf810a3b2ca7c38">set_srv_namespace</a> (<a class="el" href="namespaceipc_1_1session.html#a6d07d9996af19e57eb42416e914110ea">Shared_name</a> &amp;&amp;srv_namespace_new)</td></tr>
<tr class="memdesc:a28825fcdeaf1249a7bf810a3b2ca7c38 inherit pro_methods_classipc_1_1session_1_1Session__base"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets <a class="el" href="classipc_1_1session_1_1Session__base.html#a4d1327608d6067ed6690bd4efa323c6f" title="See Server_session_impl, Client_session_impl.">srv_namespace()</a> (do not call if already set).  <a href="classipc_1_1session_1_1Session__base.html#a28825fcdeaf1249a7bf810a3b2ca7c38">More...</a><br /></td></tr>
<tr class="separator:a28825fcdeaf1249a7bf810a3b2ca7c38 inherit pro_methods_classipc_1_1session_1_1Session__base"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8cc7a4faa098e0f71c737f44c34d593c inherit pro_methods_classipc_1_1session_1_1Session__base"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classipc_1_1session_1_1Session__base.html#a8cc7a4faa098e0f71c737f44c34d593c">set_cli_namespace</a> (<a class="el" href="namespaceipc_1_1session.html#a6d07d9996af19e57eb42416e914110ea">Shared_name</a> &amp;&amp;cli_namespace_new)</td></tr>
<tr class="memdesc:a8cc7a4faa098e0f71c737f44c34d593c inherit pro_methods_classipc_1_1session_1_1Session__base"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets <a class="el" href="classipc_1_1session_1_1Session__base.html#abd1e814b3b640f4bdaa2553352405f26" title="See Server_session_impl, Client_session_impl.">cli_namespace()</a> (do not call if already set).  <a href="classipc_1_1session_1_1Session__base.html#a8cc7a4faa098e0f71c737f44c34d593c">More...</a><br /></td></tr>
<tr class="separator:a8cc7a4faa098e0f71c737f44c34d593c inherit pro_methods_classipc_1_1session_1_1Session__base"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a60a081ce0f85651202d23b4d543d093c inherit pro_methods_classipc_1_1session_1_1Session__base"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classipc_1_1session_1_1Session__base.html#a60a081ce0f85651202d23b4d543d093c">set_cli_app_ptr</a> (const <a class="el" href="structipc_1_1session_1_1Client__app.html">Client_app</a> *cli_app_ptr_new)</td></tr>
<tr class="memdesc:a60a081ce0f85651202d23b4d543d093c inherit pro_methods_classipc_1_1session_1_1Session__base"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets <a class="el" href="classipc_1_1session_1_1Session__base.html#a3ebdafe7e70719e6d12dd0b15ae85106" title="See Server_session_impl, Client_session_impl.">cli_app_ptr()</a> (do not call if already set).  <a href="classipc_1_1session_1_1Session__base.html#a60a081ce0f85651202d23b4d543d093c">More...</a><br /></td></tr>
<tr class="separator:a60a081ce0f85651202d23b4d543d093c inherit pro_methods_classipc_1_1session_1_1Session__base"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3be1a385c905404621b58c23332b0b96 inherit pro_methods_classipc_1_1session_1_1Session__base"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classipc_1_1session_1_1Session__base.html#a3be1a385c905404621b58c23332b0b96">set_on_passive_open_channel_func</a> (<a class="el" href="classipc_1_1session_1_1Session__base.html#a3c0824a54ef32915c5c5ea76481f2409">On_passive_open_channel_func</a> &amp;&amp;on_passive_open_channel_func)</td></tr>
<tr class="memdesc:a3be1a385c905404621b58c23332b0b96 inherit pro_methods_classipc_1_1session_1_1Session__base"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets <a class="el" href="classipc_1_1session_1_1Session__base.html#a21b146b02d257d95f4aaeaca12b8d320" title="The on-passive-open handler (may be empty even in final state, meaning user wants passive-opens disab...">on_passive_open_channel_func_or_empty()</a> (do not call if already set; do not call if user intends for passive-opens to be disabled on this side).  <a href="classipc_1_1session_1_1Session__base.html#a3be1a385c905404621b58c23332b0b96">More...</a><br /></td></tr>
<tr class="separator:a3be1a385c905404621b58c23332b0b96 inherit pro_methods_classipc_1_1session_1_1Session__base"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae769a82bdec0d16702111ad06716faae inherit pro_methods_classipc_1_1session_1_1Session__base"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classipc_1_1session_1_1Session__base.html#ae769a82bdec0d16702111ad06716faae">set_on_err_func</a> (flow::async::Task_asio_err &amp;&amp;on_err_func_arg)</td></tr>
<tr class="memdesc:ae769a82bdec0d16702111ad06716faae inherit pro_methods_classipc_1_1session_1_1Session__base"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets on_err_func() (do not call if already set).  <a href="classipc_1_1session_1_1Session__base.html#ae769a82bdec0d16702111ad06716faae">More...</a><br /></td></tr>
<tr class="separator:ae769a82bdec0d16702111ad06716faae inherit pro_methods_classipc_1_1session_1_1Session__base"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aca82817beaac36d0006c44012f9fef03 inherit pro_methods_classipc_1_1session_1_1Session__base"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classipc_1_1session_1_1Session__base.html#aca82817beaac36d0006c44012f9fef03">on_err_func_set</a> () const</td></tr>
<tr class="memdesc:aca82817beaac36d0006c44012f9fef03 inherit pro_methods_classipc_1_1session_1_1Session__base"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns <code>true</code> if and only if <a class="el" href="classipc_1_1session_1_1Session__base.html#ae769a82bdec0d16702111ad06716faae" title="Sets on_err_func() (do not call if already set).">set_on_err_func()</a> has been called, or .  <a href="classipc_1_1session_1_1Session__base.html#aca82817beaac36d0006c44012f9fef03">More...</a><br /></td></tr>
<tr class="separator:aca82817beaac36d0006c44012f9fef03 inherit pro_methods_classipc_1_1session_1_1Session__base"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a21b146b02d257d95f4aaeaca12b8d320 inherit pro_methods_classipc_1_1session_1_1Session__base"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classipc_1_1session_1_1Session__base.html#a3c0824a54ef32915c5c5ea76481f2409">On_passive_open_channel_func</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classipc_1_1session_1_1Session__base.html#a21b146b02d257d95f4aaeaca12b8d320">on_passive_open_channel_func_or_empty</a> () const</td></tr>
<tr class="memdesc:a21b146b02d257d95f4aaeaca12b8d320 inherit pro_methods_classipc_1_1session_1_1Session__base"><td class="mdescLeft">&#160;</td><td class="mdescRight">The on-passive-open handler (may be empty even in final state, meaning user wants passive-opens disabled on this side).  <a href="classipc_1_1session_1_1Session__base.html#a21b146b02d257d95f4aaeaca12b8d320">More...</a><br /></td></tr>
<tr class="separator:a21b146b02d257d95f4aaeaca12b8d320 inherit pro_methods_classipc_1_1session_1_1Session__base"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7f9e67dccbab4f3191734c2834bafb63 inherit pro_methods_classipc_1_1session_1_1Session__base"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classipc_1_1session_1_1Session__base.html#a7f9e67dccbab4f3191734c2834bafb63">hose</a> (const <a class="el" href="namespaceipc.html#aa3192e586cc45d3e7c22463bf2760f89">Error_code</a> &amp;err_code)</td></tr>
<tr class="memdesc:a7f9e67dccbab4f3191734c2834bafb63 inherit pro_methods_classipc_1_1session_1_1Session__base"><td class="mdescLeft">&#160;</td><td class="mdescRight">Marks this session as hosed for (truthy) reason <code>err_code</code>; and <em>synchronously</em> invokes on-error handler; only invoke if not already <a class="el" href="classipc_1_1session_1_1Session__base.html#a398f3e6a30b3fae8e110af9fd1ff75e3" title="Returns true if and only if hose() has been called.">hosed()</a>.  <a href="classipc_1_1session_1_1Session__base.html#a7f9e67dccbab4f3191734c2834bafb63">More...</a><br /></td></tr>
<tr class="separator:a7f9e67dccbab4f3191734c2834bafb63 inherit pro_methods_classipc_1_1session_1_1Session__base"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a398f3e6a30b3fae8e110af9fd1ff75e3 inherit pro_methods_classipc_1_1session_1_1Session__base"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classipc_1_1session_1_1Session__base.html#a398f3e6a30b3fae8e110af9fd1ff75e3">hosed</a> () const</td></tr>
<tr class="memdesc:a398f3e6a30b3fae8e110af9fd1ff75e3 inherit pro_methods_classipc_1_1session_1_1Session__base"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns <code>true</code> if and only if <a class="el" href="classipc_1_1session_1_1Session__base.html#a7f9e67dccbab4f3191734c2834bafb63" title="Marks this session as hosed for (truthy) reason err_code; and synchronously invokes on-error handler;...">hose()</a> has been called.  <a href="classipc_1_1session_1_1Session__base.html#a398f3e6a30b3fae8e110af9fd1ff75e3">More...</a><br /></td></tr>
<tr class="separator:a398f3e6a30b3fae8e110af9fd1ff75e3 inherit pro_methods_classipc_1_1session_1_1Session__base"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pri-types" name="pri-types"></a>
Private Types</h2></td></tr>
<tr class="memitem:af7a951bd266bdd0e3339a0fbddba9e8b"><td class="memItemLeft" align="right" valign="top">enum class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classipc_1_1session_1_1Client__session__impl.html#af7a951bd266bdd0e3339a0fbddba9e8b">State</a> { <a class="el" href="classipc_1_1session_1_1Client__session__impl.html#af7a951bd266bdd0e3339a0fbddba9e8bac6bd7568063494695099321f427efcb2">S_NULL</a>
, <a class="el" href="classipc_1_1session_1_1Client__session__impl.html#af7a951bd266bdd0e3339a0fbddba9e8baae585d03fce4ac2011967830bf0ffbfb">S_CONNECTING</a>
, <a class="el" href="classipc_1_1session_1_1Client__session__impl.html#af7a951bd266bdd0e3339a0fbddba9e8bad9a05d721258c584cd559c56fd035887">S_PEER</a>
 }</td></tr>
<tr class="memdesc:af7a951bd266bdd0e3339a0fbddba9e8b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Overall state of a <a class="el" href="classipc_1_1session_1_1Client__session__impl.html" title="Internal, non-movable pImpl-lite implementation of Client_session_mv class template.">Client_session_impl</a>.  <a href="classipc_1_1session_1_1Client__session__impl.html#af7a951bd266bdd0e3339a0fbddba9e8b">More...</a><br /></td></tr>
<tr class="separator:af7a951bd266bdd0e3339a0fbddba9e8b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2a2960c4707475bab5d33b65bab9ba75"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classipc_1_1session_1_1Client__session__impl.html#a2a2960c4707475bab5d33b65bab9ba75">Master_structured_channel_ptr</a> = typename <a class="el" href="classipc_1_1session_1_1Session__base.html#af0ca2a01d7d0d92038aae56fc1cdd505">Base::Master_structured_channel_ptr</a></td></tr>
<tr class="memdesc:a2a2960c4707475bab5d33b65bab9ba75"><td class="mdescLeft">&#160;</td><td class="mdescRight">See <a class="el" href="classipc_1_1session_1_1Session__base.html" title="Internal type containing data and types common to internal types Server_session_impl and Client_sessi...">Session_base</a>.  <a href="classipc_1_1session_1_1Client__session__impl.html#a2a2960c4707475bab5d33b65bab9ba75">More...</a><br /></td></tr>
<tr class="separator:a2a2960c4707475bab5d33b65bab9ba75"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3c26cfd7f21dc449db1a104277cef700"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classipc_1_1session_1_1Client__session__impl.html#a3c26cfd7f21dc449db1a104277cef700">Master_structured_channel_observer</a> = typename <a class="el" href="classipc_1_1session_1_1Session__base.html#ae2a123b29dd044a638e94d1f294c8f28">Base::Master_structured_channel_observer</a></td></tr>
<tr class="memdesc:a3c26cfd7f21dc449db1a104277cef700"><td class="mdescLeft">&#160;</td><td class="mdescRight">See <a class="el" href="classipc_1_1session_1_1Session__base.html" title="Internal type containing data and types common to internal types Server_session_impl and Client_sessi...">Session_base</a>.  <a href="classipc_1_1session_1_1Client__session__impl.html#a3c26cfd7f21dc449db1a104277cef700">More...</a><br /></td></tr>
<tr class="separator:a3c26cfd7f21dc449db1a104277cef700"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7d38f0ec6408a5ed6b3eef661f1f0894"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classipc_1_1session_1_1Client__session__impl.html#a7d38f0ec6408a5ed6b3eef661f1f0894">Persistent_mq_handle_from_cfg</a> = typename <a class="el" href="classipc_1_1session_1_1Session__base.html#a848c0f5247644ada0f8b0ab816eedda8">Base::Persistent_mq_handle_from_cfg</a></td></tr>
<tr class="memdesc:a7d38f0ec6408a5ed6b3eef661f1f0894"><td class="mdescLeft">&#160;</td><td class="mdescRight">See <a class="el" href="classipc_1_1session_1_1Session__base.html" title="Internal type containing data and types common to internal types Server_session_impl and Client_sessi...">Session_base</a>.  <a href="classipc_1_1session_1_1Client__session__impl.html#a7d38f0ec6408a5ed6b3eef661f1f0894">More...</a><br /></td></tr>
<tr class="separator:a7d38f0ec6408a5ed6b3eef661f1f0894"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a801b5883e969a12a844fe85f581ab01d"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classipc_1_1session_1_1Client__session__impl.html#a801b5883e969a12a844fe85f581ab01d">On_passive_open_channel_func</a> = typename <a class="el" href="classipc_1_1session_1_1Session__base.html#a3c0824a54ef32915c5c5ea76481f2409">Base::On_passive_open_channel_func</a></td></tr>
<tr class="memdesc:a801b5883e969a12a844fe85f581ab01d"><td class="mdescLeft">&#160;</td><td class="mdescRight">See <a class="el" href="classipc_1_1session_1_1Session__base.html" title="Internal type containing data and types common to internal types Server_session_impl and Client_sessi...">Session_base</a>.  <a href="classipc_1_1session_1_1Client__session__impl.html#a801b5883e969a12a844fe85f581ab01d">More...</a><br /></td></tr>
<tr class="separator:a801b5883e969a12a844fe85f581ab01d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a23c0fbed0e0fe45f9b2dc251bccddac9"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classipc_1_1session_1_1Client__session__impl.html#a23c0fbed0e0fe45f9b2dc251bccddac9">Master_channel_req_ptr</a> = boost::shared_ptr&lt; <a class="el" href="structipc_1_1session_1_1Client__session__impl_1_1Master__channel__req.html">Master_channel_req</a> &gt;</td></tr>
<tr class="memdesc:a23c0fbed0e0fe45f9b2dc251bccddac9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Short-hand for ref-counted pointer to <a class="el" href="structipc_1_1session_1_1Client__session__impl_1_1Master__channel__req.html" title="An open-channel/log-in request out-message.">Master_channel_req</a>.  <a href="classipc_1_1session_1_1Client__session__impl.html#a23c0fbed0e0fe45f9b2dc251bccddac9">More...</a><br /></td></tr>
<tr class="separator:a23c0fbed0e0fe45f9b2dc251bccddac9"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pri-methods" name="pri-methods"></a>
Private Member Functions</h2></td></tr>
<tr class="memitem:a6db7a1f722663528520775e6c8a65c61"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classipc_1_1session_1_1Client__session__impl.html#a6db7a1f722663528520775e6c8a65c61">Client_session_impl</a> (flow::log::Logger *logger_ptr, const <a class="el" href="structipc_1_1session_1_1Client__app.html">Client_app</a> &amp;cli_app_ref, const <a class="el" href="structipc_1_1session_1_1Server__app.html">Server_app</a> &amp;srv_app_ref, flow::async::Task_asio_err &amp;&amp;on_err_func, <a class="el" href="classipc_1_1session_1_1Client__session__impl.html#a801b5883e969a12a844fe85f581ab01d">On_passive_open_channel_func</a> &amp;&amp;on_passive_open_channel_func_or_empty_arg, std::nullptr_t tag)</td></tr>
<tr class="memdesc:a6db7a1f722663528520775e6c8a65c61"><td class="mdescLeft">&#160;</td><td class="mdescRight">Delegated-to ctor that implements both non-default <code>public</code> ctors.  <a href="classipc_1_1session_1_1Client__session__impl.html#a6db7a1f722663528520775e6c8a65c61">More...</a><br /></td></tr>
<tr class="separator:a6db7a1f722663528520775e6c8a65c61"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acaacff906e2eb50f48d1b04a64247649"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classipc_1_1session_1_1Client__session__impl.html#acaacff906e2eb50f48d1b04a64247649">conn_on_async_connect_or_error</a> (const <a class="el" href="namespaceipc_1_1session.html#a6d07d9996af19e57eb42416e914110ea">Shared_name</a> &amp;acc_name, <a class="el" href="classipc_1_1transport_1_1Native__socket__stream.html">transport::Native_socket_stream</a> &amp;&amp;sock_stm, <a class="el" href="classipc_1_1session_1_1Client__session__impl.html#a5d391e86ccc1153b4975efdc8e5401e4">Mdt_builder_ptr</a> &amp;&amp;mdt, <a class="el" href="classipc_1_1session_1_1Client__session__impl.html#a48487e4c98ae3a82ef344269742c8057">Channels</a> *init_channels_by_cli_req_pre_sized, <a class="el" href="classipc_1_1session_1_1Client__session__impl.html#a2cc5b77dd2367cc8e821fdcab7f6c109">Mdt_reader_ptr</a> *mdt_from_srv_or_null, <a class="el" href="classipc_1_1session_1_1Client__session__impl.html#a48487e4c98ae3a82ef344269742c8057">Channels</a> *init_channels_by_srv_req, const <a class="el" href="namespaceipc.html#aa3192e586cc45d3e7c22463bf2760f89">Error_code</a> &amp;async_err_code)</td></tr>
<tr class="memdesc:acaacff906e2eb50f48d1b04a64247649"><td class="mdescLeft">&#160;</td><td class="mdescRight">In thread W, handler for the <a class="el" href="classipc_1_1transport_1_1Native__socket__stream.html#a3614a9677c1a203090b97ac935093390" title="To be invoked in NULL state only, it asynchronously attempts to connect to an opposing Native_socket_...">transport::Native_socket_stream::async_connect()</a>, as invoked in CONNECTING state.  <a href="classipc_1_1session_1_1Client__session__impl.html#acaacff906e2eb50f48d1b04a64247649">More...</a><br /></td></tr>
<tr class="separator:acaacff906e2eb50f48d1b04a64247649"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5d9ae1ffb0b776fc78aa8f3daf60918b"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classipc_1_1session_1_1Client__session__impl.html#a5d9ae1ffb0b776fc78aa8f3daf60918b">on_master_channel_error</a> (const <a class="el" href="classipc_1_1session_1_1Client__session__impl.html#a3c26cfd7f21dc449db1a104277cef700">Master_structured_channel_observer</a> &amp;master_channel_observer, const <a class="el" href="namespaceipc.html#aa3192e586cc45d3e7c22463bf2760f89">Error_code</a> &amp;err_code)</td></tr>
<tr class="memdesc:a5d9ae1ffb0b776fc78aa8f3daf60918b"><td class="mdescLeft">&#160;</td><td class="mdescRight">In thread W, handler for <a class="el" href="classipc_1_1session_1_1Client__session__impl.html#a5f526c4f9567f2529471dec9cd70f83c" title="The session master channel.">m_master_channel</a> indicating incoming-direction channel-hosing error.  <a href="classipc_1_1session_1_1Client__session__impl.html#a5d9ae1ffb0b776fc78aa8f3daf60918b">More...</a><br /></td></tr>
<tr class="separator:a5d9ae1ffb0b776fc78aa8f3daf60918b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad3e5b51e17d2851b6deecedee67d8b50"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classipc_1_1session_1_1Client__session__impl.html#ad3e5b51e17d2851b6deecedee67d8b50">on_master_channel_log_in_rsp</a> (typename Master_structured_channel::Msg_in_ptr &amp;&amp;log_in_rsp, <a class="el" href="classipc_1_1session_1_1Client__session__impl.html#a48487e4c98ae3a82ef344269742c8057">Channels</a> *init_channels_by_cli_req_pre_sized, <a class="el" href="classipc_1_1session_1_1Client__session__impl.html#a2cc5b77dd2367cc8e821fdcab7f6c109">Mdt_reader_ptr</a> *mdt_from_srv_or_null, <a class="el" href="classipc_1_1session_1_1Client__session__impl.html#a48487e4c98ae3a82ef344269742c8057">Channels</a> *init_channels_by_srv_req)</td></tr>
<tr class="memdesc:ad3e5b51e17d2851b6deecedee67d8b50"><td class="mdescLeft">&#160;</td><td class="mdescRight">In thread W, handler for the successful receipt of log-in response (upon <code>send()</code>ing the log-in request), as invoked in CONNECTING state only if the low-level <a class="el" href="classipc_1_1transport_1_1Native__socket__stream.html#a3614a9677c1a203090b97ac935093390" title="To be invoked in NULL state only, it asynchronously attempts to connect to an opposing Native_socket_...">transport::Native_socket_stream::async_connect()</a> succeeded.  <a href="classipc_1_1session_1_1Client__session__impl.html#ad3e5b51e17d2851b6deecedee67d8b50">More...</a><br /></td></tr>
<tr class="separator:ad3e5b51e17d2851b6deecedee67d8b50"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a908d037a1bc90800a60fe56a8dded67d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classipc_1_1session_1_1Client__session__impl.html#a908d037a1bc90800a60fe56a8dded67d">on_master_channel_init_open_channel</a> (typename Master_structured_channel::Msg_in_ptr &amp;&amp;open_channel_msg, size_t n_init_channels, const boost::shared_ptr&lt; <a class="el" href="classipc_1_1session_1_1Client__session__impl.html#a48487e4c98ae3a82ef344269742c8057">Channels</a> &gt; &amp;init_channels_ptr, <a class="el" href="classipc_1_1session_1_1Client__session__impl.html#a48487e4c98ae3a82ef344269742c8057">Channels</a> *init_channels_by_cli_req_pre_sized, <a class="el" href="classipc_1_1session_1_1Client__session__impl.html#a2cc5b77dd2367cc8e821fdcab7f6c109">Mdt_reader_ptr</a> *mdt_from_srv_or_null, <a class="el" href="classipc_1_1session_1_1Client__session__impl.html#a48487e4c98ae3a82ef344269742c8057">Channels</a> *init_channels_by_srv_req, <a class="el" href="classipc_1_1session_1_1Client__session__impl.html#a2cc5b77dd2367cc8e821fdcab7f6c109">Mdt_reader_ptr</a> &amp;&amp;mdt_from_srv)</td></tr>
<tr class="memdesc:a908d037a1bc90800a60fe56a8dded67d"><td class="mdescLeft">&#160;</td><td class="mdescRight">In thread W, handler for <a class="el" href="classipc_1_1session_1_1Client__session__impl.html#a5f526c4f9567f2529471dec9cd70f83c" title="The session master channel.">m_master_channel</a> receiving a init-channel-open message.  <a href="classipc_1_1session_1_1Client__session__impl.html#a908d037a1bc90800a60fe56a8dded67d">More...</a><br /></td></tr>
<tr class="separator:a908d037a1bc90800a60fe56a8dded67d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9160d0684b8a1f39258d4a0b5a26a839"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classipc_1_1session_1_1Client__session__impl.html#a9160d0684b8a1f39258d4a0b5a26a839">on_master_channel_open_channel_req</a> (typename Master_structured_channel::Msg_in_ptr &amp;&amp;open_channel_req)</td></tr>
<tr class="memdesc:a9160d0684b8a1f39258d4a0b5a26a839"><td class="mdescLeft">&#160;</td><td class="mdescRight">In thread W, handler for <a class="el" href="classipc_1_1session_1_1Client__session__impl.html#a5f526c4f9567f2529471dec9cd70f83c" title="The session master channel.">m_master_channel</a> receiving a passive-open (a/k/a open-channel-to-client) request.  <a href="classipc_1_1session_1_1Client__session__impl.html#a9160d0684b8a1f39258d4a0b5a26a839">More...</a><br /></td></tr>
<tr class="separator:a9160d0684b8a1f39258d4a0b5a26a839"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a224dd90df35537680e649f74e427d47d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classipc_1_1session_1_1Client__session__impl.html#a224dd90df35537680e649f74e427d47d">create_channel_obj</a> (const <a class="el" href="namespaceipc_1_1session.html#a6d07d9996af19e57eb42416e914110ea">Shared_name</a> &amp;mq_name_c2s_or_none, const <a class="el" href="namespaceipc_1_1session.html#a6d07d9996af19e57eb42416e914110ea">Shared_name</a> &amp;mq_name_s2c_or_none, <a class="el" href="structipc_1_1util_1_1Native__handle.html">util::Native_handle</a> &amp;&amp;local_hndl_or_null, <a class="el" href="classipc_1_1session_1_1Client__session__impl.html#a418a1e70b7b51833cc9d24d1046e3526">Channel_obj</a> *opened_channel_ptr, bool active_else_passive, <a class="el" href="namespaceipc.html#aa3192e586cc45d3e7c22463bf2760f89">Error_code</a> *err_code_ptr)</td></tr>
<tr class="memdesc:a224dd90df35537680e649f74e427d47d"><td class="mdescLeft">&#160;</td><td class="mdescRight">In thread W, based on resources acquired on server side, creates local <a class="el" href="classipc_1_1session_1_1Client__session__impl.html#a418a1e70b7b51833cc9d24d1046e3526" title="See Client_session_mv counterpart.">Channel_obj</a> to emit to the user thus completing a channel-open.  <a href="classipc_1_1session_1_1Client__session__impl.html#a224dd90df35537680e649f74e427d47d">More...</a><br /></td></tr>
<tr class="separator:a224dd90df35537680e649f74e427d47d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7aaccbdd0e823796e6cec233ac6134ec"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classipc_1_1session_1_1Client__session__impl.html#a7aaccbdd0e823796e6cec233ac6134ec">invoke_conn_on_done_func</a> (const <a class="el" href="namespaceipc.html#aa3192e586cc45d3e7c22463bf2760f89">Error_code</a> &amp;err_code)</td></tr>
<tr class="memdesc:a7aaccbdd0e823796e6cec233ac6134ec"><td class="mdescLeft">&#160;</td><td class="mdescRight">Little helper that invokes <a class="el" href="classipc_1_1session_1_1Client__session__impl.html#a64ac1e72347053e73b125209a7756a1e" title="The on_done_func argument to async_connect(); .empty() except while in State::S_CONNECTING state.">m_conn_on_done_func_or_empty</a>, passing it <code>err_code</code>, and &ndash; per that member's internal use semantics &ndash; empties <a class="el" href="classipc_1_1session_1_1Client__session__impl.html#a64ac1e72347053e73b125209a7756a1e" title="The on_done_func argument to async_connect(); .empty() except while in State::S_CONNECTING state.">m_conn_on_done_func_or_empty</a>.  <a href="classipc_1_1session_1_1Client__session__impl.html#a7aaccbdd0e823796e6cec233ac6134ec">More...</a><br /></td></tr>
<tr class="separator:a7aaccbdd0e823796e6cec233ac6134ec"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pri-attribs" name="pri-attribs"></a>
Private Attributes</h2></td></tr>
<tr class="memitem:afd6871349fe71ab7a991bad2782421ba"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classipc_1_1session_1_1Client__session__impl.html#af7a951bd266bdd0e3339a0fbddba9e8b">State</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classipc_1_1session_1_1Client__session__impl.html#afd6871349fe71ab7a991bad2782421ba">m_state</a></td></tr>
<tr class="memdesc:afd6871349fe71ab7a991bad2782421ba"><td class="mdescLeft">&#160;</td><td class="mdescRight">The current state of <code>*this</code>.  <a href="classipc_1_1session_1_1Client__session__impl.html#afd6871349fe71ab7a991bad2782421ba">More...</a><br /></td></tr>
<tr class="separator:afd6871349fe71ab7a991bad2782421ba"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a64ac1e72347053e73b125209a7756a1e"><td class="memItemLeft" align="right" valign="top">flow::async::Task_asio_err&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classipc_1_1session_1_1Client__session__impl.html#a64ac1e72347053e73b125209a7756a1e">m_conn_on_done_func_or_empty</a></td></tr>
<tr class="memdesc:a64ac1e72347053e73b125209a7756a1e"><td class="mdescLeft">&#160;</td><td class="mdescRight">The <code>on_done_func</code> argument to <a class="el" href="classipc_1_1session_1_1Client__session__impl.html#af03a9fca2006fba2cc522efa1178e83e" title="See Client_session_mv counterpart.">async_connect()</a>; <code>.empty()</code> except while in <a class="el" href="classipc_1_1session_1_1Client__session__impl.html#af7a951bd266bdd0e3339a0fbddba9e8baae585d03fce4ac2011967830bf0ffbfb" title="Not a peer but async_connect() in progress to try to make it a peer.">State::S_CONNECTING</a> state.  <a href="classipc_1_1session_1_1Client__session__impl.html#a64ac1e72347053e73b125209a7756a1e">More...</a><br /></td></tr>
<tr class="separator:a64ac1e72347053e73b125209a7756a1e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abd394250fd8009dbc5a5b91973d56adf"><td class="memItemLeft" align="right" valign="top">unsigned int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classipc_1_1session_1_1Client__session__impl.html#abd394250fd8009dbc5a5b91973d56adf">m_last_actively_opened_channel_id</a></td></tr>
<tr class="memdesc:abd394250fd8009dbc5a5b91973d56adf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Logging-only <code>*this</code>-unique ID used in nicknaming the last actively-opened (via <a class="el" href="classipc_1_1session_1_1Client__session__impl.html#a4229549db1093aaa1e7e84c6e6467e80" title="See Client_session_mv counterpart.">open_channel()</a>) channel.  <a href="classipc_1_1session_1_1Client__session__impl.html#abd394250fd8009dbc5a5b91973d56adf">More...</a><br /></td></tr>
<tr class="separator:abd394250fd8009dbc5a5b91973d56adf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaaba9b5089387689dfdc4fce53a358e9"><td class="memItemLeft" align="right" valign="top">unsigned int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classipc_1_1session_1_1Client__session__impl.html#aaaba9b5089387689dfdc4fce53a358e9">m_last_passively_opened_channel_id</a></td></tr>
<tr class="memdesc:aaaba9b5089387689dfdc4fce53a358e9"><td class="mdescLeft">&#160;</td><td class="mdescRight">A-la <a class="el" href="classipc_1_1session_1_1Client__session__impl.html#abd394250fd8009dbc5a5b91973d56adf" title="Logging-only *this-unique ID used in nicknaming the last actively-opened (via open_channel()) channel...">m_last_actively_opened_channel_id</a> but for passively-opened channels (<a class="el" href="classipc_1_1session_1_1Client__session__impl.html#a9160d0684b8a1f39258d4a0b5a26a839" title="In thread W, handler for m_master_channel receiving a passive-open (a/k/a open-channel-to-client) req...">on_master_channel_open_channel_req()</a>).  <a href="classipc_1_1session_1_1Client__session__impl.html#aaaba9b5089387689dfdc4fce53a358e9">More...</a><br /></td></tr>
<tr class="separator:aaaba9b5089387689dfdc4fce53a358e9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa7be8826b9256addf316ef407aa8bd76"><td class="memItemLeft" align="right" valign="top">flow::async::Single_thread_task_loop&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classipc_1_1session_1_1Client__session__impl.html#aa7be8826b9256addf316ef407aa8bd76">m_async_worker</a></td></tr>
<tr class="memdesc:aa7be8826b9256addf316ef407aa8bd76"><td class="mdescLeft">&#160;</td><td class="mdescRight">Worker thread (a/k/a thread W).  <a href="classipc_1_1session_1_1Client__session__impl.html#aa7be8826b9256addf316ef407aa8bd76">More...</a><br /></td></tr>
<tr class="separator:aa7be8826b9256addf316ef407aa8bd76"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5f526c4f9567f2529471dec9cd70f83c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classipc_1_1session_1_1Client__session__impl.html#a2a2960c4707475bab5d33b65bab9ba75">Master_structured_channel_ptr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classipc_1_1session_1_1Client__session__impl.html#a5f526c4f9567f2529471dec9cd70f83c">m_master_channel</a></td></tr>
<tr class="memdesc:a5f526c4f9567f2529471dec9cd70f83c"><td class="mdescLeft">&#160;</td><td class="mdescRight">The session master channel.  <a href="classipc_1_1session_1_1Client__session__impl.html#a5f526c4f9567f2529471dec9cd70f83c">More...</a><br /></td></tr>
<tr class="separator:a5f526c4f9567f2529471dec9cd70f83c"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="related" name="related"></a>
Related Functions</h2></td></tr>
<tr><td class="ititle" colspan="2"><p >(Note that these are not member functions.) </p>
</td></tr>
<tr class="memitem:a2c0fec2b8fcc95779db8561e8ad27c42"><td class="memTemplParams" colspan="2">template&lt;schema::MqType S_MQ_TYPE_OR_NONE, bool S_TRANSMIT_NATIVE_HANDLES, typename Mdt_payload , schema::ShmType S_SHM_TYPE_OR_NONE&gt; </td></tr>
<tr class="memitem:a2c0fec2b8fcc95779db8561e8ad27c42"><td class="memTemplItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classipc_1_1session_1_1Client__session__impl.html#a2c0fec2b8fcc95779db8561e8ad27c42">operator&lt;&lt;</a> (std::ostream &amp;os, const <a class="el" href="classipc_1_1session_1_1Client__session__impl.html">Client_session_impl</a>&lt; S_MQ_TYPE_OR_NONE, S_TRANSMIT_NATIVE_HANDLES, Mdt_payload, S_SHM_TYPE_OR_NONE &gt; &amp;val)</td></tr>
<tr class="memdesc:a2c0fec2b8fcc95779db8561e8ad27c42"><td class="mdescLeft">&#160;</td><td class="mdescRight">Prints string representation of the given <code><a class="el" href="classipc_1_1session_1_1Client__session__impl.html" title="Internal, non-movable pImpl-lite implementation of Client_session_mv class template.">Client_session_impl</a></code> to the given <code>ostream</code>.  <a href="classipc_1_1session_1_1Client__session__impl.html#a2c0fec2b8fcc95779db8561e8ad27c42">More...</a><br /></td></tr>
<tr class="separator:a2c0fec2b8fcc95779db8561e8ad27c42"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="inherited" name="inherited"></a>
Additional Inherited Members</h2></td></tr>
<tr class="inherit_header pub_static_methods_classipc_1_1session_1_1Session__base"><td colspan="2" onclick="javascript:toggleInherit('pub_static_methods_classipc_1_1session_1_1Session__base')"><img src="closed.png" alt="-"/>&#160;Static Public Member Functions inherited from <a class="el" href="classipc_1_1session_1_1Session__base.html">ipc::session::Session_base&lt; S_MQ_TYPE_OR_NONE, S_TRANSMIT_NATIVE_HANDLES, Mdt_payload &gt;</a></td></tr>
<tr class="memitem:a08b3d69a6707dcbb233076b7a48de285 inherit pub_static_methods_classipc_1_1session_1_1Session__base"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classipc_1_1session_1_1Session__base.html#aee0db48505c84d3553b7110a9a815036">Structured_msg_builder_config</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classipc_1_1session_1_1Session__base.html#a08b3d69a6707dcbb233076b7a48de285">heap_fixed_builder_config</a> (flow::log::Logger *logger_ptr)</td></tr>
<tr class="memdesc:a08b3d69a6707dcbb233076b7a48de285 inherit pub_static_methods_classipc_1_1session_1_1Session__base"><td class="mdescLeft">&#160;</td><td class="mdescRight">See <a class="el" href="classipc_1_1session_1_1Session__mv.html#a107684fdd5d233549c6daac26a81a542" title="Utility that obtains a heap-based (non-zero-copy) Struct_builder::Config, constructed with the most e...">Session_mv::heap_fixed_builder_config()</a> (1-arg).  <a href="classipc_1_1session_1_1Session__base.html#a08b3d69a6707dcbb233076b7a48de285">More...</a><br /></td></tr>
<tr class="separator:a08b3d69a6707dcbb233076b7a48de285 inherit pub_static_methods_classipc_1_1session_1_1Session__base"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a489bb6ec7726e39e78dcd4dd2fe3de75 inherit pub_static_methods_classipc_1_1session_1_1Session__base"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classipc_1_1session_1_1Session__base.html#abd854f2b9316361ef18f15610c242d4b">Structured_msg_reader_config</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classipc_1_1session_1_1Session__base.html#a489bb6ec7726e39e78dcd4dd2fe3de75">heap_reader_config</a> (flow::log::Logger *logger_ptr)</td></tr>
<tr class="memdesc:a489bb6ec7726e39e78dcd4dd2fe3de75 inherit pub_static_methods_classipc_1_1session_1_1Session__base"><td class="mdescLeft">&#160;</td><td class="mdescRight">See <a class="el" href="classipc_1_1session_1_1Session__mv.html#ab3c69e3f8ccbd70d315bed86d697255d" title="Deserializing counterpart to non-static heap_fixed_builder_config().">Session_mv::heap_reader_config()</a> (1-arg).  <a href="classipc_1_1session_1_1Session__base.html#a489bb6ec7726e39e78dcd4dd2fe3de75">More...</a><br /></td></tr>
<tr class="separator:a489bb6ec7726e39e78dcd4dd2fe3de75 inherit pub_static_methods_classipc_1_1session_1_1Session__base"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pub_attribs_classipc_1_1session_1_1Session__base"><td colspan="2" onclick="javascript:toggleInherit('pub_attribs_classipc_1_1session_1_1Session__base')"><img src="closed.png" alt="-"/>&#160;Public Attributes inherited from <a class="el" href="classipc_1_1session_1_1Session__base.html">ipc::session::Session_base&lt; S_MQ_TYPE_OR_NONE, S_TRANSMIT_NATIVE_HANDLES, Mdt_payload &gt;</a></td></tr>
<tr class="memitem:afd32d90b86d699263a0f02637dd7c6c6 inherit pub_attribs_classipc_1_1session_1_1Session__base"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="structipc_1_1session_1_1Server__app.html">Server_app</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classipc_1_1session_1_1Session__base.html#afd32d90b86d699263a0f02637dd7c6c6">m_srv_app_ref</a></td></tr>
<tr class="memdesc:afd32d90b86d699263a0f02637dd7c6c6 inherit pub_attribs_classipc_1_1session_1_1Session__base"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reference to <a class="el" href="structipc_1_1session_1_1Server__app.html" title="An App that is used as a server in at least one client-server IPC split.">Server_app</a> (referring to local process in Server_session, opposing process in Client_session).  <a href="classipc_1_1session_1_1Session__base.html#afd32d90b86d699263a0f02637dd7c6c6">More...</a><br /></td></tr>
<tr class="separator:afd32d90b86d699263a0f02637dd7c6c6 inherit pub_attribs_classipc_1_1session_1_1Session__base"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pro_static_attribs_classipc_1_1session_1_1Session__base"><td colspan="2" onclick="javascript:toggleInherit('pro_static_attribs_classipc_1_1session_1_1Session__base')"><img src="closed.png" alt="-"/>&#160;Static Protected Attributes inherited from <a class="el" href="classipc_1_1session_1_1Session__base.html">ipc::session::Session_base&lt; S_MQ_TYPE_OR_NONE, S_TRANSMIT_NATIVE_HANDLES, Mdt_payload &gt;</a></td></tr>
<tr class="memitem:ae68b7b80ff82ba5cde28a53fa52a5095 inherit pro_static_attribs_classipc_1_1session_1_1Session__base"><td class="memItemLeft" align="right" valign="top">static constexpr <a class="el" href="namespaceipc_1_1util.html#ac66141280c3b7295a86b65209f31cc58">util::Fine_duration</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classipc_1_1session_1_1Session__base.html#ae68b7b80ff82ba5cde28a53fa52a5095">S_OPEN_CHANNEL_TIMEOUT</a> = boost::chrono::seconds(60)</td></tr>
<tr class="memdesc:ae68b7b80ff82ba5cde28a53fa52a5095 inherit pro_static_attribs_classipc_1_1session_1_1Session__base"><td class="mdescLeft">&#160;</td><td class="mdescRight">Internal timeout for <code>open_channel()</code>.  <a href="classipc_1_1session_1_1Session__base.html#ae68b7b80ff82ba5cde28a53fa52a5095">More...</a><br /></td></tr>
<tr class="separator:ae68b7b80ff82ba5cde28a53fa52a5095 inherit pro_static_attribs_classipc_1_1session_1_1Session__base"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af0b52934c6b1204cb3ba676480727d27 inherit pro_static_attribs_classipc_1_1session_1_1Session__base"><td class="memItemLeft" align="right" valign="top">static constexpr size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classipc_1_1session_1_1Session__base.html#af0b52934c6b1204cb3ba676480727d27">S_MQS_MAX_MSG_SZ</a> = 8 * 1024</td></tr>
<tr class="memdesc:af0b52934c6b1204cb3ba676480727d27 inherit pro_static_attribs_classipc_1_1session_1_1Session__base"><td class="mdescLeft">&#160;</td><td class="mdescRight">The max sendable MQ message size as decided by <a class="el" href="classipc_1_1session_1_1Server__session__impl.html#a37d0b0fdbe58ecb22e19c8bebfe976cd" title="Helper for create_channel_and_resources(), invoked and compiled if and only if S_MQS_ENABLED,...">Server_session_impl::make_channel_mqs()</a> (and imposed on both sides, both directions), if <a class="el" href="classipc_1_1session_1_1Session__base.html#a27a5731a648effb6b4b42f0312affa74" title="See Session_mv.">S_MQS_ENABLED</a> <em>and</em> <a class="el" href="classipc_1_1session_1_1Server__session__impl.html#a5de86bde678c98c48f300742bd98f7ff" title="See Session_mv counterpart.">Server_session_impl::S_SHM_ENABLED</a> is <code>false</code>, when a channel is opened (regardless of which side did the active-open or requested pre-opening at session start).  <a href="classipc_1_1session_1_1Session__base.html#af0b52934c6b1204cb3ba676480727d27">More...</a><br /></td></tr>
<tr class="separator:af0b52934c6b1204cb3ba676480727d27 inherit pro_static_attribs_classipc_1_1session_1_1Session__base"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><div class="compoundTemplParams">template&lt;schema::MqType S_MQ_TYPE_OR_NONE, bool S_TRANSMIT_NATIVE_HANDLES, typename Mdt_payload, schema::ShmType S_SHM_TYPE_OR_NONE&gt;<br />
class ipc::session::Client_session_impl&lt; S_MQ_TYPE_OR_NONE, S_TRANSMIT_NATIVE_HANDLES, Mdt_payload, S_SHM_TYPE_OR_NONE &gt;</div><p >Internal, non-movable pImpl-lite implementation of <a class="el" href="classipc_1_1session_1_1Client__session__mv.html" title="Implements Session concept on the Client_app end: a Session_mv that first achieves PEER state by conn...">Client_session_mv</a> class template. </p>
<p >In and of itself it would have been directly and publicly usable; however <a class="el" href="classipc_1_1session_1_1Client__session__mv.html" title="Implements Session concept on the Client_app end: a Session_mv that first achieves PEER state by conn...">Client_session_mv</a> adds move semantics.</p>
<dl class="section see"><dt>See also</dt><dd>All discussion of the public API is in <a class="el" href="classipc_1_1session_1_1Client__session__mv.html" title="Implements Session concept on the Client_app end: a Session_mv that first achieves PEER state by conn...">Client_session_mv</a> doc header; that class template forwards to this one. All discussion of pImpl-lite-related notions is also there. See that doc header first please. Then come back here.</dd></dl>
<h2>Impl design </h2>
<p >Thread U represents all threads other than thread W: since the relevant methods are to be called by the user sans concurrency, those threads as a collection can be thought of as one thread.</p>
<p >Thread W is the async worker thread where most work is done; this helps us entirely avoid mutexes. Both <a class="el" href="classipc_1_1session_1_1Client__session__impl.html#af03a9fca2006fba2cc522efa1178e83e" title="See Client_session_mv counterpart.">async_connect()</a> and <a class="el" href="classipc_1_1session_1_1Client__session__impl.html#a4229549db1093aaa1e7e84c6e6467e80" title="See Client_session_mv counterpart.">open_channel()</a> are fairly infrequently called, so it's not necessary to avoid latency by doing work concurrently in threads U and W. So we keep it simple by posting most stuff onto thread W.</p>
<p >There are two distinct states (other than NULL): CONNECTING (<a class="el" href="classipc_1_1session_1_1Client__session__impl.html#af03a9fca2006fba2cc522efa1178e83e" title="See Client_session_mv counterpart.">async_connect()</a> outstanding) and PEER (it succeeded: <code>*this</code> is now a <a class="el" href="classipc_1_1session_1_1Session.html" title="A documentation-only concept defining the local side of an IPC conversation (session) with another en...">Session</a> in PEER state per concept).</p>
<h3>CONNECTING state impl</h3>
<p >Once <a class="el" href="classipc_1_1session_1_1Client__session__impl.html#af03a9fca2006fba2cc522efa1178e83e" title="See Client_session_mv counterpart.">async_connect()</a> is issued we must do the following:</p><ol type="1">
<li>Synchronously find out the full <code>Shared_name</code> where the opposing <a class="el" href="classipc_1_1session_1_1Session__server.html" title="To be instantiated typically once in a given process, an object of this type asynchronously listens f...">Session_server</a> is allegedly listening, which is computable by a <a class="el" href="classipc_1_1session_1_1Client__session__impl.html#a1bc8c5b0a277261799062827992efbea" title="Short-hand for base type.">Base</a> helper. So that it can be computed we need to find out <a class="el" href="classipc_1_1session_1_1Session__base.html#a4d1327608d6067ed6690bd4efa323c6f" title="See Server_session_impl, Client_session_impl.">Session_base::srv_namespace()</a> which we immediately do by checking the expected file that should have been written by <a class="el" href="classipc_1_1session_1_1Session__server.html" title="To be instantiated typically once in a given process, an object of this type asynchronously listens f...">Session_server</a>.</li>
<li>Issue the Native_socket_stream::async_connect() to that abstract-address and await success asynchronously.</li>
<li>Once that's done, go back to NULL on failure; or continue as follows on success: The Native_socket_stream, now in PEER state (connected), is upgraded to (wrapped by) a <a class="el" href="classipc_1_1transport_1_1Channel.html" title="Peer to a bundle of 1-2 full-duplex pipe(s), one for transmitting unstructured binary blobs; the othe...">transport::Channel</a> which is in turn upgraded to a <a class="el" href="classipc_1_1transport_1_1struc_1_1Channel.html" title="Owning and wrapping a pre-connected transport::Channel peer (an endpoint of an established channel ov...">transport::struc::Channel</a> <a class="el" href="classipc_1_1session_1_1Client__session__impl.html#a5f526c4f9567f2529471dec9cd70f83c" title="The session master channel.">Client_session_impl::m_master_channel</a>. This is the session master channel, in log-in phase (as client) (details of that API are in <a class="el" href="classipc_1_1transport_1_1struc_1_1Channel.html" title="Owning and wrapping a pre-connected transport::Channel peer (an endpoint of an established channel ov...">transport::struc::Channel</a> docs). So we immediately issue the next (and final) async step: sending the log-in requset over <code>m_master_channel</code> and async-await log-in response.</li>
<li>Once that's done, go back to NULL on failure; or else yay: we're now in PEER state.</li>
</ol>
<p >See session_master_channel.capnp for the schema for <code>m_master_channel</code>. Reading that gives a nice overview of the protocol involved, both in CONNECTING (after the socket is connected) and in PEER. Also notable is that this setup allows us to immediately "eat our own dog food" by using a <code>struc::Channel</code> to enable the opening of any further channels (structured or otherwise).</p>
<h3>PEER state impl</h3>
<p >Here our algorithm is complementary to the PEER state algorithm in <a class="el" href="classipc_1_1session_1_1Server__session__impl.html" title="Internal, non-movable pImpl-lite implementation of Server_session_mv class template.">Server_session_impl</a>. Namely we expect passive-opens via an appropriate <a class="el" href="classipc_1_1transport_1_1struc_1_1Channel.html#a3376b821b129ca3847484a178e080c67" title="Registers the expectation of 0+ notification in-messages whose Msg_which equals which.">transport::struc::Channel::expect_msgs()</a>; and we allow active-opens via <a class="el" href="classipc_1_1session_1_1Client__session__impl.html#a4229549db1093aaa1e7e84c6e6467e80" title="See Client_session_mv counterpart.">open_channel()</a>. The details of how these work is best understood just by reading that code inline.</p>
<p ><a class="el" href="classipc_1_1session_1_1Client__session__impl.html#a4229549db1093aaa1e7e84c6e6467e80" title="See Client_session_mv counterpart.">open_channel()</a>, similarly to <a class="el" href="classipc_1_1session_1_1Server__session__impl.html#a6cafd2bcde466e128bc4ac542e1be9c5" title="See Server_session_mv counterpart.">Server_session_impl::open_channel()</a>, has one interesting quirk which is: To the user it is presented as synchronous and blocking with the aim of being non-blockingly fast, as long as the other side is in PEER state. It uses <a class="el" href="classipc_1_1transport_1_1struc_1_1Channel.html#aa41aee3c76035f43833078e625e6ef78" title="Equivalent to the other sync_request() overload but with no timeout; meaning it shall exit only once ...">transport::struc::Channel::sync_request()</a> with a generous timeout, while knowing that if both sides in PEER state in practice the call will complete rather swiftly; the generous timeout aimed making it clear that <a class="el" href="classipc_1_1session_1_1Client__session__impl.html#a4229549db1093aaa1e7e84c6e6467e80" title="See Client_session_mv counterpart.">open_channel()</a> is failing <em>not</em> due to some overly tight internal timeout but more likely due to some application problem such as not calling <a class="el" href="classipc_1_1session_1_1Server__session__mv.html#a99097e5aa6883877c74f8a93ebc9f3e1" title="To be invoked by public user upon first obtaining *this: memorizes the given on-error and on-passive-...">Server_session::init_handlers()</a> quickly enough.</p>
<p >Once PEER state is reached, the Session-concept error emission semantics come into play. See its doc header.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">S_MQ_TYPE_OR_NONE</td><td>See <a class="el" href="namespaceipc_1_1session.html#a77d8fda00e1e17f595a6a5d4c44375e7" title="A vanilla Client_session with no optional capabilities.">Client_session</a> counterpart. </td></tr>
    <tr><td class="paramname">S_TRANSMIT_NATIVE_HANDLES</td><td>See <a class="el" href="namespaceipc_1_1session.html#a77d8fda00e1e17f595a6a5d4c44375e7" title="A vanilla Client_session with no optional capabilities.">Client_session</a> counterpart. </td></tr>
    <tr><td class="paramname">Mdt_payload</td><td>See <a class="el" href="namespaceipc_1_1session.html#a77d8fda00e1e17f595a6a5d4c44375e7" title="A vanilla Client_session with no optional capabilities.">Client_session</a> counterpart. </td></tr>
    <tr><td class="paramname">S_SHM_TYPE_OR_NONE</td><td>Identical to opposing <a class="el" href="classipc_1_1session_1_1Server__session__impl.html" title="Internal, non-movable pImpl-lite implementation of Server_session_mv class template.">Server_session_impl</a> counterpart. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="ipc__session_2src_2ipc_2session_2detail_2client__session__impl_8hpp_source.html#l00099">99</a> of file <a class="el" href="ipc__session_2src_2ipc_2session_2detail_2client__session__impl_8hpp_source.html">client_session_impl.hpp</a>.</p>
</div><h2 class="groupheader">Member Typedef Documentation</h2>
<a id="a1bc8c5b0a277261799062827992efbea" name="a1bc8c5b0a277261799062827992efbea"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1bc8c5b0a277261799062827992efbea">&#9670;&nbsp;</a></span>Base</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;schema::MqType S_MQ_TYPE_OR_NONE, bool S_TRANSMIT_NATIVE_HANDLES, typename Mdt_payload , schema::ShmType S_SHM_TYPE_OR_NONE&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classipc_1_1session_1_1Client__session__impl.html">ipc::session::Client_session_impl</a>&lt; S_MQ_TYPE_OR_NONE, S_TRANSMIT_NATIVE_HANDLES, Mdt_payload, S_SHM_TYPE_OR_NONE &gt;::Base =  <a class="el" href="classipc_1_1session_1_1Session__base.html">Session_base</a>&lt;S_MQ_TYPE_OR_NONE, S_TRANSMIT_NATIVE_HANDLES, Mdt_payload&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Short-hand for base type. </p>

<p class="definition">Definition at line <a class="el" href="ipc__session_2src_2ipc_2session_2detail_2client__session__impl_8hpp_source.html#l00107">107</a> of file <a class="el" href="ipc__session_2src_2ipc_2session_2detail_2client__session__impl_8hpp_source.html">client_session_impl.hpp</a>.</p>

</div>
</div>
<a id="a418a1e70b7b51833cc9d24d1046e3526" name="a418a1e70b7b51833cc9d24d1046e3526"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a418a1e70b7b51833cc9d24d1046e3526">&#9670;&nbsp;</a></span>Channel_obj</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;schema::MqType S_MQ_TYPE_OR_NONE, bool S_TRANSMIT_NATIVE_HANDLES, typename Mdt_payload , schema::ShmType S_SHM_TYPE_OR_NONE&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classipc_1_1session_1_1Client__session__impl.html">ipc::session::Client_session_impl</a>&lt; S_MQ_TYPE_OR_NONE, S_TRANSMIT_NATIVE_HANDLES, Mdt_payload, S_SHM_TYPE_OR_NONE &gt;::Channel_obj =  typename <a class="el" href="classipc_1_1session_1_1Session__base.html#a71f02a809d667c23ff8af29a96940bd1">Base::Channel_obj</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>See <a class="el" href="classipc_1_1session_1_1Client__session__mv.html" title="Implements Session concept on the Client_app end: a Session_mv that first achieves PEER state by conn...">Client_session_mv</a> counterpart. </p>

<p class="definition">Definition at line <a class="el" href="ipc__session_2src_2ipc_2session_2detail_2client__session__impl_8hpp_source.html#l00113">113</a> of file <a class="el" href="ipc__session_2src_2ipc_2session_2detail_2client__session__impl_8hpp_source.html">client_session_impl.hpp</a>.</p>

</div>
</div>
<a id="a48487e4c98ae3a82ef344269742c8057" name="a48487e4c98ae3a82ef344269742c8057"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a48487e4c98ae3a82ef344269742c8057">&#9670;&nbsp;</a></span>Channels</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;schema::MqType S_MQ_TYPE_OR_NONE, bool S_TRANSMIT_NATIVE_HANDLES, typename Mdt_payload , schema::ShmType S_SHM_TYPE_OR_NONE&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classipc_1_1session_1_1Client__session__impl.html">ipc::session::Client_session_impl</a>&lt; S_MQ_TYPE_OR_NONE, S_TRANSMIT_NATIVE_HANDLES, Mdt_payload, S_SHM_TYPE_OR_NONE &gt;::Channels =  typename <a class="el" href="classipc_1_1session_1_1Session__base.html#a638232ef74a0eb80aeb4f027ee06f9bf">Base::Channels</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>See <a class="el" href="classipc_1_1session_1_1Session__mv.html" title="Implements the Session concept when it is in PEER state.">Session_mv</a> counterpart. </p>

<p class="definition">Definition at line <a class="el" href="ipc__session_2src_2ipc_2session_2detail_2client__session__impl_8hpp_source.html#l00116">116</a> of file <a class="el" href="ipc__session_2src_2ipc_2session_2detail_2client__session__impl_8hpp_source.html">client_session_impl.hpp</a>.</p>

</div>
</div>
<a id="a23c0fbed0e0fe45f9b2dc251bccddac9" name="a23c0fbed0e0fe45f9b2dc251bccddac9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a23c0fbed0e0fe45f9b2dc251bccddac9">&#9670;&nbsp;</a></span>Master_channel_req_ptr</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;schema::MqType S_MQ_TYPE_OR_NONE, bool S_TRANSMIT_NATIVE_HANDLES, typename Mdt_payload , schema::ShmType S_SHM_TYPE_OR_NONE&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classipc_1_1session_1_1Client__session__impl.html">ipc::session::Client_session_impl</a>&lt; S_MQ_TYPE_OR_NONE, S_TRANSMIT_NATIVE_HANDLES, Mdt_payload, S_SHM_TYPE_OR_NONE &gt;::Master_channel_req_ptr =  boost::shared_ptr&lt;<a class="el" href="structipc_1_1session_1_1Client__session__impl_1_1Master__channel__req.html">Master_channel_req</a>&gt;</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Short-hand for ref-counted pointer to <a class="el" href="structipc_1_1session_1_1Client__session__impl_1_1Master__channel__req.html" title="An open-channel/log-in request out-message.">Master_channel_req</a>. </p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="structipc_1_1session_1_1Client__session__impl_1_1Master__channel__req.html" title="An open-channel/log-in request out-message.">Master_channel_req</a> doc header for info on the true nature of such <code>shared_ptr</code> as returned by us. </dd></dl>

<p class="definition">Definition at line <a class="el" href="ipc__session_2src_2ipc_2session_2detail_2client__session__impl_8hpp_source.html#l00456">456</a> of file <a class="el" href="ipc__session_2src_2ipc_2session_2detail_2client__session__impl_8hpp_source.html">client_session_impl.hpp</a>.</p>

</div>
</div>
<a id="adf598b765af3aa2fe0a2f3ead176477b" name="adf598b765af3aa2fe0a2f3ead176477b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adf598b765af3aa2fe0a2f3ead176477b">&#9670;&nbsp;</a></span>Master_structured_channel</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;schema::MqType S_MQ_TYPE_OR_NONE, bool S_TRANSMIT_NATIVE_HANDLES, typename Mdt_payload , schema::ShmType S_SHM_TYPE_OR_NONE&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classipc_1_1session_1_1Client__session__impl.html">ipc::session::Client_session_impl</a>&lt; S_MQ_TYPE_OR_NONE, S_TRANSMIT_NATIVE_HANDLES, Mdt_payload, S_SHM_TYPE_OR_NONE &gt;::Master_structured_channel =  typename <a class="el" href="classipc_1_1session_1_1Session__base.html#a26d038e14e3c0e461e76de88c4ce76c5">Base::Master_structured_channel</a></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>See <a class="el" href="classipc_1_1session_1_1Session__base.html" title="Internal type containing data and types common to internal types Server_session_impl and Client_sessi...">Session_base</a>. </p>

<p class="definition">Definition at line <a class="el" href="ipc__session_2src_2ipc_2session_2detail_2client__session__impl_8hpp_source.html#l00273">273</a> of file <a class="el" href="ipc__session_2src_2ipc_2session_2detail_2client__session__impl_8hpp_source.html">client_session_impl.hpp</a>.</p>

</div>
</div>
<a id="a3c26cfd7f21dc449db1a104277cef700" name="a3c26cfd7f21dc449db1a104277cef700"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3c26cfd7f21dc449db1a104277cef700">&#9670;&nbsp;</a></span>Master_structured_channel_observer</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;schema::MqType S_MQ_TYPE_OR_NONE, bool S_TRANSMIT_NATIVE_HANDLES, typename Mdt_payload , schema::ShmType S_SHM_TYPE_OR_NONE&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classipc_1_1session_1_1Client__session__impl.html">ipc::session::Client_session_impl</a>&lt; S_MQ_TYPE_OR_NONE, S_TRANSMIT_NATIVE_HANDLES, Mdt_payload, S_SHM_TYPE_OR_NONE &gt;::Master_structured_channel_observer =  typename <a class="el" href="classipc_1_1session_1_1Session__base.html#ae2a123b29dd044a638e94d1f294c8f28">Base::Master_structured_channel_observer</a></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>See <a class="el" href="classipc_1_1session_1_1Session__base.html" title="Internal type containing data and types common to internal types Server_session_impl and Client_sessi...">Session_base</a>. </p>

<p class="definition">Definition at line <a class="el" href="ipc__session_2src_2ipc_2session_2detail_2client__session__impl_8hpp_source.html#l00377">377</a> of file <a class="el" href="ipc__session_2src_2ipc_2session_2detail_2client__session__impl_8hpp_source.html">client_session_impl.hpp</a>.</p>

</div>
</div>
<a id="a2a2960c4707475bab5d33b65bab9ba75" name="a2a2960c4707475bab5d33b65bab9ba75"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2a2960c4707475bab5d33b65bab9ba75">&#9670;&nbsp;</a></span>Master_structured_channel_ptr</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;schema::MqType S_MQ_TYPE_OR_NONE, bool S_TRANSMIT_NATIVE_HANDLES, typename Mdt_payload , schema::ShmType S_SHM_TYPE_OR_NONE&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classipc_1_1session_1_1Client__session__impl.html">ipc::session::Client_session_impl</a>&lt; S_MQ_TYPE_OR_NONE, S_TRANSMIT_NATIVE_HANDLES, Mdt_payload, S_SHM_TYPE_OR_NONE &gt;::Master_structured_channel_ptr =  typename <a class="el" href="classipc_1_1session_1_1Session__base.html#af0ca2a01d7d0d92038aae56fc1cdd505">Base::Master_structured_channel_ptr</a></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>See <a class="el" href="classipc_1_1session_1_1Session__base.html" title="Internal type containing data and types common to internal types Server_session_impl and Client_sessi...">Session_base</a>. </p>

<p class="definition">Definition at line <a class="el" href="ipc__session_2src_2ipc_2session_2detail_2client__session__impl_8hpp_source.html#l00374">374</a> of file <a class="el" href="ipc__session_2src_2ipc_2session_2detail_2client__session__impl_8hpp_source.html">client_session_impl.hpp</a>.</p>

</div>
</div>
<a id="aec1f6670627bf8fc5b148b19a6faa9cf" name="aec1f6670627bf8fc5b148b19a6faa9cf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aec1f6670627bf8fc5b148b19a6faa9cf">&#9670;&nbsp;</a></span>Mdt_builder</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;schema::MqType S_MQ_TYPE_OR_NONE, bool S_TRANSMIT_NATIVE_HANDLES, typename Mdt_payload , schema::ShmType S_SHM_TYPE_OR_NONE&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classipc_1_1session_1_1Client__session__impl.html">ipc::session::Client_session_impl</a>&lt; S_MQ_TYPE_OR_NONE, S_TRANSMIT_NATIVE_HANDLES, Mdt_payload, S_SHM_TYPE_OR_NONE &gt;::Mdt_builder =  typename <a class="el" href="classipc_1_1session_1_1Session__base.html#a7d68bbb8c0c09983619d563bca30bd45">Base::Mdt_builder</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>See <a class="el" href="classipc_1_1session_1_1Client__session__mv.html" title="Implements Session concept on the Client_app end: a Session_mv that first achieves PEER state by conn...">Client_session_mv</a> counterpart. </p>

<p class="definition">Definition at line <a class="el" href="ipc__session_2src_2ipc_2session_2detail_2client__session__impl_8hpp_source.html#l00125">125</a> of file <a class="el" href="ipc__session_2src_2ipc_2session_2detail_2client__session__impl_8hpp_source.html">client_session_impl.hpp</a>.</p>

</div>
</div>
<a id="a5d391e86ccc1153b4975efdc8e5401e4" name="a5d391e86ccc1153b4975efdc8e5401e4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5d391e86ccc1153b4975efdc8e5401e4">&#9670;&nbsp;</a></span>Mdt_builder_ptr</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;schema::MqType S_MQ_TYPE_OR_NONE, bool S_TRANSMIT_NATIVE_HANDLES, typename Mdt_payload , schema::ShmType S_SHM_TYPE_OR_NONE&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classipc_1_1session_1_1Client__session__impl.html">ipc::session::Client_session_impl</a>&lt; S_MQ_TYPE_OR_NONE, S_TRANSMIT_NATIVE_HANDLES, Mdt_payload, S_SHM_TYPE_OR_NONE &gt;::Mdt_builder_ptr =  typename <a class="el" href="classipc_1_1session_1_1Session__base.html#a4a7a5b83f6ba8bd505685636eabc012b">Base::Mdt_builder_ptr</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>See <a class="el" href="classipc_1_1session_1_1Client__session__mv.html" title="Implements Session concept on the Client_app end: a Session_mv that first achieves PEER state by conn...">Client_session_mv</a> counterpart. </p>

<p class="definition">Definition at line <a class="el" href="ipc__session_2src_2ipc_2session_2detail_2client__session__impl_8hpp_source.html#l00128">128</a> of file <a class="el" href="ipc__session_2src_2ipc_2session_2detail_2client__session__impl_8hpp_source.html">client_session_impl.hpp</a>.</p>

</div>
</div>
<a id="a3e6259ce0f762ce44f161818640db0c6" name="a3e6259ce0f762ce44f161818640db0c6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3e6259ce0f762ce44f161818640db0c6">&#9670;&nbsp;</a></span>Mdt_payload_obj</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;schema::MqType S_MQ_TYPE_OR_NONE, bool S_TRANSMIT_NATIVE_HANDLES, typename Mdt_payload , schema::ShmType S_SHM_TYPE_OR_NONE&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classipc_1_1session_1_1Client__session__impl.html">ipc::session::Client_session_impl</a>&lt; S_MQ_TYPE_OR_NONE, S_TRANSMIT_NATIVE_HANDLES, Mdt_payload, S_SHM_TYPE_OR_NONE &gt;::Mdt_payload_obj =  typename <a class="el" href="classipc_1_1session_1_1Session__base.html#a35234981ca87cc2f6b118b3e52452ea8">Base::Mdt_payload_obj</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>See <a class="el" href="classipc_1_1session_1_1Client__session__mv.html" title="Implements Session concept on the Client_app end: a Session_mv that first achieves PEER state by conn...">Client_session_mv</a> counterpart. </p>

<p class="definition">Definition at line <a class="el" href="ipc__session_2src_2ipc_2session_2detail_2client__session__impl_8hpp_source.html#l00119">119</a> of file <a class="el" href="ipc__session_2src_2ipc_2session_2detail_2client__session__impl_8hpp_source.html">client_session_impl.hpp</a>.</p>

</div>
</div>
<a id="a2cc5b77dd2367cc8e821fdcab7f6c109" name="a2cc5b77dd2367cc8e821fdcab7f6c109"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2cc5b77dd2367cc8e821fdcab7f6c109">&#9670;&nbsp;</a></span>Mdt_reader_ptr</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;schema::MqType S_MQ_TYPE_OR_NONE, bool S_TRANSMIT_NATIVE_HANDLES, typename Mdt_payload , schema::ShmType S_SHM_TYPE_OR_NONE&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classipc_1_1session_1_1Client__session__impl.html">ipc::session::Client_session_impl</a>&lt; S_MQ_TYPE_OR_NONE, S_TRANSMIT_NATIVE_HANDLES, Mdt_payload, S_SHM_TYPE_OR_NONE &gt;::Mdt_reader_ptr =  typename <a class="el" href="classipc_1_1session_1_1Session__base.html#ace4dab42adec6354cc66081dd218ac71">Base::Mdt_reader_ptr</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>See <a class="el" href="classipc_1_1session_1_1Client__session__mv.html" title="Implements Session concept on the Client_app end: a Session_mv that first achieves PEER state by conn...">Client_session_mv</a> counterpart. </p>

<p class="definition">Definition at line <a class="el" href="ipc__session_2src_2ipc_2session_2detail_2client__session__impl_8hpp_source.html#l00122">122</a> of file <a class="el" href="ipc__session_2src_2ipc_2session_2detail_2client__session__impl_8hpp_source.html">client_session_impl.hpp</a>.</p>

</div>
</div>
<a id="a801b5883e969a12a844fe85f581ab01d" name="a801b5883e969a12a844fe85f581ab01d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a801b5883e969a12a844fe85f581ab01d">&#9670;&nbsp;</a></span>On_passive_open_channel_func</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;schema::MqType S_MQ_TYPE_OR_NONE, bool S_TRANSMIT_NATIVE_HANDLES, typename Mdt_payload , schema::ShmType S_SHM_TYPE_OR_NONE&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classipc_1_1session_1_1Client__session__impl.html">ipc::session::Client_session_impl</a>&lt; S_MQ_TYPE_OR_NONE, S_TRANSMIT_NATIVE_HANDLES, Mdt_payload, S_SHM_TYPE_OR_NONE &gt;::On_passive_open_channel_func =  typename <a class="el" href="classipc_1_1session_1_1Session__base.html#a3c0824a54ef32915c5c5ea76481f2409">Base::On_passive_open_channel_func</a></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>See <a class="el" href="classipc_1_1session_1_1Session__base.html" title="Internal type containing data and types common to internal types Server_session_impl and Client_sessi...">Session_base</a>. </p>

<p class="definition">Definition at line <a class="el" href="ipc__session_2src_2ipc_2session_2detail_2client__session__impl_8hpp_source.html#l00383">383</a> of file <a class="el" href="ipc__session_2src_2ipc_2session_2detail_2client__session__impl_8hpp_source.html">client_session_impl.hpp</a>.</p>

</div>
</div>
<a id="a7d38f0ec6408a5ed6b3eef661f1f0894" name="a7d38f0ec6408a5ed6b3eef661f1f0894"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7d38f0ec6408a5ed6b3eef661f1f0894">&#9670;&nbsp;</a></span>Persistent_mq_handle_from_cfg</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;schema::MqType S_MQ_TYPE_OR_NONE, bool S_TRANSMIT_NATIVE_HANDLES, typename Mdt_payload , schema::ShmType S_SHM_TYPE_OR_NONE&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classipc_1_1session_1_1Client__session__impl.html">ipc::session::Client_session_impl</a>&lt; S_MQ_TYPE_OR_NONE, S_TRANSMIT_NATIVE_HANDLES, Mdt_payload, S_SHM_TYPE_OR_NONE &gt;::Persistent_mq_handle_from_cfg =  typename <a class="el" href="classipc_1_1session_1_1Session__base.html#a848c0f5247644ada0f8b0ab816eedda8">Base::Persistent_mq_handle_from_cfg</a></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>See <a class="el" href="classipc_1_1session_1_1Session__base.html" title="Internal type containing data and types common to internal types Server_session_impl and Client_sessi...">Session_base</a>. </p>

<p class="definition">Definition at line <a class="el" href="ipc__session_2src_2ipc_2session_2detail_2client__session__impl_8hpp_source.html#l00380">380</a> of file <a class="el" href="ipc__session_2src_2ipc_2session_2detail_2client__session__impl_8hpp_source.html">client_session_impl.hpp</a>.</p>

</div>
</div>
<a id="a8942fcefa7654708f863946fc467f875" name="a8942fcefa7654708f863946fc467f875"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8942fcefa7654708f863946fc467f875">&#9670;&nbsp;</a></span>Session_base_obj</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;schema::MqType S_MQ_TYPE_OR_NONE, bool S_TRANSMIT_NATIVE_HANDLES, typename Mdt_payload , schema::ShmType S_SHM_TYPE_OR_NONE&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classipc_1_1session_1_1Client__session__impl.html">ipc::session::Client_session_impl</a>&lt; S_MQ_TYPE_OR_NONE, S_TRANSMIT_NATIVE_HANDLES, Mdt_payload, S_SHM_TYPE_OR_NONE &gt;::Session_base_obj =  <a class="el" href="classipc_1_1session_1_1Client__session__impl.html#a1bc8c5b0a277261799062827992efbea">Base</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Short-hand for <a class="el" href="classipc_1_1session_1_1Session__base.html" title="Internal type containing data and types common to internal types Server_session_impl and Client_sessi...">Session_base</a> super-class. </p>

<p class="definition">Definition at line <a class="el" href="ipc__session_2src_2ipc_2session_2detail_2client__session__impl_8hpp_source.html#l00110">110</a> of file <a class="el" href="ipc__session_2src_2ipc_2session_2detail_2client__session__impl_8hpp_source.html">client_session_impl.hpp</a>.</p>

</div>
</div>
<a id="ae93393f13b3f9f05179d3334a607b26e" name="ae93393f13b3f9f05179d3334a607b26e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae93393f13b3f9f05179d3334a607b26e">&#9670;&nbsp;</a></span>Structured_msg_builder_config</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;schema::MqType S_MQ_TYPE_OR_NONE, bool S_TRANSMIT_NATIVE_HANDLES, typename Mdt_payload , schema::ShmType S_SHM_TYPE_OR_NONE&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classipc_1_1session_1_1Client__session__impl.html">ipc::session::Client_session_impl</a>&lt; S_MQ_TYPE_OR_NONE, S_TRANSMIT_NATIVE_HANDLES, Mdt_payload, S_SHM_TYPE_OR_NONE &gt;::Structured_msg_builder_config =  typename <a class="el" href="classipc_1_1session_1_1Session__base.html#aee0db48505c84d3553b7110a9a815036">Base::Structured_msg_builder_config</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>See <a class="el" href="classipc_1_1session_1_1Session__mv.html" title="Implements the Session concept when it is in PEER state.">Session_mv</a> counterpart. </p>

<p class="definition">Definition at line <a class="el" href="ipc__session_2src_2ipc_2session_2detail_2client__session__impl_8hpp_source.html#l00131">131</a> of file <a class="el" href="ipc__session_2src_2ipc_2session_2detail_2client__session__impl_8hpp_source.html">client_session_impl.hpp</a>.</p>

</div>
</div>
<a id="ae3d2416929234a32dd7d1f5532af549f" name="ae3d2416929234a32dd7d1f5532af549f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae3d2416929234a32dd7d1f5532af549f">&#9670;&nbsp;</a></span>Structured_msg_reader_config</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;schema::MqType S_MQ_TYPE_OR_NONE, bool S_TRANSMIT_NATIVE_HANDLES, typename Mdt_payload , schema::ShmType S_SHM_TYPE_OR_NONE&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classipc_1_1session_1_1Client__session__impl.html">ipc::session::Client_session_impl</a>&lt; S_MQ_TYPE_OR_NONE, S_TRANSMIT_NATIVE_HANDLES, Mdt_payload, S_SHM_TYPE_OR_NONE &gt;::Structured_msg_reader_config =  typename <a class="el" href="classipc_1_1session_1_1Session__base.html#abd854f2b9316361ef18f15610c242d4b">Base::Structured_msg_reader_config</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>See <a class="el" href="classipc_1_1session_1_1Session__mv.html" title="Implements the Session concept when it is in PEER state.">Session_mv</a> counterpart. </p>

<p class="definition">Definition at line <a class="el" href="ipc__session_2src_2ipc_2session_2detail_2client__session__impl_8hpp_source.html#l00134">134</a> of file <a class="el" href="ipc__session_2src_2ipc_2session_2detail_2client__session__impl_8hpp_source.html">client_session_impl.hpp</a>.</p>

</div>
</div>
<h2 class="groupheader">Member Enumeration Documentation</h2>
<a id="af7a951bd266bdd0e3339a0fbddba9e8b" name="af7a951bd266bdd0e3339a0fbddba9e8b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af7a951bd266bdd0e3339a0fbddba9e8b">&#9670;&nbsp;</a></span>State</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;schema::MqType S_MQ_TYPE_OR_NONE, bool S_TRANSMIT_NATIVE_HANDLES, typename Mdt_payload , schema::ShmType S_SHM_TYPE_OR_NONE&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">enum class <a class="el" href="classipc_1_1session_1_1Client__session__impl.html#af7a951bd266bdd0e3339a0fbddba9e8b">ipc::session::Client_session_impl::State</a></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">strong</span><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Overall state of a <a class="el" href="classipc_1_1session_1_1Client__session__impl.html" title="Internal, non-movable pImpl-lite implementation of Client_session_mv class template.">Client_session_impl</a>. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="af7a951bd266bdd0e3339a0fbddba9e8bac6bd7568063494695099321f427efcb2" name="af7a951bd266bdd0e3339a0fbddba9e8bac6bd7568063494695099321f427efcb2"></a>S_NULL&#160;</td><td class="fielddoc"><p >Not a peer. </p>
<p >Initial state; goes to CONNECTING (via <a class="el" href="classipc_1_1session_1_1Client__session__impl.html#af03a9fca2006fba2cc522efa1178e83e" title="See Client_session_mv counterpart.">async_connect()</a>). Only <a class="el" href="classipc_1_1session_1_1Client__session__impl.html#af03a9fca2006fba2cc522efa1178e83e" title="See Client_session_mv counterpart.">async_connect()</a> is possible in this state (other public mutators return immediately). </p>
</td></tr>
<tr><td class="fieldname"><a id="af7a951bd266bdd0e3339a0fbddba9e8baae585d03fce4ac2011967830bf0ffbfb" name="af7a951bd266bdd0e3339a0fbddba9e8baae585d03fce4ac2011967830bf0ffbfb"></a>S_CONNECTING&#160;</td><td class="fielddoc"><p >Not a peer but <a class="el" href="classipc_1_1session_1_1Client__session__impl.html#af03a9fca2006fba2cc522efa1178e83e" title="See Client_session_mv counterpart.">async_connect()</a> in progress to try to make it a peer. </p>
<p >Entry from NULL; goes to PEER or NULL. No public mutating methods are possible in this state (they return immediately). </p>
</td></tr>
<tr><td class="fieldname"><a id="af7a951bd266bdd0e3339a0fbddba9e8bad9a05d721258c584cd559c56fd035887" name="af7a951bd266bdd0e3339a0fbddba9e8bad9a05d721258c584cd559c56fd035887"></a>S_PEER&#160;</td><td class="fielddoc"><p >Is or was a connected peer. </p>
<p >Entry from CONNECTING; does not transition to any other state (once a PEER, always a PEER). <a class="el" href="classipc_1_1session_1_1Client__session__impl.html#af03a9fca2006fba2cc522efa1178e83e" title="See Client_session_mv counterpart.">async_connect()</a> is not possible in this state (it returns immediately); all other mutating public methods are possible. </p>
</td></tr>
</table>

<p class="definition">Definition at line <a class="el" href="ipc__session_2src_2ipc_2session_2detail_2client__session__impl_8hpp_source.html#l00386">386</a> of file <a class="el" href="ipc__session_2src_2ipc_2session_2detail_2client__session__impl_8hpp_source.html">client_session_impl.hpp</a>.</p>

</div>
</div>
<h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="ae43a93e3a573beb5f66f12420393b857" name="ae43a93e3a573beb5f66f12420393b857"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae43a93e3a573beb5f66f12420393b857">&#9670;&nbsp;</a></span>Client_session_impl() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;schema::MqType S_MQ_TYPE_OR_NONE, bool S_TRANSMIT_NATIVE_HANDLES, typename Mdt_payload , schema::ShmType S_SHM_TYPE_OR_NONE&gt; </div>
<div class="memtemplate">
template&lt;typename On_passive_open_channel_handler , typename Task_err &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classipc_1_1session_1_1Client__session__impl.html">ipc::session::Client_session_impl</a>&lt; S_MQ_TYPE_OR_NONE, S_TRANSMIT_NATIVE_HANDLES, Mdt_payload, S_SHM_TYPE_OR_NONE &gt;::Client_session_impl </td>
          <td>(</td>
          <td class="paramtype">flow::log::Logger *&#160;</td>
          <td class="paramname"><em>logger_ptr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structipc_1_1session_1_1Client__app.html">Client_app</a> &amp;&#160;</td>
          <td class="paramname"><em>cli_app_ref</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structipc_1_1session_1_1Server__app.html">Server_app</a> &amp;&#160;</td>
          <td class="paramname"><em>srv_app_ref</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Task_err &amp;&amp;&#160;</td>
          <td class="paramname"><em>on_err_func</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">On_passive_open_channel_handler &amp;&amp;&#160;</td>
          <td class="paramname"><em>on_passive_open_channel_func</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">explicit</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>See <a class="el" href="classipc_1_1session_1_1Client__session__mv.html" title="Implements Session concept on the Client_app end: a Session_mv that first achieves PEER state by conn...">Client_session_mv</a> counterpart. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">logger_ptr</td><td>See <a class="el" href="classipc_1_1session_1_1Client__session__mv.html" title="Implements Session concept on the Client_app end: a Session_mv that first achieves PEER state by conn...">Client_session_mv</a> counterpart. </td></tr>
    <tr><td class="paramname">cli_app_ref</td><td>See <a class="el" href="classipc_1_1session_1_1Client__session__mv.html" title="Implements Session concept on the Client_app end: a Session_mv that first achieves PEER state by conn...">Client_session_mv</a> counterpart. </td></tr>
    <tr><td class="paramname">srv_app_ref</td><td>See <a class="el" href="classipc_1_1session_1_1Client__session__mv.html" title="Implements Session concept on the Client_app end: a Session_mv that first achieves PEER state by conn...">Client_session_mv</a> counterpart. </td></tr>
    <tr><td class="paramname">on_err_func</td><td>See <a class="el" href="classipc_1_1session_1_1Client__session__mv.html" title="Implements Session concept on the Client_app end: a Session_mv that first achieves PEER state by conn...">Client_session_mv</a> counterpart. </td></tr>
    <tr><td class="paramname">on_passive_open_channel_func</td><td>See <a class="el" href="classipc_1_1session_1_1Client__session__mv.html" title="Implements Session concept on the Client_app end: a Session_mv that first achieves PEER state by conn...">Client_session_mv</a> counterpart. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="ipc__session_2src_2ipc_2session_2detail_2client__session__impl_8hpp_source.html#l00754">754</a> of file <a class="el" href="ipc__session_2src_2ipc_2session_2detail_2client__session__impl_8hpp_source.html">client_session_impl.hpp</a>.</p>

</div>
</div>
<a id="a44e1af36f971cb682ca52bc569204b80" name="a44e1af36f971cb682ca52bc569204b80"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a44e1af36f971cb682ca52bc569204b80">&#9670;&nbsp;</a></span>Client_session_impl() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;schema::MqType S_MQ_TYPE_OR_NONE, bool S_TRANSMIT_NATIVE_HANDLES, typename Mdt_payload , schema::ShmType S_SHM_TYPE_OR_NONE&gt; </div>
<div class="memtemplate">
template&lt;typename Task_err &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classipc_1_1session_1_1Client__session__impl.html">ipc::session::Client_session_impl</a>&lt; S_MQ_TYPE_OR_NONE, S_TRANSMIT_NATIVE_HANDLES, Mdt_payload, S_SHM_TYPE_OR_NONE &gt;::Client_session_impl </td>
          <td>(</td>
          <td class="paramtype">flow::log::Logger *&#160;</td>
          <td class="paramname"><em>logger_ptr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structipc_1_1session_1_1Client__app.html">Client_app</a> &amp;&#160;</td>
          <td class="paramname"><em>cli_app_ref</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structipc_1_1session_1_1Server__app.html">Server_app</a> &amp;&#160;</td>
          <td class="paramname"><em>srv_app_ref</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Task_err &amp;&amp;&#160;</td>
          <td class="paramname"><em>on_err_func</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">explicit</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>See <a class="el" href="classipc_1_1session_1_1Client__session__mv.html" title="Implements Session concept on the Client_app end: a Session_mv that first achieves PEER state by conn...">Client_session_mv</a> counterpart. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">logger_ptr</td><td>See <a class="el" href="classipc_1_1session_1_1Client__session__mv.html" title="Implements Session concept on the Client_app end: a Session_mv that first achieves PEER state by conn...">Client_session_mv</a> counterpart. </td></tr>
    <tr><td class="paramname">cli_app_ref</td><td>See <a class="el" href="classipc_1_1session_1_1Client__session__mv.html" title="Implements Session concept on the Client_app end: a Session_mv that first achieves PEER state by conn...">Client_session_mv</a> counterpart. </td></tr>
    <tr><td class="paramname">srv_app_ref</td><td>See <a class="el" href="classipc_1_1session_1_1Client__session__mv.html" title="Implements Session concept on the Client_app end: a Session_mv that first achieves PEER state by conn...">Client_session_mv</a> counterpart. </td></tr>
    <tr><td class="paramname">on_err_func</td><td>See <a class="el" href="classipc_1_1session_1_1Client__session__mv.html" title="Implements Session concept on the Client_app end: a Session_mv that first achieves PEER state by conn...">Client_session_mv</a> counterpart. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="ipc__session_2src_2ipc_2session_2detail_2client__session__impl_8hpp_source.html#l00767">767</a> of file <a class="el" href="ipc__session_2src_2ipc_2session_2detail_2client__session__impl_8hpp_source.html">client_session_impl.hpp</a>.</p>

</div>
</div>
<a id="a45c22f131543ca25adc0cdcb608ddb1f" name="a45c22f131543ca25adc0cdcb608ddb1f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a45c22f131543ca25adc0cdcb608ddb1f">&#9670;&nbsp;</a></span>~Client_session_impl()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;schema::MqType S_MQ_TYPE_OR_NONE, bool S_TRANSMIT_NATIVE_HANDLES, typename Mdt_payload , schema::ShmType S_SHM_TYPE_OR_NONE&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classipc_1_1session_1_1Client__session__impl.html">ipc::session::Client_session_impl</a>&lt; S_MQ_TYPE_OR_NONE, S_TRANSMIT_NATIVE_HANDLES, Mdt_payload, S_SHM_TYPE_OR_NONE &gt;::~<a class="el" href="classipc_1_1session_1_1Client__session__impl.html">Client_session_impl</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>See <a class="el" href="classipc_1_1session_1_1Client__session__mv.html" title="Implements Session concept on the Client_app end: a Session_mv that first achieves PEER state by conn...">Client_session_mv</a> counterpart. </p>

<p class="definition">Definition at line <a class="el" href="ipc__session_2src_2ipc_2session_2detail_2client__session__impl_8hpp_source.html#l00830">830</a> of file <a class="el" href="ipc__session_2src_2ipc_2session_2detail_2client__session__impl_8hpp_source.html">client_session_impl.hpp</a>.</p>

<p class="reference">References <a class="el" href="namespaceipc_1_1session_1_1error.html#a0708d4bec9ae853f4d7e3d7822fc8f2fafe29343445a7bf167cc186a44bd2c6ed">ipc::session::error::S_OBJECT_SHUTDOWN_ABORTED_COMPLETION_HANDLER</a>.</p>

</div>
</div>
<a id="a6db7a1f722663528520775e6c8a65c61" name="a6db7a1f722663528520775e6c8a65c61"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6db7a1f722663528520775e6c8a65c61">&#9670;&nbsp;</a></span>Client_session_impl() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;schema::MqType S_MQ_TYPE_OR_NONE, bool S_TRANSMIT_NATIVE_HANDLES, typename Mdt_payload , schema::ShmType S_SHM_TYPE_OR_NONE&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classipc_1_1session_1_1Client__session__impl.html">ipc::session::Client_session_impl</a>&lt; S_MQ_TYPE_OR_NONE, S_TRANSMIT_NATIVE_HANDLES, Mdt_payload, S_SHM_TYPE_OR_NONE &gt;::Client_session_impl </td>
          <td>(</td>
          <td class="paramtype">flow::log::Logger *&#160;</td>
          <td class="paramname"><em>logger_ptr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structipc_1_1session_1_1Client__app.html">Client_app</a> &amp;&#160;</td>
          <td class="paramname"><em>cli_app_ref</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structipc_1_1session_1_1Server__app.html">Server_app</a> &amp;&#160;</td>
          <td class="paramname"><em>srv_app_ref</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">flow::async::Task_asio_err &amp;&amp;&#160;</td>
          <td class="paramname"><em>on_err_func</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classipc_1_1session_1_1Client__session__impl.html#a801b5883e969a12a844fe85f581ab01d">On_passive_open_channel_func</a> &amp;&amp;&#160;</td>
          <td class="paramname"><em>on_passive_open_channel_func_or_empty_arg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::nullptr_t&#160;</td>
          <td class="paramname"><em>tag</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">explicit</span><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Delegated-to ctor that implements both non-default <code>public</code> ctors. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">logger_ptr</td><td>See public ctors. </td></tr>
    <tr><td class="paramname">cli_app_ref</td><td>See public ctors. </td></tr>
    <tr><td class="paramname">srv_app_ref</td><td>See public ctors. </td></tr>
    <tr><td class="paramname">on_err_func</td><td>See public ctors. This is the concretely-typed version of that arg. </td></tr>
    <tr><td class="paramname">on_passive_open_channel_func_or_empty_arg</td><td>See public ctors. This is the concretely-typed version of that arg; <code>.empty()</code> if the version without this arg was used. </td></tr>
    <tr><td class="paramname">tag</td><td>Ctor-selecting tag. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="ipc__session_2src_2ipc_2session_2detail_2client__session__impl_8hpp_source.html#l00731">731</a> of file <a class="el" href="ipc__session_2src_2ipc_2session_2detail_2client__session__impl_8hpp_source.html">client_session_impl.hpp</a>.</p>

<p class="reference">References <a class="el" href="ipc__session_2src_2ipc_2session_2detail_2client__session__impl_8hpp_source.html#l00693">ipc::session::Client_session_impl&lt; S_MQ_TYPE_OR_NONE, S_TRANSMIT_NATIVE_HANDLES, Mdt_payload, S_SHM_TYPE_OR_NONE &gt;::m_async_worker</a>.</p>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="adebedf1cbe09067a8f785a524e146b2f" name="adebedf1cbe09067a8f785a524e146b2f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adebedf1cbe09067a8f785a524e146b2f">&#9670;&nbsp;</a></span>async_connect() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;schema::MqType S_MQ_TYPE_OR_NONE, bool S_TRANSMIT_NATIVE_HANDLES, typename Mdt_payload , schema::ShmType S_SHM_TYPE_OR_NONE&gt; </div>
<div class="memtemplate">
template&lt;typename Task_err &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classipc_1_1session_1_1Client__session__impl.html">ipc::session::Client_session_impl</a>&lt; S_MQ_TYPE_OR_NONE, S_TRANSMIT_NATIVE_HANDLES, Mdt_payload, S_SHM_TYPE_OR_NONE &gt;::async_connect </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classipc_1_1session_1_1Client__session__impl.html#a5d391e86ccc1153b4975efdc8e5401e4">Mdt_builder_ptr</a> &amp;&#160;</td>
          <td class="paramname"><em>mdt</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classipc_1_1session_1_1Client__session__impl.html#a48487e4c98ae3a82ef344269742c8057">Channels</a> *&#160;</td>
          <td class="paramname"><em>init_channels_by_cli_req_pre_sized</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classipc_1_1session_1_1Client__session__impl.html#a2cc5b77dd2367cc8e821fdcab7f6c109">Mdt_reader_ptr</a> *&#160;</td>
          <td class="paramname"><em>mdt_from_srv_or_null</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classipc_1_1session_1_1Client__session__impl.html#a48487e4c98ae3a82ef344269742c8057">Channels</a> *&#160;</td>
          <td class="paramname"><em>init_channels_by_srv_req</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Task_err &amp;&amp;&#160;</td>
          <td class="paramname"><em>on_done_func</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>See <a class="el" href="classipc_1_1session_1_1Client__session__mv.html" title="Implements Session concept on the Client_app end: a Session_mv that first achieves PEER state by conn...">Client_session_mv</a> counterpart. </p>
<dl class="section return"><dt>Returns</dt><dd>See <a class="el" href="classipc_1_1session_1_1Client__session__mv.html" title="Implements Session concept on the Client_app end: a Session_mv that first achieves PEER state by conn...">Client_session_mv</a> counterpart.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">mdt</td><td>See <a class="el" href="classipc_1_1session_1_1Client__session__mv.html" title="Implements Session concept on the Client_app end: a Session_mv that first achieves PEER state by conn...">Client_session_mv</a> counterpart. </td></tr>
    <tr><td class="paramname">init_channels_by_cli_req_pre_sized</td><td>See <a class="el" href="classipc_1_1session_1_1Client__session__mv.html" title="Implements Session concept on the Client_app end: a Session_mv that first achieves PEER state by conn...">Client_session_mv</a> counterpart. </td></tr>
    <tr><td class="paramname">mdt_from_srv_or_null</td><td>See <a class="el" href="classipc_1_1session_1_1Client__session__mv.html" title="Implements Session concept on the Client_app end: a Session_mv that first achieves PEER state by conn...">Client_session_mv</a> counterpart. </td></tr>
    <tr><td class="paramname">init_channels_by_srv_req</td><td>See <a class="el" href="classipc_1_1session_1_1Client__session__mv.html" title="Implements Session concept on the Client_app end: a Session_mv that first achieves PEER state by conn...">Client_session_mv</a> counterpart. </td></tr>
    <tr><td class="paramname">on_done_func</td><td>See <a class="el" href="classipc_1_1session_1_1Client__session__mv.html" title="Implements Session concept on the Client_app end: a Session_mv that first achieves PEER state by conn...">Client_session_mv</a> counterpart. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="ipc__session_2src_2ipc_2session_2detail_2client__session__impl_8hpp_source.html#l00879">879</a> of file <a class="el" href="ipc__session_2src_2ipc_2session_2detail_2client__session__impl_8hpp_source.html">client_session_impl.hpp</a>.</p>

<p class="reference">References <a class="el" href="shared__name_8hpp_source.html#l00674">ipc::util::Shared_name::ct()</a>, <a class="el" href="ipc__session_2src_2ipc_2session_2detail_2client__session__impl_8hpp_source.html#l00449">ipc::session::Client_session_impl&lt; S_MQ_TYPE_OR_NONE, S_TRANSMIT_NATIVE_HANDLES, Mdt_payload, S_SHM_TYPE_OR_NONE &gt;::Master_channel_req::m_req_msg</a>, <a class="el" href="util_8hpp_source.html#l00034">ipc::util::op_with_possible_bipc_exception()</a>, <a class="el" href="ipc__core_2src_2ipc_2util_2util_8cpp_source.html#l00030">ipc::util::OPEN_OR_CREATE</a>, <a class="el" href="namespaceipc_1_1session_1_1error.html#a0708d4bec9ae853f4d7e3d7822fc8f2fa486f5607320d062fe89e559a1e7856b2">ipc::session::error::S_CLIENT_NAMESPACE_STORE_BAD_FORMAT</a>, <a class="el" href="namespaceipc_1_1session_1_1error.html#a0708d4bec9ae853f4d7e3d7822fc8f2fa7300721595cc25baa9a9e43bd76296aa">ipc::session::error::S_MUTEX_BIPC_MISC_LIBRARY_ERROR</a>, <a class="el" href="namespaceipc_1_1transport_1_1error.html#adfef15ef4e76cc55d652fbd9c2797297afe29343445a7bf167cc186a44bd2c6ed">ipc::transport::error::S_OBJECT_SHUTDOWN_ABORTED_COMPLETION_HANDLER</a>, and <a class="el" href="ipc__core_2src_2ipc_2util_2util_8cpp_source.html#l00037">ipc::util::shared_resource_permissions()</a>.</p>
<div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="classipc_1_1session_1_1Client__session__impl_adebedf1cbe09067a8f785a524e146b2f_cgraph.svg" width="360" height="180"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe>
</div>
</div>

</div>
</div>
<a id="af03a9fca2006fba2cc522efa1178e83e" name="af03a9fca2006fba2cc522efa1178e83e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af03a9fca2006fba2cc522efa1178e83e">&#9670;&nbsp;</a></span>async_connect() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;schema::MqType S_MQ_TYPE_OR_NONE, bool S_TRANSMIT_NATIVE_HANDLES, typename Mdt_payload , schema::ShmType S_SHM_TYPE_OR_NONE&gt; </div>
<div class="memtemplate">
template&lt;typename Task_err &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classipc_1_1session_1_1Client__session__impl.html">ipc::session::Client_session_impl</a>&lt; S_MQ_TYPE_OR_NONE, S_TRANSMIT_NATIVE_HANDLES, Mdt_payload, S_SHM_TYPE_OR_NONE &gt;::async_connect </td>
          <td>(</td>
          <td class="paramtype">Task_err &amp;&amp;&#160;</td>
          <td class="paramname"><em>on_done_func</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>See <a class="el" href="classipc_1_1session_1_1Client__session__mv.html" title="Implements Session concept on the Client_app end: a Session_mv that first achieves PEER state by conn...">Client_session_mv</a> counterpart. </p>
<dl class="section return"><dt>Returns</dt><dd>See <a class="el" href="classipc_1_1session_1_1Client__session__mv.html" title="Implements Session concept on the Client_app end: a Session_mv that first achieves PEER state by conn...">Client_session_mv</a> counterpart.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">on_done_func</td><td>See <a class="el" href="classipc_1_1session_1_1Client__session__mv.html" title="Implements Session concept on the Client_app end: a Session_mv that first achieves PEER state by conn...">Client_session_mv</a> counterpart. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="ipc__session_2src_2ipc_2session_2detail_2client__session__impl_8hpp_source.html#l00872">872</a> of file <a class="el" href="ipc__session_2src_2ipc_2session_2detail_2client__session__impl_8hpp_source.html">client_session_impl.hpp</a>.</p>

</div>
</div>
<a id="a01deaa0719df7e73e205dd1bfba35abf" name="a01deaa0719df7e73e205dd1bfba35abf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a01deaa0719df7e73e205dd1bfba35abf">&#9670;&nbsp;</a></span>async_worker()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;schema::MqType S_MQ_TYPE_OR_NONE, bool S_TRANSMIT_NATIVE_HANDLES, typename Mdt_payload , schema::ShmType S_SHM_TYPE_OR_NONE&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">flow::async::Single_thread_task_loop * <a class="el" href="classipc_1_1session_1_1Client__session__impl.html">ipc::session::Client_session_impl</a>&lt; S_MQ_TYPE_OR_NONE, S_TRANSMIT_NATIVE_HANDLES, Mdt_payload, S_SHM_TYPE_OR_NONE &gt;::async_worker</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Utility for sub-classes: provides ability to schedule or post tasks onto thread W. </p>
<dl class="section return"><dt>Returns</dt><dd>See above. </dd></dl>

<p class="definition">Definition at line <a class="el" href="ipc__session_2src_2ipc_2session_2detail_2client__session__impl_8hpp_source.html#l02290">2290</a> of file <a class="el" href="ipc__session_2src_2ipc_2session_2detail_2client__session__impl_8hpp_source.html">client_session_impl.hpp</a>.</p>

</div>
</div>
<a id="addcd3cf7a3c21221bf032686782feb03" name="addcd3cf7a3c21221bf032686782feb03"></a>
<h2 class="memtitle"><span class="permalink"><a href="#addcd3cf7a3c21221bf032686782feb03">&#9670;&nbsp;</a></span>cancel_peer_state_to_connecting()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;schema::MqType S_MQ_TYPE_OR_NONE, bool S_TRANSMIT_NATIVE_HANDLES, typename Mdt_payload , schema::ShmType S_SHM_TYPE_OR_NONE&gt; </div>
<div class="memtemplate">
template&lt;typename Task_err &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classipc_1_1session_1_1Client__session__impl.html">Client_session_impl</a>&lt; S_MQ_TYPE_OR_NONE, S_TRANSMIT_NATIVE_HANDLES, Mdt_payload, S_SHM_TYPE_OR_NONE &gt;<a class="el" href="classipc_1_1session_1_1Client__session__impl.html#adf598b765af3aa2fe0a2f3ead176477b">::Master_structured_channel</a> * <a class="el" href="classipc_1_1session_1_1Client__session__impl.html">ipc::session::Client_session_impl</a>&lt; S_MQ_TYPE_OR_NONE, S_TRANSMIT_NATIVE_HANDLES, Mdt_payload, S_SHM_TYPE_OR_NONE &gt;::cancel_peer_state_to_connecting </td>
          <td>(</td>
          <td class="paramtype">Task_err &amp;&amp;&#160;</td>
          <td class="paramname"><em>on_done_func</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Utility for sub-classes: executed from <a class="el" href="classipc_1_1session_1_1Client__session__impl.html#af03a9fca2006fba2cc522efa1178e83e" title="See Client_session_mv counterpart.">async_connect()</a>'s <code>on_done_func(Error_code())</code> (i.e., directly from handler invoked on success) &ndash; hence from thread W &ndash; this instead goes back to CONNECTING state, essentially indicating "yes, the vanilla <a class="el" href="classipc_1_1session_1_1Client__session__impl.html#af03a9fca2006fba2cc522efa1178e83e" title="See Client_session_mv counterpart.">async_connect()</a> succeeded, but the true user-called <a class="el" href="classipc_1_1session_1_1Client__session__impl.html#af03a9fca2006fba2cc522efa1178e83e" title="See Client_session_mv counterpart.">async_connect()</a> that piggybacked on the vanilla one will now do some more async stuff before reaching PEER state (or NULL on error). </p>
<p >"</p>
<p >As <code>on_done_func</code> was already invoked (and thus forgotten), the caller must supply a new one to execute once either PEER or NULL state is reached again. Since <code>*this</code> has completed its vanilla <a class="el" href="classipc_1_1session_1_1Client__session__impl.html#af03a9fca2006fba2cc522efa1178e83e" title="See Client_session_mv counterpart.">async_connect()</a> work already, the responsibility for reaching one of those 2 states is now on the caller. Therefore whatever async processing follows our invocation is required to call <a class="el" href="classipc_1_1session_1_1Client__session__impl.html#a2e871ae9e633e48bc02dd62600722c15" title="Utility for sub-classes: to be invoked, only from thread W and asynchronously at that,...">complete_async_connect_after_canceling_peer_state()</a>. That said, if a master-session-channel error occurs before that has a chance to be called, then:</p><ul>
<li><code>*this</code> will enter NULL state itself.</li>
<li><code>*this</code> will invoke the handler supplied here to <a class="el" href="classipc_1_1session_1_1Client__session__impl.html#addcd3cf7a3c21221bf032686782feb03" title="Utility for sub-classes: executed from async_connect()&#39;s on_done_func(Error_code()) (i....">cancel_peer_state_to_connecting()</a>.</li>
</ul>
<p >The session master channel is returned, so that the sub-class can take over operation as needed until either <a class="el" href="classipc_1_1session_1_1Client__session__impl.html#a2e871ae9e633e48bc02dd62600722c15" title="Utility for sub-classes: to be invoked, only from thread W and asynchronously at that,...">complete_async_connect_after_canceling_peer_state()</a> or that channel becoming hosed (either way on_done_func() will be invoked). This avoids providing unrestricted <code>protected</code> access to it all times. See also <a class="el" href="classipc_1_1session_1_1Client__session__impl.html#a01deaa0719df7e73e205dd1bfba35abf" title="Utility for sub-classes: provides ability to schedule or post tasks onto thread W.">async_worker()</a>.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Task_err</td><td>See <a class="el" href="classipc_1_1session_1_1Client__session__impl.html#af03a9fca2006fba2cc522efa1178e83e" title="See Client_session_mv counterpart.">async_connect()</a>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">on_done_func</td><td>See <a class="el" href="classipc_1_1session_1_1Client__session__impl.html#af03a9fca2006fba2cc522efa1178e83e" title="See Client_session_mv counterpart.">async_connect()</a>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>See above. </dd></dl>

<p class="definition">Definition at line <a class="el" href="ipc__session_2src_2ipc_2session_2detail_2client__session__impl_8hpp_source.html#l02243">2243</a> of file <a class="el" href="ipc__session_2src_2ipc_2session_2detail_2client__session__impl_8hpp_source.html">client_session_impl.hpp</a>.</p>

</div>
</div>
<a id="ad84c75d7233fcaaab287ed405a267df2" name="ad84c75d7233fcaaab287ed405a267df2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad84c75d7233fcaaab287ed405a267df2">&#9670;&nbsp;</a></span>cancel_peer_state_to_null()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;schema::MqType S_MQ_TYPE_OR_NONE, bool S_TRANSMIT_NATIVE_HANDLES, typename Mdt_payload , schema::ShmType S_SHM_TYPE_OR_NONE&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classipc_1_1session_1_1Client__session__impl.html">ipc::session::Client_session_impl</a>&lt; S_MQ_TYPE_OR_NONE, S_TRANSMIT_NATIVE_HANDLES, Mdt_payload, S_SHM_TYPE_OR_NONE &gt;::cancel_peer_state_to_null</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Utility for sub-classes: executed from <a class="el" href="classipc_1_1session_1_1Client__session__impl.html#af03a9fca2006fba2cc522efa1178e83e" title="See Client_session_mv counterpart.">async_connect()</a>'s <code>on_done_func(Error_code())</code> (i.e., directly from handler invoked on success) &ndash; hence from thread W &ndash; this instead goes back to NULL state, essentially indicating "never mind -- this successful async_connect() actually failed.". </p>
<p >This... um... highly specific utility is intended for overriding <a class="el" href="classipc_1_1session_1_1Client__session__impl.html#af03a9fca2006fba2cc522efa1178e83e" title="See Client_session_mv counterpart.">async_connect()</a> impl that performs <em>synchronous</em> post-processing in its own <code>on_done_func()</code> wrapper from sub-class's <a class="el" href="classipc_1_1session_1_1Client__session__impl.html#af03a9fca2006fba2cc522efa1178e83e" title="See Client_session_mv counterpart.">async_connect()</a> that calls this class's <a class="el" href="classipc_1_1session_1_1Client__session__impl.html#af03a9fca2006fba2cc522efa1178e83e" title="See Client_session_mv counterpart.">async_connect()</a>. </p>

<p class="definition">Definition at line <a class="el" href="ipc__session_2src_2ipc_2session_2detail_2client__session__impl_8hpp_source.html#l02224">2224</a> of file <a class="el" href="ipc__session_2src_2ipc_2session_2detail_2client__session__impl_8hpp_source.html">client_session_impl.hpp</a>.</p>

</div>
</div>
<a id="a2e871ae9e633e48bc02dd62600722c15" name="a2e871ae9e633e48bc02dd62600722c15"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2e871ae9e633e48bc02dd62600722c15">&#9670;&nbsp;</a></span>complete_async_connect_after_canceling_peer_state()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;schema::MqType S_MQ_TYPE_OR_NONE, bool S_TRANSMIT_NATIVE_HANDLES, typename Mdt_payload , schema::ShmType S_SHM_TYPE_OR_NONE&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classipc_1_1session_1_1Client__session__impl.html">ipc::session::Client_session_impl</a>&lt; S_MQ_TYPE_OR_NONE, S_TRANSMIT_NATIVE_HANDLES, Mdt_payload, S_SHM_TYPE_OR_NONE &gt;::complete_async_connect_after_canceling_peer_state </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespaceipc.html#aa3192e586cc45d3e7c22463bf2760f89">Error_code</a> &amp;&#160;</td>
          <td class="paramname"><em>err_code_or_success</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Utility for sub-classes: to be invoked, only from thread W and asynchronously at that, after <a class="el" href="classipc_1_1session_1_1Client__session__impl.html#addcd3cf7a3c21221bf032686782feb03" title="Utility for sub-classes: executed from async_connect()&#39;s on_done_func(Error_code()) (i....">cancel_peer_state_to_connecting()</a>, this indicates the completion of the sub-class's additional async-connect steps, setting state to either NULL or PEER. </p>
<p >Invoke only in CONNECTING state; else undefined behavior (assertion may trip).</p>
<p >The handler given to <a class="el" href="classipc_1_1session_1_1Client__session__impl.html#addcd3cf7a3c21221bf032686782feb03" title="Utility for sub-classes: executed from async_connect()&#39;s on_done_func(Error_code()) (i....">cancel_peer_state_to_connecting()</a> will execute.</p>
<p >Take care to check <a class="el" href="classipc_1_1session_1_1Session__base.html#a398f3e6a30b3fae8e110af9fd1ff75e3" title="Returns true if and only if hose() has been called.">Session_base::hosed()</a> as needed before calling this; if hosed then do not call.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">err_code_or_success</td><td>State will proceed to PEER if falsy else to NULL; in the latter case the given code shall be passed to handler as the reason for failure to ultimately async-connect. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="ipc__session_2src_2ipc_2session_2detail_2client__session__impl_8hpp_source.html#l02262">2262</a> of file <a class="el" href="ipc__session_2src_2ipc_2session_2detail_2client__session__impl_8hpp_source.html">client_session_impl.hpp</a>.</p>

</div>
</div>
<a id="acaacff906e2eb50f48d1b04a64247649" name="acaacff906e2eb50f48d1b04a64247649"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acaacff906e2eb50f48d1b04a64247649">&#9670;&nbsp;</a></span>conn_on_async_connect_or_error()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;schema::MqType S_MQ_TYPE_OR_NONE, bool S_TRANSMIT_NATIVE_HANDLES, typename Mdt_payload , schema::ShmType S_SHM_TYPE_OR_NONE&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classipc_1_1session_1_1Client__session__impl.html">ipc::session::Client_session_impl</a>&lt; S_MQ_TYPE_OR_NONE, S_TRANSMIT_NATIVE_HANDLES, Mdt_payload, S_SHM_TYPE_OR_NONE &gt;::conn_on_async_connect_or_error </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespaceipc_1_1session.html#a6d07d9996af19e57eb42416e914110ea">Shared_name</a> &amp;&#160;</td>
          <td class="paramname"><em>acc_name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classipc_1_1transport_1_1Native__socket__stream.html">transport::Native_socket_stream</a> &amp;&amp;&#160;</td>
          <td class="paramname"><em>sock_stm</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classipc_1_1session_1_1Client__session__impl.html#a5d391e86ccc1153b4975efdc8e5401e4">Mdt_builder_ptr</a> &amp;&amp;&#160;</td>
          <td class="paramname"><em>mdt</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classipc_1_1session_1_1Client__session__impl.html#a48487e4c98ae3a82ef344269742c8057">Channels</a> *&#160;</td>
          <td class="paramname"><em>init_channels_by_cli_req_pre_sized</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classipc_1_1session_1_1Client__session__impl.html#a2cc5b77dd2367cc8e821fdcab7f6c109">Mdt_reader_ptr</a> *&#160;</td>
          <td class="paramname"><em>mdt_from_srv_or_null</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classipc_1_1session_1_1Client__session__impl.html#a48487e4c98ae3a82ef344269742c8057">Channels</a> *&#160;</td>
          <td class="paramname"><em>init_channels_by_srv_req</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespaceipc.html#aa3192e586cc45d3e7c22463bf2760f89">Error_code</a> &amp;&#160;</td>
          <td class="paramname"><em>async_err_code</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>In thread W, handler for the <a class="el" href="classipc_1_1transport_1_1Native__socket__stream.html#a3614a9677c1a203090b97ac935093390" title="To be invoked in NULL state only, it asynchronously attempts to connect to an opposing Native_socket_...">transport::Native_socket_stream::async_connect()</a>, as invoked in CONNECTING state. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">acc_name</td><td><a class="el" href="classipc_1_1transport_1_1Native__socket__stream__acceptor.html" title="A server object that binds to a Shared_name and listens for incoming Native_socket_stream::*_connect(...">transport::Native_socket_stream_acceptor</a> address (for logging). </td></tr>
    <tr><td class="paramname">sock_stm</td><td>The target <code>Native_socket_stream</code>. In PEER state if <code>!async_err_code</code>; else in NULL state still. </td></tr>
    <tr><td class="paramname">mdt</td><td>See advanced <a class="el" href="classipc_1_1session_1_1Client__session__impl.html#af03a9fca2006fba2cc522efa1178e83e" title="See Client_session_mv counterpart.">async_connect()</a> overload. </td></tr>
    <tr><td class="paramname">init_channels_by_cli_req_pre_sized</td><td>See advanced <a class="el" href="classipc_1_1session_1_1Client__session__impl.html#af03a9fca2006fba2cc522efa1178e83e" title="See Client_session_mv counterpart.">async_connect()</a> overload. </td></tr>
    <tr><td class="paramname">mdt_from_srv_or_null</td><td>See advanced <a class="el" href="classipc_1_1session_1_1Client__session__impl.html#af03a9fca2006fba2cc522efa1178e83e" title="See Client_session_mv counterpart.">async_connect()</a> overload. </td></tr>
    <tr><td class="paramname">init_channels_by_srv_req</td><td>See advanced <a class="el" href="classipc_1_1session_1_1Client__session__impl.html#af03a9fca2006fba2cc522efa1178e83e" title="See Client_session_mv counterpart.">async_connect()</a> overload. </td></tr>
    <tr><td class="paramname">async_err_code</td><td>Result of the <code><a class="el" href="classipc_1_1session_1_1Client__session__impl.html#af03a9fca2006fba2cc522efa1178e83e" title="See Client_session_mv counterpart.">async_connect()</a></code> from <a class="el" href="namespaceipc_1_1transport.html" title="Flow-IPC module providing transmission of structured messages and/or low-level blobs (and more) betwe...">ipc::transport</a>. Not operation-aborted. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="ipc__session_2src_2ipc_2session_2detail_2client__session__impl_8hpp_source.html#l01137">1137</a> of file <a class="el" href="ipc__session_2src_2ipc_2session_2detail_2client__session__impl_8hpp_source.html">client_session_impl.hpp</a>.</p>

<p class="reference">References <a class="el" href="process__credentials_8cpp_source.html#l00136">ipc::util::Process_credentials::own_group_id()</a>, <a class="el" href="process__credentials_8cpp_source.html#l00126">ipc::util::Process_credentials::own_process_id()</a>, <a class="el" href="process__credentials_8cpp_source.html#l00131">ipc::util::Process_credentials::own_user_id()</a>, <a class="el" href="ipc__core_2src_2ipc_2transport_2channel_8hpp_source.html#l02211">ipc::transport::Socket_stream_channel&lt; SIO &gt;::remote_peer_process_credentials()</a>, and <a class="el" href="channel__base_8hpp_source.html#l00157">ipc::transport::struc::Channel_base::S_SERIALIZE_VIA_HEAP</a>.</p>
<div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="classipc_1_1session_1_1Client__session__impl_acaacff906e2eb50f48d1b04a64247649_cgraph.svg" width="396" height="240"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe>
</div>
</div>

</div>
</div>
<a id="a224dd90df35537680e649f74e427d47d" name="a224dd90df35537680e649f74e427d47d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a224dd90df35537680e649f74e427d47d">&#9670;&nbsp;</a></span>create_channel_obj()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;schema::MqType S_MQ_TYPE_OR_NONE, bool S_TRANSMIT_NATIVE_HANDLES, typename Mdt_payload , schema::ShmType S_SHM_TYPE_OR_NONE&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classipc_1_1session_1_1Client__session__impl.html">ipc::session::Client_session_impl</a>&lt; S_MQ_TYPE_OR_NONE, S_TRANSMIT_NATIVE_HANDLES, Mdt_payload, S_SHM_TYPE_OR_NONE &gt;::create_channel_obj </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespaceipc_1_1session.html#a6d07d9996af19e57eb42416e914110ea">Shared_name</a> &amp;&#160;</td>
          <td class="paramname"><em>mq_name_c2s_or_none</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespaceipc_1_1session.html#a6d07d9996af19e57eb42416e914110ea">Shared_name</a> &amp;&#160;</td>
          <td class="paramname"><em>mq_name_s2c_or_none</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structipc_1_1util_1_1Native__handle.html">util::Native_handle</a> &amp;&amp;&#160;</td>
          <td class="paramname"><em>local_hndl_or_null</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classipc_1_1session_1_1Client__session__impl.html#a418a1e70b7b51833cc9d24d1046e3526">Channel_obj</a> *&#160;</td>
          <td class="paramname"><em>opened_channel_ptr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>active_else_passive</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceipc.html#aa3192e586cc45d3e7c22463bf2760f89">Error_code</a> *&#160;</td>
          <td class="paramname"><em>err_code_ptr</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>In thread W, based on resources acquired on server side, creates local <a class="el" href="classipc_1_1session_1_1Client__session__impl.html#a418a1e70b7b51833cc9d24d1046e3526" title="See Client_session_mv counterpart.">Channel_obj</a> to emit to the user thus completing a channel-open. </p>
<p >If active-open on our part, we do this upon receiving server response to our open-channel-to-server request. If passive-open, we do this upon receiving server's open-channel-to-client request, before replying with our OK. Either way the in-message from server contained the handle(s) to the resource(s) it acquired for this channel; these are args to this method.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">mq_name_c2s_or_none</td><td>If <a class="el" href="classipc_1_1session_1_1Client__session__impl.html#a3541a8e1f4192c3fd6647827507440dd" title="See Client_session_mv counterpart.">S_MQS_ENABLED</a> this is the (non-empty) name of the client-&gt;server unidirectional MQ for the channel. Else empty/ignored. </td></tr>
    <tr><td class="paramname">mq_name_s2c_or_none</td><td>Like the preceding but opposite-direction (server-&gt;client). </td></tr>
    <tr><td class="paramname">local_hndl_or_null</td><td>If <a class="el" href="classipc_1_1session_1_1Client__session__impl.html#a921264bb66a3c1c2da679399f0bd59aa" title="See Client_session_mv counterpart.">S_SOCKET_STREAM_ENABLED</a> this is our pre-connected <code>Native_handle</code>; the server did <code>connect_pair()</code> and sent us 1/2 of the pair. Else null/ignored. </td></tr>
    <tr><td class="paramname">opened_channel_ptr</td><td>Target <a class="el" href="classipc_1_1session_1_1Client__session__impl.html#a418a1e70b7b51833cc9d24d1046e3526" title="See Client_session_mv counterpart.">Channel_obj</a> we shall try to move-to PEER state. It'll be left unmodified if error is emitted. </td></tr>
    <tr><td class="paramname">active_else_passive</td><td><code>true</code> if this is from <a class="el" href="classipc_1_1session_1_1Client__session__impl.html#a4229549db1093aaa1e7e84c6e6467e80" title="See Client_session_mv counterpart.">open_channel()</a>; <code>false</code> if from <a class="el" href="classipc_1_1session_1_1Client__session__impl.html#a9160d0684b8a1f39258d4a0b5a26a839" title="In thread W, handler for m_master_channel receiving a passive-open (a/k/a open-channel-to-client) req...">on_master_channel_open_channel_req()</a>. </td></tr>
    <tr><td class="paramname">err_code_ptr</td><td>Non-null pointer to <a class="el" href="namespaceipc.html#aa3192e586cc45d3e7c22463bf2760f89" title="Short-hand for boost.interprocess namespace.">Error_code</a>; deref shall be untouched on success (and must be falsy at entry); else deref shall be set to reason for failure. As of this writing the only possible path to failure is if <a class="el" href="classipc_1_1session_1_1Client__session__impl.html#a3541a8e1f4192c3fd6647827507440dd" title="See Client_session_mv counterpart.">S_MQS_ENABLED</a>, and we're unable to open an MQ handle or <a class="el" href="classipc_1_1transport_1_1Blob__stream__mq__sender.html" title="Implements Blob_sender concept by using an adopted Persistent_mq_handle MQ handle to an MQ (message q...">transport::Blob_stream_mq_sender</a> or <a class="el" href="classipc_1_1transport_1_1Blob__stream__mq__receiver.html" title="Implements Blob_receiver concept by using an adopted Persistent_mq_handle MQ handle to an MQ (message...">transport::Blob_stream_mq_receiver</a> to 1 of the MQs. This is highly unlikely, since the server was able to do it fine, but we leave it to caller to deal with the implications.</td></tr>
  </table>
  </dd>
</dl>
<dl class="todo"><dt><b><a class="el" href="todo.html#_todo000034">Todo:</a></b></dt><dd>As of this writing the eventuality where <a class="el" href="classipc_1_1session_1_1Client__session__impl.html#a224dd90df35537680e649f74e427d47d" title="In thread W, based on resources acquired on server side, creates local Channel_obj to emit to the use...">Client_session_impl::create_channel_obj()</a> yields an error is treated as assertion-trip-worthy by its caller; hence consider just tripping assertion inside instead and no out-arg. For now it is left this way in case we'd want the (internal) caller to do something more graceful in the future, and in the meantime it's a decently reusable chunk of code to use in that alleged contingency. </dd></dl>

<p class="definition">Definition at line <a class="el" href="ipc__session_2src_2ipc_2session_2detail_2client__session__impl_8hpp_source.html#l02110">2110</a> of file <a class="el" href="ipc__session_2src_2ipc_2session_2detail_2client__session__impl_8hpp_source.html">client_session_impl.hpp</a>.</p>

<p class="reference">References <a class="el" href="shared__name_8cpp_source.html#l00155">ipc::util::Shared_name::empty()</a>, and <a class="el" href="ipc__core_2src_2ipc_2util_2util_8cpp_source.html#l00031">ipc::util::OPEN_ONLY</a>.</p>
<div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="classipc_1_1session_1_1Client__session__impl_a224dd90df35537680e649f74e427d47d_cgraph.svg" width="346" height="59"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe>
</div>
</div>

</div>
</div>
<a id="ad6e279dc528e995d735611fedc26b347" name="ad6e279dc528e995d735611fedc26b347"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad6e279dc528e995d735611fedc26b347">&#9670;&nbsp;</a></span>dtor_async_worker_stop()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;schema::MqType S_MQ_TYPE_OR_NONE, bool S_TRANSMIT_NATIVE_HANDLES, typename Mdt_payload , schema::ShmType S_SHM_TYPE_OR_NONE&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classipc_1_1session_1_1Client__session__impl.html">ipc::session::Client_session_impl</a>&lt; S_MQ_TYPE_OR_NONE, S_TRANSMIT_NATIVE_HANDLES, Mdt_payload, S_SHM_TYPE_OR_NONE &gt;::dtor_async_worker_stop</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Synchronously stops <a class="el" href="classipc_1_1session_1_1Client__session__impl.html#a01deaa0719df7e73e205dd1bfba35abf" title="Utility for sub-classes: provides ability to schedule or post tasks onto thread W.">async_worker()</a> loop, the post-condition being that thread W has been joined; no tasks <code>post()</code>ed onto it by <code>*this</code> or subclass shall execute after this returns. </p>
<ul>
<li>If <code>*this</code> is not being subclassed, or if it never posts onto <a class="el" href="classipc_1_1session_1_1Client__session__impl.html#a01deaa0719df7e73e205dd1bfba35abf" title="Utility for sub-classes: provides ability to schedule or post tasks onto thread W.">async_worker()</a>: Our own dtor shall call this first-thing; no need for subclass to worry.</li>
<li>If <code>*this</code> is being subclassed, and it does post onto <a class="el" href="classipc_1_1session_1_1Client__session__impl.html#a01deaa0719df7e73e205dd1bfba35abf" title="Utility for sub-classes: provides ability to schedule or post tasks onto thread W.">async_worker()</a>: The terminal subclass's dtor must call this ~first-thing (our own dtor, once it is soon called, shall know not to re-execute the same thing).</li>
</ul>
<p >Call at most once; otherwise undefined behavior (assertion may trip).</p>
<p >This exists to avoid a race, however unlikely, between a subclass's asynchronous accept-log-in code posted onto thread W, and that same class's dtor being invoked by the user in thread U. There is a short time period, when thread W (<a class="el" href="classipc_1_1session_1_1Client__session__impl.html#aa7be8826b9256addf316ef407aa8bd76" title="Worker thread (a/k/a thread W).">m_async_worker</a>) is active &ndash; <code>*this</code> is still intact &ndash; but the subclass's members are being destroyed by its dtor. In that case <a class="el" href="classipc_1_1session_1_1Client__session__impl.html#ad6e279dc528e995d735611fedc26b347" title="Synchronously stops async_worker() loop, the post-condition being that thread W has been joined; no t...">dtor_async_worker_stop()</a> would be called by the subclass dtor to put an end to async shenanigans in thread W, so it cano continue destroying self in peace. When there is no subclass, our own dtor does so. </p>

<p class="definition">Definition at line <a class="el" href="ipc__session_2src_2ipc_2session_2detail_2client__session__impl_8hpp_source.html#l00778">778</a> of file <a class="el" href="ipc__session_2src_2ipc_2session_2detail_2client__session__impl_8hpp_source.html">client_session_impl.hpp</a>.</p>

</div>
</div>
<a id="a7aaccbdd0e823796e6cec233ac6134ec" name="a7aaccbdd0e823796e6cec233ac6134ec"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7aaccbdd0e823796e6cec233ac6134ec">&#9670;&nbsp;</a></span>invoke_conn_on_done_func()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;schema::MqType S_MQ_TYPE_OR_NONE, bool S_TRANSMIT_NATIVE_HANDLES, typename Mdt_payload , schema::ShmType S_SHM_TYPE_OR_NONE&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classipc_1_1session_1_1Client__session__impl.html">ipc::session::Client_session_impl</a>&lt; S_MQ_TYPE_OR_NONE, S_TRANSMIT_NATIVE_HANDLES, Mdt_payload, S_SHM_TYPE_OR_NONE &gt;::invoke_conn_on_done_func </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespaceipc.html#aa3192e586cc45d3e7c22463bf2760f89">Error_code</a> &amp;&#160;</td>
          <td class="paramname"><em>err_code</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Little helper that invokes <a class="el" href="classipc_1_1session_1_1Client__session__impl.html#a64ac1e72347053e73b125209a7756a1e" title="The on_done_func argument to async_connect(); .empty() except while in State::S_CONNECTING state.">m_conn_on_done_func_or_empty</a>, passing it <code>err_code</code>, and &ndash; per that member's internal use semantics &ndash; empties <a class="el" href="classipc_1_1session_1_1Client__session__impl.html#a64ac1e72347053e73b125209a7756a1e" title="The on_done_func argument to async_connect(); .empty() except while in State::S_CONNECTING state.">m_conn_on_done_func_or_empty</a>. </p>
<p >A key property is that the emptying occurs just <em>before</em> invoking it (obviously first saving it). This allows the handler to itself un-empty <a class="el" href="classipc_1_1session_1_1Client__session__impl.html#a64ac1e72347053e73b125209a7756a1e" title="The on_done_func argument to async_connect(); .empty() except while in State::S_CONNECTING state.">m_conn_on_done_func_or_empty</a>, as required by <a class="el" href="classipc_1_1session_1_1Client__session__impl.html#addcd3cf7a3c21221bf032686782feb03" title="Utility for sub-classes: executed from async_connect()&#39;s on_done_func(Error_code()) (i....">cancel_peer_state_to_connecting()</a> at least. (That, in turn, may be used by sub-classes that implement <a class="el" href="classipc_1_1session_1_1Client__session__impl.html#af03a9fca2006fba2cc522efa1178e83e" title="See Client_session_mv counterpart.">async_connect()</a> by piggybacking onto our vanilla one.)</p>
<p ><a class="el" href="classipc_1_1session_1_1Client__session__impl.html#a64ac1e72347053e73b125209a7756a1e" title="The on_done_func argument to async_connect(); .empty() except while in State::S_CONNECTING state.">m_conn_on_done_func_or_empty</a> must not be empty; or behavior is undefined.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">err_code</td><td>Arg to <code><a class="el" href="classipc_1_1session_1_1Client__session__impl.html#a64ac1e72347053e73b125209a7756a1e" title="The on_done_func argument to async_connect(); .empty() except while in State::S_CONNECTING state.">m_conn_on_done_func_or_empty()</a></code>. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="ipc__session_2src_2ipc_2session_2detail_2client__session__impl_8hpp_source.html#l01649">1649</a> of file <a class="el" href="ipc__session_2src_2ipc_2session_2detail_2client__session__impl_8hpp_source.html">client_session_impl.hpp</a>.</p>

</div>
</div>
<a id="ae2780708c51943c873d7054fcd91c451" name="ae2780708c51943c873d7054fcd91c451"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae2780708c51943c873d7054fcd91c451">&#9670;&nbsp;</a></span>master_channel_const()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;schema::MqType S_MQ_TYPE_OR_NONE, bool S_TRANSMIT_NATIVE_HANDLES, typename Mdt_payload , schema::ShmType S_SHM_TYPE_OR_NONE&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classipc_1_1session_1_1Client__session__impl.html">Client_session_impl</a>&lt; S_MQ_TYPE_OR_NONE, S_TRANSMIT_NATIVE_HANDLES, Mdt_payload, S_SHM_TYPE_OR_NONE &gt;<a class="el" href="classipc_1_1session_1_1Client__session__impl.html#adf598b765af3aa2fe0a2f3ead176477b">::Master_structured_channel</a> &amp; <a class="el" href="classipc_1_1session_1_1Client__session__impl.html">ipc::session::Client_session_impl</a>&lt; S_MQ_TYPE_OR_NONE, S_TRANSMIT_NATIVE_HANDLES, Mdt_payload, S_SHM_TYPE_OR_NONE &gt;::master_channel_const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Utility for sub-classes: provides ability to <em>immutably query</em> the session master channel, particularly after our async_accept_log_in() succeeds, but before the sub-classed wrapper of its on-done handler succeeds. </p>
<p >For example one can harmlessly query <a class="el" href="classipc_1_1transport_1_1struc_1_1Channel.html#a9a540a274df3bc7da8fc35ed2a2c1e57" title="Returns the (non-nil) logged-in session token; or nil if not in logged-in phase, or if a prior error ...">transport::struc::Channel::session_token()</a>.</p>
<p ><code>protected</code> but <code>const</code> access does not much bother me (ygoldfel) stylistically.</p>
<dl class="section return"><dt>Returns</dt><dd>See above. </dd></dl>

<p class="definition">Definition at line <a class="el" href="ipc__session_2src_2ipc_2session_2detail_2client__session__impl_8hpp_source.html#l02296">2296</a> of file <a class="el" href="ipc__session_2src_2ipc_2session_2detail_2client__session__impl_8hpp_source.html">client_session_impl.hpp</a>.</p>

</div>
</div>
<a id="ae37fe210e9809b4670b49e0d5b727d31" name="ae37fe210e9809b4670b49e0d5b727d31"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae37fe210e9809b4670b49e0d5b727d31">&#9670;&nbsp;</a></span>mdt_builder()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;schema::MqType S_MQ_TYPE_OR_NONE, bool S_TRANSMIT_NATIVE_HANDLES, typename Mdt_payload , schema::ShmType S_SHM_TYPE_OR_NONE&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classipc_1_1session_1_1Client__session__impl.html">Client_session_impl</a>&lt; S_MQ_TYPE_OR_NONE, S_TRANSMIT_NATIVE_HANDLES, Mdt_payload, S_SHM_TYPE_OR_NONE &gt;<a class="el" href="classipc_1_1session_1_1Client__session__impl.html#a5d391e86ccc1153b4975efdc8e5401e4">::Mdt_builder_ptr</a> <a class="el" href="classipc_1_1session_1_1Client__session__impl.html">ipc::session::Client_session_impl</a>&lt; S_MQ_TYPE_OR_NONE, S_TRANSMIT_NATIVE_HANDLES, Mdt_payload, S_SHM_TYPE_OR_NONE &gt;::mdt_builder</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>See <a class="el" href="classipc_1_1session_1_1Client__session__mv.html" title="Implements Session concept on the Client_app end: a Session_mv that first achieves PEER state by conn...">Client_session_mv</a> counterpart. </p>
<p >Reminder: it can be used not only in PEER state (for <a class="el" href="classipc_1_1session_1_1Client__session__impl.html#a4229549db1093aaa1e7e84c6e6467e80" title="See Client_session_mv counterpart.">open_channel()</a>) but also NULL state (for <a class="el" href="classipc_1_1session_1_1Client__session__impl.html#af03a9fca2006fba2cc522efa1178e83e" title="See Client_session_mv counterpart.">async_connect()</a>).</p>
<dl class="section return"><dt>Returns</dt><dd>See <a class="el" href="classipc_1_1session_1_1Client__session__mv.html" title="Implements Session concept on the Client_app end: a Session_mv that first achieves PEER state by conn...">Client_session_mv</a> counterpart. </dd></dl>

<p class="definition">Definition at line <a class="el" href="ipc__session_2src_2ipc_2session_2detail_2client__session__impl_8hpp_source.html#l01765">1765</a> of file <a class="el" href="ipc__session_2src_2ipc_2session_2detail_2client__session__impl_8hpp_source.html">client_session_impl.hpp</a>.</p>

<p class="reference">References <a class="el" href="sync__io_2native__socket__stream_8hpp_source.html#l00238">ipc::transport::sync_io::Native_socket_stream::S_MAX_META_BLOB_LENGTH</a>.</p>

</div>
</div>
<a id="a5d9ae1ffb0b776fc78aa8f3daf60918b" name="a5d9ae1ffb0b776fc78aa8f3daf60918b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5d9ae1ffb0b776fc78aa8f3daf60918b">&#9670;&nbsp;</a></span>on_master_channel_error()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;schema::MqType S_MQ_TYPE_OR_NONE, bool S_TRANSMIT_NATIVE_HANDLES, typename Mdt_payload , schema::ShmType S_SHM_TYPE_OR_NONE&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classipc_1_1session_1_1Client__session__impl.html">ipc::session::Client_session_impl</a>&lt; S_MQ_TYPE_OR_NONE, S_TRANSMIT_NATIVE_HANDLES, Mdt_payload, S_SHM_TYPE_OR_NONE &gt;::on_master_channel_error </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classipc_1_1session_1_1Client__session__impl.html#a3c26cfd7f21dc449db1a104277cef700">Master_structured_channel_observer</a> &amp;&#160;</td>
          <td class="paramname"><em>master_channel_observer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespaceipc.html#aa3192e586cc45d3e7c22463bf2760f89">Error_code</a> &amp;&#160;</td>
          <td class="paramname"><em>err_code</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>In thread W, handler for <a class="el" href="classipc_1_1session_1_1Client__session__impl.html#a5f526c4f9567f2529471dec9cd70f83c" title="The session master channel.">m_master_channel</a> indicating incoming-direction channel-hosing error. </p>
<p >It is possible that <a class="el" href="classipc_1_1session_1_1Client__session__impl.html#a5f526c4f9567f2529471dec9cd70f83c" title="The session master channel.">m_master_channel</a> has been <code>.reset()</code> in the meantime, by seeing log-in failure in <a class="el" href="classipc_1_1session_1_1Client__session__impl.html#ad3e5b51e17d2851b6deecedee67d8b50" title="In thread W, handler for the successful receipt of log-in response (upon send()ing the log-in request...">on_master_channel_log_in_rsp()</a>, and no longer exists. This is tested via the observer arg.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">master_channel_observer</td><td><code>weak_ptr</code> observer of <a class="el" href="classipc_1_1session_1_1Client__session__impl.html#a5f526c4f9567f2529471dec9cd70f83c" title="The session master channel.">m_master_channel</a> at the time it was constructed. <code>master_channel_observer.lock()</code> is either null (we've destroyed <a class="el" href="classipc_1_1session_1_1Client__session__impl.html#a5f526c4f9567f2529471dec9cd70f83c" title="The session master channel.">m_master_channel</a> due to another error condition) or equals <a class="el" href="classipc_1_1session_1_1Client__session__impl.html#a5f526c4f9567f2529471dec9cd70f83c" title="The session master channel.">m_master_channel</a>. </td></tr>
    <tr><td class="paramname">err_code</td><td>The non-success <a class="el" href="namespaceipc.html#aa3192e586cc45d3e7c22463bf2760f89" title="Short-hand for boost.interprocess namespace.">Error_code</a> from <code>struc::Channel</code>. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="ipc__session_2src_2ipc_2session_2detail_2client__session__impl_8hpp_source.html#l01664">1664</a> of file <a class="el" href="ipc__session_2src_2ipc_2session_2detail_2client__session__impl_8hpp_source.html">client_session_impl.hpp</a>.</p>

</div>
</div>
<a id="a908d037a1bc90800a60fe56a8dded67d" name="a908d037a1bc90800a60fe56a8dded67d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a908d037a1bc90800a60fe56a8dded67d">&#9670;&nbsp;</a></span>on_master_channel_init_open_channel()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;schema::MqType S_MQ_TYPE_OR_NONE, bool S_TRANSMIT_NATIVE_HANDLES, typename Mdt_payload , schema::ShmType S_SHM_TYPE_OR_NONE&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classipc_1_1session_1_1Client__session__impl.html">ipc::session::Client_session_impl</a>&lt; S_MQ_TYPE_OR_NONE, S_TRANSMIT_NATIVE_HANDLES, Mdt_payload, S_SHM_TYPE_OR_NONE &gt;::on_master_channel_init_open_channel </td>
          <td>(</td>
          <td class="paramtype">typename Master_structured_channel::Msg_in_ptr &amp;&amp;&#160;</td>
          <td class="paramname"><em>open_channel_msg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>n_init_channels</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const boost::shared_ptr&lt; <a class="el" href="classipc_1_1session_1_1Client__session__impl.html#a48487e4c98ae3a82ef344269742c8057">Channels</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>init_channels_ptr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classipc_1_1session_1_1Client__session__impl.html#a48487e4c98ae3a82ef344269742c8057">Channels</a> *&#160;</td>
          <td class="paramname"><em>init_channels_by_cli_req_pre_sized</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classipc_1_1session_1_1Client__session__impl.html#a2cc5b77dd2367cc8e821fdcab7f6c109">Mdt_reader_ptr</a> *&#160;</td>
          <td class="paramname"><em>mdt_from_srv_or_null</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classipc_1_1session_1_1Client__session__impl.html#a48487e4c98ae3a82ef344269742c8057">Channels</a> *&#160;</td>
          <td class="paramname"><em>init_channels_by_srv_req</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classipc_1_1session_1_1Client__session__impl.html#a2cc5b77dd2367cc8e821fdcab7f6c109">Mdt_reader_ptr</a> &amp;&amp;&#160;</td>
          <td class="paramname"><em>mdt_from_srv</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>In thread W, handler for <a class="el" href="classipc_1_1session_1_1Client__session__impl.html#a5f526c4f9567f2529471dec9cd70f83c" title="The session master channel.">m_master_channel</a> receiving a init-channel-open message. </p>
<p >This is similar to <a class="el" href="classipc_1_1session_1_1Client__session__impl.html#a9160d0684b8a1f39258d4a0b5a26a839" title="In thread W, handler for m_master_channel receiving a passive-open (a/k/a open-channel-to-client) req...">on_master_channel_open_channel_req()</a>, except:</p><ul>
<li>It occurs in CONNECTING state, after log-in, if server is required to open init-channels on our behalf or its behalf or both.</li>
<li>It uses the same in-message, but it is not treated as a request; rather just a notification of the info regarding 1 of the requested channels...</li>
<li>...except for the last one, which <em>is</em> treated as a request:<ul>
<li>we set up the regular passive-open-channel handler (<a class="el" href="classipc_1_1session_1_1Client__session__impl.html#a9160d0684b8a1f39258d4a0b5a26a839" title="In thread W, handler for m_master_channel receiving a passive-open (a/k/a open-channel-to-client) req...">on_master_channel_open_channel_req()</a>);</li>
<li>we move to PEER state (emit to <a class="el" href="classipc_1_1session_1_1Client__session__impl.html#a64ac1e72347053e73b125209a7756a1e" title="The on_done_func argument to async_connect(); .empty() except while in State::S_CONNECTING state.">m_conn_on_done_func_or_empty</a>);</li>
<li>we respond with an OK; so server knows it too can move to PEER state.<ul>
<li>If that <code>send()</code> fails we move to NULL instead of PEER state (still invoke on-connect-done handler).</li>
</ul>
</li>
</ul>
</li>
</ul>
<p >So this method is invoked <code>n_init_channels</code> times (assuming all goes well); and each time <code>*init_channels_ptr</code> grows by 1 element; once it is <code>n_init_channels</code> long &ndash; that's the last one, and we do those last 3 sub-bullet points.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">open_channel_msg</td><td>The in-message from <code>struc::Channel</code>. </td></tr>
    <tr><td class="paramname">n_init_channels</td><td>1+, the count of clients local <a class="el" href="classipc_1_1session_1_1Client__session__impl.html#af03a9fca2006fba2cc522efa1178e83e" title="See Client_session_mv counterpart.">async_connect()</a> requested plus same from opposing <code>async_accept()</code>. </td></tr>
    <tr><td class="paramname">init_channels_ptr</td><td>Intermediate PEER-state <a class="el" href="classipc_1_1session_1_1Client__session__impl.html#a418a1e70b7b51833cc9d24d1046e3526" title="See Client_session_mv counterpart.">Channel_obj</a> results list; first empty, next time with 1 elements, then 2, .... If <code>.size() == n_init_channels</code>, we shall move to PEER state. </td></tr>
    <tr><td class="paramname">init_channels_by_cli_req_pre_sized</td><td>See advanced <a class="el" href="classipc_1_1session_1_1Client__session__impl.html#af03a9fca2006fba2cc522efa1178e83e" title="See Client_session_mv counterpart.">async_connect()</a> overload. </td></tr>
    <tr><td class="paramname">mdt_from_srv_or_null</td><td>See advanced <a class="el" href="classipc_1_1session_1_1Client__session__impl.html#af03a9fca2006fba2cc522efa1178e83e" title="See Client_session_mv counterpart.">async_connect()</a> overload. </td></tr>
    <tr><td class="paramname">init_channels_by_srv_req</td><td>See advanced <a class="el" href="classipc_1_1session_1_1Client__session__impl.html#af03a9fca2006fba2cc522efa1178e83e" title="See Client_session_mv counterpart.">async_connect()</a> overload. </td></tr>
    <tr><td class="paramname">mdt_from_srv</td><td>Value to which to set <code>*mdt_from_srv_or_null</code>, if the latter is not null, and this is the last invocation of this method. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="ipc__session_2src_2ipc_2session_2detail_2client__session__impl_8hpp_source.html#l01499">1499</a> of file <a class="el" href="ipc__session_2src_2ipc_2session_2detail_2client__session__impl_8hpp_source.html">client_session_impl.hpp</a>.</p>

<p class="reference">References <a class="el" href="shared__name_8hpp_source.html#l00674">ipc::util::Shared_name::ct()</a>.</p>
<div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="classipc_1_1session_1_1Client__session__impl_a908d037a1bc90800a60fe56a8dded67d_cgraph.svg" width="398" height="59"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe>
</div>
</div>

</div>
</div>
<a id="ad3e5b51e17d2851b6deecedee67d8b50" name="ad3e5b51e17d2851b6deecedee67d8b50"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad3e5b51e17d2851b6deecedee67d8b50">&#9670;&nbsp;</a></span>on_master_channel_log_in_rsp()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;schema::MqType S_MQ_TYPE_OR_NONE, bool S_TRANSMIT_NATIVE_HANDLES, typename Mdt_payload , schema::ShmType S_SHM_TYPE_OR_NONE&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classipc_1_1session_1_1Client__session__impl.html">ipc::session::Client_session_impl</a>&lt; S_MQ_TYPE_OR_NONE, S_TRANSMIT_NATIVE_HANDLES, Mdt_payload, S_SHM_TYPE_OR_NONE &gt;::on_master_channel_log_in_rsp </td>
          <td>(</td>
          <td class="paramtype">typename Master_structured_channel::Msg_in_ptr &amp;&amp;&#160;</td>
          <td class="paramname"><em>log_in_rsp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classipc_1_1session_1_1Client__session__impl.html#a48487e4c98ae3a82ef344269742c8057">Channels</a> *&#160;</td>
          <td class="paramname"><em>init_channels_by_cli_req_pre_sized</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classipc_1_1session_1_1Client__session__impl.html#a2cc5b77dd2367cc8e821fdcab7f6c109">Mdt_reader_ptr</a> *&#160;</td>
          <td class="paramname"><em>mdt_from_srv_or_null</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classipc_1_1session_1_1Client__session__impl.html#a48487e4c98ae3a82ef344269742c8057">Channels</a> *&#160;</td>
          <td class="paramname"><em>init_channels_by_srv_req</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>In thread W, handler for the successful receipt of log-in response (upon <code>send()</code>ing the log-in request), as invoked in CONNECTING state only if the low-level <a class="el" href="classipc_1_1transport_1_1Native__socket__stream.html#a3614a9677c1a203090b97ac935093390" title="To be invoked in NULL state only, it asynchronously attempts to connect to an opposing Native_socket_...">transport::Native_socket_stream::async_connect()</a> succeeded. </p>
<p >Post-condition:</p><ul>
<li>If no init-channels requested by client (<a class="el" href="classipc_1_1session_1_1Client__session__impl.html#af03a9fca2006fba2cc522efa1178e83e" title="See Client_session_mv counterpart.">async_connect()</a> advanced overload) <em>nor</em> by server (as indicated in <code>log_in_rsp</code> itself): <a class="el" href="classipc_1_1session_1_1Client__session__impl.html#afd6871349fe71ab7a991bad2782421ba" title="The current state of *this.">m_state</a> changed from CONNECTING to either NULL or PEER, depending on whether the log-in response <code>log_in_rsp</code> indicates server side OKed the log-in. Per the invariant in <a class="el" href="classipc_1_1session_1_1Client__session__impl.html#a5f526c4f9567f2529471dec9cd70f83c" title="The session master channel.">m_master_channel</a> doc header: <a class="el" href="classipc_1_1session_1_1Client__session__impl.html#a5f526c4f9567f2529471dec9cd70f83c" title="The session master channel.">m_master_channel</a> is null (state became NULL) or non-null (state became PEER). In the former case <a class="el" href="classipc_1_1session_1_1Client__session__impl.html#af03a9fca2006fba2cc522efa1178e83e" title="See Client_session_mv counterpart.">async_connect()</a> can be attempted again.</li>
<li>Otherwise (if 1+ such channels, in total, requested): <a class="el" href="classipc_1_1session_1_1Client__session__impl.html#afd6871349fe71ab7a991bad2782421ba" title="The current state of *this.">m_state</a> unchanged from CONNECTING; <a class="el" href="classipc_1_1session_1_1Client__session__impl.html#a908d037a1bc90800a60fe56a8dded67d" title="In thread W, handler for m_master_channel receiving a init-channel-open message.">on_master_channel_init_open_channel()</a> shall be executed once per requested (by either side) init-channel generated by opposing server.<ul>
<li><a class="el" href="classipc_1_1session_1_1Client__session__impl.html#a908d037a1bc90800a60fe56a8dded67d" title="In thread W, handler for m_master_channel receiving a init-channel-open message.">on_master_channel_init_open_channel()</a> (the last one) shall move to PEER state in our stead.</li>
</ul>
</li>
</ul>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">log_in_rsp</td><td>The response in-message from <code>struc::Channel</code>. </td></tr>
    <tr><td class="paramname">init_channels_by_cli_req_pre_sized</td><td>See advanced <a class="el" href="classipc_1_1session_1_1Client__session__impl.html#af03a9fca2006fba2cc522efa1178e83e" title="See Client_session_mv counterpart.">async_connect()</a> overload. </td></tr>
    <tr><td class="paramname">mdt_from_srv_or_null</td><td>See advanced <a class="el" href="classipc_1_1session_1_1Client__session__impl.html#af03a9fca2006fba2cc522efa1178e83e" title="See Client_session_mv counterpart.">async_connect()</a> overload. </td></tr>
    <tr><td class="paramname">init_channels_by_srv_req</td><td>See advanced <a class="el" href="classipc_1_1session_1_1Client__session__impl.html#af03a9fca2006fba2cc522efa1178e83e" title="See Client_session_mv counterpart.">async_connect()</a> overload. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="ipc__session_2src_2ipc_2session_2detail_2client__session__impl_8hpp_source.html#l01301">1301</a> of file <a class="el" href="ipc__session_2src_2ipc_2session_2detail_2client__session__impl_8hpp_source.html">client_session_impl.hpp</a>.</p>

<p class="reference">References <a class="el" href="shared__name_8hpp_source.html#l00674">ipc::util::Shared_name::ct()</a>, <a class="el" href="namespaceipc_1_1session_1_1error.html#a0708d4bec9ae853f4d7e3d7822fc8f2fa866090a4d042120126722b4daf1ecc33">ipc::session::error::S_CLIENT_MASTER_LOG_IN_RESPONSE_BAD</a>, <a class="el" href="namespaceipc_1_1session_1_1error.html#a0708d4bec9ae853f4d7e3d7822fc8f2fac416e988563e44bf15fc6a81743eef53">ipc::session::error::S_INVALID_ARGUMENT</a>, and <a class="el" href="shared__name_8hpp_source.html#l00280">ipc::util::Shared_name::S_SENTINEL</a>.</p>
<div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="classipc_1_1session_1_1Client__session__impl_ad3e5b51e17d2851b6deecedee67d8b50_cgraph.svg" width="386" height="59"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe>
</div>
</div>

</div>
</div>
<a id="a9160d0684b8a1f39258d4a0b5a26a839" name="a9160d0684b8a1f39258d4a0b5a26a839"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9160d0684b8a1f39258d4a0b5a26a839">&#9670;&nbsp;</a></span>on_master_channel_open_channel_req()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;schema::MqType S_MQ_TYPE_OR_NONE, bool S_TRANSMIT_NATIVE_HANDLES, typename Mdt_payload , schema::ShmType S_SHM_TYPE_OR_NONE&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classipc_1_1session_1_1Client__session__impl.html">ipc::session::Client_session_impl</a>&lt; S_MQ_TYPE_OR_NONE, S_TRANSMIT_NATIVE_HANDLES, Mdt_payload, S_SHM_TYPE_OR_NONE &gt;::on_master_channel_open_channel_req </td>
          <td>(</td>
          <td class="paramtype">typename Master_structured_channel::Msg_in_ptr &amp;&amp;&#160;</td>
          <td class="paramname"><em>open_channel_req</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>In thread W, handler for <a class="el" href="classipc_1_1session_1_1Client__session__impl.html#a5f526c4f9567f2529471dec9cd70f83c" title="The session master channel.">m_master_channel</a> receiving a passive-open (a/k/a open-channel-to-client) request. </p>
<p >If there is no issue with this request, and we're able to sync-send the open-channel response to that effect, this shall fire on-passive-open handler, giving it a new <a class="el" href="classipc_1_1session_1_1Client__session__impl.html#a418a1e70b7b51833cc9d24d1046e3526" title="See Client_session_mv counterpart.">Channel_obj</a> in PEER state + metadata. If there is a problem, then it's not a session-hosing situation; local user is none-the-wiser; except that if the <code>send()</code> reveals a <em>new</em> error, then it is a session-hosing situation, and local user is informed via on-error handler.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">open_channel_req</td><td>The request in-message from <code>struc::Channel</code>. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="ipc__session_2src_2ipc_2session_2detail_2client__session__impl_8hpp_source.html#l01991">1991</a> of file <a class="el" href="ipc__session_2src_2ipc_2session_2detail_2client__session__impl_8hpp_source.html">client_session_impl.hpp</a>.</p>

<p class="reference">References <a class="el" href="shared__name_8hpp_source.html#l00674">ipc::util::Shared_name::ct()</a>.</p>
<div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="classipc_1_1session_1_1Client__session__impl_a9160d0684b8a1f39258d4a0b5a26a839_cgraph.svg" width="399" height="59"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe>
</div>
</div>

</div>
</div>
<a id="a4229549db1093aaa1e7e84c6e6467e80" name="a4229549db1093aaa1e7e84c6e6467e80"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4229549db1093aaa1e7e84c6e6467e80">&#9670;&nbsp;</a></span>open_channel() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;schema::MqType S_MQ_TYPE_OR_NONE, bool S_TRANSMIT_NATIVE_HANDLES, typename Mdt_payload , schema::ShmType S_SHM_TYPE_OR_NONE&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classipc_1_1session_1_1Client__session__impl.html">ipc::session::Client_session_impl</a>&lt; S_MQ_TYPE_OR_NONE, S_TRANSMIT_NATIVE_HANDLES, Mdt_payload, S_SHM_TYPE_OR_NONE &gt;::open_channel </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classipc_1_1session_1_1Client__session__impl.html#a418a1e70b7b51833cc9d24d1046e3526">Channel_obj</a> *&#160;</td>
          <td class="paramname"><em>target_channel</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classipc_1_1session_1_1Client__session__impl.html#a5d391e86ccc1153b4975efdc8e5401e4">Mdt_builder_ptr</a> &amp;&#160;</td>
          <td class="paramname"><em>mdt</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceipc.html#aa3192e586cc45d3e7c22463bf2760f89">Error_code</a> *&#160;</td>
          <td class="paramname"><em>err_code</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>See <a class="el" href="classipc_1_1session_1_1Client__session__mv.html" title="Implements Session concept on the Client_app end: a Session_mv that first achieves PEER state by conn...">Client_session_mv</a> counterpart. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">target_channel</td><td>See <a class="el" href="classipc_1_1session_1_1Client__session__mv.html" title="Implements Session concept on the Client_app end: a Session_mv that first achieves PEER state by conn...">Client_session_mv</a> counterpart. </td></tr>
    <tr><td class="paramname">mdt</td><td>See <a class="el" href="classipc_1_1session_1_1Client__session__mv.html" title="Implements Session concept on the Client_app end: a Session_mv that first achieves PEER state by conn...">Client_session_mv</a> counterpart. </td></tr>
    <tr><td class="paramname">err_code</td><td>See <a class="el" href="classipc_1_1session_1_1Client__session__mv.html" title="Implements Session concept on the Client_app end: a Session_mv that first achieves PEER state by conn...">Client_session_mv</a> counterpart. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>See <a class="el" href="classipc_1_1session_1_1Client__session__mv.html" title="Implements Session concept on the Client_app end: a Session_mv that first achieves PEER state by conn...">Client_session_mv</a> counterpart. </dd></dl>

<p class="definition">Definition at line <a class="el" href="ipc__session_2src_2ipc_2session_2detail_2client__session__impl_8hpp_source.html#l01818">1818</a> of file <a class="el" href="ipc__session_2src_2ipc_2session_2detail_2client__session__impl_8hpp_source.html">client_session_impl.hpp</a>.</p>

<p class="reference">References <a class="el" href="shared__name_8hpp_source.html#l00674">ipc::util::Shared_name::ct()</a>, <a class="el" href="ipc__session_2src_2ipc_2session_2detail_2client__session__impl_8hpp_source.html#l01818">ipc::session::Client_session_impl&lt; S_MQ_TYPE_OR_NONE, S_TRANSMIT_NATIVE_HANDLES, Mdt_payload, S_SHM_TYPE_OR_NONE &gt;::open_channel()</a>, <a class="el" href="namespaceipc_1_1session_1_1error.html#a0708d4bec9ae853f4d7e3d7822fc8f2fa7d85b87223a9b277b8875c1f7971d6ad">ipc::session::error::S_SESSION_OPEN_CHANNEL_ACTIVE_TIMEOUT</a>, <a class="el" href="namespaceipc_1_1session_1_1error.html#a0708d4bec9ae853f4d7e3d7822fc8f2fa2c8c27c65ff6234220a84f96de8a1870">ipc::session::error::S_SESSION_OPEN_CHANNEL_REMOTE_PEER_REJECTED_PASSIVE_OPEN</a>, <a class="el" href="namespaceipc_1_1session_1_1error.html#a0708d4bec9ae853f4d7e3d7822fc8f2fa10d32cf1382fb003f09a6df2da408574">ipc::session::error::S_SESSION_OPEN_CHANNEL_SERVER_CANNOT_PROCEED_RESOURCE_UNAVAILABLE</a>, and <a class="el" href="namespaceipc_1_1transport_1_1error.html#adfef15ef4e76cc55d652fbd9c2797297abcfca4c2347f9d377dd2ac41c41dc027">ipc::transport::error::S_TIMEOUT</a>.</p>

<p class="reference">Referenced by <a class="el" href="ipc__session_2src_2ipc_2session_2detail_2client__session__impl_8hpp_source.html#l01818">ipc::session::Client_session_impl&lt; S_MQ_TYPE_OR_NONE, S_TRANSMIT_NATIVE_HANDLES, Mdt_payload, S_SHM_TYPE_OR_NONE &gt;::open_channel()</a>.</p>
<div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="classipc_1_1session_1_1Client__session__impl_a4229549db1093aaa1e7e84c6e6467e80_cgraph.svg" width="406" height="71"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe>
</div>
</div>
<div class="dynheader">
Here is the caller graph for this function:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="classipc_1_1session_1_1Client__session__impl_a4229549db1093aaa1e7e84c6e6467e80_icgraph.svg" width="194" height="71"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe>
</div>
</div>

</div>
</div>
<a id="a7bfdeb2c55e656f8ec9acb147ef14194" name="a7bfdeb2c55e656f8ec9acb147ef14194"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7bfdeb2c55e656f8ec9acb147ef14194">&#9670;&nbsp;</a></span>open_channel() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;schema::MqType S_MQ_TYPE_OR_NONE, bool S_TRANSMIT_NATIVE_HANDLES, typename Mdt_payload , schema::ShmType S_SHM_TYPE_OR_NONE&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classipc_1_1session_1_1Client__session__impl.html">ipc::session::Client_session_impl</a>&lt; S_MQ_TYPE_OR_NONE, S_TRANSMIT_NATIVE_HANDLES, Mdt_payload, S_SHM_TYPE_OR_NONE &gt;::open_channel </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classipc_1_1session_1_1Client__session__impl.html#a418a1e70b7b51833cc9d24d1046e3526">Channel_obj</a> *&#160;</td>
          <td class="paramname"><em>target_channel</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceipc.html#aa3192e586cc45d3e7c22463bf2760f89">Error_code</a> *&#160;</td>
          <td class="paramname"><em>err_code</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>See <a class="el" href="classipc_1_1session_1_1Client__session__mv.html" title="Implements Session concept on the Client_app end: a Session_mv that first achieves PEER state by conn...">Client_session_mv</a> counterpart. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">target_channel</td><td>See <a class="el" href="classipc_1_1session_1_1Client__session__mv.html" title="Implements Session concept on the Client_app end: a Session_mv that first achieves PEER state by conn...">Client_session_mv</a> counterpart. </td></tr>
    <tr><td class="paramname">err_code</td><td>See <a class="el" href="classipc_1_1session_1_1Client__session__mv.html" title="Implements Session concept on the Client_app end: a Session_mv that first achieves PEER state by conn...">Client_session_mv</a> counterpart. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>See <a class="el" href="classipc_1_1session_1_1Client__session__mv.html" title="Implements Session concept on the Client_app end: a Session_mv that first achieves PEER state by conn...">Client_session_mv</a> counterpart. </dd></dl>

<p class="definition">Definition at line <a class="el" href="ipc__session_2src_2ipc_2session_2detail_2client__session__impl_8hpp_source.html#l01984">1984</a> of file <a class="el" href="ipc__session_2src_2ipc_2session_2detail_2client__session__impl_8hpp_source.html">client_session_impl.hpp</a>.</p>

</div>
</div>
<a id="adf14fe1ec27560741d35cf1d554c4933" name="adf14fe1ec27560741d35cf1d554c4933"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adf14fe1ec27560741d35cf1d554c4933">&#9670;&nbsp;</a></span>session_token()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;schema::MqType S_MQ_TYPE_OR_NONE, bool S_TRANSMIT_NATIVE_HANDLES, typename Mdt_payload , schema::ShmType S_SHM_TYPE_OR_NONE&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="namespaceipc_1_1session.html#ade2b302f1a3623e8adc9694568d94d2c">Session_token</a> &amp; <a class="el" href="classipc_1_1session_1_1Client__session__impl.html">ipc::session::Client_session_impl</a>&lt; S_MQ_TYPE_OR_NONE, S_TRANSMIT_NATIVE_HANDLES, Mdt_payload, S_SHM_TYPE_OR_NONE &gt;::session_token</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>See <a class="el" href="classipc_1_1session_1_1Client__session__mv.html" title="Implements Session concept on the Client_app end: a Session_mv that first achieves PEER state by conn...">Client_session_mv</a> counterpart. </p>
<dl class="section return"><dt>Returns</dt><dd>See <a class="el" href="classipc_1_1session_1_1Client__session__mv.html" title="Implements Session concept on the Client_app end: a Session_mv that first achieves PEER state by conn...">Client_session_mv</a> counterpart. </dd></dl>

<p class="definition">Definition at line <a class="el" href="ipc__session_2src_2ipc_2session_2detail_2client__session__impl_8hpp_source.html#l01727">1727</a> of file <a class="el" href="ipc__session_2src_2ipc_2session_2detail_2client__session__impl_8hpp_source.html">client_session_impl.hpp</a>.</p>

<p class="reference">References <a class="el" href="ipc__transport__structured_2src_2ipc_2transport_2struc_2channel_8cpp_source.html#l00035">ipc::transport::struc::NULL_SESSION_TOKEN</a>.</p>

</div>
</div>
<h2 class="groupheader">Friends And Related Function Documentation</h2>
<a id="a2c0fec2b8fcc95779db8561e8ad27c42" name="a2c0fec2b8fcc95779db8561e8ad27c42"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2c0fec2b8fcc95779db8561e8ad27c42">&#9670;&nbsp;</a></span>operator&lt;&lt;()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;schema::MqType S_MQ_TYPE_OR_NONE, bool S_TRANSMIT_NATIVE_HANDLES, typename Mdt_payload , schema::ShmType S_SHM_TYPE_OR_NONE&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::ostream &amp; operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>os</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classipc_1_1session_1_1Client__session__impl.html">Client_session_impl</a>&lt; S_MQ_TYPE_OR_NONE, S_TRANSMIT_NATIVE_HANDLES, Mdt_payload, S_SHM_TYPE_OR_NONE &gt; &amp;&#160;</td>
          <td class="paramname"><em>val</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Prints string representation of the given <code><a class="el" href="classipc_1_1session_1_1Client__session__impl.html" title="Internal, non-movable pImpl-lite implementation of Client_session_mv class template.">Client_session_impl</a></code> to the given <code>ostream</code>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">os</td><td>Stream to which to write. </td></tr>
    <tr><td class="paramname">val</td><td>Object to serialize. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>os</code>. </dd></dl>

<p class="definition">Definition at line <a class="el" href="ipc__session_2src_2ipc_2session_2detail_2client__session__impl_8hpp_source.html#l02302">2302</a> of file <a class="el" href="ipc__session_2src_2ipc_2session_2detail_2client__session__impl_8hpp_source.html">client_session_impl.hpp</a>.</p>

</div>
</div>
<h2 class="groupheader">Member Data Documentation</h2>
<a id="aa7be8826b9256addf316ef407aa8bd76" name="aa7be8826b9256addf316ef407aa8bd76"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa7be8826b9256addf316ef407aa8bd76">&#9670;&nbsp;</a></span>m_async_worker</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;schema::MqType S_MQ_TYPE_OR_NONE, bool S_TRANSMIT_NATIVE_HANDLES, typename Mdt_payload , schema::ShmType S_SHM_TYPE_OR_NONE&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">flow::async::Single_thread_task_loop <a class="el" href="classipc_1_1session_1_1Client__session__impl.html">ipc::session::Client_session_impl</a>&lt; S_MQ_TYPE_OR_NONE, S_TRANSMIT_NATIVE_HANDLES, Mdt_payload, S_SHM_TYPE_OR_NONE &gt;::m_async_worker</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">mutable</span><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Worker thread (a/k/a thread W). </p>
<p >Ordering: Should be declared before <a class="el" href="classipc_1_1session_1_1Client__session__impl.html#a5f526c4f9567f2529471dec9cd70f83c" title="The session master channel.">m_master_channel</a>: It should destruct before the <code>Task_engine</code> onto which its queued-up handlers might <code>post()</code> items destructs prematurely.</p>
<h3>Why <code>mutable</code>?</h3>
<p >Well, <a class="el" href="classipc_1_1session_1_1Client__session__impl.html#adf14fe1ec27560741d35cf1d554c4933" title="See Client_session_mv counterpart.">session_token()</a> is <code>const</code> to the user but must <code>.post()</code> which is non-<code>const</code>. This fits the spirit of <code>mutable</code>. I (ygoldfel) think. </p>

<p class="definition">Definition at line <a class="el" href="ipc__session_2src_2ipc_2session_2detail_2client__session__impl_8hpp_source.html#l00693">693</a> of file <a class="el" href="ipc__session_2src_2ipc_2session_2detail_2client__session__impl_8hpp_source.html">client_session_impl.hpp</a>.</p>

<p class="reference">Referenced by <a class="el" href="ipc__session_2src_2ipc_2session_2detail_2client__session__impl_8hpp_source.html#l00731">ipc::session::Client_session_impl&lt; S_MQ_TYPE_OR_NONE, S_TRANSMIT_NATIVE_HANDLES, Mdt_payload, S_SHM_TYPE_OR_NONE &gt;::Client_session_impl()</a>.</p>

</div>
</div>
<a id="a64ac1e72347053e73b125209a7756a1e" name="a64ac1e72347053e73b125209a7756a1e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a64ac1e72347053e73b125209a7756a1e">&#9670;&nbsp;</a></span>m_conn_on_done_func_or_empty</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;schema::MqType S_MQ_TYPE_OR_NONE, bool S_TRANSMIT_NATIVE_HANDLES, typename Mdt_payload , schema::ShmType S_SHM_TYPE_OR_NONE&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">flow::async::Task_asio_err <a class="el" href="classipc_1_1session_1_1Client__session__impl.html">ipc::session::Client_session_impl</a>&lt; S_MQ_TYPE_OR_NONE, S_TRANSMIT_NATIVE_HANDLES, Mdt_payload, S_SHM_TYPE_OR_NONE &gt;::m_conn_on_done_func_or_empty</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>The <code>on_done_func</code> argument to <a class="el" href="classipc_1_1session_1_1Client__session__impl.html#af03a9fca2006fba2cc522efa1178e83e" title="See Client_session_mv counterpart.">async_connect()</a>; <code>.empty()</code> except while in <a class="el" href="classipc_1_1session_1_1Client__session__impl.html#af7a951bd266bdd0e3339a0fbddba9e8baae585d03fce4ac2011967830bf0ffbfb" title="Not a peer but async_connect() in progress to try to make it a peer.">State::S_CONNECTING</a> state. </p>
<p >In other words it is assigned at entry to CONNECTING and <code>.clear()</code>ed at subsequent entry to <a class="el" href="classipc_1_1session_1_1Client__session__impl.html#af7a951bd266bdd0e3339a0fbddba9e8bad9a05d721258c584cd559c56fd035887" title="Is or was a connected peer.">State::S_PEER</a> or <a class="el" href="classipc_1_1session_1_1Client__session__impl.html#af7a951bd266bdd0e3339a0fbddba9e8bac6bd7568063494695099321f427efcb2" title="Not a peer.">State::S_NULL</a> (depending on success/failure of the connect op). </p>

<p class="definition">Definition at line <a class="el" href="ipc__session_2src_2ipc_2session_2detail_2client__session__impl_8hpp_source.html#l00672">672</a> of file <a class="el" href="ipc__session_2src_2ipc_2session_2detail_2client__session__impl_8hpp_source.html">client_session_impl.hpp</a>.</p>

</div>
</div>
<a id="abd394250fd8009dbc5a5b91973d56adf" name="abd394250fd8009dbc5a5b91973d56adf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abd394250fd8009dbc5a5b91973d56adf">&#9670;&nbsp;</a></span>m_last_actively_opened_channel_id</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;schema::MqType S_MQ_TYPE_OR_NONE, bool S_TRANSMIT_NATIVE_HANDLES, typename Mdt_payload , schema::ShmType S_SHM_TYPE_OR_NONE&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">unsigned int <a class="el" href="classipc_1_1session_1_1Client__session__impl.html">ipc::session::Client_session_impl</a>&lt; S_MQ_TYPE_OR_NONE, S_TRANSMIT_NATIVE_HANDLES, Mdt_payload, S_SHM_TYPE_OR_NONE &gt;::m_last_actively_opened_channel_id</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Logging-only <code>*this</code>-unique ID used in nicknaming the last actively-opened (via <a class="el" href="classipc_1_1session_1_1Client__session__impl.html#a4229549db1093aaa1e7e84c6e6467e80" title="See Client_session_mv counterpart.">open_channel()</a>) channel. </p>
<p >It is incremented each time. Accessed in thread W only (not protected by mutex). </p>

<p class="definition">Definition at line <a class="el" href="ipc__session_2src_2ipc_2session_2detail_2client__session__impl_8hpp_source.html#l00678">678</a> of file <a class="el" href="ipc__session_2src_2ipc_2session_2detail_2client__session__impl_8hpp_source.html">client_session_impl.hpp</a>.</p>

</div>
</div>
<a id="aaaba9b5089387689dfdc4fce53a358e9" name="aaaba9b5089387689dfdc4fce53a358e9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaaba9b5089387689dfdc4fce53a358e9">&#9670;&nbsp;</a></span>m_last_passively_opened_channel_id</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;schema::MqType S_MQ_TYPE_OR_NONE, bool S_TRANSMIT_NATIVE_HANDLES, typename Mdt_payload , schema::ShmType S_SHM_TYPE_OR_NONE&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">unsigned int <a class="el" href="classipc_1_1session_1_1Client__session__impl.html">ipc::session::Client_session_impl</a>&lt; S_MQ_TYPE_OR_NONE, S_TRANSMIT_NATIVE_HANDLES, Mdt_payload, S_SHM_TYPE_OR_NONE &gt;::m_last_passively_opened_channel_id</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>A-la <a class="el" href="classipc_1_1session_1_1Client__session__impl.html#abd394250fd8009dbc5a5b91973d56adf" title="Logging-only *this-unique ID used in nicknaming the last actively-opened (via open_channel()) channel...">m_last_actively_opened_channel_id</a> but for passively-opened channels (<a class="el" href="classipc_1_1session_1_1Client__session__impl.html#a9160d0684b8a1f39258d4a0b5a26a839" title="In thread W, handler for m_master_channel receiving a passive-open (a/k/a open-channel-to-client) req...">on_master_channel_open_channel_req()</a>). </p>

<p class="definition">Definition at line <a class="el" href="ipc__session_2src_2ipc_2session_2detail_2client__session__impl_8hpp_source.html#l00681">681</a> of file <a class="el" href="ipc__session_2src_2ipc_2session_2detail_2client__session__impl_8hpp_source.html">client_session_impl.hpp</a>.</p>

</div>
</div>
<a id="a5f526c4f9567f2529471dec9cd70f83c" name="a5f526c4f9567f2529471dec9cd70f83c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5f526c4f9567f2529471dec9cd70f83c">&#9670;&nbsp;</a></span>m_master_channel</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;schema::MqType S_MQ_TYPE_OR_NONE, bool S_TRANSMIT_NATIVE_HANDLES, typename Mdt_payload , schema::ShmType S_SHM_TYPE_OR_NONE&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classipc_1_1session_1_1Client__session__impl.html#a2a2960c4707475bab5d33b65bab9ba75">Master_structured_channel_ptr</a> <a class="el" href="classipc_1_1session_1_1Client__session__impl.html">ipc::session::Client_session_impl</a>&lt; S_MQ_TYPE_OR_NONE, S_TRANSMIT_NATIVE_HANDLES, Mdt_payload, S_SHM_TYPE_OR_NONE &gt;::m_master_channel</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>The session master channel. </p>
<p >Accessed in thread W only (not protected by mutex).</p><ul>
<li>When <a class="el" href="classipc_1_1session_1_1Client__session__impl.html#afd6871349fe71ab7a991bad2782421ba" title="The current state of *this.">m_state</a> is NULL, this is null.</li>
<li>When <a class="el" href="classipc_1_1session_1_1Client__session__impl.html#afd6871349fe71ab7a991bad2782421ba" title="The current state of *this.">m_state</a> is CONNECTING:<ul>
<li>It is still null until <a class="el" href="classipc_1_1transport_1_1Native__socket__stream.html#a3614a9677c1a203090b97ac935093390" title="To be invoked in NULL state only, it asynchronously attempts to connect to an opposing Native_socket_...">transport::Native_socket_stream::async_connect()</a> yields a PEER-state socket.</li>
<li>It is not null from that point on &ndash; including through entry to PEER &ndash; but it <em>does</em> go back to null if log-in procedure fails putting <code>m_state = <a class="el" href="classipc_1_1session_1_1Client__session__impl.html#af7a951bd266bdd0e3339a0fbddba9e8bac6bd7568063494695099321f427efcb2" title="Not a peer.">State::S_NULL</a></code> again.</li>
</ul>
</li>
<li>When <a class="el" href="classipc_1_1session_1_1Client__session__impl.html#afd6871349fe71ab7a991bad2782421ba" title="The current state of *this.">m_state</a> is PEER: It remains non-null and immutable until dtor.</li>
</ul>
<h3>Rationale for above invariant</h3>
<p >Generally it is a pain in the butt to deal with a <code>struc::Channel</code> being destroyed, as it has non-boost.asio-style handler semantics wherein one must be ready for a handler for channel C to fire in our thread W, even after we destroy C in a preceding thread W task. So, here as in other classes, we aim to keep it non-null and immutable once it's been constructed. (E.g., that's the case in <a class="el" href="classipc_1_1session_1_1Server__session__impl.html" title="Internal, non-movable pImpl-lite implementation of Server_session_mv class template.">Server_session_impl</a>.) However, since we allow <a class="el" href="classipc_1_1session_1_1Client__session__impl.html#af03a9fca2006fba2cc522efa1178e83e" title="See Client_session_mv counterpart.">async_connect()</a> to be retried on failure, we do need to get back to a coherent state when <a class="el" href="classipc_1_1session_1_1Client__session__impl.html#afd6871349fe71ab7a991bad2782421ba" title="The current state of *this.">m_state</a> is NULL. So in that case only, it is renullified.</p>
<p >Because it is renullified, there's the "observer" thing used in <a class="el" href="classipc_1_1session_1_1Client__session__impl.html#a5d9ae1ffb0b776fc78aa8f3daf60918b" title="In thread W, handler for m_master_channel indicating incoming-direction channel-hosing error.">on_master_channel_error()</a> to deal with it. It's a fairly small section of code though. </p>

<p class="definition">Definition at line <a class="el" href="ipc__session_2src_2ipc_2session_2detail_2client__session__impl_8hpp_source.html#l00715">715</a> of file <a class="el" href="ipc__session_2src_2ipc_2session_2detail_2client__session__impl_8hpp_source.html">client_session_impl.hpp</a>.</p>

</div>
</div>
<a id="afd6871349fe71ab7a991bad2782421ba" name="afd6871349fe71ab7a991bad2782421ba"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afd6871349fe71ab7a991bad2782421ba">&#9670;&nbsp;</a></span>m_state</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;schema::MqType S_MQ_TYPE_OR_NONE, bool S_TRANSMIT_NATIVE_HANDLES, typename Mdt_payload , schema::ShmType S_SHM_TYPE_OR_NONE&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classipc_1_1session_1_1Client__session__impl.html#af7a951bd266bdd0e3339a0fbddba9e8b">State</a> <a class="el" href="classipc_1_1session_1_1Client__session__impl.html">ipc::session::Client_session_impl</a>&lt; S_MQ_TYPE_OR_NONE, S_TRANSMIT_NATIVE_HANDLES, Mdt_payload, S_SHM_TYPE_OR_NONE &gt;::m_state</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>The current state of <code>*this</code>. </p>
<p >Accessed in thread W only (not protected by mutex).</p>
<dl class="section note"><dt>Note</dt><dd>I (ygoldfel) considered just relying on Native_socket_stream itself to just return <code>false</code>, and then we'd forward to its state detection. It would've been nice, but ultimately it just seemed a bit too sloppy and hard to reason about... I ~duplicated this here instead. </dd></dl>

<p class="definition">Definition at line <a class="el" href="ipc__session_2src_2ipc_2session_2detail_2client__session__impl_8hpp_source.html#l00665">665</a> of file <a class="el" href="ipc__session_2src_2ipc_2session_2detail_2client__session__impl_8hpp_source.html">client_session_impl.hpp</a>.</p>

</div>
</div>
<a id="a3541a8e1f4192c3fd6647827507440dd" name="a3541a8e1f4192c3fd6647827507440dd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3541a8e1f4192c3fd6647827507440dd">&#9670;&nbsp;</a></span>S_MQS_ENABLED</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;schema::MqType S_MQ_TYPE_OR_NONE, bool S_TRANSMIT_NATIVE_HANDLES, typename Mdt_payload , schema::ShmType S_SHM_TYPE_OR_NONE&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr bool <a class="el" href="classipc_1_1session_1_1Client__session__impl.html">ipc::session::Client_session_impl</a>&lt; S_MQ_TYPE_OR_NONE, S_TRANSMIT_NATIVE_HANDLES, Mdt_payload, S_SHM_TYPE_OR_NONE &gt;::S_MQS_ENABLED = Base::S_MQS_ENABLED</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>See <a class="el" href="classipc_1_1session_1_1Client__session__mv.html" title="Implements Session concept on the Client_app end: a Session_mv that first achieves PEER state by conn...">Client_session_mv</a> counterpart. </p>

<p class="definition">Definition at line <a class="el" href="ipc__session_2src_2ipc_2session_2detail_2client__session__impl_8hpp_source.html#l00148">148</a> of file <a class="el" href="ipc__session_2src_2ipc_2session_2detail_2client__session__impl_8hpp_source.html">client_session_impl.hpp</a>.</p>

</div>
</div>
<a id="afd118867d8628d18363f877dea8d601a" name="afd118867d8628d18363f877dea8d601a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afd118867d8628d18363f877dea8d601a">&#9670;&nbsp;</a></span>S_SHM_ENABLED</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;schema::MqType S_MQ_TYPE_OR_NONE, bool S_TRANSMIT_NATIVE_HANDLES, typename Mdt_payload , schema::ShmType S_SHM_TYPE_OR_NONE&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr bool <a class="el" href="classipc_1_1session_1_1Client__session__impl.html">ipc::session::Client_session_impl</a>&lt; S_MQ_TYPE_OR_NONE, S_TRANSMIT_NATIVE_HANDLES, Mdt_payload, S_SHM_TYPE_OR_NONE &gt;::S_SHM_ENABLED = <a class="el" href="classipc_1_1session_1_1Client__session__impl.html#aeb8590957bbc0dfac64fec8a703985ae">S_SHM_TYPE</a> != schema::ShmType::NONE</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>See <a class="el" href="classipc_1_1session_1_1Session__mv.html" title="Implements the Session concept when it is in PEER state.">Session_mv</a> counterpart. </p>

<p class="definition">Definition at line <a class="el" href="ipc__session_2src_2ipc_2session_2detail_2client__session__impl_8hpp_source.html#l00145">145</a> of file <a class="el" href="ipc__session_2src_2ipc_2session_2detail_2client__session__impl_8hpp_source.html">client_session_impl.hpp</a>.</p>

</div>
</div>
<a id="aeb8590957bbc0dfac64fec8a703985ae" name="aeb8590957bbc0dfac64fec8a703985ae"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aeb8590957bbc0dfac64fec8a703985ae">&#9670;&nbsp;</a></span>S_SHM_TYPE</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;schema::MqType S_MQ_TYPE_OR_NONE, bool S_TRANSMIT_NATIVE_HANDLES, typename Mdt_payload , schema::ShmType S_SHM_TYPE_OR_NONE&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr schema::ShmType <a class="el" href="classipc_1_1session_1_1Client__session__impl.html">ipc::session::Client_session_impl</a>&lt; S_MQ_TYPE_OR_NONE, S_TRANSMIT_NATIVE_HANDLES, Mdt_payload, S_SHM_TYPE_OR_NONE &gt;::S_SHM_TYPE = S_SHM_TYPE_OR_NONE</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>See <a class="el" href="classipc_1_1session_1_1Session__mv.html" title="Implements the Session concept when it is in PEER state.">Session_mv</a> counterpart. </p>

<p class="definition">Definition at line <a class="el" href="ipc__session_2src_2ipc_2session_2detail_2client__session__impl_8hpp_source.html#l00142">142</a> of file <a class="el" href="ipc__session_2src_2ipc_2session_2detail_2client__session__impl_8hpp_source.html">client_session_impl.hpp</a>.</p>

</div>
</div>
<a id="a921264bb66a3c1c2da679399f0bd59aa" name="a921264bb66a3c1c2da679399f0bd59aa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a921264bb66a3c1c2da679399f0bd59aa">&#9670;&nbsp;</a></span>S_SOCKET_STREAM_ENABLED</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;schema::MqType S_MQ_TYPE_OR_NONE, bool S_TRANSMIT_NATIVE_HANDLES, typename Mdt_payload , schema::ShmType S_SHM_TYPE_OR_NONE&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr bool <a class="el" href="classipc_1_1session_1_1Client__session__impl.html">ipc::session::Client_session_impl</a>&lt; S_MQ_TYPE_OR_NONE, S_TRANSMIT_NATIVE_HANDLES, Mdt_payload, S_SHM_TYPE_OR_NONE &gt;::S_SOCKET_STREAM_ENABLED = Base::S_SOCKET_STREAM_ENABLED</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>See <a class="el" href="classipc_1_1session_1_1Client__session__mv.html" title="Implements Session concept on the Client_app end: a Session_mv that first achieves PEER state by conn...">Client_session_mv</a> counterpart. </p>

<p class="definition">Definition at line <a class="el" href="ipc__session_2src_2ipc_2session_2detail_2client__session__impl_8hpp_source.html#l00151">151</a> of file <a class="el" href="ipc__session_2src_2ipc_2session_2detail_2client__session__impl_8hpp_source.html">client_session_impl.hpp</a>.</p>

</div>
</div>
<hr/>The documentation for this class was generated from the following files:<ul>
<li>session/detail/<a class="el" href="ipc__session_2src_2ipc_2session_2detail_2client__session__impl_8hpp_source.html">client_session_impl.hpp</a></li>
<li>session/detail/<a class="el" href="detail_2session__fwd_8hpp_source.html">session_fwd.hpp</a></li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Tue Jan 23 2024 07:05:16 for Flow-IPC by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.4
</small></address>
</body>
</html>
