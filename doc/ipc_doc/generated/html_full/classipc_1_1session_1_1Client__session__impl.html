<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.9.4"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Flow-IPC: ipc::session::Client_session_impl&lt; S_MQ_TYPE_OR_NONE, S_TRANSMIT_NATIVE_HANDLES, Mdt_payload, S_SHM_TYPE_OR_NONE, S_GRACEFUL_FINISH_REQUIRED_V &gt; Class Template Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">Flow-IPC<span id="projectnumber">&#160;1.0.2</span>
   </div>
   <div id="projectbrief">Flow-IPC project: Full implementation reference.</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.4 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search",'Search','.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespaceipc.html">ipc</a></li><li class="navelem"><a class="el" href="namespaceipc_1_1session.html">session</a></li><li class="navelem"><a class="el" href="classipc_1_1session_1_1Client__session__impl.html">Client_session_impl</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#pub-types">Public Types</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pub-static-attribs">Static Public Attributes</a> &#124;
<a href="#pro-types">Protected Types</a> &#124;
<a href="#pro-methods">Protected Member Functions</a> &#124;
<a href="#pri-types">Private Types</a> &#124;
<a href="#pri-methods">Private Member Functions</a> &#124;
<a href="#pri-attribs">Private Attributes</a> &#124;
<a href="#related">Related Functions</a> &#124;
<a href="classipc_1_1session_1_1Client__session__impl-members.html">List of all members</a>  </div>
  <div class="headertitle"><div class="title">ipc::session::Client_session_impl&lt; S_MQ_TYPE_OR_NONE, S_TRANSMIT_NATIVE_HANDLES, Mdt_payload, S_SHM_TYPE_OR_NONE, S_GRACEFUL_FINISH_REQUIRED_V &gt; Class Template Reference</div></div>
</div><!--header-->
<div class="contents">

<p>Internal, non-movable pImpl-lite implementation of <a class="el" href="classipc_1_1session_1_1Client__session__mv.html" title="Implements Session concept on the Client_app end: a Session_mv that first achieves PEER state by conn...">Client_session_mv</a> class template.  
 <a href="classipc_1_1session_1_1Client__session__impl.html#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="ipc__session_2src_2ipc_2session_2detail_2client__session__impl_8hpp_source.html">client_session_impl.hpp</a>&gt;</code></p>
<div class="dynheader">
Inheritance diagram for ipc::session::Client_session_impl&lt; S_MQ_TYPE_OR_NONE, S_TRANSMIT_NATIVE_HANDLES, Mdt_payload, S_SHM_TYPE_OR_NONE, S_GRACEFUL_FINISH_REQUIRED_V &gt;:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="classipc_1_1session_1_1Client__session__impl__inherit__graph.svg" width="658" height="120"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe>
</div>
<center><span class="legend">[<a href="graph_legend.html">legend</a>]</span></center></div>
<div class="dynheader">
Collaboration diagram for ipc::session::Client_session_impl&lt; S_MQ_TYPE_OR_NONE, S_TRANSMIT_NATIVE_HANDLES, Mdt_payload, S_SHM_TYPE_OR_NONE, S_GRACEFUL_FINISH_REQUIRED_V &gt;:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="classipc_1_1session_1_1Client__session__impl__coll__graph.svg" width="1927" height="1088"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe>
</div>
<center><span class="legend">[<a href="graph_legend.html">legend</a>]</span></center></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="nested-classes" name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structipc_1_1session_1_1Client__session__impl_1_1Master__channel__req.html">Master_channel_req</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">An open-channel/log-in request out-message.  <a href="structipc_1_1session_1_1Client__session__impl_1_1Master__channel__req.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-types" name="pub-types"></a>
Public Types</h2></td></tr>
<tr class="memitem:acd9519f313206fdd2cd6ca91efb79516"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classipc_1_1session_1_1Client__session__impl.html#acd9519f313206fdd2cd6ca91efb79516">Base</a> = <a class="el" href="classipc_1_1session_1_1Session__base.html">Session_base</a>&lt; S_MQ_TYPE_OR_NONE, S_TRANSMIT_NATIVE_HANDLES, Mdt_payload &gt;</td></tr>
<tr class="memdesc:acd9519f313206fdd2cd6ca91efb79516"><td class="mdescLeft">&#160;</td><td class="mdescRight">Short-hand for base type.  <a href="classipc_1_1session_1_1Client__session__impl.html#acd9519f313206fdd2cd6ca91efb79516">More...</a><br /></td></tr>
<tr class="separator:acd9519f313206fdd2cd6ca91efb79516"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7d1a81d91f59edf7fd3f5ea104294a7c"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classipc_1_1session_1_1Client__session__impl.html#a7d1a81d91f59edf7fd3f5ea104294a7c">Session_base_obj</a> = <a class="el" href="classipc_1_1session_1_1Client__session__impl.html#acd9519f313206fdd2cd6ca91efb79516">Base</a></td></tr>
<tr class="memdesc:a7d1a81d91f59edf7fd3f5ea104294a7c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Short-hand for <a class="el" href="classipc_1_1session_1_1Session__base.html" title="Internal type containing data and types common to internal types Server_session_impl and Client_sessi...">Session_base</a> super-class.  <a href="classipc_1_1session_1_1Client__session__impl.html#a7d1a81d91f59edf7fd3f5ea104294a7c">More...</a><br /></td></tr>
<tr class="separator:a7d1a81d91f59edf7fd3f5ea104294a7c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a994a2f0b281fdeaeb6c09f6d91df351a"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classipc_1_1session_1_1Client__session__impl.html#a994a2f0b281fdeaeb6c09f6d91df351a">Channel_obj</a> = typename <a class="el" href="classipc_1_1session_1_1Session__base.html#a71f02a809d667c23ff8af29a96940bd1">Base::Channel_obj</a></td></tr>
<tr class="memdesc:a994a2f0b281fdeaeb6c09f6d91df351a"><td class="mdescLeft">&#160;</td><td class="mdescRight">See <a class="el" href="classipc_1_1session_1_1Client__session__mv.html" title="Implements Session concept on the Client_app end: a Session_mv that first achieves PEER state by conn...">Client_session_mv</a> counterpart.  <a href="classipc_1_1session_1_1Client__session__impl.html#a994a2f0b281fdeaeb6c09f6d91df351a">More...</a><br /></td></tr>
<tr class="separator:a994a2f0b281fdeaeb6c09f6d91df351a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aab1b23e3370a77db375a50ab156b5662"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classipc_1_1session_1_1Client__session__impl.html#aab1b23e3370a77db375a50ab156b5662">Channels</a> = typename <a class="el" href="classipc_1_1session_1_1Session__base.html#a638232ef74a0eb80aeb4f027ee06f9bf">Base::Channels</a></td></tr>
<tr class="memdesc:aab1b23e3370a77db375a50ab156b5662"><td class="mdescLeft">&#160;</td><td class="mdescRight">See <a class="el" href="classipc_1_1session_1_1Session__mv.html" title="Implements the Session concept when it is in PEER state.">Session_mv</a> counterpart.  <a href="classipc_1_1session_1_1Client__session__impl.html#aab1b23e3370a77db375a50ab156b5662">More...</a><br /></td></tr>
<tr class="separator:aab1b23e3370a77db375a50ab156b5662"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae457d7b16843699006feb43e1073296a"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classipc_1_1session_1_1Client__session__impl.html#ae457d7b16843699006feb43e1073296a">Mdt_payload_obj</a> = typename <a class="el" href="classipc_1_1session_1_1Session__base.html#a35234981ca87cc2f6b118b3e52452ea8">Base::Mdt_payload_obj</a></td></tr>
<tr class="memdesc:ae457d7b16843699006feb43e1073296a"><td class="mdescLeft">&#160;</td><td class="mdescRight">See <a class="el" href="classipc_1_1session_1_1Client__session__mv.html" title="Implements Session concept on the Client_app end: a Session_mv that first achieves PEER state by conn...">Client_session_mv</a> counterpart.  <a href="classipc_1_1session_1_1Client__session__impl.html#ae457d7b16843699006feb43e1073296a">More...</a><br /></td></tr>
<tr class="separator:ae457d7b16843699006feb43e1073296a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad0ad69f676fc1260a3c493781fbbb81d"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classipc_1_1session_1_1Client__session__impl.html#ad0ad69f676fc1260a3c493781fbbb81d">Mdt_reader_ptr</a> = typename <a class="el" href="classipc_1_1session_1_1Session__base.html#ace4dab42adec6354cc66081dd218ac71">Base::Mdt_reader_ptr</a></td></tr>
<tr class="memdesc:ad0ad69f676fc1260a3c493781fbbb81d"><td class="mdescLeft">&#160;</td><td class="mdescRight">See <a class="el" href="classipc_1_1session_1_1Client__session__mv.html" title="Implements Session concept on the Client_app end: a Session_mv that first achieves PEER state by conn...">Client_session_mv</a> counterpart.  <a href="classipc_1_1session_1_1Client__session__impl.html#ad0ad69f676fc1260a3c493781fbbb81d">More...</a><br /></td></tr>
<tr class="separator:ad0ad69f676fc1260a3c493781fbbb81d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad5a3539f5e10933ff4abc7cde1056798"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classipc_1_1session_1_1Client__session__impl.html#ad5a3539f5e10933ff4abc7cde1056798">Mdt_builder</a> = typename <a class="el" href="classipc_1_1session_1_1Session__base.html#a7d68bbb8c0c09983619d563bca30bd45">Base::Mdt_builder</a></td></tr>
<tr class="memdesc:ad5a3539f5e10933ff4abc7cde1056798"><td class="mdescLeft">&#160;</td><td class="mdescRight">See <a class="el" href="classipc_1_1session_1_1Client__session__mv.html" title="Implements Session concept on the Client_app end: a Session_mv that first achieves PEER state by conn...">Client_session_mv</a> counterpart.  <a href="classipc_1_1session_1_1Client__session__impl.html#ad5a3539f5e10933ff4abc7cde1056798">More...</a><br /></td></tr>
<tr class="separator:ad5a3539f5e10933ff4abc7cde1056798"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9d93e6080abf3b0827b97e084f5e8356"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classipc_1_1session_1_1Client__session__impl.html#a9d93e6080abf3b0827b97e084f5e8356">Mdt_builder_ptr</a> = typename <a class="el" href="classipc_1_1session_1_1Session__base.html#a4a7a5b83f6ba8bd505685636eabc012b">Base::Mdt_builder_ptr</a></td></tr>
<tr class="memdesc:a9d93e6080abf3b0827b97e084f5e8356"><td class="mdescLeft">&#160;</td><td class="mdescRight">See <a class="el" href="classipc_1_1session_1_1Client__session__mv.html" title="Implements Session concept on the Client_app end: a Session_mv that first achieves PEER state by conn...">Client_session_mv</a> counterpart.  <a href="classipc_1_1session_1_1Client__session__impl.html#a9d93e6080abf3b0827b97e084f5e8356">More...</a><br /></td></tr>
<tr class="separator:a9d93e6080abf3b0827b97e084f5e8356"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a95c690ae89ac5e4017dd2ac030703dae"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classipc_1_1session_1_1Client__session__impl.html#a95c690ae89ac5e4017dd2ac030703dae">Structured_msg_builder_config</a> = typename <a class="el" href="classipc_1_1session_1_1Session__base.html#aee0db48505c84d3553b7110a9a815036">Base::Structured_msg_builder_config</a></td></tr>
<tr class="memdesc:a95c690ae89ac5e4017dd2ac030703dae"><td class="mdescLeft">&#160;</td><td class="mdescRight">See <a class="el" href="classipc_1_1session_1_1Session__mv.html" title="Implements the Session concept when it is in PEER state.">Session_mv</a> counterpart.  <a href="classipc_1_1session_1_1Client__session__impl.html#a95c690ae89ac5e4017dd2ac030703dae">More...</a><br /></td></tr>
<tr class="separator:a95c690ae89ac5e4017dd2ac030703dae"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae82914b6c13a8ff1b8ad9b2b179d4d74"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classipc_1_1session_1_1Client__session__impl.html#ae82914b6c13a8ff1b8ad9b2b179d4d74">Structured_msg_reader_config</a> = typename <a class="el" href="classipc_1_1session_1_1Session__base.html#abd854f2b9316361ef18f15610c242d4b">Base::Structured_msg_reader_config</a></td></tr>
<tr class="memdesc:ae82914b6c13a8ff1b8ad9b2b179d4d74"><td class="mdescLeft">&#160;</td><td class="mdescRight">See <a class="el" href="classipc_1_1session_1_1Session__mv.html" title="Implements the Session concept when it is in PEER state.">Session_mv</a> counterpart.  <a href="classipc_1_1session_1_1Client__session__impl.html#ae82914b6c13a8ff1b8ad9b2b179d4d74">More...</a><br /></td></tr>
<tr class="separator:ae82914b6c13a8ff1b8ad9b2b179d4d74"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pub_types_classipc_1_1session_1_1Session__base"><td colspan="2" onclick="javascript:toggleInherit('pub_types_classipc_1_1session_1_1Session__base')"><img src="closed.png" alt="-"/>&#160;Public Types inherited from <a class="el" href="classipc_1_1session_1_1Session__base.html">ipc::session::Session_base&lt; S_MQ_TYPE_OR_NONE, S_TRANSMIT_NATIVE_HANDLES, Mdt_payload &gt;</a></td></tr>
<tr class="memitem:a848c0f5247644ada0f8b0ab816eedda8 inherit pub_types_classipc_1_1session_1_1Session__base"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classipc_1_1session_1_1Session__base.html#a848c0f5247644ada0f8b0ab816eedda8">Persistent_mq_handle_from_cfg</a> = std::conditional_t&lt;!<a class="el" href="classipc_1_1session_1_1Session__base.html#a27a5731a648effb6b4b42f0312affa74">S_MQS_ENABLED</a>, <a class="el" href="classipc_1_1transport_1_1Null__peer.html">transport::Null_peer</a>, std::conditional_t&lt; S_MQ_TYPE_OR_NONE==schema::MqType::POSIX, <a class="el" href="classipc_1_1transport_1_1Posix__mq__handle.html">transport::Posix_mq_handle</a>, <a class="el" href="classipc_1_1transport_1_1Bipc__mq__handle.html">transport::Bipc_mq_handle</a> &gt; &gt;</td></tr>
<tr class="memdesc:a848c0f5247644ada0f8b0ab816eedda8 inherit pub_types_classipc_1_1session_1_1Session__base"><td class="mdescLeft">&#160;</td><td class="mdescRight">Relevant only if <a class="el" href="classipc_1_1session_1_1Session__base.html#a27a5731a648effb6b4b42f0312affa74" title="See Session_mv.">S_MQS_ENABLED</a>, this is the Persistent_mq_handle-concept impl type specified by the user via <code>S_MQ_TYPE_OR_NONE</code>.  <a href="classipc_1_1session_1_1Session__base.html#a848c0f5247644ada0f8b0ab816eedda8">More...</a><br /></td></tr>
<tr class="separator:a848c0f5247644ada0f8b0ab816eedda8 inherit pub_types_classipc_1_1session_1_1Session__base"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a71f02a809d667c23ff8af29a96940bd1 inherit pub_types_classipc_1_1session_1_1Session__base"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classipc_1_1session_1_1Session__base.html#a71f02a809d667c23ff8af29a96940bd1">Channel_obj</a> = std::conditional_t&lt; <a class="el" href="classipc_1_1session_1_1Session__base.html#a27a5731a648effb6b4b42f0312affa74">S_MQS_ENABLED</a>, std::conditional_t&lt; S_TRANSMIT_NATIVE_HANDLES, <a class="el" href="classipc_1_1transport_1_1Mqs__socket__stream__channel.html">transport::Mqs_socket_stream_channel</a>&lt; true, <a class="el" href="classipc_1_1session_1_1Session__base.html#a848c0f5247644ada0f8b0ab816eedda8">Persistent_mq_handle_from_cfg</a> &gt;, <a class="el" href="classipc_1_1transport_1_1Mqs__channel.html">transport::Mqs_channel</a>&lt; true, <a class="el" href="classipc_1_1session_1_1Session__base.html#a848c0f5247644ada0f8b0ab816eedda8">Persistent_mq_handle_from_cfg</a> &gt; &gt;, std::conditional_t&lt; S_TRANSMIT_NATIVE_HANDLES, <a class="el" href="classipc_1_1transport_1_1Socket__stream__channel.html">transport::Socket_stream_channel</a>&lt; true &gt;, <a class="el" href="classipc_1_1transport_1_1Socket__stream__channel__of__blobs.html">transport::Socket_stream_channel_of_blobs</a>&lt; true &gt; &gt; &gt;</td></tr>
<tr class="memdesc:a71f02a809d667c23ff8af29a96940bd1 inherit pub_types_classipc_1_1session_1_1Session__base"><td class="mdescLeft">&#160;</td><td class="mdescRight">See <a class="el" href="classipc_1_1session_1_1Session__mv.html" title="Implements the Session concept when it is in PEER state.">Session_mv</a> (or <a class="el" href="classipc_1_1session_1_1Session.html" title="A documentation-only concept defining the local side of an IPC conversation (session) with another en...">Session</a> concept).  <a href="classipc_1_1session_1_1Session__base.html#a71f02a809d667c23ff8af29a96940bd1">More...</a><br /></td></tr>
<tr class="separator:a71f02a809d667c23ff8af29a96940bd1 inherit pub_types_classipc_1_1session_1_1Session__base"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a638232ef74a0eb80aeb4f027ee06f9bf inherit pub_types_classipc_1_1session_1_1Session__base"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classipc_1_1session_1_1Session__base.html#a638232ef74a0eb80aeb4f027ee06f9bf">Channels</a> = std::vector&lt; <a class="el" href="classipc_1_1session_1_1Session__base.html#a71f02a809d667c23ff8af29a96940bd1">Channel_obj</a> &gt;</td></tr>
<tr class="memdesc:a638232ef74a0eb80aeb4f027ee06f9bf inherit pub_types_classipc_1_1session_1_1Session__base"><td class="mdescLeft">&#160;</td><td class="mdescRight">See <a class="el" href="classipc_1_1session_1_1Session__mv.html" title="Implements the Session concept when it is in PEER state.">Session_mv</a>. Note: If changed from <code>vector</code> please update those doc headers too.  <a href="classipc_1_1session_1_1Session__base.html#a638232ef74a0eb80aeb4f027ee06f9bf">More...</a><br /></td></tr>
<tr class="separator:a638232ef74a0eb80aeb4f027ee06f9bf inherit pub_types_classipc_1_1session_1_1Session__base"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a35234981ca87cc2f6b118b3e52452ea8 inherit pub_types_classipc_1_1session_1_1Session__base"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classipc_1_1session_1_1Session__base.html#a35234981ca87cc2f6b118b3e52452ea8">Mdt_payload_obj</a> = Mdt_payload</td></tr>
<tr class="memdesc:a35234981ca87cc2f6b118b3e52452ea8 inherit pub_types_classipc_1_1session_1_1Session__base"><td class="mdescLeft">&#160;</td><td class="mdescRight">See <a class="el" href="classipc_1_1session_1_1Session__mv.html" title="Implements the Session concept when it is in PEER state.">Session_mv</a> (or <a class="el" href="classipc_1_1session_1_1Session.html" title="A documentation-only concept defining the local side of an IPC conversation (session) with another en...">Session</a> concept).  <a href="classipc_1_1session_1_1Session__base.html#a35234981ca87cc2f6b118b3e52452ea8">More...</a><br /></td></tr>
<tr class="separator:a35234981ca87cc2f6b118b3e52452ea8 inherit pub_types_classipc_1_1session_1_1Session__base"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ace4dab42adec6354cc66081dd218ac71 inherit pub_types_classipc_1_1session_1_1Session__base"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classipc_1_1session_1_1Session__base.html#ace4dab42adec6354cc66081dd218ac71">Mdt_reader_ptr</a> = boost::shared_ptr&lt; typename transport::struc::schema::Metadata&lt; <a class="el" href="classipc_1_1session_1_1Session__base.html#a35234981ca87cc2f6b118b3e52452ea8">Mdt_payload_obj</a> &gt;::Reader &gt;</td></tr>
<tr class="memdesc:ace4dab42adec6354cc66081dd218ac71 inherit pub_types_classipc_1_1session_1_1Session__base"><td class="mdescLeft">&#160;</td><td class="mdescRight">See <a class="el" href="classipc_1_1session_1_1Session__mv.html" title="Implements the Session concept when it is in PEER state.">Session_mv</a> (or <a class="el" href="classipc_1_1session_1_1Session.html" title="A documentation-only concept defining the local side of an IPC conversation (session) with another en...">Session</a> concept).  <a href="classipc_1_1session_1_1Session__base.html#ace4dab42adec6354cc66081dd218ac71">More...</a><br /></td></tr>
<tr class="separator:ace4dab42adec6354cc66081dd218ac71 inherit pub_types_classipc_1_1session_1_1Session__base"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7d68bbb8c0c09983619d563bca30bd45 inherit pub_types_classipc_1_1session_1_1Session__base"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classipc_1_1session_1_1Session__base.html#a7d68bbb8c0c09983619d563bca30bd45">Mdt_builder</a> = typename transport::struc::schema::Metadata&lt; <a class="el" href="classipc_1_1session_1_1Session__base.html#a35234981ca87cc2f6b118b3e52452ea8">Mdt_payload_obj</a> &gt;<a class="el" href="classStruct__builder__config_1_1Builder.html">::Builder</a></td></tr>
<tr class="memdesc:a7d68bbb8c0c09983619d563bca30bd45 inherit pub_types_classipc_1_1session_1_1Session__base"><td class="mdescLeft">&#160;</td><td class="mdescRight">See <a class="el" href="classipc_1_1session_1_1Session__mv.html" title="Implements the Session concept when it is in PEER state.">Session_mv</a> (or <a class="el" href="classipc_1_1session_1_1Session.html" title="A documentation-only concept defining the local side of an IPC conversation (session) with another en...">Session</a> concept).  <a href="classipc_1_1session_1_1Session__base.html#a7d68bbb8c0c09983619d563bca30bd45">More...</a><br /></td></tr>
<tr class="separator:a7d68bbb8c0c09983619d563bca30bd45 inherit pub_types_classipc_1_1session_1_1Session__base"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4a7a5b83f6ba8bd505685636eabc012b inherit pub_types_classipc_1_1session_1_1Session__base"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classipc_1_1session_1_1Session__base.html#a4a7a5b83f6ba8bd505685636eabc012b">Mdt_builder_ptr</a> = boost::shared_ptr&lt; <a class="el" href="classipc_1_1session_1_1Session__base.html#a7d68bbb8c0c09983619d563bca30bd45">Mdt_builder</a> &gt;</td></tr>
<tr class="memdesc:a4a7a5b83f6ba8bd505685636eabc012b inherit pub_types_classipc_1_1session_1_1Session__base"><td class="mdescLeft">&#160;</td><td class="mdescRight">See <a class="el" href="classipc_1_1session_1_1Session__mv.html" title="Implements the Session concept when it is in PEER state.">Session_mv</a> (or <a class="el" href="classipc_1_1session_1_1Session.html" title="A documentation-only concept defining the local side of an IPC conversation (session) with another en...">Session</a> concept).  <a href="classipc_1_1session_1_1Session__base.html#a4a7a5b83f6ba8bd505685636eabc012b">More...</a><br /></td></tr>
<tr class="separator:a4a7a5b83f6ba8bd505685636eabc012b inherit pub_types_classipc_1_1session_1_1Session__base"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aee0db48505c84d3553b7110a9a815036 inherit pub_types_classipc_1_1session_1_1Session__base"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classipc_1_1session_1_1Session__base.html#aee0db48505c84d3553b7110a9a815036">Structured_msg_builder_config</a> = <a class="el" href="structipc_1_1transport_1_1struc_1_1Heap__fixed__builder_1_1Config.html">transport::struc::Heap_fixed_builder::Config</a></td></tr>
<tr class="memdesc:aee0db48505c84d3553b7110a9a815036 inherit pub_types_classipc_1_1session_1_1Session__base"><td class="mdescLeft">&#160;</td><td class="mdescRight">See <a class="el" href="classipc_1_1session_1_1Session__mv.html" title="Implements the Session concept when it is in PEER state.">Session_mv</a> (or <a class="el" href="classipc_1_1session_1_1Session.html" title="A documentation-only concept defining the local side of an IPC conversation (session) with another en...">Session</a> concept).  <a href="classipc_1_1session_1_1Session__base.html#aee0db48505c84d3553b7110a9a815036">More...</a><br /></td></tr>
<tr class="separator:aee0db48505c84d3553b7110a9a815036 inherit pub_types_classipc_1_1session_1_1Session__base"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abd854f2b9316361ef18f15610c242d4b inherit pub_types_classipc_1_1session_1_1Session__base"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classipc_1_1session_1_1Session__base.html#abd854f2b9316361ef18f15610c242d4b">Structured_msg_reader_config</a> = <a class="el" href="structipc_1_1transport_1_1struc_1_1Heap__reader_1_1Config.html">transport::struc::Heap_reader::Config</a></td></tr>
<tr class="memdesc:abd854f2b9316361ef18f15610c242d4b inherit pub_types_classipc_1_1session_1_1Session__base"><td class="mdescLeft">&#160;</td><td class="mdescRight">See <a class="el" href="classipc_1_1session_1_1Session__mv.html" title="Implements the Session concept when it is in PEER state.">Session_mv</a> (or <a class="el" href="classipc_1_1session_1_1Session.html" title="A documentation-only concept defining the local side of an IPC conversation (session) with another en...">Session</a> concept).  <a href="classipc_1_1session_1_1Session__base.html#abd854f2b9316361ef18f15610c242d4b">More...</a><br /></td></tr>
<tr class="separator:abd854f2b9316361ef18f15610c242d4b inherit pub_types_classipc_1_1session_1_1Session__base"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-methods" name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a8fe80ed65e416a2d1fcadb045dac0fcf"><td class="memTemplParams" colspan="2">template&lt;typename On_passive_open_channel_handler , typename Task_err &gt; </td></tr>
<tr class="memitem:a8fe80ed65e416a2d1fcadb045dac0fcf"><td class="memTemplItemLeft" align="right" valign="top">&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classipc_1_1session_1_1Client__session__impl.html#a8fe80ed65e416a2d1fcadb045dac0fcf">Client_session_impl</a> (flow::log::Logger *logger_ptr, const <a class="el" href="structipc_1_1session_1_1Client__app.html">Client_app</a> &amp;cli_app_ref, const <a class="el" href="structipc_1_1session_1_1Server__app.html">Server_app</a> &amp;srv_app_ref, Task_err &amp;&amp;on_err_func, On_passive_open_channel_handler &amp;&amp;on_passive_open_channel_func)</td></tr>
<tr class="memdesc:a8fe80ed65e416a2d1fcadb045dac0fcf"><td class="mdescLeft">&#160;</td><td class="mdescRight">See <a class="el" href="classipc_1_1session_1_1Client__session__mv.html" title="Implements Session concept on the Client_app end: a Session_mv that first achieves PEER state by conn...">Client_session_mv</a> counterpart.  <a href="classipc_1_1session_1_1Client__session__impl.html#a8fe80ed65e416a2d1fcadb045dac0fcf">More...</a><br /></td></tr>
<tr class="separator:a8fe80ed65e416a2d1fcadb045dac0fcf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0edcc39889b5f68492eb9156dc7a9b7a"><td class="memTemplParams" colspan="2">template&lt;typename Task_err &gt; </td></tr>
<tr class="memitem:a0edcc39889b5f68492eb9156dc7a9b7a"><td class="memTemplItemLeft" align="right" valign="top">&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classipc_1_1session_1_1Client__session__impl.html#a0edcc39889b5f68492eb9156dc7a9b7a">Client_session_impl</a> (flow::log::Logger *logger_ptr, const <a class="el" href="structipc_1_1session_1_1Client__app.html">Client_app</a> &amp;cli_app_ref, const <a class="el" href="structipc_1_1session_1_1Server__app.html">Server_app</a> &amp;srv_app_ref, Task_err &amp;&amp;on_err_func)</td></tr>
<tr class="memdesc:a0edcc39889b5f68492eb9156dc7a9b7a"><td class="mdescLeft">&#160;</td><td class="mdescRight">See <a class="el" href="classipc_1_1session_1_1Client__session__mv.html" title="Implements Session concept on the Client_app end: a Session_mv that first achieves PEER state by conn...">Client_session_mv</a> counterpart.  <a href="classipc_1_1session_1_1Client__session__impl.html#a0edcc39889b5f68492eb9156dc7a9b7a">More...</a><br /></td></tr>
<tr class="separator:a0edcc39889b5f68492eb9156dc7a9b7a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa12539a1a446cffb097f70cba8166088"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classipc_1_1session_1_1Client__session__impl.html#aa12539a1a446cffb097f70cba8166088">~Client_session_impl</a> ()</td></tr>
<tr class="memdesc:aa12539a1a446cffb097f70cba8166088"><td class="mdescLeft">&#160;</td><td class="mdescRight">See <a class="el" href="classipc_1_1session_1_1Client__session__mv.html" title="Implements Session concept on the Client_app end: a Session_mv that first achieves PEER state by conn...">Client_session_mv</a> counterpart.  <a href="classipc_1_1session_1_1Client__session__impl.html#aa12539a1a446cffb097f70cba8166088">More...</a><br /></td></tr>
<tr class="separator:aa12539a1a446cffb097f70cba8166088"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7ecad909e1013271ff365437f2fdae85"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classipc_1_1session_1_1Client__session__impl.html#a9d93e6080abf3b0827b97e084f5e8356">Mdt_builder_ptr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classipc_1_1session_1_1Client__session__impl.html#a7ecad909e1013271ff365437f2fdae85">mdt_builder</a> () const</td></tr>
<tr class="memdesc:a7ecad909e1013271ff365437f2fdae85"><td class="mdescLeft">&#160;</td><td class="mdescRight">See <a class="el" href="classipc_1_1session_1_1Client__session__mv.html" title="Implements Session concept on the Client_app end: a Session_mv that first achieves PEER state by conn...">Client_session_mv</a> counterpart.  <a href="classipc_1_1session_1_1Client__session__impl.html#a7ecad909e1013271ff365437f2fdae85">More...</a><br /></td></tr>
<tr class="separator:a7ecad909e1013271ff365437f2fdae85"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaf622f5f111ffa95d4ec6c636cfddb4a"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classipc_1_1session_1_1Client__session__impl.html#aaf622f5f111ffa95d4ec6c636cfddb4a">sync_connect</a> (<a class="el" href="namespaceipc.html#aa3192e586cc45d3e7c22463bf2760f89">Error_code</a> *err_code)</td></tr>
<tr class="memdesc:aaf622f5f111ffa95d4ec6c636cfddb4a"><td class="mdescLeft">&#160;</td><td class="mdescRight">See <a class="el" href="classipc_1_1session_1_1Client__session__mv.html" title="Implements Session concept on the Client_app end: a Session_mv that first achieves PEER state by conn...">Client_session_mv</a> counterpart.  <a href="classipc_1_1session_1_1Client__session__impl.html#aaf622f5f111ffa95d4ec6c636cfddb4a">More...</a><br /></td></tr>
<tr class="separator:aaf622f5f111ffa95d4ec6c636cfddb4a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa60d7f50f9a9bec95c627778f1556be0"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classipc_1_1session_1_1Client__session__impl.html#aa60d7f50f9a9bec95c627778f1556be0">sync_connect</a> (const <a class="el" href="classipc_1_1session_1_1Client__session__impl.html#a9d93e6080abf3b0827b97e084f5e8356">Mdt_builder_ptr</a> &amp;mdt, <a class="el" href="classipc_1_1session_1_1Client__session__impl.html#aab1b23e3370a77db375a50ab156b5662">Channels</a> *init_channels_by_cli_req_pre_sized, <a class="el" href="classipc_1_1session_1_1Client__session__impl.html#ad0ad69f676fc1260a3c493781fbbb81d">Mdt_reader_ptr</a> *mdt_from_srv_or_null, <a class="el" href="classipc_1_1session_1_1Client__session__impl.html#aab1b23e3370a77db375a50ab156b5662">Channels</a> *init_channels_by_srv_req, <a class="el" href="namespaceipc.html#aa3192e586cc45d3e7c22463bf2760f89">Error_code</a> *err_code)</td></tr>
<tr class="memdesc:aa60d7f50f9a9bec95c627778f1556be0"><td class="mdescLeft">&#160;</td><td class="mdescRight">See <a class="el" href="classipc_1_1session_1_1Client__session__mv.html" title="Implements Session concept on the Client_app end: a Session_mv that first achieves PEER state by conn...">Client_session_mv</a> counterpart.  <a href="classipc_1_1session_1_1Client__session__impl.html#aa60d7f50f9a9bec95c627778f1556be0">More...</a><br /></td></tr>
<tr class="separator:aa60d7f50f9a9bec95c627778f1556be0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4a377590fbf55b6d312f24d888d2a1bd"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classipc_1_1session_1_1Client__session__impl.html#a4a377590fbf55b6d312f24d888d2a1bd">open_channel</a> (<a class="el" href="classipc_1_1session_1_1Client__session__impl.html#a994a2f0b281fdeaeb6c09f6d91df351a">Channel_obj</a> *target_channel, const <a class="el" href="classipc_1_1session_1_1Client__session__impl.html#a9d93e6080abf3b0827b97e084f5e8356">Mdt_builder_ptr</a> &amp;mdt, <a class="el" href="namespaceipc.html#aa3192e586cc45d3e7c22463bf2760f89">Error_code</a> *err_code)</td></tr>
<tr class="memdesc:a4a377590fbf55b6d312f24d888d2a1bd"><td class="mdescLeft">&#160;</td><td class="mdescRight">See <a class="el" href="classipc_1_1session_1_1Client__session__mv.html" title="Implements Session concept on the Client_app end: a Session_mv that first achieves PEER state by conn...">Client_session_mv</a> counterpart.  <a href="classipc_1_1session_1_1Client__session__impl.html#a4a377590fbf55b6d312f24d888d2a1bd">More...</a><br /></td></tr>
<tr class="separator:a4a377590fbf55b6d312f24d888d2a1bd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acaca4c5b8e56cf4cd29b5cc886993ded"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classipc_1_1session_1_1Client__session__impl.html#acaca4c5b8e56cf4cd29b5cc886993ded">open_channel</a> (<a class="el" href="classipc_1_1session_1_1Client__session__impl.html#a994a2f0b281fdeaeb6c09f6d91df351a">Channel_obj</a> *target_channel, <a class="el" href="namespaceipc.html#aa3192e586cc45d3e7c22463bf2760f89">Error_code</a> *err_code)</td></tr>
<tr class="memdesc:acaca4c5b8e56cf4cd29b5cc886993ded"><td class="mdescLeft">&#160;</td><td class="mdescRight">See <a class="el" href="classipc_1_1session_1_1Client__session__mv.html" title="Implements Session concept on the Client_app end: a Session_mv that first achieves PEER state by conn...">Client_session_mv</a> counterpart.  <a href="classipc_1_1session_1_1Client__session__impl.html#acaca4c5b8e56cf4cd29b5cc886993ded">More...</a><br /></td></tr>
<tr class="separator:acaca4c5b8e56cf4cd29b5cc886993ded"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aad9a5e95ffde170a6483b74f397d9169"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="namespaceipc_1_1session.html#ade2b302f1a3623e8adc9694568d94d2c">Session_token</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classipc_1_1session_1_1Client__session__impl.html#aad9a5e95ffde170a6483b74f397d9169">session_token</a> () const</td></tr>
<tr class="memdesc:aad9a5e95ffde170a6483b74f397d9169"><td class="mdescLeft">&#160;</td><td class="mdescRight">See <a class="el" href="classipc_1_1session_1_1Client__session__mv.html" title="Implements Session concept on the Client_app end: a Session_mv that first achieves PEER state by conn...">Client_session_mv</a> counterpart.  <a href="classipc_1_1session_1_1Client__session__impl.html#aad9a5e95ffde170a6483b74f397d9169">More...</a><br /></td></tr>
<tr class="separator:aad9a5e95ffde170a6483b74f397d9169"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pub_methods_classipc_1_1session_1_1Session__base"><td colspan="2" onclick="javascript:toggleInherit('pub_methods_classipc_1_1session_1_1Session__base')"><img src="closed.png" alt="-"/>&#160;Public Member Functions inherited from <a class="el" href="classipc_1_1session_1_1Session__base.html">ipc::session::Session_base&lt; S_MQ_TYPE_OR_NONE, S_TRANSMIT_NATIVE_HANDLES, Mdt_payload &gt;</a></td></tr>
<tr class="memitem:a4d1327608d6067ed6690bd4efa323c6f inherit pub_methods_classipc_1_1session_1_1Session__base"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="namespaceipc_1_1session.html#a6d07d9996af19e57eb42416e914110ea">Shared_name</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classipc_1_1session_1_1Session__base.html#a4d1327608d6067ed6690bd4efa323c6f">srv_namespace</a> () const</td></tr>
<tr class="memdesc:a4d1327608d6067ed6690bd4efa323c6f inherit pub_methods_classipc_1_1session_1_1Session__base"><td class="mdescLeft">&#160;</td><td class="mdescRight">See <a class="el" href="classipc_1_1session_1_1Server__session__impl.html" title="Internal, non-movable pImpl-lite implementation of Server_session_mv class template.">Server_session_impl</a>, <a class="el" href="classipc_1_1session_1_1Client__session__impl.html" title="Internal, non-movable pImpl-lite implementation of Client_session_mv class template.">Client_session_impl</a>.  <a href="classipc_1_1session_1_1Session__base.html#a4d1327608d6067ed6690bd4efa323c6f">More...</a><br /></td></tr>
<tr class="separator:a4d1327608d6067ed6690bd4efa323c6f inherit pub_methods_classipc_1_1session_1_1Session__base"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abd1e814b3b640f4bdaa2553352405f26 inherit pub_methods_classipc_1_1session_1_1Session__base"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="namespaceipc_1_1session.html#a6d07d9996af19e57eb42416e914110ea">Shared_name</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classipc_1_1session_1_1Session__base.html#abd1e814b3b640f4bdaa2553352405f26">cli_namespace</a> () const</td></tr>
<tr class="memdesc:abd1e814b3b640f4bdaa2553352405f26 inherit pub_methods_classipc_1_1session_1_1Session__base"><td class="mdescLeft">&#160;</td><td class="mdescRight">See <a class="el" href="classipc_1_1session_1_1Server__session__impl.html" title="Internal, non-movable pImpl-lite implementation of Server_session_mv class template.">Server_session_impl</a>, <a class="el" href="classipc_1_1session_1_1Client__session__impl.html" title="Internal, non-movable pImpl-lite implementation of Client_session_mv class template.">Client_session_impl</a>.  <a href="classipc_1_1session_1_1Session__base.html#abd1e814b3b640f4bdaa2553352405f26">More...</a><br /></td></tr>
<tr class="separator:abd1e814b3b640f4bdaa2553352405f26 inherit pub_methods_classipc_1_1session_1_1Session__base"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3ebdafe7e70719e6d12dd0b15ae85106 inherit pub_methods_classipc_1_1session_1_1Session__base"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="structipc_1_1session_1_1Client__app.html">Client_app</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classipc_1_1session_1_1Session__base.html#a3ebdafe7e70719e6d12dd0b15ae85106">cli_app_ptr</a> () const</td></tr>
<tr class="memdesc:a3ebdafe7e70719e6d12dd0b15ae85106 inherit pub_methods_classipc_1_1session_1_1Session__base"><td class="mdescLeft">&#160;</td><td class="mdescRight">See <a class="el" href="classipc_1_1session_1_1Server__session__impl.html" title="Internal, non-movable pImpl-lite implementation of Server_session_mv class template.">Server_session_impl</a>, <a class="el" href="classipc_1_1session_1_1Client__session__impl.html" title="Internal, non-movable pImpl-lite implementation of Client_session_mv class template.">Client_session_impl</a>.  <a href="classipc_1_1session_1_1Session__base.html#a3ebdafe7e70719e6d12dd0b15ae85106">More...</a><br /></td></tr>
<tr class="separator:a3ebdafe7e70719e6d12dd0b15ae85106 inherit pub_methods_classipc_1_1session_1_1Session__base"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a09cbe99083616bae00928f8e37c8373b inherit pub_methods_classipc_1_1session_1_1Session__base"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespaceipc_1_1session.html#a6d07d9996af19e57eb42416e914110ea">Shared_name</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classipc_1_1session_1_1Session__base.html#a09cbe99083616bae00928f8e37c8373b">cur_ns_store_mutex_absolute_name</a> () const</td></tr>
<tr class="memdesc:a09cbe99083616bae00928f8e37c8373b inherit pub_methods_classipc_1_1session_1_1Session__base"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the name of the interprocess named-mutex used to control reading/writing to the file storing (written by server, read by client) the value for <a class="el" href="classipc_1_1session_1_1Session__base.html#a4d1327608d6067ed6690bd4efa323c6f" title="See Server_session_impl, Client_session_impl.">srv_namespace()</a>.  <a href="classipc_1_1session_1_1Session__base.html#a09cbe99083616bae00928f8e37c8373b">More...</a><br /></td></tr>
<tr class="separator:a09cbe99083616bae00928f8e37c8373b inherit pub_methods_classipc_1_1session_1_1Session__base"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af059faab56cdf384873f9f2aba8f79cf inherit pub_methods_classipc_1_1session_1_1Session__base"><td class="memItemLeft" align="right" valign="top">fs::path&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classipc_1_1session_1_1Session__base.html#af059faab56cdf384873f9f2aba8f79cf">cur_ns_store_absolute_path</a> () const</td></tr>
<tr class="memdesc:af059faab56cdf384873f9f2aba8f79cf inherit pub_methods_classipc_1_1session_1_1Session__base"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the absolute path to file storing (written by server, read by client) the value for <a class="el" href="classipc_1_1session_1_1Session__base.html#a4d1327608d6067ed6690bd4efa323c6f" title="See Server_session_impl, Client_session_impl.">srv_namespace()</a>.  <a href="classipc_1_1session_1_1Session__base.html#af059faab56cdf384873f9f2aba8f79cf">More...</a><br /></td></tr>
<tr class="separator:af059faab56cdf384873f9f2aba8f79cf inherit pub_methods_classipc_1_1session_1_1Session__base"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3d34c5a9c283a6b7c8ab943f344cdd28 inherit pub_methods_classipc_1_1session_1_1Session__base"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespaceipc_1_1session.html#a6d07d9996af19e57eb42416e914110ea">Shared_name</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classipc_1_1session_1_1Session__base.html#a3d34c5a9c283a6b7c8ab943f344cdd28">session_master_socket_stream_acceptor_absolute_name</a> () const</td></tr>
<tr class="memdesc:a3d34c5a9c283a6b7c8ab943f344cdd28 inherit pub_methods_classipc_1_1session_1_1Session__base"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the absolute name at which the server shall set up a <a class="el" href="classipc_1_1transport_1_1Native__socket__stream__acceptor.html" title="A server object that binds to a Shared_name and listens for incoming Native_socket_stream connect att...">transport::Native_socket_stream_acceptor</a> to which client shall <a class="el" href="classipc_1_1transport_1_1Native__socket__stream.html#a89d591db714e83dcb55a52738fed1ebb" title="To be invoked in NULL state only, it synchronously and non-blockingly attempts to connect to an oppos...">transport::Native_socket_stream::sync_connect()</a> in order to establish a PEER-state session.  <a href="classipc_1_1session_1_1Session__base.html#a3d34c5a9c283a6b7c8ab943f344cdd28">More...</a><br /></td></tr>
<tr class="separator:a3d34c5a9c283a6b7c8ab943f344cdd28 inherit pub_methods_classipc_1_1session_1_1Session__base"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-static-attribs" name="pub-static-attribs"></a>
Static Public Attributes</h2></td></tr>
<tr class="memitem:a1b34618ce1160871a4b16f4ecc3e86e6"><td class="memItemLeft" align="right" valign="top">static constexpr schema::ShmType&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classipc_1_1session_1_1Client__session__impl.html#a1b34618ce1160871a4b16f4ecc3e86e6">S_SHM_TYPE</a> = S_SHM_TYPE_OR_NONE</td></tr>
<tr class="memdesc:a1b34618ce1160871a4b16f4ecc3e86e6"><td class="mdescLeft">&#160;</td><td class="mdescRight">See <a class="el" href="classipc_1_1session_1_1Session__mv.html" title="Implements the Session concept when it is in PEER state.">Session_mv</a> counterpart.  <a href="classipc_1_1session_1_1Client__session__impl.html#a1b34618ce1160871a4b16f4ecc3e86e6">More...</a><br /></td></tr>
<tr class="separator:a1b34618ce1160871a4b16f4ecc3e86e6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a20f1ea81df379ff8153ba14f56b7f035"><td class="memItemLeft" align="right" valign="top">static constexpr bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classipc_1_1session_1_1Client__session__impl.html#a20f1ea81df379ff8153ba14f56b7f035">S_SHM_ENABLED</a> = <a class="el" href="classipc_1_1session_1_1Client__session__impl.html#a1b34618ce1160871a4b16f4ecc3e86e6">S_SHM_TYPE</a> != schema::ShmType::NONE</td></tr>
<tr class="memdesc:a20f1ea81df379ff8153ba14f56b7f035"><td class="mdescLeft">&#160;</td><td class="mdescRight">See <a class="el" href="classipc_1_1session_1_1Session__mv.html" title="Implements the Session concept when it is in PEER state.">Session_mv</a> counterpart.  <a href="classipc_1_1session_1_1Client__session__impl.html#a20f1ea81df379ff8153ba14f56b7f035">More...</a><br /></td></tr>
<tr class="separator:a20f1ea81df379ff8153ba14f56b7f035"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4036fbd01410a9befc7c541368d92704"><td class="memItemLeft" align="right" valign="top">static constexpr bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classipc_1_1session_1_1Client__session__impl.html#a4036fbd01410a9befc7c541368d92704">S_MQS_ENABLED</a> = Base::S_MQS_ENABLED</td></tr>
<tr class="memdesc:a4036fbd01410a9befc7c541368d92704"><td class="mdescLeft">&#160;</td><td class="mdescRight">See <a class="el" href="classipc_1_1session_1_1Client__session__mv.html" title="Implements Session concept on the Client_app end: a Session_mv that first achieves PEER state by conn...">Client_session_mv</a> counterpart.  <a href="classipc_1_1session_1_1Client__session__impl.html#a4036fbd01410a9befc7c541368d92704">More...</a><br /></td></tr>
<tr class="separator:a4036fbd01410a9befc7c541368d92704"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac28652995339005a7afeb467b33b3b62"><td class="memItemLeft" align="right" valign="top">static constexpr bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classipc_1_1session_1_1Client__session__impl.html#ac28652995339005a7afeb467b33b3b62">S_SOCKET_STREAM_ENABLED</a> = Base::S_SOCKET_STREAM_ENABLED</td></tr>
<tr class="memdesc:ac28652995339005a7afeb467b33b3b62"><td class="mdescLeft">&#160;</td><td class="mdescRight">See <a class="el" href="classipc_1_1session_1_1Client__session__mv.html" title="Implements Session concept on the Client_app end: a Session_mv that first achieves PEER state by conn...">Client_session_mv</a> counterpart.  <a href="classipc_1_1session_1_1Client__session__impl.html#ac28652995339005a7afeb467b33b3b62">More...</a><br /></td></tr>
<tr class="separator:ac28652995339005a7afeb467b33b3b62"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a65fe6d3d227016858428a170db961cc7"><td class="memItemLeft" align="right" valign="top">static constexpr bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classipc_1_1session_1_1Client__session__impl.html#a65fe6d3d227016858428a170db961cc7">S_GRACEFUL_FINISH_REQUIRED</a> = S_GRACEFUL_FINISH_REQUIRED_V</td></tr>
<tr class="memdesc:a65fe6d3d227016858428a170db961cc7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Short-hand for template parameter knob <code>S_GRACEFUL_FINISH_REQUIRED_V</code>: see class template doc header.  <a href="classipc_1_1session_1_1Client__session__impl.html#a65fe6d3d227016858428a170db961cc7">More...</a><br /></td></tr>
<tr class="separator:a65fe6d3d227016858428a170db961cc7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pub_static_attribs_classipc_1_1session_1_1Session__base"><td colspan="2" onclick="javascript:toggleInherit('pub_static_attribs_classipc_1_1session_1_1Session__base')"><img src="closed.png" alt="-"/>&#160;Static Public Attributes inherited from <a class="el" href="classipc_1_1session_1_1Session__base.html">ipc::session::Session_base&lt; S_MQ_TYPE_OR_NONE, S_TRANSMIT_NATIVE_HANDLES, Mdt_payload &gt;</a></td></tr>
<tr class="memitem:a27a5731a648effb6b4b42f0312affa74 inherit pub_static_attribs_classipc_1_1session_1_1Session__base"><td class="memItemLeft" align="right" valign="top">static constexpr bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classipc_1_1session_1_1Session__base.html#a27a5731a648effb6b4b42f0312affa74">S_MQS_ENABLED</a> = S_MQ_TYPE_OR_NONE != schema::MqType::NONE</td></tr>
<tr class="memdesc:a27a5731a648effb6b4b42f0312affa74 inherit pub_static_attribs_classipc_1_1session_1_1Session__base"><td class="mdescLeft">&#160;</td><td class="mdescRight">See <a class="el" href="classipc_1_1session_1_1Session__mv.html" title="Implements the Session concept when it is in PEER state.">Session_mv</a>.  <a href="classipc_1_1session_1_1Session__base.html#a27a5731a648effb6b4b42f0312affa74">More...</a><br /></td></tr>
<tr class="separator:a27a5731a648effb6b4b42f0312affa74 inherit pub_static_attribs_classipc_1_1session_1_1Session__base"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1f7c4243c8bd55930f51a568884c8aaf inherit pub_static_attribs_classipc_1_1session_1_1Session__base"><td class="memItemLeft" align="right" valign="top">static constexpr bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classipc_1_1session_1_1Session__base.html#a1f7c4243c8bd55930f51a568884c8aaf">S_SOCKET_STREAM_ENABLED</a> = (!<a class="el" href="classipc_1_1session_1_1Session__base.html#a27a5731a648effb6b4b42f0312affa74">S_MQS_ENABLED</a>) || S_TRANSMIT_NATIVE_HANDLES</td></tr>
<tr class="memdesc:a1f7c4243c8bd55930f51a568884c8aaf inherit pub_static_attribs_classipc_1_1session_1_1Session__base"><td class="mdescLeft">&#160;</td><td class="mdescRight">See <a class="el" href="classipc_1_1session_1_1Session__mv.html" title="Implements the Session concept when it is in PEER state.">Session_mv</a>.  <a href="classipc_1_1session_1_1Session__base.html#a1f7c4243c8bd55930f51a568884c8aaf">More...</a><br /></td></tr>
<tr class="separator:a1f7c4243c8bd55930f51a568884c8aaf inherit pub_static_attribs_classipc_1_1session_1_1Session__base"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pro-types" name="pro-types"></a>
Protected Types</h2></td></tr>
<tr class="memitem:a4c62a381340b0f494c4f117960bfca2b"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classipc_1_1session_1_1Client__session__impl.html#a4c62a381340b0f494c4f117960bfca2b">Master_structured_channel</a> = typename <a class="el" href="classipc_1_1session_1_1Session__base.html#a26d038e14e3c0e461e76de88c4ce76c5">Base::Master_structured_channel</a></td></tr>
<tr class="memdesc:a4c62a381340b0f494c4f117960bfca2b"><td class="mdescLeft">&#160;</td><td class="mdescRight">See <a class="el" href="classipc_1_1session_1_1Session__base.html" title="Internal type containing data and types common to internal types Server_session_impl and Client_sessi...">Session_base</a>.  <a href="classipc_1_1session_1_1Client__session__impl.html#a4c62a381340b0f494c4f117960bfca2b">More...</a><br /></td></tr>
<tr class="separator:a4c62a381340b0f494c4f117960bfca2b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pro_types_classipc_1_1session_1_1Session__base"><td colspan="2" onclick="javascript:toggleInherit('pro_types_classipc_1_1session_1_1Session__base')"><img src="closed.png" alt="-"/>&#160;Protected Types inherited from <a class="el" href="classipc_1_1session_1_1Session__base.html">ipc::session::Session_base&lt; S_MQ_TYPE_OR_NONE, S_TRANSMIT_NATIVE_HANDLES, Mdt_payload &gt;</a></td></tr>
<tr class="memitem:a26d038e14e3c0e461e76de88c4ce76c5 inherit pro_types_classipc_1_1session_1_1Session__base"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classipc_1_1session_1_1Session__base.html#a26d038e14e3c0e461e76de88c4ce76c5">Master_structured_channel</a> = <a class="el" href="namespaceipc_1_1transport_1_1struc.html#aca041b0efd4a9ae18e10088b2ee3c052">transport::struc::Channel_via_heap</a>&lt; <a class="el" href="classipc_1_1transport_1_1Socket__stream__channel.html">transport::Socket_stream_channel</a>&lt; true &gt;, schema::detail::SessionMasterChannelMessageBody&lt; <a class="el" href="classipc_1_1session_1_1Session__base.html#a35234981ca87cc2f6b118b3e52452ea8">Mdt_payload_obj</a> &gt; &gt;</td></tr>
<tr class="memdesc:a26d038e14e3c0e461e76de88c4ce76c5 inherit pro_types_classipc_1_1session_1_1Session__base"><td class="mdescLeft">&#160;</td><td class="mdescRight">The (internally used) session master channel is a <a class="el" href="classipc_1_1transport_1_1struc_1_1Channel.html" title="Owning and wrapping a pre-connected transport::Channel peer (an endpoint of an established channel ov...">transport::struc::Channel</a> of this concrete type.  <a href="classipc_1_1session_1_1Session__base.html#a26d038e14e3c0e461e76de88c4ce76c5">More...</a><br /></td></tr>
<tr class="separator:a26d038e14e3c0e461e76de88c4ce76c5 inherit pro_types_classipc_1_1session_1_1Session__base"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af0ca2a01d7d0d92038aae56fc1cdd505 inherit pro_types_classipc_1_1session_1_1Session__base"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classipc_1_1session_1_1Session__base.html#af0ca2a01d7d0d92038aae56fc1cdd505">Master_structured_channel_ptr</a> = boost::shared_ptr&lt; <a class="el" href="classipc_1_1session_1_1Session__base.html#a26d038e14e3c0e461e76de88c4ce76c5">Master_structured_channel</a> &gt;</td></tr>
<tr class="memdesc:af0ca2a01d7d0d92038aae56fc1cdd505 inherit pro_types_classipc_1_1session_1_1Session__base"><td class="mdescLeft">&#160;</td><td class="mdescRight">Handle to <a class="el" href="classipc_1_1session_1_1Session__base.html#a26d038e14e3c0e461e76de88c4ce76c5" title="The (internally used) session master channel is a transport::struc::Channel of this concrete type.">Master_structured_channel</a>.  <a href="classipc_1_1session_1_1Session__base.html#af0ca2a01d7d0d92038aae56fc1cdd505">More...</a><br /></td></tr>
<tr class="separator:af0ca2a01d7d0d92038aae56fc1cdd505 inherit pro_types_classipc_1_1session_1_1Session__base"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae2a123b29dd044a638e94d1f294c8f28 inherit pro_types_classipc_1_1session_1_1Session__base"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classipc_1_1session_1_1Session__base.html#ae2a123b29dd044a638e94d1f294c8f28">Master_structured_channel_observer</a> = boost::weak_ptr&lt; <a class="el" href="classipc_1_1session_1_1Session__base.html#a26d038e14e3c0e461e76de88c4ce76c5">Master_structured_channel</a> &gt;</td></tr>
<tr class="memdesc:ae2a123b29dd044a638e94d1f294c8f28 inherit pro_types_classipc_1_1session_1_1Session__base"><td class="mdescLeft">&#160;</td><td class="mdescRight">Observer of <a class="el" href="classipc_1_1session_1_1Session__base.html#af0ca2a01d7d0d92038aae56fc1cdd505" title="Handle to Master_structured_channel.">Master_structured_channel_ptr</a>. See its doc header.  <a href="classipc_1_1session_1_1Session__base.html#ae2a123b29dd044a638e94d1f294c8f28">More...</a><br /></td></tr>
<tr class="separator:ae2a123b29dd044a638e94d1f294c8f28 inherit pro_types_classipc_1_1session_1_1Session__base"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3c0824a54ef32915c5c5ea76481f2409 inherit pro_types_classipc_1_1session_1_1Session__base"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classipc_1_1session_1_1Session__base.html#a3c0824a54ef32915c5c5ea76481f2409">On_passive_open_channel_func</a> = <a class="el" href="namespaceipc.html#aa455c7f045059736578ca275fc1a851f">Function</a>&lt; void(<a class="el" href="classipc_1_1session_1_1Session__base.html#a71f02a809d667c23ff8af29a96940bd1">Channel_obj</a> &amp;&amp;new_channel, <a class="el" href="classipc_1_1session_1_1Session__base.html#ace4dab42adec6354cc66081dd218ac71">Mdt_reader_ptr</a> &amp;&amp;new_channel_mdt)&gt;</td></tr>
<tr class="memdesc:a3c0824a54ef32915c5c5ea76481f2409 inherit pro_types_classipc_1_1session_1_1Session__base"><td class="mdescLeft">&#160;</td><td class="mdescRight">Concrete function type for the on-passive-open handler (if any), used for storage.  <a href="classipc_1_1session_1_1Session__base.html#a3c0824a54ef32915c5c5ea76481f2409">More...</a><br /></td></tr>
<tr class="separator:a3c0824a54ef32915c5c5ea76481f2409 inherit pro_types_classipc_1_1session_1_1Session__base"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pro-methods" name="pro-methods"></a>
Protected Member Functions</h2></td></tr>
<tr class="memitem:a1a7560109fa2aa2c16d4f4159918e2c2"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classipc_1_1session_1_1Client__session__impl.html#a1a7560109fa2aa2c16d4f4159918e2c2">sync_connect_impl</a> (<a class="el" href="namespaceipc.html#aa3192e586cc45d3e7c22463bf2760f89">Error_code</a> *err_code, <a class="el" href="namespaceipc.html#aa455c7f045059736578ca275fc1a851f">Function</a>&lt; bool(flow::async::Task_asio_err &amp;&amp;)&gt; *async_connect_impl_func)</td></tr>
<tr class="memdesc:a1a7560109fa2aa2c16d4f4159918e2c2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Utility for <code>*this</code> and sub-classes: Implements <a class="el" href="classipc_1_1session_1_1Client__session__impl.html#aaf622f5f111ffa95d4ec6c636cfddb4a" title="See Client_session_mv counterpart.">sync_connect()</a> given a functor that invokes the calling class's (including <a class="el" href="classipc_1_1session_1_1Client__session__impl.html" title="Internal, non-movable pImpl-lite implementation of Client_session_mv class template.">Client_session_impl</a>) <a class="el" href="classipc_1_1session_1_1Client__session__impl.html#a56c0d2b0ff082d1f7b0738e2528b4a92" title="Core implementation of sync_connect().">async_connect()</a> with the args passed to the calling <a class="el" href="classipc_1_1session_1_1Client__session__impl.html#aaf622f5f111ffa95d4ec6c636cfddb4a" title="See Client_session_mv counterpart.">sync_connect()</a>.  <a href="classipc_1_1session_1_1Client__session__impl.html#a1a7560109fa2aa2c16d4f4159918e2c2">More...</a><br /></td></tr>
<tr class="separator:a1a7560109fa2aa2c16d4f4159918e2c2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a56c0d2b0ff082d1f7b0738e2528b4a92"><td class="memTemplParams" colspan="2">template&lt;typename Task_err &gt; </td></tr>
<tr class="memitem:a56c0d2b0ff082d1f7b0738e2528b4a92"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classipc_1_1session_1_1Client__session__impl.html#a56c0d2b0ff082d1f7b0738e2528b4a92">async_connect</a> (const <a class="el" href="classipc_1_1session_1_1Client__session__impl.html#a9d93e6080abf3b0827b97e084f5e8356">Mdt_builder_ptr</a> &amp;mdt, <a class="el" href="classipc_1_1session_1_1Client__session__impl.html#aab1b23e3370a77db375a50ab156b5662">Channels</a> *init_channels_by_cli_req_pre_sized, <a class="el" href="classipc_1_1session_1_1Client__session__impl.html#ad0ad69f676fc1260a3c493781fbbb81d">Mdt_reader_ptr</a> *mdt_from_srv_or_null, <a class="el" href="classipc_1_1session_1_1Client__session__impl.html#aab1b23e3370a77db375a50ab156b5662">Channels</a> *init_channels_by_srv_req, Task_err &amp;&amp;on_done_func)</td></tr>
<tr class="memdesc:a56c0d2b0ff082d1f7b0738e2528b4a92"><td class="mdescLeft">&#160;</td><td class="mdescRight">Core implementation of <a class="el" href="classipc_1_1session_1_1Client__session__impl.html#aaf622f5f111ffa95d4ec6c636cfddb4a" title="See Client_session_mv counterpart.">sync_connect()</a>.  <a href="classipc_1_1session_1_1Client__session__impl.html#a56c0d2b0ff082d1f7b0738e2528b4a92">More...</a><br /></td></tr>
<tr class="separator:a56c0d2b0ff082d1f7b0738e2528b4a92"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a43d56aeae47d1fa815178ebd0ae1ff48"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classipc_1_1session_1_1Client__session__impl.html#a43d56aeae47d1fa815178ebd0ae1ff48">cancel_peer_state_to_null</a> ()</td></tr>
<tr class="memdesc:a43d56aeae47d1fa815178ebd0ae1ff48"><td class="mdescLeft">&#160;</td><td class="mdescRight">Utility for sub-classes: executed from <a class="el" href="classipc_1_1session_1_1Client__session__impl.html#a56c0d2b0ff082d1f7b0738e2528b4a92" title="Core implementation of sync_connect().">async_connect()</a>'s <code>on_done_func(Error_code())</code> (i.e., directly from handler invoked on success) &ndash; hence from thread W &ndash; this instead goes back to NULL state, essentially indicating "never mind -- this successful async_connect() actually failed.".  <a href="classipc_1_1session_1_1Client__session__impl.html#a43d56aeae47d1fa815178ebd0ae1ff48">More...</a><br /></td></tr>
<tr class="separator:a43d56aeae47d1fa815178ebd0ae1ff48"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adac4cba3aefa629566f182a240b4cedd"><td class="memTemplParams" colspan="2">template&lt;typename Task_err &gt; </td></tr>
<tr class="memitem:adac4cba3aefa629566f182a240b4cedd"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classipc_1_1session_1_1Client__session__impl.html#a4c62a381340b0f494c4f117960bfca2b">Master_structured_channel</a> *&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classipc_1_1session_1_1Client__session__impl.html#adac4cba3aefa629566f182a240b4cedd">cancel_peer_state_to_connecting</a> (Task_err &amp;&amp;on_done_func)</td></tr>
<tr class="memdesc:adac4cba3aefa629566f182a240b4cedd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Utility for sub-classes: executed from <a class="el" href="classipc_1_1session_1_1Client__session__impl.html#a56c0d2b0ff082d1f7b0738e2528b4a92" title="Core implementation of sync_connect().">async_connect()</a>'s <code>on_done_func(Error_code())</code> (i.e., directly from handler invoked on success) &ndash; hence from thread W &ndash; this instead goes back to CONNECTING state, essentially indicating "yes, the vanilla <a class="el" href="classipc_1_1session_1_1Client__session__impl.html#a56c0d2b0ff082d1f7b0738e2528b4a92" title="Core implementation of sync_connect().">async_connect()</a> succeeded, but the true user-called <a class="el" href="classipc_1_1session_1_1Client__session__impl.html#a56c0d2b0ff082d1f7b0738e2528b4a92" title="Core implementation of sync_connect().">async_connect()</a> that piggybacked on the vanilla one will now do some more async stuff before reaching PEER state (or NULL on error).  <a href="classipc_1_1session_1_1Client__session__impl.html#adac4cba3aefa629566f182a240b4cedd">More...</a><br /></td></tr>
<tr class="separator:adac4cba3aefa629566f182a240b4cedd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a313e2fc3d4017232bad4fac2baae20a4"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classipc_1_1session_1_1Client__session__impl.html#a313e2fc3d4017232bad4fac2baae20a4">complete_async_connect_after_canceling_peer_state</a> (const <a class="el" href="namespaceipc.html#aa3192e586cc45d3e7c22463bf2760f89">Error_code</a> &amp;err_code_or_success)</td></tr>
<tr class="memdesc:a313e2fc3d4017232bad4fac2baae20a4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Utility for sub-classes: to be invoked, only from thread W and asynchronously at that, after <a class="el" href="classipc_1_1session_1_1Client__session__impl.html#adac4cba3aefa629566f182a240b4cedd" title="Utility for sub-classes: executed from async_connect()&#39;s on_done_func(Error_code()) (i....">cancel_peer_state_to_connecting()</a>, this indicates the completion of the sub-class's additional async-connect steps, setting state to either NULL or PEER.  <a href="classipc_1_1session_1_1Client__session__impl.html#a313e2fc3d4017232bad4fac2baae20a4">More...</a><br /></td></tr>
<tr class="separator:a313e2fc3d4017232bad4fac2baae20a4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab792f2389fd035827ae8dbead1650b78"><td class="memItemLeft" align="right" valign="top">flow::async::Single_thread_task_loop *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classipc_1_1session_1_1Client__session__impl.html#ab792f2389fd035827ae8dbead1650b78">async_worker</a> ()</td></tr>
<tr class="memdesc:ab792f2389fd035827ae8dbead1650b78"><td class="mdescLeft">&#160;</td><td class="mdescRight">Utility for sub-classes: provides ability to schedule or post tasks onto thread W.  <a href="classipc_1_1session_1_1Client__session__impl.html#ab792f2389fd035827ae8dbead1650b78">More...</a><br /></td></tr>
<tr class="separator:ab792f2389fd035827ae8dbead1650b78"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5f156b23ce19cd878c3e83330e63f56f"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classipc_1_1session_1_1Client__session__impl.html#a4c62a381340b0f494c4f117960bfca2b">Master_structured_channel</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classipc_1_1session_1_1Client__session__impl.html#a5f156b23ce19cd878c3e83330e63f56f">master_channel_const</a> () const</td></tr>
<tr class="memdesc:a5f156b23ce19cd878c3e83330e63f56f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Utility for sub-classes: provides ability to <em>immutably query</em> the session master channel, particularly after our async_accept_log_in() succeeds, but before the sub-classed wrapper of its on-done handler succeeds.  <a href="classipc_1_1session_1_1Client__session__impl.html#a5f156b23ce19cd878c3e83330e63f56f">More...</a><br /></td></tr>
<tr class="separator:a5f156b23ce19cd878c3e83330e63f56f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afb09c3a23b7e63938b9a494cec6e769b"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classipc_1_1session_1_1Client__session__impl.html#afb09c3a23b7e63938b9a494cec6e769b">dtor_async_worker_stop</a> ()</td></tr>
<tr class="memdesc:afb09c3a23b7e63938b9a494cec6e769b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Synchronously stops <a class="el" href="classipc_1_1session_1_1Client__session__impl.html#ab792f2389fd035827ae8dbead1650b78" title="Utility for sub-classes: provides ability to schedule or post tasks onto thread W.">async_worker()</a> loop, the post-condition being that thread W has been joined; no tasks <code>post()</code>ed onto it by <code>*this</code> or subclass shall execute after this returns.  <a href="classipc_1_1session_1_1Client__session__impl.html#afb09c3a23b7e63938b9a494cec6e769b">More...</a><br /></td></tr>
<tr class="separator:afb09c3a23b7e63938b9a494cec6e769b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pro_methods_classipc_1_1session_1_1Session__base"><td colspan="2" onclick="javascript:toggleInherit('pro_methods_classipc_1_1session_1_1Session__base')"><img src="closed.png" alt="-"/>&#160;Protected Member Functions inherited from <a class="el" href="classipc_1_1session_1_1Session__base.html">ipc::session::Session_base&lt; S_MQ_TYPE_OR_NONE, S_TRANSMIT_NATIVE_HANDLES, Mdt_payload &gt;</a></td></tr>
<tr class="memitem:aab2db8b2cdb3d8189c1cc497aed7b2b1 inherit pro_methods_classipc_1_1session_1_1Session__base"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classipc_1_1session_1_1Session__base.html#aab2db8b2cdb3d8189c1cc497aed7b2b1">Session_base</a> (const <a class="el" href="structipc_1_1session_1_1Client__app.html">Client_app</a> &amp;cli_app_ref, const <a class="el" href="structipc_1_1session_1_1Server__app.html">Server_app</a> &amp;srv_app_ref, flow::async::Task_asio_err &amp;&amp;on_err_func, <a class="el" href="classipc_1_1session_1_1Session__base.html#a3c0824a54ef32915c5c5ea76481f2409">On_passive_open_channel_func</a> &amp;&amp;on_passive_open_channel_func_or_empty_arg)</td></tr>
<tr class="memdesc:aab2db8b2cdb3d8189c1cc497aed7b2b1 inherit pro_methods_classipc_1_1session_1_1Session__base"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructs: <a class="el" href="classipc_1_1session_1_1Client__session__impl.html" title="Internal, non-movable pImpl-lite implementation of Client_session_mv class template.">Client_session_impl</a> form (the user is the one constructing the object, though in NULL state).  <a href="classipc_1_1session_1_1Session__base.html#aab2db8b2cdb3d8189c1cc497aed7b2b1">More...</a><br /></td></tr>
<tr class="separator:aab2db8b2cdb3d8189c1cc497aed7b2b1 inherit pro_methods_classipc_1_1session_1_1Session__base"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8d323ca75006777b3fc929bd0720f7df inherit pro_methods_classipc_1_1session_1_1Session__base"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classipc_1_1session_1_1Session__base.html#a8d323ca75006777b3fc929bd0720f7df">Session_base</a> (const <a class="el" href="structipc_1_1session_1_1Server__app.html">Server_app</a> &amp;srv_app_ref)</td></tr>
<tr class="memdesc:a8d323ca75006777b3fc929bd0720f7df inherit pro_methods_classipc_1_1session_1_1Session__base"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructs: <a class="el" href="classipc_1_1session_1_1Server__session__impl.html" title="Internal, non-movable pImpl-lite implementation of Server_session_mv class template.">Server_session_impl</a> form (<a class="el" href="classipc_1_1session_1_1Session__server.html" title="To be instantiated typically once in a given process, an object of this type asynchronously listens f...">Session_server</a> is the one constructing the object, though in NULL state, before log-in has completed, but after the socket-stream connection has been established).  <a href="classipc_1_1session_1_1Session__base.html#a8d323ca75006777b3fc929bd0720f7df">More...</a><br /></td></tr>
<tr class="separator:a8d323ca75006777b3fc929bd0720f7df inherit pro_methods_classipc_1_1session_1_1Session__base"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a28825fcdeaf1249a7bf810a3b2ca7c38 inherit pro_methods_classipc_1_1session_1_1Session__base"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classipc_1_1session_1_1Session__base.html#a28825fcdeaf1249a7bf810a3b2ca7c38">set_srv_namespace</a> (<a class="el" href="namespaceipc_1_1session.html#a6d07d9996af19e57eb42416e914110ea">Shared_name</a> &amp;&amp;srv_namespace_new)</td></tr>
<tr class="memdesc:a28825fcdeaf1249a7bf810a3b2ca7c38 inherit pro_methods_classipc_1_1session_1_1Session__base"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets <a class="el" href="classipc_1_1session_1_1Session__base.html#a4d1327608d6067ed6690bd4efa323c6f" title="See Server_session_impl, Client_session_impl.">srv_namespace()</a> (do not call if already set).  <a href="classipc_1_1session_1_1Session__base.html#a28825fcdeaf1249a7bf810a3b2ca7c38">More...</a><br /></td></tr>
<tr class="separator:a28825fcdeaf1249a7bf810a3b2ca7c38 inherit pro_methods_classipc_1_1session_1_1Session__base"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8cc7a4faa098e0f71c737f44c34d593c inherit pro_methods_classipc_1_1session_1_1Session__base"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classipc_1_1session_1_1Session__base.html#a8cc7a4faa098e0f71c737f44c34d593c">set_cli_namespace</a> (<a class="el" href="namespaceipc_1_1session.html#a6d07d9996af19e57eb42416e914110ea">Shared_name</a> &amp;&amp;cli_namespace_new)</td></tr>
<tr class="memdesc:a8cc7a4faa098e0f71c737f44c34d593c inherit pro_methods_classipc_1_1session_1_1Session__base"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets <a class="el" href="classipc_1_1session_1_1Session__base.html#abd1e814b3b640f4bdaa2553352405f26" title="See Server_session_impl, Client_session_impl.">cli_namespace()</a> (do not call if already set).  <a href="classipc_1_1session_1_1Session__base.html#a8cc7a4faa098e0f71c737f44c34d593c">More...</a><br /></td></tr>
<tr class="separator:a8cc7a4faa098e0f71c737f44c34d593c inherit pro_methods_classipc_1_1session_1_1Session__base"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a60a081ce0f85651202d23b4d543d093c inherit pro_methods_classipc_1_1session_1_1Session__base"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classipc_1_1session_1_1Session__base.html#a60a081ce0f85651202d23b4d543d093c">set_cli_app_ptr</a> (const <a class="el" href="structipc_1_1session_1_1Client__app.html">Client_app</a> *cli_app_ptr_new)</td></tr>
<tr class="memdesc:a60a081ce0f85651202d23b4d543d093c inherit pro_methods_classipc_1_1session_1_1Session__base"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets <a class="el" href="classipc_1_1session_1_1Session__base.html#a3ebdafe7e70719e6d12dd0b15ae85106" title="See Server_session_impl, Client_session_impl.">cli_app_ptr()</a> (do not call if already set).  <a href="classipc_1_1session_1_1Session__base.html#a60a081ce0f85651202d23b4d543d093c">More...</a><br /></td></tr>
<tr class="separator:a60a081ce0f85651202d23b4d543d093c inherit pro_methods_classipc_1_1session_1_1Session__base"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3be1a385c905404621b58c23332b0b96 inherit pro_methods_classipc_1_1session_1_1Session__base"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classipc_1_1session_1_1Session__base.html#a3be1a385c905404621b58c23332b0b96">set_on_passive_open_channel_func</a> (<a class="el" href="classipc_1_1session_1_1Session__base.html#a3c0824a54ef32915c5c5ea76481f2409">On_passive_open_channel_func</a> &amp;&amp;on_passive_open_channel_func)</td></tr>
<tr class="memdesc:a3be1a385c905404621b58c23332b0b96 inherit pro_methods_classipc_1_1session_1_1Session__base"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets <a class="el" href="classipc_1_1session_1_1Session__base.html#a21b146b02d257d95f4aaeaca12b8d320" title="The on-passive-open handler (may be empty even in final state, meaning user wants passive-opens disab...">on_passive_open_channel_func_or_empty()</a> (do not call if already set; do not call if user intends for passive-opens to be disabled on this side).  <a href="classipc_1_1session_1_1Session__base.html#a3be1a385c905404621b58c23332b0b96">More...</a><br /></td></tr>
<tr class="separator:a3be1a385c905404621b58c23332b0b96 inherit pro_methods_classipc_1_1session_1_1Session__base"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae769a82bdec0d16702111ad06716faae inherit pro_methods_classipc_1_1session_1_1Session__base"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classipc_1_1session_1_1Session__base.html#ae769a82bdec0d16702111ad06716faae">set_on_err_func</a> (flow::async::Task_asio_err &amp;&amp;on_err_func_arg)</td></tr>
<tr class="memdesc:ae769a82bdec0d16702111ad06716faae inherit pro_methods_classipc_1_1session_1_1Session__base"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets on_err_func() (do not call if already set).  <a href="classipc_1_1session_1_1Session__base.html#ae769a82bdec0d16702111ad06716faae">More...</a><br /></td></tr>
<tr class="separator:ae769a82bdec0d16702111ad06716faae inherit pro_methods_classipc_1_1session_1_1Session__base"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aca82817beaac36d0006c44012f9fef03 inherit pro_methods_classipc_1_1session_1_1Session__base"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classipc_1_1session_1_1Session__base.html#aca82817beaac36d0006c44012f9fef03">on_err_func_set</a> () const</td></tr>
<tr class="memdesc:aca82817beaac36d0006c44012f9fef03 inherit pro_methods_classipc_1_1session_1_1Session__base"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns <code>true</code> if and only if <a class="el" href="classipc_1_1session_1_1Session__base.html#ae769a82bdec0d16702111ad06716faae" title="Sets on_err_func() (do not call if already set).">set_on_err_func()</a> has been called.  <a href="classipc_1_1session_1_1Session__base.html#aca82817beaac36d0006c44012f9fef03">More...</a><br /></td></tr>
<tr class="separator:aca82817beaac36d0006c44012f9fef03 inherit pro_methods_classipc_1_1session_1_1Session__base"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a21b146b02d257d95f4aaeaca12b8d320 inherit pro_methods_classipc_1_1session_1_1Session__base"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classipc_1_1session_1_1Session__base.html#a3c0824a54ef32915c5c5ea76481f2409">On_passive_open_channel_func</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classipc_1_1session_1_1Session__base.html#a21b146b02d257d95f4aaeaca12b8d320">on_passive_open_channel_func_or_empty</a> () const</td></tr>
<tr class="memdesc:a21b146b02d257d95f4aaeaca12b8d320 inherit pro_methods_classipc_1_1session_1_1Session__base"><td class="mdescLeft">&#160;</td><td class="mdescRight">The on-passive-open handler (may be empty even in final state, meaning user wants passive-opens disabled on this side).  <a href="classipc_1_1session_1_1Session__base.html#a21b146b02d257d95f4aaeaca12b8d320">More...</a><br /></td></tr>
<tr class="separator:a21b146b02d257d95f4aaeaca12b8d320 inherit pro_methods_classipc_1_1session_1_1Session__base"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7f9e67dccbab4f3191734c2834bafb63 inherit pro_methods_classipc_1_1session_1_1Session__base"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classipc_1_1session_1_1Session__base.html#a7f9e67dccbab4f3191734c2834bafb63">hose</a> (const <a class="el" href="namespaceipc.html#aa3192e586cc45d3e7c22463bf2760f89">Error_code</a> &amp;err_code)</td></tr>
<tr class="memdesc:a7f9e67dccbab4f3191734c2834bafb63 inherit pro_methods_classipc_1_1session_1_1Session__base"><td class="mdescLeft">&#160;</td><td class="mdescRight">Marks this session as hosed for (truthy) reason <code>err_code</code>; and <em>synchronously</em> invokes on-error handler; only invoke if not already <a class="el" href="classipc_1_1session_1_1Session__base.html#a398f3e6a30b3fae8e110af9fd1ff75e3" title="Returns true if and only if hose() has been called.">hosed()</a>.  <a href="classipc_1_1session_1_1Session__base.html#a7f9e67dccbab4f3191734c2834bafb63">More...</a><br /></td></tr>
<tr class="separator:a7f9e67dccbab4f3191734c2834bafb63 inherit pro_methods_classipc_1_1session_1_1Session__base"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a398f3e6a30b3fae8e110af9fd1ff75e3 inherit pro_methods_classipc_1_1session_1_1Session__base"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classipc_1_1session_1_1Session__base.html#a398f3e6a30b3fae8e110af9fd1ff75e3">hosed</a> () const</td></tr>
<tr class="memdesc:a398f3e6a30b3fae8e110af9fd1ff75e3 inherit pro_methods_classipc_1_1session_1_1Session__base"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns <code>true</code> if and only if <a class="el" href="classipc_1_1session_1_1Session__base.html#a7f9e67dccbab4f3191734c2834bafb63" title="Marks this session as hosed for (truthy) reason err_code; and synchronously invokes on-error handler;...">hose()</a> has been called.  <a href="classipc_1_1session_1_1Session__base.html#a398f3e6a30b3fae8e110af9fd1ff75e3">More...</a><br /></td></tr>
<tr class="separator:a398f3e6a30b3fae8e110af9fd1ff75e3 inherit pro_methods_classipc_1_1session_1_1Session__base"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pri-types" name="pri-types"></a>
Private Types</h2></td></tr>
<tr class="memitem:af7a951bd266bdd0e3339a0fbddba9e8b"><td class="memItemLeft" align="right" valign="top">enum class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classipc_1_1session_1_1Client__session__impl.html#af7a951bd266bdd0e3339a0fbddba9e8b">State</a> { <a class="el" href="classipc_1_1session_1_1Client__session__impl.html#af7a951bd266bdd0e3339a0fbddba9e8bac6bd7568063494695099321f427efcb2">S_NULL</a>
, <a class="el" href="classipc_1_1session_1_1Client__session__impl.html#af7a951bd266bdd0e3339a0fbddba9e8baae585d03fce4ac2011967830bf0ffbfb">S_CONNECTING</a>
, <a class="el" href="classipc_1_1session_1_1Client__session__impl.html#af7a951bd266bdd0e3339a0fbddba9e8bad9a05d721258c584cd559c56fd035887">S_PEER</a>
 }</td></tr>
<tr class="memdesc:af7a951bd266bdd0e3339a0fbddba9e8b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Overall state of a <a class="el" href="classipc_1_1session_1_1Client__session__impl.html" title="Internal, non-movable pImpl-lite implementation of Client_session_mv class template.">Client_session_impl</a>.  <a href="classipc_1_1session_1_1Client__session__impl.html#af7a951bd266bdd0e3339a0fbddba9e8b">More...</a><br /></td></tr>
<tr class="separator:af7a951bd266bdd0e3339a0fbddba9e8b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad432ab4e95ddcfd0396d5ea821dec15c"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classipc_1_1session_1_1Client__session__impl.html#ad432ab4e95ddcfd0396d5ea821dec15c">Master_structured_channel_ptr</a> = typename <a class="el" href="classipc_1_1session_1_1Session__base.html#af0ca2a01d7d0d92038aae56fc1cdd505">Base::Master_structured_channel_ptr</a></td></tr>
<tr class="memdesc:ad432ab4e95ddcfd0396d5ea821dec15c"><td class="mdescLeft">&#160;</td><td class="mdescRight">See <a class="el" href="classipc_1_1session_1_1Session__base.html" title="Internal type containing data and types common to internal types Server_session_impl and Client_sessi...">Session_base</a>.  <a href="classipc_1_1session_1_1Client__session__impl.html#ad432ab4e95ddcfd0396d5ea821dec15c">More...</a><br /></td></tr>
<tr class="separator:ad432ab4e95ddcfd0396d5ea821dec15c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6a1cb9c344c312b4eff5c360d7114e2c"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classipc_1_1session_1_1Client__session__impl.html#a6a1cb9c344c312b4eff5c360d7114e2c">Master_structured_channel_observer</a> = typename <a class="el" href="classipc_1_1session_1_1Session__base.html#ae2a123b29dd044a638e94d1f294c8f28">Base::Master_structured_channel_observer</a></td></tr>
<tr class="memdesc:a6a1cb9c344c312b4eff5c360d7114e2c"><td class="mdescLeft">&#160;</td><td class="mdescRight">See <a class="el" href="classipc_1_1session_1_1Session__base.html" title="Internal type containing data and types common to internal types Server_session_impl and Client_sessi...">Session_base</a>.  <a href="classipc_1_1session_1_1Client__session__impl.html#a6a1cb9c344c312b4eff5c360d7114e2c">More...</a><br /></td></tr>
<tr class="separator:a6a1cb9c344c312b4eff5c360d7114e2c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa4a518c48b0611e13ad4982d067674f7"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classipc_1_1session_1_1Client__session__impl.html#aa4a518c48b0611e13ad4982d067674f7">Persistent_mq_handle_from_cfg</a> = typename <a class="el" href="classipc_1_1session_1_1Session__base.html#a848c0f5247644ada0f8b0ab816eedda8">Base::Persistent_mq_handle_from_cfg</a></td></tr>
<tr class="memdesc:aa4a518c48b0611e13ad4982d067674f7"><td class="mdescLeft">&#160;</td><td class="mdescRight">See <a class="el" href="classipc_1_1session_1_1Session__base.html" title="Internal type containing data and types common to internal types Server_session_impl and Client_sessi...">Session_base</a>.  <a href="classipc_1_1session_1_1Client__session__impl.html#aa4a518c48b0611e13ad4982d067674f7">More...</a><br /></td></tr>
<tr class="separator:aa4a518c48b0611e13ad4982d067674f7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad6624a4b1f7fd6e24bdde50b323b8f97"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classipc_1_1session_1_1Client__session__impl.html#ad6624a4b1f7fd6e24bdde50b323b8f97">On_passive_open_channel_func</a> = typename <a class="el" href="classipc_1_1session_1_1Session__base.html#a3c0824a54ef32915c5c5ea76481f2409">Base::On_passive_open_channel_func</a></td></tr>
<tr class="memdesc:ad6624a4b1f7fd6e24bdde50b323b8f97"><td class="mdescLeft">&#160;</td><td class="mdescRight">See <a class="el" href="classipc_1_1session_1_1Session__base.html" title="Internal type containing data and types common to internal types Server_session_impl and Client_sessi...">Session_base</a>.  <a href="classipc_1_1session_1_1Client__session__impl.html#ad6624a4b1f7fd6e24bdde50b323b8f97">More...</a><br /></td></tr>
<tr class="separator:ad6624a4b1f7fd6e24bdde50b323b8f97"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abe6c733821534ec020b7cec02cfc3e66"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classipc_1_1session_1_1Client__session__impl.html#abe6c733821534ec020b7cec02cfc3e66">Master_channel_req_ptr</a> = boost::shared_ptr&lt; <a class="el" href="structipc_1_1session_1_1Client__session__impl_1_1Master__channel__req.html">Master_channel_req</a> &gt;</td></tr>
<tr class="memdesc:abe6c733821534ec020b7cec02cfc3e66"><td class="mdescLeft">&#160;</td><td class="mdescRight">Short-hand for ref-counted pointer to <a class="el" href="structipc_1_1session_1_1Client__session__impl_1_1Master__channel__req.html" title="An open-channel/log-in request out-message.">Master_channel_req</a>.  <a href="classipc_1_1session_1_1Client__session__impl.html#abe6c733821534ec020b7cec02cfc3e66">More...</a><br /></td></tr>
<tr class="separator:abe6c733821534ec020b7cec02cfc3e66"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pri-methods" name="pri-methods"></a>
Private Member Functions</h2></td></tr>
<tr class="memitem:aeaf64876702dffaab7441e3006195134"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classipc_1_1session_1_1Client__session__impl.html#aeaf64876702dffaab7441e3006195134">Client_session_impl</a> (flow::log::Logger *logger_ptr, const <a class="el" href="structipc_1_1session_1_1Client__app.html">Client_app</a> &amp;cli_app_ref, const <a class="el" href="structipc_1_1session_1_1Server__app.html">Server_app</a> &amp;srv_app_ref, flow::async::Task_asio_err &amp;&amp;on_err_func, <a class="el" href="classipc_1_1session_1_1Client__session__impl.html#ad6624a4b1f7fd6e24bdde50b323b8f97">On_passive_open_channel_func</a> &amp;&amp;on_passive_open_channel_func_or_empty_arg, std::nullptr_t tag)</td></tr>
<tr class="memdesc:aeaf64876702dffaab7441e3006195134"><td class="mdescLeft">&#160;</td><td class="mdescRight">Delegated-to ctor that implements both non-default <code>public</code> ctors.  <a href="classipc_1_1session_1_1Client__session__impl.html#aeaf64876702dffaab7441e3006195134">More...</a><br /></td></tr>
<tr class="separator:aeaf64876702dffaab7441e3006195134"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a417e9c40eefdfb4622f84275795640c4"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classipc_1_1session_1_1Client__session__impl.html#a417e9c40eefdfb4622f84275795640c4">on_master_channel_error</a> (const <a class="el" href="classipc_1_1session_1_1Client__session__impl.html#a6a1cb9c344c312b4eff5c360d7114e2c">Master_structured_channel_observer</a> &amp;master_channel_observer, const <a class="el" href="namespaceipc.html#aa3192e586cc45d3e7c22463bf2760f89">Error_code</a> &amp;err_code)</td></tr>
<tr class="memdesc:a417e9c40eefdfb4622f84275795640c4"><td class="mdescLeft">&#160;</td><td class="mdescRight">In thread W, handler for <a class="el" href="classipc_1_1session_1_1Client__session__impl.html#a3acf3432c3806476fc20e951d0790949" title="The session master channel.">m_master_channel</a> indicating incoming-direction channel-hosing error.  <a href="classipc_1_1session_1_1Client__session__impl.html#a417e9c40eefdfb4622f84275795640c4">More...</a><br /></td></tr>
<tr class="separator:a417e9c40eefdfb4622f84275795640c4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a139fde1cf8dc2c64276b9eb25b35bcee"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classipc_1_1session_1_1Client__session__impl.html#a139fde1cf8dc2c64276b9eb25b35bcee">on_master_channel_log_in_rsp</a> (typename Master_structured_channel::Msg_in_ptr &amp;&amp;log_in_rsp, <a class="el" href="classipc_1_1session_1_1Client__session__impl.html#aab1b23e3370a77db375a50ab156b5662">Channels</a> *init_channels_by_cli_req_pre_sized, <a class="el" href="classipc_1_1session_1_1Client__session__impl.html#ad0ad69f676fc1260a3c493781fbbb81d">Mdt_reader_ptr</a> *mdt_from_srv_or_null, <a class="el" href="classipc_1_1session_1_1Client__session__impl.html#aab1b23e3370a77db375a50ab156b5662">Channels</a> *init_channels_by_srv_req)</td></tr>
<tr class="memdesc:a139fde1cf8dc2c64276b9eb25b35bcee"><td class="mdescLeft">&#160;</td><td class="mdescRight">In thread W, handler for the successful receipt of log-in response (upon <code>send()</code>ing the log-in request), as invoked in CONNECTING state only if the low-level transport::Native_socket_stream::async_connect() succeeded.  <a href="classipc_1_1session_1_1Client__session__impl.html#a139fde1cf8dc2c64276b9eb25b35bcee">More...</a><br /></td></tr>
<tr class="separator:a139fde1cf8dc2c64276b9eb25b35bcee"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac983066e433f143cf02cd730260e6e65"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classipc_1_1session_1_1Client__session__impl.html#ac983066e433f143cf02cd730260e6e65">on_master_channel_init_open_channel</a> (typename Master_structured_channel::Msg_in_ptr &amp;&amp;open_channel_msg, size_t n_init_channels, const boost::shared_ptr&lt; <a class="el" href="classipc_1_1session_1_1Client__session__impl.html#aab1b23e3370a77db375a50ab156b5662">Channels</a> &gt; &amp;init_channels_ptr, <a class="el" href="classipc_1_1session_1_1Client__session__impl.html#aab1b23e3370a77db375a50ab156b5662">Channels</a> *init_channels_by_cli_req_pre_sized, <a class="el" href="classipc_1_1session_1_1Client__session__impl.html#ad0ad69f676fc1260a3c493781fbbb81d">Mdt_reader_ptr</a> *mdt_from_srv_or_null, <a class="el" href="classipc_1_1session_1_1Client__session__impl.html#aab1b23e3370a77db375a50ab156b5662">Channels</a> *init_channels_by_srv_req, <a class="el" href="classipc_1_1session_1_1Client__session__impl.html#ad0ad69f676fc1260a3c493781fbbb81d">Mdt_reader_ptr</a> &amp;&amp;mdt_from_srv)</td></tr>
<tr class="memdesc:ac983066e433f143cf02cd730260e6e65"><td class="mdescLeft">&#160;</td><td class="mdescRight">In thread W, handler for <a class="el" href="classipc_1_1session_1_1Client__session__impl.html#a3acf3432c3806476fc20e951d0790949" title="The session master channel.">m_master_channel</a> receiving a init-channel-open message.  <a href="classipc_1_1session_1_1Client__session__impl.html#ac983066e433f143cf02cd730260e6e65">More...</a><br /></td></tr>
<tr class="separator:ac983066e433f143cf02cd730260e6e65"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a84bcd253bb1cd89fcf94233c2f771142"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classipc_1_1session_1_1Client__session__impl.html#a84bcd253bb1cd89fcf94233c2f771142">on_master_channel_open_channel_req</a> (typename Master_structured_channel::Msg_in_ptr &amp;&amp;open_channel_req)</td></tr>
<tr class="memdesc:a84bcd253bb1cd89fcf94233c2f771142"><td class="mdescLeft">&#160;</td><td class="mdescRight">In thread W, handler for <a class="el" href="classipc_1_1session_1_1Client__session__impl.html#a3acf3432c3806476fc20e951d0790949" title="The session master channel.">m_master_channel</a> receiving a passive-open (a/k/a open-channel-to-client) request.  <a href="classipc_1_1session_1_1Client__session__impl.html#a84bcd253bb1cd89fcf94233c2f771142">More...</a><br /></td></tr>
<tr class="separator:a84bcd253bb1cd89fcf94233c2f771142"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6c67f6c993089dadf16acb47d535cb68"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classipc_1_1session_1_1Client__session__impl.html#a6c67f6c993089dadf16acb47d535cb68">create_channel_obj</a> (const <a class="el" href="namespaceipc_1_1session.html#a6d07d9996af19e57eb42416e914110ea">Shared_name</a> &amp;mq_name_c2s_or_none, const <a class="el" href="namespaceipc_1_1session.html#a6d07d9996af19e57eb42416e914110ea">Shared_name</a> &amp;mq_name_s2c_or_none, <a class="el" href="structipc_1_1util_1_1Native__handle.html">util::Native_handle</a> &amp;&amp;local_hndl_or_null, <a class="el" href="classipc_1_1session_1_1Client__session__impl.html#a994a2f0b281fdeaeb6c09f6d91df351a">Channel_obj</a> *opened_channel_ptr, bool active_else_passive, <a class="el" href="namespaceipc.html#aa3192e586cc45d3e7c22463bf2760f89">Error_code</a> *err_code_ptr)</td></tr>
<tr class="memdesc:a6c67f6c993089dadf16acb47d535cb68"><td class="mdescLeft">&#160;</td><td class="mdescRight">In thread W, based on resources acquired on server side, creates local <a class="el" href="classipc_1_1session_1_1Client__session__impl.html#a994a2f0b281fdeaeb6c09f6d91df351a" title="See Client_session_mv counterpart.">Channel_obj</a> to emit to the user thus completing a channel-open.  <a href="classipc_1_1session_1_1Client__session__impl.html#a6c67f6c993089dadf16acb47d535cb68">More...</a><br /></td></tr>
<tr class="separator:a6c67f6c993089dadf16acb47d535cb68"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a428ae010a09aae1bac509e87fd927152"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classipc_1_1session_1_1Client__session__impl.html#a428ae010a09aae1bac509e87fd927152">invoke_conn_on_done_func</a> (const <a class="el" href="namespaceipc.html#aa3192e586cc45d3e7c22463bf2760f89">Error_code</a> &amp;err_code)</td></tr>
<tr class="memdesc:a428ae010a09aae1bac509e87fd927152"><td class="mdescLeft">&#160;</td><td class="mdescRight">Little helper that invokes <a class="el" href="classipc_1_1session_1_1Client__session__impl.html#addb0e40c34f2ae44ee1252f8123c149c" title="The on_done_func argument to async_connect(); .empty() except while in State::S_CONNECTING state.">m_conn_on_done_func_or_empty</a>, passing it <code>err_code</code>, and &ndash; per that member's internal use semantics &ndash; empties <a class="el" href="classipc_1_1session_1_1Client__session__impl.html#addb0e40c34f2ae44ee1252f8123c149c" title="The on_done_func argument to async_connect(); .empty() except while in State::S_CONNECTING state.">m_conn_on_done_func_or_empty</a>.  <a href="classipc_1_1session_1_1Client__session__impl.html#a428ae010a09aae1bac509e87fd927152">More...</a><br /></td></tr>
<tr class="separator:a428ae010a09aae1bac509e87fd927152"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pri-attribs" name="pri-attribs"></a>
Private Attributes</h2></td></tr>
<tr class="memitem:a3a5f5102020adace1e898d977e929908"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classipc_1_1session_1_1Client__session__impl.html#af7a951bd266bdd0e3339a0fbddba9e8b">State</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classipc_1_1session_1_1Client__session__impl.html#a3a5f5102020adace1e898d977e929908">m_state</a></td></tr>
<tr class="memdesc:a3a5f5102020adace1e898d977e929908"><td class="mdescLeft">&#160;</td><td class="mdescRight">The current state of <code>*this</code>.  <a href="classipc_1_1session_1_1Client__session__impl.html#a3a5f5102020adace1e898d977e929908">More...</a><br /></td></tr>
<tr class="separator:a3a5f5102020adace1e898d977e929908"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab55fdca2097f5444f35efc97a8af326b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classipc_1_1transport_1_1Protocol__negotiator.html">transport::Protocol_negotiator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classipc_1_1session_1_1Client__session__impl.html#ab55fdca2097f5444f35efc97a8af326b">m_protocol_negotiator</a></td></tr>
<tr class="memdesc:ab55fdca2097f5444f35efc97a8af326b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Handles the protocol negotiation at the start of the pipe, as pertains to algorithms perpetuated by the vanilla <a class="el" href="namespaceipc_1_1session.html" title="Flow-IPC module providing the broad lifecycle and shared-resource organization  via the session conc...">ipc::session</a> <code><a class="el" href="classipc_1_1session_1_1Session.html" title="A documentation-only concept defining the local side of an IPC conversation (session) with another en...">Session</a></code> hierarchy.  <a href="classipc_1_1session_1_1Client__session__impl.html#ab55fdca2097f5444f35efc97a8af326b">More...</a><br /></td></tr>
<tr class="separator:ab55fdca2097f5444f35efc97a8af326b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3c53046a113fcf1ba4c857e8d4c2fbbd"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classipc_1_1transport_1_1Protocol__negotiator.html">transport::Protocol_negotiator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classipc_1_1session_1_1Client__session__impl.html#a3c53046a113fcf1ba4c857e8d4c2fbbd">m_protocol_negotiator_aux</a></td></tr>
<tr class="memdesc:a3c53046a113fcf1ba4c857e8d4c2fbbd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Analogous to <a class="el" href="classipc_1_1session_1_1Client__session__impl.html#ab55fdca2097f5444f35efc97a8af326b" title="Handles the protocol negotiation at the start of the pipe, as pertains to algorithms perpetuated by t...">m_protocol_negotiator</a> but pertains to algorithms perpetuated by (if relevant) non-vanilla <a class="el" href="namespaceipc_1_1session.html" title="Flow-IPC module providing the broad lifecycle and shared-resource organization  via the session conc...">ipc::session</a> <code><a class="el" href="classipc_1_1session_1_1Session.html" title="A documentation-only concept defining the local side of an IPC conversation (session) with another en...">Session</a></code> hierarchy implemented on top of our vanilla <a class="el" href="namespaceipc_1_1session.html" title="Flow-IPC module providing the broad lifecycle and shared-resource organization  via the session conc...">ipc::session</a> <code><a class="el" href="classipc_1_1session_1_1Session.html" title="A documentation-only concept defining the local side of an IPC conversation (session) with another en...">Session</a></code> hierarchy.  <a href="classipc_1_1session_1_1Client__session__impl.html#a3c53046a113fcf1ba4c857e8d4c2fbbd">More...</a><br /></td></tr>
<tr class="separator:a3c53046a113fcf1ba4c857e8d4c2fbbd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:addb0e40c34f2ae44ee1252f8123c149c"><td class="memItemLeft" align="right" valign="top">flow::async::Task_asio_err&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classipc_1_1session_1_1Client__session__impl.html#addb0e40c34f2ae44ee1252f8123c149c">m_conn_on_done_func_or_empty</a></td></tr>
<tr class="memdesc:addb0e40c34f2ae44ee1252f8123c149c"><td class="mdescLeft">&#160;</td><td class="mdescRight">The <code>on_done_func</code> argument to <a class="el" href="classipc_1_1session_1_1Client__session__impl.html#a56c0d2b0ff082d1f7b0738e2528b4a92" title="Core implementation of sync_connect().">async_connect()</a>; <code>.empty()</code> except while in <a class="el" href="classipc_1_1session_1_1Client__session__impl.html#af7a951bd266bdd0e3339a0fbddba9e8baae585d03fce4ac2011967830bf0ffbfb" title="Not a peer but async_connect() in progress to try to make it a peer.">State::S_CONNECTING</a> state.  <a href="classipc_1_1session_1_1Client__session__impl.html#addb0e40c34f2ae44ee1252f8123c149c">More...</a><br /></td></tr>
<tr class="separator:addb0e40c34f2ae44ee1252f8123c149c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ade1b57a26147ececddbd0234c0b63be9"><td class="memItemLeft" align="right" valign="top">unsigned int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classipc_1_1session_1_1Client__session__impl.html#ade1b57a26147ececddbd0234c0b63be9">m_last_actively_opened_channel_id</a></td></tr>
<tr class="memdesc:ade1b57a26147ececddbd0234c0b63be9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Logging-only <code>*this</code>-unique ID used in nicknaming the last actively-opened (via <a class="el" href="classipc_1_1session_1_1Client__session__impl.html#a4a377590fbf55b6d312f24d888d2a1bd" title="See Client_session_mv counterpart.">open_channel()</a>) channel.  <a href="classipc_1_1session_1_1Client__session__impl.html#ade1b57a26147ececddbd0234c0b63be9">More...</a><br /></td></tr>
<tr class="separator:ade1b57a26147ececddbd0234c0b63be9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a89d1ce46faa61df455b6f186eb892711"><td class="memItemLeft" align="right" valign="top">unsigned int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classipc_1_1session_1_1Client__session__impl.html#a89d1ce46faa61df455b6f186eb892711">m_last_passively_opened_channel_id</a></td></tr>
<tr class="memdesc:a89d1ce46faa61df455b6f186eb892711"><td class="mdescLeft">&#160;</td><td class="mdescRight">A-la <a class="el" href="classipc_1_1session_1_1Client__session__impl.html#ade1b57a26147ececddbd0234c0b63be9" title="Logging-only *this-unique ID used in nicknaming the last actively-opened (via open_channel()) channel...">m_last_actively_opened_channel_id</a> but for passively-opened channels (<a class="el" href="classipc_1_1session_1_1Client__session__impl.html#a84bcd253bb1cd89fcf94233c2f771142" title="In thread W, handler for m_master_channel receiving a passive-open (a/k/a open-channel-to-client) req...">on_master_channel_open_channel_req()</a>).  <a href="classipc_1_1session_1_1Client__session__impl.html#a89d1ce46faa61df455b6f186eb892711">More...</a><br /></td></tr>
<tr class="separator:a89d1ce46faa61df455b6f186eb892711"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac3039c565e1da99296dfb71255129201"><td class="memItemLeft" align="right" valign="top">flow::async::Single_thread_task_loop&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classipc_1_1session_1_1Client__session__impl.html#ac3039c565e1da99296dfb71255129201">m_async_worker</a></td></tr>
<tr class="memdesc:ac3039c565e1da99296dfb71255129201"><td class="mdescLeft">&#160;</td><td class="mdescRight">Worker thread (a/k/a thread W).  <a href="classipc_1_1session_1_1Client__session__impl.html#ac3039c565e1da99296dfb71255129201">More...</a><br /></td></tr>
<tr class="separator:ac3039c565e1da99296dfb71255129201"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3acf3432c3806476fc20e951d0790949"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classipc_1_1session_1_1Client__session__impl.html#ad432ab4e95ddcfd0396d5ea821dec15c">Master_structured_channel_ptr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classipc_1_1session_1_1Client__session__impl.html#a3acf3432c3806476fc20e951d0790949">m_master_channel</a></td></tr>
<tr class="memdesc:a3acf3432c3806476fc20e951d0790949"><td class="mdescLeft">&#160;</td><td class="mdescRight">The session master channel.  <a href="classipc_1_1session_1_1Client__session__impl.html#a3acf3432c3806476fc20e951d0790949">More...</a><br /></td></tr>
<tr class="separator:a3acf3432c3806476fc20e951d0790949"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abba4e0890f2d40b0f0cd76ecface739f"><td class="memItemLeft" align="right" valign="top">std::optional&lt; typename <a class="el" href="classipc_1_1session_1_1Session__base_1_1Graceful__finisher.html">Base::Graceful_finisher</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classipc_1_1session_1_1Client__session__impl.html#abba4e0890f2d40b0f0cd76ecface739f">m_graceful_finisher</a></td></tr>
<tr class="memdesc:abba4e0890f2d40b0f0cd76ecface739f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Null until PEER state is reached, and NULL unless compile-time <a class="el" href="classipc_1_1session_1_1Client__session__impl.html#a65fe6d3d227016858428a170db961cc7" title="Short-hand for template parameter knob S_GRACEFUL_FINISH_REQUIRED_V: see class template doc header.">S_GRACEFUL_FINISH_REQUIRED</a> is <code>true</code>, this is used to block at the start of dtor to synchronize with the opposing <code><a class="el" href="classipc_1_1session_1_1Session.html" title="A documentation-only concept defining the local side of an IPC conversation (session) with another en...">Session</a></code> dtor for safety.  <a href="classipc_1_1session_1_1Client__session__impl.html#abba4e0890f2d40b0f0cd76ecface739f">More...</a><br /></td></tr>
<tr class="separator:abba4e0890f2d40b0f0cd76ecface739f"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="related" name="related"></a>
Related Functions</h2></td></tr>
<tr><td class="ititle" colspan="2"><p >(Note that these are not member functions.) </p>
</td></tr>
<tr class="memitem:a7c3b6df1a8dab3a2c31b3ad492aa5d8a"><td class="memTemplParams" colspan="2">template&lt;schema::MqType S_MQ_TYPE_OR_NONE, bool S_TRANSMIT_NATIVE_HANDLES, typename Mdt_payload , schema::ShmType S_SHM_TYPE_OR_NONE, bool S_GRACEFUL_FINISH_REQUIRED_V&gt; </td></tr>
<tr class="memitem:a7c3b6df1a8dab3a2c31b3ad492aa5d8a"><td class="memTemplItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classipc_1_1session_1_1Client__session__impl.html#a7c3b6df1a8dab3a2c31b3ad492aa5d8a">operator&lt;&lt;</a> (std::ostream &amp;os, const <a class="el" href="classipc_1_1session_1_1Client__session__impl.html">Client_session_impl</a>&lt; S_MQ_TYPE_OR_NONE, S_TRANSMIT_NATIVE_HANDLES, Mdt_payload, S_SHM_TYPE_OR_NONE, S_GRACEFUL_FINISH_REQUIRED_V &gt; &amp;val)</td></tr>
<tr class="memdesc:a7c3b6df1a8dab3a2c31b3ad492aa5d8a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Prints string representation of the given <code><a class="el" href="classipc_1_1session_1_1Client__session__impl.html" title="Internal, non-movable pImpl-lite implementation of Client_session_mv class template.">Client_session_impl</a></code> to the given <code>ostream</code>.  <a href="classipc_1_1session_1_1Client__session__impl.html#a7c3b6df1a8dab3a2c31b3ad492aa5d8a">More...</a><br /></td></tr>
<tr class="separator:a7c3b6df1a8dab3a2c31b3ad492aa5d8a"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="inherited" name="inherited"></a>
Additional Inherited Members</h2></td></tr>
<tr class="inherit_header pub_static_methods_classipc_1_1session_1_1Session__base"><td colspan="2" onclick="javascript:toggleInherit('pub_static_methods_classipc_1_1session_1_1Session__base')"><img src="closed.png" alt="-"/>&#160;Static Public Member Functions inherited from <a class="el" href="classipc_1_1session_1_1Session__base.html">ipc::session::Session_base&lt; S_MQ_TYPE_OR_NONE, S_TRANSMIT_NATIVE_HANDLES, Mdt_payload &gt;</a></td></tr>
<tr class="memitem:a08b3d69a6707dcbb233076b7a48de285 inherit pub_static_methods_classipc_1_1session_1_1Session__base"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classipc_1_1session_1_1Session__base.html#aee0db48505c84d3553b7110a9a815036">Structured_msg_builder_config</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classipc_1_1session_1_1Session__base.html#a08b3d69a6707dcbb233076b7a48de285">heap_fixed_builder_config</a> (flow::log::Logger *logger_ptr)</td></tr>
<tr class="memdesc:a08b3d69a6707dcbb233076b7a48de285 inherit pub_static_methods_classipc_1_1session_1_1Session__base"><td class="mdescLeft">&#160;</td><td class="mdescRight">See <a class="el" href="classipc_1_1session_1_1Session__mv.html#a107684fdd5d233549c6daac26a81a542" title="Utility that obtains a heap-based (non-zero-copy) Struct_builder::Config, constructed with the most e...">Session_mv::heap_fixed_builder_config()</a> (1-arg).  <a href="classipc_1_1session_1_1Session__base.html#a08b3d69a6707dcbb233076b7a48de285">More...</a><br /></td></tr>
<tr class="separator:a08b3d69a6707dcbb233076b7a48de285 inherit pub_static_methods_classipc_1_1session_1_1Session__base"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a489bb6ec7726e39e78dcd4dd2fe3de75 inherit pub_static_methods_classipc_1_1session_1_1Session__base"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classipc_1_1session_1_1Session__base.html#abd854f2b9316361ef18f15610c242d4b">Structured_msg_reader_config</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classipc_1_1session_1_1Session__base.html#a489bb6ec7726e39e78dcd4dd2fe3de75">heap_reader_config</a> (flow::log::Logger *logger_ptr)</td></tr>
<tr class="memdesc:a489bb6ec7726e39e78dcd4dd2fe3de75 inherit pub_static_methods_classipc_1_1session_1_1Session__base"><td class="mdescLeft">&#160;</td><td class="mdescRight">See <a class="el" href="classipc_1_1session_1_1Session__mv.html#ab3c69e3f8ccbd70d315bed86d697255d" title="Deserializing counterpart to non-static heap_fixed_builder_config().">Session_mv::heap_reader_config()</a> (1-arg).  <a href="classipc_1_1session_1_1Session__base.html#a489bb6ec7726e39e78dcd4dd2fe3de75">More...</a><br /></td></tr>
<tr class="separator:a489bb6ec7726e39e78dcd4dd2fe3de75 inherit pub_static_methods_classipc_1_1session_1_1Session__base"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pub_attribs_classipc_1_1session_1_1Session__base"><td colspan="2" onclick="javascript:toggleInherit('pub_attribs_classipc_1_1session_1_1Session__base')"><img src="closed.png" alt="-"/>&#160;Public Attributes inherited from <a class="el" href="classipc_1_1session_1_1Session__base.html">ipc::session::Session_base&lt; S_MQ_TYPE_OR_NONE, S_TRANSMIT_NATIVE_HANDLES, Mdt_payload &gt;</a></td></tr>
<tr class="memitem:afd32d90b86d699263a0f02637dd7c6c6 inherit pub_attribs_classipc_1_1session_1_1Session__base"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="structipc_1_1session_1_1Server__app.html">Server_app</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classipc_1_1session_1_1Session__base.html#afd32d90b86d699263a0f02637dd7c6c6">m_srv_app_ref</a></td></tr>
<tr class="memdesc:afd32d90b86d699263a0f02637dd7c6c6 inherit pub_attribs_classipc_1_1session_1_1Session__base"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reference to <a class="el" href="structipc_1_1session_1_1Server__app.html" title="An App that is used as a server in at least one client-server IPC split.">Server_app</a> (referring to local process in <a class="el" href="classipc_1_1session_1_1Server__session__impl.html" title="Internal, non-movable pImpl-lite implementation of Server_session_mv class template.">Server_session_impl</a>, opposing process in <a class="el" href="classipc_1_1session_1_1Client__session__impl.html" title="Internal, non-movable pImpl-lite implementation of Client_session_mv class template.">Client_session_impl</a>).  <a href="classipc_1_1session_1_1Session__base.html#afd32d90b86d699263a0f02637dd7c6c6">More...</a><br /></td></tr>
<tr class="separator:afd32d90b86d699263a0f02637dd7c6c6 inherit pub_attribs_classipc_1_1session_1_1Session__base"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pro_static_attribs_classipc_1_1session_1_1Session__base"><td colspan="2" onclick="javascript:toggleInherit('pro_static_attribs_classipc_1_1session_1_1Session__base')"><img src="closed.png" alt="-"/>&#160;Static Protected Attributes inherited from <a class="el" href="classipc_1_1session_1_1Session__base.html">ipc::session::Session_base&lt; S_MQ_TYPE_OR_NONE, S_TRANSMIT_NATIVE_HANDLES, Mdt_payload &gt;</a></td></tr>
<tr class="memitem:ae68b7b80ff82ba5cde28a53fa52a5095 inherit pro_static_attribs_classipc_1_1session_1_1Session__base"><td class="memItemLeft" align="right" valign="top">static constexpr <a class="el" href="namespaceipc_1_1util.html#ac66141280c3b7295a86b65209f31cc58">util::Fine_duration</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classipc_1_1session_1_1Session__base.html#ae68b7b80ff82ba5cde28a53fa52a5095">S_OPEN_CHANNEL_TIMEOUT</a> = boost::chrono::seconds(60)</td></tr>
<tr class="memdesc:ae68b7b80ff82ba5cde28a53fa52a5095 inherit pro_static_attribs_classipc_1_1session_1_1Session__base"><td class="mdescLeft">&#160;</td><td class="mdescRight">Internal timeout for <code>open_channel()</code>.  <a href="classipc_1_1session_1_1Session__base.html#ae68b7b80ff82ba5cde28a53fa52a5095">More...</a><br /></td></tr>
<tr class="separator:ae68b7b80ff82ba5cde28a53fa52a5095 inherit pro_static_attribs_classipc_1_1session_1_1Session__base"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af0b52934c6b1204cb3ba676480727d27 inherit pro_static_attribs_classipc_1_1session_1_1Session__base"><td class="memItemLeft" align="right" valign="top">static constexpr size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classipc_1_1session_1_1Session__base.html#af0b52934c6b1204cb3ba676480727d27">S_MQS_MAX_MSG_SZ</a> = 8 * 1024</td></tr>
<tr class="memdesc:af0b52934c6b1204cb3ba676480727d27 inherit pro_static_attribs_classipc_1_1session_1_1Session__base"><td class="mdescLeft">&#160;</td><td class="mdescRight">The max sendable MQ message size as decided by <a class="el" href="classipc_1_1session_1_1Server__session__impl.html#a84d54a57d3e06c064cde737d1f4be472" title="Helper for create_channel_and_resources(), invoked and compiled if and only if S_MQS_ENABLED,...">Server_session_impl::make_channel_mqs()</a> (and imposed on both sides, both directions), if <a class="el" href="classipc_1_1session_1_1Session__base.html#a27a5731a648effb6b4b42f0312affa74" title="See Session_mv.">S_MQS_ENABLED</a> <em>and</em> <a class="el" href="classipc_1_1session_1_1Server__session__impl.html#a1ded7990451b90f29e11f8fa7ce0e80b" title="See Session_mv counterpart.">Server_session_impl::S_SHM_ENABLED</a> is <code>false</code>, when a channel is opened (regardless of which side did the active-open or requested pre-opening at session start).  <a href="classipc_1_1session_1_1Session__base.html#af0b52934c6b1204cb3ba676480727d27">More...</a><br /></td></tr>
<tr class="separator:af0b52934c6b1204cb3ba676480727d27 inherit pro_static_attribs_classipc_1_1session_1_1Session__base"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><div class="compoundTemplParams">template&lt;schema::MqType S_MQ_TYPE_OR_NONE, bool S_TRANSMIT_NATIVE_HANDLES, typename Mdt_payload, schema::ShmType S_SHM_TYPE_OR_NONE, bool S_GRACEFUL_FINISH_REQUIRED_V&gt;<br />
class ipc::session::Client_session_impl&lt; S_MQ_TYPE_OR_NONE, S_TRANSMIT_NATIVE_HANDLES, Mdt_payload, S_SHM_TYPE_OR_NONE, S_GRACEFUL_FINISH_REQUIRED_V &gt;</div><p >Internal, non-movable pImpl-lite implementation of <a class="el" href="classipc_1_1session_1_1Client__session__mv.html" title="Implements Session concept on the Client_app end: a Session_mv that first achieves PEER state by conn...">Client_session_mv</a> class template. </p>
<p >In and of itself it would have been directly and publicly usable; however <a class="el" href="classipc_1_1session_1_1Client__session__mv.html" title="Implements Session concept on the Client_app end: a Session_mv that first achieves PEER state by conn...">Client_session_mv</a> adds move semantics.</p>
<dl class="section see"><dt>See also</dt><dd>All discussion of the public API is in <a class="el" href="classipc_1_1session_1_1Client__session__mv.html" title="Implements Session concept on the Client_app end: a Session_mv that first achieves PEER state by conn...">Client_session_mv</a> doc header; that class template forwards to this one. All discussion of pImpl-lite-related notions is also there. See that doc header first please. Then come back here.</dd></dl>
<h2>Impl design </h2>
<p >Thread U represents all threads other than thread W: since the relevant methods are to be called by the user sans concurrency, those threads as a collection can be thought of as one thread.</p>
<p >Thread W is the async worker thread where most work is done; this helps us entirely avoid mutexes. Both <a class="el" href="classipc_1_1session_1_1Client__session__impl.html#a56c0d2b0ff082d1f7b0738e2528b4a92" title="Core implementation of sync_connect().">async_connect()</a> (from <a class="el" href="classipc_1_1session_1_1Client__session__impl.html#aaf622f5f111ffa95d4ec6c636cfddb4a" title="See Client_session_mv counterpart.">sync_connect()</a>) and <a class="el" href="classipc_1_1session_1_1Client__session__impl.html#a4a377590fbf55b6d312f24d888d2a1bd" title="See Client_session_mv counterpart.">open_channel()</a> are fairly infrequently called, so it's not necessary to avoid latency by doing work concurrently in threads U and W. So we keep it simple by posting most stuff onto thread W.</p>
<p >There are two distinct states (other than NULL): CONNECTING (<a class="el" href="classipc_1_1session_1_1Client__session__impl.html#a56c0d2b0ff082d1f7b0738e2528b4a92" title="Core implementation of sync_connect().">async_connect()</a> outstanding) and PEER (it succeeded: <code>*this</code> is now a <a class="el" href="classipc_1_1session_1_1Session.html" title="A documentation-only concept defining the local side of an IPC conversation (session) with another en...">Session</a> in PEER state per concept). (As of this writing <a class="el" href="classipc_1_1session_1_1Client__session__impl.html#a56c0d2b0ff082d1f7b0738e2528b4a92" title="Core implementation of sync_connect().">async_connect()</a> is <code>private</code> and invoked by <code>public</code> <a class="el" href="classipc_1_1session_1_1Client__session__impl.html#aaf622f5f111ffa95d4ec6c636cfddb4a" title="See Client_session_mv counterpart.">sync_connect()</a>; more on that jsut below.)</p>
<h3>CONNECTING state impl</h3>
<p >Once <a class="el" href="classipc_1_1session_1_1Client__session__impl.html#a56c0d2b0ff082d1f7b0738e2528b4a92" title="Core implementation of sync_connect().">async_connect()</a> is issued we must do the following:</p><ol type="1">
<li>Synchronously find out the full <code>Shared_name</code> where the opposing <a class="el" href="classipc_1_1session_1_1Session__server.html" title="To be instantiated typically once in a given process, an object of this type asynchronously listens f...">Session_server</a> is allegedly listening, which is computable by a <a class="el" href="classipc_1_1session_1_1Client__session__impl.html#acd9519f313206fdd2cd6ca91efb79516" title="Short-hand for base type.">Base</a> helper. So that it can be computed we need to find out <a class="el" href="classipc_1_1session_1_1Session__base.html#a4d1327608d6067ed6690bd4efa323c6f" title="See Server_session_impl, Client_session_impl.">Session_base::srv_namespace()</a> which we immediately do by checking the expected file that should have been written by <a class="el" href="classipc_1_1session_1_1Session__server.html" title="To be instantiated typically once in a given process, an object of this type asynchronously listens f...">Session_server</a>.</li>
<li>Issue the Native_socket_stream::sync_connect() which shall synchronously/non-blockingly connect to that abstract-address.</li>
<li>Once that's done, go back to NULL on failure; or continue as follows on success: The Native_socket_stream, now in PEER state (connected), is upgraded to (wrapped by) a <a class="el" href="classipc_1_1transport_1_1Channel.html" title="Peer to a bundle of 1-2 full-duplex pipe(s), one for transmitting unstructured binary blobs; the othe...">transport::Channel</a> which is in turn upgraded to a <a class="el" href="classipc_1_1transport_1_1struc_1_1Channel.html" title="Owning and wrapping a pre-connected transport::Channel peer (an endpoint of an established channel ov...">transport::struc::Channel</a> <a class="el" href="classipc_1_1session_1_1Client__session__impl.html#a3acf3432c3806476fc20e951d0790949" title="The session master channel.">Client_session_impl::m_master_channel</a>. This is the session master channel, in log-in phase (as client) (details of that API are in <a class="el" href="classipc_1_1transport_1_1struc_1_1Channel.html" title="Owning and wrapping a pre-connected transport::Channel peer (an endpoint of an established channel ov...">transport::struc::Channel</a> docs). So we immediately issue the next async step: sending the log-in request over <code>m_master_channel</code> and async-await log-in response.</li>
<li>Once that's done, go back to NULL on failure; or else yay: we're now in PEER state...</li>
<li>...almost. If the advanced form of <a class="el" href="classipc_1_1session_1_1Client__session__impl.html#aaf622f5f111ffa95d4ec6c636cfddb4a" title="See Client_session_mv counterpart.">sync_connect()</a> was the one invoked, there's an additional exchange of info about init-channels, wherein the opposing <a class="el" href="classipc_1_1session_1_1Session__server.html" title="To be instantiated typically once in a given process, an object of this type asynchronously listens f...">Session_server</a> sends us info about the pre-opened init-channels. If so, PEER state is reached upon receipt of this; otherwise immediately.</li>
</ol>
<p >See session_master_channel.capnp for the schema for <code>m_master_channel</code>. Reading that gives a nice overview of the protocol involved, both in CONNECTING (after the socket is connected) and in PEER. Also notable is that this setup allows us to immediately "eat our own dog food" by using a <code>struc::Channel</code> to enable the opening of any further channels (structured or otherwise).</p>
<h3>CONNECTING state and asynchronicity</h3>
<p >As written, <a class="el" href="classipc_1_1session_1_1Client__session__impl.html#aaf622f5f111ffa95d4ec6c636cfddb4a" title="See Client_session_mv counterpart.">sync_connect()</a> &ndash; as a black box &ndash; is synchronous and non-blocking. It is written trivially as invoking <a class="el" href="classipc_1_1session_1_1Client__session__impl.html#a56c0d2b0ff082d1f7b0738e2528b4a92" title="Core implementation of sync_connect().">async_connect()</a> (which is <code>private</code>); giving it a simple completion handler that fulfills a <code>promise</code>; <a class="el" href="classipc_1_1session_1_1Client__session__impl.html#aaf622f5f111ffa95d4ec6c636cfddb4a" title="See Client_session_mv counterpart.">sync_connect()</a> awaits this fulfillment in the user's calling thread and then returns. This raises two key questions.</p>
<p >One, how is this even possible &ndash; if there's (even internally) an async step, how can <a class="el" href="classipc_1_1session_1_1Client__session__impl.html#aaf622f5f111ffa95d4ec6c636cfddb4a" title="See Client_session_mv counterpart.">sync_connect()</a> be synchronous yet non-blocking? Answer: First we quote the <a class="el" href="classipc_1_1session_1_1Client__session__mv.html" title="Implements Session concept on the Client_app end: a Session_mv that first achieves PEER state by conn...">Client_session_mv</a> public doc header which explains why there is only <code><a class="el" href="classipc_1_1session_1_1Client__session__impl.html#aaf622f5f111ffa95d4ec6c636cfddb4a" title="See Client_session_mv counterpart.">sync_connect()</a></code> but no <code><a class="el" href="classipc_1_1session_1_1Client__session__impl.html#a56c0d2b0ff082d1f7b0738e2528b4a92" title="Core implementation of sync_connect().">async_connect()</a></code>: "Without networking, the other side (Session_server) either exists/is listening; or no.
Connecting is a synchronous, non-blocking operation; so an &lt;tt&gt;async_connect()&lt;/tt&gt; API in this context only makes
life harder for the user.  (However, there are some serious plans to add a networking-capable counterpart
(probably via TCP at least) to &lt;tt&gt;Native_socket_stream&lt;/tt&gt; and therefore Client_session_mv; such a networky-client-session
class will almost certainly have an &lt;tt&gt;async_connect()&lt;/tt&gt;, while its &lt;tt&gt;sync_connect()&lt;/tt&gt; will probably become potentially
blocking.)" So that is why it works: in a local setting, the socket-connect is synchronous/fast; and upon connecting the necessary log-in/init-channel exchange is also quick.</p>
<p >Two: Why is it written like this? Wouldn't the internal code be simpler, if it lacked asynchronicity? The answer is two-fold:</p><ul>
<li>The mundane reason as of this writing is there is no <a class="el" href="classipc_1_1transport_1_1struc_1_1Channel.html" title="Owning and wrapping a pre-connected transport::Channel peer (an endpoint of an established channel ov...">transport::struc::Channel</a> <code>sync_expect_msgs()</code>, a hypothetical method that'd await N incoming messages. That's a to-do maybe: provide <code>sync_expect_msg[s]()</code> which would be to <code>expect_msg[s]()</code> what <code>sync_request()</code> is to <code>async_request()</code>. Then the init-channel phase can be written in synchronous form.<ul>
<li>That said, the other steps listed above are already writable in synchronous form: <a class="el" href="classipc_1_1transport_1_1Native__socket__stream.html#a89d591db714e83dcb55a52738fed1ebb" title="To be invoked in NULL state only, it synchronously and non-blockingly attempts to connect to an oppos...">transport::Native_socket_stream::sync_connect()</a> we already use; the log-in <code>.async_request()</code> can be trivially replaced with <code>.sync_request()</code>.</li>
</ul>
</li>
<li>But the true, deeper reason has to do with the above public-facing quote: When/if we network-enable some form of <code>*this</code>, all 2-3 quick/synchronous steps described will potentially block; and we'll need to make <a class="el" href="classipc_1_1session_1_1Client__session__impl.html#a56c0d2b0ff082d1f7b0738e2528b4a92" title="Core implementation of sync_connect().">async_connect()</a> a public API. At that point writing <a class="el" href="classipc_1_1session_1_1Client__session__impl.html#aaf622f5f111ffa95d4ec6c636cfddb4a" title="See Client_session_mv counterpart.">sync_connect()</a> in terms of <a class="el" href="classipc_1_1session_1_1Client__session__impl.html#a56c0d2b0ff082d1f7b0738e2528b4a92" title="Core implementation of sync_connect().">async_connect()</a> will pay dividends. The trade-off is the existing code is somewhat more complex in the meantime.<ul>
<li>Detail: Since there is no public <code>Native_socket_stream::async_connect()</code> (as it, too, is not network-enabled), we do use the simpler-to-use <code>Native_socket_stream::sync_connect()</code>. Once network-enabled, that guy will become potentially blocking; so we'd need to start using the speculated public-API <code><a class="el" href="classipc_1_1session_1_1Client__session__impl.html#a56c0d2b0ff082d1f7b0738e2528b4a92" title="Core implementation of sync_connect().">async_connect()</a></code>.</li>
</ul>
</li>
</ul>
<p >A related aspect is that <code>on_done_func</code> completion handler we pass to <a class="el" href="classipc_1_1session_1_1Client__session__impl.html#a56c0d2b0ff082d1f7b0738e2528b4a92" title="Core implementation of sync_connect().">async_connect()</a> currently <em>will</em> fire before <a class="el" href="classipc_1_1session_1_1Client__session__impl.html#aaf622f5f111ffa95d4ec6c636cfddb4a" title="See Client_session_mv counterpart.">sync_connect()</a> returns; so there's no contract for the dtor to fire it with operation-aborted error code, and we can just <code>assert()</code> on this in dtor and not worry about it further. Yet if <a class="el" href="classipc_1_1session_1_1Client__session__impl.html#a56c0d2b0ff082d1f7b0738e2528b4a92" title="Core implementation of sync_connect().">async_connect()</a> becomes public, then there's no longer that guarantee, and we'll need to fire it as needed from dtor.</p>
<p >In the code itself we sometimes refer to the above discussion to hopefully make maintenance/future development easier.</p>
<dl class="section note"><dt>Note</dt><dd>If some form of <code>*this</code> becomes network-enabled, <a class="el" href="classipc_1_1session_1_1Client__session__impl.html#a4a377590fbf55b6d312f24d888d2a1bd" title="See Client_session_mv counterpart.">open_channel()</a> too will need an async form most likely, while existing <a class="el" href="classipc_1_1session_1_1Client__session__impl.html#a4a377590fbf55b6d312f24d888d2a1bd" title="See Client_session_mv counterpart.">open_channel()</a> would become potentially-blocking.</dd></dl>
<h3>Protocol negotiation</h3>
<p >First please see <a class="el" href="classipc_1_1transport_1_1struc_1_1sync__io_1_1Channel.html" title="sync_io-pattern counterpart to async-I/O-pattern transport::struc::Channel.">transport::struc::sync_io::Channel</a> doc header section of the same name. (There is involved discussion there which we definitely don't want to repeat.) Then come back here.</p>
<p >How we're similar: <code>Channel</code> decided to divide the protocols into 2: one in struc::sync_io::Channel code itself, and the rest in whatever extra stuff might be involved in the (likely SHM-related, optionally used) non-vanilla <a class="el" href="classipc_1_1transport_1_1struc_1_1Struct__builder.html" title="A documentation-only concept defining the behavior of an object capable of zero-copy-serializing,...">transport::struc::Struct_builder</a> and <a class="el" href="classipc_1_1transport_1_1struc_1_1Struct__reader.html" title="A documentation-only concept that is, conceptually, roughly what capnp::MessageReader is to capnp::Me...">transport::struc::Struct_reader</a> concept impls (namely most likely <a class="el" href="classipc_1_1transport_1_1struc_1_1shm_1_1Builder.html" title="Implements Struct_builder concept with maximal zero-copy perf by (1) storing the actual user-schema-c...">transport::struc::shm::Builder</a> and <a class="el" href="classipc_1_1transport_1_1struc_1_1shm_1_1Reader.html" title="Implements Struct_reader concept by interpreting a serialization by shm::Builder with the same templa...">transport::struc::shm::Reader</a>). So essentially there's the <code>ipc_transport_structured</code> part, and the (other) part (likely but not necessarily from <code>ipc_shm</code>). We do something vaguely similar conceptually:</p><ul>
<li>There is the basic <a class="el" href="namespaceipc_1_1session.html" title="Flow-IPC module providing the broad lifecycle and shared-resource organization  via the session conc...">ipc::session</a> protocol, including the <code>LogInReq/LogInRsp/OpenChannel*</code> messages. This is from <a class="el" href="namespaceipc_1_1session.html" title="Flow-IPC module providing the broad lifecycle and shared-resource organization  via the session conc...">ipc::session</a> proper (<code>ipc_session</code> module/library).</li>
<li>There is the optionally-used protocol woven into it activated by the fact the user chose to use <a class="el" href="namespaceipc_1_1session_1_1shm.html" title="ipc::session sub-namespace that groups together facilities for SHM-backed sessions,...">ipc::session::shm</a> (or maybe even their own) <code><a class="el" href="classipc_1_1session_1_1Session.html" title="A documentation-only concept defining the local side of an IPC conversation (session) with another en...">Session</a></code> hierarchy. (As of this writing, <a class="el" href="namespaceipc_1_1session_1_1shm.html" title="ipc::session sub-namespace that groups together facilities for SHM-backed sessions,...">ipc::session::shm</a> contains two hierarchies, depending on the SHM-provider of choice: SHM-classic <code><a class="el" href="namespaceipc_1_1session_1_1shm_1_1classic.html" title="Support for SHM-backed ipc::session sessions and session-servers with the SHM-classic (ipc::shm::clas...">shm::classic</a></code> or SHM-jemalloc <code><a class="el" href="namespaceipc_1_1session_1_1shm_1_1arena__lend_1_1jemalloc.html" title="Support for SHM-backed ipc::session sessions and session-servers with the SHM-jemalloc (ipc::shm::are...">shm::arena_lend::jemalloc</a></code>.)</li>
</ul>
<p >So we, too, maintain two <code>Protocol_negotiator</code>s: the main one and the "aux" one for those two bullet points respectively. As of this writing there is only version 1 of everything; but if this changes for one of the "aux" <code><a class="el" href="classipc_1_1session_1_1Session.html" title="A documentation-only concept defining the local side of an IPC conversation (session) with another en...">Session</a></code> hierarchies &ndash; e.g., SHM-jemalloc's internally used ipc_session_message.capnp channel/schema &ndash; then that guy's "aux" protocol-version can be bumped up. (In the case of ipc_session_message.capnp specifically, and I say this only for exposition, that code can &ndash; if it wants &ndash; do its own protocol negotiation along its own channel; but by leveraging the "aux" <code>Protocol_negotiator</code> version infrastructure, they do not have to. Good for perf and, in this case more importantly, good for keeping code complexity down.)</p>
<p >How we're different: The mechanics of protocol-version exchange are simpler for us, because we have a built-in SYN/SYN-ACK like exchange at the start (log-in-request, log-in-response) via the session master channel. So we piggy-back (piggy-front?) the protocol-negotiation info onto those 2 messages which exist anyway. You can see that now by looking at session_master_channel.capnp and noting how <code>ProtocolNegotiation</code> fields sit up-top in <code>LogInReq</code> and <code>LogInRsp</code>. As Protocol_version doc header discussion suggests, it is important to verify the <code>ProtocolNegotiation</code> fields before interpreting any other part of the incoming <code>LogInReq</code> and <code>LogInRsp</code> by server and client respectively (and in that chronological order, as guaranteed by the handshake setup).</p>
<p >(In contrast to this: struc::sync_io::Channel does not itself have a mandatory built-in handshake phase. Hence each side has to send a special <code>ProtocolNegotiation</code> message ASAP and expect one &ndash; in each pipe of up-to-2 &ndash; to come in as well. No handshake/client/server =&gt; the two exchanges are full-duplex, that is mutually independent, in nature.)</p>
<p >If you're keeping score: as of this writing, the most complex/full-featured setup for a session is the SHM-jemalloc session setup. Excluding any structured channels opened within the session, the following <a class="el" href="classipc_1_1transport_1_1Protocol__negotiator.html" title="A simple state machine that, assuming the opposide side of a comm pathway uses an equivalent state ma...">transport::Protocol_negotiator</a> negotiations shall occur:</p><ul>
<li><a class="el" href="classipc_1_1session_1_1Session.html" title="A documentation-only concept defining the local side of an IPC conversation (session) with another en...">Session</a> master channel <code>Native_socket_stream</code> low-level protocol (1 <code>Protocol_negotiator</code> per side). Full-duplex exchange.</li>
<li><a class="el" href="classipc_1_1session_1_1Session.html" title="A documentation-only concept defining the local side of an IPC conversation (session) with another en...">Session</a> master channel <code>struc::Channel</code> protocol (2 <code>Protocol_negotiator</code>s per side, "aux" one unused because the session master channel is a vanilla, non-SHM-backed channel). Full-duplex exchange.</li>
<li><a class="el" href="classipc_1_1session_1_1Session.html" title="A documentation-only concept defining the local side of an IPC conversation (session) with another en...">Session</a> master channel vanilla session protocol (1 <code>Protocol_negotiator</code> per side). Handshake exchange.</li>
<li><a class="el" href="classipc_1_1session_1_1Session.html" title="A documentation-only concept defining the local side of an IPC conversation (session) with another en...">Session</a> master channel SHM-jemalloc session protocol (1 <code>Protocol_negotiator</code> per side). Handshake exchange (same one as in the previous bullet point).</li>
</ul>
<p >Unrelated to sessions, consider the most complex/full-featured setup for a user <code><a class="el" href="classipc_1_1transport_1_1struc_1_1Channel.html" title="Owning and wrapping a pre-connected transport::Channel peer (an endpoint of an established channel ov...">transport::struc::Channel</a></code> operating over a 2-pipe <code><a class="el" href="classipc_1_1transport_1_1Channel.html" title="Peer to a bundle of 1-2 full-duplex pipe(s), one for transmitting unstructured binary blobs; the othe...">transport::Channel</a></code> (1 pipe for blobs, 1 pipe for <code>Native_handle</code>s):</p><ul>
<li>User channel <code>Native_socket_stream</code> low-level protocol (1 <code>Protocol_negotiator</code> per side). Full-duplex exchange (pipe 1).</li>
<li>User channel <code>Blob_stream_mq_*er</code> low-level protocol (1 <code>Protocol_negotiator</code> per side). Full-duplex exchange (pipe 2, same layer as preceding bullet point, different transport type).</li>
<li><a class="el" href="classipc_1_1session_1_1Session.html" title="A documentation-only concept defining the local side of an IPC conversation (session) with another en...">Session</a> master channel <code>struc::Channel</code> protocol (2 <code>Protocol_negotiator</code>s per side; main one for the vanilla layer, "aux" one for the SHM layer). Full-duplex exchange.</li>
</ul>
<h3>PEER state impl</h3>
<p >Here our algorithm is complementary to the PEER state algorithm in <a class="el" href="classipc_1_1session_1_1Server__session__impl.html" title="Internal, non-movable pImpl-lite implementation of Server_session_mv class template.">Server_session_impl</a>. Namely we expect passive-opens via an appropriate <a class="el" href="classipc_1_1transport_1_1struc_1_1Channel.html#a3376b821b129ca3847484a178e080c67" title="Registers the expectation of 0+ notification in-messages whose Msg_which equals which.">transport::struc::Channel::expect_msgs()</a>; and we allow active-opens via <a class="el" href="classipc_1_1session_1_1Client__session__impl.html#a4a377590fbf55b6d312f24d888d2a1bd" title="See Client_session_mv counterpart.">open_channel()</a>. The details of how these work is best understood just by reading that code inline.</p>
<p ><a class="el" href="classipc_1_1session_1_1Client__session__impl.html#a4a377590fbf55b6d312f24d888d2a1bd" title="See Client_session_mv counterpart.">open_channel()</a>, similarly to <a class="el" href="classipc_1_1session_1_1Server__session__impl.html#a45a5ae92b706ea539c27be0d19a303c4" title="See Server_session_mv counterpart.">Server_session_impl::open_channel()</a>, has one interesting quirk which is: To the user it is presented as synchronous and blocking with the aim of being non-blockingly fast, as long as the other side is in PEER state. It uses <a class="el" href="classipc_1_1transport_1_1struc_1_1Channel.html#aa41aee3c76035f43833078e625e6ef78" title="Equivalent to the other sync_request() overload but with no timeout; meaning it shall exit only once ...">transport::struc::Channel::sync_request()</a> with a generous timeout, while knowing that if both sides in PEER state in practice the call will complete rather swiftly; the generous timeout aimed making it clear that <a class="el" href="classipc_1_1session_1_1Client__session__impl.html#a4a377590fbf55b6d312f24d888d2a1bd" title="See Client_session_mv counterpart.">open_channel()</a> is failing <em>not</em> due to some overly tight internal timeout but more likely due to some application problem such as not calling <a class="el" href="classipc_1_1session_1_1Server__session__mv.html#a99097e5aa6883877c74f8a93ebc9f3e1" title="To be invoked by public user upon first obtaining *this: memorizes the given on-error and on-passive-...">Server_session::init_handlers()</a> quickly enough.</p>
<p >Once PEER state is reached, the Session-concept error emission semantics come into play. See its doc header.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">S_MQ_TYPE_OR_NONE</td><td>See <a class="el" href="namespaceipc_1_1session.html#a77d8fda00e1e17f595a6a5d4c44375e7" title="A vanilla Client_session with no optional capabilities.">Client_session</a> counterpart. </td></tr>
    <tr><td class="paramname">S_TRANSMIT_NATIVE_HANDLES</td><td>See <a class="el" href="namespaceipc_1_1session.html#a77d8fda00e1e17f595a6a5d4c44375e7" title="A vanilla Client_session with no optional capabilities.">Client_session</a> counterpart. </td></tr>
    <tr><td class="paramname">Mdt_payload</td><td>See <a class="el" href="namespaceipc_1_1session.html#a77d8fda00e1e17f595a6a5d4c44375e7" title="A vanilla Client_session with no optional capabilities.">Client_session</a> counterpart. </td></tr>
    <tr><td class="paramname">S_SHM_TYPE_OR_NONE</td><td>Identical to opposing <a class="el" href="classipc_1_1session_1_1Server__session__impl.html" title="Internal, non-movable pImpl-lite implementation of Server_session_mv class template.">Server_session_impl</a> counterpart. </td></tr>
    <tr><td class="paramname">S_GRACEFUL_FINISH_REQUIRED_V</td><td><code>true</code> if and only if <a class="el" href="classipc_1_1session_1_1Session__base_1_1Graceful__finisher.html" title="Optional to use by subclasses, this operates a simple state machine that carries out a graceful-sessi...">Session_base::Graceful_finisher</a> must be used. See its doc header for explanation when that would be the case. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="ipc__session_2src_2ipc_2session_2detail_2client__session__impl_8hpp_source.html#l00217">217</a> of file <a class="el" href="ipc__session_2src_2ipc_2session_2detail_2client__session__impl_8hpp_source.html">client_session_impl.hpp</a>.</p>
</div><h2 class="groupheader">Member Typedef Documentation</h2>
<a id="acd9519f313206fdd2cd6ca91efb79516" name="acd9519f313206fdd2cd6ca91efb79516"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acd9519f313206fdd2cd6ca91efb79516">&#9670;&nbsp;</a></span>Base</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;schema::MqType S_MQ_TYPE_OR_NONE, bool S_TRANSMIT_NATIVE_HANDLES, typename Mdt_payload , schema::ShmType S_SHM_TYPE_OR_NONE, bool S_GRACEFUL_FINISH_REQUIRED_V&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classipc_1_1session_1_1Client__session__impl.html">ipc::session::Client_session_impl</a>&lt; S_MQ_TYPE_OR_NONE, S_TRANSMIT_NATIVE_HANDLES, Mdt_payload, S_SHM_TYPE_OR_NONE, S_GRACEFUL_FINISH_REQUIRED_V &gt;::Base =  <a class="el" href="classipc_1_1session_1_1Session__base.html">Session_base</a>&lt;S_MQ_TYPE_OR_NONE, S_TRANSMIT_NATIVE_HANDLES, Mdt_payload&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Short-hand for base type. </p>

<p class="definition">Definition at line <a class="el" href="ipc__session_2src_2ipc_2session_2detail_2client__session__impl_8hpp_source.html#l00225">225</a> of file <a class="el" href="ipc__session_2src_2ipc_2session_2detail_2client__session__impl_8hpp_source.html">client_session_impl.hpp</a>.</p>

</div>
</div>
<a id="a994a2f0b281fdeaeb6c09f6d91df351a" name="a994a2f0b281fdeaeb6c09f6d91df351a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a994a2f0b281fdeaeb6c09f6d91df351a">&#9670;&nbsp;</a></span>Channel_obj</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;schema::MqType S_MQ_TYPE_OR_NONE, bool S_TRANSMIT_NATIVE_HANDLES, typename Mdt_payload , schema::ShmType S_SHM_TYPE_OR_NONE, bool S_GRACEFUL_FINISH_REQUIRED_V&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classipc_1_1session_1_1Client__session__impl.html">ipc::session::Client_session_impl</a>&lt; S_MQ_TYPE_OR_NONE, S_TRANSMIT_NATIVE_HANDLES, Mdt_payload, S_SHM_TYPE_OR_NONE, S_GRACEFUL_FINISH_REQUIRED_V &gt;::Channel_obj =  typename <a class="el" href="classipc_1_1session_1_1Session__base.html#a71f02a809d667c23ff8af29a96940bd1">Base::Channel_obj</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>See <a class="el" href="classipc_1_1session_1_1Client__session__mv.html" title="Implements Session concept on the Client_app end: a Session_mv that first achieves PEER state by conn...">Client_session_mv</a> counterpart. </p>

<p class="definition">Definition at line <a class="el" href="ipc__session_2src_2ipc_2session_2detail_2client__session__impl_8hpp_source.html#l00231">231</a> of file <a class="el" href="ipc__session_2src_2ipc_2session_2detail_2client__session__impl_8hpp_source.html">client_session_impl.hpp</a>.</p>

</div>
</div>
<a id="aab1b23e3370a77db375a50ab156b5662" name="aab1b23e3370a77db375a50ab156b5662"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aab1b23e3370a77db375a50ab156b5662">&#9670;&nbsp;</a></span>Channels</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;schema::MqType S_MQ_TYPE_OR_NONE, bool S_TRANSMIT_NATIVE_HANDLES, typename Mdt_payload , schema::ShmType S_SHM_TYPE_OR_NONE, bool S_GRACEFUL_FINISH_REQUIRED_V&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classipc_1_1session_1_1Client__session__impl.html">ipc::session::Client_session_impl</a>&lt; S_MQ_TYPE_OR_NONE, S_TRANSMIT_NATIVE_HANDLES, Mdt_payload, S_SHM_TYPE_OR_NONE, S_GRACEFUL_FINISH_REQUIRED_V &gt;::Channels =  typename <a class="el" href="classipc_1_1session_1_1Session__base.html#a638232ef74a0eb80aeb4f027ee06f9bf">Base::Channels</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>See <a class="el" href="classipc_1_1session_1_1Session__mv.html" title="Implements the Session concept when it is in PEER state.">Session_mv</a> counterpart. </p>

<p class="definition">Definition at line <a class="el" href="ipc__session_2src_2ipc_2session_2detail_2client__session__impl_8hpp_source.html#l00234">234</a> of file <a class="el" href="ipc__session_2src_2ipc_2session_2detail_2client__session__impl_8hpp_source.html">client_session_impl.hpp</a>.</p>

</div>
</div>
<a id="abe6c733821534ec020b7cec02cfc3e66" name="abe6c733821534ec020b7cec02cfc3e66"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abe6c733821534ec020b7cec02cfc3e66">&#9670;&nbsp;</a></span>Master_channel_req_ptr</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;schema::MqType S_MQ_TYPE_OR_NONE, bool S_TRANSMIT_NATIVE_HANDLES, typename Mdt_payload , schema::ShmType S_SHM_TYPE_OR_NONE, bool S_GRACEFUL_FINISH_REQUIRED_V&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classipc_1_1session_1_1Client__session__impl.html">ipc::session::Client_session_impl</a>&lt; S_MQ_TYPE_OR_NONE, S_TRANSMIT_NATIVE_HANDLES, Mdt_payload, S_SHM_TYPE_OR_NONE, S_GRACEFUL_FINISH_REQUIRED_V &gt;::Master_channel_req_ptr =  boost::shared_ptr&lt;<a class="el" href="structipc_1_1session_1_1Client__session__impl_1_1Master__channel__req.html">Master_channel_req</a>&gt;</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Short-hand for ref-counted pointer to <a class="el" href="structipc_1_1session_1_1Client__session__impl_1_1Master__channel__req.html" title="An open-channel/log-in request out-message.">Master_channel_req</a>. </p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="structipc_1_1session_1_1Client__session__impl_1_1Master__channel__req.html" title="An open-channel/log-in request out-message.">Master_channel_req</a> doc header for info on the true nature of such <code>shared_ptr</code> as returned by us. </dd></dl>

<p class="definition">Definition at line <a class="el" href="ipc__session_2src_2ipc_2session_2detail_2client__session__impl_8hpp_source.html#l00618">618</a> of file <a class="el" href="ipc__session_2src_2ipc_2session_2detail_2client__session__impl_8hpp_source.html">client_session_impl.hpp</a>.</p>

</div>
</div>
<a id="a4c62a381340b0f494c4f117960bfca2b" name="a4c62a381340b0f494c4f117960bfca2b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4c62a381340b0f494c4f117960bfca2b">&#9670;&nbsp;</a></span>Master_structured_channel</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;schema::MqType S_MQ_TYPE_OR_NONE, bool S_TRANSMIT_NATIVE_HANDLES, typename Mdt_payload , schema::ShmType S_SHM_TYPE_OR_NONE, bool S_GRACEFUL_FINISH_REQUIRED_V&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classipc_1_1session_1_1Client__session__impl.html">ipc::session::Client_session_impl</a>&lt; S_MQ_TYPE_OR_NONE, S_TRANSMIT_NATIVE_HANDLES, Mdt_payload, S_SHM_TYPE_OR_NONE, S_GRACEFUL_FINISH_REQUIRED_V &gt;::Master_structured_channel =  typename <a class="el" href="classipc_1_1session_1_1Session__base.html#a26d038e14e3c0e461e76de88c4ce76c5">Base::Master_structured_channel</a></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>See <a class="el" href="classipc_1_1session_1_1Session__base.html" title="Internal type containing data and types common to internal types Server_session_impl and Client_sessi...">Session_base</a>. </p>

<p class="definition">Definition at line <a class="el" href="ipc__session_2src_2ipc_2session_2detail_2client__session__impl_8hpp_source.html#l00390">390</a> of file <a class="el" href="ipc__session_2src_2ipc_2session_2detail_2client__session__impl_8hpp_source.html">client_session_impl.hpp</a>.</p>

</div>
</div>
<a id="a6a1cb9c344c312b4eff5c360d7114e2c" name="a6a1cb9c344c312b4eff5c360d7114e2c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6a1cb9c344c312b4eff5c360d7114e2c">&#9670;&nbsp;</a></span>Master_structured_channel_observer</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;schema::MqType S_MQ_TYPE_OR_NONE, bool S_TRANSMIT_NATIVE_HANDLES, typename Mdt_payload , schema::ShmType S_SHM_TYPE_OR_NONE, bool S_GRACEFUL_FINISH_REQUIRED_V&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classipc_1_1session_1_1Client__session__impl.html">ipc::session::Client_session_impl</a>&lt; S_MQ_TYPE_OR_NONE, S_TRANSMIT_NATIVE_HANDLES, Mdt_payload, S_SHM_TYPE_OR_NONE, S_GRACEFUL_FINISH_REQUIRED_V &gt;::Master_structured_channel_observer =  typename <a class="el" href="classipc_1_1session_1_1Session__base.html#ae2a123b29dd044a638e94d1f294c8f28">Base::Master_structured_channel_observer</a></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>See <a class="el" href="classipc_1_1session_1_1Session__base.html" title="Internal type containing data and types common to internal types Server_session_impl and Client_sessi...">Session_base</a>. </p>

<p class="definition">Definition at line <a class="el" href="ipc__session_2src_2ipc_2session_2detail_2client__session__impl_8hpp_source.html#l00539">539</a> of file <a class="el" href="ipc__session_2src_2ipc_2session_2detail_2client__session__impl_8hpp_source.html">client_session_impl.hpp</a>.</p>

</div>
</div>
<a id="ad432ab4e95ddcfd0396d5ea821dec15c" name="ad432ab4e95ddcfd0396d5ea821dec15c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad432ab4e95ddcfd0396d5ea821dec15c">&#9670;&nbsp;</a></span>Master_structured_channel_ptr</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;schema::MqType S_MQ_TYPE_OR_NONE, bool S_TRANSMIT_NATIVE_HANDLES, typename Mdt_payload , schema::ShmType S_SHM_TYPE_OR_NONE, bool S_GRACEFUL_FINISH_REQUIRED_V&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classipc_1_1session_1_1Client__session__impl.html">ipc::session::Client_session_impl</a>&lt; S_MQ_TYPE_OR_NONE, S_TRANSMIT_NATIVE_HANDLES, Mdt_payload, S_SHM_TYPE_OR_NONE, S_GRACEFUL_FINISH_REQUIRED_V &gt;::Master_structured_channel_ptr =  typename <a class="el" href="classipc_1_1session_1_1Session__base.html#af0ca2a01d7d0d92038aae56fc1cdd505">Base::Master_structured_channel_ptr</a></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>See <a class="el" href="classipc_1_1session_1_1Session__base.html" title="Internal type containing data and types common to internal types Server_session_impl and Client_sessi...">Session_base</a>. </p>

<p class="definition">Definition at line <a class="el" href="ipc__session_2src_2ipc_2session_2detail_2client__session__impl_8hpp_source.html#l00536">536</a> of file <a class="el" href="ipc__session_2src_2ipc_2session_2detail_2client__session__impl_8hpp_source.html">client_session_impl.hpp</a>.</p>

</div>
</div>
<a id="ad5a3539f5e10933ff4abc7cde1056798" name="ad5a3539f5e10933ff4abc7cde1056798"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad5a3539f5e10933ff4abc7cde1056798">&#9670;&nbsp;</a></span>Mdt_builder</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;schema::MqType S_MQ_TYPE_OR_NONE, bool S_TRANSMIT_NATIVE_HANDLES, typename Mdt_payload , schema::ShmType S_SHM_TYPE_OR_NONE, bool S_GRACEFUL_FINISH_REQUIRED_V&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classipc_1_1session_1_1Client__session__impl.html">ipc::session::Client_session_impl</a>&lt; S_MQ_TYPE_OR_NONE, S_TRANSMIT_NATIVE_HANDLES, Mdt_payload, S_SHM_TYPE_OR_NONE, S_GRACEFUL_FINISH_REQUIRED_V &gt;::Mdt_builder =  typename <a class="el" href="classipc_1_1session_1_1Session__base.html#a7d68bbb8c0c09983619d563bca30bd45">Base::Mdt_builder</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>See <a class="el" href="classipc_1_1session_1_1Client__session__mv.html" title="Implements Session concept on the Client_app end: a Session_mv that first achieves PEER state by conn...">Client_session_mv</a> counterpart. </p>

<p class="definition">Definition at line <a class="el" href="ipc__session_2src_2ipc_2session_2detail_2client__session__impl_8hpp_source.html#l00243">243</a> of file <a class="el" href="ipc__session_2src_2ipc_2session_2detail_2client__session__impl_8hpp_source.html">client_session_impl.hpp</a>.</p>

</div>
</div>
<a id="a9d93e6080abf3b0827b97e084f5e8356" name="a9d93e6080abf3b0827b97e084f5e8356"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9d93e6080abf3b0827b97e084f5e8356">&#9670;&nbsp;</a></span>Mdt_builder_ptr</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;schema::MqType S_MQ_TYPE_OR_NONE, bool S_TRANSMIT_NATIVE_HANDLES, typename Mdt_payload , schema::ShmType S_SHM_TYPE_OR_NONE, bool S_GRACEFUL_FINISH_REQUIRED_V&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classipc_1_1session_1_1Client__session__impl.html">ipc::session::Client_session_impl</a>&lt; S_MQ_TYPE_OR_NONE, S_TRANSMIT_NATIVE_HANDLES, Mdt_payload, S_SHM_TYPE_OR_NONE, S_GRACEFUL_FINISH_REQUIRED_V &gt;::Mdt_builder_ptr =  typename <a class="el" href="classipc_1_1session_1_1Session__base.html#a4a7a5b83f6ba8bd505685636eabc012b">Base::Mdt_builder_ptr</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>See <a class="el" href="classipc_1_1session_1_1Client__session__mv.html" title="Implements Session concept on the Client_app end: a Session_mv that first achieves PEER state by conn...">Client_session_mv</a> counterpart. </p>

<p class="definition">Definition at line <a class="el" href="ipc__session_2src_2ipc_2session_2detail_2client__session__impl_8hpp_source.html#l00246">246</a> of file <a class="el" href="ipc__session_2src_2ipc_2session_2detail_2client__session__impl_8hpp_source.html">client_session_impl.hpp</a>.</p>

</div>
</div>
<a id="ae457d7b16843699006feb43e1073296a" name="ae457d7b16843699006feb43e1073296a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae457d7b16843699006feb43e1073296a">&#9670;&nbsp;</a></span>Mdt_payload_obj</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;schema::MqType S_MQ_TYPE_OR_NONE, bool S_TRANSMIT_NATIVE_HANDLES, typename Mdt_payload , schema::ShmType S_SHM_TYPE_OR_NONE, bool S_GRACEFUL_FINISH_REQUIRED_V&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classipc_1_1session_1_1Client__session__impl.html">ipc::session::Client_session_impl</a>&lt; S_MQ_TYPE_OR_NONE, S_TRANSMIT_NATIVE_HANDLES, Mdt_payload, S_SHM_TYPE_OR_NONE, S_GRACEFUL_FINISH_REQUIRED_V &gt;::Mdt_payload_obj =  typename <a class="el" href="classipc_1_1session_1_1Session__base.html#a35234981ca87cc2f6b118b3e52452ea8">Base::Mdt_payload_obj</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>See <a class="el" href="classipc_1_1session_1_1Client__session__mv.html" title="Implements Session concept on the Client_app end: a Session_mv that first achieves PEER state by conn...">Client_session_mv</a> counterpart. </p>

<p class="definition">Definition at line <a class="el" href="ipc__session_2src_2ipc_2session_2detail_2client__session__impl_8hpp_source.html#l00237">237</a> of file <a class="el" href="ipc__session_2src_2ipc_2session_2detail_2client__session__impl_8hpp_source.html">client_session_impl.hpp</a>.</p>

</div>
</div>
<a id="ad0ad69f676fc1260a3c493781fbbb81d" name="ad0ad69f676fc1260a3c493781fbbb81d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad0ad69f676fc1260a3c493781fbbb81d">&#9670;&nbsp;</a></span>Mdt_reader_ptr</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;schema::MqType S_MQ_TYPE_OR_NONE, bool S_TRANSMIT_NATIVE_HANDLES, typename Mdt_payload , schema::ShmType S_SHM_TYPE_OR_NONE, bool S_GRACEFUL_FINISH_REQUIRED_V&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classipc_1_1session_1_1Client__session__impl.html">ipc::session::Client_session_impl</a>&lt; S_MQ_TYPE_OR_NONE, S_TRANSMIT_NATIVE_HANDLES, Mdt_payload, S_SHM_TYPE_OR_NONE, S_GRACEFUL_FINISH_REQUIRED_V &gt;::Mdt_reader_ptr =  typename <a class="el" href="classipc_1_1session_1_1Session__base.html#ace4dab42adec6354cc66081dd218ac71">Base::Mdt_reader_ptr</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>See <a class="el" href="classipc_1_1session_1_1Client__session__mv.html" title="Implements Session concept on the Client_app end: a Session_mv that first achieves PEER state by conn...">Client_session_mv</a> counterpart. </p>

<p class="definition">Definition at line <a class="el" href="ipc__session_2src_2ipc_2session_2detail_2client__session__impl_8hpp_source.html#l00240">240</a> of file <a class="el" href="ipc__session_2src_2ipc_2session_2detail_2client__session__impl_8hpp_source.html">client_session_impl.hpp</a>.</p>

</div>
</div>
<a id="ad6624a4b1f7fd6e24bdde50b323b8f97" name="ad6624a4b1f7fd6e24bdde50b323b8f97"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad6624a4b1f7fd6e24bdde50b323b8f97">&#9670;&nbsp;</a></span>On_passive_open_channel_func</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;schema::MqType S_MQ_TYPE_OR_NONE, bool S_TRANSMIT_NATIVE_HANDLES, typename Mdt_payload , schema::ShmType S_SHM_TYPE_OR_NONE, bool S_GRACEFUL_FINISH_REQUIRED_V&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classipc_1_1session_1_1Client__session__impl.html">ipc::session::Client_session_impl</a>&lt; S_MQ_TYPE_OR_NONE, S_TRANSMIT_NATIVE_HANDLES, Mdt_payload, S_SHM_TYPE_OR_NONE, S_GRACEFUL_FINISH_REQUIRED_V &gt;::On_passive_open_channel_func =  typename <a class="el" href="classipc_1_1session_1_1Session__base.html#a3c0824a54ef32915c5c5ea76481f2409">Base::On_passive_open_channel_func</a></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>See <a class="el" href="classipc_1_1session_1_1Session__base.html" title="Internal type containing data and types common to internal types Server_session_impl and Client_sessi...">Session_base</a>. </p>

<p class="definition">Definition at line <a class="el" href="ipc__session_2src_2ipc_2session_2detail_2client__session__impl_8hpp_source.html#l00545">545</a> of file <a class="el" href="ipc__session_2src_2ipc_2session_2detail_2client__session__impl_8hpp_source.html">client_session_impl.hpp</a>.</p>

</div>
</div>
<a id="aa4a518c48b0611e13ad4982d067674f7" name="aa4a518c48b0611e13ad4982d067674f7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa4a518c48b0611e13ad4982d067674f7">&#9670;&nbsp;</a></span>Persistent_mq_handle_from_cfg</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;schema::MqType S_MQ_TYPE_OR_NONE, bool S_TRANSMIT_NATIVE_HANDLES, typename Mdt_payload , schema::ShmType S_SHM_TYPE_OR_NONE, bool S_GRACEFUL_FINISH_REQUIRED_V&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classipc_1_1session_1_1Client__session__impl.html">ipc::session::Client_session_impl</a>&lt; S_MQ_TYPE_OR_NONE, S_TRANSMIT_NATIVE_HANDLES, Mdt_payload, S_SHM_TYPE_OR_NONE, S_GRACEFUL_FINISH_REQUIRED_V &gt;::Persistent_mq_handle_from_cfg =  typename <a class="el" href="classipc_1_1session_1_1Session__base.html#a848c0f5247644ada0f8b0ab816eedda8">Base::Persistent_mq_handle_from_cfg</a></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>See <a class="el" href="classipc_1_1session_1_1Session__base.html" title="Internal type containing data and types common to internal types Server_session_impl and Client_sessi...">Session_base</a>. </p>

<p class="definition">Definition at line <a class="el" href="ipc__session_2src_2ipc_2session_2detail_2client__session__impl_8hpp_source.html#l00542">542</a> of file <a class="el" href="ipc__session_2src_2ipc_2session_2detail_2client__session__impl_8hpp_source.html">client_session_impl.hpp</a>.</p>

</div>
</div>
<a id="a7d1a81d91f59edf7fd3f5ea104294a7c" name="a7d1a81d91f59edf7fd3f5ea104294a7c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7d1a81d91f59edf7fd3f5ea104294a7c">&#9670;&nbsp;</a></span>Session_base_obj</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;schema::MqType S_MQ_TYPE_OR_NONE, bool S_TRANSMIT_NATIVE_HANDLES, typename Mdt_payload , schema::ShmType S_SHM_TYPE_OR_NONE, bool S_GRACEFUL_FINISH_REQUIRED_V&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classipc_1_1session_1_1Client__session__impl.html">ipc::session::Client_session_impl</a>&lt; S_MQ_TYPE_OR_NONE, S_TRANSMIT_NATIVE_HANDLES, Mdt_payload, S_SHM_TYPE_OR_NONE, S_GRACEFUL_FINISH_REQUIRED_V &gt;::Session_base_obj =  <a class="el" href="classipc_1_1session_1_1Client__session__impl.html#acd9519f313206fdd2cd6ca91efb79516">Base</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Short-hand for <a class="el" href="classipc_1_1session_1_1Session__base.html" title="Internal type containing data and types common to internal types Server_session_impl and Client_sessi...">Session_base</a> super-class. </p>

<p class="definition">Definition at line <a class="el" href="ipc__session_2src_2ipc_2session_2detail_2client__session__impl_8hpp_source.html#l00228">228</a> of file <a class="el" href="ipc__session_2src_2ipc_2session_2detail_2client__session__impl_8hpp_source.html">client_session_impl.hpp</a>.</p>

</div>
</div>
<a id="a95c690ae89ac5e4017dd2ac030703dae" name="a95c690ae89ac5e4017dd2ac030703dae"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a95c690ae89ac5e4017dd2ac030703dae">&#9670;&nbsp;</a></span>Structured_msg_builder_config</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;schema::MqType S_MQ_TYPE_OR_NONE, bool S_TRANSMIT_NATIVE_HANDLES, typename Mdt_payload , schema::ShmType S_SHM_TYPE_OR_NONE, bool S_GRACEFUL_FINISH_REQUIRED_V&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classipc_1_1session_1_1Client__session__impl.html">ipc::session::Client_session_impl</a>&lt; S_MQ_TYPE_OR_NONE, S_TRANSMIT_NATIVE_HANDLES, Mdt_payload, S_SHM_TYPE_OR_NONE, S_GRACEFUL_FINISH_REQUIRED_V &gt;::Structured_msg_builder_config =  typename <a class="el" href="classipc_1_1session_1_1Session__base.html#aee0db48505c84d3553b7110a9a815036">Base::Structured_msg_builder_config</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>See <a class="el" href="classipc_1_1session_1_1Session__mv.html" title="Implements the Session concept when it is in PEER state.">Session_mv</a> counterpart. </p>

<p class="definition">Definition at line <a class="el" href="ipc__session_2src_2ipc_2session_2detail_2client__session__impl_8hpp_source.html#l00249">249</a> of file <a class="el" href="ipc__session_2src_2ipc_2session_2detail_2client__session__impl_8hpp_source.html">client_session_impl.hpp</a>.</p>

</div>
</div>
<a id="ae82914b6c13a8ff1b8ad9b2b179d4d74" name="ae82914b6c13a8ff1b8ad9b2b179d4d74"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae82914b6c13a8ff1b8ad9b2b179d4d74">&#9670;&nbsp;</a></span>Structured_msg_reader_config</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;schema::MqType S_MQ_TYPE_OR_NONE, bool S_TRANSMIT_NATIVE_HANDLES, typename Mdt_payload , schema::ShmType S_SHM_TYPE_OR_NONE, bool S_GRACEFUL_FINISH_REQUIRED_V&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classipc_1_1session_1_1Client__session__impl.html">ipc::session::Client_session_impl</a>&lt; S_MQ_TYPE_OR_NONE, S_TRANSMIT_NATIVE_HANDLES, Mdt_payload, S_SHM_TYPE_OR_NONE, S_GRACEFUL_FINISH_REQUIRED_V &gt;::Structured_msg_reader_config =  typename <a class="el" href="classipc_1_1session_1_1Session__base.html#abd854f2b9316361ef18f15610c242d4b">Base::Structured_msg_reader_config</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>See <a class="el" href="classipc_1_1session_1_1Session__mv.html" title="Implements the Session concept when it is in PEER state.">Session_mv</a> counterpart. </p>

<p class="definition">Definition at line <a class="el" href="ipc__session_2src_2ipc_2session_2detail_2client__session__impl_8hpp_source.html#l00252">252</a> of file <a class="el" href="ipc__session_2src_2ipc_2session_2detail_2client__session__impl_8hpp_source.html">client_session_impl.hpp</a>.</p>

</div>
</div>
<h2 class="groupheader">Member Enumeration Documentation</h2>
<a id="af7a951bd266bdd0e3339a0fbddba9e8b" name="af7a951bd266bdd0e3339a0fbddba9e8b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af7a951bd266bdd0e3339a0fbddba9e8b">&#9670;&nbsp;</a></span>State</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;schema::MqType S_MQ_TYPE_OR_NONE, bool S_TRANSMIT_NATIVE_HANDLES, typename Mdt_payload , schema::ShmType S_SHM_TYPE_OR_NONE, bool S_GRACEFUL_FINISH_REQUIRED_V&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">enum class <a class="el" href="classipc_1_1session_1_1Client__session__impl.html#af7a951bd266bdd0e3339a0fbddba9e8b">ipc::session::Client_session_impl::State</a></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">strong</span><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Overall state of a <a class="el" href="classipc_1_1session_1_1Client__session__impl.html" title="Internal, non-movable pImpl-lite implementation of Client_session_mv class template.">Client_session_impl</a>. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="af7a951bd266bdd0e3339a0fbddba9e8bac6bd7568063494695099321f427efcb2" name="af7a951bd266bdd0e3339a0fbddba9e8bac6bd7568063494695099321f427efcb2"></a>S_NULL&#160;</td><td class="fielddoc"><p >Not a peer. </p>
<p >Initial state; goes to CONNECTING (via <a class="el" href="classipc_1_1session_1_1Client__session__impl.html#a56c0d2b0ff082d1f7b0738e2528b4a92" title="Core implementation of sync_connect().">async_connect()</a>). Only <a class="el" href="classipc_1_1session_1_1Client__session__impl.html#a56c0d2b0ff082d1f7b0738e2528b4a92" title="Core implementation of sync_connect().">async_connect()</a> is possible in this state (other public mutators return immediately). </p>
</td></tr>
<tr><td class="fieldname"><a id="af7a951bd266bdd0e3339a0fbddba9e8baae585d03fce4ac2011967830bf0ffbfb" name="af7a951bd266bdd0e3339a0fbddba9e8baae585d03fce4ac2011967830bf0ffbfb"></a>S_CONNECTING&#160;</td><td class="fielddoc"><p >Not a peer but <a class="el" href="classipc_1_1session_1_1Client__session__impl.html#a56c0d2b0ff082d1f7b0738e2528b4a92" title="Core implementation of sync_connect().">async_connect()</a> in progress to try to make it a peer. </p>
<p >Barring moves-from/moves-to: Entry from NULL; goes to PEER or NULL. </p>
</td></tr>
<tr><td class="fieldname"><a id="af7a951bd266bdd0e3339a0fbddba9e8bad9a05d721258c584cd559c56fd035887" name="af7a951bd266bdd0e3339a0fbddba9e8bad9a05d721258c584cd559c56fd035887"></a>S_PEER&#160;</td><td class="fielddoc"><p >Is or was a connected peer. </p>
<p >Entry from CONNECTING; does not transition to any other state (once a PEER, always a PEER). <code>*_connect()</code> is not possible in this state (it returns immediately); all other mutating public methods are possible. </p>
</td></tr>
</table>

<p class="definition">Definition at line <a class="el" href="ipc__session_2src_2ipc_2session_2detail_2client__session__impl_8hpp_source.html#l00548">548</a> of file <a class="el" href="ipc__session_2src_2ipc_2session_2detail_2client__session__impl_8hpp_source.html">client_session_impl.hpp</a>.</p>

</div>
</div>
<h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="a8fe80ed65e416a2d1fcadb045dac0fcf" name="a8fe80ed65e416a2d1fcadb045dac0fcf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8fe80ed65e416a2d1fcadb045dac0fcf">&#9670;&nbsp;</a></span>Client_session_impl() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;schema::MqType S_MQ_TYPE_OR_NONE, bool S_TRANSMIT_NATIVE_HANDLES, typename Mdt_payload , schema::ShmType S_SHM_TYPE_OR_NONE, bool S_GRACEFUL_FINISH_REQUIRED_V&gt; </div>
<div class="memtemplate">
template&lt;typename On_passive_open_channel_handler , typename Task_err &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classipc_1_1session_1_1Client__session__impl.html">ipc::session::Client_session_impl</a>&lt; S_MQ_TYPE_OR_NONE, S_TRANSMIT_NATIVE_HANDLES, Mdt_payload, S_SHM_TYPE_OR_NONE, S_GRACEFUL_FINISH_REQUIRED_V &gt;::Client_session_impl </td>
          <td>(</td>
          <td class="paramtype">flow::log::Logger *&#160;</td>
          <td class="paramname"><em>logger_ptr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structipc_1_1session_1_1Client__app.html">Client_app</a> &amp;&#160;</td>
          <td class="paramname"><em>cli_app_ref</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structipc_1_1session_1_1Server__app.html">Server_app</a> &amp;&#160;</td>
          <td class="paramname"><em>srv_app_ref</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Task_err &amp;&amp;&#160;</td>
          <td class="paramname"><em>on_err_func</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">On_passive_open_channel_handler &amp;&amp;&#160;</td>
          <td class="paramname"><em>on_passive_open_channel_func</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">explicit</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>See <a class="el" href="classipc_1_1session_1_1Client__session__mv.html" title="Implements Session concept on the Client_app end: a Session_mv that first achieves PEER state by conn...">Client_session_mv</a> counterpart. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">logger_ptr</td><td>See <a class="el" href="classipc_1_1session_1_1Client__session__mv.html" title="Implements Session concept on the Client_app end: a Session_mv that first achieves PEER state by conn...">Client_session_mv</a> counterpart. </td></tr>
    <tr><td class="paramname">cli_app_ref</td><td>See <a class="el" href="classipc_1_1session_1_1Client__session__mv.html" title="Implements Session concept on the Client_app end: a Session_mv that first achieves PEER state by conn...">Client_session_mv</a> counterpart. </td></tr>
    <tr><td class="paramname">srv_app_ref</td><td>See <a class="el" href="classipc_1_1session_1_1Client__session__mv.html" title="Implements Session concept on the Client_app end: a Session_mv that first achieves PEER state by conn...">Client_session_mv</a> counterpart. </td></tr>
    <tr><td class="paramname">on_err_func</td><td>See <a class="el" href="classipc_1_1session_1_1Client__session__mv.html" title="Implements Session concept on the Client_app end: a Session_mv that first achieves PEER state by conn...">Client_session_mv</a> counterpart. </td></tr>
    <tr><td class="paramname">on_passive_open_channel_func</td><td>See <a class="el" href="classipc_1_1session_1_1Client__session__mv.html" title="Implements Session concept on the Client_app end: a Session_mv that first achieves PEER state by conn...">Client_session_mv</a> counterpart. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="ipc__session_2src_2ipc_2session_2detail_2client__session__impl_8hpp_source.html#l00931">931</a> of file <a class="el" href="ipc__session_2src_2ipc_2session_2detail_2client__session__impl_8hpp_source.html">client_session_impl.hpp</a>.</p>

</div>
</div>
<a id="a0edcc39889b5f68492eb9156dc7a9b7a" name="a0edcc39889b5f68492eb9156dc7a9b7a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0edcc39889b5f68492eb9156dc7a9b7a">&#9670;&nbsp;</a></span>Client_session_impl() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;schema::MqType S_MQ_TYPE_OR_NONE, bool S_TRANSMIT_NATIVE_HANDLES, typename Mdt_payload , schema::ShmType S_SHM_TYPE_OR_NONE, bool S_GRACEFUL_FINISH_REQUIRED_V&gt; </div>
<div class="memtemplate">
template&lt;typename Task_err &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classipc_1_1session_1_1Client__session__impl.html">ipc::session::Client_session_impl</a>&lt; S_MQ_TYPE_OR_NONE, S_TRANSMIT_NATIVE_HANDLES, Mdt_payload, S_SHM_TYPE_OR_NONE, S_GRACEFUL_FINISH_REQUIRED_V &gt;::Client_session_impl </td>
          <td>(</td>
          <td class="paramtype">flow::log::Logger *&#160;</td>
          <td class="paramname"><em>logger_ptr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structipc_1_1session_1_1Client__app.html">Client_app</a> &amp;&#160;</td>
          <td class="paramname"><em>cli_app_ref</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structipc_1_1session_1_1Server__app.html">Server_app</a> &amp;&#160;</td>
          <td class="paramname"><em>srv_app_ref</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Task_err &amp;&amp;&#160;</td>
          <td class="paramname"><em>on_err_func</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">explicit</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>See <a class="el" href="classipc_1_1session_1_1Client__session__mv.html" title="Implements Session concept on the Client_app end: a Session_mv that first achieves PEER state by conn...">Client_session_mv</a> counterpart. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">logger_ptr</td><td>See <a class="el" href="classipc_1_1session_1_1Client__session__mv.html" title="Implements Session concept on the Client_app end: a Session_mv that first achieves PEER state by conn...">Client_session_mv</a> counterpart. </td></tr>
    <tr><td class="paramname">cli_app_ref</td><td>See <a class="el" href="classipc_1_1session_1_1Client__session__mv.html" title="Implements Session concept on the Client_app end: a Session_mv that first achieves PEER state by conn...">Client_session_mv</a> counterpart. </td></tr>
    <tr><td class="paramname">srv_app_ref</td><td>See <a class="el" href="classipc_1_1session_1_1Client__session__mv.html" title="Implements Session concept on the Client_app end: a Session_mv that first achieves PEER state by conn...">Client_session_mv</a> counterpart. </td></tr>
    <tr><td class="paramname">on_err_func</td><td>See <a class="el" href="classipc_1_1session_1_1Client__session__mv.html" title="Implements Session concept on the Client_app end: a Session_mv that first achieves PEER state by conn...">Client_session_mv</a> counterpart. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="ipc__session_2src_2ipc_2session_2detail_2client__session__impl_8hpp_source.html#l00944">944</a> of file <a class="el" href="ipc__session_2src_2ipc_2session_2detail_2client__session__impl_8hpp_source.html">client_session_impl.hpp</a>.</p>

</div>
</div>
<a id="aa12539a1a446cffb097f70cba8166088" name="aa12539a1a446cffb097f70cba8166088"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa12539a1a446cffb097f70cba8166088">&#9670;&nbsp;</a></span>~Client_session_impl()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;schema::MqType S_MQ_TYPE_OR_NONE, bool S_TRANSMIT_NATIVE_HANDLES, typename Mdt_payload , schema::ShmType S_SHM_TYPE_OR_NONE, bool S_GRACEFUL_FINISH_REQUIRED_V&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classipc_1_1session_1_1Client__session__impl.html">ipc::session::Client_session_impl</a>&lt; S_MQ_TYPE_OR_NONE, S_TRANSMIT_NATIVE_HANDLES, Mdt_payload, S_SHM_TYPE_OR_NONE, S_GRACEFUL_FINISH_REQUIRED_V &gt;::~<a class="el" href="classipc_1_1session_1_1Client__session__impl.html">Client_session_impl</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>See <a class="el" href="classipc_1_1session_1_1Client__session__mv.html" title="Implements Session concept on the Client_app end: a Session_mv that first achieves PEER state by conn...">Client_session_mv</a> counterpart. </p>

<p class="definition">Definition at line <a class="el" href="ipc__session_2src_2ipc_2session_2detail_2client__session__impl_8hpp_source.html#l01042">1042</a> of file <a class="el" href="ipc__session_2src_2ipc_2session_2detail_2client__session__impl_8hpp_source.html">client_session_impl.hpp</a>.</p>

</div>
</div>
<a id="aeaf64876702dffaab7441e3006195134" name="aeaf64876702dffaab7441e3006195134"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aeaf64876702dffaab7441e3006195134">&#9670;&nbsp;</a></span>Client_session_impl() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;schema::MqType S_MQ_TYPE_OR_NONE, bool S_TRANSMIT_NATIVE_HANDLES, typename Mdt_payload , schema::ShmType S_SHM_TYPE_OR_NONE, bool S_GRACEFUL_FINISH_REQUIRED_V&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classipc_1_1session_1_1Client__session__impl.html">ipc::session::Client_session_impl</a>&lt; S_MQ_TYPE_OR_NONE, S_TRANSMIT_NATIVE_HANDLES, Mdt_payload, S_SHM_TYPE_OR_NONE, S_GRACEFUL_FINISH_REQUIRED_V &gt;::Client_session_impl </td>
          <td>(</td>
          <td class="paramtype">flow::log::Logger *&#160;</td>
          <td class="paramname"><em>logger_ptr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structipc_1_1session_1_1Client__app.html">Client_app</a> &amp;&#160;</td>
          <td class="paramname"><em>cli_app_ref</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structipc_1_1session_1_1Server__app.html">Server_app</a> &amp;&#160;</td>
          <td class="paramname"><em>srv_app_ref</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">flow::async::Task_asio_err &amp;&amp;&#160;</td>
          <td class="paramname"><em>on_err_func</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classipc_1_1session_1_1Client__session__impl.html#ad6624a4b1f7fd6e24bdde50b323b8f97">On_passive_open_channel_func</a> &amp;&amp;&#160;</td>
          <td class="paramname"><em>on_passive_open_channel_func_or_empty_arg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::nullptr_t&#160;</td>
          <td class="paramname"><em>tag</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">explicit</span><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Delegated-to ctor that implements both non-default <code>public</code> ctors. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">logger_ptr</td><td>See public ctors. </td></tr>
    <tr><td class="paramname">cli_app_ref</td><td>See public ctors. </td></tr>
    <tr><td class="paramname">srv_app_ref</td><td>See public ctors. </td></tr>
    <tr><td class="paramname">on_err_func</td><td>See public ctors. This is the concretely-typed version of that arg. </td></tr>
    <tr><td class="paramname">on_passive_open_channel_func_or_empty_arg</td><td>See public ctors. This is the concretely-typed version of that arg; <code>.empty()</code> if the version without this arg was used. </td></tr>
    <tr><td class="paramname">tag</td><td>Ctor-selecting tag. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="ipc__session_2src_2ipc_2session_2detail_2client__session__impl_8hpp_source.html#l00901">901</a> of file <a class="el" href="ipc__session_2src_2ipc_2session_2detail_2client__session__impl_8hpp_source.html">client_session_impl.hpp</a>.</p>

<p class="reference">References <a class="el" href="ipc__session_2src_2ipc_2session_2detail_2client__session__impl_8hpp_source.html#l00853">ipc::session::Client_session_impl&lt; S_MQ_TYPE_OR_NONE, S_TRANSMIT_NATIVE_HANDLES, Mdt_payload, S_SHM_TYPE_OR_NONE, S_GRACEFUL_FINISH_REQUIRED_V &gt;::m_async_worker</a>.</p>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="a56c0d2b0ff082d1f7b0738e2528b4a92" name="a56c0d2b0ff082d1f7b0738e2528b4a92"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a56c0d2b0ff082d1f7b0738e2528b4a92">&#9670;&nbsp;</a></span>async_connect()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;schema::MqType S_MQ_TYPE_OR_NONE, bool S_TRANSMIT_NATIVE_HANDLES, typename Mdt_payload , schema::ShmType S_SHM_TYPE_OR_NONE, bool S_GRACEFUL_FINISH_REQUIRED_V&gt; </div>
<div class="memtemplate">
template&lt;typename Task_err &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classipc_1_1session_1_1Client__session__impl.html">ipc::session::Client_session_impl</a>&lt; S_MQ_TYPE_OR_NONE, S_TRANSMIT_NATIVE_HANDLES, Mdt_payload, S_SHM_TYPE_OR_NONE, S_GRACEFUL_FINISH_REQUIRED_V &gt;::async_connect </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classipc_1_1session_1_1Client__session__impl.html#a9d93e6080abf3b0827b97e084f5e8356">Mdt_builder_ptr</a> &amp;&#160;</td>
          <td class="paramname"><em>mdt</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classipc_1_1session_1_1Client__session__impl.html#aab1b23e3370a77db375a50ab156b5662">Channels</a> *&#160;</td>
          <td class="paramname"><em>init_channels_by_cli_req_pre_sized</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classipc_1_1session_1_1Client__session__impl.html#ad0ad69f676fc1260a3c493781fbbb81d">Mdt_reader_ptr</a> *&#160;</td>
          <td class="paramname"><em>mdt_from_srv_or_null</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classipc_1_1session_1_1Client__session__impl.html#aab1b23e3370a77db375a50ab156b5662">Channels</a> *&#160;</td>
          <td class="paramname"><em>init_channels_by_srv_req</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Task_err &amp;&amp;&#160;</td>
          <td class="paramname"><em>on_done_func</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Core implementation of <a class="el" href="classipc_1_1session_1_1Client__session__impl.html#aaf622f5f111ffa95d4ec6c636cfddb4a" title="See Client_session_mv counterpart.">sync_connect()</a>. </p>
<p >See "CONNECTING state and asynchronicity" in class doc header for key background.</p>
<dl class="section return"><dt>Returns</dt><dd>See sync_conect(). </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">mdt</td><td>See sync_conect(). </td></tr>
    <tr><td class="paramname">init_channels_by_cli_req_pre_sized</td><td>See sync_conect(). </td></tr>
    <tr><td class="paramname">mdt_from_srv_or_null</td><td>See sync_conect(). </td></tr>
    <tr><td class="paramname">init_channels_by_srv_req</td><td>See sync_conect(). </td></tr>
    <tr><td class="paramname">on_done_func</td><td>What to invoke in thread W on completion of the async-connect. As of this writing this is supplied by <a class="el" href="classipc_1_1session_1_1Client__session__impl.html#a1a7560109fa2aa2c16d4f4159918e2c2" title="Utility for *this and sub-classes: Implements sync_connect() given a functor that invokes the calling...">sync_connect_impl()</a> internal code. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="ipc__session_2src_2ipc_2session_2detail_2client__session__impl_8hpp_source.html#l01127">1127</a> of file <a class="el" href="ipc__session_2src_2ipc_2session_2detail_2client__session__impl_8hpp_source.html">client_session_impl.hpp</a>.</p>

<p class="reference">References <a class="el" href="shared__name_8hpp_source.html#l00674">ipc::util::Shared_name::ct()</a>, <a class="el" href="ipc__session_2src_2ipc_2session_2detail_2client__session__impl_8hpp_source.html#l00611">ipc::session::Client_session_impl&lt; S_MQ_TYPE_OR_NONE, S_TRANSMIT_NATIVE_HANDLES, Mdt_payload, S_SHM_TYPE_OR_NONE, S_GRACEFUL_FINISH_REQUIRED_V &gt;::Master_channel_req::m_req_msg</a>, <a class="el" href="util_8hpp_source.html#l00034">ipc::util::op_with_possible_bipc_exception()</a>, <a class="el" href="ipc__core_2src_2ipc_2util_2util_8cpp_source.html#l00030">ipc::util::OPEN_OR_CREATE</a>, <a class="el" href="process__credentials_8cpp_source.html#l00136">ipc::util::Process_credentials::own_group_id()</a>, <a class="el" href="process__credentials_8cpp_source.html#l00126">ipc::util::Process_credentials::own_process_id()</a>, <a class="el" href="process__credentials_8cpp_source.html#l00131">ipc::util::Process_credentials::own_user_id()</a>, <a class="el" href="ipc__core_2src_2ipc_2transport_2channel_8hpp_source.html#l02211">ipc::transport::Socket_stream_channel&lt; SIO &gt;::remote_peer_process_credentials()</a>, <a class="el" href="namespaceipc_1_1session_1_1error.html#a0708d4bec9ae853f4d7e3d7822fc8f2fa486f5607320d062fe89e559a1e7856b2">ipc::session::error::S_CLIENT_NAMESPACE_STORE_BAD_FORMAT</a>, <a class="el" href="namespaceipc_1_1session_1_1error.html#a0708d4bec9ae853f4d7e3d7822fc8f2fa7300721595cc25baa9a9e43bd76296aa">ipc::session::error::S_MUTEX_BIPC_MISC_LIBRARY_ERROR</a>, <a class="el" href="channel__base_8hpp_source.html#l00157">ipc::transport::struc::Channel_base::S_SERIALIZE_VIA_HEAP</a>, <a class="el" href="ipc__core_2src_2ipc_2util_2util_8cpp_source.html#l00037">ipc::util::shared_resource_permissions()</a>, and <a class="el" href="sync__io_2native__socket__stream_8cpp_source.html#l00083">ipc::transport::sync_io::Native_socket_stream::sync_connect()</a>.</p>
<div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="classipc_1_1session_1_1Client__session__impl_a56c0d2b0ff082d1f7b0738e2528b4a92_cgraph.svg" width="622" height="506"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe>
</div>
</div>

</div>
</div>
<a id="ab792f2389fd035827ae8dbead1650b78" name="ab792f2389fd035827ae8dbead1650b78"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab792f2389fd035827ae8dbead1650b78">&#9670;&nbsp;</a></span>async_worker()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;schema::MqType S_MQ_TYPE_OR_NONE, bool S_TRANSMIT_NATIVE_HANDLES, typename Mdt_payload , schema::ShmType S_SHM_TYPE_OR_NONE, bool S_GRACEFUL_FINISH_REQUIRED_V&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">flow::async::Single_thread_task_loop * <a class="el" href="classipc_1_1session_1_1Client__session__impl.html">ipc::session::Client_session_impl</a>&lt; S_MQ_TYPE_OR_NONE, S_TRANSMIT_NATIVE_HANDLES, Mdt_payload, S_SHM_TYPE_OR_NONE, S_GRACEFUL_FINISH_REQUIRED_V &gt;::async_worker</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Utility for sub-classes: provides ability to schedule or post tasks onto thread W. </p>
<dl class="section return"><dt>Returns</dt><dd>See above. </dd></dl>

<p class="definition">Definition at line <a class="el" href="ipc__session_2src_2ipc_2session_2detail_2client__session__impl_8hpp_source.html#l02583">2583</a> of file <a class="el" href="ipc__session_2src_2ipc_2session_2detail_2client__session__impl_8hpp_source.html">client_session_impl.hpp</a>.</p>

</div>
</div>
<a id="adac4cba3aefa629566f182a240b4cedd" name="adac4cba3aefa629566f182a240b4cedd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adac4cba3aefa629566f182a240b4cedd">&#9670;&nbsp;</a></span>cancel_peer_state_to_connecting()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;schema::MqType S_MQ_TYPE_OR_NONE, bool S_TRANSMIT_NATIVE_HANDLES, typename Mdt_payload , schema::ShmType S_SHM_TYPE_OR_NONE, bool S_GRACEFUL_FINISH_REQUIRED_V&gt; </div>
<div class="memtemplate">
template&lt;typename Task_err &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classipc_1_1session_1_1Client__session__impl.html">Client_session_impl</a>&lt; S_MQ_TYPE_OR_NONE, S_TRANSMIT_NATIVE_HANDLES, Mdt_payload, S_SHM_TYPE_OR_NONE, S_GRACEFUL_FINISH_REQUIRED_V &gt;<a class="el" href="classipc_1_1session_1_1Client__session__impl.html#a4c62a381340b0f494c4f117960bfca2b">::Master_structured_channel</a> * <a class="el" href="classipc_1_1session_1_1Client__session__impl.html">ipc::session::Client_session_impl</a>&lt; S_MQ_TYPE_OR_NONE, S_TRANSMIT_NATIVE_HANDLES, Mdt_payload, S_SHM_TYPE_OR_NONE, S_GRACEFUL_FINISH_REQUIRED_V &gt;::cancel_peer_state_to_connecting </td>
          <td>(</td>
          <td class="paramtype">Task_err &amp;&amp;&#160;</td>
          <td class="paramname"><em>on_done_func</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Utility for sub-classes: executed from <a class="el" href="classipc_1_1session_1_1Client__session__impl.html#a56c0d2b0ff082d1f7b0738e2528b4a92" title="Core implementation of sync_connect().">async_connect()</a>'s <code>on_done_func(Error_code())</code> (i.e., directly from handler invoked on success) &ndash; hence from thread W &ndash; this instead goes back to CONNECTING state, essentially indicating "yes, the vanilla <a class="el" href="classipc_1_1session_1_1Client__session__impl.html#a56c0d2b0ff082d1f7b0738e2528b4a92" title="Core implementation of sync_connect().">async_connect()</a> succeeded, but the true user-called <a class="el" href="classipc_1_1session_1_1Client__session__impl.html#a56c0d2b0ff082d1f7b0738e2528b4a92" title="Core implementation of sync_connect().">async_connect()</a> that piggybacked on the vanilla one will now do some more async stuff before reaching PEER state (or NULL on error). </p>
<p >"</p>
<p >As <code>on_done_func</code> was already invoked (and thus forgotten), the caller must supply a new one to execute once either PEER or NULL state is reached again. Since <code>*this</code> has completed its vanilla <a class="el" href="classipc_1_1session_1_1Client__session__impl.html#a56c0d2b0ff082d1f7b0738e2528b4a92" title="Core implementation of sync_connect().">async_connect()</a> work already, the responsibility for reaching one of those 2 states is now on the caller. Therefore whatever async processing follows our invocation is required to call <a class="el" href="classipc_1_1session_1_1Client__session__impl.html#a313e2fc3d4017232bad4fac2baae20a4" title="Utility for sub-classes: to be invoked, only from thread W and asynchronously at that,...">complete_async_connect_after_canceling_peer_state()</a>. That said, if a master-session-channel error occurs before that has a chance to be called, then:</p><ul>
<li><code>*this</code> will enter NULL state itself.</li>
<li><code>*this</code> will invoke the handler supplied here to <a class="el" href="classipc_1_1session_1_1Client__session__impl.html#adac4cba3aefa629566f182a240b4cedd" title="Utility for sub-classes: executed from async_connect()&#39;s on_done_func(Error_code()) (i....">cancel_peer_state_to_connecting()</a>.</li>
</ul>
<p >The session master channel is returned, so that the sub-class can take over operation as needed until either <a class="el" href="classipc_1_1session_1_1Client__session__impl.html#a313e2fc3d4017232bad4fac2baae20a4" title="Utility for sub-classes: to be invoked, only from thread W and asynchronously at that,...">complete_async_connect_after_canceling_peer_state()</a> or that channel becoming hosed (either way on_done_func() will be invoked). This avoids providing unrestricted <code>protected</code> access to it all times. See also <a class="el" href="classipc_1_1session_1_1Client__session__impl.html#ab792f2389fd035827ae8dbead1650b78" title="Utility for sub-classes: provides ability to schedule or post tasks onto thread W.">async_worker()</a>.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Task_err</td><td>See <a class="el" href="classipc_1_1session_1_1Client__session__impl.html#a56c0d2b0ff082d1f7b0738e2528b4a92" title="Core implementation of sync_connect().">async_connect()</a>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">on_done_func</td><td>See <a class="el" href="classipc_1_1session_1_1Client__session__impl.html#a56c0d2b0ff082d1f7b0738e2528b4a92" title="Core implementation of sync_connect().">async_connect()</a>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>See above. </dd></dl>

<p class="definition">Definition at line <a class="el" href="ipc__session_2src_2ipc_2session_2detail_2client__session__impl_8hpp_source.html#l02530">2530</a> of file <a class="el" href="ipc__session_2src_2ipc_2session_2detail_2client__session__impl_8hpp_source.html">client_session_impl.hpp</a>.</p>

</div>
</div>
<a id="a43d56aeae47d1fa815178ebd0ae1ff48" name="a43d56aeae47d1fa815178ebd0ae1ff48"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a43d56aeae47d1fa815178ebd0ae1ff48">&#9670;&nbsp;</a></span>cancel_peer_state_to_null()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;schema::MqType S_MQ_TYPE_OR_NONE, bool S_TRANSMIT_NATIVE_HANDLES, typename Mdt_payload , schema::ShmType S_SHM_TYPE_OR_NONE, bool S_GRACEFUL_FINISH_REQUIRED_V&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classipc_1_1session_1_1Client__session__impl.html">ipc::session::Client_session_impl</a>&lt; S_MQ_TYPE_OR_NONE, S_TRANSMIT_NATIVE_HANDLES, Mdt_payload, S_SHM_TYPE_OR_NONE, S_GRACEFUL_FINISH_REQUIRED_V &gt;::cancel_peer_state_to_null</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Utility for sub-classes: executed from <a class="el" href="classipc_1_1session_1_1Client__session__impl.html#a56c0d2b0ff082d1f7b0738e2528b4a92" title="Core implementation of sync_connect().">async_connect()</a>'s <code>on_done_func(Error_code())</code> (i.e., directly from handler invoked on success) &ndash; hence from thread W &ndash; this instead goes back to NULL state, essentially indicating "never mind -- this successful async_connect() actually failed.". </p>
<p >This... um... highly specific utility is intended for overriding <a class="el" href="classipc_1_1session_1_1Client__session__impl.html#a56c0d2b0ff082d1f7b0738e2528b4a92" title="Core implementation of sync_connect().">async_connect()</a> impl that performs <em>synchronous</em> post-processing in its own <code>on_done_func()</code> wrapper from sub-class's <a class="el" href="classipc_1_1session_1_1Client__session__impl.html#a56c0d2b0ff082d1f7b0738e2528b4a92" title="Core implementation of sync_connect().">async_connect()</a> that calls this class's <a class="el" href="classipc_1_1session_1_1Client__session__impl.html#a56c0d2b0ff082d1f7b0738e2528b4a92" title="Core implementation of sync_connect().">async_connect()</a>. </p>

<p class="definition">Definition at line <a class="el" href="ipc__session_2src_2ipc_2session_2detail_2client__session__impl_8hpp_source.html#l02511">2511</a> of file <a class="el" href="ipc__session_2src_2ipc_2session_2detail_2client__session__impl_8hpp_source.html">client_session_impl.hpp</a>.</p>

</div>
</div>
<a id="a313e2fc3d4017232bad4fac2baae20a4" name="a313e2fc3d4017232bad4fac2baae20a4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a313e2fc3d4017232bad4fac2baae20a4">&#9670;&nbsp;</a></span>complete_async_connect_after_canceling_peer_state()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;schema::MqType S_MQ_TYPE_OR_NONE, bool S_TRANSMIT_NATIVE_HANDLES, typename Mdt_payload , schema::ShmType S_SHM_TYPE_OR_NONE, bool S_GRACEFUL_FINISH_REQUIRED_V&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classipc_1_1session_1_1Client__session__impl.html">ipc::session::Client_session_impl</a>&lt; S_MQ_TYPE_OR_NONE, S_TRANSMIT_NATIVE_HANDLES, Mdt_payload, S_SHM_TYPE_OR_NONE, S_GRACEFUL_FINISH_REQUIRED_V &gt;::complete_async_connect_after_canceling_peer_state </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespaceipc.html#aa3192e586cc45d3e7c22463bf2760f89">Error_code</a> &amp;&#160;</td>
          <td class="paramname"><em>err_code_or_success</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Utility for sub-classes: to be invoked, only from thread W and asynchronously at that, after <a class="el" href="classipc_1_1session_1_1Client__session__impl.html#adac4cba3aefa629566f182a240b4cedd" title="Utility for sub-classes: executed from async_connect()&#39;s on_done_func(Error_code()) (i....">cancel_peer_state_to_connecting()</a>, this indicates the completion of the sub-class's additional async-connect steps, setting state to either NULL or PEER. </p>
<p >Invoke only in CONNECTING state; else undefined behavior (assertion may trip).</p>
<p >The handler given to <a class="el" href="classipc_1_1session_1_1Client__session__impl.html#adac4cba3aefa629566f182a240b4cedd" title="Utility for sub-classes: executed from async_connect()&#39;s on_done_func(Error_code()) (i....">cancel_peer_state_to_connecting()</a> will execute.</p>
<p >Take care to check <a class="el" href="classipc_1_1session_1_1Session__base.html#a398f3e6a30b3fae8e110af9fd1ff75e3" title="Returns true if and only if hose() has been called.">Session_base::hosed()</a> as needed before calling this; if hosed then do not call.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">err_code_or_success</td><td>State will proceed to PEER if falsy else to NULL; in the latter case the given code shall be passed to handler as the reason for failure to ultimately async-connect. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="ipc__session_2src_2ipc_2session_2detail_2client__session__impl_8hpp_source.html#l02549">2549</a> of file <a class="el" href="ipc__session_2src_2ipc_2session_2detail_2client__session__impl_8hpp_source.html">client_session_impl.hpp</a>.</p>

</div>
</div>
<a id="a6c67f6c993089dadf16acb47d535cb68" name="a6c67f6c993089dadf16acb47d535cb68"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6c67f6c993089dadf16acb47d535cb68">&#9670;&nbsp;</a></span>create_channel_obj()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;schema::MqType S_MQ_TYPE_OR_NONE, bool S_TRANSMIT_NATIVE_HANDLES, typename Mdt_payload , schema::ShmType S_SHM_TYPE_OR_NONE, bool S_GRACEFUL_FINISH_REQUIRED_V&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classipc_1_1session_1_1Client__session__impl.html">ipc::session::Client_session_impl</a>&lt; S_MQ_TYPE_OR_NONE, S_TRANSMIT_NATIVE_HANDLES, Mdt_payload, S_SHM_TYPE_OR_NONE, S_GRACEFUL_FINISH_REQUIRED_V &gt;::create_channel_obj </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespaceipc_1_1session.html#a6d07d9996af19e57eb42416e914110ea">Shared_name</a> &amp;&#160;</td>
          <td class="paramname"><em>mq_name_c2s_or_none</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespaceipc_1_1session.html#a6d07d9996af19e57eb42416e914110ea">Shared_name</a> &amp;&#160;</td>
          <td class="paramname"><em>mq_name_s2c_or_none</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structipc_1_1util_1_1Native__handle.html">util::Native_handle</a> &amp;&amp;&#160;</td>
          <td class="paramname"><em>local_hndl_or_null</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classipc_1_1session_1_1Client__session__impl.html#a994a2f0b281fdeaeb6c09f6d91df351a">Channel_obj</a> *&#160;</td>
          <td class="paramname"><em>opened_channel_ptr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>active_else_passive</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceipc.html#aa3192e586cc45d3e7c22463bf2760f89">Error_code</a> *&#160;</td>
          <td class="paramname"><em>err_code_ptr</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>In thread W, based on resources acquired on server side, creates local <a class="el" href="classipc_1_1session_1_1Client__session__impl.html#a994a2f0b281fdeaeb6c09f6d91df351a" title="See Client_session_mv counterpart.">Channel_obj</a> to emit to the user thus completing a channel-open. </p>
<p >If active-open on our part, we do this upon receiving server response to our open-channel-to-server request. If passive-open, we do this upon receiving server's open-channel-to-client request, before replying with our OK. Either way the in-message from server contained the handle(s) to the resource(s) it acquired for this channel; these are args to this method.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">mq_name_c2s_or_none</td><td>If <a class="el" href="classipc_1_1session_1_1Client__session__impl.html#a4036fbd01410a9befc7c541368d92704" title="See Client_session_mv counterpart.">S_MQS_ENABLED</a> this is the (non-empty) name of the client-&gt;server unidirectional MQ for the channel. Else empty/ignored. </td></tr>
    <tr><td class="paramname">mq_name_s2c_or_none</td><td>Like the preceding but opposite-direction (server-&gt;client). </td></tr>
    <tr><td class="paramname">local_hndl_or_null</td><td>If <a class="el" href="classipc_1_1session_1_1Client__session__impl.html#ac28652995339005a7afeb467b33b3b62" title="See Client_session_mv counterpart.">S_SOCKET_STREAM_ENABLED</a> this is our pre-connected <code>Native_handle</code>; the server did <code>connect_pair()</code> and sent us 1/2 of the pair. Else null/ignored. </td></tr>
    <tr><td class="paramname">opened_channel_ptr</td><td>Target <a class="el" href="classipc_1_1session_1_1Client__session__impl.html#a994a2f0b281fdeaeb6c09f6d91df351a" title="See Client_session_mv counterpart.">Channel_obj</a> we shall try to move-to PEER state. It'll be left unmodified if error is emitted. </td></tr>
    <tr><td class="paramname">active_else_passive</td><td><code>true</code> if this is from <a class="el" href="classipc_1_1session_1_1Client__session__impl.html#a4a377590fbf55b6d312f24d888d2a1bd" title="See Client_session_mv counterpart.">open_channel()</a>; <code>false</code> if from <a class="el" href="classipc_1_1session_1_1Client__session__impl.html#a84bcd253bb1cd89fcf94233c2f771142" title="In thread W, handler for m_master_channel receiving a passive-open (a/k/a open-channel-to-client) req...">on_master_channel_open_channel_req()</a>. </td></tr>
    <tr><td class="paramname">err_code_ptr</td><td>Non-null pointer to <a class="el" href="namespaceipc.html#aa3192e586cc45d3e7c22463bf2760f89" title="Short-hand for flow::Error_code which is very common.">Error_code</a>; deref shall be untouched on success (and must be falsy at entry); else deref shall be set to reason for failure. As of this writing the only possible path to failure is if <a class="el" href="classipc_1_1session_1_1Client__session__impl.html#a4036fbd01410a9befc7c541368d92704" title="See Client_session_mv counterpart.">S_MQS_ENABLED</a>, and we're unable to open an MQ handle or <a class="el" href="classipc_1_1transport_1_1Blob__stream__mq__sender.html" title="Implements Blob_sender concept by using an adopted Persistent_mq_handle MQ handle to an MQ (message q...">transport::Blob_stream_mq_sender</a> or <a class="el" href="classipc_1_1transport_1_1Blob__stream__mq__receiver.html" title="Implements Blob_receiver concept by using an adopted Persistent_mq_handle MQ handle to an MQ (message...">transport::Blob_stream_mq_receiver</a> to 1 of the MQs. This is highly unlikely, since the server was able to do it fine, but we leave it to caller to deal with the implications.</td></tr>
  </table>
  </dd>
</dl>
<dl class="todo"><dt><b><a class="el" href="todo.html#_todo000032">Todo:</a></b></dt><dd>As of this writing the eventuality where <a class="el" href="classipc_1_1session_1_1Client__session__impl.html#a6c67f6c993089dadf16acb47d535cb68" title="In thread W, based on resources acquired on server side, creates local Channel_obj to emit to the use...">Client_session_impl::create_channel_obj()</a> yields an error is treated as assertion-trip-worthy by its caller; hence consider just tripping assertion inside instead and no out-arg. For now it is left this way in case we'd want the (internal) caller to do something more graceful in the future, and in the meantime it's a decently reusable chunk of code to use in that alleged contingency. </dd></dl>

<p class="definition">Definition at line <a class="el" href="ipc__session_2src_2ipc_2session_2detail_2client__session__impl_8hpp_source.html#l02397">2397</a> of file <a class="el" href="ipc__session_2src_2ipc_2session_2detail_2client__session__impl_8hpp_source.html">client_session_impl.hpp</a>.</p>

<p class="reference">References <a class="el" href="shared__name_8cpp_source.html#l00155">ipc::util::Shared_name::empty()</a>, and <a class="el" href="ipc__core_2src_2ipc_2util_2util_8cpp_source.html#l00031">ipc::util::OPEN_ONLY</a>.</p>
<div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="classipc_1_1session_1_1Client__session__impl_a6c67f6c993089dadf16acb47d535cb68_cgraph.svg" width="346" height="59"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe>
</div>
</div>

</div>
</div>
<a id="afb09c3a23b7e63938b9a494cec6e769b" name="afb09c3a23b7e63938b9a494cec6e769b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afb09c3a23b7e63938b9a494cec6e769b">&#9670;&nbsp;</a></span>dtor_async_worker_stop()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;schema::MqType S_MQ_TYPE_OR_NONE, bool S_TRANSMIT_NATIVE_HANDLES, typename Mdt_payload , schema::ShmType S_SHM_TYPE_OR_NONE, bool S_GRACEFUL_FINISH_REQUIRED_V&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classipc_1_1session_1_1Client__session__impl.html">ipc::session::Client_session_impl</a>&lt; S_MQ_TYPE_OR_NONE, S_TRANSMIT_NATIVE_HANDLES, Mdt_payload, S_SHM_TYPE_OR_NONE, S_GRACEFUL_FINISH_REQUIRED_V &gt;::dtor_async_worker_stop</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Synchronously stops <a class="el" href="classipc_1_1session_1_1Client__session__impl.html#ab792f2389fd035827ae8dbead1650b78" title="Utility for sub-classes: provides ability to schedule or post tasks onto thread W.">async_worker()</a> loop, the post-condition being that thread W has been joined; no tasks <code>post()</code>ed onto it by <code>*this</code> or subclass shall execute after this returns. </p>
<ul>
<li>If <code>*this</code> is not being subclassed, or if it never posts onto <a class="el" href="classipc_1_1session_1_1Client__session__impl.html#ab792f2389fd035827ae8dbead1650b78" title="Utility for sub-classes: provides ability to schedule or post tasks onto thread W.">async_worker()</a>: Our own dtor shall call this first-thing; no need for subclass to worry.</li>
<li>If <code>*this</code> is being subclassed, and it does post onto <a class="el" href="classipc_1_1session_1_1Client__session__impl.html#ab792f2389fd035827ae8dbead1650b78" title="Utility for sub-classes: provides ability to schedule or post tasks onto thread W.">async_worker()</a>: The terminal subclass's dtor must call this ~first-thing (our own dtor, once it is soon called, shall know not to re-execute the same thing).</li>
</ul>
<p >Call at most once; otherwise undefined behavior (assertion may trip).</p>
<p >This exists to avoid a race, however unlikely, between a subclass's asynchronous accept-log-in code posted onto thread W, and that same class's dtor being invoked by the user in thread U. There is a short time period, when thread W (<a class="el" href="classipc_1_1session_1_1Client__session__impl.html#ac3039c565e1da99296dfb71255129201" title="Worker thread (a/k/a thread W).">m_async_worker</a>) is active &ndash; <code>*this</code> is still intact &ndash; but the subclass's members are being destroyed by its dtor. In that case <a class="el" href="classipc_1_1session_1_1Client__session__impl.html#afb09c3a23b7e63938b9a494cec6e769b" title="Synchronously stops async_worker() loop, the post-condition being that thread W has been joined; no t...">dtor_async_worker_stop()</a> would be called by the subclass dtor to put an end to async shenanigans in thread W, so it can continue destroying self in peace. When there is no subclass, our own dtor does so. </p>

<p class="definition">Definition at line <a class="el" href="ipc__session_2src_2ipc_2session_2detail_2client__session__impl_8hpp_source.html#l00955">955</a> of file <a class="el" href="ipc__session_2src_2ipc_2session_2detail_2client__session__impl_8hpp_source.html">client_session_impl.hpp</a>.</p>

<p class="reference">References <a class="el" href="session__base_8hpp_source.html#l01126">ipc::session::Session_base&lt; S_MQ_TYPE_OR_NONE, S_TRANSMIT_NATIVE_HANDLES, Mdt_payload &gt;::Graceful_finisher::on_dtor_start()</a>.</p>
<div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="classipc_1_1session_1_1Client__session__impl_afb09c3a23b7e63938b9a494cec6e769b_cgraph.svg" width="378" height="59"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe>
</div>
</div>

</div>
</div>
<a id="a428ae010a09aae1bac509e87fd927152" name="a428ae010a09aae1bac509e87fd927152"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a428ae010a09aae1bac509e87fd927152">&#9670;&nbsp;</a></span>invoke_conn_on_done_func()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;schema::MqType S_MQ_TYPE_OR_NONE, bool S_TRANSMIT_NATIVE_HANDLES, typename Mdt_payload , schema::ShmType S_SHM_TYPE_OR_NONE, bool S_GRACEFUL_FINISH_REQUIRED_V&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classipc_1_1session_1_1Client__session__impl.html">ipc::session::Client_session_impl</a>&lt; S_MQ_TYPE_OR_NONE, S_TRANSMIT_NATIVE_HANDLES, Mdt_payload, S_SHM_TYPE_OR_NONE, S_GRACEFUL_FINISH_REQUIRED_V &gt;::invoke_conn_on_done_func </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespaceipc.html#aa3192e586cc45d3e7c22463bf2760f89">Error_code</a> &amp;&#160;</td>
          <td class="paramname"><em>err_code</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Little helper that invokes <a class="el" href="classipc_1_1session_1_1Client__session__impl.html#addb0e40c34f2ae44ee1252f8123c149c" title="The on_done_func argument to async_connect(); .empty() except while in State::S_CONNECTING state.">m_conn_on_done_func_or_empty</a>, passing it <code>err_code</code>, and &ndash; per that member's internal use semantics &ndash; empties <a class="el" href="classipc_1_1session_1_1Client__session__impl.html#addb0e40c34f2ae44ee1252f8123c149c" title="The on_done_func argument to async_connect(); .empty() except while in State::S_CONNECTING state.">m_conn_on_done_func_or_empty</a>. </p>
<p >A key property is that the emptying occurs just <em>before</em> invoking it (obviously first saving it). This allows the handler to itself un-empty <a class="el" href="classipc_1_1session_1_1Client__session__impl.html#addb0e40c34f2ae44ee1252f8123c149c" title="The on_done_func argument to async_connect(); .empty() except while in State::S_CONNECTING state.">m_conn_on_done_func_or_empty</a>, as required by <a class="el" href="classipc_1_1session_1_1Client__session__impl.html#adac4cba3aefa629566f182a240b4cedd" title="Utility for sub-classes: executed from async_connect()&#39;s on_done_func(Error_code()) (i....">cancel_peer_state_to_connecting()</a> at least. (That, in turn, may be used by sub-classes that implement <a class="el" href="classipc_1_1session_1_1Client__session__impl.html#a56c0d2b0ff082d1f7b0738e2528b4a92" title="Core implementation of sync_connect().">async_connect()</a> by piggybacking onto our vanilla one.)</p>
<p ><a class="el" href="classipc_1_1session_1_1Client__session__impl.html#addb0e40c34f2ae44ee1252f8123c149c" title="The on_done_func argument to async_connect(); .empty() except while in State::S_CONNECTING state.">m_conn_on_done_func_or_empty</a> must not be empty; or behavior is undefined.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">err_code</td><td>Arg to <code><a class="el" href="classipc_1_1session_1_1Client__session__impl.html#addb0e40c34f2ae44ee1252f8123c149c" title="The on_done_func argument to async_connect(); .empty() except while in State::S_CONNECTING state.">m_conn_on_done_func_or_empty()</a></code>. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="ipc__session_2src_2ipc_2session_2detail_2client__session__impl_8hpp_source.html#l01931">1931</a> of file <a class="el" href="ipc__session_2src_2ipc_2session_2detail_2client__session__impl_8hpp_source.html">client_session_impl.hpp</a>.</p>

</div>
</div>
<a id="a5f156b23ce19cd878c3e83330e63f56f" name="a5f156b23ce19cd878c3e83330e63f56f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5f156b23ce19cd878c3e83330e63f56f">&#9670;&nbsp;</a></span>master_channel_const()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;schema::MqType S_MQ_TYPE_OR_NONE, bool S_TRANSMIT_NATIVE_HANDLES, typename Mdt_payload , schema::ShmType S_SHM_TYPE_OR_NONE, bool S_GRACEFUL_FINISH_REQUIRED_V&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classipc_1_1session_1_1Client__session__impl.html">Client_session_impl</a>&lt; S_MQ_TYPE_OR_NONE, S_TRANSMIT_NATIVE_HANDLES, Mdt_payload, S_SHM_TYPE_OR_NONE, S_GRACEFUL_FINISH_REQUIRED_V &gt;<a class="el" href="classipc_1_1session_1_1Client__session__impl.html#a4c62a381340b0f494c4f117960bfca2b">::Master_structured_channel</a> &amp; <a class="el" href="classipc_1_1session_1_1Client__session__impl.html">ipc::session::Client_session_impl</a>&lt; S_MQ_TYPE_OR_NONE, S_TRANSMIT_NATIVE_HANDLES, Mdt_payload, S_SHM_TYPE_OR_NONE, S_GRACEFUL_FINISH_REQUIRED_V &gt;::master_channel_const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Utility for sub-classes: provides ability to <em>immutably query</em> the session master channel, particularly after our async_accept_log_in() succeeds, but before the sub-classed wrapper of its on-done handler succeeds. </p>
<p >For example one can harmlessly query <a class="el" href="classipc_1_1transport_1_1struc_1_1Channel.html#a9a540a274df3bc7da8fc35ed2a2c1e57" title="Returns the (non-nil) logged-in session token; or nil if not in logged-in phase, or if a prior error ...">transport::struc::Channel::session_token()</a>.</p>
<p ><code>protected</code> but <code>const</code> access does not much bother me (ygoldfel) stylistically.</p>
<dl class="section return"><dt>Returns</dt><dd>See above. </dd></dl>

<p class="definition">Definition at line <a class="el" href="ipc__session_2src_2ipc_2session_2detail_2client__session__impl_8hpp_source.html#l02589">2589</a> of file <a class="el" href="ipc__session_2src_2ipc_2session_2detail_2client__session__impl_8hpp_source.html">client_session_impl.hpp</a>.</p>

</div>
</div>
<a id="a7ecad909e1013271ff365437f2fdae85" name="a7ecad909e1013271ff365437f2fdae85"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7ecad909e1013271ff365437f2fdae85">&#9670;&nbsp;</a></span>mdt_builder()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;schema::MqType S_MQ_TYPE_OR_NONE, bool S_TRANSMIT_NATIVE_HANDLES, typename Mdt_payload , schema::ShmType S_SHM_TYPE_OR_NONE, bool S_GRACEFUL_FINISH_REQUIRED_V&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classipc_1_1session_1_1Client__session__impl.html">Client_session_impl</a>&lt; S_MQ_TYPE_OR_NONE, S_TRANSMIT_NATIVE_HANDLES, Mdt_payload, S_SHM_TYPE_OR_NONE, S_GRACEFUL_FINISH_REQUIRED_V &gt;<a class="el" href="classipc_1_1session_1_1Client__session__impl.html#a9d93e6080abf3b0827b97e084f5e8356">::Mdt_builder_ptr</a> <a class="el" href="classipc_1_1session_1_1Client__session__impl.html">ipc::session::Client_session_impl</a>&lt; S_MQ_TYPE_OR_NONE, S_TRANSMIT_NATIVE_HANDLES, Mdt_payload, S_SHM_TYPE_OR_NONE, S_GRACEFUL_FINISH_REQUIRED_V &gt;::mdt_builder</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>See <a class="el" href="classipc_1_1session_1_1Client__session__mv.html" title="Implements Session concept on the Client_app end: a Session_mv that first achieves PEER state by conn...">Client_session_mv</a> counterpart. </p>
<p >Reminder: it can be used not only in PEER state (for <a class="el" href="classipc_1_1session_1_1Client__session__impl.html#a4a377590fbf55b6d312f24d888d2a1bd" title="See Client_session_mv counterpart.">open_channel()</a>) but also NULL state (for <a class="el" href="classipc_1_1session_1_1Client__session__impl.html#a56c0d2b0ff082d1f7b0738e2528b4a92" title="Core implementation of sync_connect().">async_connect()</a>).</p>
<dl class="section return"><dt>Returns</dt><dd>See <a class="el" href="classipc_1_1session_1_1Client__session__mv.html" title="Implements Session concept on the Client_app end: a Session_mv that first achieves PEER state by conn...">Client_session_mv</a> counterpart. </dd></dl>

<p class="definition">Definition at line <a class="el" href="ipc__session_2src_2ipc_2session_2detail_2client__session__impl_8hpp_source.html#l02052">2052</a> of file <a class="el" href="ipc__session_2src_2ipc_2session_2detail_2client__session__impl_8hpp_source.html">client_session_impl.hpp</a>.</p>

<p class="reference">References <a class="el" href="sync__io_2native__socket__stream_8hpp_source.html#l00197">ipc::transport::sync_io::Native_socket_stream::S_MAX_META_BLOB_LENGTH</a>.</p>

</div>
</div>
<a id="a417e9c40eefdfb4622f84275795640c4" name="a417e9c40eefdfb4622f84275795640c4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a417e9c40eefdfb4622f84275795640c4">&#9670;&nbsp;</a></span>on_master_channel_error()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;schema::MqType S_MQ_TYPE_OR_NONE, bool S_TRANSMIT_NATIVE_HANDLES, typename Mdt_payload , schema::ShmType S_SHM_TYPE_OR_NONE, bool S_GRACEFUL_FINISH_REQUIRED_V&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classipc_1_1session_1_1Client__session__impl.html">ipc::session::Client_session_impl</a>&lt; S_MQ_TYPE_OR_NONE, S_TRANSMIT_NATIVE_HANDLES, Mdt_payload, S_SHM_TYPE_OR_NONE, S_GRACEFUL_FINISH_REQUIRED_V &gt;::on_master_channel_error </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classipc_1_1session_1_1Client__session__impl.html#a6a1cb9c344c312b4eff5c360d7114e2c">Master_structured_channel_observer</a> &amp;&#160;</td>
          <td class="paramname"><em>master_channel_observer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespaceipc.html#aa3192e586cc45d3e7c22463bf2760f89">Error_code</a> &amp;&#160;</td>
          <td class="paramname"><em>err_code</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>In thread W, handler for <a class="el" href="classipc_1_1session_1_1Client__session__impl.html#a3acf3432c3806476fc20e951d0790949" title="The session master channel.">m_master_channel</a> indicating incoming-direction channel-hosing error. </p>
<p >It is possible that <a class="el" href="classipc_1_1session_1_1Client__session__impl.html#a3acf3432c3806476fc20e951d0790949" title="The session master channel.">m_master_channel</a> has been <code>.reset()</code> in the meantime, by seeing log-in failure in <a class="el" href="classipc_1_1session_1_1Client__session__impl.html#a139fde1cf8dc2c64276b9eb25b35bcee" title="In thread W, handler for the successful receipt of log-in response (upon send()ing the log-in request...">on_master_channel_log_in_rsp()</a>, and no longer exists. This is tested via the observer arg.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">master_channel_observer</td><td><code>weak_ptr</code> observer of <a class="el" href="classipc_1_1session_1_1Client__session__impl.html#a3acf3432c3806476fc20e951d0790949" title="The session master channel.">m_master_channel</a> at the time it was constructed. <code>master_channel_observer.lock()</code> is either null (we've destroyed <a class="el" href="classipc_1_1session_1_1Client__session__impl.html#a3acf3432c3806476fc20e951d0790949" title="The session master channel.">m_master_channel</a> due to another error condition) or equals <a class="el" href="classipc_1_1session_1_1Client__session__impl.html#a3acf3432c3806476fc20e951d0790949" title="The session master channel.">m_master_channel</a>. </td></tr>
    <tr><td class="paramname">err_code</td><td>The non-success <a class="el" href="namespaceipc.html#aa3192e586cc45d3e7c22463bf2760f89" title="Short-hand for flow::Error_code which is very common.">Error_code</a> from <code>struc::Channel</code>. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="ipc__session_2src_2ipc_2session_2detail_2client__session__impl_8hpp_source.html#l01946">1946</a> of file <a class="el" href="ipc__session_2src_2ipc_2session_2detail_2client__session__impl_8hpp_source.html">client_session_impl.hpp</a>.</p>

</div>
</div>
<a id="ac983066e433f143cf02cd730260e6e65" name="ac983066e433f143cf02cd730260e6e65"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac983066e433f143cf02cd730260e6e65">&#9670;&nbsp;</a></span>on_master_channel_init_open_channel()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;schema::MqType S_MQ_TYPE_OR_NONE, bool S_TRANSMIT_NATIVE_HANDLES, typename Mdt_payload , schema::ShmType S_SHM_TYPE_OR_NONE, bool S_GRACEFUL_FINISH_REQUIRED_V&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classipc_1_1session_1_1Client__session__impl.html">ipc::session::Client_session_impl</a>&lt; S_MQ_TYPE_OR_NONE, S_TRANSMIT_NATIVE_HANDLES, Mdt_payload, S_SHM_TYPE_OR_NONE, S_GRACEFUL_FINISH_REQUIRED_V &gt;::on_master_channel_init_open_channel </td>
          <td>(</td>
          <td class="paramtype">typename Master_structured_channel::Msg_in_ptr &amp;&amp;&#160;</td>
          <td class="paramname"><em>open_channel_msg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>n_init_channels</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const boost::shared_ptr&lt; <a class="el" href="classipc_1_1session_1_1Client__session__impl.html#aab1b23e3370a77db375a50ab156b5662">Channels</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>init_channels_ptr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classipc_1_1session_1_1Client__session__impl.html#aab1b23e3370a77db375a50ab156b5662">Channels</a> *&#160;</td>
          <td class="paramname"><em>init_channels_by_cli_req_pre_sized</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classipc_1_1session_1_1Client__session__impl.html#ad0ad69f676fc1260a3c493781fbbb81d">Mdt_reader_ptr</a> *&#160;</td>
          <td class="paramname"><em>mdt_from_srv_or_null</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classipc_1_1session_1_1Client__session__impl.html#aab1b23e3370a77db375a50ab156b5662">Channels</a> *&#160;</td>
          <td class="paramname"><em>init_channels_by_srv_req</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classipc_1_1session_1_1Client__session__impl.html#ad0ad69f676fc1260a3c493781fbbb81d">Mdt_reader_ptr</a> &amp;&amp;&#160;</td>
          <td class="paramname"><em>mdt_from_srv</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>In thread W, handler for <a class="el" href="classipc_1_1session_1_1Client__session__impl.html#a3acf3432c3806476fc20e951d0790949" title="The session master channel.">m_master_channel</a> receiving a init-channel-open message. </p>
<p >This is similar to <a class="el" href="classipc_1_1session_1_1Client__session__impl.html#a84bcd253bb1cd89fcf94233c2f771142" title="In thread W, handler for m_master_channel receiving a passive-open (a/k/a open-channel-to-client) req...">on_master_channel_open_channel_req()</a>, except:</p><ul>
<li>It occurs in CONNECTING state, after log-in, if server is required to open init-channels on our behalf or its behalf or both.</li>
<li>It uses the same in-message, but it is not treated as a request; rather just a notification of the info regarding 1 of the requested channels...</li>
<li>...except for the last one, which <em>is</em> treated as a request:<ul>
<li>we set up the regular passive-open-channel handler (<a class="el" href="classipc_1_1session_1_1Client__session__impl.html#a84bcd253bb1cd89fcf94233c2f771142" title="In thread W, handler for m_master_channel receiving a passive-open (a/k/a open-channel-to-client) req...">on_master_channel_open_channel_req()</a>);</li>
<li>we move to PEER state (emit to <a class="el" href="classipc_1_1session_1_1Client__session__impl.html#addb0e40c34f2ae44ee1252f8123c149c" title="The on_done_func argument to async_connect(); .empty() except while in State::S_CONNECTING state.">m_conn_on_done_func_or_empty</a>);</li>
<li>we respond with an OK; so server knows it too can move to PEER state.<ul>
<li>If that <code>send()</code> fails we move to NULL instead of PEER state (still invoke on-connect-done handler).</li>
</ul>
</li>
</ul>
</li>
</ul>
<p >So this method is invoked <code>n_init_channels</code> times (assuming all goes well); and each time <code>*init_channels_ptr</code> grows by 1 element; once it is <code>n_init_channels</code> long &ndash; that's the last one, and we do those last 3 sub-bullet points.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">open_channel_msg</td><td>The in-message from <code>struc::Channel</code>. </td></tr>
    <tr><td class="paramname">n_init_channels</td><td>1+, the count of clients local <a class="el" href="classipc_1_1session_1_1Client__session__impl.html#a56c0d2b0ff082d1f7b0738e2528b4a92" title="Core implementation of sync_connect().">async_connect()</a> requested plus same from opposing <code>async_accept()</code>. </td></tr>
    <tr><td class="paramname">init_channels_ptr</td><td>Intermediate PEER-state <a class="el" href="classipc_1_1session_1_1Client__session__impl.html#a994a2f0b281fdeaeb6c09f6d91df351a" title="See Client_session_mv counterpart.">Channel_obj</a> results list; first empty, next time with 1 elements, then 2, .... If <code>.size() == n_init_channels</code>, we shall move to PEER state. </td></tr>
    <tr><td class="paramname">init_channels_by_cli_req_pre_sized</td><td>See advanced <a class="el" href="classipc_1_1session_1_1Client__session__impl.html#a56c0d2b0ff082d1f7b0738e2528b4a92" title="Core implementation of sync_connect().">async_connect()</a> features. </td></tr>
    <tr><td class="paramname">mdt_from_srv_or_null</td><td>See advanced <a class="el" href="classipc_1_1session_1_1Client__session__impl.html#a56c0d2b0ff082d1f7b0738e2528b4a92" title="Core implementation of sync_connect().">async_connect()</a> features. </td></tr>
    <tr><td class="paramname">init_channels_by_srv_req</td><td>See advanced <a class="el" href="classipc_1_1session_1_1Client__session__impl.html#a56c0d2b0ff082d1f7b0738e2528b4a92" title="Core implementation of sync_connect().">async_connect()</a> features. </td></tr>
    <tr><td class="paramname">mdt_from_srv</td><td>Value to which to set <code>*mdt_from_srv_or_null</code>, if the latter is not null, and this is the last invocation of this method. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="ipc__session_2src_2ipc_2session_2detail_2client__session__impl_8hpp_source.html#l01770">1770</a> of file <a class="el" href="ipc__session_2src_2ipc_2session_2detail_2client__session__impl_8hpp_source.html">client_session_impl.hpp</a>.</p>

<p class="reference">References <a class="el" href="shared__name_8hpp_source.html#l00674">ipc::util::Shared_name::ct()</a>.</p>
<div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="classipc_1_1session_1_1Client__session__impl_ac983066e433f143cf02cd730260e6e65_cgraph.svg" width="398" height="59"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe>
</div>
</div>

</div>
</div>
<a id="a139fde1cf8dc2c64276b9eb25b35bcee" name="a139fde1cf8dc2c64276b9eb25b35bcee"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a139fde1cf8dc2c64276b9eb25b35bcee">&#9670;&nbsp;</a></span>on_master_channel_log_in_rsp()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;schema::MqType S_MQ_TYPE_OR_NONE, bool S_TRANSMIT_NATIVE_HANDLES, typename Mdt_payload , schema::ShmType S_SHM_TYPE_OR_NONE, bool S_GRACEFUL_FINISH_REQUIRED_V&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classipc_1_1session_1_1Client__session__impl.html">ipc::session::Client_session_impl</a>&lt; S_MQ_TYPE_OR_NONE, S_TRANSMIT_NATIVE_HANDLES, Mdt_payload, S_SHM_TYPE_OR_NONE, S_GRACEFUL_FINISH_REQUIRED_V &gt;::on_master_channel_log_in_rsp </td>
          <td>(</td>
          <td class="paramtype">typename Master_structured_channel::Msg_in_ptr &amp;&amp;&#160;</td>
          <td class="paramname"><em>log_in_rsp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classipc_1_1session_1_1Client__session__impl.html#aab1b23e3370a77db375a50ab156b5662">Channels</a> *&#160;</td>
          <td class="paramname"><em>init_channels_by_cli_req_pre_sized</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classipc_1_1session_1_1Client__session__impl.html#ad0ad69f676fc1260a3c493781fbbb81d">Mdt_reader_ptr</a> *&#160;</td>
          <td class="paramname"><em>mdt_from_srv_or_null</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classipc_1_1session_1_1Client__session__impl.html#aab1b23e3370a77db375a50ab156b5662">Channels</a> *&#160;</td>
          <td class="paramname"><em>init_channels_by_srv_req</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>In thread W, handler for the successful receipt of log-in response (upon <code>send()</code>ing the log-in request), as invoked in CONNECTING state only if the low-level transport::Native_socket_stream::async_connect() succeeded. </p>
<p >Post-condition:</p><ul>
<li>If no init-channels requested by client (<a class="el" href="classipc_1_1session_1_1Client__session__impl.html#a56c0d2b0ff082d1f7b0738e2528b4a92" title="Core implementation of sync_connect().">async_connect()</a> advanced-use) <em>nor</em> by server (as indicated in <code>log_in_rsp</code> itself): <a class="el" href="classipc_1_1session_1_1Client__session__impl.html#a3a5f5102020adace1e898d977e929908" title="The current state of *this.">m_state</a> changed from CONNECTING to either NULL or PEER, depending on whether the log-in response <code>log_in_rsp</code> indicates server side OKed the log-in. Per the invariant in <a class="el" href="classipc_1_1session_1_1Client__session__impl.html#a3acf3432c3806476fc20e951d0790949" title="The session master channel.">m_master_channel</a> doc header: <a class="el" href="classipc_1_1session_1_1Client__session__impl.html#a3acf3432c3806476fc20e951d0790949" title="The session master channel.">m_master_channel</a> is null (state became NULL) or non-null (state became PEER). In the former case <a class="el" href="classipc_1_1session_1_1Client__session__impl.html#a56c0d2b0ff082d1f7b0738e2528b4a92" title="Core implementation of sync_connect().">async_connect()</a> can be attempted again.</li>
<li>Otherwise (if 1+ such channels, in total, requested): <a class="el" href="classipc_1_1session_1_1Client__session__impl.html#a3a5f5102020adace1e898d977e929908" title="The current state of *this.">m_state</a> unchanged from CONNECTING; <a class="el" href="classipc_1_1session_1_1Client__session__impl.html#ac983066e433f143cf02cd730260e6e65" title="In thread W, handler for m_master_channel receiving a init-channel-open message.">on_master_channel_init_open_channel()</a> shall be executed once per requested (by either side) init-channel generated by opposing server.<ul>
<li><a class="el" href="classipc_1_1session_1_1Client__session__impl.html#ac983066e433f143cf02cd730260e6e65" title="In thread W, handler for m_master_channel receiving a init-channel-open message.">on_master_channel_init_open_channel()</a> (the last one) shall move to PEER state in our stead.</li>
</ul>
</li>
</ul>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">log_in_rsp</td><td>The response in-message from <code>struc::Channel</code>. </td></tr>
    <tr><td class="paramname">init_channels_by_cli_req_pre_sized</td><td>See advanced <a class="el" href="classipc_1_1session_1_1Client__session__impl.html#a56c0d2b0ff082d1f7b0738e2528b4a92" title="Core implementation of sync_connect().">async_connect()</a> features. </td></tr>
    <tr><td class="paramname">mdt_from_srv_or_null</td><td>See advanced <a class="el" href="classipc_1_1session_1_1Client__session__impl.html#a56c0d2b0ff082d1f7b0738e2528b4a92" title="Core implementation of sync_connect().">async_connect()</a> features. </td></tr>
    <tr><td class="paramname">init_channels_by_srv_req</td><td>See advanced <a class="el" href="classipc_1_1session_1_1Client__session__impl.html#a56c0d2b0ff082d1f7b0738e2528b4a92" title="Core implementation of sync_connect().">async_connect()</a> features. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="ipc__session_2src_2ipc_2session_2detail_2client__session__impl_8hpp_source.html#l01527">1527</a> of file <a class="el" href="ipc__session_2src_2ipc_2session_2detail_2client__session__impl_8hpp_source.html">client_session_impl.hpp</a>.</p>

<p class="reference">References <a class="el" href="shared__name_8hpp_source.html#l00674">ipc::util::Shared_name::ct()</a>, <a class="el" href="namespaceipc_1_1session_1_1error.html#a0708d4bec9ae853f4d7e3d7822fc8f2fa866090a4d042120126722b4daf1ecc33">ipc::session::error::S_CLIENT_MASTER_LOG_IN_RESPONSE_BAD</a>, <a class="el" href="namespaceipc_1_1session_1_1error.html#a0708d4bec9ae853f4d7e3d7822fc8f2fac416e988563e44bf15fc6a81743eef53">ipc::session::error::S_INVALID_ARGUMENT</a>, and <a class="el" href="shared__name_8hpp_source.html#l00280">ipc::util::Shared_name::S_SENTINEL</a>.</p>
<div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="classipc_1_1session_1_1Client__session__impl_a139fde1cf8dc2c64276b9eb25b35bcee_cgraph.svg" width="386" height="59"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe>
</div>
</div>

</div>
</div>
<a id="a84bcd253bb1cd89fcf94233c2f771142" name="a84bcd253bb1cd89fcf94233c2f771142"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a84bcd253bb1cd89fcf94233c2f771142">&#9670;&nbsp;</a></span>on_master_channel_open_channel_req()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;schema::MqType S_MQ_TYPE_OR_NONE, bool S_TRANSMIT_NATIVE_HANDLES, typename Mdt_payload , schema::ShmType S_SHM_TYPE_OR_NONE, bool S_GRACEFUL_FINISH_REQUIRED_V&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classipc_1_1session_1_1Client__session__impl.html">ipc::session::Client_session_impl</a>&lt; S_MQ_TYPE_OR_NONE, S_TRANSMIT_NATIVE_HANDLES, Mdt_payload, S_SHM_TYPE_OR_NONE, S_GRACEFUL_FINISH_REQUIRED_V &gt;::on_master_channel_open_channel_req </td>
          <td>(</td>
          <td class="paramtype">typename Master_structured_channel::Msg_in_ptr &amp;&amp;&#160;</td>
          <td class="paramname"><em>open_channel_req</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>In thread W, handler for <a class="el" href="classipc_1_1session_1_1Client__session__impl.html#a3acf3432c3806476fc20e951d0790949" title="The session master channel.">m_master_channel</a> receiving a passive-open (a/k/a open-channel-to-client) request. </p>
<p >If there is no issue with this request, and we're able to sync-send the open-channel response to that effect, this shall fire on-passive-open handler, giving it a new <a class="el" href="classipc_1_1session_1_1Client__session__impl.html#a994a2f0b281fdeaeb6c09f6d91df351a" title="See Client_session_mv counterpart.">Channel_obj</a> in PEER state + metadata. If there is a problem, then it's not a session-hosing situation; local user is none-the-wiser; except that if the <code>send()</code> reveals a <em>new</em> error, then it is a session-hosing situation, and local user is informed via on-error handler.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">open_channel_req</td><td>The request in-message from <code>struc::Channel</code>. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="ipc__session_2src_2ipc_2session_2detail_2client__session__impl_8hpp_source.html#l02278">2278</a> of file <a class="el" href="ipc__session_2src_2ipc_2session_2detail_2client__session__impl_8hpp_source.html">client_session_impl.hpp</a>.</p>

<p class="reference">References <a class="el" href="shared__name_8hpp_source.html#l00674">ipc::util::Shared_name::ct()</a>.</p>
<div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="classipc_1_1session_1_1Client__session__impl_a84bcd253bb1cd89fcf94233c2f771142_cgraph.svg" width="399" height="59"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe>
</div>
</div>

</div>
</div>
<a id="a4a377590fbf55b6d312f24d888d2a1bd" name="a4a377590fbf55b6d312f24d888d2a1bd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4a377590fbf55b6d312f24d888d2a1bd">&#9670;&nbsp;</a></span>open_channel() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;schema::MqType S_MQ_TYPE_OR_NONE, bool S_TRANSMIT_NATIVE_HANDLES, typename Mdt_payload , schema::ShmType S_SHM_TYPE_OR_NONE, bool S_GRACEFUL_FINISH_REQUIRED_V&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classipc_1_1session_1_1Client__session__impl.html">ipc::session::Client_session_impl</a>&lt; S_MQ_TYPE_OR_NONE, S_TRANSMIT_NATIVE_HANDLES, Mdt_payload, S_SHM_TYPE_OR_NONE, S_GRACEFUL_FINISH_REQUIRED_V &gt;::open_channel </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classipc_1_1session_1_1Client__session__impl.html#a994a2f0b281fdeaeb6c09f6d91df351a">Channel_obj</a> *&#160;</td>
          <td class="paramname"><em>target_channel</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classipc_1_1session_1_1Client__session__impl.html#a9d93e6080abf3b0827b97e084f5e8356">Mdt_builder_ptr</a> &amp;&#160;</td>
          <td class="paramname"><em>mdt</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceipc.html#aa3192e586cc45d3e7c22463bf2760f89">Error_code</a> *&#160;</td>
          <td class="paramname"><em>err_code</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>See <a class="el" href="classipc_1_1session_1_1Client__session__mv.html" title="Implements Session concept on the Client_app end: a Session_mv that first achieves PEER state by conn...">Client_session_mv</a> counterpart. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">target_channel</td><td>See <a class="el" href="classipc_1_1session_1_1Client__session__mv.html" title="Implements Session concept on the Client_app end: a Session_mv that first achieves PEER state by conn...">Client_session_mv</a> counterpart. </td></tr>
    <tr><td class="paramname">mdt</td><td>See <a class="el" href="classipc_1_1session_1_1Client__session__mv.html" title="Implements Session concept on the Client_app end: a Session_mv that first achieves PEER state by conn...">Client_session_mv</a> counterpart. </td></tr>
    <tr><td class="paramname">err_code</td><td>See <a class="el" href="classipc_1_1session_1_1Client__session__mv.html" title="Implements Session concept on the Client_app end: a Session_mv that first achieves PEER state by conn...">Client_session_mv</a> counterpart. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>See <a class="el" href="classipc_1_1session_1_1Client__session__mv.html" title="Implements Session concept on the Client_app end: a Session_mv that first achieves PEER state by conn...">Client_session_mv</a> counterpart. </dd></dl>

<p class="definition">Definition at line <a class="el" href="ipc__session_2src_2ipc_2session_2detail_2client__session__impl_8hpp_source.html#l02105">2105</a> of file <a class="el" href="ipc__session_2src_2ipc_2session_2detail_2client__session__impl_8hpp_source.html">client_session_impl.hpp</a>.</p>

<p class="reference">References <a class="el" href="shared__name_8hpp_source.html#l00674">ipc::util::Shared_name::ct()</a>, <a class="el" href="ipc__session_2src_2ipc_2session_2detail_2client__session__impl_8hpp_source.html#l02105">ipc::session::Client_session_impl&lt; S_MQ_TYPE_OR_NONE, S_TRANSMIT_NATIVE_HANDLES, Mdt_payload, S_SHM_TYPE_OR_NONE, S_GRACEFUL_FINISH_REQUIRED_V &gt;::open_channel()</a>, <a class="el" href="namespaceipc_1_1session_1_1error.html#a0708d4bec9ae853f4d7e3d7822fc8f2fa7d85b87223a9b277b8875c1f7971d6ad">ipc::session::error::S_SESSION_OPEN_CHANNEL_ACTIVE_TIMEOUT</a>, <a class="el" href="namespaceipc_1_1session_1_1error.html#a0708d4bec9ae853f4d7e3d7822fc8f2fa2c8c27c65ff6234220a84f96de8a1870">ipc::session::error::S_SESSION_OPEN_CHANNEL_REMOTE_PEER_REJECTED_PASSIVE_OPEN</a>, <a class="el" href="namespaceipc_1_1session_1_1error.html#a0708d4bec9ae853f4d7e3d7822fc8f2fa10d32cf1382fb003f09a6df2da408574">ipc::session::error::S_SESSION_OPEN_CHANNEL_SERVER_CANNOT_PROCEED_RESOURCE_UNAVAILABLE</a>, and <a class="el" href="namespaceipc_1_1transport_1_1error.html#adfef15ef4e76cc55d652fbd9c2797297abcfca4c2347f9d377dd2ac41c41dc027">ipc::transport::error::S_TIMEOUT</a>.</p>

<p class="reference">Referenced by <a class="el" href="ipc__session_2src_2ipc_2session_2detail_2client__session__impl_8hpp_source.html#l02105">ipc::session::Client_session_impl&lt; S_MQ_TYPE_OR_NONE, S_TRANSMIT_NATIVE_HANDLES, Mdt_payload, S_SHM_TYPE_OR_NONE, S_GRACEFUL_FINISH_REQUIRED_V &gt;::open_channel()</a>.</p>
<div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="classipc_1_1session_1_1Client__session__impl_a4a377590fbf55b6d312f24d888d2a1bd_cgraph.svg" width="406" height="71"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe>
</div>
</div>
<div class="dynheader">
Here is the caller graph for this function:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="classipc_1_1session_1_1Client__session__impl_a4a377590fbf55b6d312f24d888d2a1bd_icgraph.svg" width="194" height="71"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe>
</div>
</div>

</div>
</div>
<a id="acaca4c5b8e56cf4cd29b5cc886993ded" name="acaca4c5b8e56cf4cd29b5cc886993ded"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acaca4c5b8e56cf4cd29b5cc886993ded">&#9670;&nbsp;</a></span>open_channel() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;schema::MqType S_MQ_TYPE_OR_NONE, bool S_TRANSMIT_NATIVE_HANDLES, typename Mdt_payload , schema::ShmType S_SHM_TYPE_OR_NONE, bool S_GRACEFUL_FINISH_REQUIRED_V&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classipc_1_1session_1_1Client__session__impl.html">ipc::session::Client_session_impl</a>&lt; S_MQ_TYPE_OR_NONE, S_TRANSMIT_NATIVE_HANDLES, Mdt_payload, S_SHM_TYPE_OR_NONE, S_GRACEFUL_FINISH_REQUIRED_V &gt;::open_channel </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classipc_1_1session_1_1Client__session__impl.html#a994a2f0b281fdeaeb6c09f6d91df351a">Channel_obj</a> *&#160;</td>
          <td class="paramname"><em>target_channel</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceipc.html#aa3192e586cc45d3e7c22463bf2760f89">Error_code</a> *&#160;</td>
          <td class="paramname"><em>err_code</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>See <a class="el" href="classipc_1_1session_1_1Client__session__mv.html" title="Implements Session concept on the Client_app end: a Session_mv that first achieves PEER state by conn...">Client_session_mv</a> counterpart. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">target_channel</td><td>See <a class="el" href="classipc_1_1session_1_1Client__session__mv.html" title="Implements Session concept on the Client_app end: a Session_mv that first achieves PEER state by conn...">Client_session_mv</a> counterpart. </td></tr>
    <tr><td class="paramname">err_code</td><td>See <a class="el" href="classipc_1_1session_1_1Client__session__mv.html" title="Implements Session concept on the Client_app end: a Session_mv that first achieves PEER state by conn...">Client_session_mv</a> counterpart. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>See <a class="el" href="classipc_1_1session_1_1Client__session__mv.html" title="Implements Session concept on the Client_app end: a Session_mv that first achieves PEER state by conn...">Client_session_mv</a> counterpart. </dd></dl>

<p class="definition">Definition at line <a class="el" href="ipc__session_2src_2ipc_2session_2detail_2client__session__impl_8hpp_source.html#l02271">2271</a> of file <a class="el" href="ipc__session_2src_2ipc_2session_2detail_2client__session__impl_8hpp_source.html">client_session_impl.hpp</a>.</p>

</div>
</div>
<a id="aad9a5e95ffde170a6483b74f397d9169" name="aad9a5e95ffde170a6483b74f397d9169"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aad9a5e95ffde170a6483b74f397d9169">&#9670;&nbsp;</a></span>session_token()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;schema::MqType S_MQ_TYPE_OR_NONE, bool S_TRANSMIT_NATIVE_HANDLES, typename Mdt_payload , schema::ShmType S_SHM_TYPE_OR_NONE, bool S_GRACEFUL_FINISH_REQUIRED_V&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="namespaceipc_1_1session.html#ade2b302f1a3623e8adc9694568d94d2c">Session_token</a> &amp; <a class="el" href="classipc_1_1session_1_1Client__session__impl.html">ipc::session::Client_session_impl</a>&lt; S_MQ_TYPE_OR_NONE, S_TRANSMIT_NATIVE_HANDLES, Mdt_payload, S_SHM_TYPE_OR_NONE, S_GRACEFUL_FINISH_REQUIRED_V &gt;::session_token</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>See <a class="el" href="classipc_1_1session_1_1Client__session__mv.html" title="Implements Session concept on the Client_app end: a Session_mv that first achieves PEER state by conn...">Client_session_mv</a> counterpart. </p>
<dl class="section return"><dt>Returns</dt><dd>See <a class="el" href="classipc_1_1session_1_1Client__session__mv.html" title="Implements Session concept on the Client_app end: a Session_mv that first achieves PEER state by conn...">Client_session_mv</a> counterpart. </dd></dl>

<p class="definition">Definition at line <a class="el" href="ipc__session_2src_2ipc_2session_2detail_2client__session__impl_8hpp_source.html#l02014">2014</a> of file <a class="el" href="ipc__session_2src_2ipc_2session_2detail_2client__session__impl_8hpp_source.html">client_session_impl.hpp</a>.</p>

<p class="reference">References <a class="el" href="ipc__transport__structured_2src_2ipc_2transport_2struc_2channel_8cpp_source.html#l00035">ipc::transport::struc::NULL_SESSION_TOKEN</a>.</p>

</div>
</div>
<a id="aa60d7f50f9a9bec95c627778f1556be0" name="aa60d7f50f9a9bec95c627778f1556be0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa60d7f50f9a9bec95c627778f1556be0">&#9670;&nbsp;</a></span>sync_connect() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;schema::MqType S_MQ_TYPE_OR_NONE, bool S_TRANSMIT_NATIVE_HANDLES, typename Mdt_payload , schema::ShmType S_SHM_TYPE_OR_NONE, bool S_GRACEFUL_FINISH_REQUIRED_V&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classipc_1_1session_1_1Client__session__impl.html">ipc::session::Client_session_impl</a>&lt; S_MQ_TYPE_OR_NONE, S_TRANSMIT_NATIVE_HANDLES, Mdt_payload, S_SHM_TYPE_OR_NONE, S_GRACEFUL_FINISH_REQUIRED_V &gt;::sync_connect </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classipc_1_1session_1_1Client__session__impl.html#a9d93e6080abf3b0827b97e084f5e8356">Mdt_builder_ptr</a> &amp;&#160;</td>
          <td class="paramname"><em>mdt</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classipc_1_1session_1_1Client__session__impl.html#aab1b23e3370a77db375a50ab156b5662">Channels</a> *&#160;</td>
          <td class="paramname"><em>init_channels_by_cli_req_pre_sized</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classipc_1_1session_1_1Client__session__impl.html#ad0ad69f676fc1260a3c493781fbbb81d">Mdt_reader_ptr</a> *&#160;</td>
          <td class="paramname"><em>mdt_from_srv_or_null</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classipc_1_1session_1_1Client__session__impl.html#aab1b23e3370a77db375a50ab156b5662">Channels</a> *&#160;</td>
          <td class="paramname"><em>init_channels_by_srv_req</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceipc.html#aa3192e586cc45d3e7c22463bf2760f89">Error_code</a> *&#160;</td>
          <td class="paramname"><em>err_code</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>See <a class="el" href="classipc_1_1session_1_1Client__session__mv.html" title="Implements Session concept on the Client_app end: a Session_mv that first achieves PEER state by conn...">Client_session_mv</a> counterpart. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">mdt</td><td>See <a class="el" href="classipc_1_1session_1_1Client__session__mv.html" title="Implements Session concept on the Client_app end: a Session_mv that first achieves PEER state by conn...">Client_session_mv</a> counterpart. </td></tr>
    <tr><td class="paramname">init_channels_by_cli_req_pre_sized</td><td>See <a class="el" href="classipc_1_1session_1_1Client__session__mv.html" title="Implements Session concept on the Client_app end: a Session_mv that first achieves PEER state by conn...">Client_session_mv</a> counterpart. </td></tr>
    <tr><td class="paramname">mdt_from_srv_or_null</td><td>See <a class="el" href="classipc_1_1session_1_1Client__session__mv.html" title="Implements Session concept on the Client_app end: a Session_mv that first achieves PEER state by conn...">Client_session_mv</a> counterpart. </td></tr>
    <tr><td class="paramname">init_channels_by_srv_req</td><td>See <a class="el" href="classipc_1_1session_1_1Client__session__mv.html" title="Implements Session concept on the Client_app end: a Session_mv that first achieves PEER state by conn...">Client_session_mv</a> counterpart. </td></tr>
    <tr><td class="paramname">err_code</td><td>See <a class="el" href="classipc_1_1session_1_1Client__session__mv.html" title="Implements Session concept on the Client_app end: a Session_mv that first achieves PEER state by conn...">Client_session_mv</a> counterpart. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>See <a class="el" href="classipc_1_1session_1_1Client__session__mv.html" title="Implements Session concept on the Client_app end: a Session_mv that first achieves PEER state by conn...">Client_session_mv</a> counterpart. </dd></dl>

<p class="definition">Definition at line <a class="el" href="ipc__session_2src_2ipc_2session_2detail_2client__session__impl_8hpp_source.html#l01068">1068</a> of file <a class="el" href="ipc__session_2src_2ipc_2session_2detail_2client__session__impl_8hpp_source.html">client_session_impl.hpp</a>.</p>

</div>
</div>
<a id="aaf622f5f111ffa95d4ec6c636cfddb4a" name="aaf622f5f111ffa95d4ec6c636cfddb4a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaf622f5f111ffa95d4ec6c636cfddb4a">&#9670;&nbsp;</a></span>sync_connect() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;schema::MqType S_MQ_TYPE_OR_NONE, bool S_TRANSMIT_NATIVE_HANDLES, typename Mdt_payload , schema::ShmType S_SHM_TYPE_OR_NONE, bool S_GRACEFUL_FINISH_REQUIRED_V&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classipc_1_1session_1_1Client__session__impl.html">ipc::session::Client_session_impl</a>&lt; S_MQ_TYPE_OR_NONE, S_TRANSMIT_NATIVE_HANDLES, Mdt_payload, S_SHM_TYPE_OR_NONE, S_GRACEFUL_FINISH_REQUIRED_V &gt;::sync_connect </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespaceipc.html#aa3192e586cc45d3e7c22463bf2760f89">Error_code</a> *&#160;</td>
          <td class="paramname"><em>err_code</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>See <a class="el" href="classipc_1_1session_1_1Client__session__mv.html" title="Implements Session concept on the Client_app end: a Session_mv that first achieves PEER state by conn...">Client_session_mv</a> counterpart. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">err_code</td><td>See <a class="el" href="classipc_1_1session_1_1Client__session__mv.html" title="Implements Session concept on the Client_app end: a Session_mv that first achieves PEER state by conn...">Client_session_mv</a> counterpart. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>See <a class="el" href="classipc_1_1session_1_1Client__session__mv.html" title="Implements Session concept on the Client_app end: a Session_mv that first achieves PEER state by conn...">Client_session_mv</a> counterpart. </dd></dl>

<p class="definition">Definition at line <a class="el" href="ipc__session_2src_2ipc_2session_2detail_2client__session__impl_8hpp_source.html#l01062">1062</a> of file <a class="el" href="ipc__session_2src_2ipc_2session_2detail_2client__session__impl_8hpp_source.html">client_session_impl.hpp</a>.</p>

</div>
</div>
<a id="a1a7560109fa2aa2c16d4f4159918e2c2" name="a1a7560109fa2aa2c16d4f4159918e2c2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1a7560109fa2aa2c16d4f4159918e2c2">&#9670;&nbsp;</a></span>sync_connect_impl()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;schema::MqType S_MQ_TYPE_OR_NONE, bool S_TRANSMIT_NATIVE_HANDLES, typename Mdt_payload , schema::ShmType S_SHM_TYPE_OR_NONE, bool S_GRACEFUL_FINISH_REQUIRED_V&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classipc_1_1session_1_1Client__session__impl.html">ipc::session::Client_session_impl</a>&lt; S_MQ_TYPE_OR_NONE, S_TRANSMIT_NATIVE_HANDLES, Mdt_payload, S_SHM_TYPE_OR_NONE, S_GRACEFUL_FINISH_REQUIRED_V &gt;::sync_connect_impl </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespaceipc.html#aa3192e586cc45d3e7c22463bf2760f89">Error_code</a> *&#160;</td>
          <td class="paramname"><em>err_code</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceipc.html#aa455c7f045059736578ca275fc1a851f">Function</a>&lt; bool(flow::async::Task_asio_err &amp;&amp;)&gt; *&#160;</td>
          <td class="paramname"><em>async_connect_impl_func</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Utility for <code>*this</code> and sub-classes: Implements <a class="el" href="classipc_1_1session_1_1Client__session__impl.html#aaf622f5f111ffa95d4ec6c636cfddb4a" title="See Client_session_mv counterpart.">sync_connect()</a> given a functor that invokes the calling class's (including <a class="el" href="classipc_1_1session_1_1Client__session__impl.html" title="Internal, non-movable pImpl-lite implementation of Client_session_mv class template.">Client_session_impl</a>) <a class="el" href="classipc_1_1session_1_1Client__session__impl.html#a56c0d2b0ff082d1f7b0738e2528b4a92" title="Core implementation of sync_connect().">async_connect()</a> with the args passed to the calling <a class="el" href="classipc_1_1session_1_1Client__session__impl.html#aaf622f5f111ffa95d4ec6c636cfddb4a" title="See Client_session_mv counterpart.">sync_connect()</a>. </p>
<p >This allows sub-classes to reuse our straightforward <code>promise</code>-based implementation of <a class="el" href="classipc_1_1session_1_1Client__session__impl.html#aaf622f5f111ffa95d4ec6c636cfddb4a" title="See Client_session_mv counterpart.">sync_connect()</a> in terms of <a class="el" href="classipc_1_1session_1_1Client__session__impl.html#a56c0d2b0ff082d1f7b0738e2528b4a92" title="Core implementation of sync_connect().">async_connect()</a>. Otherwise they'd need to copy/paste that stuff or something. E.g., see <a class="el" href="classipc_1_1session_1_1shm_1_1classic_1_1Client__session__impl.html" title="Core internally-used implementation of shm::classic::Client_session: it is to the latter what its pub...">shm::classic::Client_session_impl</a> and/or <a class="el" href="classipc_1_1session_1_1shm_1_1arena__lend_1_1jemalloc_1_1Client__session__impl.html" title="Core internally-used implementation of shm::arena_lend::jemalloc::Client_session: it is to the latter...">shm::arena_lend::jemalloc::Client_session_impl</a>. If sub-classes were not an issue, <a class="el" href="classipc_1_1session_1_1Client__session__impl.html#a1a7560109fa2aa2c16d4f4159918e2c2" title="Utility for *this and sub-classes: Implements sync_connect() given a functor that invokes the calling...">sync_connect_impl()</a> would not be needed; we'd just call our <a class="el" href="classipc_1_1session_1_1Client__session__impl.html#a56c0d2b0ff082d1f7b0738e2528b4a92" title="Core implementation of sync_connect().">async_connect()</a> directly.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">err_code</td><td>See <a class="el" href="classipc_1_1session_1_1Client__session__impl.html#aaf622f5f111ffa95d4ec6c636cfddb4a" title="See Client_session_mv counterpart.">sync_connect()</a>. </td></tr>
    <tr><td class="paramname">async_connect_impl_func</td><td>Non-null pointer to a function that (1) calls <code><a class="el" href="classipc_1_1session_1_1Client__session__impl.html#a56c0d2b0ff082d1f7b0738e2528b4a92" title="Core implementation of sync_connect().">async_connect()</a></code>-like method, forwarding to it the args to the calling <code><a class="el" href="classipc_1_1session_1_1Client__session__impl.html#aaf622f5f111ffa95d4ec6c636cfddb4a" title="See Client_session_mv counterpart.">sync_connect()</a></code>-like method, except (2) the last arg is to be a forward of the <code>on_done_func</code>-signature-matching arg to <code>async_connect_impl_func</code>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>See <a class="el" href="classipc_1_1session_1_1Client__session__impl.html#aaf622f5f111ffa95d4ec6c636cfddb4a" title="See Client_session_mv counterpart.">sync_connect()</a>. </dd></dl>

<p class="definition">Definition at line <a class="el" href="ipc__session_2src_2ipc_2session_2detail_2client__session__impl_8hpp_source.html#l01092">1092</a> of file <a class="el" href="ipc__session_2src_2ipc_2session_2detail_2client__session__impl_8hpp_source.html">client_session_impl.hpp</a>.</p>

<p class="reference">References <a class="el" href="ipc__session_2src_2ipc_2session_2detail_2client__session__impl_8hpp_source.html#l01092">ipc::session::Client_session_impl&lt; S_MQ_TYPE_OR_NONE, S_TRANSMIT_NATIVE_HANDLES, Mdt_payload, S_SHM_TYPE_OR_NONE, S_GRACEFUL_FINISH_REQUIRED_V &gt;::sync_connect_impl()</a>.</p>

<p class="reference">Referenced by <a class="el" href="ipc__session_2src_2ipc_2session_2detail_2client__session__impl_8hpp_source.html#l01092">ipc::session::Client_session_impl&lt; S_MQ_TYPE_OR_NONE, S_TRANSMIT_NATIVE_HANDLES, Mdt_payload, S_SHM_TYPE_OR_NONE, S_GRACEFUL_FINISH_REQUIRED_V &gt;::sync_connect_impl()</a>.</p>
<div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="classipc_1_1session_1_1Client__session__impl_a1a7560109fa2aa2c16d4f4159918e2c2_cgraph.svg" width="218" height="71"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe>
</div>
</div>
<div class="dynheader">
Here is the caller graph for this function:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="classipc_1_1session_1_1Client__session__impl_a1a7560109fa2aa2c16d4f4159918e2c2_icgraph.svg" width="218" height="71"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe>
</div>
</div>

</div>
</div>
<h2 class="groupheader">Friends And Related Function Documentation</h2>
<a id="a7c3b6df1a8dab3a2c31b3ad492aa5d8a" name="a7c3b6df1a8dab3a2c31b3ad492aa5d8a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7c3b6df1a8dab3a2c31b3ad492aa5d8a">&#9670;&nbsp;</a></span>operator&lt;&lt;()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;schema::MqType S_MQ_TYPE_OR_NONE, bool S_TRANSMIT_NATIVE_HANDLES, typename Mdt_payload , schema::ShmType S_SHM_TYPE_OR_NONE, bool S_GRACEFUL_FINISH_REQUIRED_V&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::ostream &amp; operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>os</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classipc_1_1session_1_1Client__session__impl.html">Client_session_impl</a>&lt; S_MQ_TYPE_OR_NONE, S_TRANSMIT_NATIVE_HANDLES, Mdt_payload, S_SHM_TYPE_OR_NONE, S_GRACEFUL_FINISH_REQUIRED_V &gt; &amp;&#160;</td>
          <td class="paramname"><em>val</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Prints string representation of the given <code><a class="el" href="classipc_1_1session_1_1Client__session__impl.html" title="Internal, non-movable pImpl-lite implementation of Client_session_mv class template.">Client_session_impl</a></code> to the given <code>ostream</code>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">os</td><td>Stream to which to write. </td></tr>
    <tr><td class="paramname">val</td><td>Object to serialize. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>os</code>. </dd></dl>

<p class="definition">Definition at line <a class="el" href="ipc__session_2src_2ipc_2session_2detail_2client__session__impl_8hpp_source.html#l02595">2595</a> of file <a class="el" href="ipc__session_2src_2ipc_2session_2detail_2client__session__impl_8hpp_source.html">client_session_impl.hpp</a>.</p>

</div>
</div>
<h2 class="groupheader">Member Data Documentation</h2>
<a id="ac3039c565e1da99296dfb71255129201" name="ac3039c565e1da99296dfb71255129201"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac3039c565e1da99296dfb71255129201">&#9670;&nbsp;</a></span>m_async_worker</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;schema::MqType S_MQ_TYPE_OR_NONE, bool S_TRANSMIT_NATIVE_HANDLES, typename Mdt_payload , schema::ShmType S_SHM_TYPE_OR_NONE, bool S_GRACEFUL_FINISH_REQUIRED_V&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">flow::async::Single_thread_task_loop <a class="el" href="classipc_1_1session_1_1Client__session__impl.html">ipc::session::Client_session_impl</a>&lt; S_MQ_TYPE_OR_NONE, S_TRANSMIT_NATIVE_HANDLES, Mdt_payload, S_SHM_TYPE_OR_NONE, S_GRACEFUL_FINISH_REQUIRED_V &gt;::m_async_worker</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">mutable</span><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Worker thread (a/k/a thread W). </p>
<p >Ordering: Should be declared before <a class="el" href="classipc_1_1session_1_1Client__session__impl.html#a3acf3432c3806476fc20e951d0790949" title="The session master channel.">m_master_channel</a>: It should destruct before the <code>Task_engine</code> onto which its queued-up handlers might <code>post()</code> items destructs prematurely.</p>
<h3>Why <code>mutable</code>?</h3>
<p >Well, <a class="el" href="classipc_1_1session_1_1Client__session__impl.html#aad9a5e95ffde170a6483b74f397d9169" title="See Client_session_mv counterpart.">session_token()</a> is <code>const</code> to the user but must <code>.post()</code> which is non-<code>const</code>. This fits the spirit of <code>mutable</code>. I (ygoldfel) think. </p>

<p class="definition">Definition at line <a class="el" href="ipc__session_2src_2ipc_2session_2detail_2client__session__impl_8hpp_source.html#l00853">853</a> of file <a class="el" href="ipc__session_2src_2ipc_2session_2detail_2client__session__impl_8hpp_source.html">client_session_impl.hpp</a>.</p>

<p class="reference">Referenced by <a class="el" href="ipc__session_2src_2ipc_2session_2detail_2client__session__impl_8hpp_source.html#l00901">ipc::session::Client_session_impl&lt; S_MQ_TYPE_OR_NONE, S_TRANSMIT_NATIVE_HANDLES, Mdt_payload, S_SHM_TYPE_OR_NONE, S_GRACEFUL_FINISH_REQUIRED_V &gt;::Client_session_impl()</a>.</p>

</div>
</div>
<a id="addb0e40c34f2ae44ee1252f8123c149c" name="addb0e40c34f2ae44ee1252f8123c149c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#addb0e40c34f2ae44ee1252f8123c149c">&#9670;&nbsp;</a></span>m_conn_on_done_func_or_empty</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;schema::MqType S_MQ_TYPE_OR_NONE, bool S_TRANSMIT_NATIVE_HANDLES, typename Mdt_payload , schema::ShmType S_SHM_TYPE_OR_NONE, bool S_GRACEFUL_FINISH_REQUIRED_V&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">flow::async::Task_asio_err <a class="el" href="classipc_1_1session_1_1Client__session__impl.html">ipc::session::Client_session_impl</a>&lt; S_MQ_TYPE_OR_NONE, S_TRANSMIT_NATIVE_HANDLES, Mdt_payload, S_SHM_TYPE_OR_NONE, S_GRACEFUL_FINISH_REQUIRED_V &gt;::m_conn_on_done_func_or_empty</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>The <code>on_done_func</code> argument to <a class="el" href="classipc_1_1session_1_1Client__session__impl.html#a56c0d2b0ff082d1f7b0738e2528b4a92" title="Core implementation of sync_connect().">async_connect()</a>; <code>.empty()</code> except while in <a class="el" href="classipc_1_1session_1_1Client__session__impl.html#af7a951bd266bdd0e3339a0fbddba9e8baae585d03fce4ac2011967830bf0ffbfb" title="Not a peer but async_connect() in progress to try to make it a peer.">State::S_CONNECTING</a> state. </p>
<p >In other words it is assigned at entry to CONNECTING and <code>.clear()</code>ed at subsequent entry to <a class="el" href="classipc_1_1session_1_1Client__session__impl.html#af7a951bd266bdd0e3339a0fbddba9e8bad9a05d721258c584cd559c56fd035887" title="Is or was a connected peer.">State::S_PEER</a> or <a class="el" href="classipc_1_1session_1_1Client__session__impl.html#af7a951bd266bdd0e3339a0fbddba9e8bac6bd7568063494695099321f427efcb2" title="Not a peer.">State::S_NULL</a> (depending on success/failure of the connect op). </p>

<p class="definition">Definition at line <a class="el" href="ipc__session_2src_2ipc_2session_2detail_2client__session__impl_8hpp_source.html#l00832">832</a> of file <a class="el" href="ipc__session_2src_2ipc_2session_2detail_2client__session__impl_8hpp_source.html">client_session_impl.hpp</a>.</p>

</div>
</div>
<a id="abba4e0890f2d40b0f0cd76ecface739f" name="abba4e0890f2d40b0f0cd76ecface739f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abba4e0890f2d40b0f0cd76ecface739f">&#9670;&nbsp;</a></span>m_graceful_finisher</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;schema::MqType S_MQ_TYPE_OR_NONE, bool S_TRANSMIT_NATIVE_HANDLES, typename Mdt_payload , schema::ShmType S_SHM_TYPE_OR_NONE, bool S_GRACEFUL_FINISH_REQUIRED_V&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::optional&lt;typename <a class="el" href="classipc_1_1session_1_1Session__base_1_1Graceful__finisher.html">Base::Graceful_finisher</a>&gt; <a class="el" href="classipc_1_1session_1_1Client__session__impl.html">ipc::session::Client_session_impl</a>&lt; S_MQ_TYPE_OR_NONE, S_TRANSMIT_NATIVE_HANDLES, Mdt_payload, S_SHM_TYPE_OR_NONE, S_GRACEFUL_FINISH_REQUIRED_V &gt;::m_graceful_finisher</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Null until PEER state is reached, and NULL unless compile-time <a class="el" href="classipc_1_1session_1_1Client__session__impl.html#a65fe6d3d227016858428a170db961cc7" title="Short-hand for template parameter knob S_GRACEFUL_FINISH_REQUIRED_V: see class template doc header.">S_GRACEFUL_FINISH_REQUIRED</a> is <code>true</code>, this is used to block at the start of dtor to synchronize with the opposing <code><a class="el" href="classipc_1_1session_1_1Session.html" title="A documentation-only concept defining the local side of an IPC conversation (session) with another en...">Session</a></code> dtor for safety. </p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classipc_1_1session_1_1Session__base_1_1Graceful__finisher.html" title="Optional to use by subclasses, this operates a simple state machine that carries out a graceful-sessi...">Session_base::Graceful_finisher</a> doc header for all the background ever. </dd></dl>

<p class="definition">Definition at line <a class="el" href="ipc__session_2src_2ipc_2session_2detail_2client__session__impl_8hpp_source.html#l00884">884</a> of file <a class="el" href="ipc__session_2src_2ipc_2session_2detail_2client__session__impl_8hpp_source.html">client_session_impl.hpp</a>.</p>

</div>
</div>
<a id="ade1b57a26147ececddbd0234c0b63be9" name="ade1b57a26147ececddbd0234c0b63be9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ade1b57a26147ececddbd0234c0b63be9">&#9670;&nbsp;</a></span>m_last_actively_opened_channel_id</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;schema::MqType S_MQ_TYPE_OR_NONE, bool S_TRANSMIT_NATIVE_HANDLES, typename Mdt_payload , schema::ShmType S_SHM_TYPE_OR_NONE, bool S_GRACEFUL_FINISH_REQUIRED_V&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">unsigned int <a class="el" href="classipc_1_1session_1_1Client__session__impl.html">ipc::session::Client_session_impl</a>&lt; S_MQ_TYPE_OR_NONE, S_TRANSMIT_NATIVE_HANDLES, Mdt_payload, S_SHM_TYPE_OR_NONE, S_GRACEFUL_FINISH_REQUIRED_V &gt;::m_last_actively_opened_channel_id</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Logging-only <code>*this</code>-unique ID used in nicknaming the last actively-opened (via <a class="el" href="classipc_1_1session_1_1Client__session__impl.html#a4a377590fbf55b6d312f24d888d2a1bd" title="See Client_session_mv counterpart.">open_channel()</a>) channel. </p>
<p >It is incremented each time. Accessed in thread W only (not protected by mutex). </p>

<p class="definition">Definition at line <a class="el" href="ipc__session_2src_2ipc_2session_2detail_2client__session__impl_8hpp_source.html#l00838">838</a> of file <a class="el" href="ipc__session_2src_2ipc_2session_2detail_2client__session__impl_8hpp_source.html">client_session_impl.hpp</a>.</p>

</div>
</div>
<a id="a89d1ce46faa61df455b6f186eb892711" name="a89d1ce46faa61df455b6f186eb892711"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a89d1ce46faa61df455b6f186eb892711">&#9670;&nbsp;</a></span>m_last_passively_opened_channel_id</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;schema::MqType S_MQ_TYPE_OR_NONE, bool S_TRANSMIT_NATIVE_HANDLES, typename Mdt_payload , schema::ShmType S_SHM_TYPE_OR_NONE, bool S_GRACEFUL_FINISH_REQUIRED_V&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">unsigned int <a class="el" href="classipc_1_1session_1_1Client__session__impl.html">ipc::session::Client_session_impl</a>&lt; S_MQ_TYPE_OR_NONE, S_TRANSMIT_NATIVE_HANDLES, Mdt_payload, S_SHM_TYPE_OR_NONE, S_GRACEFUL_FINISH_REQUIRED_V &gt;::m_last_passively_opened_channel_id</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>A-la <a class="el" href="classipc_1_1session_1_1Client__session__impl.html#ade1b57a26147ececddbd0234c0b63be9" title="Logging-only *this-unique ID used in nicknaming the last actively-opened (via open_channel()) channel...">m_last_actively_opened_channel_id</a> but for passively-opened channels (<a class="el" href="classipc_1_1session_1_1Client__session__impl.html#a84bcd253bb1cd89fcf94233c2f771142" title="In thread W, handler for m_master_channel receiving a passive-open (a/k/a open-channel-to-client) req...">on_master_channel_open_channel_req()</a>). </p>

<p class="definition">Definition at line <a class="el" href="ipc__session_2src_2ipc_2session_2detail_2client__session__impl_8hpp_source.html#l00841">841</a> of file <a class="el" href="ipc__session_2src_2ipc_2session_2detail_2client__session__impl_8hpp_source.html">client_session_impl.hpp</a>.</p>

</div>
</div>
<a id="a3acf3432c3806476fc20e951d0790949" name="a3acf3432c3806476fc20e951d0790949"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3acf3432c3806476fc20e951d0790949">&#9670;&nbsp;</a></span>m_master_channel</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;schema::MqType S_MQ_TYPE_OR_NONE, bool S_TRANSMIT_NATIVE_HANDLES, typename Mdt_payload , schema::ShmType S_SHM_TYPE_OR_NONE, bool S_GRACEFUL_FINISH_REQUIRED_V&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classipc_1_1session_1_1Client__session__impl.html#ad432ab4e95ddcfd0396d5ea821dec15c">Master_structured_channel_ptr</a> <a class="el" href="classipc_1_1session_1_1Client__session__impl.html">ipc::session::Client_session_impl</a>&lt; S_MQ_TYPE_OR_NONE, S_TRANSMIT_NATIVE_HANDLES, Mdt_payload, S_SHM_TYPE_OR_NONE, S_GRACEFUL_FINISH_REQUIRED_V &gt;::m_master_channel</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>The session master channel. </p>
<p >Accessed in thread W only (not protected by mutex).</p><ul>
<li>When <a class="el" href="classipc_1_1session_1_1Client__session__impl.html#a3a5f5102020adace1e898d977e929908" title="The current state of *this.">m_state</a> is NULL, this is null.</li>
<li>When <a class="el" href="classipc_1_1session_1_1Client__session__impl.html#a3a5f5102020adace1e898d977e929908" title="The current state of *this.">m_state</a> is CONNECTING:<ul>
<li>It is still null until <a class="el" href="classipc_1_1transport_1_1Native__socket__stream.html#a89d591db714e83dcb55a52738fed1ebb" title="To be invoked in NULL state only, it synchronously and non-blockingly attempts to connect to an oppos...">transport::Native_socket_stream::sync_connect()</a> yields a PEER-state socket. (This occurs, if it does occur, within a non-blocking time period upon entry to <a class="el" href="classipc_1_1session_1_1Client__session__impl.html#a56c0d2b0ff082d1f7b0738e2528b4a92" title="Core implementation of sync_connect().">async_connect()</a>.)</li>
<li>It is not null from that point on &ndash; including through entry to PEER &ndash; but it <em>does</em> go back to null if log-in procedure fails putting <code>m_state = <a class="el" href="classipc_1_1session_1_1Client__session__impl.html#af7a951bd266bdd0e3339a0fbddba9e8bac6bd7568063494695099321f427efcb2" title="Not a peer.">State::S_NULL</a></code> again.</li>
</ul>
</li>
<li>When <a class="el" href="classipc_1_1session_1_1Client__session__impl.html#a3a5f5102020adace1e898d977e929908" title="The current state of *this.">m_state</a> is PEER: It remains non-null and immutable until dtor.</li>
</ul>
<h3>Rationale for above invariant</h3>
<p >Generally it is a pain in the butt to deal with a <code>struc::Channel</code> being destroyed, as it has non-boost.asio-style handler semantics wherein one must be ready for a handler for channel C to fire in our thread W, even after we destroy C in a preceding thread W task. So, here as in other classes, we aim to keep it non-null and immutable once it's been constructed. (E.g., that's the case in <a class="el" href="classipc_1_1session_1_1Server__session__impl.html" title="Internal, non-movable pImpl-lite implementation of Server_session_mv class template.">Server_session_impl</a>.) However, since we allow <a class="el" href="classipc_1_1session_1_1Client__session__impl.html#a56c0d2b0ff082d1f7b0738e2528b4a92" title="Core implementation of sync_connect().">async_connect()</a> to be retried on failure, we do need to get back to a coherent state when <a class="el" href="classipc_1_1session_1_1Client__session__impl.html#a3a5f5102020adace1e898d977e929908" title="The current state of *this.">m_state</a> is NULL. So in that case only, it is renullified.</p>
<p >Because it is renullified, there's the "observer" thing used in <a class="el" href="classipc_1_1session_1_1Client__session__impl.html#a417e9c40eefdfb4622f84275795640c4" title="In thread W, handler for m_master_channel indicating incoming-direction channel-hosing error.">on_master_channel_error()</a> to deal with it. It's a fairly small section of code though. </p>

<p class="definition">Definition at line <a class="el" href="ipc__session_2src_2ipc_2session_2detail_2client__session__impl_8hpp_source.html#l00876">876</a> of file <a class="el" href="ipc__session_2src_2ipc_2session_2detail_2client__session__impl_8hpp_source.html">client_session_impl.hpp</a>.</p>

</div>
</div>
<a id="ab55fdca2097f5444f35efc97a8af326b" name="ab55fdca2097f5444f35efc97a8af326b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab55fdca2097f5444f35efc97a8af326b">&#9670;&nbsp;</a></span>m_protocol_negotiator</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;schema::MqType S_MQ_TYPE_OR_NONE, bool S_TRANSMIT_NATIVE_HANDLES, typename Mdt_payload , schema::ShmType S_SHM_TYPE_OR_NONE, bool S_GRACEFUL_FINISH_REQUIRED_V&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classipc_1_1transport_1_1Protocol__negotiator.html">transport::Protocol_negotiator</a> <a class="el" href="classipc_1_1session_1_1Client__session__impl.html">ipc::session::Client_session_impl</a>&lt; S_MQ_TYPE_OR_NONE, S_TRANSMIT_NATIVE_HANDLES, Mdt_payload, S_SHM_TYPE_OR_NONE, S_GRACEFUL_FINISH_REQUIRED_V &gt;::m_protocol_negotiator</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Handles the protocol negotiation at the start of the pipe, as pertains to algorithms perpetuated by the vanilla <a class="el" href="namespaceipc_1_1session.html" title="Flow-IPC module providing the broad lifecycle and shared-resource organization  via the session conc...">ipc::session</a> <code><a class="el" href="classipc_1_1session_1_1Session.html" title="A documentation-only concept defining the local side of an IPC conversation (session) with another en...">Session</a></code> hierarchy. </p>
<p >Reset essentially at start of each <a class="el" href="classipc_1_1session_1_1Client__session__impl.html#a56c0d2b0ff082d1f7b0738e2528b4a92" title="Core implementation of sync_connect().">async_connect()</a>.</p>
<p >Outgoing-direction state is touched when assembling <code>LogInReq</code> to send to opposing <code>Server_session</code>. Incoming-direction state is touched/verified at the start of interpreting <code>LogInRsp</code> receiver from there.</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classipc_1_1transport_1_1Protocol__negotiator.html" title="A simple state machine that, assuming the opposide side of a comm pathway uses an equivalent state ma...">transport::Protocol_negotiator</a> doc header for key background on the topic. </dd></dl>

<p class="definition">Definition at line <a class="el" href="ipc__session_2src_2ipc_2session_2detail_2client__session__impl_8hpp_source.html#l00815">815</a> of file <a class="el" href="ipc__session_2src_2ipc_2session_2detail_2client__session__impl_8hpp_source.html">client_session_impl.hpp</a>.</p>

</div>
</div>
<a id="a3c53046a113fcf1ba4c857e8d4c2fbbd" name="a3c53046a113fcf1ba4c857e8d4c2fbbd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3c53046a113fcf1ba4c857e8d4c2fbbd">&#9670;&nbsp;</a></span>m_protocol_negotiator_aux</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;schema::MqType S_MQ_TYPE_OR_NONE, bool S_TRANSMIT_NATIVE_HANDLES, typename Mdt_payload , schema::ShmType S_SHM_TYPE_OR_NONE, bool S_GRACEFUL_FINISH_REQUIRED_V&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classipc_1_1transport_1_1Protocol__negotiator.html">transport::Protocol_negotiator</a> <a class="el" href="classipc_1_1session_1_1Client__session__impl.html">ipc::session::Client_session_impl</a>&lt; S_MQ_TYPE_OR_NONE, S_TRANSMIT_NATIVE_HANDLES, Mdt_payload, S_SHM_TYPE_OR_NONE, S_GRACEFUL_FINISH_REQUIRED_V &gt;::m_protocol_negotiator_aux</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Analogous to <a class="el" href="classipc_1_1session_1_1Client__session__impl.html#ab55fdca2097f5444f35efc97a8af326b" title="Handles the protocol negotiation at the start of the pipe, as pertains to algorithms perpetuated by t...">m_protocol_negotiator</a> but pertains to algorithms perpetuated by (if relevant) non-vanilla <a class="el" href="namespaceipc_1_1session.html" title="Flow-IPC module providing the broad lifecycle and shared-resource organization  via the session conc...">ipc::session</a> <code><a class="el" href="classipc_1_1session_1_1Session.html" title="A documentation-only concept defining the local side of an IPC conversation (session) with another en...">Session</a></code> hierarchy implemented on top of our vanilla <a class="el" href="namespaceipc_1_1session.html" title="Flow-IPC module providing the broad lifecycle and shared-resource organization  via the session conc...">ipc::session</a> <code><a class="el" href="classipc_1_1session_1_1Session.html" title="A documentation-only concept defining the local side of an IPC conversation (session) with another en...">Session</a></code> hierarchy. </p>
<p >For example, <a class="el" href="namespaceipc_1_1session_1_1shm.html" title="ipc::session sub-namespace that groups together facilities for SHM-backed sessions,...">ipc::session::shm</a> hierarchies can use this to version whatever additional protocol is required to establish SHM things.</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classipc_1_1transport_1_1Protocol__negotiator.html" title="A simple state machine that, assuming the opposide side of a comm pathway uses an equivalent state ma...">transport::Protocol_negotiator</a> doc header for key background on the topic. </dd></dl>

<p class="definition">Definition at line <a class="el" href="ipc__session_2src_2ipc_2session_2detail_2client__session__impl_8hpp_source.html#l00825">825</a> of file <a class="el" href="ipc__session_2src_2ipc_2session_2detail_2client__session__impl_8hpp_source.html">client_session_impl.hpp</a>.</p>

</div>
</div>
<a id="a3a5f5102020adace1e898d977e929908" name="a3a5f5102020adace1e898d977e929908"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3a5f5102020adace1e898d977e929908">&#9670;&nbsp;</a></span>m_state</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;schema::MqType S_MQ_TYPE_OR_NONE, bool S_TRANSMIT_NATIVE_HANDLES, typename Mdt_payload , schema::ShmType S_SHM_TYPE_OR_NONE, bool S_GRACEFUL_FINISH_REQUIRED_V&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classipc_1_1session_1_1Client__session__impl.html#af7a951bd266bdd0e3339a0fbddba9e8b">State</a> <a class="el" href="classipc_1_1session_1_1Client__session__impl.html">ipc::session::Client_session_impl</a>&lt; S_MQ_TYPE_OR_NONE, S_TRANSMIT_NATIVE_HANDLES, Mdt_payload, S_SHM_TYPE_OR_NONE, S_GRACEFUL_FINISH_REQUIRED_V &gt;::m_state</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>The current state of <code>*this</code>. </p>
<p >Accessed in thread W only (not protected by mutex).</p>
<dl class="section note"><dt>Note</dt><dd>I (ygoldfel) considered just relying on Native_socket_stream itself to just return <code>false</code>, and then we'd forward to its state detection. It would've been nice, but ultimately it just seemed a bit too sloppy and hard to reason about... I ~duplicated this here instead. </dd></dl>

<p class="definition">Definition at line <a class="el" href="ipc__session_2src_2ipc_2session_2detail_2client__session__impl_8hpp_source.html#l00804">804</a> of file <a class="el" href="ipc__session_2src_2ipc_2session_2detail_2client__session__impl_8hpp_source.html">client_session_impl.hpp</a>.</p>

</div>
</div>
<a id="a65fe6d3d227016858428a170db961cc7" name="a65fe6d3d227016858428a170db961cc7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a65fe6d3d227016858428a170db961cc7">&#9670;&nbsp;</a></span>S_GRACEFUL_FINISH_REQUIRED</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;schema::MqType S_MQ_TYPE_OR_NONE, bool S_TRANSMIT_NATIVE_HANDLES, typename Mdt_payload , schema::ShmType S_SHM_TYPE_OR_NONE, bool S_GRACEFUL_FINISH_REQUIRED_V&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr bool <a class="el" href="classipc_1_1session_1_1Client__session__impl.html">ipc::session::Client_session_impl</a>&lt; S_MQ_TYPE_OR_NONE, S_TRANSMIT_NATIVE_HANDLES, Mdt_payload, S_SHM_TYPE_OR_NONE, S_GRACEFUL_FINISH_REQUIRED_V &gt;::S_GRACEFUL_FINISH_REQUIRED = S_GRACEFUL_FINISH_REQUIRED_V</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Short-hand for template parameter knob <code>S_GRACEFUL_FINISH_REQUIRED_V</code>: see class template doc header. </p>

<p class="definition">Definition at line <a class="el" href="ipc__session_2src_2ipc_2session_2detail_2client__session__impl_8hpp_source.html#l00272">272</a> of file <a class="el" href="ipc__session_2src_2ipc_2session_2detail_2client__session__impl_8hpp_source.html">client_session_impl.hpp</a>.</p>

</div>
</div>
<a id="a4036fbd01410a9befc7c541368d92704" name="a4036fbd01410a9befc7c541368d92704"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4036fbd01410a9befc7c541368d92704">&#9670;&nbsp;</a></span>S_MQS_ENABLED</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;schema::MqType S_MQ_TYPE_OR_NONE, bool S_TRANSMIT_NATIVE_HANDLES, typename Mdt_payload , schema::ShmType S_SHM_TYPE_OR_NONE, bool S_GRACEFUL_FINISH_REQUIRED_V&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr bool <a class="el" href="classipc_1_1session_1_1Client__session__impl.html">ipc::session::Client_session_impl</a>&lt; S_MQ_TYPE_OR_NONE, S_TRANSMIT_NATIVE_HANDLES, Mdt_payload, S_SHM_TYPE_OR_NONE, S_GRACEFUL_FINISH_REQUIRED_V &gt;::S_MQS_ENABLED = Base::S_MQS_ENABLED</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>See <a class="el" href="classipc_1_1session_1_1Client__session__mv.html" title="Implements Session concept on the Client_app end: a Session_mv that first achieves PEER state by conn...">Client_session_mv</a> counterpart. </p>

<p class="definition">Definition at line <a class="el" href="ipc__session_2src_2ipc_2session_2detail_2client__session__impl_8hpp_source.html#l00266">266</a> of file <a class="el" href="ipc__session_2src_2ipc_2session_2detail_2client__session__impl_8hpp_source.html">client_session_impl.hpp</a>.</p>

</div>
</div>
<a id="a20f1ea81df379ff8153ba14f56b7f035" name="a20f1ea81df379ff8153ba14f56b7f035"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a20f1ea81df379ff8153ba14f56b7f035">&#9670;&nbsp;</a></span>S_SHM_ENABLED</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;schema::MqType S_MQ_TYPE_OR_NONE, bool S_TRANSMIT_NATIVE_HANDLES, typename Mdt_payload , schema::ShmType S_SHM_TYPE_OR_NONE, bool S_GRACEFUL_FINISH_REQUIRED_V&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr bool <a class="el" href="classipc_1_1session_1_1Client__session__impl.html">ipc::session::Client_session_impl</a>&lt; S_MQ_TYPE_OR_NONE, S_TRANSMIT_NATIVE_HANDLES, Mdt_payload, S_SHM_TYPE_OR_NONE, S_GRACEFUL_FINISH_REQUIRED_V &gt;::S_SHM_ENABLED = <a class="el" href="classipc_1_1session_1_1Client__session__impl.html#a1b34618ce1160871a4b16f4ecc3e86e6">S_SHM_TYPE</a> != schema::ShmType::NONE</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>See <a class="el" href="classipc_1_1session_1_1Session__mv.html" title="Implements the Session concept when it is in PEER state.">Session_mv</a> counterpart. </p>

<p class="definition">Definition at line <a class="el" href="ipc__session_2src_2ipc_2session_2detail_2client__session__impl_8hpp_source.html#l00263">263</a> of file <a class="el" href="ipc__session_2src_2ipc_2session_2detail_2client__session__impl_8hpp_source.html">client_session_impl.hpp</a>.</p>

</div>
</div>
<a id="a1b34618ce1160871a4b16f4ecc3e86e6" name="a1b34618ce1160871a4b16f4ecc3e86e6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1b34618ce1160871a4b16f4ecc3e86e6">&#9670;&nbsp;</a></span>S_SHM_TYPE</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;schema::MqType S_MQ_TYPE_OR_NONE, bool S_TRANSMIT_NATIVE_HANDLES, typename Mdt_payload , schema::ShmType S_SHM_TYPE_OR_NONE, bool S_GRACEFUL_FINISH_REQUIRED_V&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr schema::ShmType <a class="el" href="classipc_1_1session_1_1Client__session__impl.html">ipc::session::Client_session_impl</a>&lt; S_MQ_TYPE_OR_NONE, S_TRANSMIT_NATIVE_HANDLES, Mdt_payload, S_SHM_TYPE_OR_NONE, S_GRACEFUL_FINISH_REQUIRED_V &gt;::S_SHM_TYPE = S_SHM_TYPE_OR_NONE</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>See <a class="el" href="classipc_1_1session_1_1Session__mv.html" title="Implements the Session concept when it is in PEER state.">Session_mv</a> counterpart. </p>

<p class="definition">Definition at line <a class="el" href="ipc__session_2src_2ipc_2session_2detail_2client__session__impl_8hpp_source.html#l00260">260</a> of file <a class="el" href="ipc__session_2src_2ipc_2session_2detail_2client__session__impl_8hpp_source.html">client_session_impl.hpp</a>.</p>

</div>
</div>
<a id="ac28652995339005a7afeb467b33b3b62" name="ac28652995339005a7afeb467b33b3b62"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac28652995339005a7afeb467b33b3b62">&#9670;&nbsp;</a></span>S_SOCKET_STREAM_ENABLED</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;schema::MqType S_MQ_TYPE_OR_NONE, bool S_TRANSMIT_NATIVE_HANDLES, typename Mdt_payload , schema::ShmType S_SHM_TYPE_OR_NONE, bool S_GRACEFUL_FINISH_REQUIRED_V&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr bool <a class="el" href="classipc_1_1session_1_1Client__session__impl.html">ipc::session::Client_session_impl</a>&lt; S_MQ_TYPE_OR_NONE, S_TRANSMIT_NATIVE_HANDLES, Mdt_payload, S_SHM_TYPE_OR_NONE, S_GRACEFUL_FINISH_REQUIRED_V &gt;::S_SOCKET_STREAM_ENABLED = Base::S_SOCKET_STREAM_ENABLED</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>See <a class="el" href="classipc_1_1session_1_1Client__session__mv.html" title="Implements Session concept on the Client_app end: a Session_mv that first achieves PEER state by conn...">Client_session_mv</a> counterpart. </p>

<p class="definition">Definition at line <a class="el" href="ipc__session_2src_2ipc_2session_2detail_2client__session__impl_8hpp_source.html#l00269">269</a> of file <a class="el" href="ipc__session_2src_2ipc_2session_2detail_2client__session__impl_8hpp_source.html">client_session_impl.hpp</a>.</p>

</div>
</div>
<hr/>The documentation for this class was generated from the following files:<ul>
<li>session/detail/<a class="el" href="ipc__session_2src_2ipc_2session_2detail_2client__session__impl_8hpp_source.html">client_session_impl.hpp</a></li>
<li>session/detail/<a class="el" href="detail_2session__fwd_8hpp_source.html">session_fwd.hpp</a></li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Thu May 2 2024 23:56:39 for Flow-IPC by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.4
</small></address>
</body>
</html>
