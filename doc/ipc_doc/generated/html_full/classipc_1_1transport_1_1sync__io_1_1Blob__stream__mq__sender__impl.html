<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.9.4"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Flow-IPC: ipc::transport::sync_io::Blob_stream_mq_sender_impl&lt; Persistent_mq_handle &gt; Class Template Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">Flow-IPC<span id="projectnumber">&#160;2.0.0</span>
   </div>
   <div id="projectbrief">Flow-IPC project: Full implementation reference.</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.4 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search",'Search','.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespaceipc.html">ipc</a></li><li class="navelem"><a class="el" href="namespaceipc_1_1transport.html">transport</a></li><li class="navelem"><a class="el" href="namespaceipc_1_1transport_1_1sync__io.html">sync_io</a></li><li class="navelem"><a class="el" href="classipc_1_1transport_1_1sync__io_1_1Blob__stream__mq__sender__impl.html">Blob_stream_mq_sender_impl</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#pub-types">Public Types</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pri-types">Private Types</a> &#124;
<a href="#pri-methods">Private Member Functions</a> &#124;
<a href="#pri-attribs">Private Attributes</a> &#124;
<a href="#related">Related Functions</a> &#124;
<a href="classipc_1_1transport_1_1sync__io_1_1Blob__stream__mq__sender__impl-members.html">List of all members</a>  </div>
  <div class="headertitle"><div class="title">ipc::transport::sync_io::Blob_stream_mq_sender_impl&lt; Persistent_mq_handle &gt; Class Template Reference</div></div>
</div><!--header-->
<div class="contents">

<p>Internal, non-movable pImpl-lite implementation of <a class="el" href="classipc_1_1transport_1_1sync__io_1_1Blob__stream__mq__sender.html" title="Implements sync_io::Blob_sender concept by using an adopted Persistent_mq_handle MQ handle to an MQ (...">sync_io::Blob_stream_mq_sender</a> class template.  
 <a href="classipc_1_1transport_1_1sync__io_1_1Blob__stream__mq__sender__impl.html#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="sync__io_2detail_2blob__stream__mq__snd__impl_8hpp_source.html">blob_stream_mq_snd_impl.hpp</a>&gt;</code></p>
<div class="dynheader">
Inheritance diagram for ipc::transport::sync_io::Blob_stream_mq_sender_impl&lt; Persistent_mq_handle &gt;:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="classipc_1_1transport_1_1sync__io_1_1Blob__stream__mq__sender__impl__inherit__graph.svg" width="418" height="155"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe>
</div>
<center><span class="legend">[<a href="graph_legend.html">legend</a>]</span></center></div>
<div class="dynheader">
Collaboration diagram for ipc::transport::sync_io::Blob_stream_mq_sender_impl&lt; Persistent_mq_handle &gt;:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="classipc_1_1transport_1_1sync__io_1_1Blob__stream__mq__sender__impl__coll__graph.svg" width="1226" height="1646"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe>
</div>
<center><span class="legend">[<a href="graph_legend.html">legend</a>]</span></center></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="nested-classes" name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structipc_1_1transport_1_1sync__io_1_1Blob__stream__mq__sender__impl_1_1Snd__low__lvl__payload.html">Snd_low_lvl_payload</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Data store representing a payload corresponding to exactly one attempted async write-op, albeit used if and only if we encounter would-block in <code><a class="el" href="classipc_1_1transport_1_1sync__io_1_1Blob__stream__mq__sender__impl.html#aba05c51d1033a4ea4ca03679f2fa1f8c" title="See Blob_stream_mq_sender counterpart, but assuming PEER state.">send_blob()</a></code> or <a class="el" href="classipc_1_1transport_1_1sync__io_1_1Blob__stream__mq__sender__impl.html#ad84b0f43cd4d1329c8bac6ea1376d3ca" title="Handler for the async-wait, via util::sync_io::Timer_event_emitter, of the auto-ping timer firing; if...">on_ev_auto_ping_now_timer_fired()</a> or <code>*end_sending()</code> and have to queue (and therefore one-time-copy) data in <a class="el" href="classipc_1_1transport_1_1sync__io_1_1Blob__stream__mq__sender__impl.html#aaecb4615ae4d9fbf82ab2c195ada47cf" title="Queue storing (at head) the currently in-progress async write-op of a Snd_low_lvl_payload; followed b...">m_pending_payloads_q</a>.  <a href="structipc_1_1transport_1_1sync__io_1_1Blob__stream__mq__sender__impl_1_1Snd__low__lvl__payload.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-types" name="pub-types"></a>
Public Types</h2></td></tr>
<tr class="memitem:a5a36bff3c8346f952b154e081817f53c"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classipc_1_1transport_1_1sync__io_1_1Blob__stream__mq__sender__impl.html#a5a36bff3c8346f952b154e081817f53c">Base</a> = <a class="el" href="classipc_1_1transport_1_1Blob__stream__mq__base__impl.html">Blob_stream_mq_base_impl</a>&lt; <a class="el" href="classipc_1_1transport_1_1Persistent__mq__handle.html">Persistent_mq_handle</a> &gt;</td></tr>
<tr class="memdesc:a5a36bff3c8346f952b154e081817f53c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Short-hand for our base with <code>static</code> goodies at least.  <a href="classipc_1_1transport_1_1sync__io_1_1Blob__stream__mq__sender__impl.html#a5a36bff3c8346f952b154e081817f53c">More...</a><br /></td></tr>
<tr class="separator:a5a36bff3c8346f952b154e081817f53c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0e32cf8f7e9d6040925bcaf9da36515b"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classipc_1_1transport_1_1sync__io_1_1Blob__stream__mq__sender__impl.html#a0e32cf8f7e9d6040925bcaf9da36515b">Mq</a> = typename <a class="el" href="classipc_1_1transport_1_1Blob__stream__mq__base__impl.html#a8fac0ed5fff23aa42e0a601db6fee42d">Base::Mq</a></td></tr>
<tr class="memdesc:a0e32cf8f7e9d6040925bcaf9da36515b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Short-hand for template arg for underlying MQ handle type.  <a href="classipc_1_1transport_1_1sync__io_1_1Blob__stream__mq__sender__impl.html#a0e32cf8f7e9d6040925bcaf9da36515b">More...</a><br /></td></tr>
<tr class="separator:a0e32cf8f7e9d6040925bcaf9da36515b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pub_types_classipc_1_1transport_1_1Blob__stream__mq__base__impl"><td colspan="2" onclick="javascript:toggleInherit('pub_types_classipc_1_1transport_1_1Blob__stream__mq__base__impl')"><img src="closed.png" alt="-"/>&#160;Public Types inherited from <a class="el" href="classipc_1_1transport_1_1Blob__stream__mq__base__impl.html">ipc::transport::Blob_stream_mq_base_impl&lt; Persistent_mq_handle &gt;</a></td></tr>
<tr class="memitem:a8fac0ed5fff23aa42e0a601db6fee42d inherit pub_types_classipc_1_1transport_1_1Blob__stream__mq__base__impl"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classipc_1_1transport_1_1Blob__stream__mq__base__impl.html#a8fac0ed5fff23aa42e0a601db6fee42d">Mq</a> = <a class="el" href="classipc_1_1transport_1_1Persistent__mq__handle.html">Persistent_mq_handle</a></td></tr>
<tr class="memdesc:a8fac0ed5fff23aa42e0a601db6fee42d inherit pub_types_classipc_1_1transport_1_1Blob__stream__mq__base__impl"><td class="mdescLeft">&#160;</td><td class="mdescRight">Short-hand for template arg for underlying MQ handle type.  <a href="classipc_1_1transport_1_1Blob__stream__mq__base__impl.html#a8fac0ed5fff23aa42e0a601db6fee42d">More...</a><br /></td></tr>
<tr class="separator:a8fac0ed5fff23aa42e0a601db6fee42d inherit pub_types_classipc_1_1transport_1_1Blob__stream__mq__base__impl"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aab7c4c91d42c746c93e61eb367572eb1 inherit pub_types_classipc_1_1transport_1_1Blob__stream__mq__base__impl"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classipc_1_1transport_1_1Blob__stream__mq__base__impl.html#aab7c4c91d42c746c93e61eb367572eb1">Auto_closing_mq</a> = boost::movelib::unique_ptr&lt; <a class="el" href="classipc_1_1transport_1_1Blob__stream__mq__base__impl.html#a8fac0ed5fff23aa42e0a601db6fee42d">Mq</a>, <a class="el" href="namespaceipc.html#aa455c7f045059736578ca275fc1a851f">Function</a>&lt; void(<a class="el" href="classipc_1_1transport_1_1Blob__stream__mq__base__impl.html#a8fac0ed5fff23aa42e0a601db6fee42d">Mq</a> *)&gt; &gt;</td></tr>
<tr class="memdesc:aab7c4c91d42c746c93e61eb367572eb1 inherit pub_types_classipc_1_1transport_1_1Blob__stream__mq__base__impl"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classipc_1_1transport_1_1Persistent__mq__handle.html" title="A documentation-only concept defining the behavior of an object representing a light-weight handle to...">Persistent_mq_handle</a> holder that takes a deleter lambda on construction, intended here to perform additional deinit steps in addition to closing the <a class="el" href="classipc_1_1transport_1_1Blob__stream__mq__base__impl.html#a8fac0ed5fff23aa42e0a601db6fee42d" title="Short-hand for template arg for underlying MQ handle type.">Mq</a> by deleting it.  <a href="classipc_1_1transport_1_1Blob__stream__mq__base__impl.html#aab7c4c91d42c746c93e61eb367572eb1">More...</a><br /></td></tr>
<tr class="separator:aab7c4c91d42c746c93e61eb367572eb1 inherit pub_types_classipc_1_1transport_1_1Blob__stream__mq__base__impl"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-methods" name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a71caa7f5002886b2c0717645945d7144"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classipc_1_1transport_1_1sync__io_1_1Blob__stream__mq__sender__impl.html#a71caa7f5002886b2c0717645945d7144">Blob_stream_mq_sender_impl</a> (flow::log::Logger *logger_ptr, <a class="el" href="namespaceipc_1_1util.html#ae6ac47812a90d1287c61e0b7de7bc4f5">util::String_view</a> nickname_str, <a class="el" href="classipc_1_1transport_1_1Blob__stream__mq__base__impl.html#a8fac0ed5fff23aa42e0a601db6fee42d">Mq</a> &amp;&amp;mq_moved, <a class="el" href="namespaceipc.html#aa3192e586cc45d3e7c22463bf2760f89">Error_code</a> *err_code)</td></tr>
<tr class="memdesc:a71caa7f5002886b2c0717645945d7144"><td class="mdescLeft">&#160;</td><td class="mdescRight">See <a class="el" href="classipc_1_1transport_1_1sync__io_1_1Blob__stream__mq__sender.html" title="Implements sync_io::Blob_sender concept by using an adopted Persistent_mq_handle MQ handle to an MQ (...">Blob_stream_mq_sender</a> counterpart.  <a href="classipc_1_1transport_1_1sync__io_1_1Blob__stream__mq__sender__impl.html#a71caa7f5002886b2c0717645945d7144">More...</a><br /></td></tr>
<tr class="separator:a71caa7f5002886b2c0717645945d7144"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afe0b25b57614615d0672c40cf8f58170"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classipc_1_1transport_1_1sync__io_1_1Blob__stream__mq__sender__impl.html#afe0b25b57614615d0672c40cf8f58170">~Blob_stream_mq_sender_impl</a> ()</td></tr>
<tr class="memdesc:afe0b25b57614615d0672c40cf8f58170"><td class="mdescLeft">&#160;</td><td class="mdescRight">See <a class="el" href="classipc_1_1transport_1_1sync__io_1_1Blob__stream__mq__sender.html" title="Implements sync_io::Blob_sender concept by using an adopted Persistent_mq_handle MQ handle to an MQ (...">Blob_stream_mq_sender</a> counterpart.  <a href="classipc_1_1transport_1_1sync__io_1_1Blob__stream__mq__sender__impl.html#afe0b25b57614615d0672c40cf8f58170">More...</a><br /></td></tr>
<tr class="separator:afe0b25b57614615d0672c40cf8f58170"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa16854340cdf194120efd08f711c74f9"><td class="memTemplParams" colspan="2">template&lt;typename Create_ev_wait_hndl_func &gt; </td></tr>
<tr class="memitem:aa16854340cdf194120efd08f711c74f9"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classipc_1_1transport_1_1sync__io_1_1Blob__stream__mq__sender__impl.html#aa16854340cdf194120efd08f711c74f9">replace_event_wait_handles</a> (const Create_ev_wait_hndl_func &amp;create_ev_wait_hndl_func)</td></tr>
<tr class="memdesc:aa16854340cdf194120efd08f711c74f9"><td class="mdescLeft">&#160;</td><td class="mdescRight">See <a class="el" href="classipc_1_1transport_1_1sync__io_1_1Blob__stream__mq__sender.html" title="Implements sync_io::Blob_sender concept by using an adopted Persistent_mq_handle MQ handle to an MQ (...">Blob_stream_mq_sender</a> counterpart.  <a href="classipc_1_1transport_1_1sync__io_1_1Blob__stream__mq__sender__impl.html#aa16854340cdf194120efd08f711c74f9">More...</a><br /></td></tr>
<tr class="separator:aa16854340cdf194120efd08f711c74f9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae56c0c2aeb9fa3c34c364ec46a506994"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classipc_1_1transport_1_1sync__io_1_1Blob__stream__mq__sender__impl.html#ae56c0c2aeb9fa3c34c364ec46a506994">send_blob_max_size</a> () const</td></tr>
<tr class="memdesc:ae56c0c2aeb9fa3c34c364ec46a506994"><td class="mdescLeft">&#160;</td><td class="mdescRight">See <a class="el" href="classipc_1_1transport_1_1sync__io_1_1Blob__stream__mq__sender.html" title="Implements sync_io::Blob_sender concept by using an adopted Persistent_mq_handle MQ handle to an MQ (...">Blob_stream_mq_sender</a> counterpart, but assuming PEER state.  <a href="classipc_1_1transport_1_1sync__io_1_1Blob__stream__mq__sender__impl.html#ae56c0c2aeb9fa3c34c364ec46a506994">More...</a><br /></td></tr>
<tr class="separator:ae56c0c2aeb9fa3c34c364ec46a506994"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa3116afe888df718c4ae10befcf2a16f"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classipc_1_1transport_1_1sync__io_1_1Blob__stream__mq__sender__impl.html#aa3116afe888df718c4ae10befcf2a16f">start_send_blob_ops</a> (<a class="el" href="namespaceipc_1_1util_1_1sync__io.html#aa0b9a3cc6bdc7dedbef4f9e06851aa24">util::sync_io::Event_wait_func</a> &amp;&amp;ev_wait_func)</td></tr>
<tr class="memdesc:aa3116afe888df718c4ae10befcf2a16f"><td class="mdescLeft">&#160;</td><td class="mdescRight">See <a class="el" href="classipc_1_1transport_1_1sync__io_1_1Blob__stream__mq__sender.html" title="Implements sync_io::Blob_sender concept by using an adopted Persistent_mq_handle MQ handle to an MQ (...">Blob_stream_mq_sender</a> counterpart.  <a href="classipc_1_1transport_1_1sync__io_1_1Blob__stream__mq__sender__impl.html#aa3116afe888df718c4ae10befcf2a16f">More...</a><br /></td></tr>
<tr class="separator:aa3116afe888df718c4ae10befcf2a16f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aba05c51d1033a4ea4ca03679f2fa1f8c"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classipc_1_1transport_1_1sync__io_1_1Blob__stream__mq__sender__impl.html#aba05c51d1033a4ea4ca03679f2fa1f8c">send_blob</a> (const <a class="el" href="namespaceipc_1_1util.html#ae0be7edba7e30ffa3f8b742af621f2ab">util::Blob_const</a> &amp;blob, <a class="el" href="namespaceipc.html#aa3192e586cc45d3e7c22463bf2760f89">Error_code</a> *err_code)</td></tr>
<tr class="memdesc:aba05c51d1033a4ea4ca03679f2fa1f8c"><td class="mdescLeft">&#160;</td><td class="mdescRight">See <a class="el" href="classipc_1_1transport_1_1sync__io_1_1Blob__stream__mq__sender.html" title="Implements sync_io::Blob_sender concept by using an adopted Persistent_mq_handle MQ handle to an MQ (...">Blob_stream_mq_sender</a> counterpart, but assuming PEER state.  <a href="classipc_1_1transport_1_1sync__io_1_1Blob__stream__mq__sender__impl.html#aba05c51d1033a4ea4ca03679f2fa1f8c">More...</a><br /></td></tr>
<tr class="separator:aba05c51d1033a4ea4ca03679f2fa1f8c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4709b00fb1a8fc0ea63535d0a47f15f0"><td class="memTemplParams" colspan="2">template&lt;typename Task_err &gt; </td></tr>
<tr class="memitem:a4709b00fb1a8fc0ea63535d0a47f15f0"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classipc_1_1transport_1_1sync__io_1_1Blob__stream__mq__sender__impl.html#a4709b00fb1a8fc0ea63535d0a47f15f0">async_end_sending</a> (<a class="el" href="namespaceipc.html#aa3192e586cc45d3e7c22463bf2760f89">Error_code</a> *sync_err_code, Task_err &amp;&amp;on_done_func)</td></tr>
<tr class="memdesc:a4709b00fb1a8fc0ea63535d0a47f15f0"><td class="mdescLeft">&#160;</td><td class="mdescRight">See <a class="el" href="classipc_1_1transport_1_1sync__io_1_1Blob__stream__mq__sender.html" title="Implements sync_io::Blob_sender concept by using an adopted Persistent_mq_handle MQ handle to an MQ (...">Blob_stream_mq_sender</a> counterpart, but assuming PEER state.  <a href="classipc_1_1transport_1_1sync__io_1_1Blob__stream__mq__sender__impl.html#a4709b00fb1a8fc0ea63535d0a47f15f0">More...</a><br /></td></tr>
<tr class="separator:a4709b00fb1a8fc0ea63535d0a47f15f0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a66bdd766d92029aa20d50b97edae0ce5"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classipc_1_1transport_1_1sync__io_1_1Blob__stream__mq__sender__impl.html#a66bdd766d92029aa20d50b97edae0ce5">end_sending</a> ()</td></tr>
<tr class="memdesc:a66bdd766d92029aa20d50b97edae0ce5"><td class="mdescLeft">&#160;</td><td class="mdescRight">See <a class="el" href="classipc_1_1transport_1_1sync__io_1_1Blob__stream__mq__sender.html" title="Implements sync_io::Blob_sender concept by using an adopted Persistent_mq_handle MQ handle to an MQ (...">Blob_stream_mq_sender</a> counterpart, but assuming PEER state.  <a href="classipc_1_1transport_1_1sync__io_1_1Blob__stream__mq__sender__impl.html#a66bdd766d92029aa20d50b97edae0ce5">More...</a><br /></td></tr>
<tr class="separator:a66bdd766d92029aa20d50b97edae0ce5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a19e169b59c90ceac14671aa324a00649"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classipc_1_1transport_1_1sync__io_1_1Blob__stream__mq__sender__impl.html#a19e169b59c90ceac14671aa324a00649">auto_ping</a> (<a class="el" href="namespaceipc_1_1util.html#ac66141280c3b7295a86b65209f31cc58">util::Fine_duration</a> period)</td></tr>
<tr class="memdesc:a19e169b59c90ceac14671aa324a00649"><td class="mdescLeft">&#160;</td><td class="mdescRight">See <a class="el" href="classipc_1_1transport_1_1sync__io_1_1Blob__stream__mq__sender.html" title="Implements sync_io::Blob_sender concept by using an adopted Persistent_mq_handle MQ handle to an MQ (...">Blob_stream_mq_sender</a> counterpart, but assuming PEER state.  <a href="classipc_1_1transport_1_1sync__io_1_1Blob__stream__mq__sender__impl.html#a19e169b59c90ceac14671aa324a00649">More...</a><br /></td></tr>
<tr class="separator:a19e169b59c90ceac14671aa324a00649"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad30ee34fd91e68a084d207763e753f6d"><td class="memItemLeft" align="right" valign="top">const std::string &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classipc_1_1transport_1_1sync__io_1_1Blob__stream__mq__sender__impl.html#ad30ee34fd91e68a084d207763e753f6d">nickname</a> () const</td></tr>
<tr class="memdesc:ad30ee34fd91e68a084d207763e753f6d"><td class="mdescLeft">&#160;</td><td class="mdescRight">See <a class="el" href="classipc_1_1transport_1_1sync__io_1_1Blob__stream__mq__sender.html" title="Implements sync_io::Blob_sender concept by using an adopted Persistent_mq_handle MQ handle to an MQ (...">Blob_stream_mq_sender</a> counterpart, but assuming PEER state.  <a href="classipc_1_1transport_1_1sync__io_1_1Blob__stream__mq__sender__impl.html#ad30ee34fd91e68a084d207763e753f6d">More...</a><br /></td></tr>
<tr class="separator:ad30ee34fd91e68a084d207763e753f6d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0763f3a2891a2a0e41f3ff15f06db7cc"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="namespaceipc_1_1transport.html#a33de1c256addb3964b839dc2dd407d24">Shared_name</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classipc_1_1transport_1_1sync__io_1_1Blob__stream__mq__sender__impl.html#a0763f3a2891a2a0e41f3ff15f06db7cc">absolute_name</a> () const</td></tr>
<tr class="memdesc:a0763f3a2891a2a0e41f3ff15f06db7cc"><td class="mdescLeft">&#160;</td><td class="mdescRight">See <a class="el" href="classipc_1_1transport_1_1sync__io_1_1Blob__stream__mq__sender.html" title="Implements sync_io::Blob_sender concept by using an adopted Persistent_mq_handle MQ handle to an MQ (...">Blob_stream_mq_sender</a> counterpart, but assuming PEER state.  <a href="classipc_1_1transport_1_1sync__io_1_1Blob__stream__mq__sender__impl.html#a0763f3a2891a2a0e41f3ff15f06db7cc">More...</a><br /></td></tr>
<tr class="separator:a0763f3a2891a2a0e41f3ff15f06db7cc"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pri-types" name="pri-types"></a>
Private Types</h2></td></tr>
<tr class="memitem:a62ce20c2a91367330b92c8b392524b32"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classipc_1_1transport_1_1sync__io_1_1Blob__stream__mq__sender__impl.html#a62ce20c2a91367330b92c8b392524b32">Control_cmd</a> = typename <a class="el" href="classipc_1_1transport_1_1Blob__stream__mq__base__impl.html#a2e46672d40fbf38cf6054edfad69e705">Base::Control_cmd</a></td></tr>
<tr class="memdesc:a62ce20c2a91367330b92c8b392524b32"><td class="mdescLeft">&#160;</td><td class="mdescRight">Short-hand for <a class="el" href="classipc_1_1transport_1_1Blob__stream__mq__base__impl.html#a2e46672d40fbf38cf6054edfad69e705" title="If Blob_stream_mq_sender_impl sends an empty message, in NORMAL state Blob_stream_mq_receiver enters ...">Blob_stream_mq_base_impl::Control_cmd</a>.  <a href="classipc_1_1transport_1_1sync__io_1_1Blob__stream__mq__sender__impl.html#a62ce20c2a91367330b92c8b392524b32">More...</a><br /></td></tr>
<tr class="separator:a62ce20c2a91367330b92c8b392524b32"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pri-methods" name="pri-methods"></a>
Private Member Functions</h2></td></tr>
<tr class="memitem:aa7f092848ef3691dcf97182e5b3e2383"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classipc_1_1transport_1_1sync__io_1_1Blob__stream__mq__sender__impl.html#aa7f092848ef3691dcf97182e5b3e2383">op_started</a> (<a class="el" href="namespaceipc_1_1util.html#ae6ac47812a90d1287c61e0b7de7bc4f5">util::String_view</a> context) const</td></tr>
<tr class="memdesc:aa7f092848ef3691dcf97182e5b3e2383"><td class="mdescLeft">&#160;</td><td class="mdescRight">Helper that returns <code>true</code> silently if <code>start_*_ops()</code> has been called; else logs WARNING and returns <code>false</code>.  <a href="classipc_1_1transport_1_1sync__io_1_1Blob__stream__mq__sender__impl.html#aa7f092848ef3691dcf97182e5b3e2383">More...</a><br /></td></tr>
<tr class="separator:aa7f092848ef3691dcf97182e5b3e2383"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adc7d43cbe05d4ad239d7abcf010955db"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classipc_1_1transport_1_1sync__io_1_1Blob__stream__mq__sender__impl.html#adc7d43cbe05d4ad239d7abcf010955db">async_end_sending_impl</a> (<a class="el" href="namespaceipc.html#aa3192e586cc45d3e7c22463bf2760f89">Error_code</a> *sync_err_code_ptr_or_null, flow::async::Task_asio_err &amp;&amp;on_done_func_or_empty)</td></tr>
<tr class="memdesc:adc7d43cbe05d4ad239d7abcf010955db"><td class="mdescLeft">&#160;</td><td class="mdescRight"><code>*end_sending()</code> body.  <a href="classipc_1_1transport_1_1sync__io_1_1Blob__stream__mq__sender__impl.html#adc7d43cbe05d4ad239d7abcf010955db">More...</a><br /></td></tr>
<tr class="separator:adc7d43cbe05d4ad239d7abcf010955db"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad84b0f43cd4d1329c8bac6ea1376d3ca"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classipc_1_1transport_1_1sync__io_1_1Blob__stream__mq__sender__impl.html#ad84b0f43cd4d1329c8bac6ea1376d3ca">on_ev_auto_ping_now_timer_fired</a> ()</td></tr>
<tr class="memdesc:ad84b0f43cd4d1329c8bac6ea1376d3ca"><td class="mdescLeft">&#160;</td><td class="mdescRight">Handler for the async-wait, via <a class="el" href="classipc_1_1util_1_1sync__io_1_1Timer__event__emitter.html" title="An object of this type, used internally to implement sync_io-pattern objects that require timer event...">util::sync_io::Timer_event_emitter</a>, of the auto-ping timer firing; if all is cool, sends auto-ping and schedules the next such async-wait.  <a href="classipc_1_1transport_1_1sync__io_1_1Blob__stream__mq__sender__impl.html#ad84b0f43cd4d1329c8bac6ea1376d3ca">More...</a><br /></td></tr>
<tr class="separator:ad84b0f43cd4d1329c8bac6ea1376d3ca"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a25e79124ef73da11430ce3060587f12a"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classipc_1_1transport_1_1sync__io_1_1Blob__stream__mq__sender__impl.html#a25e79124ef73da11430ce3060587f12a">sync_write_or_q_payload</a> (const <a class="el" href="namespaceipc_1_1util.html#ae0be7edba7e30ffa3f8b742af621f2ab">util::Blob_const</a> &amp;orig_blob, bool *avoided_qing_or_null)</td></tr>
<tr class="memdesc:a25e79124ef73da11430ce3060587f12a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Either synchronously sends <code>orig_blob</code> low-level blob over <a class="el" href="classipc_1_1transport_1_1sync__io_1_1Blob__stream__mq__sender__impl.html#a32a49dff090ce4b658707e7d9b9036c9" title="The MQ handle adopted by the ctor, through which nb-sends and blocking-waits are executed.">m_mq</a>, or if an async-send is in progress queues it to be sent later; dropping-sans-queuing allowed under certain circumstances in <code>avoided_qing</code> mode.  <a href="classipc_1_1transport_1_1sync__io_1_1Blob__stream__mq__sender__impl.html#a25e79124ef73da11430ce3060587f12a">More...</a><br /></td></tr>
<tr class="separator:a25e79124ef73da11430ce3060587f12a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af7657579dd859f95c234e447246b9410"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classipc_1_1transport_1_1sync__io_1_1Blob__stream__mq__sender__impl.html#af7657579dd859f95c234e447246b9410">sync_write_or_q_ctl_cmd</a> (<a class="el" href="classipc_1_1transport_1_1Blob__stream__mq__base__impl.html#a2e46672d40fbf38cf6054edfad69e705">Control_cmd</a> cmd)</td></tr>
<tr class="memdesc:af7657579dd859f95c234e447246b9410"><td class="mdescLeft">&#160;</td><td class="mdescRight">Writes the 2 payloads corresponding to CONTROL command <code>cmd</code> to <a class="el" href="classipc_1_1transport_1_1sync__io_1_1Blob__stream__mq__sender__impl.html#a32a49dff090ce4b658707e7d9b9036c9" title="The MQ handle adopted by the ctor, through which nb-sends and blocking-waits are executed.">m_mq</a>; if unable to do so synchronously &ndash; either because items are already queued in <a class="el" href="classipc_1_1transport_1_1sync__io_1_1Blob__stream__mq__sender__impl.html#aaecb4615ae4d9fbf82ab2c195ada47cf" title="Queue storing (at head) the currently in-progress async write-op of a Snd_low_lvl_payload; followed b...">m_pending_payloads_q</a>, or MQ is full &ndash; then enqueue 1-2 of the payloads onto that queue.  <a href="classipc_1_1transport_1_1sync__io_1_1Blob__stream__mq__sender__impl.html#af7657579dd859f95c234e447246b9410">More...</a><br /></td></tr>
<tr class="separator:af7657579dd859f95c234e447246b9410"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab8230261c54efb813aabc8a80f79fc8d"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classipc_1_1transport_1_1sync__io_1_1Blob__stream__mq__sender__impl.html#ab8230261c54efb813aabc8a80f79fc8d">sync_write_or_q_ctl_cmd_impl</a> (std::underlying_type_t&lt; <a class="el" href="classipc_1_1transport_1_1Blob__stream__mq__base__impl.html#a2e46672d40fbf38cf6054edfad69e705">Control_cmd</a> &gt; raw_cmd)</td></tr>
<tr class="memdesc:ab8230261c54efb813aabc8a80f79fc8d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Equivalent to <a class="el" href="classipc_1_1transport_1_1sync__io_1_1Blob__stream__mq__sender__impl.html#af7657579dd859f95c234e447246b9410" title="Writes the 2 payloads corresponding to CONTROL command cmd to m_mq; if unable to do so synchronously ...">sync_write_or_q_ctl_cmd()</a> but takes the raw representation of the command to send; this allows both sending the <code>enum Control_cmd</code> value or the special protocol negotiation payload.  <a href="classipc_1_1transport_1_1sync__io_1_1Blob__stream__mq__sender__impl.html#ab8230261c54efb813aabc8a80f79fc8d">More...</a><br /></td></tr>
<tr class="separator:ab8230261c54efb813aabc8a80f79fc8d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a57737a56544ffac3cfd8d130663bb6ce"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classipc_1_1transport_1_1sync__io_1_1Blob__stream__mq__sender__impl.html#a57737a56544ffac3cfd8d130663bb6ce">async_write_q_head_payload</a> ()</td></tr>
<tr class="memdesc:a57737a56544ffac3cfd8d130663bb6ce"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initiates async-write over <a class="el" href="classipc_1_1transport_1_1sync__io_1_1Blob__stream__mq__sender__impl.html#a32a49dff090ce4b658707e7d9b9036c9" title="The MQ handle adopted by the ctor, through which nb-sends and blocking-waits are executed.">m_mq</a> of the low-level payload at the head of out-queue <a class="el" href="classipc_1_1transport_1_1sync__io_1_1Blob__stream__mq__sender__impl.html#aaecb4615ae4d9fbf82ab2c195ada47cf" title="Queue storing (at head) the currently in-progress async write-op of a Snd_low_lvl_payload; followed b...">m_pending_payloads_q</a>, with completion handler also inside this method.  <a href="classipc_1_1transport_1_1sync__io_1_1Blob__stream__mq__sender__impl.html#a57737a56544ffac3cfd8d130663bb6ce">More...</a><br /></td></tr>
<tr class="separator:a57737a56544ffac3cfd8d130663bb6ce"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pri-attribs" name="pri-attribs"></a>
Private Attributes</h2></td></tr>
<tr class="memitem:ab9c3904b9cd89438c1f2de5ec974f814"><td class="memItemLeft" align="right" valign="top">const std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classipc_1_1transport_1_1sync__io_1_1Blob__stream__mq__sender__impl.html#ab9c3904b9cd89438c1f2de5ec974f814">m_nickname</a></td></tr>
<tr class="memdesc:ab9c3904b9cd89438c1f2de5ec974f814"><td class="mdescLeft">&#160;</td><td class="mdescRight">See <a class="el" href="classipc_1_1transport_1_1sync__io_1_1Blob__stream__mq__sender__impl.html#ad30ee34fd91e68a084d207763e753f6d" title="See Blob_stream_mq_sender counterpart, but assuming PEER state.">nickname()</a>.  <a href="classipc_1_1transport_1_1sync__io_1_1Blob__stream__mq__sender__impl.html#ab9c3904b9cd89438c1f2de5ec974f814">More...</a><br /></td></tr>
<tr class="separator:ab9c3904b9cd89438c1f2de5ec974f814"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a28485fe8e4fbeea78f05eadc69a31c20"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classipc_1_1transport_1_1Protocol__negotiator.html">Protocol_negotiator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classipc_1_1transport_1_1sync__io_1_1Blob__stream__mq__sender__impl.html#a28485fe8e4fbeea78f05eadc69a31c20">m_protocol_negotiator</a></td></tr>
<tr class="memdesc:a28485fe8e4fbeea78f05eadc69a31c20"><td class="mdescLeft">&#160;</td><td class="mdescRight">Handles the protocol negotiation at the start of the pipe.  <a href="classipc_1_1transport_1_1sync__io_1_1Blob__stream__mq__sender__impl.html#a28485fe8e4fbeea78f05eadc69a31c20">More...</a><br /></td></tr>
<tr class="separator:a28485fe8e4fbeea78f05eadc69a31c20"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4ea460de8caacec0ac8f75dd93f6c548"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="namespaceipc_1_1transport.html#a33de1c256addb3964b839dc2dd407d24">Shared_name</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classipc_1_1transport_1_1sync__io_1_1Blob__stream__mq__sender__impl.html#a4ea460de8caacec0ac8f75dd93f6c548">m_absolute_name</a></td></tr>
<tr class="memdesc:a4ea460de8caacec0ac8f75dd93f6c548"><td class="mdescLeft">&#160;</td><td class="mdescRight">See <a class="el" href="classipc_1_1transport_1_1sync__io_1_1Blob__stream__mq__sender__impl.html#a0763f3a2891a2a0e41f3ff15f06db7cc" title="See Blob_stream_mq_sender counterpart, but assuming PEER state.">absolute_name()</a>.  <a href="classipc_1_1transport_1_1sync__io_1_1Blob__stream__mq__sender__impl.html#a4ea460de8caacec0ac8f75dd93f6c548">More...</a><br /></td></tr>
<tr class="separator:a4ea460de8caacec0ac8f75dd93f6c548"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0614000879d4595c84f803ecadae708a"><td class="memItemLeft" align="right" valign="top">std::optional&lt; flow::util::Task_engine &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classipc_1_1transport_1_1sync__io_1_1Blob__stream__mq__sender__impl.html#a0614000879d4595c84f803ecadae708a">m_nb_task_engine</a></td></tr>
<tr class="memdesc:a0614000879d4595c84f803ecadae708a"><td class="mdescLeft">&#160;</td><td class="mdescRight">The <code>Task_engine</code> for <code>m_mq_ready_*</code>.  <a href="classipc_1_1transport_1_1sync__io_1_1Blob__stream__mq__sender__impl.html#a0614000879d4595c84f803ecadae708a">More...</a><br /></td></tr>
<tr class="separator:a0614000879d4595c84f803ecadae708a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abdda4c698320a44bdf479340cbed6934"><td class="memItemLeft" align="right" valign="top">flow::util::Task_engine&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classipc_1_1transport_1_1sync__io_1_1Blob__stream__mq__sender__impl.html#abdda4c698320a44bdf479340cbed6934">m_ev_hndl_task_engine_unused</a></td></tr>
<tr class="memdesc:abdda4c698320a44bdf479340cbed6934"><td class="mdescLeft">&#160;</td><td class="mdescRight">The <code>Task_engine</code> for <code>m_ev_wait_hndl_*</code>, unless it is replaced via <a class="el" href="classipc_1_1transport_1_1sync__io_1_1Blob__stream__mq__sender__impl.html#aa16854340cdf194120efd08f711c74f9" title="See Blob_stream_mq_sender counterpart.">replace_event_wait_handles()</a>.  <a href="classipc_1_1transport_1_1sync__io_1_1Blob__stream__mq__sender__impl.html#abdda4c698320a44bdf479340cbed6934">More...</a><br /></td></tr>
<tr class="separator:abdda4c698320a44bdf479340cbed6934"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a32a49dff090ce4b658707e7d9b9036c9"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classipc_1_1transport_1_1Blob__stream__mq__base__impl.html#aab7c4c91d42c746c93e61eb367572eb1">Base::Auto_closing_mq</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classipc_1_1transport_1_1sync__io_1_1Blob__stream__mq__sender__impl.html#a32a49dff090ce4b658707e7d9b9036c9">m_mq</a></td></tr>
<tr class="memdesc:a32a49dff090ce4b658707e7d9b9036c9"><td class="mdescLeft">&#160;</td><td class="mdescRight">The MQ handle adopted by the ctor, through which nb-sends and blocking-waits are executed.  <a href="classipc_1_1transport_1_1sync__io_1_1Blob__stream__mq__sender__impl.html#a32a49dff090ce4b658707e7d9b9036c9">More...</a><br /></td></tr>
<tr class="separator:a32a49dff090ce4b658707e7d9b9036c9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3a69e00d989a53f1151c64b58560551f"><td class="memItemLeft" align="right" valign="top">const size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classipc_1_1transport_1_1sync__io_1_1Blob__stream__mq__sender__impl.html#a3a69e00d989a53f1151c64b58560551f">m_mq_max_msg_sz</a></td></tr>
<tr class="memdesc:a3a69e00d989a53f1151c64b58560551f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Equals <code>m_mq.max_msg_size()</code>.  <a href="classipc_1_1transport_1_1sync__io_1_1Blob__stream__mq__sender__impl.html#a3a69e00d989a53f1151c64b58560551f">More...</a><br /></td></tr>
<tr class="separator:a3a69e00d989a53f1151c64b58560551f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a63f5f55ad38aecc5195a93bccaf23014"><td class="memItemLeft" align="right" valign="top">std::optional&lt; <a class="el" href="namespaceipc_1_1util.html#aaf368acf8243bb25de3eef4e836c15de">util::Pipe_reader</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classipc_1_1transport_1_1sync__io_1_1Blob__stream__mq__sender__impl.html#a63f5f55ad38aecc5195a93bccaf23014">m_mq_ready_reader</a></td></tr>
<tr class="memdesc:a63f5f55ad38aecc5195a93bccaf23014"><td class="mdescLeft">&#160;</td><td class="mdescRight">Read-end of IPC-pipe used by thread U to detect that a thread-W transmissibility-wait has completed, meaning would-block has cleared, and therefore thread U can attempt to nb-transmit again.  <a href="classipc_1_1transport_1_1sync__io_1_1Blob__stream__mq__sender__impl.html#a63f5f55ad38aecc5195a93bccaf23014">More...</a><br /></td></tr>
<tr class="separator:a63f5f55ad38aecc5195a93bccaf23014"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a72c3901ca66a8d94aa22c83118aedbdd"><td class="memItemLeft" align="right" valign="top">std::optional&lt; <a class="el" href="namespaceipc_1_1util.html#a844d5ca9c17b672644fc8d9dbe758db0">util::Pipe_writer</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classipc_1_1transport_1_1sync__io_1_1Blob__stream__mq__sender__impl.html#a72c3901ca66a8d94aa22c83118aedbdd">m_mq_ready_writer</a></td></tr>
<tr class="memdesc:a72c3901ca66a8d94aa22c83118aedbdd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Write-end of IPC-pipe used by thread W to inform thread U that a thread-W transmissibility-wait has completed, meaning would-block has cleared, and therefore thread U can attempt to nb-transmit again.  <a href="classipc_1_1transport_1_1sync__io_1_1Blob__stream__mq__sender__impl.html#a72c3901ca66a8d94aa22c83118aedbdd">More...</a><br /></td></tr>
<tr class="separator:a72c3901ca66a8d94aa22c83118aedbdd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a31580924c39d2dfe9cdfa9f7cb36ccd4"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classipc_1_1util_1_1sync__io_1_1Asio__waitable__native__handle.html">util::sync_io::Asio_waitable_native_handle</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classipc_1_1transport_1_1sync__io_1_1Blob__stream__mq__sender__impl.html#a31580924c39d2dfe9cdfa9f7cb36ccd4">m_ev_wait_hndl_mq</a></td></tr>
<tr class="memdesc:a31580924c39d2dfe9cdfa9f7cb36ccd4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Descriptor waitable by outside event loop async-waits &ndash; storing the same <code>Native_handle</code> as (and thus being used to wait on events from) <a class="el" href="classipc_1_1transport_1_1sync__io_1_1Blob__stream__mq__sender__impl.html#a63f5f55ad38aecc5195a93bccaf23014" title="Read-end of IPC-pipe used by thread U to detect that a thread-W transmissibility-wait has completed,...">m_mq_ready_reader</a>; or if <a class="el" href="classipc_1_1transport_1_1sync__io_1_1Blob__stream__mq__sender__impl.html#a32a49dff090ce4b658707e7d9b9036c9" title="The MQ handle adopted by the ctor, through which nb-sends and blocking-waits are executed.">m_mq</a> can be watched directly (known at compile-time) then as <code>m_mq</code> itself.  <a href="classipc_1_1transport_1_1sync__io_1_1Blob__stream__mq__sender__impl.html#a31580924c39d2dfe9cdfa9f7cb36ccd4">More...</a><br /></td></tr>
<tr class="separator:a31580924c39d2dfe9cdfa9f7cb36ccd4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab8bae935aff314b88d6163d04f52b5eb"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classipc_1_1util_1_1sync__io_1_1Timer__event__emitter.html">util::sync_io::Timer_event_emitter</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classipc_1_1transport_1_1sync__io_1_1Blob__stream__mq__sender__impl.html#ab8bae935aff314b88d6163d04f52b5eb">m_timer_worker</a></td></tr>
<tr class="memdesc:ab8bae935aff314b88d6163d04f52b5eb"><td class="mdescLeft">&#160;</td><td class="mdescRight">As typical in timer-needing <code><a class="el" href="namespaceipc_1_1transport_1_1sync__io.html" title="sync_io-pattern counterparts to async-I/O-pattern object types in parent namespace ipc::transport.">sync_io</a></code>-pattern-implementing objects, maintains a thread exclusively for <code>Timer</code> wait completion handlers which ferry timer-fired events to internal IPC-mechanisms waitable by the <code><a class="el" href="namespaceipc_1_1transport_1_1sync__io.html" title="sync_io-pattern counterparts to async-I/O-pattern object types in parent namespace ipc::transport.">sync_io</a></code>-pattern-using outside event loop.  <a href="classipc_1_1transport_1_1sync__io_1_1Blob__stream__mq__sender__impl.html#ab8bae935aff314b88d6163d04f52b5eb">More...</a><br /></td></tr>
<tr class="separator:ab8bae935aff314b88d6163d04f52b5eb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaecb4615ae4d9fbf82ab2c195ada47cf"><td class="memItemLeft" align="right" valign="top">std::queue&lt; typename <a class="el" href="structipc_1_1transport_1_1sync__io_1_1Blob__stream__mq__sender__impl_1_1Snd__low__lvl__payload.html#ad30cb6fc47d87a52a665e748b48e47ed">Snd_low_lvl_payload::Ptr</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classipc_1_1transport_1_1sync__io_1_1Blob__stream__mq__sender__impl.html#aaecb4615ae4d9fbf82ab2c195ada47cf">m_pending_payloads_q</a></td></tr>
<tr class="memdesc:aaecb4615ae4d9fbf82ab2c195ada47cf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Queue storing (at head) the currently in-progress async write-op of a <a class="el" href="structipc_1_1transport_1_1sync__io_1_1Blob__stream__mq__sender__impl_1_1Snd__low__lvl__payload.html" title="Data store representing a payload corresponding to exactly one attempted async write-op,...">Snd_low_lvl_payload</a>; followed by the payloads that should be written after that completes, in order.  <a href="classipc_1_1transport_1_1sync__io_1_1Blob__stream__mq__sender__impl.html#aaecb4615ae4d9fbf82ab2c195ada47cf">More...</a><br /></td></tr>
<tr class="separator:aaecb4615ae4d9fbf82ab2c195ada47cf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:affd27be454f2e394f44fc76a5a4c50de"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespaceipc.html#aa3192e586cc45d3e7c22463bf2760f89">Error_code</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classipc_1_1transport_1_1sync__io_1_1Blob__stream__mq__sender__impl.html#affd27be454f2e394f44fc76a5a4c50de">m_pending_err_code</a></td></tr>
<tr class="memdesc:affd27be454f2e394f44fc76a5a4c50de"><td class="mdescLeft">&#160;</td><td class="mdescRight">The first and only connection-hosing error condition detected when attempting to low-level-write on <a class="el" href="classipc_1_1transport_1_1sync__io_1_1Blob__stream__mq__sender__impl.html#a32a49dff090ce4b658707e7d9b9036c9" title="The MQ handle adopted by the ctor, through which nb-sends and blocking-waits are executed.">m_mq</a>; or falsy if no such error has yet been detected.  <a href="classipc_1_1transport_1_1sync__io_1_1Blob__stream__mq__sender__impl.html#affd27be454f2e394f44fc76a5a4c50de">More...</a><br /></td></tr>
<tr class="separator:affd27be454f2e394f44fc76a5a4c50de"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac9712c677320d7e9d4efa83798fa8aac"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classipc_1_1transport_1_1sync__io_1_1Blob__stream__mq__sender__impl.html#ac9712c677320d7e9d4efa83798fa8aac">m_finished</a></td></tr>
<tr class="memdesc:ac9712c677320d7e9d4efa83798fa8aac"><td class="mdescLeft">&#160;</td><td class="mdescRight"><code>false</code> at start; set to <code>true</code> forever on the first <code>*end_sending()</code> invocation; <code>true</code> will prevent any subsequent <a class="el" href="classipc_1_1transport_1_1sync__io_1_1Blob__stream__mq__sender__impl.html#aba05c51d1033a4ea4ca03679f2fa1f8c" title="See Blob_stream_mq_sender counterpart, but assuming PEER state.">send_blob()</a> calls from proceeding.  <a href="classipc_1_1transport_1_1sync__io_1_1Blob__stream__mq__sender__impl.html#ac9712c677320d7e9d4efa83798fa8aac">More...</a><br /></td></tr>
<tr class="separator:ac9712c677320d7e9d4efa83798fa8aac"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a48689f6fbe1a1d4df3285736326b18f4"><td class="memItemLeft" align="right" valign="top">flow::async::Task_asio_err&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classipc_1_1transport_1_1sync__io_1_1Blob__stream__mq__sender__impl.html#a48689f6fbe1a1d4df3285736326b18f4">m_pending_on_last_send_done_func_or_empty</a></td></tr>
<tr class="memdesc:a48689f6fbe1a1d4df3285736326b18f4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function passed to <a class="el" href="classipc_1_1transport_1_1sync__io_1_1Blob__stream__mq__sender__impl.html#a4709b00fb1a8fc0ea63535d0a47f15f0" title="See Blob_stream_mq_sender counterpart, but assuming PEER state.">async_end_sending()</a>, if it returned <code>true</code> and was unable to synchronously flush everything including the graceful-close itself (synchronously detecting new or previous pipe-hosing error <em>does</em> entail flushing everything); otherwise <code>.empty()</code>.  <a href="classipc_1_1transport_1_1sync__io_1_1Blob__stream__mq__sender__impl.html#a48689f6fbe1a1d4df3285736326b18f4">More...</a><br /></td></tr>
<tr class="separator:a48689f6fbe1a1d4df3285736326b18f4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2c8029fdae05966ef05312919c85aeac"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespaceipc_1_1util.html#ac66141280c3b7295a86b65209f31cc58">util::Fine_duration</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classipc_1_1transport_1_1sync__io_1_1Blob__stream__mq__sender__impl.html#a2c8029fdae05966ef05312919c85aeac">m_auto_ping_period</a></td></tr>
<tr class="memdesc:a2c8029fdae05966ef05312919c85aeac"><td class="mdescLeft">&#160;</td><td class="mdescRight">Equals <code>zero()</code> before <a class="el" href="classipc_1_1transport_1_1sync__io_1_1Blob__stream__mq__sender__impl.html#a19e169b59c90ceac14671aa324a00649" title="See Blob_stream_mq_sender counterpart, but assuming PEER state.">auto_ping()</a>; immutably equals <code>period</code> (<a class="el" href="classipc_1_1transport_1_1sync__io_1_1Blob__stream__mq__sender__impl.html#a19e169b59c90ceac14671aa324a00649" title="See Blob_stream_mq_sender counterpart, but assuming PEER state.">auto_ping()</a> arg) subsequently to that first successful call (if any).  <a href="classipc_1_1transport_1_1sync__io_1_1Blob__stream__mq__sender__impl.html#a2c8029fdae05966ef05312919c85aeac">More...</a><br /></td></tr>
<tr class="separator:a2c8029fdae05966ef05312919c85aeac"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a41bb316b2f9ca88371506ebed3890261"><td class="memItemLeft" align="right" valign="top">flow::util::Timer&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classipc_1_1transport_1_1sync__io_1_1Blob__stream__mq__sender__impl.html#a41bb316b2f9ca88371506ebed3890261">m_auto_ping_timer</a></td></tr>
<tr class="memdesc:a41bb316b2f9ca88371506ebed3890261"><td class="mdescLeft">&#160;</td><td class="mdescRight">Timer that fires <a class="el" href="classipc_1_1transport_1_1sync__io_1_1Blob__stream__mq__sender__impl.html#ad84b0f43cd4d1329c8bac6ea1376d3ca" title="Handler for the async-wait, via util::sync_io::Timer_event_emitter, of the auto-ping timer firing; if...">on_ev_auto_ping_now_timer_fired()</a> (which sends an auto-ping) and is always scheduled to fire <a class="el" href="classipc_1_1transport_1_1sync__io_1_1Blob__stream__mq__sender__impl.html#a2c8029fdae05966ef05312919c85aeac" title="Equals zero() before auto_ping(); immutably equals period (auto_ping() arg) subsequently to that firs...">m_auto_ping_period</a> after the last send (<a class="el" href="classipc_1_1transport_1_1sync__io_1_1Blob__stream__mq__sender__impl.html#aba05c51d1033a4ea4ca03679f2fa1f8c" title="See Blob_stream_mq_sender counterpart, but assuming PEER state.">send_blob()</a>, <a class="el" href="classipc_1_1transport_1_1sync__io_1_1Blob__stream__mq__sender__impl.html#a19e169b59c90ceac14671aa324a00649" title="See Blob_stream_mq_sender counterpart, but assuming PEER state.">auto_ping()</a>, <a class="el" href="classipc_1_1transport_1_1sync__io_1_1Blob__stream__mq__sender__impl.html#ad84b0f43cd4d1329c8bac6ea1376d3ca" title="Handler for the async-wait, via util::sync_io::Timer_event_emitter, of the auto-ping timer firing; if...">on_ev_auto_ping_now_timer_fired()</a> itself).  <a href="classipc_1_1transport_1_1sync__io_1_1Blob__stream__mq__sender__impl.html#a41bb316b2f9ca88371506ebed3890261">More...</a><br /></td></tr>
<tr class="separator:a41bb316b2f9ca88371506ebed3890261"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac4bd1d018000ca258478b62cf67cc524"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classipc_1_1util_1_1sync__io_1_1Timer__event__emitter.html#a1533a54927a64579fda02c61ec94b735">util::sync_io::Timer_event_emitter::Timer_fired_read_end</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classipc_1_1transport_1_1sync__io_1_1Blob__stream__mq__sender__impl.html#ac4bd1d018000ca258478b62cf67cc524">m_auto_ping_timer_fired_peer</a></td></tr>
<tr class="memdesc:ac4bd1d018000ca258478b62cf67cc524"><td class="mdescLeft">&#160;</td><td class="mdescRight">Read-end of IPC-mechanism used by <a class="el" href="classipc_1_1transport_1_1sync__io_1_1Blob__stream__mq__sender__impl.html#ab8bae935aff314b88d6163d04f52b5eb" title="As typical in timer-needing sync_io-pattern-implementing objects, maintains a thread exclusively for ...">m_timer_worker</a> to ferry timer-fired events from <a class="el" href="classipc_1_1transport_1_1sync__io_1_1Blob__stream__mq__sender__impl.html#a41bb316b2f9ca88371506ebed3890261" title="Timer that fires on_ev_auto_ping_now_timer_fired() (which sends an auto-ping) and is always scheduled...">m_auto_ping_timer</a> to <code><a class="el" href="namespaceipc_1_1transport_1_1sync__io.html" title="sync_io-pattern counterparts to async-I/O-pattern object types in parent namespace ipc::transport.">sync_io</a></code> outside async-wait to our actual on-timer-fired handler logic.  <a href="classipc_1_1transport_1_1sync__io_1_1Blob__stream__mq__sender__impl.html#ac4bd1d018000ca258478b62cf67cc524">More...</a><br /></td></tr>
<tr class="separator:ac4bd1d018000ca258478b62cf67cc524"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a50bf9bbbf413b27e6189aa4d393b9dd7"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classipc_1_1util_1_1sync__io_1_1Asio__waitable__native__handle.html">util::sync_io::Asio_waitable_native_handle</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classipc_1_1transport_1_1sync__io_1_1Blob__stream__mq__sender__impl.html#a50bf9bbbf413b27e6189aa4d393b9dd7">m_ev_wait_hndl_auto_ping_timer_fired_peer</a></td></tr>
<tr class="memdesc:a50bf9bbbf413b27e6189aa4d393b9dd7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Descriptor waitable by outside event loop async-waits &ndash; storing the same <code>Native_handle</code> as (and thus being used to wait on events from) <a class="el" href="classipc_1_1transport_1_1sync__io_1_1Blob__stream__mq__sender__impl.html#ac4bd1d018000ca258478b62cf67cc524" title="Read-end of IPC-mechanism used by m_timer_worker to ferry timer-fired events from m_auto_ping_timer t...">m_auto_ping_timer_fired_peer</a>.  <a href="classipc_1_1transport_1_1sync__io_1_1Blob__stream__mq__sender__impl.html#a50bf9bbbf413b27e6189aa4d393b9dd7">More...</a><br /></td></tr>
<tr class="separator:a50bf9bbbf413b27e6189aa4d393b9dd7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9dca3046bc4d15657c08ac1c06f3b36d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespaceipc_1_1util_1_1sync__io.html#aa0b9a3cc6bdc7dedbef4f9e06851aa24">util::sync_io::Event_wait_func</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classipc_1_1transport_1_1sync__io_1_1Blob__stream__mq__sender__impl.html#a9dca3046bc4d15657c08ac1c06f3b36d">m_ev_wait_func</a></td></tr>
<tr class="memdesc:a9dca3046bc4d15657c08ac1c06f3b36d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function (set forever in <a class="el" href="classipc_1_1transport_1_1sync__io_1_1Blob__stream__mq__sender__impl.html#aa3116afe888df718c4ae10befcf2a16f" title="See Blob_stream_mq_sender counterpart.">start_send_blob_ops()</a>) through which we invoke the outside event loop's async-wait facility for descriptors/events to our ops.  <a href="classipc_1_1transport_1_1sync__io_1_1Blob__stream__mq__sender__impl.html#a9dca3046bc4d15657c08ac1c06f3b36d">More...</a><br /></td></tr>
<tr class="separator:a9dca3046bc4d15657c08ac1c06f3b36d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a33709386e4339aae663702488cbfe5c7"><td class="memItemLeft" align="right" valign="top">std::optional&lt; flow::async::Single_thread_task_loop &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classipc_1_1transport_1_1sync__io_1_1Blob__stream__mq__sender__impl.html#a33709386e4339aae663702488cbfe5c7">m_blocking_worker</a></td></tr>
<tr class="memdesc:a33709386e4339aae663702488cbfe5c7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Worker thread W always in one of 2 states: idle; or (when <a class="el" href="classipc_1_1transport_1_1sync__io_1_1Blob__stream__mq__sender__impl.html#a32a49dff090ce4b658707e7d9b9036c9" title="The MQ handle adopted by the ctor, through which nb-sends and blocking-waits are executed.">m_mq</a> is in would-block condition) executing an indefinite, interrupting blocking wait for transmissibility of <a class="el" href="classipc_1_1transport_1_1sync__io_1_1Blob__stream__mq__sender__impl.html#a32a49dff090ce4b658707e7d9b9036c9" title="The MQ handle adopted by the ctor, through which nb-sends and blocking-waits are executed.">m_mq</a>.  <a href="classipc_1_1transport_1_1sync__io_1_1Blob__stream__mq__sender__impl.html#a33709386e4339aae663702488cbfe5c7">More...</a><br /></td></tr>
<tr class="separator:a33709386e4339aae663702488cbfe5c7"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="related" name="related"></a>
Related Functions</h2></td></tr>
<tr><td class="ititle" colspan="2"><p >(Note that these are not member functions.) </p>
</td></tr>
<tr class="memitem:a8bc3464c81b40649e99da6ce2ee5f87c"><td class="memTemplParams" colspan="2">template&lt;typename <a class="el" href="classipc_1_1transport_1_1Persistent__mq__handle.html">Persistent_mq_handle</a> &gt; </td></tr>
<tr class="memitem:a8bc3464c81b40649e99da6ce2ee5f87c"><td class="memTemplItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classipc_1_1transport_1_1sync__io_1_1Blob__stream__mq__sender__impl.html#a8bc3464c81b40649e99da6ce2ee5f87c">operator&lt;&lt;</a> (std::ostream &amp;os, const <a class="el" href="classipc_1_1transport_1_1sync__io_1_1Blob__stream__mq__sender__impl.html">Blob_stream_mq_sender_impl</a>&lt; <a class="el" href="classipc_1_1transport_1_1Persistent__mq__handle.html">Persistent_mq_handle</a> &gt; &amp;val)</td></tr>
<tr class="memdesc:a8bc3464c81b40649e99da6ce2ee5f87c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Prints string representation of the given <code><a class="el" href="classipc_1_1transport_1_1sync__io_1_1Blob__stream__mq__sender.html" title="Implements sync_io::Blob_sender concept by using an adopted Persistent_mq_handle MQ handle to an MQ (...">Blob_stream_mq_sender</a></code> to the given <code>ostream</code>.  <a href="classipc_1_1transport_1_1sync__io_1_1Blob__stream__mq__sender__impl.html#a8bc3464c81b40649e99da6ce2ee5f87c">More...</a><br /></td></tr>
<tr class="separator:a8bc3464c81b40649e99da6ce2ee5f87c"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="inherited" name="inherited"></a>
Additional Inherited Members</h2></td></tr>
<tr class="inherit_header pub_static_methods_classipc_1_1transport_1_1Blob__stream__mq__base__impl"><td colspan="2" onclick="javascript:toggleInherit('pub_static_methods_classipc_1_1transport_1_1Blob__stream__mq__base__impl')"><img src="closed.png" alt="-"/>&#160;Static Public Member Functions inherited from <a class="el" href="classipc_1_1transport_1_1Blob__stream__mq__base__impl.html">ipc::transport::Blob_stream_mq_base_impl&lt; Persistent_mq_handle &gt;</a></td></tr>
<tr class="memitem:a8877f75af055ab927a4b4c993f0873a2 inherit pub_static_methods_classipc_1_1transport_1_1Blob__stream__mq__base__impl"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classipc_1_1transport_1_1Blob__stream__mq__base__impl.html#a8877f75af055ab927a4b4c993f0873a2">remove_persistent</a> (flow::log::Logger *logger_ptr, const <a class="el" href="namespaceipc_1_1transport.html#a33de1c256addb3964b839dc2dd407d24">Shared_name</a> &amp;name, <a class="el" href="namespaceipc.html#aa3192e586cc45d3e7c22463bf2760f89">Error_code</a> *err_code)</td></tr>
<tr class="memdesc:a8877f75af055ab927a4b4c993f0873a2 inherit pub_static_methods_classipc_1_1transport_1_1Blob__stream__mq__base__impl"><td class="mdescLeft">&#160;</td><td class="mdescRight">See <a class="el" href="classipc_1_1transport_1_1Blob__stream__mq__base.html" title="Base of Blob_stream_mq_sender and Blob_stream_mq_receiver containing certain static facilities,...">Blob_stream_mq_base</a> counterpart.  <a href="classipc_1_1transport_1_1Blob__stream__mq__base__impl.html#a8877f75af055ab927a4b4c993f0873a2">More...</a><br /></td></tr>
<tr class="separator:a8877f75af055ab927a4b4c993f0873a2 inherit pub_static_methods_classipc_1_1transport_1_1Blob__stream__mq__base__impl"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a88105803396fe1f60faab3b0bad97785 inherit pub_static_methods_classipc_1_1transport_1_1Blob__stream__mq__base__impl"><td class="memTemplParams" colspan="2">template&lt;typename Handle_name_func &gt; </td></tr>
<tr class="memitem:a88105803396fe1f60faab3b0bad97785 inherit pub_static_methods_classipc_1_1transport_1_1Blob__stream__mq__base__impl"><td class="memTemplItemLeft" align="right" valign="top">static void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classipc_1_1transport_1_1Blob__stream__mq__base__impl.html#a88105803396fe1f60faab3b0bad97785">for_each_persistent</a> (const Handle_name_func &amp;handle_name_func)</td></tr>
<tr class="memdesc:a88105803396fe1f60faab3b0bad97785 inherit pub_static_methods_classipc_1_1transport_1_1Blob__stream__mq__base__impl"><td class="mdescLeft">&#160;</td><td class="mdescRight">See <a class="el" href="classipc_1_1transport_1_1Blob__stream__mq__base.html" title="Base of Blob_stream_mq_sender and Blob_stream_mq_receiver containing certain static facilities,...">Blob_stream_mq_base</a> counterpart.  <a href="classipc_1_1transport_1_1Blob__stream__mq__base__impl.html#a88105803396fe1f60faab3b0bad97785">More...</a><br /></td></tr>
<tr class="separator:a88105803396fe1f60faab3b0bad97785 inherit pub_static_methods_classipc_1_1transport_1_1Blob__stream__mq__base__impl"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4776b5f569ccac03eccb3fc2f360fcc9 inherit pub_static_methods_classipc_1_1transport_1_1Blob__stream__mq__base__impl"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classipc_1_1transport_1_1Blob__stream__mq__base__impl.html#aab7c4c91d42c746c93e61eb367572eb1">Auto_closing_mq</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classipc_1_1transport_1_1Blob__stream__mq__base__impl.html#a4776b5f569ccac03eccb3fc2f360fcc9">ensure_unique_peer</a> (flow::log::Logger *logger_ptr, <a class="el" href="classipc_1_1transport_1_1Blob__stream__mq__base__impl.html#a8fac0ed5fff23aa42e0a601db6fee42d">Mq</a> &amp;&amp;mq, bool snd_else_rcv, <a class="el" href="namespaceipc.html#aa3192e586cc45d3e7c22463bf2760f89">Error_code</a> *err_code)</td></tr>
<tr class="memdesc:a4776b5f569ccac03eccb3fc2f360fcc9 inherit pub_static_methods_classipc_1_1transport_1_1Blob__stream__mq__base__impl"><td class="mdescLeft">&#160;</td><td class="mdescRight">Internal helper for <a class="el" href="classipc_1_1transport_1_1Blob__stream__mq__sender.html" title="Implements Blob_sender concept by using an adopted Persistent_mq_handle MQ handle to an MQ (message q...">Blob_stream_mq_sender</a> and <a class="el" href="classipc_1_1transport_1_1Blob__stream__mq__receiver.html" title="Implements Blob_receiver concept by using an adopted Persistent_mq_handle MQ handle to an MQ (message...">Blob_stream_mq_receiver</a> that operates both the start and end of the anti-dupe-endpoint machinery used by those 2 classes to prevent more than 1 <code>_sender</code> and more than 1 <code>_receiver</code> for a given underlying MQ.  <a href="classipc_1_1transport_1_1Blob__stream__mq__base__impl.html#a4776b5f569ccac03eccb3fc2f360fcc9">More...</a><br /></td></tr>
<tr class="separator:a4776b5f569ccac03eccb3fc2f360fcc9 inherit pub_static_methods_classipc_1_1transport_1_1Blob__stream__mq__base__impl"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pro_types_classipc_1_1transport_1_1Blob__stream__mq__base__impl"><td colspan="2" onclick="javascript:toggleInherit('pro_types_classipc_1_1transport_1_1Blob__stream__mq__base__impl')"><img src="closed.png" alt="-"/>&#160;Protected Types inherited from <a class="el" href="classipc_1_1transport_1_1Blob__stream__mq__base__impl.html">ipc::transport::Blob_stream_mq_base_impl&lt; Persistent_mq_handle &gt;</a></td></tr>
<tr class="memitem:a2e46672d40fbf38cf6054edfad69e705 inherit pro_types_classipc_1_1transport_1_1Blob__stream__mq__base__impl"><td class="memItemLeft" align="right" valign="top">enum class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classipc_1_1transport_1_1Blob__stream__mq__base__impl.html#a2e46672d40fbf38cf6054edfad69e705">Control_cmd</a> : int64_t { <a class="el" href="classipc_1_1transport_1_1Blob__stream__mq__base__impl.html#a2e46672d40fbf38cf6054edfad69e705ad584ea5a5dbf02d7e925adb912f3051a">S_END_SENDING</a>
, <a class="el" href="classipc_1_1transport_1_1Blob__stream__mq__base__impl.html#a2e46672d40fbf38cf6054edfad69e705ad79c2ad1486703a583c7516555a907e9">S_PING</a>
, <a class="el" href="classipc_1_1transport_1_1Blob__stream__mq__base__impl.html#a2e46672d40fbf38cf6054edfad69e705a6fba12db09e5bebfaa04f6372c41c2cf">S_END_SENTINEL</a>
 }</td></tr>
<tr class="memdesc:a2e46672d40fbf38cf6054edfad69e705"><td class="mdescLeft">&#160;</td><td class="mdescRight">If <a class="el" href="classipc_1_1transport_1_1Blob__stream__mq__sender__impl.html" title="Internal, non-movable pImpl-lite implementation of Blob_stream_mq_sender class template.">Blob_stream_mq_sender_impl</a> sends an empty message, in NORMAL state <a class="el" href="classipc_1_1transport_1_1Blob__stream__mq__receiver.html" title="Implements Blob_receiver concept by using an adopted Persistent_mq_handle MQ handle to an MQ (message...">Blob_stream_mq_receiver</a> enters CONTROL state and expects one of these values in the next message, to react as documented per <code>enum</code> value (upon re-entering NORMAL state).  <a href="classipc_1_1transport_1_1Blob__stream__mq__base__impl.html#a2e46672d40fbf38cf6054edfad69e705">More...</a><br /></td></tr>
<tr class="separator:a2e46672d40fbf38cf6054edfad69e705 inherit pro_types_classipc_1_1transport_1_1Blob__stream__mq__base__impl"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><div class="compoundTemplParams">template&lt;typename <a class="el" href="classipc_1_1transport_1_1Persistent__mq__handle.html">Persistent_mq_handle</a>&gt;<br />
class ipc::transport::sync_io::Blob_stream_mq_sender_impl&lt; Persistent_mq_handle &gt;</div><p >Internal, non-movable pImpl-lite implementation of <a class="el" href="classipc_1_1transport_1_1sync__io_1_1Blob__stream__mq__sender.html" title="Implements sync_io::Blob_sender concept by using an adopted Persistent_mq_handle MQ handle to an MQ (...">sync_io::Blob_stream_mq_sender</a> class template. </p>
<p >In and of itself it would have been directly and publicly usable; however <a class="el" href="classipc_1_1transport_1_1sync__io_1_1Blob__stream__mq__sender.html" title="Implements sync_io::Blob_sender concept by using an adopted Persistent_mq_handle MQ handle to an MQ (...">Blob_stream_mq_sender</a> adds move semantics which are essential to cooperation with the rest of the API, <a class="el" href="classipc_1_1transport_1_1Channel.html" title="Peer to a bundle of 1-2 full-duplex pipe(s), one for transmitting unstructured binary blobs; the othe...">Channel</a> in particular.</p>
<dl class="section see"><dt>See also</dt><dd>All discussion of the public API is in <a class="el" href="classipc_1_1transport_1_1sync__io_1_1Blob__stream__mq__sender.html" title="Implements sync_io::Blob_sender concept by using an adopted Persistent_mq_handle MQ handle to an MQ (...">Blob_stream_mq_sender</a> doc header; that class template forwards to this one. All discussion of pImpl-lite-related notions is also there. See that doc header first please. Then come back here.</dd></dl>
<h3>Impl design</h3>
<p >Here's the thing. All the <code>_sender</code> and <code>_receiver</code> stuff historically was written first in what is now <a class="el" href="classipc_1_1transport_1_1sync__io_1_1Native__socket__stream_1_1Impl.html" title="Internal, non-movable pImpl implementation of sync_io::Native_socket_stream class.">sync_io::Native_socket_stream::Impl</a>. Next, this MQ stuff was written to implement (basically) the same concepts. So everything is explained, first, in <a class="el" href="classipc_1_1transport_1_1sync__io_1_1Native__socket__stream_1_1Impl.html" title="Internal, non-movable pImpl implementation of sync_io::Native_socket_stream class.">sync_io::Native_socket_stream::Impl</a>. Next I (ygoldfel) wrote each of <code>*this</code> and <a class="el" href="classipc_1_1transport_1_1sync__io_1_1Blob__stream__mq__receiver__impl.html" title="Internal, non-movable pImpl-lite implementation of sync_io::Blob_stream_mq_receiver class template.">Blob_stream_mq_receiver_impl</a>. Therefore:</p><ul>
<li><code>*this</code> impl is similar to the outgoing-direction, PEER-state logic in that socket-stream <code>Impl</code> class.</li>
<li>And accordingly for incoming-direction and <code><a class="el" href="classipc_1_1transport_1_1sync__io_1_1Blob__stream__mq__receiver__impl.html" title="Internal, non-movable pImpl-lite implementation of sync_io::Blob_stream_mq_receiver class template.">Blob_stream_mq_receiver_impl</a></code>.</li>
</ul>
<p >Therefore we will only explain here the differences between that socket-stream out-pipe algorithms and <code>*this</code> impl. Before going into it more consider these points:</p><ul>
<li>Socket-stream has to worry about both directions <em>and</em> (some) interaction between the two (even though it is full-duplex). We do not. There are no mutual concurrency issues to speak of in particular.</li>
<li>Socket-stream has to worry about going from NULL state to PEER state via CONNECTING (optionally) &ndash; <code>sync_connect()</code> at least. We do not: the <code>_impl</code> is always in PEER state (unless ctor failed, but that's not interesting).</li>
<li>Socket-stream must be able to transmit <code>Native_handle</code>s, and when applicable they correspond in a tricky way to byte 1 of the containing send/receive call. We do not transmit them &ndash; just blobs.</li>
<li>Socket-stream is operating over a medium that lacks message boundaries; so it must worry about transmitting only part of a payload, etc. We do not: a low-level message either goes through, or it does not (would-block). A user message is 1-1 with a low-level message; so we need not transmit length prefixes. There are 2 exceptions:<ul>
<li>An auto-ping is a special message. We express it as an "escape" low-level message (0-length &ndash; as a user message must not be 0-length) followed by an encoded enumeration value in the following message.</li>
<li>A graceful-close is a special message. It is a similarly escaped enumeration value (2 low-level messages).</li>
</ul>
</li>
</ul>
<p >I (ygoldfel) could find no way to reuse code between the 2 counterparts despite similarities. Some comments and some code <em>are</em> repeated, but they are also different enough to where it couldn't really be avoided. That said: if you have a reason to understand <code><a class="el" href="classipc_1_1transport_1_1sync__io_1_1Native__socket__stream_1_1Impl.html" title="Internal, non-movable pImpl implementation of sync_io::Native_socket_stream class.">Native_socket_stream::Impl</a></code> specifically first, then coming back here afterward should be a piece of cake.</p>
<p >If not, due to the simplified/reduced purview of a <code>*this</code>, it should be quite doable to follow the logic. I won't pontificate with some overview beyond the above. Simply grok the following simple protocol, then the <code><a class="el" href="namespaceipc_1_1transport_1_1sync__io.html" title="sync_io-pattern counterparts to async-I/O-pattern object types in parent namespace ipc::transport.">sync_io</a></code> pattern (<a class="el" href="namespaceipc_1_1util_1_1sync__io.html" title="Contains common code, as well as important explanatory documentation in the following text,...">util::sync_io</a> doc header) &ndash; and then jump into the code.</p>
<p >(For that last part, we recommend starting with the data member doc headers.)</p>
<p >So, the protocol:</p>
<p >Two states: steady state, CONTROL state. In steady state (default) each user message corresponds to a message over the MQ. By the concept, these cannot be empty. When it is necessary to send an auto-ping (<a class="el" href="classipc_1_1transport_1_1sync__io_1_1Blob__stream__mq__sender__impl.html#a19e169b59c90ceac14671aa324a00649" title="See Blob_stream_mq_sender counterpart, but assuming PEER state.">auto_ping()</a> and then periodically as needed), we enter CONTROL state, sending an empty message, then <code>Control_cmd::S_PING</code> in the next message, which enters steady state again. Lastly, <code>*end_sending()</code> means we enter CONTROL state similarly, then send <code>Control_cmd::S_END_SENDING</code> in the next message, which enters steady state again.</p>
<h3>Protocol negotiation</h3>
<p >This adds a bit of stuff onto the above protocol. It is very simple; please see <a class="el" href="classipc_1_1transport_1_1Protocol__negotiator.html" title="A simple state machine that, assuming the opposide side of a comm pathway uses an equivalent state ma...">Protocol_negotiator</a> doc header; we use that convention. Moreover, since this is the init version (version 1) of the protocol, we need not worry about speaking more than one version. So all we do is send the version ahead of the first payload that would otherwise be sent for any reason (user message from <a class="el" href="classipc_1_1transport_1_1sync__io_1_1Blob__stream__mq__sender__impl.html#aba05c51d1033a4ea4ca03679f2fa1f8c" title="See Blob_stream_mq_sender counterpart, but assuming PEER state.">send_blob()</a>, end-sending token from <code>*end_sending()</code>, or ping from <a class="el" href="classipc_1_1transport_1_1sync__io_1_1Blob__stream__mq__sender__impl.html#a19e169b59c90ceac14671aa324a00649" title="See Blob_stream_mq_sender counterpart, but assuming PEER state.">auto_ping()</a>, as of this writing), as a special CONTROL message that encodes the value <code>-1</code>, meaning version 1 (as the true <code>Control_cmd enum</code> values would be 0, 1, etc.). Conversely <a class="el" href="classipc_1_1transport_1_1sync__io_1_1Blob__stream__mq__receiver__impl.html" title="Internal, non-movable pImpl-lite implementation of sync_io::Blob_stream_mq_receiver class template.">Blob_stream_mq_receiver_impl</a> expects the first message it does receive to be that CONTROL message encoding a version number; but that's not our concern here, as we are only the outgoing-direction class.</p>
<dl class="section note"><dt>Note</dt><dd>It is very tempting to do that initial send in lazy fashion: meaning, about to send the first "real" payload? OK, then pre-pend the negotiation message. However this can create trouble in the future, if a future protocol wants to be backwards-compatible (support more than 2 protocol versions): we'll need to have received the opposing guy's preferred version, and thus determined which version to speak, before sending further (non-negotiation) messages. Bottom line... the initial send shall occur as soon as we are operational (start_send_native_handle_ops()).</dd></dl>
<p>After that, we just speak what we speak... which is the protocol's initial version &ndash; as there is no other version for us. (The opposing-side peer is responsible for closing the MQs, if it is unable to speak version 1.)</p>
<p >If we do add protocol version 2, etc., in the future, then things <em>might</em> become somewhat more complex (but even then not necessarily so). This is discussed in the <code><a class="el" href="classipc_1_1transport_1_1Protocol__negotiator.html" title="A simple state machine that, assuming the opposide side of a comm pathway uses an equivalent state ma...">Protocol_negotiator</a> m_protocol_negotiator</code> member doc header.</p>
<dl class="section note"><dt>Note</dt><dd>We suggest that if version 2, etc., is/are added, then the above notes be kept more or less intact; then add updates to show changes. This will provide a good overview of how the protocol evolved; and our backwards-compatibility story (even if we decide to have no backwards-compatibility).</dd></dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname"><a class="el" href="classipc_1_1transport_1_1Persistent__mq__handle.html" title="A documentation-only concept defining the behavior of an object representing a light-weight handle to...">Persistent_mq_handle</a></td><td>See <a class="el" href="classipc_1_1transport_1_1Persistent__mq__handle.html" title="A documentation-only concept defining the behavior of an object representing a light-weight handle to...">Persistent_mq_handle</a> concept doc header. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="sync__io_2detail_2blob__stream__mq__snd__impl_8hpp_source.html#l00121">121</a> of file <a class="el" href="sync__io_2detail_2blob__stream__mq__snd__impl_8hpp_source.html">blob_stream_mq_snd_impl.hpp</a>.</p>
</div><h2 class="groupheader">Member Typedef Documentation</h2>
<a id="a5a36bff3c8346f952b154e081817f53c" name="a5a36bff3c8346f952b154e081817f53c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5a36bff3c8346f952b154e081817f53c">&#9670;&nbsp;</a></span>Base</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename <a class="el" href="classipc_1_1transport_1_1Persistent__mq__handle.html">Persistent_mq_handle</a> &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classipc_1_1transport_1_1sync__io_1_1Blob__stream__mq__sender__impl.html">ipc::transport::sync_io::Blob_stream_mq_sender_impl</a>&lt; <a class="el" href="classipc_1_1transport_1_1Persistent__mq__handle.html">Persistent_mq_handle</a> &gt;::Base =  <a class="el" href="classipc_1_1transport_1_1Blob__stream__mq__base__impl.html">Blob_stream_mq_base_impl</a>&lt;<a class="el" href="classipc_1_1transport_1_1Persistent__mq__handle.html">Persistent_mq_handle</a>&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Short-hand for our base with <code>static</code> goodies at least. </p>

<p class="definition">Definition at line <a class="el" href="sync__io_2detail_2blob__stream__mq__snd__impl_8hpp_source.html#l00130">130</a> of file <a class="el" href="sync__io_2detail_2blob__stream__mq__snd__impl_8hpp_source.html">blob_stream_mq_snd_impl.hpp</a>.</p>

</div>
</div>
<a id="a62ce20c2a91367330b92c8b392524b32" name="a62ce20c2a91367330b92c8b392524b32"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a62ce20c2a91367330b92c8b392524b32">&#9670;&nbsp;</a></span>Control_cmd</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename <a class="el" href="classipc_1_1transport_1_1Persistent__mq__handle.html">Persistent_mq_handle</a> &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classipc_1_1transport_1_1sync__io_1_1Blob__stream__mq__sender__impl.html">ipc::transport::sync_io::Blob_stream_mq_sender_impl</a>&lt; <a class="el" href="classipc_1_1transport_1_1Persistent__mq__handle.html">Persistent_mq_handle</a> &gt;::Control_cmd =  typename <a class="el" href="classipc_1_1transport_1_1Blob__stream__mq__base__impl.html#a2e46672d40fbf38cf6054edfad69e705">Base::Control_cmd</a></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Short-hand for <a class="el" href="classipc_1_1transport_1_1Blob__stream__mq__base__impl.html#a2e46672d40fbf38cf6054edfad69e705" title="If Blob_stream_mq_sender_impl sends an empty message, in NORMAL state Blob_stream_mq_receiver enters ...">Blob_stream_mq_base_impl::Control_cmd</a>. </p>

<p class="definition">Definition at line <a class="el" href="sync__io_2detail_2blob__stream__mq__snd__impl_8hpp_source.html#l00274">274</a> of file <a class="el" href="sync__io_2detail_2blob__stream__mq__snd__impl_8hpp_source.html">blob_stream_mq_snd_impl.hpp</a>.</p>

</div>
</div>
<a id="a0e32cf8f7e9d6040925bcaf9da36515b" name="a0e32cf8f7e9d6040925bcaf9da36515b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0e32cf8f7e9d6040925bcaf9da36515b">&#9670;&nbsp;</a></span>Mq</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename <a class="el" href="classipc_1_1transport_1_1Persistent__mq__handle.html">Persistent_mq_handle</a> &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classipc_1_1transport_1_1sync__io_1_1Blob__stream__mq__sender__impl.html">ipc::transport::sync_io::Blob_stream_mq_sender_impl</a>&lt; <a class="el" href="classipc_1_1transport_1_1Persistent__mq__handle.html">Persistent_mq_handle</a> &gt;::Mq =  typename <a class="el" href="classipc_1_1transport_1_1Blob__stream__mq__base__impl.html#a8fac0ed5fff23aa42e0a601db6fee42d">Base::Mq</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Short-hand for template arg for underlying MQ handle type. </p>

<p class="definition">Definition at line <a class="el" href="sync__io_2detail_2blob__stream__mq__snd__impl_8hpp_source.html#l00133">133</a> of file <a class="el" href="sync__io_2detail_2blob__stream__mq__snd__impl_8hpp_source.html">blob_stream_mq_snd_impl.hpp</a>.</p>

</div>
</div>
<h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="a71caa7f5002886b2c0717645945d7144" name="a71caa7f5002886b2c0717645945d7144"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a71caa7f5002886b2c0717645945d7144">&#9670;&nbsp;</a></span>Blob_stream_mq_sender_impl()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename <a class="el" href="classipc_1_1transport_1_1Persistent__mq__handle.html">Persistent_mq_handle</a> &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classipc_1_1transport_1_1sync__io_1_1Blob__stream__mq__sender__impl.html">ipc::transport::sync_io::Blob_stream_mq_sender_impl</a>&lt; <a class="el" href="classipc_1_1transport_1_1Persistent__mq__handle.html">Persistent_mq_handle</a> &gt;::Blob_stream_mq_sender_impl </td>
          <td>(</td>
          <td class="paramtype">flow::log::Logger *&#160;</td>
          <td class="paramname"><em>logger_ptr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceipc_1_1util.html#ae6ac47812a90d1287c61e0b7de7bc4f5">util::String_view</a>&#160;</td>
          <td class="paramname"><em>nickname_str</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classipc_1_1transport_1_1Blob__stream__mq__base__impl.html#a8fac0ed5fff23aa42e0a601db6fee42d">Mq</a> &amp;&amp;&#160;</td>
          <td class="paramname"><em>mq_moved</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceipc.html#aa3192e586cc45d3e7c22463bf2760f89">Error_code</a> *&#160;</td>
          <td class="paramname"><em>err_code</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">explicit</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>See <a class="el" href="classipc_1_1transport_1_1sync__io_1_1Blob__stream__mq__sender.html" title="Implements sync_io::Blob_sender concept by using an adopted Persistent_mq_handle MQ handle to an MQ (...">Blob_stream_mq_sender</a> counterpart. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">logger_ptr</td><td>See <a class="el" href="classipc_1_1transport_1_1sync__io_1_1Blob__stream__mq__sender.html" title="Implements sync_io::Blob_sender concept by using an adopted Persistent_mq_handle MQ handle to an MQ (...">Blob_stream_mq_sender</a> counterpart. </td></tr>
    <tr><td class="paramname">mq_moved</td><td>See <a class="el" href="classipc_1_1transport_1_1sync__io_1_1Blob__stream__mq__sender.html" title="Implements sync_io::Blob_sender concept by using an adopted Persistent_mq_handle MQ handle to an MQ (...">Blob_stream_mq_sender</a> counterpart. </td></tr>
    <tr><td class="paramname">nickname_str</td><td>See <a class="el" href="classipc_1_1transport_1_1sync__io_1_1Blob__stream__mq__sender.html" title="Implements sync_io::Blob_sender concept by using an adopted Persistent_mq_handle MQ handle to an MQ (...">Blob_stream_mq_sender</a> counterpart. </td></tr>
    <tr><td class="paramname">err_code</td><td>See <a class="el" href="classipc_1_1transport_1_1sync__io_1_1Blob__stream__mq__sender.html" title="Implements sync_io::Blob_sender concept by using an adopted Persistent_mq_handle MQ handle to an MQ (...">Blob_stream_mq_sender</a> counterpart. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="sync__io_2detail_2blob__stream__mq__snd__impl_8hpp_source.html#l00640">640</a> of file <a class="el" href="sync__io_2detail_2blob__stream__mq__snd__impl_8hpp_source.html">blob_stream_mq_snd_impl.hpp</a>.</p>

<p class="reference">References <a class="el" href="asio__waitable__native__hndl_8cpp_source.html#l00065">ipc::util::sync_io::Asio_waitable_native_handle::assign()</a>, <a class="el" href="blob__stream__mq__impl_8hpp_source.html#l00219">ipc::transport::Blob_stream_mq_base_impl&lt; Persistent_mq_handle &gt;::ensure_unique_peer()</a>, <a class="el" href="sync__io_2detail_2blob__stream__mq__snd__impl_8hpp_source.html#l00632">ipc::transport::sync_io::Blob_stream_mq_sender_impl&lt; Persistent_mq_handle &gt;::m_blocking_worker</a>, <a class="el" href="sync__io_2detail_2blob__stream__mq__snd__impl_8hpp_source.html#l00533">ipc::transport::sync_io::Blob_stream_mq_sender_impl&lt; Persistent_mq_handle &gt;::m_ev_wait_hndl_mq</a>, <a class="el" href="sync__io_2detail_2blob__stream__mq__snd__impl_8hpp_source.html#l00491">ipc::transport::sync_io::Blob_stream_mq_sender_impl&lt; Persistent_mq_handle &gt;::m_mq</a>, <a class="el" href="sync__io_2detail_2blob__stream__mq__snd__impl_8hpp_source.html#l00511">ipc::transport::sync_io::Blob_stream_mq_sender_impl&lt; Persistent_mq_handle &gt;::m_mq_ready_reader</a>, <a class="el" href="sync__io_2detail_2blob__stream__mq__snd__impl_8hpp_source.html#l00522">ipc::transport::sync_io::Blob_stream_mq_sender_impl&lt; Persistent_mq_handle &gt;::m_mq_ready_writer</a>, <a class="el" href="sync__io_2detail_2blob__stream__mq__snd__impl_8hpp_source.html#l00456">ipc::transport::sync_io::Blob_stream_mq_sender_impl&lt; Persistent_mq_handle &gt;::m_nb_task_engine</a>, <a class="el" href="sync__io_2detail_2blob__stream__mq__snd__impl_8hpp_source.html#l00557">ipc::transport::sync_io::Blob_stream_mq_sender_impl&lt; Persistent_mq_handle &gt;::m_pending_err_code</a>, and <a class="el" href="sync__io_2detail_2blob__stream__mq__snd__impl_8hpp_source.html#l01696">ipc::transport::sync_io::Blob_stream_mq_sender_impl&lt; Persistent_mq_handle &gt;::nickname()</a>.</p>
<div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="classipc_1_1transport_1_1sync__io_1_1Blob__stream__mq__sender__impl_a71caa7f5002886b2c0717645945d7144_cgraph.svg" width="876" height="203"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe>
</div>
</div>

</div>
</div>
<a id="afe0b25b57614615d0672c40cf8f58170" name="afe0b25b57614615d0672c40cf8f58170"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afe0b25b57614615d0672c40cf8f58170">&#9670;&nbsp;</a></span>~Blob_stream_mq_sender_impl()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename <a class="el" href="classipc_1_1transport_1_1Persistent__mq__handle.html">Persistent_mq_handle</a> &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classipc_1_1transport_1_1sync__io_1_1Blob__stream__mq__sender__impl.html">ipc::transport::sync_io::Blob_stream_mq_sender_impl</a>&lt; <a class="el" href="classipc_1_1transport_1_1Persistent__mq__handle.html">Persistent_mq_handle</a> &gt;::~<a class="el" href="classipc_1_1transport_1_1sync__io_1_1Blob__stream__mq__sender__impl.html">Blob_stream_mq_sender_impl</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>See <a class="el" href="classipc_1_1transport_1_1sync__io_1_1Blob__stream__mq__sender.html" title="Implements sync_io::Blob_sender concept by using an adopted Persistent_mq_handle MQ handle to an MQ (...">Blob_stream_mq_sender</a> counterpart. </p>

<p class="definition">Definition at line <a class="el" href="sync__io_2detail_2blob__stream__mq__snd__impl_8hpp_source.html#l00753">753</a> of file <a class="el" href="sync__io_2detail_2blob__stream__mq__snd__impl_8hpp_source.html">blob_stream_mq_snd_impl.hpp</a>.</p>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="a0763f3a2891a2a0e41f3ff15f06db7cc" name="a0763f3a2891a2a0e41f3ff15f06db7cc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0763f3a2891a2a0e41f3ff15f06db7cc">&#9670;&nbsp;</a></span>absolute_name()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename <a class="el" href="classipc_1_1transport_1_1Persistent__mq__handle.html">Persistent_mq_handle</a> &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="namespaceipc_1_1transport.html#a33de1c256addb3964b839dc2dd407d24">Shared_name</a> &amp; <a class="el" href="classipc_1_1transport_1_1sync__io_1_1Blob__stream__mq__sender__impl.html">ipc::transport::sync_io::Blob_stream_mq_sender_impl</a>&lt; <a class="el" href="classipc_1_1transport_1_1Persistent__mq__handle.html">Persistent_mq_handle</a> &gt;::absolute_name</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>See <a class="el" href="classipc_1_1transport_1_1sync__io_1_1Blob__stream__mq__sender.html" title="Implements sync_io::Blob_sender concept by using an adopted Persistent_mq_handle MQ handle to an MQ (...">Blob_stream_mq_sender</a> counterpart, but assuming PEER state. </p>
<dl class="section return"><dt>Returns</dt><dd>See <a class="el" href="classipc_1_1transport_1_1sync__io_1_1Blob__stream__mq__sender.html" title="Implements sync_io::Blob_sender concept by using an adopted Persistent_mq_handle MQ handle to an MQ (...">Blob_stream_mq_sender</a> counterpart. </dd></dl>

<p class="definition">Definition at line <a class="el" href="sync__io_2detail_2blob__stream__mq__snd__impl_8hpp_source.html#l01690">1690</a> of file <a class="el" href="sync__io_2detail_2blob__stream__mq__snd__impl_8hpp_source.html">blob_stream_mq_snd_impl.hpp</a>.</p>

<p class="reference">Referenced by <a class="el" href="sync__io_2detail_2blob__stream__mq__snd__impl_8hpp_source.html#l01702">ipc::transport::sync_io::Blob_stream_mq_sender_impl&lt; Persistent_mq_handle &gt;::operator&lt;&lt;()</a>.</p>
<div class="dynheader">
Here is the caller graph for this function:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="classipc_1_1transport_1_1sync__io_1_1Blob__stream__mq__sender__impl_a0763f3a2891a2a0e41f3ff15f06db7cc_icgraph.svg" width="414" height="59"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe>
</div>
</div>

</div>
</div>
<a id="a4709b00fb1a8fc0ea63535d0a47f15f0" name="a4709b00fb1a8fc0ea63535d0a47f15f0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4709b00fb1a8fc0ea63535d0a47f15f0">&#9670;&nbsp;</a></span>async_end_sending()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename <a class="el" href="classipc_1_1transport_1_1Persistent__mq__handle.html">Persistent_mq_handle</a> &gt; </div>
<div class="memtemplate">
template&lt;typename Task_err &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classipc_1_1transport_1_1sync__io_1_1Blob__stream__mq__sender__impl.html">ipc::transport::sync_io::Blob_stream_mq_sender_impl</a>&lt; <a class="el" href="classipc_1_1transport_1_1Persistent__mq__handle.html">Persistent_mq_handle</a> &gt;::async_end_sending </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespaceipc.html#aa3192e586cc45d3e7c22463bf2760f89">Error_code</a> *&#160;</td>
          <td class="paramname"><em>sync_err_code</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Task_err &amp;&amp;&#160;</td>
          <td class="paramname"><em>on_done_func</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>See <a class="el" href="classipc_1_1transport_1_1sync__io_1_1Blob__stream__mq__sender.html" title="Implements sync_io::Blob_sender concept by using an adopted Persistent_mq_handle MQ handle to an MQ (...">Blob_stream_mq_sender</a> counterpart, but assuming PEER state. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">sync_err_code</td><td>See <a class="el" href="classipc_1_1transport_1_1sync__io_1_1Blob__stream__mq__sender.html" title="Implements sync_io::Blob_sender concept by using an adopted Persistent_mq_handle MQ handle to an MQ (...">Blob_stream_mq_sender</a> counterpart. </td></tr>
    <tr><td class="paramname">on_done_func</td><td>See <a class="el" href="classipc_1_1transport_1_1sync__io_1_1Blob__stream__mq__sender.html" title="Implements sync_io::Blob_sender concept by using an adopted Persistent_mq_handle MQ handle to an MQ (...">Blob_stream_mq_sender</a> counterpart. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>See <a class="el" href="classipc_1_1transport_1_1sync__io_1_1Blob__stream__mq__sender.html" title="Implements sync_io::Blob_sender concept by using an adopted Persistent_mq_handle MQ handle to an MQ (...">Blob_stream_mq_sender</a> counterpart. </dd></dl>

<p class="definition">Definition at line <a class="el" href="sync__io_2detail_2blob__stream__mq__snd__impl_8hpp_source.html#l01048">1048</a> of file <a class="el" href="sync__io_2detail_2blob__stream__mq__snd__impl_8hpp_source.html">blob_stream_mq_snd_impl.hpp</a>.</p>

</div>
</div>
<a id="adc7d43cbe05d4ad239d7abcf010955db" name="adc7d43cbe05d4ad239d7abcf010955db"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adc7d43cbe05d4ad239d7abcf010955db">&#9670;&nbsp;</a></span>async_end_sending_impl()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename <a class="el" href="classipc_1_1transport_1_1Persistent__mq__handle.html">Persistent_mq_handle</a> &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classipc_1_1transport_1_1sync__io_1_1Blob__stream__mq__sender__impl.html">ipc::transport::sync_io::Blob_stream_mq_sender_impl</a>&lt; <a class="el" href="classipc_1_1transport_1_1Persistent__mq__handle.html">Persistent_mq_handle</a> &gt;::async_end_sending_impl </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespaceipc.html#aa3192e586cc45d3e7c22463bf2760f89">Error_code</a> *&#160;</td>
          <td class="paramname"><em>sync_err_code_ptr_or_null</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">flow::async::Task_asio_err &amp;&amp;&#160;</td>
          <td class="paramname"><em>on_done_func_or_empty</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><code>*end_sending()</code> body. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">sync_err_code_ptr_or_null</td><td>See <a class="el" href="classipc_1_1transport_1_1sync__io_1_1Blob__stream__mq__sender__impl.html#a4709b00fb1a8fc0ea63535d0a47f15f0" title="See Blob_stream_mq_sender counterpart, but assuming PEER state.">async_end_sending()</a>. Null if and only if invoked from the no-arg <a class="el" href="classipc_1_1transport_1_1sync__io_1_1Blob__stream__mq__sender__impl.html#a66bdd766d92029aa20d50b97edae0ce5" title="See Blob_stream_mq_sender counterpart, but assuming PEER state.">end_sending()</a>. Note well: even if <code>async_end_sending(sync_err_code = nullptr)</code> was used, this must not be null. </td></tr>
    <tr><td class="paramname">on_done_func_or_empty</td><td>See <a class="el" href="classipc_1_1transport_1_1sync__io_1_1Blob__stream__mq__sender__impl.html#a4709b00fb1a8fc0ea63535d0a47f15f0" title="See Blob_stream_mq_sender counterpart, but assuming PEER state.">async_end_sending()</a>. <code>.empty() == true</code> if and only if invoked from the no-arg <a class="el" href="classipc_1_1transport_1_1sync__io_1_1Blob__stream__mq__sender__impl.html#a66bdd766d92029aa20d50b97edae0ce5" title="See Blob_stream_mq_sender counterpart, but assuming PEER state.">end_sending()</a>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>See <a class="el" href="classipc_1_1transport_1_1sync__io_1_1Blob__stream__mq__sender__impl.html#a4709b00fb1a8fc0ea63535d0a47f15f0" title="See Blob_stream_mq_sender counterpart, but assuming PEER state.">async_end_sending()</a> and <a class="el" href="classipc_1_1transport_1_1sync__io_1_1Blob__stream__mq__sender__impl.html#a66bdd766d92029aa20d50b97edae0ce5" title="See Blob_stream_mq_sender counterpart, but assuming PEER state.">end_sending()</a>. </dd></dl>

<p class="definition">Definition at line <a class="el" href="sync__io_2detail_2blob__stream__mq__snd__impl_8hpp_source.html#l01074">1074</a> of file <a class="el" href="sync__io_2detail_2blob__stream__mq__snd__impl_8hpp_source.html">blob_stream_mq_snd_impl.hpp</a>.</p>

<p class="reference">References <a class="el" href="namespaceipc_1_1transport_1_1error.html#adfef15ef4e76cc55d652fbd9c2797297aa667487757f9d6300f6888bac40bcc24">ipc::transport::error::S_SYNC_IO_WOULD_BLOCK</a>.</p>

</div>
</div>
<a id="a57737a56544ffac3cfd8d130663bb6ce" name="a57737a56544ffac3cfd8d130663bb6ce"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a57737a56544ffac3cfd8d130663bb6ce">&#9670;&nbsp;</a></span>async_write_q_head_payload()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename <a class="el" href="classipc_1_1transport_1_1Persistent__mq__handle.html">Persistent_mq_handle</a> &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classipc_1_1transport_1_1sync__io_1_1Blob__stream__mq__sender__impl.html">ipc::transport::sync_io::Blob_stream_mq_sender_impl</a>&lt; <a class="el" href="classipc_1_1transport_1_1Persistent__mq__handle.html">Persistent_mq_handle</a> &gt;::async_write_q_head_payload</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Initiates async-write over <a class="el" href="classipc_1_1transport_1_1sync__io_1_1Blob__stream__mq__sender__impl.html#a32a49dff090ce4b658707e7d9b9036c9" title="The MQ handle adopted by the ctor, through which nb-sends and blocking-waits are executed.">m_mq</a> of the low-level payload at the head of out-queue <a class="el" href="classipc_1_1transport_1_1sync__io_1_1Blob__stream__mq__sender__impl.html#aaecb4615ae4d9fbf82ab2c195ada47cf" title="Queue storing (at head) the currently in-progress async write-op of a Snd_low_lvl_payload; followed b...">m_pending_payloads_q</a>, with completion handler also inside this method. </p>
<p >The first step of this is an async-wait via <code><a class="el" href="namespaceipc_1_1transport_1_1sync__io.html" title="sync_io-pattern counterparts to async-I/O-pattern object types in parent namespace ipc::transport.">sync_io</a></code> pattern. </p>

<p class="definition">Definition at line <a class="el" href="sync__io_2detail_2blob__stream__mq__snd__impl_8hpp_source.html#l01507">1507</a> of file <a class="el" href="sync__io_2detail_2blob__stream__mq__snd__impl_8hpp_source.html">blob_stream_mq_snd_impl.hpp</a>.</p>

<p class="reference">References <a class="el" href="ipc__core_2src_2ipc_2util_2detail_2util_8cpp_source.html#l00096">ipc::util::pipe_consume()</a>, <a class="el" href="ipc__core_2src_2ipc_2util_2detail_2util_8cpp_source.html#l00067">ipc::util::pipe_produce()</a>, and <a class="el" href="namespaceipc_1_1transport_1_1error.html#adfef15ef4e76cc55d652fbd9c2797297a291f8a813c292ccdb475c345181653ac">ipc::transport::error::S_INTERRUPTED</a>.</p>
<div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="classipc_1_1transport_1_1sync__io_1_1Blob__stream__mq__sender__impl_a57737a56544ffac3cfd8d130663bb6ce_cgraph.svg" width="387" height="83"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe>
</div>
</div>

</div>
</div>
<a id="a19e169b59c90ceac14671aa324a00649" name="a19e169b59c90ceac14671aa324a00649"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a19e169b59c90ceac14671aa324a00649">&#9670;&nbsp;</a></span>auto_ping()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename <a class="el" href="classipc_1_1transport_1_1Persistent__mq__handle.html">Persistent_mq_handle</a> &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classipc_1_1transport_1_1sync__io_1_1Blob__stream__mq__sender__impl.html">ipc::transport::sync_io::Blob_stream_mq_sender_impl</a>&lt; <a class="el" href="classipc_1_1transport_1_1Persistent__mq__handle.html">Persistent_mq_handle</a> &gt;::auto_ping </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespaceipc_1_1util.html#ac66141280c3b7295a86b65209f31cc58">util::Fine_duration</a>&#160;</td>
          <td class="paramname"><em>period</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>See <a class="el" href="classipc_1_1transport_1_1sync__io_1_1Blob__stream__mq__sender.html" title="Implements sync_io::Blob_sender concept by using an adopted Persistent_mq_handle MQ handle to an MQ (...">Blob_stream_mq_sender</a> counterpart, but assuming PEER state. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">period</td><td>See <a class="el" href="classipc_1_1transport_1_1sync__io_1_1Blob__stream__mq__sender.html" title="Implements sync_io::Blob_sender concept by using an adopted Persistent_mq_handle MQ handle to an MQ (...">Blob_stream_mq_sender</a> counterpart. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>See <a class="el" href="classipc_1_1transport_1_1sync__io_1_1Blob__stream__mq__sender.html" title="Implements sync_io::Blob_sender concept by using an adopted Persistent_mq_handle MQ handle to an MQ (...">Blob_stream_mq_sender</a> counterpart. </dd></dl>

<p class="definition">Definition at line <a class="el" href="sync__io_2detail_2blob__stream__mq__snd__impl_8hpp_source.html#l01171">1171</a> of file <a class="el" href="sync__io_2detail_2blob__stream__mq__snd__impl_8hpp_source.html">blob_stream_mq_snd_impl.hpp</a>.</p>

</div>
</div>
<a id="a66bdd766d92029aa20d50b97edae0ce5" name="a66bdd766d92029aa20d50b97edae0ce5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a66bdd766d92029aa20d50b97edae0ce5">&#9670;&nbsp;</a></span>end_sending()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename <a class="el" href="classipc_1_1transport_1_1Persistent__mq__handle.html">Persistent_mq_handle</a> &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classipc_1_1transport_1_1sync__io_1_1Blob__stream__mq__sender__impl.html">ipc::transport::sync_io::Blob_stream_mq_sender_impl</a>&lt; <a class="el" href="classipc_1_1transport_1_1Persistent__mq__handle.html">Persistent_mq_handle</a> &gt;::end_sending</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>See <a class="el" href="classipc_1_1transport_1_1sync__io_1_1Blob__stream__mq__sender.html" title="Implements sync_io::Blob_sender concept by using an adopted Persistent_mq_handle MQ handle to an MQ (...">Blob_stream_mq_sender</a> counterpart, but assuming PEER state. </p>
<dl class="section return"><dt>Returns</dt><dd>See <a class="el" href="classipc_1_1transport_1_1sync__io_1_1Blob__stream__mq__sender.html" title="Implements sync_io::Blob_sender concept by using an adopted Persistent_mq_handle MQ handle to an MQ (...">Blob_stream_mq_sender</a> counterpart. </dd></dl>

<p class="definition">Definition at line <a class="el" href="sync__io_2detail_2blob__stream__mq__snd__impl_8hpp_source.html#l01041">1041</a> of file <a class="el" href="sync__io_2detail_2blob__stream__mq__snd__impl_8hpp_source.html">blob_stream_mq_snd_impl.hpp</a>.</p>

</div>
</div>
<a id="ad30ee34fd91e68a084d207763e753f6d" name="ad30ee34fd91e68a084d207763e753f6d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad30ee34fd91e68a084d207763e753f6d">&#9670;&nbsp;</a></span>nickname()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename <a class="el" href="classipc_1_1transport_1_1Persistent__mq__handle.html">Persistent_mq_handle</a> &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">const std::string &amp; <a class="el" href="classipc_1_1transport_1_1sync__io_1_1Blob__stream__mq__sender__impl.html">ipc::transport::sync_io::Blob_stream_mq_sender_impl</a>&lt; <a class="el" href="classipc_1_1transport_1_1Persistent__mq__handle.html">Persistent_mq_handle</a> &gt;::nickname</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>See <a class="el" href="classipc_1_1transport_1_1sync__io_1_1Blob__stream__mq__sender.html" title="Implements sync_io::Blob_sender concept by using an adopted Persistent_mq_handle MQ handle to an MQ (...">Blob_stream_mq_sender</a> counterpart, but assuming PEER state. </p>
<dl class="section return"><dt>Returns</dt><dd>See <a class="el" href="classipc_1_1transport_1_1sync__io_1_1Blob__stream__mq__sender.html" title="Implements sync_io::Blob_sender concept by using an adopted Persistent_mq_handle MQ handle to an MQ (...">Blob_stream_mq_sender</a> counterpart. </dd></dl>

<p class="definition">Definition at line <a class="el" href="sync__io_2detail_2blob__stream__mq__snd__impl_8hpp_source.html#l01696">1696</a> of file <a class="el" href="sync__io_2detail_2blob__stream__mq__snd__impl_8hpp_source.html">blob_stream_mq_snd_impl.hpp</a>.</p>

<p class="reference">Referenced by <a class="el" href="sync__io_2detail_2blob__stream__mq__snd__impl_8hpp_source.html#l00641">ipc::transport::sync_io::Blob_stream_mq_sender_impl&lt; Persistent_mq_handle &gt;::Blob_stream_mq_sender_impl()</a>, and <a class="el" href="sync__io_2detail_2blob__stream__mq__snd__impl_8hpp_source.html#l01702">ipc::transport::sync_io::Blob_stream_mq_sender_impl&lt; Persistent_mq_handle &gt;::operator&lt;&lt;()</a>.</p>
<div class="dynheader">
Here is the caller graph for this function:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="classipc_1_1transport_1_1sync__io_1_1Blob__stream__mq__sender__impl_ad30ee34fd91e68a084d207763e753f6d_icgraph.svg" width="455" height="131"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe>
</div>
</div>

</div>
</div>
<a id="ad84b0f43cd4d1329c8bac6ea1376d3ca" name="ad84b0f43cd4d1329c8bac6ea1376d3ca"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad84b0f43cd4d1329c8bac6ea1376d3ca">&#9670;&nbsp;</a></span>on_ev_auto_ping_now_timer_fired()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename <a class="el" href="classipc_1_1transport_1_1Persistent__mq__handle.html">Persistent_mq_handle</a> &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classipc_1_1transport_1_1sync__io_1_1Blob__stream__mq__sender__impl.html">ipc::transport::sync_io::Blob_stream_mq_sender_impl</a>&lt; <a class="el" href="classipc_1_1transport_1_1Persistent__mq__handle.html">Persistent_mq_handle</a> &gt;::on_ev_auto_ping_now_timer_fired</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Handler for the async-wait, via <a class="el" href="classipc_1_1util_1_1sync__io_1_1Timer__event__emitter.html" title="An object of this type, used internally to implement sync_io-pattern objects that require timer event...">util::sync_io::Timer_event_emitter</a>, of the auto-ping timer firing; if all is cool, sends auto-ping and schedules the next such async-wait. </p>
<p >That wait itself can be rescheduled when non-idleness (other send attempts) occurs. If all is not cool &ndash; sends finished via <code>*end_sending()</code>, out-pipe hosed &ndash; then neither sends auto-ping nor schedules another. </p>

<p class="definition">Definition at line <a class="el" href="sync__io_2detail_2blob__stream__mq__snd__impl_8hpp_source.html#l01274">1274</a> of file <a class="el" href="sync__io_2detail_2blob__stream__mq__snd__impl_8hpp_source.html">blob_stream_mq_snd_impl.hpp</a>.</p>

</div>
</div>
<a id="aa7f092848ef3691dcf97182e5b3e2383" name="aa7f092848ef3691dcf97182e5b3e2383"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa7f092848ef3691dcf97182e5b3e2383">&#9670;&nbsp;</a></span>op_started()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename <a class="el" href="classipc_1_1transport_1_1Persistent__mq__handle.html">Persistent_mq_handle</a> &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classipc_1_1transport_1_1sync__io_1_1Blob__stream__mq__sender__impl.html">ipc::transport::sync_io::Blob_stream_mq_sender_impl</a>&lt; <a class="el" href="classipc_1_1transport_1_1Persistent__mq__handle.html">Persistent_mq_handle</a> &gt;::op_started </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespaceipc_1_1util.html#ae6ac47812a90d1287c61e0b7de7bc4f5">util::String_view</a>&#160;</td>
          <td class="paramname"><em>context</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Helper that returns <code>true</code> silently if <code>start_*_ops()</code> has been called; else logs WARNING and returns <code>false</code>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">context</td><td>For logging: the algorithmic context (function name or whatever). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>See above. </dd></dl>

<p class="definition">Definition at line <a class="el" href="sync__io_2detail_2blob__stream__mq__snd__impl_8hpp_source.html#l00864">864</a> of file <a class="el" href="sync__io_2detail_2blob__stream__mq__snd__impl_8hpp_source.html">blob_stream_mq_snd_impl.hpp</a>.</p>

</div>
</div>
<a id="aa16854340cdf194120efd08f711c74f9" name="aa16854340cdf194120efd08f711c74f9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa16854340cdf194120efd08f711c74f9">&#9670;&nbsp;</a></span>replace_event_wait_handles()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename <a class="el" href="classipc_1_1transport_1_1Persistent__mq__handle.html">Persistent_mq_handle</a> &gt; </div>
<div class="memtemplate">
template&lt;typename Create_ev_wait_hndl_func &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classipc_1_1transport_1_1sync__io_1_1Blob__stream__mq__sender__impl.html">ipc::transport::sync_io::Blob_stream_mq_sender_impl</a>&lt; <a class="el" href="classipc_1_1transport_1_1Persistent__mq__handle.html">Persistent_mq_handle</a> &gt;::replace_event_wait_handles </td>
          <td>(</td>
          <td class="paramtype">const Create_ev_wait_hndl_func &amp;&#160;</td>
          <td class="paramname"><em>create_ev_wait_hndl_func</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>See <a class="el" href="classipc_1_1transport_1_1sync__io_1_1Blob__stream__mq__sender.html" title="Implements sync_io::Blob_sender concept by using an adopted Persistent_mq_handle MQ handle to an MQ (...">Blob_stream_mq_sender</a> counterpart. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Create_ev_wait_hndl_func</td><td>See <a class="el" href="classipc_1_1transport_1_1sync__io_1_1Blob__stream__mq__sender.html" title="Implements sync_io::Blob_sender concept by using an adopted Persistent_mq_handle MQ handle to an MQ (...">Blob_stream_mq_sender</a> counterpart. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">create_ev_wait_hndl_func</td><td>See <a class="el" href="classipc_1_1transport_1_1sync__io_1_1Blob__stream__mq__sender.html" title="Implements sync_io::Blob_sender concept by using an adopted Persistent_mq_handle MQ handle to an MQ (...">Blob_stream_mq_sender</a> counterpart. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>See <a class="el" href="classipc_1_1transport_1_1sync__io_1_1Blob__stream__mq__sender.html" title="Implements sync_io::Blob_sender concept by using an adopted Persistent_mq_handle MQ handle to an MQ (...">Blob_stream_mq_sender</a> counterpart. </dd></dl>

<p class="definition">Definition at line <a class="el" href="sync__io_2detail_2blob__stream__mq__snd__impl_8hpp_source.html#l00781">781</a> of file <a class="el" href="sync__io_2detail_2blob__stream__mq__snd__impl_8hpp_source.html">blob_stream_mq_snd_impl.hpp</a>.</p>

<p class="reference">References <a class="el" href="native__handle_8hpp_source.html#l00085">ipc::util::Native_handle::m_native_handle</a>.</p>

</div>
</div>
<a id="aba05c51d1033a4ea4ca03679f2fa1f8c" name="aba05c51d1033a4ea4ca03679f2fa1f8c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aba05c51d1033a4ea4ca03679f2fa1f8c">&#9670;&nbsp;</a></span>send_blob()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename <a class="el" href="classipc_1_1transport_1_1Persistent__mq__handle.html">Persistent_mq_handle</a> &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classipc_1_1transport_1_1sync__io_1_1Blob__stream__mq__sender__impl.html">ipc::transport::sync_io::Blob_stream_mq_sender_impl</a>&lt; <a class="el" href="classipc_1_1transport_1_1Persistent__mq__handle.html">Persistent_mq_handle</a> &gt;::send_blob </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespaceipc_1_1util.html#ae0be7edba7e30ffa3f8b742af621f2ab">util::Blob_const</a> &amp;&#160;</td>
          <td class="paramname"><em>blob</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceipc.html#aa3192e586cc45d3e7c22463bf2760f89">Error_code</a> *&#160;</td>
          <td class="paramname"><em>err_code</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>See <a class="el" href="classipc_1_1transport_1_1sync__io_1_1Blob__stream__mq__sender.html" title="Implements sync_io::Blob_sender concept by using an adopted Persistent_mq_handle MQ handle to an MQ (...">Blob_stream_mq_sender</a> counterpart, but assuming PEER state. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">blob</td><td>See <a class="el" href="classipc_1_1transport_1_1sync__io_1_1Blob__stream__mq__sender.html" title="Implements sync_io::Blob_sender concept by using an adopted Persistent_mq_handle MQ handle to an MQ (...">Blob_stream_mq_sender</a> counterpart. </td></tr>
    <tr><td class="paramname">err_code</td><td>See <a class="el" href="classipc_1_1transport_1_1sync__io_1_1Blob__stream__mq__sender.html" title="Implements sync_io::Blob_sender concept by using an adopted Persistent_mq_handle MQ handle to an MQ (...">Blob_stream_mq_sender</a> counterpart. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>See <a class="el" href="classipc_1_1transport_1_1sync__io_1_1Blob__stream__mq__sender.html" title="Implements sync_io::Blob_sender concept by using an adopted Persistent_mq_handle MQ handle to an MQ (...">Blob_stream_mq_sender</a> counterpart. </dd></dl>

<p class="definition">Definition at line <a class="el" href="sync__io_2detail_2blob__stream__mq__snd__impl_8hpp_source.html#l00878">878</a> of file <a class="el" href="sync__io_2detail_2blob__stream__mq__snd__impl_8hpp_source.html">blob_stream_mq_snd_impl.hpp</a>.</p>

<p class="reference">References <a class="el" href="namespaceipc_1_1transport_1_1error.html#adfef15ef4e76cc55d652fbd9c2797297ac416e988563e44bf15fc6a81743eef53">ipc::transport::error::S_INVALID_ARGUMENT</a>, and <a class="el" href="namespaceipc_1_1transport_1_1error.html#adfef15ef4e76cc55d652fbd9c2797297a42d41c622e92e9053177ba73e75633fe">ipc::transport::error::S_SENDS_FINISHED_CANNOT_SEND</a>.</p>

</div>
</div>
<a id="ae56c0c2aeb9fa3c34c364ec46a506994" name="ae56c0c2aeb9fa3c34c364ec46a506994"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae56c0c2aeb9fa3c34c364ec46a506994">&#9670;&nbsp;</a></span>send_blob_max_size()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename <a class="el" href="classipc_1_1transport_1_1Persistent__mq__handle.html">Persistent_mq_handle</a> &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">size_t <a class="el" href="classipc_1_1transport_1_1sync__io_1_1Blob__stream__mq__sender__impl.html">ipc::transport::sync_io::Blob_stream_mq_sender_impl</a>&lt; <a class="el" href="classipc_1_1transport_1_1Persistent__mq__handle.html">Persistent_mq_handle</a> &gt;::send_blob_max_size</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>See <a class="el" href="classipc_1_1transport_1_1sync__io_1_1Blob__stream__mq__sender.html" title="Implements sync_io::Blob_sender concept by using an adopted Persistent_mq_handle MQ handle to an MQ (...">Blob_stream_mq_sender</a> counterpart, but assuming PEER state. </p>
<dl class="section return"><dt>Returns</dt><dd>See <a class="el" href="classipc_1_1transport_1_1sync__io_1_1Blob__stream__mq__sender.html" title="Implements sync_io::Blob_sender concept by using an adopted Persistent_mq_handle MQ handle to an MQ (...">Blob_stream_mq_sender</a> counterpart. </dd></dl>

<p class="definition">Definition at line <a class="el" href="sync__io_2detail_2blob__stream__mq__snd__impl_8hpp_source.html#l01684">1684</a> of file <a class="el" href="sync__io_2detail_2blob__stream__mq__snd__impl_8hpp_source.html">blob_stream_mq_snd_impl.hpp</a>.</p>

</div>
</div>
<a id="aa3116afe888df718c4ae10befcf2a16f" name="aa3116afe888df718c4ae10befcf2a16f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa3116afe888df718c4ae10befcf2a16f">&#9670;&nbsp;</a></span>start_send_blob_ops()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename <a class="el" href="classipc_1_1transport_1_1Persistent__mq__handle.html">Persistent_mq_handle</a> &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classipc_1_1transport_1_1sync__io_1_1Blob__stream__mq__sender__impl.html">ipc::transport::sync_io::Blob_stream_mq_sender_impl</a>&lt; <a class="el" href="classipc_1_1transport_1_1Persistent__mq__handle.html">Persistent_mq_handle</a> &gt;::start_send_blob_ops </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespaceipc_1_1util_1_1sync__io.html#aa0b9a3cc6bdc7dedbef4f9e06851aa24">util::sync_io::Event_wait_func</a> &amp;&amp;&#160;</td>
          <td class="paramname"><em>ev_wait_func</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>See <a class="el" href="classipc_1_1transport_1_1sync__io_1_1Blob__stream__mq__sender.html" title="Implements sync_io::Blob_sender concept by using an adopted Persistent_mq_handle MQ handle to an MQ (...">Blob_stream_mq_sender</a> counterpart. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ev_wait_func</td><td>See <a class="el" href="classipc_1_1transport_1_1sync__io_1_1Blob__stream__mq__sender.html" title="Implements sync_io::Blob_sender concept by using an adopted Persistent_mq_handle MQ handle to an MQ (...">Blob_stream_mq_sender</a> counterpart. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>See <a class="el" href="classipc_1_1transport_1_1sync__io_1_1Blob__stream__mq__sender.html" title="Implements sync_io::Blob_sender concept by using an adopted Persistent_mq_handle MQ handle to an MQ (...">Blob_stream_mq_sender</a> counterpart. </dd></dl>

<p class="definition">Definition at line <a class="el" href="sync__io_2detail_2blob__stream__mq__snd__impl_8hpp_source.html#l00824">824</a> of file <a class="el" href="sync__io_2detail_2blob__stream__mq__snd__impl_8hpp_source.html">blob_stream_mq_snd_impl.hpp</a>.</p>

<p class="reference">References <a class="el" href="protocol__negotiator_8hpp_source.html#l00215">ipc::transport::Protocol_negotiator::S_VER_UNKNOWN</a>.</p>

</div>
</div>
<a id="af7657579dd859f95c234e447246b9410" name="af7657579dd859f95c234e447246b9410"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af7657579dd859f95c234e447246b9410">&#9670;&nbsp;</a></span>sync_write_or_q_ctl_cmd()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename <a class="el" href="classipc_1_1transport_1_1Persistent__mq__handle.html">Persistent_mq_handle</a> &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classipc_1_1transport_1_1sync__io_1_1Blob__stream__mq__sender__impl.html">ipc::transport::sync_io::Blob_stream_mq_sender_impl</a>&lt; <a class="el" href="classipc_1_1transport_1_1Persistent__mq__handle.html">Persistent_mq_handle</a> &gt;::sync_write_or_q_ctl_cmd </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classipc_1_1transport_1_1Blob__stream__mq__base__impl.html#a2e46672d40fbf38cf6054edfad69e705">Control_cmd</a>&#160;</td>
          <td class="paramname"><em>cmd</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Writes the 2 payloads corresponding to CONTROL command <code>cmd</code> to <a class="el" href="classipc_1_1transport_1_1sync__io_1_1Blob__stream__mq__sender__impl.html#a32a49dff090ce4b658707e7d9b9036c9" title="The MQ handle adopted by the ctor, through which nb-sends and blocking-waits are executed.">m_mq</a>; if unable to do so synchronously &ndash; either because items are already queued in <a class="el" href="classipc_1_1transport_1_1sync__io_1_1Blob__stream__mq__sender__impl.html#aaecb4615ae4d9fbf82ab2c195ada47cf" title="Queue storing (at head) the currently in-progress async write-op of a Snd_low_lvl_payload; followed b...">m_pending_payloads_q</a>, or MQ is full &ndash; then enqueue 1-2 of the payloads onto that queue. </p>
<p >In the case of Control_cmd::S_PING it may drop both payloads silently (see <a class="el" href="classipc_1_1transport_1_1sync__io_1_1Blob__stream__mq__sender__impl.html#a25e79124ef73da11430ce3060587f12a" title="Either synchronously sends orig_blob low-level blob over m_mq, or if an async-send is in progress que...">sync_write_or_q_payload()</a> notes regarding <code>avoided_qing</code> mode).</p>
<p >Essentially this combines 1-2 <a class="el" href="classipc_1_1transport_1_1sync__io_1_1Blob__stream__mq__sender__impl.html#a25e79124ef73da11430ce3060587f12a" title="Either synchronously sends orig_blob low-level blob over m_mq, or if an async-send is in progress que...">sync_write_or_q_payload()</a> for the specific task of sending out a CONTROL command. If one desires to send a normal (user) message &ndash; use <a class="el" href="classipc_1_1transport_1_1sync__io_1_1Blob__stream__mq__sender__impl.html#a25e79124ef73da11430ce3060587f12a" title="Either synchronously sends orig_blob low-level blob over m_mq, or if an async-send is in progress que...">sync_write_or_q_payload()</a> directly (it shall deal with a single payload).</p>
<p >If a sync-write uncovers <a class="el" href="classipc_1_1transport_1_1sync__io_1_1Blob__stream__mq__sender__impl.html#a32a49dff090ce4b658707e7d9b9036c9" title="The MQ handle adopted by the ctor, through which nb-sends and blocking-waits are executed.">m_mq</a> is hosed, then <a class="el" href="classipc_1_1transport_1_1sync__io_1_1Blob__stream__mq__sender__impl.html#affd27be454f2e394f44fc76a5a4c50de" title="The first and only connection-hosing error condition detected when attempting to low-level-write on m...">m_pending_err_code</a> is made truthy.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">cmd</td><td>See above. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A-la <a class="el" href="classipc_1_1transport_1_1sync__io_1_1Blob__stream__mq__sender__impl.html#a25e79124ef73da11430ce3060587f12a" title="Either synchronously sends orig_blob low-level blob over m_mq, or if an async-send is in progress que...">sync_write_or_q_payload()</a>: <code>false</code> if outgoing-direction pipe still has stuff in it; <code>true</code> otherwise. </dd></dl>

<p class="definition">Definition at line <a class="el" href="sync__io_2detail_2blob__stream__mq__snd__impl_8hpp_source.html#l01448">1448</a> of file <a class="el" href="sync__io_2detail_2blob__stream__mq__snd__impl_8hpp_source.html">blob_stream_mq_snd_impl.hpp</a>.</p>

</div>
</div>
<a id="ab8230261c54efb813aabc8a80f79fc8d" name="ab8230261c54efb813aabc8a80f79fc8d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab8230261c54efb813aabc8a80f79fc8d">&#9670;&nbsp;</a></span>sync_write_or_q_ctl_cmd_impl()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename <a class="el" href="classipc_1_1transport_1_1Persistent__mq__handle.html">Persistent_mq_handle</a> &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classipc_1_1transport_1_1sync__io_1_1Blob__stream__mq__sender__impl.html">ipc::transport::sync_io::Blob_stream_mq_sender_impl</a>&lt; <a class="el" href="classipc_1_1transport_1_1Persistent__mq__handle.html">Persistent_mq_handle</a> &gt;::sync_write_or_q_ctl_cmd_impl </td>
          <td>(</td>
          <td class="paramtype">std::underlying_type_t&lt; <a class="el" href="classipc_1_1transport_1_1Blob__stream__mq__base__impl.html#a2e46672d40fbf38cf6054edfad69e705">Control_cmd</a> &gt;&#160;</td>
          <td class="paramname"><em>raw_cmd</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Equivalent to <a class="el" href="classipc_1_1transport_1_1sync__io_1_1Blob__stream__mq__sender__impl.html#af7657579dd859f95c234e447246b9410" title="Writes the 2 payloads corresponding to CONTROL command cmd to m_mq; if unable to do so synchronously ...">sync_write_or_q_ctl_cmd()</a> but takes the raw representation of the command to send; this allows both sending the <code>enum Control_cmd</code> value or the special protocol negotiation payload. </p>
<p >We always send the latter as the first message, and never again; and the receiver side expects this; after that only regular <code>Control_cmd</code>-bearing CONTROL messages are sent and expected.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">raw_cmd</td><td>Either a non-negative value, which equals the cast of a <code>Control_cmd</code> to its underlying type; or a negative value, which equals the arithmetic negation of our highest (preferred) protocol version. So in the latter case -1 means version 1, -2 means version 2, etc. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>See <a class="el" href="classipc_1_1transport_1_1sync__io_1_1Blob__stream__mq__sender__impl.html#af7657579dd859f95c234e447246b9410" title="Writes the 2 payloads corresponding to CONTROL command cmd to m_mq; if unable to do so synchronously ...">sync_write_or_q_ctl_cmd()</a>. </dd></dl>

<p class="definition">Definition at line <a class="el" href="sync__io_2detail_2blob__stream__mq__snd__impl_8hpp_source.html#l01454">1454</a> of file <a class="el" href="sync__io_2detail_2blob__stream__mq__snd__impl_8hpp_source.html">blob_stream_mq_snd_impl.hpp</a>.</p>

</div>
</div>
<a id="a25e79124ef73da11430ce3060587f12a" name="a25e79124ef73da11430ce3060587f12a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a25e79124ef73da11430ce3060587f12a">&#9670;&nbsp;</a></span>sync_write_or_q_payload()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename <a class="el" href="classipc_1_1transport_1_1Persistent__mq__handle.html">Persistent_mq_handle</a> &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classipc_1_1transport_1_1sync__io_1_1Blob__stream__mq__sender__impl.html">ipc::transport::sync_io::Blob_stream_mq_sender_impl</a>&lt; <a class="el" href="classipc_1_1transport_1_1Persistent__mq__handle.html">Persistent_mq_handle</a> &gt;::sync_write_or_q_payload </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespaceipc_1_1util.html#ae0be7edba7e30ffa3f8b742af621f2ab">util::Blob_const</a> &amp;&#160;</td>
          <td class="paramname"><em>orig_blob</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool *&#160;</td>
          <td class="paramname"><em>avoided_qing_or_null</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Either synchronously sends <code>orig_blob</code> low-level blob over <a class="el" href="classipc_1_1transport_1_1sync__io_1_1Blob__stream__mq__sender__impl.html#a32a49dff090ce4b658707e7d9b9036c9" title="The MQ handle adopted by the ctor, through which nb-sends and blocking-waits are executed.">m_mq</a>, or if an async-send is in progress queues it to be sent later; dropping-sans-queuing allowed under certain circumstances in <code>avoided_qing</code> mode. </p>
<p >For details on the latter see below.</p>
<p ><a class="el" href="classipc_1_1transport_1_1sync__io_1_1Blob__stream__mq__sender__impl.html#affd27be454f2e394f44fc76a5a4c50de" title="The first and only connection-hosing error condition detected when attempting to low-level-write on m...">m_pending_err_code</a> (pre-condition: it is falsy) is set to the error to ultimately return; and if no such outgoing-pipe-hosing is synchronously encountered it is left untouched. In particular, if falsy upon return, you may call this again to send the next low-level payload. Otherwise <a class="el" href="classipc_1_1transport_1_1sync__io_1_1Blob__stream__mq__sender__impl.html#a32a49dff090ce4b658707e7d9b9036c9" title="The MQ handle adopted by the ctor, through which nb-sends and blocking-waits are executed.">m_mq</a> cannot be subsequently used (it is hosed). Thus we maintain the invariant that <a class="el" href="classipc_1_1transport_1_1sync__io_1_1Blob__stream__mq__sender__impl.html#a32a49dff090ce4b658707e7d9b9036c9" title="The MQ handle adopted by the ctor, through which nb-sends and blocking-waits are executed.">m_mq</a> is null if and only if that guy is truthy.</p>
<h3><code>avoided_qing</code> mode for auto-ping</h3>
<p >If <code>avoided_qing_or_null</code> is null, then see above. If it points to a <code>bool</code>, though, then: the above behavior is slightly modified as follows. Suppose <code>orig_blob</code> encodes an auto-ping message (see <a class="el" href="classipc_1_1transport_1_1sync__io_1_1Blob__stream__mq__sender__impl.html#a19e169b59c90ceac14671aa324a00649" title="See Blob_stream_mq_sender counterpart, but assuming PEER state.">auto_ping()</a>). Its purpose is to inform the opposing side that we are alive/not idle. So suppose this method is unable to send <code>orig_blob</code>, either because there are already-queued data waiting to be sent pending writability (due to earlier would-block), or because the MQ has already-queued bytes waiting to be popped by receiver, and there is no space there to enqueue <code>orig_blob</code>. Then the receiver must not be keeping up with us, and the next pop of the MQ will get <em>some</em> message, even if it's not the auto-ping we wanted to send; hence they'll know we are not-idle without the auto-ping. So in that case this method shall:</p><ul>
<li>disregard <code>orig_blob</code> (do not queue it &ndash; drop it, as it would be redundant anyway);</li>
<li>return <code>true</code> if and only if the size of the out-queue is 0 (though as of this writing the caller should not care: auto-ping is a fire-and-forget operation, as long as it does not detect a pipe-hosing error);</li>
<li>set <code>*avoided_qing_or_null</code>.</li>
</ul>
<p >If <code>avoided_qing_or_null</code> is not null, but no error or would-block was encountered &ndash; meaning it was placed into MQ synchronously &ndash; then <code>*avoided_qing_or_null</code> is set to <code>false</code>.</p>
<p >Why do we even have this as an out-arg? Answer: It is to be used for payload 1 of a CONTROL PING message; so if this is set to <code>true</code>, then caller should <em>not</em> <a class="el" href="classipc_1_1transport_1_1sync__io_1_1Blob__stream__mq__sender__impl.html#a25e79124ef73da11430ce3060587f12a" title="Either synchronously sends orig_blob low-level blob over m_mq, or if an async-send is in progress que...">sync_write_or_q_payload()</a> again for payload 2. Otherwise (assuming <a class="el" href="classipc_1_1transport_1_1sync__io_1_1Blob__stream__mq__sender__impl.html#a32a49dff090ce4b658707e7d9b9036c9" title="The MQ handle adopted by the ctor, through which nb-sends and blocking-waits are executed.">m_mq</a> is still alive) it should.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">orig_blob</td><td>Blob to send. Empty blob is allowed. </td></tr>
    <tr><td class="paramname">avoided_qing_or_null</td><td>See above. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>false</code> if outgoing-direction pipe still has queued stuff in it that must be sent once transport becomes writable; <code>true</code> otherwise. If <code>true</code> is returned, but <code>avoided_qing_or_null != nullptr</code>, then possibly <code>orig_blob</code> was not sent (at all); was dropped (check <code>*avoided_qing_or_null</code> to see if so). </dd></dl>

<p class="definition">Definition at line <a class="el" href="sync__io_2detail_2blob__stream__mq__snd__impl_8hpp_source.html#l01335">1335</a> of file <a class="el" href="sync__io_2detail_2blob__stream__mq__snd__impl_8hpp_source.html">blob_stream_mq_snd_impl.hpp</a>.</p>

</div>
</div>
<h2 class="groupheader">Friends And Related Function Documentation</h2>
<a id="a8bc3464c81b40649e99da6ce2ee5f87c" name="a8bc3464c81b40649e99da6ce2ee5f87c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8bc3464c81b40649e99da6ce2ee5f87c">&#9670;&nbsp;</a></span>operator&lt;&lt;()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename <a class="el" href="classipc_1_1transport_1_1Persistent__mq__handle.html">Persistent_mq_handle</a> &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::ostream &amp; operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>os</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classipc_1_1transport_1_1sync__io_1_1Blob__stream__mq__sender__impl.html">Blob_stream_mq_sender_impl</a>&lt; <a class="el" href="classipc_1_1transport_1_1Persistent__mq__handle.html">Persistent_mq_handle</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>val</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Prints string representation of the given <code><a class="el" href="classipc_1_1transport_1_1sync__io_1_1Blob__stream__mq__sender.html" title="Implements sync_io::Blob_sender concept by using an adopted Persistent_mq_handle MQ handle to an MQ (...">Blob_stream_mq_sender</a></code> to the given <code>ostream</code>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">os</td><td>Stream to which to write. </td></tr>
    <tr><td class="paramname">val</td><td>Object to serialize. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>os</code>. </dd></dl>

<p class="definition">Definition at line <a class="el" href="sync__io_2detail_2blob__stream__mq__snd__impl_8hpp_source.html#l01702">1702</a> of file <a class="el" href="sync__io_2detail_2blob__stream__mq__snd__impl_8hpp_source.html">blob_stream_mq_snd_impl.hpp</a>.</p>

<p class="reference">References <a class="el" href="sync__io_2detail_2blob__stream__mq__snd__impl_8hpp_source.html#l01690">ipc::transport::sync_io::Blob_stream_mq_sender_impl&lt; Persistent_mq_handle &gt;::absolute_name()</a>, and <a class="el" href="sync__io_2detail_2blob__stream__mq__snd__impl_8hpp_source.html#l01696">ipc::transport::sync_io::Blob_stream_mq_sender_impl&lt; Persistent_mq_handle &gt;::nickname()</a>.</p>
<div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="classipc_1_1transport_1_1sync__io_1_1Blob__stream__mq__sender__impl_a8bc3464c81b40649e99da6ce2ee5f87c_cgraph.svg" width="414" height="131"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe>
</div>
</div>

</div>
</div>
<h2 class="groupheader">Member Data Documentation</h2>
<a id="a4ea460de8caacec0ac8f75dd93f6c548" name="a4ea460de8caacec0ac8f75dd93f6c548"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4ea460de8caacec0ac8f75dd93f6c548">&#9670;&nbsp;</a></span>m_absolute_name</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename <a class="el" href="classipc_1_1transport_1_1Persistent__mq__handle.html">Persistent_mq_handle</a> &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="namespaceipc_1_1transport.html#a33de1c256addb3964b839dc2dd407d24">Shared_name</a> <a class="el" href="classipc_1_1transport_1_1sync__io_1_1Blob__stream__mq__sender__impl.html">ipc::transport::sync_io::Blob_stream_mq_sender_impl</a>&lt; <a class="el" href="classipc_1_1transport_1_1Persistent__mq__handle.html">Persistent_mq_handle</a> &gt;::m_absolute_name</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>See <a class="el" href="classipc_1_1transport_1_1sync__io_1_1Blob__stream__mq__sender__impl.html#a0763f3a2891a2a0e41f3ff15f06db7cc" title="See Blob_stream_mq_sender counterpart, but assuming PEER state.">absolute_name()</a>. </p>

<p class="definition">Definition at line <a class="el" href="sync__io_2detail_2blob__stream__mq__snd__impl_8hpp_source.html#l00439">439</a> of file <a class="el" href="sync__io_2detail_2blob__stream__mq__snd__impl_8hpp_source.html">blob_stream_mq_snd_impl.hpp</a>.</p>

</div>
</div>
<a id="a2c8029fdae05966ef05312919c85aeac" name="a2c8029fdae05966ef05312919c85aeac"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2c8029fdae05966ef05312919c85aeac">&#9670;&nbsp;</a></span>m_auto_ping_period</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename <a class="el" href="classipc_1_1transport_1_1Persistent__mq__handle.html">Persistent_mq_handle</a> &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespaceipc_1_1util.html#ac66141280c3b7295a86b65209f31cc58">util::Fine_duration</a> <a class="el" href="classipc_1_1transport_1_1sync__io_1_1Blob__stream__mq__sender__impl.html">ipc::transport::sync_io::Blob_stream_mq_sender_impl</a>&lt; <a class="el" href="classipc_1_1transport_1_1Persistent__mq__handle.html">Persistent_mq_handle</a> &gt;::m_auto_ping_period</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Equals <code>zero()</code> before <a class="el" href="classipc_1_1transport_1_1sync__io_1_1Blob__stream__mq__sender__impl.html#a19e169b59c90ceac14671aa324a00649" title="See Blob_stream_mq_sender counterpart, but assuming PEER state.">auto_ping()</a>; immutably equals <code>period</code> (<a class="el" href="classipc_1_1transport_1_1sync__io_1_1Blob__stream__mq__sender__impl.html#a19e169b59c90ceac14671aa324a00649" title="See Blob_stream_mq_sender counterpart, but assuming PEER state.">auto_ping()</a> arg) subsequently to that first successful call (if any). </p>

<p class="definition">Definition at line <a class="el" href="sync__io_2detail_2blob__stream__mq__snd__impl_8hpp_source.html#l00577">577</a> of file <a class="el" href="sync__io_2detail_2blob__stream__mq__snd__impl_8hpp_source.html">blob_stream_mq_snd_impl.hpp</a>.</p>

</div>
</div>
<a id="a41bb316b2f9ca88371506ebed3890261" name="a41bb316b2f9ca88371506ebed3890261"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a41bb316b2f9ca88371506ebed3890261">&#9670;&nbsp;</a></span>m_auto_ping_timer</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename <a class="el" href="classipc_1_1transport_1_1Persistent__mq__handle.html">Persistent_mq_handle</a> &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">flow::util::Timer <a class="el" href="classipc_1_1transport_1_1sync__io_1_1Blob__stream__mq__sender__impl.html">ipc::transport::sync_io::Blob_stream_mq_sender_impl</a>&lt; <a class="el" href="classipc_1_1transport_1_1Persistent__mq__handle.html">Persistent_mq_handle</a> &gt;::m_auto_ping_timer</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Timer that fires <a class="el" href="classipc_1_1transport_1_1sync__io_1_1Blob__stream__mq__sender__impl.html#ad84b0f43cd4d1329c8bac6ea1376d3ca" title="Handler for the async-wait, via util::sync_io::Timer_event_emitter, of the auto-ping timer firing; if...">on_ev_auto_ping_now_timer_fired()</a> (which sends an auto-ping) and is always scheduled to fire <a class="el" href="classipc_1_1transport_1_1sync__io_1_1Blob__stream__mq__sender__impl.html#a2c8029fdae05966ef05312919c85aeac" title="Equals zero() before auto_ping(); immutably equals period (auto_ping() arg) subsequently to that firs...">m_auto_ping_period</a> after the last send (<a class="el" href="classipc_1_1transport_1_1sync__io_1_1Blob__stream__mq__sender__impl.html#aba05c51d1033a4ea4ca03679f2fa1f8c" title="See Blob_stream_mq_sender counterpart, but assuming PEER state.">send_blob()</a>, <a class="el" href="classipc_1_1transport_1_1sync__io_1_1Blob__stream__mq__sender__impl.html#a19e169b59c90ceac14671aa324a00649" title="See Blob_stream_mq_sender counterpart, but assuming PEER state.">auto_ping()</a>, <a class="el" href="classipc_1_1transport_1_1sync__io_1_1Blob__stream__mq__sender__impl.html#ad84b0f43cd4d1329c8bac6ea1376d3ca" title="Handler for the async-wait, via util::sync_io::Timer_event_emitter, of the auto-ping timer firing; if...">on_ev_auto_ping_now_timer_fired()</a> itself). </p>
<p >Each of these calls indicates a send occurs, hence at worst the pipe will be idle (in need of auto-ping) in <a class="el" href="classipc_1_1transport_1_1sync__io_1_1Blob__stream__mq__sender__impl.html#a2c8029fdae05966ef05312919c85aeac" title="Equals zero() before auto_ping(); immutably equals period (auto_ping() arg) subsequently to that firs...">m_auto_ping_period</a>. Note that <code>*end_sending()</code>, while also sending bytes, does not schedule <a class="el" href="classipc_1_1transport_1_1sync__io_1_1Blob__stream__mq__sender__impl.html#a41bb316b2f9ca88371506ebed3890261" title="Timer that fires on_ev_auto_ping_now_timer_fired() (which sends an auto-ping) and is always scheduled...">m_auto_ping_timer</a>, as <code>*end_sending()</code> closes the conceptual pipe, and there is no need for auto-pinging (see <a class="el" href="classipc_1_1transport_1_1sync__io_1_1Blob__receiver.html#a6888f84e88c00d28daa579a9b47a2d77" title="In PEER state: Irreversibly enables a conceptual idle timer whose potential side effect is,...">Blob_receiver::idle_timer_run()</a>).</p>
<p >Since we implement <code><a class="el" href="namespaceipc_1_1transport_1_1sync__io.html" title="sync_io-pattern counterparts to async-I/O-pattern object types in parent namespace ipc::transport.">sync_io</a></code> pattern, the timer is obtained from, and used via, <a class="el" href="classipc_1_1util_1_1sync__io_1_1Timer__event__emitter.html" title="An object of this type, used internally to implement sync_io-pattern objects that require timer event...">util::sync_io::Timer_event_emitter</a> <a class="el" href="classipc_1_1transport_1_1sync__io_1_1Blob__stream__mq__sender__impl.html#ab8bae935aff314b88d6163d04f52b5eb" title="As typical in timer-needing sync_io-pattern-implementing objects, maintains a thread exclusively for ...">m_timer_worker</a>. See that member's doc header for more info. </p>

<p class="definition">Definition at line <a class="el" href="sync__io_2detail_2blob__stream__mq__snd__impl_8hpp_source.html#l00590">590</a> of file <a class="el" href="sync__io_2detail_2blob__stream__mq__snd__impl_8hpp_source.html">blob_stream_mq_snd_impl.hpp</a>.</p>

</div>
</div>
<a id="ac4bd1d018000ca258478b62cf67cc524" name="ac4bd1d018000ca258478b62cf67cc524"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac4bd1d018000ca258478b62cf67cc524">&#9670;&nbsp;</a></span>m_auto_ping_timer_fired_peer</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename <a class="el" href="classipc_1_1transport_1_1Persistent__mq__handle.html">Persistent_mq_handle</a> &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classipc_1_1util_1_1sync__io_1_1Timer__event__emitter.html#a1533a54927a64579fda02c61ec94b735">util::sync_io::Timer_event_emitter::Timer_fired_read_end</a>* <a class="el" href="classipc_1_1transport_1_1sync__io_1_1Blob__stream__mq__sender__impl.html">ipc::transport::sync_io::Blob_stream_mq_sender_impl</a>&lt; <a class="el" href="classipc_1_1transport_1_1Persistent__mq__handle.html">Persistent_mq_handle</a> &gt;::m_auto_ping_timer_fired_peer</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Read-end of IPC-mechanism used by <a class="el" href="classipc_1_1transport_1_1sync__io_1_1Blob__stream__mq__sender__impl.html#ab8bae935aff314b88d6163d04f52b5eb" title="As typical in timer-needing sync_io-pattern-implementing objects, maintains a thread exclusively for ...">m_timer_worker</a> to ferry timer-fired events from <a class="el" href="classipc_1_1transport_1_1sync__io_1_1Blob__stream__mq__sender__impl.html#a41bb316b2f9ca88371506ebed3890261" title="Timer that fires on_ev_auto_ping_now_timer_fired() (which sends an auto-ping) and is always scheduled...">m_auto_ping_timer</a> to <code><a class="el" href="namespaceipc_1_1transport_1_1sync__io.html" title="sync_io-pattern counterparts to async-I/O-pattern object types in parent namespace ipc::transport.">sync_io</a></code> outside async-wait to our actual on-timer-fired handler logic. </p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classipc_1_1transport_1_1sync__io_1_1Blob__stream__mq__sender__impl.html#ab8bae935aff314b88d6163d04f52b5eb" title="As typical in timer-needing sync_io-pattern-implementing objects, maintains a thread exclusively for ...">m_timer_worker</a> for more info. </dd></dl>

<p class="definition">Definition at line <a class="el" href="sync__io_2detail_2blob__stream__mq__snd__impl_8hpp_source.html#l00598">598</a> of file <a class="el" href="sync__io_2detail_2blob__stream__mq__snd__impl_8hpp_source.html">blob_stream_mq_snd_impl.hpp</a>.</p>

</div>
</div>
<a id="a33709386e4339aae663702488cbfe5c7" name="a33709386e4339aae663702488cbfe5c7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a33709386e4339aae663702488cbfe5c7">&#9670;&nbsp;</a></span>m_blocking_worker</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename <a class="el" href="classipc_1_1transport_1_1Persistent__mq__handle.html">Persistent_mq_handle</a> &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::optional&lt;flow::async::Single_thread_task_loop&gt; <a class="el" href="classipc_1_1transport_1_1sync__io_1_1Blob__stream__mq__sender__impl.html">ipc::transport::sync_io::Blob_stream_mq_sender_impl</a>&lt; <a class="el" href="classipc_1_1transport_1_1Persistent__mq__handle.html">Persistent_mq_handle</a> &gt;::m_blocking_worker</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Worker thread W always in one of 2 states: idle; or (when <a class="el" href="classipc_1_1transport_1_1sync__io_1_1Blob__stream__mq__sender__impl.html#a32a49dff090ce4b658707e7d9b9036c9" title="The MQ handle adopted by the ctor, through which nb-sends and blocking-waits are executed.">m_mq</a> is in would-block condition) executing an indefinite, interrupting blocking wait for transmissibility of <a class="el" href="classipc_1_1transport_1_1sync__io_1_1Blob__stream__mq__sender__impl.html#a32a49dff090ce4b658707e7d9b9036c9" title="The MQ handle adopted by the ctor, through which nb-sends and blocking-waits are executed.">m_mq</a>. </p>
<p >When thread U wants to send-out a payload but gets would-block, it issues the wait on this thread W and a <code><a class="el" href="namespaceipc_1_1transport_1_1sync__io.html" title="sync_io-pattern counterparts to async-I/O-pattern object types in parent namespace ipc::transport.">sync_io</a></code>-pattern async-wait for <a class="el" href="classipc_1_1transport_1_1sync__io_1_1Blob__stream__mq__sender__impl.html#a31580924c39d2dfe9cdfa9f7cb36ccd4" title="Descriptor waitable by outside event loop async-waits – storing the same Native_handle as (and thus b...">m_ev_wait_hndl_mq</a>; once that wait completes in thread W, it writes a byte to an internal IPC-pipe. <a class="el" href="classipc_1_1transport_1_1sync__io_1_1Blob__stream__mq__sender__impl.html#a31580924c39d2dfe9cdfa9f7cb36ccd4" title="Descriptor waitable by outside event loop async-waits – storing the same Native_handle as (and thus b...">m_ev_wait_hndl_mq</a> becomes readable, the outside event loop lets <code>*this</code> know, which completes the async-wait.</p>
<p >In dtor we stop thread W, including using <a class="el" href="classipc_1_1transport_1_1Persistent__mq__handle.html#af7a883553df39b16047b49942bd734c0" title="Enables sends-interrupted mode: is_sendable() (future calls), send() (future or concurrent calls),...">Persistent_mq_handle::interrupt_sends()</a> to abort the indefinite wait in thread W, as it will no longer be used once <code>*this</code> is destroyed.</p>
<p >Ordering: If we want to let things get auto-destroyed without explicit <code>m_blocking_worker-&gt;stop()</code> or nullifying wrappers in an explicit order, then this must be declared after <a class="el" href="classipc_1_1transport_1_1sync__io_1_1Blob__stream__mq__sender__impl.html#a32a49dff090ce4b658707e7d9b9036c9" title="The MQ handle adopted by the ctor, through which nb-sends and blocking-waits are executed.">m_mq</a>. Otherwise code may still be finishing up in thread W when <a class="el" href="classipc_1_1transport_1_1sync__io_1_1Blob__stream__mq__sender__impl.html#a32a49dff090ce4b658707e7d9b9036c9" title="The MQ handle adopted by the ctor, through which nb-sends and blocking-waits are executed.">m_mq</a> is destroyed already. Anyway &ndash; as long as this is destroyed or <code>.stop()</code>ed before <a class="el" href="classipc_1_1transport_1_1sync__io_1_1Blob__stream__mq__sender__impl.html#a32a49dff090ce4b658707e7d9b9036c9" title="The MQ handle adopted by the ctor, through which nb-sends and blocking-waits are executed.">m_mq</a> is gone, you're cool.</p>
<p >Never touched if <a class="el" href="classipc_1_1transport_1_1Persistent__mq__handle.html#ac2c0b560893c6a8b71aac0e748770076" title="true if and only if native_handle() method exists, and the returned value may be waited-on by poll()/...">Persistent_mq_handle::S_HAS_NATIVE_HANDLE</a>. </p>

<p class="definition">Definition at line <a class="el" href="sync__io_2detail_2blob__stream__mq__snd__impl_8hpp_source.html#l00632">632</a> of file <a class="el" href="sync__io_2detail_2blob__stream__mq__snd__impl_8hpp_source.html">blob_stream_mq_snd_impl.hpp</a>.</p>

<p class="reference">Referenced by <a class="el" href="sync__io_2detail_2blob__stream__mq__snd__impl_8hpp_source.html#l00641">ipc::transport::sync_io::Blob_stream_mq_sender_impl&lt; Persistent_mq_handle &gt;::Blob_stream_mq_sender_impl()</a>.</p>

</div>
</div>
<a id="abdda4c698320a44bdf479340cbed6934" name="abdda4c698320a44bdf479340cbed6934"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abdda4c698320a44bdf479340cbed6934">&#9670;&nbsp;</a></span>m_ev_hndl_task_engine_unused</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename <a class="el" href="classipc_1_1transport_1_1Persistent__mq__handle.html">Persistent_mq_handle</a> &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">flow::util::Task_engine <a class="el" href="classipc_1_1transport_1_1sync__io_1_1Blob__stream__mq__sender__impl.html">ipc::transport::sync_io::Blob_stream_mq_sender_impl</a>&lt; <a class="el" href="classipc_1_1transport_1_1Persistent__mq__handle.html">Persistent_mq_handle</a> &gt;::m_ev_hndl_task_engine_unused</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>The <code>Task_engine</code> for <code>m_ev_wait_hndl_*</code>, unless it is replaced via <a class="el" href="classipc_1_1transport_1_1sync__io_1_1Blob__stream__mq__sender__impl.html#aa16854340cdf194120efd08f711c74f9" title="See Blob_stream_mq_sender counterpart.">replace_event_wait_handles()</a>. </p>
<p >There are 2 possibilities:</p><ul>
<li>They leave this guy associated with <code>m_ev_wait_hndl_*</code>. Then no one shall be doing <code>.async_wait()</code> on them, and instead the user aims to perhaps use raw <code>[e]poll*()</code> on their <code>.native_handle()</code>s. We still need some <code>Task_engine</code> to construct them though, so we use this.</li>
<li>They use <a class="el" href="classipc_1_1transport_1_1sync__io_1_1Blob__stream__mq__sender__impl.html#aa16854340cdf194120efd08f711c74f9" title="See Blob_stream_mq_sender counterpart.">replace_event_wait_handles()</a>, and therefore this becomes dissociated with <code>m_ev_wait_hndl_*</code> and becomes completely unused in any fashion, period. Then they shall probably be doing their own <code>.async_wait()</code> &ndash; associated with their own <code>Task_engine</code> &ndash; on <code>m_ev_wait_hndl_*</code>.</li>
</ul>
<p >This is all to fulfill the <code><a class="el" href="namespaceipc_1_1transport_1_1sync__io.html" title="sync_io-pattern counterparts to async-I/O-pattern object types in parent namespace ipc::transport.">sync_io</a></code> pattern. </p>

<p class="definition">Definition at line <a class="el" href="sync__io_2detail_2blob__stream__mq__snd__impl_8hpp_source.html#l00470">470</a> of file <a class="el" href="sync__io_2detail_2blob__stream__mq__snd__impl_8hpp_source.html">blob_stream_mq_snd_impl.hpp</a>.</p>

</div>
</div>
<a id="a9dca3046bc4d15657c08ac1c06f3b36d" name="a9dca3046bc4d15657c08ac1c06f3b36d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9dca3046bc4d15657c08ac1c06f3b36d">&#9670;&nbsp;</a></span>m_ev_wait_func</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename <a class="el" href="classipc_1_1transport_1_1Persistent__mq__handle.html">Persistent_mq_handle</a> &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespaceipc_1_1util_1_1sync__io.html#aa0b9a3cc6bdc7dedbef4f9e06851aa24">util::sync_io::Event_wait_func</a> <a class="el" href="classipc_1_1transport_1_1sync__io_1_1Blob__stream__mq__sender__impl.html">ipc::transport::sync_io::Blob_stream_mq_sender_impl</a>&lt; <a class="el" href="classipc_1_1transport_1_1Persistent__mq__handle.html">Persistent_mq_handle</a> &gt;::m_ev_wait_func</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Function (set forever in <a class="el" href="classipc_1_1transport_1_1sync__io_1_1Blob__stream__mq__sender__impl.html#aa3116afe888df718c4ae10befcf2a16f" title="See Blob_stream_mq_sender counterpart.">start_send_blob_ops()</a>) through which we invoke the outside event loop's async-wait facility for descriptors/events to our ops. </p>
<p >See <a class="el" href="namespaceipc_1_1util_1_1sync__io.html#aa0b9a3cc6bdc7dedbef4f9e06851aa24" title="In sync_io pattern, concrete type storing user-supplied function invoked by pattern-implementing ipc:...">util::sync_io::Event_wait_func</a> doc header for a refresher on this mechanic. </p>

<p class="definition">Definition at line <a class="el" href="sync__io_2detail_2blob__stream__mq__snd__impl_8hpp_source.html#l00613">613</a> of file <a class="el" href="sync__io_2detail_2blob__stream__mq__snd__impl_8hpp_source.html">blob_stream_mq_snd_impl.hpp</a>.</p>

</div>
</div>
<a id="a50bf9bbbf413b27e6189aa4d393b9dd7" name="a50bf9bbbf413b27e6189aa4d393b9dd7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a50bf9bbbf413b27e6189aa4d393b9dd7">&#9670;&nbsp;</a></span>m_ev_wait_hndl_auto_ping_timer_fired_peer</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename <a class="el" href="classipc_1_1transport_1_1Persistent__mq__handle.html">Persistent_mq_handle</a> &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classipc_1_1util_1_1sync__io_1_1Asio__waitable__native__handle.html">util::sync_io::Asio_waitable_native_handle</a> <a class="el" href="classipc_1_1transport_1_1sync__io_1_1Blob__stream__mq__sender__impl.html">ipc::transport::sync_io::Blob_stream_mq_sender_impl</a>&lt; <a class="el" href="classipc_1_1transport_1_1Persistent__mq__handle.html">Persistent_mq_handle</a> &gt;::m_ev_wait_hndl_auto_ping_timer_fired_peer</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Descriptor waitable by outside event loop async-waits &ndash; storing the same <code>Native_handle</code> as (and thus being used to wait on events from) <a class="el" href="classipc_1_1transport_1_1sync__io_1_1Blob__stream__mq__sender__impl.html#ac4bd1d018000ca258478b62cf67cc524" title="Read-end of IPC-mechanism used by m_timer_worker to ferry timer-fired events from m_auto_ping_timer t...">m_auto_ping_timer_fired_peer</a>. </p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classipc_1_1transport_1_1sync__io_1_1Blob__stream__mq__sender__impl.html#ab8bae935aff314b88d6163d04f52b5eb" title="As typical in timer-needing sync_io-pattern-implementing objects, maintains a thread exclusively for ...">m_timer_worker</a> for more info. </dd></dl>

<p class="definition">Definition at line <a class="el" href="sync__io_2detail_2blob__stream__mq__snd__impl_8hpp_source.html#l00606">606</a> of file <a class="el" href="sync__io_2detail_2blob__stream__mq__snd__impl_8hpp_source.html">blob_stream_mq_snd_impl.hpp</a>.</p>

</div>
</div>
<a id="a31580924c39d2dfe9cdfa9f7cb36ccd4" name="a31580924c39d2dfe9cdfa9f7cb36ccd4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a31580924c39d2dfe9cdfa9f7cb36ccd4">&#9670;&nbsp;</a></span>m_ev_wait_hndl_mq</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename <a class="el" href="classipc_1_1transport_1_1Persistent__mq__handle.html">Persistent_mq_handle</a> &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classipc_1_1util_1_1sync__io_1_1Asio__waitable__native__handle.html">util::sync_io::Asio_waitable_native_handle</a> <a class="el" href="classipc_1_1transport_1_1sync__io_1_1Blob__stream__mq__sender__impl.html">ipc::transport::sync_io::Blob_stream_mq_sender_impl</a>&lt; <a class="el" href="classipc_1_1transport_1_1Persistent__mq__handle.html">Persistent_mq_handle</a> &gt;::m_ev_wait_hndl_mq</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Descriptor waitable by outside event loop async-waits &ndash; storing the same <code>Native_handle</code> as (and thus being used to wait on events from) <a class="el" href="classipc_1_1transport_1_1sync__io_1_1Blob__stream__mq__sender__impl.html#a63f5f55ad38aecc5195a93bccaf23014" title="Read-end of IPC-pipe used by thread U to detect that a thread-W transmissibility-wait has completed,...">m_mq_ready_reader</a>; or if <a class="el" href="classipc_1_1transport_1_1sync__io_1_1Blob__stream__mq__sender__impl.html#a32a49dff090ce4b658707e7d9b9036c9" title="The MQ handle adopted by the ctor, through which nb-sends and blocking-waits are executed.">m_mq</a> can be watched directly (known at compile-time) then as <code>m_mq</code> itself. </p>
<p >Its name suggests it's watching <a class="el" href="classipc_1_1transport_1_1sync__io_1_1Blob__stream__mq__sender__impl.html#a32a49dff090ce4b658707e7d9b9036c9" title="The MQ handle adopted by the ctor, through which nb-sends and blocking-waits are executed.">m_mq</a> (for transmissibility), and that's true: In the latter case one directly watches it for transmissibility in the proper direction; in the former case <a class="el" href="classipc_1_1transport_1_1Persistent__mq__handle.html" title="A documentation-only concept defining the behavior of an object representing a light-weight handle to...">Persistent_mq_handle</a> lacks a <a class="el" href="namespaceipc_1_1transport.html#a7ee4551983d9df16ec16a3139bac50e8" title="Convenience alias for the commonly used type util::Native_handle.">Native_handle</a> to watch directly &ndash; but we use the <code>m_mq_ready_*</code> pipe and a background thread to simulate it having one. Thus in that case <a class="el" href="classipc_1_1transport_1_1sync__io_1_1Blob__stream__mq__sender__impl.html#a63f5f55ad38aecc5195a93bccaf23014" title="Read-end of IPC-pipe used by thread U to detect that a thread-W transmissibility-wait has completed,...">m_mq_ready_reader</a> FD = this FD, and it being transmissible = MQ being transmissible. </p>

<p class="definition">Definition at line <a class="el" href="sync__io_2detail_2blob__stream__mq__snd__impl_8hpp_source.html#l00533">533</a> of file <a class="el" href="sync__io_2detail_2blob__stream__mq__snd__impl_8hpp_source.html">blob_stream_mq_snd_impl.hpp</a>.</p>

<p class="reference">Referenced by <a class="el" href="sync__io_2detail_2blob__stream__mq__snd__impl_8hpp_source.html#l00641">ipc::transport::sync_io::Blob_stream_mq_sender_impl&lt; Persistent_mq_handle &gt;::Blob_stream_mq_sender_impl()</a>.</p>

</div>
</div>
<a id="ac9712c677320d7e9d4efa83798fa8aac" name="ac9712c677320d7e9d4efa83798fa8aac"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac9712c677320d7e9d4efa83798fa8aac">&#9670;&nbsp;</a></span>m_finished</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename <a class="el" href="classipc_1_1transport_1_1Persistent__mq__handle.html">Persistent_mq_handle</a> &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classipc_1_1transport_1_1sync__io_1_1Blob__stream__mq__sender__impl.html">ipc::transport::sync_io::Blob_stream_mq_sender_impl</a>&lt; <a class="el" href="classipc_1_1transport_1_1Persistent__mq__handle.html">Persistent_mq_handle</a> &gt;::m_finished</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><code>false</code> at start; set to <code>true</code> forever on the first <code>*end_sending()</code> invocation; <code>true</code> will prevent any subsequent <a class="el" href="classipc_1_1transport_1_1sync__io_1_1Blob__stream__mq__sender__impl.html#aba05c51d1033a4ea4ca03679f2fa1f8c" title="See Blob_stream_mq_sender counterpart, but assuming PEER state.">send_blob()</a> calls from proceeding. </p>
<p >See class doc header impl section for design discussion. </p>

<p class="definition">Definition at line <a class="el" href="sync__io_2detail_2blob__stream__mq__snd__impl_8hpp_source.html#l00564">564</a> of file <a class="el" href="sync__io_2detail_2blob__stream__mq__snd__impl_8hpp_source.html">blob_stream_mq_snd_impl.hpp</a>.</p>

</div>
</div>
<a id="a32a49dff090ce4b658707e7d9b9036c9" name="a32a49dff090ce4b658707e7d9b9036c9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a32a49dff090ce4b658707e7d9b9036c9">&#9670;&nbsp;</a></span>m_mq</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename <a class="el" href="classipc_1_1transport_1_1Persistent__mq__handle.html">Persistent_mq_handle</a> &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classipc_1_1transport_1_1Blob__stream__mq__base__impl.html#aab7c4c91d42c746c93e61eb367572eb1">Base::Auto_closing_mq</a> <a class="el" href="classipc_1_1transport_1_1sync__io_1_1Blob__stream__mq__sender__impl.html">ipc::transport::sync_io::Blob_stream_mq_sender_impl</a>&lt; <a class="el" href="classipc_1_1transport_1_1Persistent__mq__handle.html">Persistent_mq_handle</a> &gt;::m_mq</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>The MQ handle adopted by the ctor, through which nb-sends and blocking-waits are executed. </p>
<p >It is not directly protected by any mutex; however it is accessed exclusively as follows:</p><ul>
<li>By thread W, when <a class="el" href="classipc_1_1transport_1_1sync__io_1_1Blob__stream__mq__sender__impl.html#aaecb4615ae4d9fbf82ab2c195ada47cf" title="Queue storing (at head) the currently in-progress async write-op of a Snd_low_lvl_payload; followed b...">m_pending_payloads_q</a> has elements (would-block state), thus thread U has tasked it with awaiting sendability &ndash; which it is doing and is not yet done doing.</li>
<li>By thread U, when <a class="el" href="classipc_1_1transport_1_1sync__io_1_1Blob__stream__mq__sender__impl.html#aaecb4615ae4d9fbf82ab2c195ada47cf" title="Queue storing (at head) the currently in-progress async write-op of a Snd_low_lvl_payload; followed b...">m_pending_payloads_q</a> is <code>.empty()</code> (no would-block at the moment); or it is not .empty(), but thread W has signaled it is done awaiting non-would-block, so thread U is trying to empty it via nb-writes.</li>
</ul>
<p >Exception: <code>m_mq-&gt;interrupt_sends()</code> is done from thread U (dtor), potentially <em>while</em> thread W is inside <code>m_mq-&gt;wait_sendable()</code>. However that specific action is allowed by <a class="el" href="classipc_1_1transport_1_1Persistent__mq__handle.html" title="A documentation-only concept defining the behavior of an object representing a light-weight handle to...">Persistent_mq_handle</a> contract (in fact that is the main utility of <a class="el" href="classipc_1_1transport_1_1Persistent__mq__handle.html#af7a883553df39b16047b49942bd734c0" title="Enables sends-interrupted mode: is_sendable() (future calls), send() (future or concurrent calls),...">Persistent_mq_handle::interrupt_sends()</a>). It makes the <a class="el" href="classipc_1_1transport_1_1Persistent__mq__handle.html#a230060aa545bfe11eb263211c84514f1" title="Equivalent to send() except stops short of writing anything, with non-error return indicating that tr...">Persistent_mq_handle::wait_sendable()</a> immediately return.</p>
<h3>When is it null?</h3>
<p >See <a class="el" href="classipc_1_1transport_1_1sync__io_1_1Blob__stream__mq__receiver__impl.html#ae71fa0a5594915910b0b8dd88743f62e" title="The MQ handle adopted by the ctor, through which nb-receives and blocking-waits are executed.">Blob_stream_mq_receiver_impl::m_mq</a> doc header. The same comments apply here.</p>
<p >Explicit reminder though: Do not <code>m_mq.reset()</code> until dtor, if not null upon exiting ctor! </p>

<p class="definition">Definition at line <a class="el" href="sync__io_2detail_2blob__stream__mq__snd__impl_8hpp_source.html#l00491">491</a> of file <a class="el" href="sync__io_2detail_2blob__stream__mq__snd__impl_8hpp_source.html">blob_stream_mq_snd_impl.hpp</a>.</p>

<p class="reference">Referenced by <a class="el" href="sync__io_2detail_2blob__stream__mq__snd__impl_8hpp_source.html#l00641">ipc::transport::sync_io::Blob_stream_mq_sender_impl&lt; Persistent_mq_handle &gt;::Blob_stream_mq_sender_impl()</a>.</p>

</div>
</div>
<a id="a3a69e00d989a53f1151c64b58560551f" name="a3a69e00d989a53f1151c64b58560551f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3a69e00d989a53f1151c64b58560551f">&#9670;&nbsp;</a></span>m_mq_max_msg_sz</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename <a class="el" href="classipc_1_1transport_1_1Persistent__mq__handle.html">Persistent_mq_handle</a> &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const size_t <a class="el" href="classipc_1_1transport_1_1sync__io_1_1Blob__stream__mq__sender__impl.html">ipc::transport::sync_io::Blob_stream_mq_sender_impl</a>&lt; <a class="el" href="classipc_1_1transport_1_1Persistent__mq__handle.html">Persistent_mq_handle</a> &gt;::m_mq_max_msg_sz</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Equals <code>m_mq.max_msg_size()</code>. </p>
<h3>Rationale</h3>
<p >It is saved in ctor, instead of invoking <code>m_mq-&gt;max_msg_size()</code> when needed, to keep the rules for when <a class="el" href="classipc_1_1transport_1_1sync__io_1_1Blob__stream__mq__sender__impl.html#a32a49dff090ce4b658707e7d9b9036c9" title="The MQ handle adopted by the ctor, through which nb-sends and blocking-waits are executed.">m_mq</a> is accessed simple and as described in its doc header. After all this value would never change anyway. </p>

<p class="definition">Definition at line <a class="el" href="sync__io_2detail_2blob__stream__mq__snd__impl_8hpp_source.html#l00499">499</a> of file <a class="el" href="sync__io_2detail_2blob__stream__mq__snd__impl_8hpp_source.html">blob_stream_mq_snd_impl.hpp</a>.</p>

</div>
</div>
<a id="a63f5f55ad38aecc5195a93bccaf23014" name="a63f5f55ad38aecc5195a93bccaf23014"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a63f5f55ad38aecc5195a93bccaf23014">&#9670;&nbsp;</a></span>m_mq_ready_reader</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename <a class="el" href="classipc_1_1transport_1_1Persistent__mq__handle.html">Persistent_mq_handle</a> &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::optional&lt;<a class="el" href="namespaceipc_1_1util.html#aaf368acf8243bb25de3eef4e836c15de">util::Pipe_reader</a>&gt; <a class="el" href="classipc_1_1transport_1_1sync__io_1_1Blob__stream__mq__sender__impl.html">ipc::transport::sync_io::Blob_stream_mq_sender_impl</a>&lt; <a class="el" href="classipc_1_1transport_1_1Persistent__mq__handle.html">Persistent_mq_handle</a> &gt;::m_mq_ready_reader</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Read-end of IPC-pipe used by thread U to detect that a thread-W transmissibility-wait has completed, meaning would-block has cleared, and therefore thread U can attempt to nb-transmit again. </p>
<p >The signal byte is read out of <a class="el" href="classipc_1_1transport_1_1sync__io_1_1Blob__stream__mq__sender__impl.html#a63f5f55ad38aecc5195a93bccaf23014" title="Read-end of IPC-pipe used by thread U to detect that a thread-W transmissibility-wait has completed,...">m_mq_ready_reader</a>, making it empty again (the steady-state before the next time would-block occurs, and a byte is written to it making it non-empty).</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classipc_1_1transport_1_1sync__io_1_1Blob__stream__mq__sender__impl.html#a72c3901ca66a8d94aa22c83118aedbdd" title="Write-end of IPC-pipe used by thread W to inform thread U that a thread-W transmissibility-wait has c...">m_mq_ready_writer</a>.</dd></dl>
<p>Never touched if <a class="el" href="classipc_1_1transport_1_1Persistent__mq__handle.html#ac2c0b560893c6a8b71aac0e748770076" title="true if and only if native_handle() method exists, and the returned value may be waited-on by poll()/...">Persistent_mq_handle::S_HAS_NATIVE_HANDLE</a>. </p>

<p class="definition">Definition at line <a class="el" href="sync__io_2detail_2blob__stream__mq__snd__impl_8hpp_source.html#l00511">511</a> of file <a class="el" href="sync__io_2detail_2blob__stream__mq__snd__impl_8hpp_source.html">blob_stream_mq_snd_impl.hpp</a>.</p>

<p class="reference">Referenced by <a class="el" href="sync__io_2detail_2blob__stream__mq__snd__impl_8hpp_source.html#l00641">ipc::transport::sync_io::Blob_stream_mq_sender_impl&lt; Persistent_mq_handle &gt;::Blob_stream_mq_sender_impl()</a>.</p>

</div>
</div>
<a id="a72c3901ca66a8d94aa22c83118aedbdd" name="a72c3901ca66a8d94aa22c83118aedbdd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a72c3901ca66a8d94aa22c83118aedbdd">&#9670;&nbsp;</a></span>m_mq_ready_writer</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename <a class="el" href="classipc_1_1transport_1_1Persistent__mq__handle.html">Persistent_mq_handle</a> &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::optional&lt;<a class="el" href="namespaceipc_1_1util.html#a844d5ca9c17b672644fc8d9dbe758db0">util::Pipe_writer</a>&gt; <a class="el" href="classipc_1_1transport_1_1sync__io_1_1Blob__stream__mq__sender__impl.html">ipc::transport::sync_io::Blob_stream_mq_sender_impl</a>&lt; <a class="el" href="classipc_1_1transport_1_1Persistent__mq__handle.html">Persistent_mq_handle</a> &gt;::m_mq_ready_writer</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Write-end of IPC-pipe used by thread W to inform thread U that a thread-W transmissibility-wait has completed, meaning would-block has cleared, and therefore thread U can attempt to nb-transmit again. </p>
<p >A signal byte is written to <a class="el" href="classipc_1_1transport_1_1sync__io_1_1Blob__stream__mq__sender__impl.html#a72c3901ca66a8d94aa22c83118aedbdd" title="Write-end of IPC-pipe used by thread W to inform thread U that a thread-W transmissibility-wait has c...">m_mq_ready_writer</a>, making it non-empty.</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classipc_1_1transport_1_1sync__io_1_1Blob__stream__mq__sender__impl.html#a63f5f55ad38aecc5195a93bccaf23014" title="Read-end of IPC-pipe used by thread U to detect that a thread-W transmissibility-wait has completed,...">m_mq_ready_reader</a>.</dd></dl>
<p>Never touched if <a class="el" href="classipc_1_1transport_1_1Persistent__mq__handle.html#ac2c0b560893c6a8b71aac0e748770076" title="true if and only if native_handle() method exists, and the returned value may be waited-on by poll()/...">Persistent_mq_handle::S_HAS_NATIVE_HANDLE</a>. </p>

<p class="definition">Definition at line <a class="el" href="sync__io_2detail_2blob__stream__mq__snd__impl_8hpp_source.html#l00522">522</a> of file <a class="el" href="sync__io_2detail_2blob__stream__mq__snd__impl_8hpp_source.html">blob_stream_mq_snd_impl.hpp</a>.</p>

<p class="reference">Referenced by <a class="el" href="sync__io_2detail_2blob__stream__mq__snd__impl_8hpp_source.html#l00641">ipc::transport::sync_io::Blob_stream_mq_sender_impl&lt; Persistent_mq_handle &gt;::Blob_stream_mq_sender_impl()</a>.</p>

</div>
</div>
<a id="a0614000879d4595c84f803ecadae708a" name="a0614000879d4595c84f803ecadae708a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0614000879d4595c84f803ecadae708a">&#9670;&nbsp;</a></span>m_nb_task_engine</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename <a class="el" href="classipc_1_1transport_1_1Persistent__mq__handle.html">Persistent_mq_handle</a> &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::optional&lt;flow::util::Task_engine&gt; <a class="el" href="classipc_1_1transport_1_1sync__io_1_1Blob__stream__mq__sender__impl.html">ipc::transport::sync_io::Blob_stream_mq_sender_impl</a>&lt; <a class="el" href="classipc_1_1transport_1_1Persistent__mq__handle.html">Persistent_mq_handle</a> &gt;::m_nb_task_engine</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>The <code>Task_engine</code> for <code>m_mq_ready_*</code>. </p>
<p >It is necessary to construct those pipe-end objects, but we never use that guy's <code>-&gt;async_*()</code> APIs &ndash; only non-blocking operations, essentially leveraging boost.asio's portable transmission APIs but not its actual, um, async-I/O abilities in this case. Accordingly we never load any tasks onto <a class="el" href="classipc_1_1transport_1_1sync__io_1_1Blob__stream__mq__sender__impl.html#a0614000879d4595c84f803ecadae708a" title="The Task_engine for m_mq_ready_*.">m_nb_task_engine</a> and certainly never <code>.run()</code> (or <code>.poll()</code> or ...) it.</p>
<p >In the <code><a class="el" href="namespaceipc_1_1transport_1_1sync__io.html" title="sync_io-pattern counterparts to async-I/O-pattern object types in parent namespace ipc::transport.">sync_io</a></code> pattern the user's outside event loop is responsible for awaiting readability/writability of a guy like <a class="el" href="classipc_1_1transport_1_1sync__io_1_1Blob__stream__mq__sender__impl.html#a63f5f55ad38aecc5195a93bccaf23014" title="Read-end of IPC-pipe used by thread U to detect that a thread-W transmissibility-wait has completed,...">m_mq_ready_reader</a> via our exporting of its <code>.native_handle()</code>.</p>
<p >Never touched if <a class="el" href="classipc_1_1transport_1_1Persistent__mq__handle.html#ac2c0b560893c6a8b71aac0e748770076" title="true if and only if native_handle() method exists, and the returned value may be waited-on by poll()/...">Persistent_mq_handle::S_HAS_NATIVE_HANDLE</a>.</p>
<dl class="todo"><dt><b><a class="el" href="todo.html#_todo000014">Todo:</a></b></dt><dd>Consider using specialization instead of or in addition <code>if constexpr()</code> w/r/t <code>Mq::S_HAS_NATIVE_HANDLE</code>-based compile-time branching: it could save some RAM by eliminating <code>optional</code>s such as the one near this to-do; though code would likely become wordier. </dd></dl>

<p class="definition">Definition at line <a class="el" href="sync__io_2detail_2blob__stream__mq__snd__impl_8hpp_source.html#l00456">456</a> of file <a class="el" href="sync__io_2detail_2blob__stream__mq__snd__impl_8hpp_source.html">blob_stream_mq_snd_impl.hpp</a>.</p>

<p class="reference">Referenced by <a class="el" href="sync__io_2detail_2blob__stream__mq__snd__impl_8hpp_source.html#l00641">ipc::transport::sync_io::Blob_stream_mq_sender_impl&lt; Persistent_mq_handle &gt;::Blob_stream_mq_sender_impl()</a>.</p>

</div>
</div>
<a id="ab9c3904b9cd89438c1f2de5ec974f814" name="ab9c3904b9cd89438c1f2de5ec974f814"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab9c3904b9cd89438c1f2de5ec974f814">&#9670;&nbsp;</a></span>m_nickname</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename <a class="el" href="classipc_1_1transport_1_1Persistent__mq__handle.html">Persistent_mq_handle</a> &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const std::string <a class="el" href="classipc_1_1transport_1_1sync__io_1_1Blob__stream__mq__sender__impl.html">ipc::transport::sync_io::Blob_stream_mq_sender_impl</a>&lt; <a class="el" href="classipc_1_1transport_1_1Persistent__mq__handle.html">Persistent_mq_handle</a> &gt;::m_nickname</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>See <a class="el" href="classipc_1_1transport_1_1sync__io_1_1Blob__stream__mq__sender__impl.html#ad30ee34fd91e68a084d207763e753f6d" title="See Blob_stream_mq_sender counterpart, but assuming PEER state.">nickname()</a>. </p>

<p class="definition">Definition at line <a class="el" href="sync__io_2detail_2blob__stream__mq__snd__impl_8hpp_source.html#l00394">394</a> of file <a class="el" href="sync__io_2detail_2blob__stream__mq__snd__impl_8hpp_source.html">blob_stream_mq_snd_impl.hpp</a>.</p>

</div>
</div>
<a id="affd27be454f2e394f44fc76a5a4c50de" name="affd27be454f2e394f44fc76a5a4c50de"></a>
<h2 class="memtitle"><span class="permalink"><a href="#affd27be454f2e394f44fc76a5a4c50de">&#9670;&nbsp;</a></span>m_pending_err_code</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename <a class="el" href="classipc_1_1transport_1_1Persistent__mq__handle.html">Persistent_mq_handle</a> &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespaceipc.html#aa3192e586cc45d3e7c22463bf2760f89">Error_code</a> <a class="el" href="classipc_1_1transport_1_1sync__io_1_1Blob__stream__mq__sender__impl.html">ipc::transport::sync_io::Blob_stream_mq_sender_impl</a>&lt; <a class="el" href="classipc_1_1transport_1_1Persistent__mq__handle.html">Persistent_mq_handle</a> &gt;::m_pending_err_code</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>The first and only connection-hosing error condition detected when attempting to low-level-write on <a class="el" href="classipc_1_1transport_1_1sync__io_1_1Blob__stream__mq__sender__impl.html#a32a49dff090ce4b658707e7d9b9036c9" title="The MQ handle adopted by the ctor, through which nb-sends and blocking-waits are executed.">m_mq</a>; or falsy if no such error has yet been detected. </p>
<p >Among possible other uses, it is returned by <a class="el" href="classipc_1_1transport_1_1sync__io_1_1Blob__stream__mq__sender__impl.html#aba05c51d1033a4ea4ca03679f2fa1f8c" title="See Blob_stream_mq_sender counterpart, but assuming PEER state.">send_blob()</a> and the completion handler of <a class="el" href="classipc_1_1transport_1_1sync__io_1_1Blob__stream__mq__sender__impl.html#a4709b00fb1a8fc0ea63535d0a47f15f0" title="See Blob_stream_mq_sender counterpart, but assuming PEER state.">async_end_sending()</a>. </p>

<p class="definition">Definition at line <a class="el" href="sync__io_2detail_2blob__stream__mq__snd__impl_8hpp_source.html#l00557">557</a> of file <a class="el" href="sync__io_2detail_2blob__stream__mq__snd__impl_8hpp_source.html">blob_stream_mq_snd_impl.hpp</a>.</p>

<p class="reference">Referenced by <a class="el" href="sync__io_2detail_2blob__stream__mq__snd__impl_8hpp_source.html#l00641">ipc::transport::sync_io::Blob_stream_mq_sender_impl&lt; Persistent_mq_handle &gt;::Blob_stream_mq_sender_impl()</a>.</p>

</div>
</div>
<a id="a48689f6fbe1a1d4df3285736326b18f4" name="a48689f6fbe1a1d4df3285736326b18f4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a48689f6fbe1a1d4df3285736326b18f4">&#9670;&nbsp;</a></span>m_pending_on_last_send_done_func_or_empty</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename <a class="el" href="classipc_1_1transport_1_1Persistent__mq__handle.html">Persistent_mq_handle</a> &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">flow::async::Task_asio_err <a class="el" href="classipc_1_1transport_1_1sync__io_1_1Blob__stream__mq__sender__impl.html">ipc::transport::sync_io::Blob_stream_mq_sender_impl</a>&lt; <a class="el" href="classipc_1_1transport_1_1Persistent__mq__handle.html">Persistent_mq_handle</a> &gt;::m_pending_on_last_send_done_func_or_empty</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Function passed to <a class="el" href="classipc_1_1transport_1_1sync__io_1_1Blob__stream__mq__sender__impl.html#a4709b00fb1a8fc0ea63535d0a47f15f0" title="See Blob_stream_mq_sender counterpart, but assuming PEER state.">async_end_sending()</a>, if it returned <code>true</code> and was unable to synchronously flush everything including the graceful-close itself (synchronously detecting new or previous pipe-hosing error <em>does</em> entail flushing everything); otherwise <code>.empty()</code>. </p>
<p >It's the completion handler of that graceful-close-send API. </p>

<p class="definition">Definition at line <a class="el" href="sync__io_2detail_2blob__stream__mq__snd__impl_8hpp_source.html#l00571">571</a> of file <a class="el" href="sync__io_2detail_2blob__stream__mq__snd__impl_8hpp_source.html">blob_stream_mq_snd_impl.hpp</a>.</p>

</div>
</div>
<a id="aaecb4615ae4d9fbf82ab2c195ada47cf" name="aaecb4615ae4d9fbf82ab2c195ada47cf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaecb4615ae4d9fbf82ab2c195ada47cf">&#9670;&nbsp;</a></span>m_pending_payloads_q</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename <a class="el" href="classipc_1_1transport_1_1Persistent__mq__handle.html">Persistent_mq_handle</a> &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::queue&lt;typename <a class="el" href="structipc_1_1transport_1_1sync__io_1_1Blob__stream__mq__sender__impl_1_1Snd__low__lvl__payload.html#ad30cb6fc47d87a52a665e748b48e47ed">Snd_low_lvl_payload::Ptr</a>&gt; <a class="el" href="classipc_1_1transport_1_1sync__io_1_1Blob__stream__mq__sender__impl.html">ipc::transport::sync_io::Blob_stream_mq_sender_impl</a>&lt; <a class="el" href="classipc_1_1transport_1_1Persistent__mq__handle.html">Persistent_mq_handle</a> &gt;::m_pending_payloads_q</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Queue storing (at head) the currently in-progress async write-op of a <a class="el" href="structipc_1_1transport_1_1sync__io_1_1Blob__stream__mq__sender__impl_1_1Snd__low__lvl__payload.html" title="Data store representing a payload corresponding to exactly one attempted async write-op,...">Snd_low_lvl_payload</a>; followed by the payloads that should be written after that completes, in order. </p>
<p >Only touched if would-block is encountered in... well, see <a class="el" href="structipc_1_1transport_1_1sync__io_1_1Blob__stream__mq__sender__impl_1_1Snd__low__lvl__payload.html" title="Data store representing a payload corresponding to exactly one attempted async write-op,...">Snd_low_lvl_payload</a> doc header (et al). </p>

<p class="definition">Definition at line <a class="el" href="sync__io_2detail_2blob__stream__mq__snd__impl_8hpp_source.html#l00550">550</a> of file <a class="el" href="sync__io_2detail_2blob__stream__mq__snd__impl_8hpp_source.html">blob_stream_mq_snd_impl.hpp</a>.</p>

</div>
</div>
<a id="a28485fe8e4fbeea78f05eadc69a31c20" name="a28485fe8e4fbeea78f05eadc69a31c20"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a28485fe8e4fbeea78f05eadc69a31c20">&#9670;&nbsp;</a></span>m_protocol_negotiator</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename <a class="el" href="classipc_1_1transport_1_1Persistent__mq__handle.html">Persistent_mq_handle</a> &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classipc_1_1transport_1_1Protocol__negotiator.html">Protocol_negotiator</a> <a class="el" href="classipc_1_1transport_1_1sync__io_1_1Blob__stream__mq__sender__impl.html">ipc::transport::sync_io::Blob_stream_mq_sender_impl</a>&lt; <a class="el" href="classipc_1_1transport_1_1Persistent__mq__handle.html">Persistent_mq_handle</a> &gt;::m_protocol_negotiator</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Handles the protocol negotiation at the start of the pipe. </p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classipc_1_1transport_1_1Protocol__negotiator.html" title="A simple state machine that, assuming the opposide side of a comm pathway uses an equivalent state ma...">Protocol_negotiator</a> doc header for key background on the topic. In particular check out the discussion "Key tip: Coding for version-1 versus one version versus multiple versions."</dd></dl>
<h3>Maintenace/future</h3>
<p >This version of the software talks only the initial version of the protocol: version 1 by <a class="el" href="classipc_1_1transport_1_1Protocol__negotiator.html" title="A simple state machine that, assuming the opposide side of a comm pathway uses an equivalent state ma...">Protocol_negotiator</a> convention. (Deities willing, we won't need to create more, but possibly we will.) As expained in the above-mentioned doc header section, we have very little to worry about as the sender: Just send our version, 1, as the first message (in fact, a special CONTROL message; and we send it first-thing, ahead of the first payload that would be otherwise sent, whether it's a user payload, or the end-sending token, or an auto-ping). Only version 1 exists, so we simply speak it.</p>
<p >This <em>might</em> change in the future. If there is a version 2 or later, <em>and</em> at some point we decide to maintain backwards-compatibility (not a no-brainer decision in either direction), meaning we pass a range of 2 versions or more to <a class="el" href="classipc_1_1transport_1_1Protocol__negotiator.html" title="A simple state machine that, assuming the opposide side of a comm pathway uses an equivalent state ma...">Protocol_negotiator</a> ctor, then:</p><ul>
<li>We will need to know which version to speak when sending at least <em>some</em> of our messages.</li>
<li>Normally we'd get this via a separate incoming pipe &ndash; a paired <a class="el" href="classipc_1_1transport_1_1sync__io_1_1Blob__stream__mq__receiver.html" title="Implements sync_io::Blob_receiver concept by using an adopted Persistent_mq_handle MQ handle to an MQ...">Blob_stream_mq_receiver</a> handling a separate associated MQ. So we'd need:<ul>
<li>some kind of internal logic to enter a would-block state of sorts (if we need to know the version for a certain out-message, and we haven't been told it yet) during which stuff is queued-up and not yet sent until signaled with the negotiated protocol version;</li>
<li>some kind of API that would let the paired <a class="el" href="classipc_1_1transport_1_1sync__io_1_1Blob__stream__mq__receiver.html" title="Implements sync_io::Blob_receiver concept by using an adopted Persistent_mq_handle MQ handle to an MQ...">Blob_stream_mq_receiver</a> signal us to tell us that version, when it knows;</li>
<li>possibly some kind of API that one could use in the absence of such a paired opposite-facing pipe, so that our user can simply tell us what protocol version to speak in lieu of the paired <a class="el" href="classipc_1_1transport_1_1sync__io_1_1Blob__stream__mq__receiver.html" title="Implements sync_io::Blob_receiver concept by using an adopted Persistent_mq_handle MQ handle to an MQ...">Blob_stream_mq_receiver</a>.</li>
</ul>
</li>
</ul>
<p >(Just to point a fine point on it: We are <em>one</em> direction of a <em>likely</em> bidirectional comm pathway. <a class="el" href="classipc_1_1transport_1_1Protocol__negotiator.html" title="A simple state machine that, assuming the opposide side of a comm pathway uses an equivalent state ma...">Protocol_negotiator</a> by definition applies to a bidirectional pathway. Yet we <em>can</em> exist in isolation, with no partner opposing MQ and therefore no partner local <a class="el" href="classipc_1_1transport_1_1sync__io_1_1Blob__stream__mq__sender__impl.html" title="Internal, non-movable pImpl-lite implementation of sync_io::Blob_stream_mq_sender class template.">Blob_stream_mq_sender_impl</a>. If that is indeed the case, then it is meaningless for <em>us</em> to somehow find out what protocol the either side speaks, as the other side has no way of sending us <em>anything</em>! Hence the dichotomy between those last 2 sub-bullets: If we exist in isolation and are unidirectional, then you'd best simply tell us what to speak... but if we're part of a bidirectional setup, then we can cooperate with the other direction more automagically.</p>
<p >These are decisions and work for another day, though; it is not relevant until version 2 of this protocol at the earliest. That might not even happen. </p>

<p class="definition">Definition at line <a class="el" href="sync__io_2detail_2blob__stream__mq__snd__impl_8hpp_source.html#l00436">436</a> of file <a class="el" href="sync__io_2detail_2blob__stream__mq__snd__impl_8hpp_source.html">blob_stream_mq_snd_impl.hpp</a>.</p>

</div>
</div>
<a id="ab8bae935aff314b88d6163d04f52b5eb" name="ab8bae935aff314b88d6163d04f52b5eb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab8bae935aff314b88d6163d04f52b5eb">&#9670;&nbsp;</a></span>m_timer_worker</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename <a class="el" href="classipc_1_1transport_1_1Persistent__mq__handle.html">Persistent_mq_handle</a> &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classipc_1_1util_1_1sync__io_1_1Timer__event__emitter.html">util::sync_io::Timer_event_emitter</a> <a class="el" href="classipc_1_1transport_1_1sync__io_1_1Blob__stream__mq__sender__impl.html">ipc::transport::sync_io::Blob_stream_mq_sender_impl</a>&lt; <a class="el" href="classipc_1_1transport_1_1Persistent__mq__handle.html">Persistent_mq_handle</a> &gt;::m_timer_worker</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>As typical in timer-needing <code><a class="el" href="namespaceipc_1_1transport_1_1sync__io.html" title="sync_io-pattern counterparts to async-I/O-pattern object types in parent namespace ipc::transport.">sync_io</a></code>-pattern-implementing objects, maintains a thread exclusively for <code>Timer</code> wait completion handlers which ferry timer-fired events to internal IPC-mechanisms waitable by the <code><a class="el" href="namespaceipc_1_1transport_1_1sync__io.html" title="sync_io-pattern counterparts to async-I/O-pattern object types in parent namespace ipc::transport.">sync_io</a></code>-pattern-using outside event loop. </p>
<p >In our case we (optionally) maintain the auto-ping timer.</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classipc_1_1util_1_1sync__io_1_1Timer__event__emitter.html" title="An object of this type, used internally to implement sync_io-pattern objects that require timer event...">util::sync_io::Timer_event_emitter</a> doc header for design/rationale discussion. </dd></dl>

<p class="definition">Definition at line <a class="el" href="sync__io_2detail_2blob__stream__mq__snd__impl_8hpp_source.html#l00542">542</a> of file <a class="el" href="sync__io_2detail_2blob__stream__mq__snd__impl_8hpp_source.html">blob_stream_mq_snd_impl.hpp</a>.</p>

</div>
</div>
<hr/>The documentation for this class was generated from the following files:<ul>
<li>transport/detail/<a class="el" href="detail_2transport__fwd_8hpp_source.html">transport_fwd.hpp</a></li>
<li>transport/sync_io/detail/<a class="el" href="sync__io_2detail_2blob__stream__mq__snd__impl_8hpp_source.html">blob_stream_mq_snd_impl.hpp</a></li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Wed Feb 19 2025 00:46:51 for Flow-IPC by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.4
</small></address>
</body>
</html>
