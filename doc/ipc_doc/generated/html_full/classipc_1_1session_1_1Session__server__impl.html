<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.9.4"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Flow-IPC: ipc::session::Session_server_impl&lt; Session_server_t, Server_session_t &gt; Class Template Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">Flow-IPC<span id="projectnumber">&#160;1.0.1</span>
   </div>
   <div id="projectbrief">Flow-IPC project: Full implementation reference.</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.4 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search",'Search','.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespaceipc.html">ipc</a></li><li class="navelem"><a class="el" href="namespaceipc_1_1session.html">session</a></li><li class="navelem"><a class="el" href="classipc_1_1session_1_1Session__server__impl.html">Session_server_impl</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#pub-types">Public Types</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pub-attribs">Public Attributes</a> &#124;
<a href="#pro-methods">Protected Member Functions</a> &#124;
<a href="#pri-types">Private Types</a> &#124;
<a href="#pri-attribs">Private Attributes</a> &#124;
<a href="#related">Related Functions</a> &#124;
<a href="classipc_1_1session_1_1Session__server__impl-members.html">List of all members</a>  </div>
  <div class="headertitle"><div class="title">ipc::session::Session_server_impl&lt; Session_server_t, Server_session_t &gt; Class Template Reference</div></div>
</div><!--header-->
<div class="contents">

<p>Internal class template comprising API/logic common to every <a class="el" href="classipc_1_1session_1_1Session__server.html" title="To be instantiated typically once in a given process, an object of this type asynchronously listens f...">Session_server</a> variant, meant to be <code>private</code>ly sub-classed and largely forwarded.  
 <a href="classipc_1_1session_1_1Session__server__impl.html#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="session__server__impl_8hpp_source.html">session_server_impl.hpp</a>&gt;</code></p>
<div class="dynheader">
Inheritance diagram for ipc::session::Session_server_impl&lt; Session_server_t, Server_session_t &gt;:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="classipc_1_1session_1_1Session__server__impl__inherit__graph.svg" width="310" height="131"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe>
</div>
<center><span class="legend">[<a href="graph_legend.html">legend</a>]</span></center></div>
<div class="dynheader">
Collaboration diagram for ipc::session::Session_server_impl&lt; Session_server_t, Server_session_t &gt;:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="classipc_1_1session_1_1Session__server__impl__coll__graph.svg" width="1224" height="434"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe>
</div>
<center><span class="legend">[<a href="graph_legend.html">legend</a>]</span></center></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="nested-classes" name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structipc_1_1session_1_1Session__server__impl_1_1State.html">State</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">All internal mutable state of <a class="el" href="classipc_1_1session_1_1Session__server__impl.html" title="Internal class template comprising API/logic common to every Session_server variant,...">Session_server_impl</a>.  <a href="structipc_1_1session_1_1Session__server__impl_1_1State.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-types" name="pub-types"></a>
Public Types</h2></td></tr>
<tr class="memitem:a47625f247dea35cf276d31c039c6bf0c"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classipc_1_1session_1_1Session__server__impl.html#a47625f247dea35cf276d31c039c6bf0c">Session_server_obj</a> = Session_server_t</td></tr>
<tr class="memdesc:a47625f247dea35cf276d31c039c6bf0c"><td class="mdescLeft">&#160;</td><td class="mdescRight">See <a class="el" href="classipc_1_1session_1_1Session__server__impl.html#ad7cd4d77db826af9fe39c17e8ee7ca37" title="Returns pointer to the object that is privately sub-classing us.">this_session_srv()</a>.  <a href="classipc_1_1session_1_1Session__server__impl.html#a47625f247dea35cf276d31c039c6bf0c">More...</a><br /></td></tr>
<tr class="separator:a47625f247dea35cf276d31c039c6bf0c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0009247dd98ec58b22040d1c65bb5a54"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classipc_1_1session_1_1Session__server__impl.html#a0009247dd98ec58b22040d1c65bb5a54">Server_session_obj</a> = <a class="el" href="classServer__session__t.html">Server_session_t</a></td></tr>
<tr class="memdesc:a0009247dd98ec58b22040d1c65bb5a54"><td class="mdescLeft">&#160;</td><td class="mdescRight">Useful short-hand for the concrete <code>Server_session</code> type emitted by <a class="el" href="classipc_1_1session_1_1Session__server__impl.html#a60ec88b23d73c354959a1e11636dc717" title="See Session_server method.">async_accept()</a>.  <a href="classipc_1_1session_1_1Session__server__impl.html#a0009247dd98ec58b22040d1c65bb5a54">More...</a><br /></td></tr>
<tr class="separator:a0009247dd98ec58b22040d1c65bb5a54"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a86de1d5b7cae35d89827c3235e2b8d89"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classipc_1_1session_1_1Session__server__impl.html#a86de1d5b7cae35d89827c3235e2b8d89">Mdt_reader_ptr</a> = typename Server_session_obj::Mdt_reader_ptr</td></tr>
<tr class="memdesc:a86de1d5b7cae35d89827c3235e2b8d89"><td class="mdescLeft">&#160;</td><td class="mdescRight">Short-hand for <a class="el" href="classipc_1_1session_1_1Session__mv.html#a2b1215fb0c9738b9fcfbb337d23c43df" title="Implements Session API per contract.">Session_mv::Mdt_reader_ptr</a>.  <a href="classipc_1_1session_1_1Session__server__impl.html#a86de1d5b7cae35d89827c3235e2b8d89">More...</a><br /></td></tr>
<tr class="separator:a86de1d5b7cae35d89827c3235e2b8d89"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9ad5c6cbb1c9378d42ec5cd909389dc2"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classipc_1_1session_1_1Session__server__impl.html#a9ad5c6cbb1c9378d42ec5cd909389dc2">Channels</a> = typename Server_session_obj::Channels</td></tr>
<tr class="memdesc:a9ad5c6cbb1c9378d42ec5cd909389dc2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Short-hand for <a class="el" href="classipc_1_1session_1_1Session__mv.html#af87da439644b2afd73d6a13d97e7985f" title="Container (vector&lt;&gt;) of Channel_obj.">Session_mv::Channels</a>.  <a href="classipc_1_1session_1_1Session__server__impl.html#a9ad5c6cbb1c9378d42ec5cd909389dc2">More...</a><br /></td></tr>
<tr class="separator:a9ad5c6cbb1c9378d42ec5cd909389dc2"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-methods" name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a9bf4d5502b41c98a98fee4cc3c2f2530"><td class="memTemplParams" colspan="2">template&lt;typename Per_app_setup_func &gt; </td></tr>
<tr class="memitem:a9bf4d5502b41c98a98fee4cc3c2f2530"><td class="memTemplItemLeft" align="right" valign="top">&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classipc_1_1session_1_1Session__server__impl.html#a9bf4d5502b41c98a98fee4cc3c2f2530">Session_server_impl</a> (flow::log::Logger *logger_ptr, <a class="el" href="classipc_1_1session_1_1Session__server__impl.html#a47625f247dea35cf276d31c039c6bf0c">Session_server_obj</a> *this_session_srv_arg, const <a class="el" href="structipc_1_1session_1_1Server__app.html">Server_app</a> &amp;srv_app_ref, const <a class="el" href="structipc_1_1session_1_1Client__app.html#add718cbf6aa1d2abb26fbadcc974a7bd">Client_app::Master_set</a> &amp;cli_app_master_set_ref, <a class="el" href="namespaceipc.html#aa3192e586cc45d3e7c22463bf2760f89">Error_code</a> *err_code, Per_app_setup_func &amp;&amp;per_app_setup_func)</td></tr>
<tr class="memdesc:a9bf4d5502b41c98a98fee4cc3c2f2530"><td class="mdescLeft">&#160;</td><td class="mdescRight">See <a class="el" href="classipc_1_1session_1_1Session__server.html" title="To be instantiated typically once in a given process, an object of this type asynchronously listens f...">Session_server</a> ctor; it does that.  <a href="classipc_1_1session_1_1Session__server__impl.html#a9bf4d5502b41c98a98fee4cc3c2f2530">More...</a><br /></td></tr>
<tr class="separator:a9bf4d5502b41c98a98fee4cc3c2f2530"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae4388def520aad700a3fcdfc95b6f24e"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classipc_1_1session_1_1Session__server__impl.html#ae4388def520aad700a3fcdfc95b6f24e">~Session_server_impl</a> ()</td></tr>
<tr class="memdesc:ae4388def520aad700a3fcdfc95b6f24e"><td class="mdescLeft">&#160;</td><td class="mdescRight">See <a class="el" href="classipc_1_1session_1_1Session__server.html" title="To be instantiated typically once in a given process, an object of this type asynchronously listens f...">Session_server</a> dtor.  <a href="classipc_1_1session_1_1Session__server__impl.html#ae4388def520aad700a3fcdfc95b6f24e">More...</a><br /></td></tr>
<tr class="separator:ae4388def520aad700a3fcdfc95b6f24e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a60ec88b23d73c354959a1e11636dc717"><td class="memTemplParams" colspan="2">template&lt;typename Task_err , typename N_init_channels_by_srv_req_func , typename Mdt_load_func &gt; </td></tr>
<tr class="memitem:a60ec88b23d73c354959a1e11636dc717"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classipc_1_1session_1_1Session__server__impl.html#a60ec88b23d73c354959a1e11636dc717">async_accept</a> (<a class="el" href="classipc_1_1session_1_1Session__server__impl.html#a0009247dd98ec58b22040d1c65bb5a54">Server_session_obj</a> *target_session, <a class="el" href="classipc_1_1session_1_1Session__server__impl.html#a9ad5c6cbb1c9378d42ec5cd909389dc2">Channels</a> *init_channels_by_srv_req, <a class="el" href="classipc_1_1session_1_1Session__server__impl.html#a86de1d5b7cae35d89827c3235e2b8d89">Mdt_reader_ptr</a> *mdt_from_cli_or_null, <a class="el" href="classipc_1_1session_1_1Session__server__impl.html#a9ad5c6cbb1c9378d42ec5cd909389dc2">Channels</a> *init_channels_by_cli_req, N_init_channels_by_srv_req_func &amp;&amp;n_init_channels_by_srv_req_func, Mdt_load_func &amp;&amp;mdt_load_func, Task_err &amp;&amp;on_done_func)</td></tr>
<tr class="memdesc:a60ec88b23d73c354959a1e11636dc717"><td class="mdescLeft">&#160;</td><td class="mdescRight">See <a class="el" href="classipc_1_1session_1_1Session__server.html" title="To be instantiated typically once in a given process, an object of this type asynchronously listens f...">Session_server</a> method.  <a href="classipc_1_1session_1_1Session__server__impl.html#a60ec88b23d73c354959a1e11636dc717">More...</a><br /></td></tr>
<tr class="separator:a60ec88b23d73c354959a1e11636dc717"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2a3c0c330d477176b714a9920196775d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classipc_1_1session_1_1Session__server__impl.html#a2a3c0c330d477176b714a9920196775d">to_ostream</a> (std::ostream *os) const</td></tr>
<tr class="memdesc:a2a3c0c330d477176b714a9920196775d"><td class="mdescLeft">&#160;</td><td class="mdescRight">See Server_session method.  <a href="classipc_1_1session_1_1Session__server__impl.html#a2a3c0c330d477176b714a9920196775d">More...</a><br /></td></tr>
<tr class="separator:a2a3c0c330d477176b714a9920196775d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad7cd4d77db826af9fe39c17e8ee7ca37"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classipc_1_1session_1_1Session__server__impl.html#a47625f247dea35cf276d31c039c6bf0c">Session_server_obj</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classipc_1_1session_1_1Session__server__impl.html#ad7cd4d77db826af9fe39c17e8ee7ca37">this_session_srv</a> ()</td></tr>
<tr class="memdesc:ad7cd4d77db826af9fe39c17e8ee7ca37"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns pointer to the object that is <code>private</code>ly sub-classing us.  <a href="classipc_1_1session_1_1Session__server__impl.html#ad7cd4d77db826af9fe39c17e8ee7ca37">More...</a><br /></td></tr>
<tr class="separator:ad7cd4d77db826af9fe39c17e8ee7ca37"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-attribs" name="pub-attribs"></a>
Public Attributes</h2></td></tr>
<tr class="memitem:a7be0cca184cdba62b9748e0ca37b8b17"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="structipc_1_1session_1_1Server__app.html">Server_app</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classipc_1_1session_1_1Session__server__impl.html#a7be0cca184cdba62b9748e0ca37b8b17">m_srv_app_ref</a></td></tr>
<tr class="memdesc:a7be0cca184cdba62b9748e0ca37b8b17"><td class="mdescLeft">&#160;</td><td class="mdescRight">See <a class="el" href="classipc_1_1session_1_1Session__server.html" title="To be instantiated typically once in a given process, an object of this type asynchronously listens f...">Session_server</a> public data member.  <a href="classipc_1_1session_1_1Session__server__impl.html#a7be0cca184cdba62b9748e0ca37b8b17">More...</a><br /></td></tr>
<tr class="separator:a7be0cca184cdba62b9748e0ca37b8b17"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pro-methods" name="pro-methods"></a>
Protected Member Functions</h2></td></tr>
<tr class="memitem:a40fca0b878f9150f5f7db55768da45ad"><td class="memTemplParams" colspan="2">template&lt;typename Task &gt; </td></tr>
<tr class="memitem:a40fca0b878f9150f5f7db55768da45ad"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classipc_1_1session_1_1Session__server__impl.html#a40fca0b878f9150f5f7db55768da45ad">sub_class_set_deinit_func</a> (Task &amp;&amp;task)</td></tr>
<tr class="memdesc:a40fca0b878f9150f5f7db55768da45ad"><td class="mdescLeft">&#160;</td><td class="mdescRight">Utility for sub-classes: ensures that <code>task()</code> is invoked near the end of <code>*this</code> dtor's execution, after <em>all</em> other (mutable) state has been destroyed, including stopping/joining any threads performing async <a class="el" href="classipc_1_1session_1_1Session__server__impl.html#a60ec88b23d73c354959a1e11636dc717" title="See Session_server method.">async_accept()</a> ops.  <a href="classipc_1_1session_1_1Session__server__impl.html#a40fca0b878f9150f5f7db55768da45ad">More...</a><br /></td></tr>
<tr class="separator:a40fca0b878f9150f5f7db55768da45ad"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pri-types" name="pri-types"></a>
Private Types</h2></td></tr>
<tr class="memitem:ae87dfd48a7e435800255722301d5bddc"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classipc_1_1session_1_1Session__server__impl.html#ae87dfd48a7e435800255722301d5bddc">Server_session_dtl_obj</a> = <a class="el" href="classipc_1_1session_1_1Server__session__dtl.html">Server_session_dtl</a>&lt; <a class="el" href="classipc_1_1session_1_1Session__server__impl.html#a0009247dd98ec58b22040d1c65bb5a54">Server_session_obj</a> &gt;</td></tr>
<tr class="memdesc:ae87dfd48a7e435800255722301d5bddc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Short-hand for concrete <a class="el" href="classipc_1_1session_1_1Server__session__dtl.html" title="This is the data-less sub-class of Server_session or any more-advanced (e.g., SHM-capable) variant th...">Server_session_dtl</a> type, which each <a class="el" href="classipc_1_1session_1_1Session__server__impl.html#a60ec88b23d73c354959a1e11636dc717" title="See Session_server method.">async_accept()</a> creates internally, completes the log-in process upon, and then up-casts to <a class="el" href="classipc_1_1session_1_1Session__server__impl.html#a0009247dd98ec58b22040d1c65bb5a54" title="Useful short-hand for the concrete Server_session type emitted by async_accept().">Server_session_obj</a> to emit to user via move-assignment.  <a href="classipc_1_1session_1_1Session__server__impl.html#ae87dfd48a7e435800255722301d5bddc">More...</a><br /></td></tr>
<tr class="separator:ae87dfd48a7e435800255722301d5bddc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3a608ab714f6a6725e6122470d87713f"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classipc_1_1session_1_1Session__server__impl.html#a3a608ab714f6a6725e6122470d87713f">Incomplete_session</a> = boost::shared_ptr&lt; <a class="el" href="classipc_1_1session_1_1Session__server__impl.html#ae87dfd48a7e435800255722301d5bddc">Server_session_dtl_obj</a> &gt;</td></tr>
<tr class="memdesc:a3a608ab714f6a6725e6122470d87713f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Internally used ref-counted handle to a <a class="el" href="classipc_1_1session_1_1Session__server__impl.html#ae87dfd48a7e435800255722301d5bddc" title="Short-hand for concrete Server_session_dtl type, which each async_accept() creates internally,...">Server_session_dtl_obj</a>, suitable for capturing and passing around lambdas.  <a href="classipc_1_1session_1_1Session__server__impl.html#a3a608ab714f6a6725e6122470d87713f">More...</a><br /></td></tr>
<tr class="separator:a3a608ab714f6a6725e6122470d87713f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae66f28a17f3cdd72d97212126483650a"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classipc_1_1session_1_1Session__server__impl.html#ae66f28a17f3cdd72d97212126483650a">Incomplete_session_observer</a> = boost::weak_ptr&lt; <a class="el" href="classipc_1_1session_1_1Session__server__impl.html#ae87dfd48a7e435800255722301d5bddc">Server_session_dtl_obj</a> &gt;</td></tr>
<tr class="memdesc:ae66f28a17f3cdd72d97212126483650a"><td class="mdescLeft">&#160;</td><td class="mdescRight"><code>weak_ptr</code> observer of an <a class="el" href="classipc_1_1session_1_1Session__server__impl.html#a3a608ab714f6a6725e6122470d87713f" title="Internally used ref-counted handle to a Server_session_dtl_obj, suitable for capturing and passing ar...">Incomplete_session</a>.  <a href="classipc_1_1session_1_1Session__server__impl.html#ae66f28a17f3cdd72d97212126483650a">More...</a><br /></td></tr>
<tr class="separator:ae66f28a17f3cdd72d97212126483650a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5286c0f847ccf7e62d87c088e7be32e0"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classipc_1_1session_1_1Session__server__impl.html#a5286c0f847ccf7e62d87c088e7be32e0">Incomplete_sessions</a> = boost::unordered_set&lt; <a class="el" href="classipc_1_1session_1_1Session__server__impl.html#a3a608ab714f6a6725e6122470d87713f">Incomplete_session</a> &gt;</td></tr>
<tr class="memdesc:a5286c0f847ccf7e62d87c088e7be32e0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Short-hand for set of <a class="el" href="classipc_1_1session_1_1Session__server__impl.html#a3a608ab714f6a6725e6122470d87713f" title="Internally used ref-counted handle to a Server_session_dtl_obj, suitable for capturing and passing ar...">Incomplete_session</a>, with fast insertion and removal by key <a class="el" href="classipc_1_1session_1_1Session__server__impl.html#a3a608ab714f6a6725e6122470d87713f" title="Internally used ref-counted handle to a Server_session_dtl_obj, suitable for capturing and passing ar...">Incomplete_session</a> itself.  <a href="classipc_1_1session_1_1Session__server__impl.html#a5286c0f847ccf7e62d87c088e7be32e0">More...</a><br /></td></tr>
<tr class="separator:a5286c0f847ccf7e62d87c088e7be32e0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae7f35b32be309d354044662f0e17a891"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classipc_1_1session_1_1Session__server__impl.html#ae7f35b32be309d354044662f0e17a891">Mutex</a> = flow::util::Mutex_non_recursive</td></tr>
<tr class="memdesc:ae7f35b32be309d354044662f0e17a891"><td class="mdescLeft">&#160;</td><td class="mdescRight">Short-hand for <a class="el" href="structipc_1_1session_1_1Session__server__impl_1_1State.html#a96b5d124c1a31532a38a0f0cd095ec05" title="Protects m_incomplete_sessions. See class doc header impl section for discussion of thread design.">State::m_mutex</a> type.  <a href="classipc_1_1session_1_1Session__server__impl.html#ae7f35b32be309d354044662f0e17a891">More...</a><br /></td></tr>
<tr class="separator:ae7f35b32be309d354044662f0e17a891"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5e864e857a767101ed964f532b06acd4"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classipc_1_1session_1_1Session__server__impl.html#a5e864e857a767101ed964f532b06acd4">Lock_guard</a> = flow::util::Lock_guard&lt; <a class="el" href="classipc_1_1session_1_1Session__server__impl.html#ae7f35b32be309d354044662f0e17a891">Mutex</a> &gt;</td></tr>
<tr class="memdesc:a5e864e857a767101ed964f532b06acd4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Short-hand for <a class="el" href="classipc_1_1session_1_1Session__server__impl.html#ae7f35b32be309d354044662f0e17a891" title="Short-hand for State::m_mutex type.">Mutex</a> lock.  <a href="classipc_1_1session_1_1Session__server__impl.html#a5e864e857a767101ed964f532b06acd4">More...</a><br /></td></tr>
<tr class="separator:a5e864e857a767101ed964f532b06acd4"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pri-attribs" name="pri-attribs"></a>
Private Attributes</h2></td></tr>
<tr class="memitem:aa7aed6de161203a2e7414411fa1defa5"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classipc_1_1session_1_1Session__server__impl.html#a47625f247dea35cf276d31c039c6bf0c">Session_server_obj</a> *const&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classipc_1_1session_1_1Session__server__impl.html#aa7aed6de161203a2e7414411fa1defa5">m_this_session_srv</a></td></tr>
<tr class="memdesc:aa7aed6de161203a2e7414411fa1defa5"><td class="mdescLeft">&#160;</td><td class="mdescRight">See <a class="el" href="classipc_1_1session_1_1Session__server__impl.html#ad7cd4d77db826af9fe39c17e8ee7ca37" title="Returns pointer to the object that is privately sub-classing us.">this_session_srv()</a>.  <a href="classipc_1_1session_1_1Session__server__impl.html#aa7aed6de161203a2e7414411fa1defa5">More...</a><br /></td></tr>
<tr class="separator:aa7aed6de161203a2e7414411fa1defa5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a798164cc2876cfaddf8793bd346d13f9"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="structipc_1_1session_1_1Client__app.html#add718cbf6aa1d2abb26fbadcc974a7bd">Client_app::Master_set</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classipc_1_1session_1_1Session__server__impl.html#a798164cc2876cfaddf8793bd346d13f9">m_cli_app_master_set_ref</a></td></tr>
<tr class="memdesc:a798164cc2876cfaddf8793bd346d13f9"><td class="mdescLeft">&#160;</td><td class="mdescRight">See ctor.  <a href="classipc_1_1session_1_1Session__server__impl.html#a798164cc2876cfaddf8793bd346d13f9">More...</a><br /></td></tr>
<tr class="separator:a798164cc2876cfaddf8793bd346d13f9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adc97c8fd3c5860dc6164f0a384b9fe03"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="namespaceipc.html#aa455c7f045059736578ca275fc1a851f">Function</a>&lt; <a class="el" href="namespaceipc.html#aa3192e586cc45d3e7c22463bf2760f89">Error_code</a>(const <a class="el" href="structipc_1_1session_1_1Client__app.html">Client_app</a> &amp;client_app)&gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classipc_1_1session_1_1Session__server__impl.html#adc97c8fd3c5860dc6164f0a384b9fe03">m_per_app_setup_func</a></td></tr>
<tr class="memdesc:adc97c8fd3c5860dc6164f0a384b9fe03"><td class="mdescLeft">&#160;</td><td class="mdescRight">See ctor.  <a href="classipc_1_1session_1_1Session__server__impl.html#adc97c8fd3c5860dc6164f0a384b9fe03">More...</a><br /></td></tr>
<tr class="separator:adc97c8fd3c5860dc6164f0a384b9fe03"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac49be718ad86c3919563da57502d11b3"><td class="memItemLeft" align="right" valign="top">std::optional&lt; <a class="el" href="structipc_1_1session_1_1Session__server__impl_1_1State.html">State</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classipc_1_1session_1_1Session__server__impl.html#ac49be718ad86c3919563da57502d11b3">m_state</a></td></tr>
<tr class="memdesc:ac49be718ad86c3919563da57502d11b3"><td class="mdescLeft">&#160;</td><td class="mdescRight">See <a class="el" href="structipc_1_1session_1_1Session__server__impl_1_1State.html" title="All internal mutable state of Session_server_impl.">State</a>.  <a href="classipc_1_1session_1_1Session__server__impl.html#ac49be718ad86c3919563da57502d11b3">More...</a><br /></td></tr>
<tr class="separator:ac49be718ad86c3919563da57502d11b3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a98165f48041d5a2846c7ac574833b933"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespaceipc.html#aa455c7f045059736578ca275fc1a851f">Function</a>&lt; void()&gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classipc_1_1session_1_1Session__server__impl.html#a98165f48041d5a2846c7ac574833b933">m_deinit_func_or_empty</a></td></tr>
<tr class="memdesc:a98165f48041d5a2846c7ac574833b933"><td class="mdescLeft">&#160;</td><td class="mdescRight">See <a class="el" href="classipc_1_1session_1_1Session__server__impl.html#a40fca0b878f9150f5f7db55768da45ad" title="Utility for sub-classes: ensures that task() is invoked near the end of *this dtor&#39;s execution,...">sub_class_set_deinit_func()</a>. <code>.empty()</code> unless that was called at least once.  <a href="classipc_1_1session_1_1Session__server__impl.html#a98165f48041d5a2846c7ac574833b933">More...</a><br /></td></tr>
<tr class="separator:a98165f48041d5a2846c7ac574833b933"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="related" name="related"></a>
Related Functions</h2></td></tr>
<tr><td class="ititle" colspan="2"><p >(Note that these are not member functions.) </p>
</td></tr>
<tr class="memitem:a5fc42e333522f7b1ed11fbff4ae72e5c"><td class="memTemplParams" colspan="2">template&lt;typename Session_server_t , typename <a class="el" href="classServer__session__t.html">Server_session_t</a> &gt; </td></tr>
<tr class="memitem:a5fc42e333522f7b1ed11fbff4ae72e5c"><td class="memTemplItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classipc_1_1session_1_1Session__server__impl.html#a5fc42e333522f7b1ed11fbff4ae72e5c">operator&lt;&lt;</a> (std::ostream &amp;os, const <a class="el" href="classipc_1_1session_1_1Session__server__impl.html">Session_server_impl</a>&lt; Session_server_t, <a class="el" href="classServer__session__t.html">Server_session_t</a> &gt; &amp;val)</td></tr>
<tr class="memdesc:a5fc42e333522f7b1ed11fbff4ae72e5c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Prints string representation of the given <code><a class="el" href="classipc_1_1session_1_1Session__server__impl.html" title="Internal class template comprising API/logic common to every Session_server variant,...">Session_server_impl</a></code> to the given <code>ostream</code>.  <a href="classipc_1_1session_1_1Session__server__impl.html#a5fc42e333522f7b1ed11fbff4ae72e5c">More...</a><br /></td></tr>
<tr class="separator:a5fc42e333522f7b1ed11fbff4ae72e5c"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><div class="compoundTemplParams">template&lt;typename Session_server_t, typename <a class="el" href="classServer__session__t.html">Server_session_t</a>&gt;<br />
class ipc::session::Session_server_impl&lt; Session_server_t, Server_session_t &gt;</div><p >Internal class template comprising API/logic common to every <a class="el" href="classipc_1_1session_1_1Session__server.html" title="To be instantiated typically once in a given process, an object of this type asynchronously listens f...">Session_server</a> variant, meant to be <code>private</code>ly sub-classed and largely forwarded. </p>
<p >In particular the vanilla <a class="el" href="classipc_1_1session_1_1Session__server.html" title="To be instantiated typically once in a given process, an object of this type asynchronously listens f...">Session_server</a> (see its short Implementation doc header section) sub-classes us and makes no use of the available customization points. Contrast with, e.g., <a class="el" href="classipc_1_1session_1_1shm_1_1classic_1_1Session__server.html" title="This is to vanilla Session_server what shm::classic::Server_session is to vanilla Server_session: it ...">shm::classic::Session_server</a> which uses customization points for <a class="el" href="namespaceipc_1_1session_1_1shm_1_1classic.html" title="Support for SHM-backed ipc::session sessions and session-servers with the SHM-classic (ipc::shm::clas...">shm::classic</a> SHM-arena setup.</p>
<p >The available customization points are as follows.</p><ul>
<li>Per-session: <code>*this</code> is parameterized on <a class="el" href="classipc_1_1session_1_1Session__server__impl.html#a0009247dd98ec58b22040d1c65bb5a54" title="Useful short-hand for the concrete Server_session type emitted by async_accept().">Server_session_obj</a>. The vanilla value is <code>Server_session&lt;...&gt;</code>; but to add capabilities sub-class <a class="el" href="classipc_1_1session_1_1Server__session__impl.html" title="Internal, non-movable pImpl-lite implementation of Server_session_mv class template.">Server_session_impl</a> as explained in its doc header and proceed from there. For example see <a class="el" href="classipc_1_1session_1_1shm_1_1classic_1_1Server__session.html" title="Identical to session::Server_session in every way, except that it makes available two SHM arenas,...">shm::classic::Server_session</a>. <a class="el" href="classipc_1_1session_1_1Server__session__impl.html" title="Internal, non-movable pImpl-lite implementation of Server_session_mv class template.">Server_session_impl</a> has its own customization point(s).<ul>
<li>No-customization = specify <a class="el" href="namespaceipc_1_1session.html#ab01d5bce0ab2f3435ca9dd88d27609dc" title="A vanilla Server_session with no optional capabilities.">Server_session</a> here.</li>
</ul>
</li>
<li>Cross-session: Additional per-Client_app setup (such as setting up cross-session SHM arena(s) in on-demand fashion) can be specified by passing in <code>per_app_setup_func</code> to ctor.<ul>
<li>No-customization = specify do-nothing function here that returns <code><a class="el" href="namespaceipc.html#aa3192e586cc45d3e7c22463bf2760f89" title="Short-hand for flow::Error_code which is very common.">Error_code()</a></code> always.</li>
</ul>
</li>
<li>Cross-session: Certain custom code can be caused to run as the last thing in the <a class="el" href="classipc_1_1session_1_1Server__session__impl.html" title="Internal, non-movable pImpl-lite implementation of Server_session_mv class template.">Server_session_impl</a> dtor, even after all its state has been destroyed (e.g., all threads have been stopped/joined). A sub-class may use this customization point by calling <a class="el" href="classipc_1_1session_1_1Session__server__impl.html#a40fca0b878f9150f5f7db55768da45ad" title="Utility for sub-classes: ensures that task() is invoked near the end of *this dtor&#39;s execution,...">sub_class_set_deinit_func()</a>. If not called, the customization point is unused by default.</li>
</ul>
<h3>Implementation design</h3>
<p >Generally the impl should be reasonably easy to follow by reading the method bodies, at least if one understands the general <a class="el" href="namespaceipc_1_1session.html" title="Flow-IPC module providing the broad lifecycle and shared-resource organization â€“ via the session conc...">ipc::session</a> client-server paradigm.</p>
<p >The thing to understand strategically, as usual, is the thread design. This is an acceptor, so one might have expected it to be implemented similarly to, say, Native_socket_stream_acceptor &ndash; maintaining a thread W in which to do some/most work; including maintaining a "deficit" queue of oustanding <a class="el" href="classipc_1_1session_1_1Session__server__impl.html#a60ec88b23d73c354959a1e11636dc717" title="See Session_server method.">async_accept()</a> requests and a "surplus" queue of ready <code>Server_session</code>s to emit. This was an option, but I (ygoldfel) felt that piggy-backing handling of events directly onto the unspecified handler-invoking threads of the internally used objects would produce a much simpler data structure and state machine. (As a side effect, the behavior described in "FIFO" section above occurs. Also as a side effect, the error-emission behavior described in "Error handling" above occurs. Basically: each <a class="el" href="classipc_1_1session_1_1Session__server__impl.html#a60ec88b23d73c354959a1e11636dc717" title="See Session_server method.">async_accept()</a>'s internal handling is independent of the others. They share (almost) no state; there is no single async-chain and explicit queues unlike in various other boost.asio-like classes in <a class="el" href="namespaceipc.html" title="Catch-all namespace for the Flow-IPC project: A library/API in modern C++17 providing high-performanc...">ipc</a>. Each <a class="el" href="classipc_1_1session_1_1Session__server__impl.html#a60ec88b23d73c354959a1e11636dc717" title="See Session_server method.">async_accept()</a> triggers async op 1, the handler for which triggers async op 2, the handler for which emits the result to user. This is simpler to implement, but it also results in sensible API contract behavior, I feel.)</p>
<p >Here is how it works.</p>
<p >For each potential <code>Server_session</code> &ndash; i.e., for each <a class="el" href="classipc_1_1session_1_1Session__server__impl.html#a60ec88b23d73c354959a1e11636dc717" title="See Session_server method.">async_accept()</a> &ndash; there are 2 steps that must occur asynchronously before one is ready to emit to the user-supplied handler:</p><ul>
<li>Our stored Native_socket_stream_acceptor, where we invoke <a class="el" href="classipc_1_1transport_1_1Native__socket__stream__acceptor.html#a81426af495ba5a9c832d1ba35fe23ba5" title="Asynchronously awaits for a peer connection to be established and calls on_done_func(),...">transport::Native_socket_stream_acceptor::async_accept()</a>, must emit a PEER-state (connected) <a class="el" href="classipc_1_1transport_1_1sync__io_1_1Native__socket__stream.html" title="Implements both sync_io::Native_handle_sender and sync_io::Native_handle_receiver concepts by using a...">transport::sync_io::Native_socket_stream</a> (the opposing peer object living inside the opposing Client_session).<ul>
<li>Now a <a class="el" href="classipc_1_1session_1_1Server__session__dtl.html" title="This is the data-less sub-class of Server_session or any more-advanced (e.g., SHM-capable) variant th...">Server_session_dtl</a> may be constructed (not yet emitted to user) and then <a class="el" href="classipc_1_1session_1_1Server__session__dtl.html#a31a6cd6a9ed4f836f0844ddb4069080f" title="See protected counterpart.">Server_session_dtl::async_accept_log_in()</a> is invoked.</li>
<li>Or if the socket-accept failed, then we can emit that to the user already; done.</li>
</ul>
</li>
<li>That <a class="el" href="classipc_1_1session_1_1Server__session__dtl.html#a31a6cd6a9ed4f836f0844ddb4069080f" title="See protected counterpart.">Server_session_dtl::async_accept_log_in()</a> must complete the async log-in exchange against the opposing Client_session.<ul>
<li>Now the <a class="el" href="classipc_1_1session_1_1Server__session__dtl.html" title="This is the data-less sub-class of Server_session or any more-advanced (e.g., SHM-capable) variant th...">Server_session_dtl</a> can be converted via pointer <code>static_cast&lt;&gt;</code> to <code>Server_session</code> and emitted to the user.</li>
<li>Or if the log-in fails at some state, then we can emit that to the user.</li>
</ul>
</li>
</ul>
<p >Nomenclature: We call the <code>N_s_s_a::async_accept()</code> handler-invoking thread: Wa. It is officially an unspecified thread or threads, but, by contract, handlers are executed non-concurrently, so it can be considered one thread (and actually it is as of this writing). We call the <a class="el" href="classipc_1_1session_1_1Server__session__mv.html#a74d647e2f555465c28065dc11cd092cb" title="For use by internal user Session_server: called no more than once, ideally immediately following ctor...">Server_session::async_accept_log_in()</a> handler-invoking thread: Ws. This is really a separate thread for each <code>Server_session</code>, so in fact 2 different async-accept requests can cause 2 handlers to invoke simultaneously.</p>
<p >So each time one calls <a class="el" href="classipc_1_1session_1_1Session__server__impl.html#a60ec88b23d73c354959a1e11636dc717" title="See Session_server method.">async_accept()</a> from thread U (i.e., user thread(s) from which they must never invoke mutating stuff concurrently), that kicks off <a class="el" href="classipc_1_1transport_1_1Native__socket__stream__acceptor.html#a81426af495ba5a9c832d1ba35fe23ba5" title="Asynchronously awaits for a peer connection to be established and calls on_done_func(),...">transport::Native_socket_stream_acceptor::async_accept()</a>, which fires handler in thread Wa; we then kick off <code><a class="el" href="classipc_1_1session_1_1Server__session__mv.html#a74d647e2f555465c28065dc11cd092cb" title="For use by internal user Session_server: called no more than once, ideally immediately following ctor...">Server_session::async_accept_log_in()</a></code>, which fires handler in thread Ws, where we finalize the <code>Server_session</code> and emit it to user. There is no cross-posting to some other worker thread W (but read on).</p>
<p >The obvious question is, do the handlers, some of which (as noted) may run concurrently to each other (request 1's Ws handler can co-execute with request 2's Wa handler; and request 2's Wa handler can co-execute with request 3's Wa handler), mess each other over by mutatingly accessing common data? Let's consider the state involved.</p>
<p >For each async-accept request, the amassed data are independent from any other's; they are passed around throughout the 2 async ops per request via lambda captures. There is, however, one caveat to this: Suppose <code>S-&gt;accept_log_in(F)</code> is invoked on not-yet-ready (incomplete) <code>Server_session* S</code>; suppose F is invoked with a truthy <a class="el" href="namespaceipc.html#aa3192e586cc45d3e7c22463bf2760f89" title="Short-hand for flow::Error_code which is very common.">Error_code</a> (it failed). We are now sitting in thread Ws: and S should be destroyed. But invoking dtor of S from within S's own handler is documented to be not-okay and results in a deadlock/infinite dtor execution, or if the system can detect it, at best an abort due to a thread trying to join itself. So:</p><ul>
<li>We maintain <a class="el" href="structipc_1_1session_1_1Session__server__impl_1_1State.html#ab6097ff11f1f8cca396ece86482861f4" title="The set of all Incomplete_session objects such that each one comes from a distinct async_accept() req...">State::m_incomplete_sessions</a> storing each such outstanding S. If dtor runs, then all S will be auto-destroyed which will automatically invoke the user handler with operation-aborted.</li>
<li>If an incomplete (oustanding) S successfully completes log-in, we remove it from Session_server_impl::m_incomplete_sessions and emit it to user via handler.</li>
<li>If it completes log-in with failure, we remove it from <a class="el" href="structipc_1_1session_1_1Session__server__impl_1_1State.html#ab6097ff11f1f8cca396ece86482861f4" title="The set of all Incomplete_session objects such that each one comes from a distinct async_accept() req...">State::m_incomplete_sessions</a> and then:<ul>
<li>hand it off to a mostly-idle separate thread, <a class="el" href="structipc_1_1session_1_1Session__server__impl_1_1State.html#afea14f96bce70093ebf65d0f9b612b29" title="Mostly-idle thread that solely destroys objects removed from m_incomplete_sessions in the case where ...">State::m_incomplete_session_graveyard</a>, which can run S's dtor in peace without deadlocking anyone. (If <code>*this</code> dtor runs before then, the S dtors will still run, as each queued lambda's captures are destroyed.)<ul>
<li>This is the part that avoids the deadlock. The other things above are orthogonally needed for the promised boost.asio-like semantics, where handler must run exactly once eventually, from dtor at the latest.</li>
</ul>
</li>
</ul>
</li>
</ul>
<p >However note that <a class="el" href="structipc_1_1session_1_1Session__server__impl_1_1State.html#ab6097ff11f1f8cca396ece86482861f4" title="The set of all Incomplete_session objects such that each one comes from a distinct async_accept() req...">State::m_incomplete_sessions</a> is added-to in thread Wa but removed-from in various threads Ws. Therefore it is protected by a mutex; simple enough.</p>
<dl class="todo"><dt><b><a class="el" href="todo.html#_todo000034">Todo:</a></b></dt><dd><a class="el" href="classipc_1_1session_1_1Session__server.html" title="To be instantiated typically once in a given process, an object of this type asynchronously listens f...">Session_server</a>, probably in ctor or similar, should &ndash; for safety &ndash; enforce the accuracy of <a class="el" href="structipc_1_1session_1_1Server__app.html" title="An App that is used as a server in at least one client-server IPC split.">Server_app</a> attributes including <a class="el" href="structipc_1_1session_1_1App.html#ae82a8635858664720c8546e468f8090b" title="Absolute, lexically normalized canonical path to the executable entity (which is not a directory),...">App::m_exec_path</a>, <a class="el" href="structipc_1_1session_1_1App.html#a9e32297579603f2d96616976474d0246" title="The application must run as this user ID (UID). Files and other shared resources shall have this owne...">App::m_user_id</a>, <a class="el" href="structipc_1_1session_1_1App.html#a78bb1e984835f429fd44869a83f4b093" title="The application must run as this group ID (GID). Files and other shared resources shall have this own...">App::m_group_id</a>. As of this writing it enforces these things about each <em>opposing</em> <a class="el" href="structipc_1_1session_1_1Client__app.html" title="An App that is used as a client in at least one client-server IPC split.">Client_app</a> and process &ndash; so for sanity it can/should do so about itself, before the sessions can begin.</dd></dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname"><a class="el" href="classServer__session__t.html">Server_session_t</a></td><td>See <a class="el" href="classipc_1_1session_1_1Session__server__impl.html#a0009247dd98ec58b22040d1c65bb5a54" title="Useful short-hand for the concrete Server_session type emitted by async_accept().">Server_session_obj</a>. Its API must exactly equal (or be a superset of) that of vanilla <a class="el" href="namespaceipc_1_1session.html#ab01d5bce0ab2f3435ca9dd88d27609dc" title="A vanilla Server_session with no optional capabilities.">Server_session</a>. (Its impl may perform extra steps; for example <code>async_accept_log_in()</code> might set up a per-session SHM arena.) </td></tr>
    <tr><td class="paramname">Session_server_t</td><td>The class that is in fact <code>private</code>ly sub-classing us. This is necessary for <a class="el" href="classipc_1_1session_1_1Session__server__impl.html#ad7cd4d77db826af9fe39c17e8ee7ca37" title="Returns pointer to the object that is privately sub-classing us.">this_session_srv()</a>. See its doc header for discussion. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="session__server__impl_8hpp_source.html#l00143">143</a> of file <a class="el" href="session__server__impl_8hpp_source.html">session_server_impl.hpp</a>.</p>
</div><h2 class="groupheader">Member Typedef Documentation</h2>
<a id="a9ad5c6cbb1c9378d42ec5cd909389dc2" name="a9ad5c6cbb1c9378d42ec5cd909389dc2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9ad5c6cbb1c9378d42ec5cd909389dc2">&#9670;&nbsp;</a></span>Channels</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Session_server_t , typename <a class="el" href="classServer__session__t.html">Server_session_t</a> &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classipc_1_1session_1_1Session__server__impl.html">ipc::session::Session_server_impl</a>&lt; Session_server_t, <a class="el" href="classServer__session__t.html">Server_session_t</a> &gt;::Channels =  typename Server_session_obj::Channels</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Short-hand for <a class="el" href="classipc_1_1session_1_1Session__mv.html#af87da439644b2afd73d6a13d97e7985f" title="Container (vector&lt;&gt;) of Channel_obj.">Session_mv::Channels</a>. </p>

<p class="definition">Definition at line <a class="el" href="session__server__impl_8hpp_source.html#l00160">160</a> of file <a class="el" href="session__server__impl_8hpp_source.html">session_server_impl.hpp</a>.</p>

</div>
</div>
<a id="a3a608ab714f6a6725e6122470d87713f" name="a3a608ab714f6a6725e6122470d87713f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3a608ab714f6a6725e6122470d87713f">&#9670;&nbsp;</a></span>Incomplete_session</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Session_server_t , typename <a class="el" href="classServer__session__t.html">Server_session_t</a> &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classipc_1_1session_1_1Session__server__impl.html">ipc::session::Session_server_impl</a>&lt; Session_server_t, <a class="el" href="classServer__session__t.html">Server_session_t</a> &gt;::Incomplete_session =  boost::shared_ptr&lt;<a class="el" href="classipc_1_1session_1_1Session__server__impl.html#ae87dfd48a7e435800255722301d5bddc">Server_session_dtl_obj</a>&gt;</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Internally used ref-counted handle to a <a class="el" href="classipc_1_1session_1_1Session__server__impl.html#ae87dfd48a7e435800255722301d5bddc" title="Short-hand for concrete Server_session_dtl type, which each async_accept() creates internally,...">Server_session_dtl_obj</a>, suitable for capturing and passing around lambdas. </p>
<h3>Rationale</h3>
<p >It is <code>shared_ptr</code>, not <code>unique_ptr</code>, for two reasons. Primarily, it is so that it can be captured via <a class="el" href="classipc_1_1session_1_1Session__server__impl.html#ae66f28a17f3cdd72d97212126483650a" title="weak_ptr observer of an Incomplete_session.">Incomplete_session_observer</a> to avoid a leak that would result from capturing <a class="el" href="classipc_1_1session_1_1Session__server__impl.html#a3a608ab714f6a6725e6122470d87713f" title="Internally used ref-counted handle to a Server_session_dtl_obj, suitable for capturing and passing ar...">Incomplete_session</a> in a lambda passed-to an async op on an <a class="el" href="classipc_1_1session_1_1Session__server__impl.html#a3a608ab714f6a6725e6122470d87713f" title="Internally used ref-counted handle to a Server_session_dtl_obj, suitable for capturing and passing ar...">Incomplete_session</a> <em>itself</em>. <code>unique_ptr</code> cannot be observed via <code>weak_ptr</code>; <code>shared_ptr</code> can.</p>
<p >Secondarily, a <code>unique_ptr</code> cannot be captured in a lambda in the first place. </p>

<p class="definition">Definition at line <a class="el" href="session__server__impl_8hpp_source.html#l00335">335</a> of file <a class="el" href="session__server__impl_8hpp_source.html">session_server_impl.hpp</a>.</p>

</div>
</div>
<a id="ae66f28a17f3cdd72d97212126483650a" name="ae66f28a17f3cdd72d97212126483650a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae66f28a17f3cdd72d97212126483650a">&#9670;&nbsp;</a></span>Incomplete_session_observer</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Session_server_t , typename <a class="el" href="classServer__session__t.html">Server_session_t</a> &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classipc_1_1session_1_1Session__server__impl.html">ipc::session::Session_server_impl</a>&lt; Session_server_t, <a class="el" href="classServer__session__t.html">Server_session_t</a> &gt;::Incomplete_session_observer =  boost::weak_ptr&lt;<a class="el" href="classipc_1_1session_1_1Session__server__impl.html#ae87dfd48a7e435800255722301d5bddc">Server_session_dtl_obj</a>&gt;</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><code>weak_ptr</code> observer of an <a class="el" href="classipc_1_1session_1_1Session__server__impl.html#a3a608ab714f6a6725e6122470d87713f" title="Internally used ref-counted handle to a Server_session_dtl_obj, suitable for capturing and passing ar...">Incomplete_session</a>. </p>
<p >Capturing this, instead of <a class="el" href="classipc_1_1session_1_1Session__server__impl.html#a3a608ab714f6a6725e6122470d87713f" title="Internally used ref-counted handle to a Server_session_dtl_obj, suitable for capturing and passing ar...">Incomplete_session</a> itself, allows for the underlying <a class="el" href="classipc_1_1session_1_1Session__server__impl.html#a3a608ab714f6a6725e6122470d87713f" title="Internally used ref-counted handle to a Server_session_dtl_obj, suitable for capturing and passing ar...">Incomplete_session</a> to be destroyed while the lambda still exists. </p>

<p class="definition">Definition at line <a class="el" href="session__server__impl_8hpp_source.html#l00341">341</a> of file <a class="el" href="session__server__impl_8hpp_source.html">session_server_impl.hpp</a>.</p>

</div>
</div>
<a id="a5286c0f847ccf7e62d87c088e7be32e0" name="a5286c0f847ccf7e62d87c088e7be32e0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5286c0f847ccf7e62d87c088e7be32e0">&#9670;&nbsp;</a></span>Incomplete_sessions</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Session_server_t , typename <a class="el" href="classServer__session__t.html">Server_session_t</a> &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classipc_1_1session_1_1Session__server__impl.html">ipc::session::Session_server_impl</a>&lt; Session_server_t, <a class="el" href="classServer__session__t.html">Server_session_t</a> &gt;::Incomplete_sessions =  boost::unordered_set&lt;<a class="el" href="classipc_1_1session_1_1Session__server__impl.html#a3a608ab714f6a6725e6122470d87713f">Incomplete_session</a>&gt;</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Short-hand for set of <a class="el" href="classipc_1_1session_1_1Session__server__impl.html#a3a608ab714f6a6725e6122470d87713f" title="Internally used ref-counted handle to a Server_session_dtl_obj, suitable for capturing and passing ar...">Incomplete_session</a>, with fast insertion and removal by key <a class="el" href="classipc_1_1session_1_1Session__server__impl.html#a3a608ab714f6a6725e6122470d87713f" title="Internally used ref-counted handle to a Server_session_dtl_obj, suitable for capturing and passing ar...">Incomplete_session</a> itself. </p>

<p class="definition">Definition at line <a class="el" href="session__server__impl_8hpp_source.html#l00344">344</a> of file <a class="el" href="session__server__impl_8hpp_source.html">session_server_impl.hpp</a>.</p>

</div>
</div>
<a id="a5e864e857a767101ed964f532b06acd4" name="a5e864e857a767101ed964f532b06acd4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5e864e857a767101ed964f532b06acd4">&#9670;&nbsp;</a></span>Lock_guard</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Session_server_t , typename <a class="el" href="classServer__session__t.html">Server_session_t</a> &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classipc_1_1session_1_1Session__server__impl.html">ipc::session::Session_server_impl</a>&lt; Session_server_t, <a class="el" href="classServer__session__t.html">Server_session_t</a> &gt;::Lock_guard =  flow::util::Lock_guard&lt;<a class="el" href="classipc_1_1session_1_1Session__server__impl.html#ae7f35b32be309d354044662f0e17a891">Mutex</a>&gt;</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Short-hand for <a class="el" href="classipc_1_1session_1_1Session__server__impl.html#ae7f35b32be309d354044662f0e17a891" title="Short-hand for State::m_mutex type.">Mutex</a> lock. </p>

<p class="definition">Definition at line <a class="el" href="session__server__impl_8hpp_source.html#l00350">350</a> of file <a class="el" href="session__server__impl_8hpp_source.html">session_server_impl.hpp</a>.</p>

</div>
</div>
<a id="a86de1d5b7cae35d89827c3235e2b8d89" name="a86de1d5b7cae35d89827c3235e2b8d89"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a86de1d5b7cae35d89827c3235e2b8d89">&#9670;&nbsp;</a></span>Mdt_reader_ptr</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Session_server_t , typename <a class="el" href="classServer__session__t.html">Server_session_t</a> &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classipc_1_1session_1_1Session__server__impl.html">ipc::session::Session_server_impl</a>&lt; Session_server_t, <a class="el" href="classServer__session__t.html">Server_session_t</a> &gt;::Mdt_reader_ptr =  typename Server_session_obj::Mdt_reader_ptr</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Short-hand for <a class="el" href="classipc_1_1session_1_1Session__mv.html#a2b1215fb0c9738b9fcfbb337d23c43df" title="Implements Session API per contract.">Session_mv::Mdt_reader_ptr</a>. </p>

<p class="definition">Definition at line <a class="el" href="session__server__impl_8hpp_source.html#l00157">157</a> of file <a class="el" href="session__server__impl_8hpp_source.html">session_server_impl.hpp</a>.</p>

</div>
</div>
<a id="ae7f35b32be309d354044662f0e17a891" name="ae7f35b32be309d354044662f0e17a891"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae7f35b32be309d354044662f0e17a891">&#9670;&nbsp;</a></span>Mutex</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Session_server_t , typename <a class="el" href="classServer__session__t.html">Server_session_t</a> &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classipc_1_1session_1_1Session__server__impl.html">ipc::session::Session_server_impl</a>&lt; Session_server_t, <a class="el" href="classServer__session__t.html">Server_session_t</a> &gt;::Mutex =  flow::util::Mutex_non_recursive</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Short-hand for <a class="el" href="structipc_1_1session_1_1Session__server__impl_1_1State.html#a96b5d124c1a31532a38a0f0cd095ec05" title="Protects m_incomplete_sessions. See class doc header impl section for discussion of thread design.">State::m_mutex</a> type. </p>

<p class="definition">Definition at line <a class="el" href="session__server__impl_8hpp_source.html#l00347">347</a> of file <a class="el" href="session__server__impl_8hpp_source.html">session_server_impl.hpp</a>.</p>

</div>
</div>
<a id="ae87dfd48a7e435800255722301d5bddc" name="ae87dfd48a7e435800255722301d5bddc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae87dfd48a7e435800255722301d5bddc">&#9670;&nbsp;</a></span>Server_session_dtl_obj</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Session_server_t , typename <a class="el" href="classServer__session__t.html">Server_session_t</a> &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classipc_1_1session_1_1Session__server__impl.html">ipc::session::Session_server_impl</a>&lt; Session_server_t, <a class="el" href="classServer__session__t.html">Server_session_t</a> &gt;::Server_session_dtl_obj =  <a class="el" href="classipc_1_1session_1_1Server__session__dtl.html">Server_session_dtl</a>&lt;<a class="el" href="classipc_1_1session_1_1Session__server__impl.html#a0009247dd98ec58b22040d1c65bb5a54">Server_session_obj</a>&gt;</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Short-hand for concrete <a class="el" href="classipc_1_1session_1_1Server__session__dtl.html" title="This is the data-less sub-class of Server_session or any more-advanced (e.g., SHM-capable) variant th...">Server_session_dtl</a> type, which each <a class="el" href="classipc_1_1session_1_1Session__server__impl.html#a60ec88b23d73c354959a1e11636dc717" title="See Session_server method.">async_accept()</a> creates internally, completes the log-in process upon, and then up-casts to <a class="el" href="classipc_1_1session_1_1Session__server__impl.html#a0009247dd98ec58b22040d1c65bb5a54" title="Useful short-hand for the concrete Server_session type emitted by async_accept().">Server_session_obj</a> to emit to user via move-assignment. </p>
<p ><a class="el" href="classipc_1_1session_1_1Session__server__impl.html#ae87dfd48a7e435800255722301d5bddc" title="Short-hand for concrete Server_session_dtl type, which each async_accept() creates internally,...">Server_session_dtl_obj</a> is equal to <a class="el" href="classipc_1_1session_1_1Session__server__impl.html#a0009247dd98ec58b22040d1c65bb5a54" title="Useful short-hand for the concrete Server_session type emitted by async_accept().">Server_session_obj</a> &ndash; it adds no data &ndash; but exposes certain internally invoked APIs that the user shall not access. </p>

<p class="definition">Definition at line <a class="el" href="session__server__impl_8hpp_source.html#l00321">321</a> of file <a class="el" href="session__server__impl_8hpp_source.html">session_server_impl.hpp</a>.</p>

</div>
</div>
<a id="a0009247dd98ec58b22040d1c65bb5a54" name="a0009247dd98ec58b22040d1c65bb5a54"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0009247dd98ec58b22040d1c65bb5a54">&#9670;&nbsp;</a></span>Server_session_obj</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Session_server_t , typename <a class="el" href="classServer__session__t.html">Server_session_t</a> &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classipc_1_1session_1_1Session__server__impl.html">ipc::session::Session_server_impl</a>&lt; Session_server_t, <a class="el" href="classServer__session__t.html">Server_session_t</a> &gt;::Server_session_obj =  <a class="el" href="classServer__session__t.html">Server_session_t</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Useful short-hand for the concrete <code>Server_session</code> type emitted by <a class="el" href="classipc_1_1session_1_1Session__server__impl.html#a60ec88b23d73c354959a1e11636dc717" title="See Session_server method.">async_accept()</a>. </p>

<p class="definition">Definition at line <a class="el" href="session__server__impl_8hpp_source.html#l00154">154</a> of file <a class="el" href="session__server__impl_8hpp_source.html">session_server_impl.hpp</a>.</p>

</div>
</div>
<a id="a47625f247dea35cf276d31c039c6bf0c" name="a47625f247dea35cf276d31c039c6bf0c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a47625f247dea35cf276d31c039c6bf0c">&#9670;&nbsp;</a></span>Session_server_obj</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Session_server_t , typename <a class="el" href="classServer__session__t.html">Server_session_t</a> &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classipc_1_1session_1_1Session__server__impl.html">ipc::session::Session_server_impl</a>&lt; Session_server_t, <a class="el" href="classServer__session__t.html">Server_session_t</a> &gt;::Session_server_obj =  Session_server_t</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>See <a class="el" href="classipc_1_1session_1_1Session__server__impl.html#ad7cd4d77db826af9fe39c17e8ee7ca37" title="Returns pointer to the object that is privately sub-classing us.">this_session_srv()</a>. </p>

<p class="definition">Definition at line <a class="el" href="session__server__impl_8hpp_source.html#l00151">151</a> of file <a class="el" href="session__server__impl_8hpp_source.html">session_server_impl.hpp</a>.</p>

</div>
</div>
<h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="a9bf4d5502b41c98a98fee4cc3c2f2530" name="a9bf4d5502b41c98a98fee4cc3c2f2530"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9bf4d5502b41c98a98fee4cc3c2f2530">&#9670;&nbsp;</a></span>Session_server_impl()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Session_server_t , typename <a class="el" href="classServer__session__t.html">Server_session_t</a> &gt; </div>
<div class="memtemplate">
template&lt;typename Per_app_setup_func &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classipc_1_1session_1_1Session__server__impl.html">ipc::session::Session_server_impl</a>&lt; Session_server_t, <a class="el" href="classServer__session__t.html">Server_session_t</a> &gt;::Session_server_impl </td>
          <td>(</td>
          <td class="paramtype">flow::log::Logger *&#160;</td>
          <td class="paramname"><em>logger_ptr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classipc_1_1session_1_1Session__server__impl.html#a47625f247dea35cf276d31c039c6bf0c">Session_server_obj</a> *&#160;</td>
          <td class="paramname"><em>this_session_srv_arg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structipc_1_1session_1_1Server__app.html">Server_app</a> &amp;&#160;</td>
          <td class="paramname"><em>srv_app_ref</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structipc_1_1session_1_1Client__app.html#add718cbf6aa1d2abb26fbadcc974a7bd">Client_app::Master_set</a> &amp;&#160;</td>
          <td class="paramname"><em>cli_app_master_set_ref</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceipc.html#aa3192e586cc45d3e7c22463bf2760f89">Error_code</a> *&#160;</td>
          <td class="paramname"><em>err_code</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Per_app_setup_func &amp;&amp;&#160;</td>
          <td class="paramname"><em>per_app_setup_func</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">explicit</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>See <a class="el" href="classipc_1_1session_1_1Session__server.html" title="To be instantiated typically once in a given process, an object of this type asynchronously listens f...">Session_server</a> ctor; it does that. </p>
<p >In addition:</p>
<p >takes and memorizes a functor that takes a <a class="el" href="structipc_1_1session_1_1Client__app.html" title="An App that is used as a client in at least one client-server IPC split.">Client_app</a> const ref that identifies the app that wants to open the session, performs unspecified synchronous steps, and returns an <a class="el" href="namespaceipc.html#aa3192e586cc45d3e7c22463bf2760f89" title="Short-hand for flow::Error_code which is very common.">Error_code</a> indicating success or reason for failure which dooms that <a class="el" href="classipc_1_1session_1_1Session__server__impl.html#a60ec88b23d73c354959a1e11636dc717" title="See Session_server method.">async_accept()</a>.</p>
<h3>Rationale for <code>per_app_setup_func</code></h3>
<p >It is not intended for per-session setup. <a class="el" href="classipc_1_1session_1_1Session__server__impl.html#ae87dfd48a7e435800255722301d5bddc" title="Short-hand for concrete Server_session_dtl type, which each async_accept() creates internally,...">Server_session_dtl_obj</a> should take care of that where it makes sense &ndash; it does after all represent the individual budding session peer. However our sub-class (e.g., <a class="el" href="classipc_1_1session_1_1shm_1_1classic_1_1Session__server.html" title="This is to vanilla Session_server what shm::classic::Server_session is to vanilla Server_session: it ...">shm::classic::Session_server</a>) may need to keep track of per-distinct-Client_app resources (e.g., the per-app-scope SHM arena) which must exist before the opposing Client_session-type object completes its setup (e.g., by opening the aforementioned per-Client_app/multi-instance-scope SHM arena). It can detect a new <a class="el" href="structipc_1_1session_1_1Client__app.html" title="An App that is used as a client in at least one client-server IPC split.">Client_app</a> is logging-in and set that up in the nick of time.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Per_app_setup_func</td><td>See above. Signature: <code>Error_code F(const Client_app&amp;)</code>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">logger_ptr</td><td>See <a class="el" href="classipc_1_1session_1_1Session__server.html" title="To be instantiated typically once in a given process, an object of this type asynchronously listens f...">Session_server</a> ctor. </td></tr>
    <tr><td class="paramname">srv_app_ref</td><td>See <a class="el" href="classipc_1_1session_1_1Session__server.html" title="To be instantiated typically once in a given process, an object of this type asynchronously listens f...">Session_server</a> ctor. </td></tr>
    <tr><td class="paramname">cli_app_master_set_ref</td><td>See <a class="el" href="classipc_1_1session_1_1Session__server.html" title="To be instantiated typically once in a given process, an object of this type asynchronously listens f...">Session_server</a> ctor. </td></tr>
    <tr><td class="paramname">err_code</td><td>See <a class="el" href="classipc_1_1session_1_1Session__server.html" title="To be instantiated typically once in a given process, an object of this type asynchronously listens f...">Session_server</a> ctor. Additional <a class="el" href="namespaceipc.html#aa3192e586cc45d3e7c22463bf2760f89" title="Short-hand for flow::Error_code which is very common.">Error_code</a> generated: see <code>per_app_setup_func</code>. </td></tr>
    <tr><td class="paramname">per_app_setup_func</td><td>See above. </td></tr>
    <tr><td class="paramname">this_session_srv_arg</td><td>The object that is, in fact, <code>private</code>ly sub-classing <code>*this</code> (and calling this ctor). See <a class="el" href="classipc_1_1session_1_1Session__server__impl.html#ad7cd4d77db826af9fe39c17e8ee7ca37" title="Returns pointer to the object that is privately sub-classing us.">this_session_srv()</a>. The value is only saved but not dereferenced inside the ctor. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="session__server__impl_8hpp_source.html#l00437">437</a> of file <a class="el" href="session__server__impl_8hpp_source.html">session_server_impl.hpp</a>.</p>

<p class="reference">References <a class="el" href="server__session__dtl_8hpp_source.html#l00151">ipc::session::Server_session_dtl&lt; Server_session_t &gt;::base()</a>, <a class="el" href="ipc__session_2src_2ipc_2session_2detail_2session__shared__name_8cpp_source.html#l00093">ipc::session::build_conventional_shared_name_prefix()</a>, <a class="el" href="shared__name_8hpp_source.html#l00674">ipc::util::Shared_name::ct()</a>, <a class="el" href="app_8cpp_source.html#l00031">ipc::session::ensure_resource_owner_is_app()</a>, <a class="el" href="app_8hpp_source.html#l00171">ipc::session::App::m_group_id</a>, <a class="el" href="app_8hpp_source.html#l00144">ipc::session::App::m_name</a>, <a class="el" href="app_8hpp_source.html#l00288">ipc::session::Server_app::m_permissions_level_for_client_apps</a>, <a class="el" href="session__server__impl_8hpp_source.html#l00285">ipc::session::Session_server_impl&lt; Session_server_t, Server_session_t &gt;::m_srv_app_ref</a>, <a class="el" href="session__server__impl_8hpp_source.html#l00418">ipc::session::Session_server_impl&lt; Session_server_t, Server_session_t &gt;::m_state</a>, <a class="el" href="app_8hpp_source.html#l00168">ipc::session::App::m_user_id</a>, <a class="el" href="util_8hpp_source.html#l00034">ipc::util::op_with_possible_bipc_exception()</a>, <a class="el" href="ipc__core_2src_2ipc_2util_2util_8cpp_source.html#l00030">ipc::util::OPEN_OR_CREATE</a>, <a class="el" href="ipc__core_2src_2ipc_2util_2detail_2util_8cpp_source.html#l00042">ipc::util::PRODUCER_CONSUMER_RESOURCE_PERMISSIONS_LVL_MAP</a>, <a class="el" href="namespaceipc_1_1session_1_1error.html#a0708d4bec9ae853f4d7e3d7822fc8f2fa7300721595cc25baa9a9e43bd76296aa">ipc::session::error::S_MUTEX_BIPC_MISC_LIBRARY_ERROR</a>, <a class="el" href="namespaceipc_1_1session_1_1error.html#a0708d4bec9ae853f4d7e3d7822fc8f2fa5c437fa266aea0c8e2b348ee84dd61fa">ipc::session::error::S_RESOURCE_OWNER_UNEXPECTED</a>, <a class="el" href="ipc__core_2src_2ipc_2util_2util_8cpp_source.html#l00046">ipc::util::set_resource_permissions()</a>, and <a class="el" href="ipc__core_2src_2ipc_2util_2util_8cpp_source.html#l00037">ipc::util::shared_resource_permissions()</a>.</p>
<div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="classipc_1_1session_1_1Session__server__impl_a9bf4d5502b41c98a98fee4cc3c2f2530_cgraph.svg" width="558" height="480"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe>
</div>
</div>

</div>
</div>
<a id="ae4388def520aad700a3fcdfc95b6f24e" name="ae4388def520aad700a3fcdfc95b6f24e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae4388def520aad700a3fcdfc95b6f24e">&#9670;&nbsp;</a></span>~Session_server_impl()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Session_server_t , typename <a class="el" href="classServer__session__t.html">Server_session_t</a> &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classipc_1_1session_1_1Session__server__impl.html">ipc::session::Session_server_impl</a>&lt; Session_server_t, <a class="el" href="classServer__session__t.html">Server_session_t</a> &gt;::~<a class="el" href="classipc_1_1session_1_1Session__server__impl.html">Session_server_impl</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>See <a class="el" href="classipc_1_1session_1_1Session__server.html" title="To be instantiated typically once in a given process, an object of this type asynchronously listens f...">Session_server</a> dtor. </p>

<p class="definition">Definition at line <a class="el" href="session__server__impl_8hpp_source.html#l00715">715</a> of file <a class="el" href="session__server__impl_8hpp_source.html">session_server_impl.hpp</a>.</p>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="a60ec88b23d73c354959a1e11636dc717" name="a60ec88b23d73c354959a1e11636dc717"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a60ec88b23d73c354959a1e11636dc717">&#9670;&nbsp;</a></span>async_accept()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Session_server_t , typename <a class="el" href="classServer__session__t.html">Server_session_t</a> &gt; </div>
<div class="memtemplate">
template&lt;typename Task_err , typename N_init_channels_by_srv_req_func , typename Mdt_load_func &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classipc_1_1session_1_1Session__server__impl.html">ipc::session::Session_server_impl</a>&lt; Session_server_t, <a class="el" href="classServer__session__t.html">Server_session_t</a> &gt;::async_accept </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classipc_1_1session_1_1Session__server__impl.html#a0009247dd98ec58b22040d1c65bb5a54">Server_session_obj</a> *&#160;</td>
          <td class="paramname"><em>target_session</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classipc_1_1session_1_1Session__server__impl.html#a9ad5c6cbb1c9378d42ec5cd909389dc2">Channels</a> *&#160;</td>
          <td class="paramname"><em>init_channels_by_srv_req</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classipc_1_1session_1_1Session__server__impl.html#a86de1d5b7cae35d89827c3235e2b8d89">Mdt_reader_ptr</a> *&#160;</td>
          <td class="paramname"><em>mdt_from_cli_or_null</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classipc_1_1session_1_1Session__server__impl.html#a9ad5c6cbb1c9378d42ec5cd909389dc2">Channels</a> *&#160;</td>
          <td class="paramname"><em>init_channels_by_cli_req</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">N_init_channels_by_srv_req_func &amp;&amp;&#160;</td>
          <td class="paramname"><em>n_init_channels_by_srv_req_func</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Mdt_load_func &amp;&amp;&#160;</td>
          <td class="paramname"><em>mdt_load_func</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Task_err &amp;&amp;&#160;</td>
          <td class="paramname"><em>on_done_func</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>See <a class="el" href="classipc_1_1session_1_1Session__server.html" title="To be instantiated typically once in a given process, an object of this type asynchronously listens f...">Session_server</a> method. </p>
<p >In addition: invokes <code>per_app_setup_func()</code> (from ctor) once the connecting <a class="el" href="structipc_1_1session_1_1Client__app.html" title="An App that is used as a client in at least one client-server IPC split.">Client_app</a> becomes known; if that returns truthy <a class="el" href="namespaceipc.html#aa3192e586cc45d3e7c22463bf2760f89" title="Short-hand for flow::Error_code which is very common.">Error_code</a> then this method emits that error.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Task_err</td><td>See <a class="el" href="classipc_1_1session_1_1Session__server.html" title="To be instantiated typically once in a given process, an object of this type asynchronously listens f...">Session_server</a> method. </td></tr>
    <tr><td class="paramname">N_init_channels_by_srv_req_func</td><td>See <a class="el" href="classipc_1_1session_1_1Session__server.html" title="To be instantiated typically once in a given process, an object of this type asynchronously listens f...">Session_server</a> method. </td></tr>
    <tr><td class="paramname">Mdt_load_func</td><td>See <a class="el" href="classipc_1_1session_1_1Session__server.html" title="To be instantiated typically once in a given process, an object of this type asynchronously listens f...">Session_server</a> method. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">target_session</td><td>See <a class="el" href="classipc_1_1session_1_1Session__server.html" title="To be instantiated typically once in a given process, an object of this type asynchronously listens f...">Session_server</a> method. </td></tr>
    <tr><td class="paramname">init_channels_by_srv_req</td><td>See <a class="el" href="classipc_1_1session_1_1Session__server.html" title="To be instantiated typically once in a given process, an object of this type asynchronously listens f...">Session_server</a> method. </td></tr>
    <tr><td class="paramname">mdt_from_cli_or_null</td><td>See <a class="el" href="classipc_1_1session_1_1Session__server.html" title="To be instantiated typically once in a given process, an object of this type asynchronously listens f...">Session_server</a> method. </td></tr>
    <tr><td class="paramname">init_channels_by_cli_req</td><td>See <a class="el" href="classipc_1_1session_1_1Session__server.html" title="To be instantiated typically once in a given process, an object of this type asynchronously listens f...">Session_server</a> method. </td></tr>
    <tr><td class="paramname">n_init_channels_by_srv_req_func</td><td>See <a class="el" href="classipc_1_1session_1_1Session__server.html" title="To be instantiated typically once in a given process, an object of this type asynchronously listens f...">Session_server</a> method. </td></tr>
    <tr><td class="paramname">mdt_load_func</td><td>See <a class="el" href="classipc_1_1session_1_1Session__server.html" title="To be instantiated typically once in a given process, an object of this type asynchronously listens f...">Session_server</a> method. </td></tr>
    <tr><td class="paramname">on_done_func</td><td>See <a class="el" href="classipc_1_1session_1_1Session__server.html" title="To be instantiated typically once in a given process, an object of this type asynchronously listens f...">Session_server</a> method. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="session__server__impl_8hpp_source.html#l00746">746</a> of file <a class="el" href="session__server__impl_8hpp_source.html">session_server_impl.hpp</a>.</p>

<p class="reference">References <a class="el" href="shared__name_8hpp_source.html#l00674">ipc::util::Shared_name::ct()</a>, <a class="el" href="namespaceipc_1_1transport_1_1error.html#adfef15ef4e76cc55d652fbd9c2797297afe29343445a7bf167cc186a44bd2c6ed">ipc::transport::error::S_OBJECT_SHUTDOWN_ABORTED_COMPLETION_HANDLER</a>, and <a class="el" href="namespaceipc_1_1session_1_1error.html#a0708d4bec9ae853f4d7e3d7822fc8f2fafe29343445a7bf167cc186a44bd2c6ed">ipc::session::error::S_OBJECT_SHUTDOWN_ABORTED_COMPLETION_HANDLER</a>.</p>
<div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="classipc_1_1session_1_1Session__server__impl_a60ec88b23d73c354959a1e11636dc717_cgraph.svg" width="394" height="47"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe>
</div>
</div>

</div>
</div>
<a id="a40fca0b878f9150f5f7db55768da45ad" name="a40fca0b878f9150f5f7db55768da45ad"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a40fca0b878f9150f5f7db55768da45ad">&#9670;&nbsp;</a></span>sub_class_set_deinit_func()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Session_server_t , typename <a class="el" href="classServer__session__t.html">Server_session_t</a> &gt; </div>
<div class="memtemplate">
template&lt;typename Task &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classipc_1_1session_1_1Session__server__impl.html">ipc::session::Session_server_impl</a>&lt; Session_server_t, <a class="el" href="classServer__session__t.html">Server_session_t</a> &gt;::sub_class_set_deinit_func </td>
          <td>(</td>
          <td class="paramtype">Task &amp;&amp;&#160;</td>
          <td class="paramname"><em>task</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Utility for sub-classes: ensures that <code>task()</code> is invoked near the end of <code>*this</code> dtor's execution, after <em>all</em> other (mutable) state has been destroyed, including stopping/joining any threads performing async <a class="el" href="classipc_1_1session_1_1Session__server__impl.html#a60ec88b23d73c354959a1e11636dc717" title="See Session_server method.">async_accept()</a> ops. </p>
<p >It may be invoked at most once.</p>
<p >The value it adds: A long story best told by specific example. See the original use case which is in <a class="el" href="classipc_1_1session_1_1shm_1_1classic_1_1Session__server.html" title="This is to vanilla Session_server what shm::classic::Server_session is to vanilla Server_session: it ...">shm::classic::Session_server</a>; it sets up certain SHM cleanup steps to occur, when the session-server is destroyed.</p>
<h3>Watch out!</h3>
<p >At the time <code>task()</code> runs, the calling instance of the sub-class has been destroyed &ndash; thus it is, e.g., usually wrong to capture your <code>this</code> in the <code>task</code> lambda, except for logging. <code>get_logger()</code> and <code>get_log_component()</code> (which are in this super-class) are still okay to use.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Task</td><td>Function object invoked as <code>void</code> with no args. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">task</td><td><code>task()</code> shall execute before dtor returns. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="session__server__impl_8hpp_source.html#l00987">987</a> of file <a class="el" href="session__server__impl_8hpp_source.html">session_server_impl.hpp</a>.</p>

</div>
</div>
<a id="ad7cd4d77db826af9fe39c17e8ee7ca37" name="ad7cd4d77db826af9fe39c17e8ee7ca37"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad7cd4d77db826af9fe39c17e8ee7ca37">&#9670;&nbsp;</a></span>this_session_srv()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Session_server_t , typename <a class="el" href="classServer__session__t.html">Server_session_t</a> &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classipc_1_1session_1_1Session__server__impl.html">Session_server_impl</a>&lt; Session_server_t, <a class="el" href="classServer__session__t.html">Server_session_t</a> &gt;<a class="el" href="classipc_1_1session_1_1Session__server__impl.html#a47625f247dea35cf276d31c039c6bf0c">::Session_server_obj</a> * <a class="el" href="classipc_1_1session_1_1Session__server__impl.html">ipc::session::Session_server_impl</a>&lt; Session_server_t, <a class="el" href="classServer__session__t.html">Server_session_t</a> &gt;::this_session_srv</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns pointer to the object that is <code>private</code>ly sub-classing us. </p>
<p >In other words this equals <code>static_cast&lt;const Session_server_obj*&gt;(this)</code>, where this class is the base of <a class="el" href="classipc_1_1session_1_1Session__server__impl.html#a47625f247dea35cf276d31c039c6bf0c" title="See this_session_srv().">Session_server_obj</a>, but up-casting from a <code>private</code> base is not allowed.</p>
<h3>Rationale</h3>
<p >I (ygoldfel) acknowledge this is somewhat odd. Why should a sub-class, per se, care or know about its super-class? This at least vaguely indicates some sort of design mistake. In fact this is needed, as of this writing, because <a class="el" href="classipc_1_1session_1_1shm_1_1classic_1_1Server__session__impl.html#a9c78b2c35b853e1702a06ec451545945" title="For use by internal user Session_server: See Server_session_mv counterpart.">shm::classic::Server_session_impl::async_accept_log_in()</a> gets a <a class="el" href="classipc_1_1session_1_1Session__server__impl.html" title="Internal class template comprising API/logic common to every Session_server variant,...">Session_server_impl</a> ptr, which it knows points to an object that's really the core of a <a class="el" href="classipc_1_1session_1_1shm_1_1classic_1_1Session__server.html" title="This is to vanilla Session_server what shm::classic::Server_session is to vanilla Server_session: it ...">shm::classic::Session_server</a>, and it needs to interact with the SHM-classic-specific aspect of that guy's API. So it calls this accessor here, essentially as a way to up-cast from a <code>private</code> base (which is not allowed by C++). Why can't it "just" take a <code><a class="el" href="classipc_1_1session_1_1shm_1_1classic_1_1Session__server.html" title="This is to vanilla Session_server what shm::classic::Server_session is to vanilla Server_session: it ...">shm::classic::Session_server</a>*</code> then? Answer: because <a class="el" href="classipc_1_1session_1_1Session__server__impl.html" title="Internal class template comprising API/logic common to every Session_server variant,...">Session_server_impl</a> uses, like, <code>virtual</code>-less polymorphism to invoke <code>async_accept_log_in()</code> regardless of which object it's calling it on.... It's hard to summarize here in words in any way that'll make sense, but if one looks at the relevant code it makes sense. Eventually. Bottom line is, this way, it can just pass-in <code>this</code>, and then <a class="el" href="classipc_1_1session_1_1shm_1_1classic_1_1Server__session__impl.html#a9c78b2c35b853e1702a06ec451545945" title="For use by internal user Session_server: See Server_session_mv counterpart.">shm::classic::Server_session_impl::async_accept_log_in()</a> can call <a class="el" href="classipc_1_1session_1_1Session__server__impl.html#ad7cd4d77db826af9fe39c17e8ee7ca37" title="Returns pointer to the object that is privately sub-classing us.">this_session_srv()</a> to get at the super-class version of <code>this</code>.</p>
<p >I feel it is not criminal &ndash; internal things are working together in a way that they logically intend to &ndash; but intuitively it feels like there's a smoother way to design it. Probably.</p>
<dl class="todo"><dt><b><a class="el" href="todo.html#_todo000035">Todo:</a></b></dt><dd>Reconsider the details of how classes in the non-<code>virtual</code> hierarchies <code><a class="el" href="classipc_1_1session_1_1Session__server.html" title="To be instantiated typically once in a given process, an object of this type asynchronously listens f...">Session_server</a></code>, <code>Server_session</code>, <code><a class="el" href="classipc_1_1session_1_1Session__server__impl.html" title="Internal class template comprising API/logic common to every Session_server variant,...">Session_server_impl</a></code>, <code><a class="el" href="classipc_1_1session_1_1Server__session__impl.html" title="Internal, non-movable pImpl-lite implementation of Server_session_mv class template.">Server_session_impl</a></code> cooperate internally, as there is some funky stuff going on, particularly <a class="el" href="classipc_1_1session_1_1Session__server__impl.html#ad7cd4d77db826af9fe39c17e8ee7ca37" title="Returns pointer to the object that is privately sub-classing us.">Session_server_impl::this_session_srv()</a>.</dd></dl>
<dl class="section return"><dt>Returns</dt><dd>See above. </dd></dl>

<p class="definition">Definition at line <a class="el" href="session__server__impl_8hpp_source.html#l00980">980</a> of file <a class="el" href="session__server__impl_8hpp_source.html">session_server_impl.hpp</a>.</p>

</div>
</div>
<a id="a2a3c0c330d477176b714a9920196775d" name="a2a3c0c330d477176b714a9920196775d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2a3c0c330d477176b714a9920196775d">&#9670;&nbsp;</a></span>to_ostream()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Session_server_t , typename <a class="el" href="classServer__session__t.html">Server_session_t</a> &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classipc_1_1session_1_1Session__server__impl.html">ipc::session::Session_server_impl</a>&lt; Session_server_t, <a class="el" href="classServer__session__t.html">Server_session_t</a> &gt;::to_ostream </td>
          <td>(</td>
          <td class="paramtype">std::ostream *&#160;</td>
          <td class="paramname"><em>os</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>See Server_session method. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">os</td><td>See Server_session method. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="session__server__impl_8hpp_source.html#l00974">974</a> of file <a class="el" href="session__server__impl_8hpp_source.html">session_server_impl.hpp</a>.</p>

</div>
</div>
<h2 class="groupheader">Friends And Related Function Documentation</h2>
<a id="a5fc42e333522f7b1ed11fbff4ae72e5c" name="a5fc42e333522f7b1ed11fbff4ae72e5c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5fc42e333522f7b1ed11fbff4ae72e5c">&#9670;&nbsp;</a></span>operator&lt;&lt;()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Session_server_t , typename <a class="el" href="classServer__session__t.html">Server_session_t</a> &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::ostream &amp; operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>os</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classipc_1_1session_1_1Session__server__impl.html">Session_server_impl</a>&lt; Session_server_t, <a class="el" href="classServer__session__t.html">Server_session_t</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>val</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Prints string representation of the given <code><a class="el" href="classipc_1_1session_1_1Session__server__impl.html" title="Internal class template comprising API/logic common to every Session_server variant,...">Session_server_impl</a></code> to the given <code>ostream</code>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">os</td><td>Stream to which to write. </td></tr>
    <tr><td class="paramname">val</td><td>Object to serialize. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>os</code>. </dd></dl>

<p class="definition">Definition at line <a class="el" href="session__server__impl_8hpp_source.html#l00993">993</a> of file <a class="el" href="session__server__impl_8hpp_source.html">session_server_impl.hpp</a>.</p>

</div>
</div>
<h2 class="groupheader">Member Data Documentation</h2>
<a id="a798164cc2876cfaddf8793bd346d13f9" name="a798164cc2876cfaddf8793bd346d13f9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a798164cc2876cfaddf8793bd346d13f9">&#9670;&nbsp;</a></span>m_cli_app_master_set_ref</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Session_server_t , typename <a class="el" href="classServer__session__t.html">Server_session_t</a> &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="structipc_1_1session_1_1Client__app.html#add718cbf6aa1d2abb26fbadcc974a7bd">Client_app::Master_set</a>&amp; <a class="el" href="classipc_1_1session_1_1Session__server__impl.html">ipc::session::Session_server_impl</a>&lt; Session_server_t, <a class="el" href="classServer__session__t.html">Server_session_t</a> &gt;::m_cli_app_master_set_ref</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>See ctor. </p>

<p class="definition">Definition at line <a class="el" href="session__server__impl_8hpp_source.html#l00412">412</a> of file <a class="el" href="session__server__impl_8hpp_source.html">session_server_impl.hpp</a>.</p>

</div>
</div>
<a id="a98165f48041d5a2846c7ac574833b933" name="a98165f48041d5a2846c7ac574833b933"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a98165f48041d5a2846c7ac574833b933">&#9670;&nbsp;</a></span>m_deinit_func_or_empty</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Session_server_t , typename <a class="el" href="classServer__session__t.html">Server_session_t</a> &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespaceipc.html#aa455c7f045059736578ca275fc1a851f">Function</a>&lt;void ()&gt; <a class="el" href="classipc_1_1session_1_1Session__server__impl.html">ipc::session::Session_server_impl</a>&lt; Session_server_t, <a class="el" href="classServer__session__t.html">Server_session_t</a> &gt;::m_deinit_func_or_empty</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>See <a class="el" href="classipc_1_1session_1_1Session__server__impl.html#a40fca0b878f9150f5f7db55768da45ad" title="Utility for sub-classes: ensures that task() is invoked near the end of *this dtor&#39;s execution,...">sub_class_set_deinit_func()</a>. <code>.empty()</code> unless that was called at least once. </p>

<p class="definition">Definition at line <a class="el" href="session__server__impl_8hpp_source.html#l00421">421</a> of file <a class="el" href="session__server__impl_8hpp_source.html">session_server_impl.hpp</a>.</p>

</div>
</div>
<a id="adc97c8fd3c5860dc6164f0a384b9fe03" name="adc97c8fd3c5860dc6164f0a384b9fe03"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adc97c8fd3c5860dc6164f0a384b9fe03">&#9670;&nbsp;</a></span>m_per_app_setup_func</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Session_server_t , typename <a class="el" href="classServer__session__t.html">Server_session_t</a> &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="namespaceipc.html#aa455c7f045059736578ca275fc1a851f">Function</a>&lt;<a class="el" href="namespaceipc.html#aa3192e586cc45d3e7c22463bf2760f89">Error_code</a> (const <a class="el" href="structipc_1_1session_1_1Client__app.html">Client_app</a>&amp; client_app)&gt; <a class="el" href="classipc_1_1session_1_1Session__server__impl.html">ipc::session::Session_server_impl</a>&lt; Session_server_t, <a class="el" href="classServer__session__t.html">Server_session_t</a> &gt;::m_per_app_setup_func</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>See ctor. </p>

<p class="definition">Definition at line <a class="el" href="session__server__impl_8hpp_source.html#l00415">415</a> of file <a class="el" href="session__server__impl_8hpp_source.html">session_server_impl.hpp</a>.</p>

</div>
</div>
<a id="a7be0cca184cdba62b9748e0ca37b8b17" name="a7be0cca184cdba62b9748e0ca37b8b17"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7be0cca184cdba62b9748e0ca37b8b17">&#9670;&nbsp;</a></span>m_srv_app_ref</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Session_server_t , typename <a class="el" href="classServer__session__t.html">Server_session_t</a> &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="structipc_1_1session_1_1Server__app.html">Server_app</a>&amp; <a class="el" href="classipc_1_1session_1_1Session__server__impl.html">ipc::session::Session_server_impl</a>&lt; Session_server_t, <a class="el" href="classServer__session__t.html">Server_session_t</a> &gt;::m_srv_app_ref</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>See <a class="el" href="classipc_1_1session_1_1Session__server.html" title="To be instantiated typically once in a given process, an object of this type asynchronously listens f...">Session_server</a> public data member. </p>

<p class="definition">Definition at line <a class="el" href="session__server__impl_8hpp_source.html#l00285">285</a> of file <a class="el" href="session__server__impl_8hpp_source.html">session_server_impl.hpp</a>.</p>

<p class="reference">Referenced by <a class="el" href="session__server__impl_8hpp_source.html#l00438">ipc::session::Session_server_impl&lt; Session_server_t, Server_session_t &gt;::Session_server_impl()</a>.</p>

</div>
</div>
<a id="ac49be718ad86c3919563da57502d11b3" name="ac49be718ad86c3919563da57502d11b3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac49be718ad86c3919563da57502d11b3">&#9670;&nbsp;</a></span>m_state</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Session_server_t , typename <a class="el" href="classServer__session__t.html">Server_session_t</a> &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::optional&lt;<a class="el" href="structipc_1_1session_1_1Session__server__impl_1_1State.html">State</a>&gt; <a class="el" href="classipc_1_1session_1_1Session__server__impl.html">ipc::session::Session_server_impl</a>&lt; Session_server_t, <a class="el" href="classServer__session__t.html">Server_session_t</a> &gt;::m_state</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>See <a class="el" href="structipc_1_1session_1_1Session__server__impl_1_1State.html" title="All internal mutable state of Session_server_impl.">State</a>. </p>

<p class="definition">Definition at line <a class="el" href="session__server__impl_8hpp_source.html#l00418">418</a> of file <a class="el" href="session__server__impl_8hpp_source.html">session_server_impl.hpp</a>.</p>

<p class="reference">Referenced by <a class="el" href="session__server__impl_8hpp_source.html#l00438">ipc::session::Session_server_impl&lt; Session_server_t, Server_session_t &gt;::Session_server_impl()</a>.</p>

</div>
</div>
<a id="aa7aed6de161203a2e7414411fa1defa5" name="aa7aed6de161203a2e7414411fa1defa5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa7aed6de161203a2e7414411fa1defa5">&#9670;&nbsp;</a></span>m_this_session_srv</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Session_server_t , typename <a class="el" href="classServer__session__t.html">Server_session_t</a> &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classipc_1_1session_1_1Session__server__impl.html#a47625f247dea35cf276d31c039c6bf0c">Session_server_obj</a>* const <a class="el" href="classipc_1_1session_1_1Session__server__impl.html">ipc::session::Session_server_impl</a>&lt; Session_server_t, <a class="el" href="classServer__session__t.html">Server_session_t</a> &gt;::m_this_session_srv</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>See <a class="el" href="classipc_1_1session_1_1Session__server__impl.html#ad7cd4d77db826af9fe39c17e8ee7ca37" title="Returns pointer to the object that is privately sub-classing us.">this_session_srv()</a>. </p>

<p class="definition">Definition at line <a class="el" href="session__server__impl_8hpp_source.html#l00409">409</a> of file <a class="el" href="session__server__impl_8hpp_source.html">session_server_impl.hpp</a>.</p>

</div>
</div>
<hr/>The documentation for this class was generated from the following files:<ul>
<li>session/detail/<a class="el" href="detail_2session__fwd_8hpp_source.html">session_fwd.hpp</a></li>
<li>session/detail/<a class="el" href="session__server__impl_8hpp_source.html">session_server_impl.hpp</a></li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Tue Mar 26 2024 02:49:35 for Flow-IPC by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.4
</small></address>
</body>
</html>
