<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.9.4"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Flow-IPC: transport/struc/sync_io/channel.hpp Source File</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">Flow-IPC<span id="projectnumber">&#160;1.0.1</span>
   </div>
   <div id="projectbrief">Flow-IPC project: Full implementation reference.</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.4 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search",'Search','.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="dir_58e412aa7ace8e71fc01678dc8765e7c.html">transport</a></li><li class="navelem"><a class="el" href="dir_a98fddea045b8b2df4350ebb1d483bf8.html">struc</a></li><li class="navelem"><a class="el" href="dir_29eca46078f73b220c63d096b03a57e8.html">sync_io</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="headertitle"><div class="title">channel.hpp</div></div>
</div><!--header-->
<div class="contents">
<a href="ipc__transport__structured_2src_2ipc_2transport_2struc_2sync__io_2channel_8hpp.html">Go to the documentation of this file.</a><div class="fragment"><div class="line"><a id="l00001" name="l00001"></a><span class="lineno">    1</span><span class="comment">/* Flow-IPC: Structured Transport</span></div>
<div class="line"><a id="l00002" name="l00002"></a><span class="lineno">    2</span><span class="comment"> * Copyright (c) 2023 Akamai Technologies, Inc.; and other contributors.</span></div>
<div class="line"><a id="l00003" name="l00003"></a><span class="lineno">    3</span><span class="comment"> * Each commit is copyright by its respective author or author&#39;s employer.</span></div>
<div class="line"><a id="l00004" name="l00004"></a><span class="lineno">    4</span><span class="comment"> *</span></div>
<div class="line"><a id="l00005" name="l00005"></a><span class="lineno">    5</span><span class="comment"> * Licensed under the MIT License:</span></div>
<div class="line"><a id="l00006" name="l00006"></a><span class="lineno">    6</span><span class="comment"> *</span></div>
<div class="line"><a id="l00007" name="l00007"></a><span class="lineno">    7</span><span class="comment"> * Permission is hereby granted, free of charge, to any person obtaining a copy</span></div>
<div class="line"><a id="l00008" name="l00008"></a><span class="lineno">    8</span><span class="comment"> * of this software and associated documentation files (the &quot;Software&quot;), to deal</span></div>
<div class="line"><a id="l00009" name="l00009"></a><span class="lineno">    9</span><span class="comment"> * in the Software without restriction, including without limitation the rights</span></div>
<div class="line"><a id="l00010" name="l00010"></a><span class="lineno">   10</span><span class="comment"> * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell</span></div>
<div class="line"><a id="l00011" name="l00011"></a><span class="lineno">   11</span><span class="comment"> * copies of the Software, and to permit persons to whom the Software is</span></div>
<div class="line"><a id="l00012" name="l00012"></a><span class="lineno">   12</span><span class="comment"> * furnished to do so, subject to the following conditions:</span></div>
<div class="line"><a id="l00013" name="l00013"></a><span class="lineno">   13</span><span class="comment"> *</span></div>
<div class="line"><a id="l00014" name="l00014"></a><span class="lineno">   14</span><span class="comment"> * The above copyright notice and this permission notice shall be included in</span></div>
<div class="line"><a id="l00015" name="l00015"></a><span class="lineno">   15</span><span class="comment"> * all copies or substantial portions of the Software.</span></div>
<div class="line"><a id="l00016" name="l00016"></a><span class="lineno">   16</span><span class="comment"> *</span></div>
<div class="line"><a id="l00017" name="l00017"></a><span class="lineno">   17</span><span class="comment"> * THE SOFTWARE IS PROVIDED &quot;AS IS&quot;, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR</span></div>
<div class="line"><a id="l00018" name="l00018"></a><span class="lineno">   18</span><span class="comment"> * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,</span></div>
<div class="line"><a id="l00019" name="l00019"></a><span class="lineno">   19</span><span class="comment"> * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE</span></div>
<div class="line"><a id="l00020" name="l00020"></a><span class="lineno">   20</span><span class="comment"> * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER</span></div>
<div class="line"><a id="l00021" name="l00021"></a><span class="lineno">   21</span><span class="comment"> * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,</span></div>
<div class="line"><a id="l00022" name="l00022"></a><span class="lineno">   22</span><span class="comment"> * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN</span></div>
<div class="line"><a id="l00023" name="l00023"></a><span class="lineno">   23</span><span class="comment"> * THE SOFTWARE. */</span></div>
<div class="line"><a id="l00024" name="l00024"></a><span class="lineno">   24</span><span class="comment"></span> </div>
<div class="line"><a id="l00025" name="l00025"></a><span class="lineno">   25</span><span class="comment">/// @file</span></div>
<div class="line"><a id="l00026" name="l00026"></a><span class="lineno">   26</span><span class="comment"></span><span class="preprocessor">#pragma once</span></div>
<div class="line"><a id="l00027" name="l00027"></a><span class="lineno">   27</span> </div>
<div class="line"><a id="l00028" name="l00028"></a><span class="lineno">   28</span><span class="preprocessor">#include &quot;<a class="code" href="channel__base_8hpp.html">ipc/transport/struc/channel_base.hpp</a>&quot;</span></div>
<div class="line"><a id="l00029" name="l00029"></a><span class="lineno">   29</span><span class="preprocessor">#include &quot;<a class="code" href="msg__impl_8hpp.html">ipc/transport/struc/detail/msg_impl.hpp</a>&quot;</span></div>
<div class="line"><a id="l00030" name="l00030"></a><span class="lineno">   30</span><span class="preprocessor">#include &quot;<a class="code" href="msg__mdt__out_8hpp.html">ipc/transport/struc/detail/msg_mdt_out.hpp</a>&quot;</span></div>
<div class="line"><a id="l00031" name="l00031"></a><span class="lineno">   31</span><span class="preprocessor">#include &quot;<a class="code" href="heap__serializer_8hpp.html">ipc/transport/struc/heap_serializer.hpp</a>&quot;</span></div>
<div class="line"><a id="l00032" name="l00032"></a><span class="lineno">   32</span><span class="preprocessor">#include &quot;<a class="code" href="ipc__core_2src_2ipc_2transport_2channel_8hpp.html">ipc/transport/channel.hpp</a>&quot;</span></div>
<div class="line"><a id="l00033" name="l00033"></a><span class="lineno">   33</span><span class="preprocessor">#include &quot;<a class="code" href="ipc__core_2src_2ipc_2transport_2error_8hpp.html">ipc/transport/error.hpp</a>&quot;</span></div>
<div class="line"><a id="l00034" name="l00034"></a><span class="lineno">   34</span><span class="preprocessor">#include &lt;flow/async/single_thread_task_loop.hpp&gt;</span></div>
<div class="line"><a id="l00035" name="l00035"></a><span class="lineno">   35</span><span class="preprocessor">#include &lt;capnp/pretty-print.h&gt;</span></div>
<div class="line"><a id="l00036" name="l00036"></a><span class="lineno">   36</span><span class="preprocessor">#include &lt;boost/uuid/random_generator.hpp&gt;</span></div>
<div class="line"><a id="l00037" name="l00037"></a><span class="lineno">   37</span><span class="preprocessor">#include &lt;boost/uuid/uuid_io.hpp&gt;</span></div>
<div class="line"><a id="l00038" name="l00038"></a><span class="lineno">   38</span><span class="preprocessor">#include &lt;boost/array.hpp&gt;</span></div>
<div class="line"><a id="l00039" name="l00039"></a><span class="lineno">   39</span><span class="preprocessor">#include &lt;boost/move/make_unique.hpp&gt;</span></div>
<div class="line"><a id="l00040" name="l00040"></a><span class="lineno">   40</span><span class="preprocessor">#include &lt;queue&gt;</span></div>
<div class="line"><a id="l00041" name="l00041"></a><span class="lineno">   41</span><span class="preprocessor">#include &lt;optional&gt;</span></div>
<div class="line"><a id="l00042" name="l00042"></a><span class="lineno">   42</span> </div>
<div class="line"><a id="l00043" name="l00043"></a><span class="lineno">   43</span><span class="keyword">namespace </span><a class="code hl_namespace" href="namespaceipc_1_1transport_1_1struc_1_1sync__io.html">ipc::transport::struc::sync_io</a></div>
<div class="line"><a id="l00044" name="l00044"></a><span class="lineno">   44</span>{</div>
<div class="line"><a id="l00045" name="l00045"></a><span class="lineno">   45</span> </div>
<div class="line"><a id="l00046" name="l00046"></a><span class="lineno">   46</span><span class="comment">// Types.</span></div>
<div class="line"><a id="l00047" name="l00047"></a><span class="lineno">   47</span><span class="comment"></span> </div>
<div class="line"><a id="l00048" name="l00048"></a><span class="lineno">   48</span><span class="comment">/**</span></div>
<div class="line"><a id="l00049" name="l00049"></a><span class="lineno">   49</span><span class="comment"> * `sync_io`-pattern counterpart to async-I/O-pattern transport::struc::Channel.</span></div>
<div class="line"><a id="l00050" name="l00050"></a><span class="lineno">   50</span><span class="comment"> *</span></div>
<div class="line"><a id="l00051" name="l00051"></a><span class="lineno">   51</span><span class="comment"> * @see transport::struc::Channel and util::sync_io doc headers.  The latter describes the general pattern which</span></div>
<div class="line"><a id="l00052" name="l00052"></a><span class="lineno">   52</span><span class="comment"> *      we implement here; it also contrasts it with the async-I/O pattern, which the former implements.</span></div>
<div class="line"><a id="l00053" name="l00053"></a><span class="lineno">   53</span><span class="comment"> *      In general we recommend you use a transport::struc::Channel rather than a `*this` --</span></div>
<div class="line"><a id="l00054" name="l00054"></a><span class="lineno">   54</span><span class="comment"> *      but you may have particular needs (summarized in util::sync_io doc header) that would make you decide</span></div>
<div class="line"><a id="l00055" name="l00055"></a><span class="lineno">   55</span><span class="comment"> *      otherwise.</span></div>
<div class="line"><a id="l00056" name="l00056"></a><span class="lineno">   56</span><span class="comment"> *</span></div>
<div class="line"><a id="l00057" name="l00057"></a><span class="lineno">   57</span><span class="comment"> * All notes on functionality in transport::struc::Channel (a/k/a alias Channel::Async_io_obj) doc</span></div>
<div class="line"><a id="l00058" name="l00058"></a><span class="lineno">   58</span><span class="comment"> * header apply to us.  The difference, as usual given `sync_io` and async-I/O mutual counterparts, is in how</span></div>
<div class="line"><a id="l00059" name="l00059"></a><span class="lineno">   59</span><span class="comment"> * results are reported.  Because struc::Channel in general stands apart from the many concept impls</span></div>
<div class="line"><a id="l00060" name="l00060"></a><span class="lineno">   60</span><span class="comment"> * of `Blob_sender`, `Blob_receiver`, etc. -- e.g., Native_socket_stream -- it may be helpful to summarize</span></div>
<div class="line"><a id="l00061" name="l00061"></a><span class="lineno">   61</span><span class="comment"> * how this `sync_io`-pattern type reports results.  The APIs look somewhat different from those</span></div>
<div class="line"><a id="l00062" name="l00062"></a><span class="lineno">   62</span><span class="comment"> * core-layer guys owing to the more complex mission statement here versus there.</span></div>
<div class="line"><a id="l00063" name="l00063"></a><span class="lineno">   63</span><span class="comment"> *</span></div>
<div class="line"><a id="l00064" name="l00064"></a><span class="lineno">   64</span><span class="comment"> *   - `expect_*(..., F)`: This says you want messages of a certain type, and when one arrives to invoke `F(I)`,</span></div>
<div class="line"><a id="l00065" name="l00065"></a><span class="lineno">   65</span><span class="comment"> *     `I` being the in-message.  However, depending on the API 1+ message(s) may already have been cached and</span></div>
<div class="line"><a id="l00066" name="l00066"></a><span class="lineno">   66</span><span class="comment"> *     are immediately available.  These are synchronously emitted via an out-arg; for example expect_msgs() takes</span></div>
<div class="line"><a id="l00067" name="l00067"></a><span class="lineno">   67</span><span class="comment"> *     a list-of-in-messages out-arg.  Depending on the API future messages may be relevant and will be emitted</span></div>
<div class="line"><a id="l00068" name="l00068"></a><span class="lineno">   68</span><span class="comment"> *     via `F()`.</span></div>
<div class="line"><a id="l00069" name="l00069"></a><span class="lineno">   69</span><span class="comment"> *   - `async_request(M, ..., F)`: This says you want `M` sent and expect 1 or 0+ (depending on args) response(s),</span></div>
<div class="line"><a id="l00070" name="l00070"></a><span class="lineno">   70</span><span class="comment"> *     and when one arrives to invoke `F(I)`, `I` being a response.  Since it is not possible to have received a</span></div>
<div class="line"><a id="l00071" name="l00071"></a><span class="lineno">   71</span><span class="comment"> *     response to a not-yet-sent out-message, that is just how it works.  There are no synchronous out-args.</span></div>
<div class="line"><a id="l00072" name="l00072"></a><span class="lineno">   72</span><span class="comment"> *   - `set_*unexpected_response_handler()`: If it&#39;s set, and an unexpected-response event occurs, this fires.</span></div>
<div class="line"><a id="l00073" name="l00073"></a><span class="lineno">   73</span><span class="comment"> *     If not, it doesn&#39;t.  There are no synchronous out-args.</span></div>
<div class="line"><a id="l00074" name="l00074"></a><span class="lineno">   74</span><span class="comment"> *   - `start_and_poll(F)`: This begins incoming-direction operation.  `F()` is the on-error handler.  It fires</span></div>
<div class="line"><a id="l00075" name="l00075"></a><span class="lineno">   75</span><span class="comment"> *     up to once per `*this` to indicate underlying `Owned_channel` or other channel-hosing error (including</span></div>
<div class="line"><a id="l00076" name="l00076"></a><span class="lineno">   76</span><span class="comment"> *     receiving graceful-close).  An error may synchronously occur right then, plus any `expect_*()`- and</span></div>
<div class="line"><a id="l00077" name="l00077"></a><span class="lineno">   77</span><span class="comment"> *     `async_request()`-triggered in-messages may be synchronously detected.  Therefore -- and this is quite</span></div>
<div class="line"><a id="l00078" name="l00078"></a><span class="lineno">   78</span><span class="comment"> *     rare (singular as of this writing in Flow-IPC):</span></div>
<div class="line"><a id="l00079" name="l00079"></a><span class="lineno">   79</span><span class="comment"> *     - `start_and_poll(F)` may *synchronously* (!) call a number of queued-up (in a sense) handlers including:</span></div>
<div class="line"><a id="l00080" name="l00080"></a><span class="lineno">   80</span><span class="comment"> *       - `expect_*()` handlers;</span></div>
<div class="line"><a id="l00081" name="l00081"></a><span class="lineno">   81</span><span class="comment"> *       - `async_request()` handlers;</span></div>
<div class="line"><a id="l00082" name="l00082"></a><span class="lineno">   82</span><span class="comment"> *       - `set_*unexpected_response_handler()` handlers;</span></div>
<div class="line"><a id="l00083" name="l00083"></a><span class="lineno">   83</span><span class="comment"> *       - on-error handler `F()` itself.</span></div>
<div class="line"><a id="l00084" name="l00084"></a><span class="lineno">   84</span><span class="comment"> *</span></div>
<div class="line"><a id="l00085" name="l00085"></a><span class="lineno">   85</span><span class="comment"> * Tip: If you&#39;d rather not worry about `start_and_poll()`-executed handlers -- except on-error handler which</span></div>
<div class="line"><a id="l00086" name="l00086"></a><span class="lineno">   86</span><span class="comment"> * might occur regardless -- then avoid calling `expect_*()`, async_request(), `set_*()` before</span></div>
<div class="line"><a id="l00087" name="l00087"></a><span class="lineno">   87</span><span class="comment"> * start_and_poll().  (No in-messages are ever dropped, so you won&#39;t &quot;miss&quot; something by registering an</span></div>
<div class="line"><a id="l00088" name="l00088"></a><span class="lineno">   88</span><span class="comment"> * expectation too late.)  That said there&#39;s nothing wrong per se with setting those things up before</span></div>
<div class="line"><a id="l00089" name="l00089"></a><span class="lineno">   89</span><span class="comment"> * start_and_poll() either.  Just be ready for the `_and_poll` part.</span></div>
<div class="line"><a id="l00090" name="l00090"></a><span class="lineno">   90</span><span class="comment"> *</span></div>
<div class="line"><a id="l00091" name="l00091"></a><span class="lineno">   91</span><span class="comment"> * @internal</span></div>
<div class="line"><a id="l00092" name="l00092"></a><span class="lineno">   92</span><span class="comment"> * ### Implementation overview ###</span></div>
<div class="line"><a id="l00093" name="l00093"></a><span class="lineno">   93</span><span class="comment"> * Like all `sync_io`-core object types, this one is essentially a linear state machine with no</span></div>
<div class="line"><a id="l00094" name="l00094"></a><span class="lineno">   94</span><span class="comment"> * actual asynchronicity or concurrency.  (Some `sync_io`s do need to start threads in order to perform</span></div>
<div class="line"><a id="l00095" name="l00095"></a><span class="lineno">   95</span><span class="comment"> * unavoidable blocking operations -- namely the `Blob_stream_mq_*` guys with at least the bipc MQ type which</span></div>
<div class="line"><a id="l00096" name="l00096"></a><span class="lineno">   96</span><span class="comment"> * lacks an FD-tickling API -- but this can be thought of similarly to a background kernel service.  Anyway</span></div>
<div class="line"><a id="l00097" name="l00097"></a><span class="lineno">   97</span><span class="comment"> * sync_io::Channel doesn&#39;t even feature that caveat.)</span></div>
<div class="line"><a id="l00098" name="l00098"></a><span class="lineno">   98</span><span class="comment"> *</span></div>
<div class="line"><a id="l00099" name="l00099"></a><span class="lineno">   99</span><span class="comment"> * So as with other `sync_io` cores, it&#39;s a linear sequence of API calls into `*this` that may not be</span></div>
<div class="line"><a id="l00100" name="l00100"></a><span class="lineno">  100</span><span class="comment"> * mutually concurrent (when non-`const`).  As with those others in this context an API call is either a</span></div>
<div class="line"><a id="l00101" name="l00101"></a><span class="lineno">  101</span><span class="comment"> * method call (duh) or an async-wait `Event_wait_func` calling into `*this` via `(*on_active_ev_func)()`.</span></div>
<div class="line"><a id="l00102" name="l00102"></a><span class="lineno">  102</span><span class="comment"> * Hence we don&#39;t care what thread a given thing runs in, as long as our user (e.g., transport::struc::Channel)</span></div>
<div class="line"><a id="l00103" name="l00103"></a><span class="lineno">  103</span><span class="comment"> * doesn&#39;t invoke things concurrently.</span></div>
<div class="line"><a id="l00104" name="l00104"></a><span class="lineno">  104</span><span class="comment"> *</span></div>
<div class="line"><a id="l00105" name="l00105"></a><span class="lineno">  105</span><span class="comment"> * So it&#39;s &quot;just&quot; a matter of implementing each direction -- outgoing (send() et al), incoming</span></div>
<div class="line"><a id="l00106" name="l00106"></a><span class="lineno">  106</span><span class="comment"> * (`expect_*()`, async_request()), and their (reasonably limited) interplay (e.g., async_request() conceptually =</span></div>
<div class="line"><a id="l00107" name="l00107"></a><span class="lineno">  107</span><span class="comment"> * a send() + registering expectation of particular future response in-message(s)).</span></div>
<div class="line"><a id="l00108" name="l00108"></a><span class="lineno">  108</span><span class="comment"> *</span></div>
<div class="line"><a id="l00109" name="l00109"></a><span class="lineno">  109</span><span class="comment"> * ### Implementation: layers ###</span></div>
<div class="line"><a id="l00110" name="l00110"></a><span class="lineno">  110</span><span class="comment"> * In the outgoing direction, the layers involved are fairly straightforward: send() is synchronous.  When it is</span></div>
<div class="line"><a id="l00111" name="l00111"></a><span class="lineno">  111</span><span class="comment"> * called, the zero-copy serialization of the structured out-message #Msg_out has been completed: the raw blobs</span></div>
<div class="line"><a id="l00112" name="l00112"></a><span class="lineno">  112</span><span class="comment"> * comprised by it are easily accessible from the #Msg_out (Msg_out::emit_serialization()) passed to send()</span></div>
<div class="line"><a id="l00113" name="l00113"></a><span class="lineno">  113</span><span class="comment"> * (as is the optional #Native_handle).  The 1+ blobs + the #Native_handle are synchronously `Channel::send_*()`ed,</span></div>
<div class="line"><a id="l00114" name="l00114"></a><span class="lineno">  114</span><span class="comment"> * and then send() returns.  In addition, but still synchronously within send(), each such user message is internally</span></div>
<div class="line"><a id="l00115" name="l00115"></a><span class="lineno">  115</span><span class="comment"> * accompanied by another similarly-serialized message: the *metadata* message.  This message, with a schema</span></div>
<div class="line"><a id="l00116" name="l00116"></a><span class="lineno">  116</span><span class="comment"> * in structured_msg.capnp (a detail/ file), represents a *description* of the associated #Msg_out.  Its schema</span></div>
<div class="line"><a id="l00117" name="l00117"></a><span class="lineno">  117</span><span class="comment"> * is controlled by us and is sufficiently small to require just one segment (blob) and no #Native_handle.</span></div>
<div class="line"><a id="l00118" name="l00118"></a><span class="lineno">  118</span><span class="comment"> * This contains information about the message (a/k/a metadata), notably: its message ID (discussed below),</span></div>
<div class="line"><a id="l00119" name="l00119"></a><span class="lineno">  119</span><span class="comment"> * the ID of the message to which it responds (or 0 if unsolicited), and the session token.</span></div>
<div class="line"><a id="l00120" name="l00120"></a><span class="lineno">  120</span><span class="comment"> * To summarize, then, send() of a user message in fact sends exactly 1 metadata message</span></div>
<div class="line"><a id="l00121" name="l00121"></a><span class="lineno">  121</span><span class="comment"> * (Msg_mdt_out, a special-purpose sub-class of Msg_out, adding no data members but a convenient</span></div>
<div class="line"><a id="l00122" name="l00122"></a><span class="lineno">  122</span><span class="comment"> * internally-used APIs to set its fields), across exactly 1 blob (segment), plus 1+ blobs (segments)</span></div>
<div class="line"><a id="l00123" name="l00123"></a><span class="lineno">  123</span><span class="comment"> * serializing the user message.  (async_request() = internally such a send() more or less, plus registering</span></div>
<div class="line"><a id="l00124" name="l00124"></a><span class="lineno">  124</span><span class="comment"> * that future in-message(s) with certain metadata content are expected.)</span></div>
<div class="line"><a id="l00125" name="l00125"></a><span class="lineno">  125</span><span class="comment"> *</span></div>
<div class="line"><a id="l00126" name="l00126"></a><span class="lineno">  126</span><span class="comment"> * Lastly, for some special purposes, we sometimes send internal messages.  An internal message consists of</span></div>
<div class="line"><a id="l00127" name="l00127"></a><span class="lineno">  127</span><span class="comment"> * *only* the metadata (Msg_mdt_out, alias #Msg_mdt_out), with the optional internal-message-body field</span></div>
<div class="line"><a id="l00128" name="l00128"></a><span class="lineno">  128</span><span class="comment"> * filled-out, and no user message.  Hence in this case exactly 1 `Blob` (segment) is sent.  In the few cases</span></div>
<div class="line"><a id="l00129" name="l00129"></a><span class="lineno">  129</span><span class="comment"> * where an internal message is required, internal code calls send_core() directly (with the #Msg_out arg</span></div>
<div class="line"><a id="l00130" name="l00130"></a><span class="lineno">  130</span><span class="comment"> * set to null); whereas a user message goes through send() or async_request() which invokes send_core()</span></div>
<div class="line"><a id="l00131" name="l00131"></a><span class="lineno">  131</span><span class="comment"> * (with #Msg_out arg non-null but rather the user-supplied #Msg_out).</span></div>
<div class="line"><a id="l00132" name="l00132"></a><span class="lineno">  132</span><span class="comment"> *</span></div>
<div class="line"><a id="l00133" name="l00133"></a><span class="lineno">  133</span><span class="comment"> * In the incoming direction, it is much more complex.  Receiving a blob, or blob+handle pair, is by definition</span></div>
<div class="line"><a id="l00134" name="l00134"></a><span class="lineno">  134</span><span class="comment"> * a (potentially) asynchronous operation; and a given structured in-message may consist of more than 1 blob/blob+handle</span></div>
<div class="line"><a id="l00135" name="l00135"></a><span class="lineno">  135</span><span class="comment"> * pair.  The zero-copy deserialization invoked by the user can only occur once all of them are received, so</span></div>
<div class="line"><a id="l00136" name="l00136"></a><span class="lineno">  136</span><span class="comment"> * we must build up 1 given structured in-message over 1+ async-read ops and only emit the result</span></div>
<div class="line"><a id="l00137" name="l00137"></a><span class="lineno">  137</span><span class="comment"> * (a newly allocated/cted Msg_in a/k/a #Msg_in_ptr) to the user once the last of the 1+ async-read ops</span></div>
<div class="line"><a id="l00138" name="l00138"></a><span class="lineno">  138</span><span class="comment"> * finishes.  So that&#39;s 2 layers: async-read op at the #Owned_channel level; then the structured level once a</span></div>
<div class="line"><a id="l00139" name="l00139"></a><span class="lineno">  139</span><span class="comment"> * Msg_in is ready.  Msg_in represents, conceptually, a pointer to 1-2 serialized</span></div>
<div class="line"><a id="l00140" name="l00140"></a><span class="lineno">  140</span><span class="comment"> * in-messages: the metadata in-message (always present) and, except for internal messages, the user-supplied</span></div>
<div class="line"><a id="l00141" name="l00141"></a><span class="lineno">  141</span><span class="comment"> * in-message (supplied originally via #Msg_out).  However, to the user, only the latter is accessible,</span></div>
<div class="line"><a id="l00142" name="l00142"></a><span class="lineno">  142</span><span class="comment"> * and an internal message is by definition never emitted to the user (if it were, there would be nothing for them</span></div>
<div class="line"><a id="l00143" name="l00143"></a><span class="lineno">  143</span><span class="comment"> * to access).</span></div>
<div class="line"><a id="l00144" name="l00144"></a><span class="lineno">  144</span><span class="comment"> *</span></div>
<div class="line"><a id="l00145" name="l00145"></a><span class="lineno">  145</span><span class="comment"> * The preceding paragraph talks only of *one* Channel pipe.  It is possible #Owned_channel contains 2 pipes</span></div>
<div class="line"><a id="l00146" name="l00146"></a><span class="lineno">  146</span><span class="comment"> * (Channel::S_HAS_2_PIPES), operating potentially in parallel.  (This may be useful for perf; discussion omitted</span></div>
<div class="line"><a id="l00147" name="l00147"></a><span class="lineno">  147</span><span class="comment"> * here.)  Naturally this creates the possibility of reordering of in-messages.  Hence, optionally, there is</span></div>
<div class="line"><a id="l00148" name="l00148"></a><span class="lineno">  148</span><span class="comment"> * another layer between completing a Msg_in (#Msg_in_ptr) and emitting it: a simple reassembly queue.</span></div>
<div class="line"><a id="l00149" name="l00149"></a><span class="lineno">  149</span><span class="comment"> * To make this work: each in-message (hence each out-message instance) is supplied with a unique message ID</span></div>
<div class="line"><a id="l00150" name="l00150"></a><span class="lineno">  150</span><span class="comment"> * (required anyway for, at least, request-response correlation); and that message ID doubles as a *sequence #*</span></div>
<div class="line"><a id="l00151" name="l00151"></a><span class="lineno">  151</span><span class="comment"> * (1, 2, ...).  #Reassembly_q is a reassembly queue that is (probably infrequently) used to temporarily</span></div>
<div class="line"><a id="l00152" name="l00152"></a><span class="lineno">  152</span><span class="comment"> * store out-of-order structured in-messages, flushing them once the gap between last-emitted-to-next-layer</span></div>
<div class="line"><a id="l00153" name="l00153"></a><span class="lineno">  153</span><span class="comment"> * in-message-sequence-# and lowest-in-message-sequence-#-in-reassembly-queue is filled.</span></div>
<div class="line"><a id="l00154" name="l00154"></a><span class="lineno">  154</span><span class="comment"> *</span></div>
<div class="line"><a id="l00155" name="l00155"></a><span class="lineno">  155</span><span class="comment"> * Okay; let&#39;s assume an in-message has gone through the above 2-3 layers (Channel layer, (optional) reassembly</span></div>
<div class="line"><a id="l00156" name="l00156"></a><span class="lineno">  156</span><span class="comment"> * queue layer, Msg_in completion layer).  Can we finally emit it to the user?  Often yes... but generally</span></div>
<div class="line"><a id="l00157" name="l00157"></a><span class="lineno">  157</span><span class="comment"> * no:</span></div>
<div class="line"><a id="l00158" name="l00158"></a><span class="lineno">  158</span><span class="comment"> *</span></div>
<div class="line"><a id="l00159" name="l00159"></a><span class="lineno">  159</span><span class="comment"> * In the incoming-direction, we add *notification* and *response* expectation APIs (these are</span></div>
<div class="line"><a id="l00160" name="l00160"></a><span class="lineno">  160</span><span class="comment"> * mandatory before the `*this` user receives an emitted in-message via handler).  This adds a further layer</span></div>
<div class="line"><a id="l00161" name="l00161"></a><span class="lineno">  161</span><span class="comment"> * of processing.  Once a Msg_in (#Msg_in_ptr) is assembled and ready to deserialize, one of 2 things</span></div>
<div class="line"><a id="l00162" name="l00162"></a><span class="lineno">  162</span><span class="comment"> * happens: either an expect_msg() or async_request() has registered a handler for this in-message -- then it</span></div>
<div class="line"><a id="l00163" name="l00163"></a><span class="lineno">  163</span><span class="comment"> * is immediately emitted to that handler (done!); or not -- then it is stored inside `*this`.  (Once a handler</span></div>
<div class="line"><a id="l00164" name="l00164"></a><span class="lineno">  164</span><span class="comment"> * is *subsequently* registered, the appropriate stored in-messages shall be emitted via synchronous out-args</span></div>
<div class="line"><a id="l00165" name="l00165"></a><span class="lineno">  165</span><span class="comment"> * such as `qd_msgs` for expect_msgs().)</span></div>
<div class="line"><a id="l00166" name="l00166"></a><span class="lineno">  166</span><span class="comment"> *</span></div>
<div class="line"><a id="l00167" name="l00167"></a><span class="lineno">  167</span><span class="comment"> * That&#39;s the overview.  Various doc headers on `private` types and/or data members should fill in the details.</span></div>
<div class="line"><a id="l00168" name="l00168"></a><span class="lineno">  168</span><span class="comment"> *</span></div>
<div class="line"><a id="l00169" name="l00169"></a><span class="lineno">  169</span><span class="comment"> * ### Protocol negotiation ###</span></div>
<div class="line"><a id="l00170" name="l00170"></a><span class="lineno">  170</span><span class="comment"> * A good place to familiarize oneself with this topic is a similar section in the doc header of a core-layer</span></div>
<div class="line"><a id="l00171" name="l00171"></a><span class="lineno">  171</span><span class="comment"> * (lower level) facility; sync_io::Native_socket_stream::Impl is probably best, but sync_io::Blob_stream_mq_sender_impl</span></div>
<div class="line"><a id="l00172" name="l00172"></a><span class="lineno">  172</span><span class="comment"> * and sync_io::Blob_stream_mq_receiver_impl are similar (albeit split up, because an MQ is unidirectional).</span></div>
<div class="line"><a id="l00173" name="l00173"></a><span class="lineno">  173</span><span class="comment"> * We urge you to be comfortable with that before reading on, as a certain facility with the subject matter is</span></div>
<div class="line"><a id="l00174" name="l00174"></a><span class="lineno">  174</span><span class="comment"> * needed for the following discussion.</span></div>
<div class="line"><a id="l00175" name="l00175"></a><span class="lineno">  175</span><span class="comment"> *</span></div>
<div class="line"><a id="l00176" name="l00176"></a><span class="lineno">  176</span><span class="comment"> * Consider the big picture: transport::Channel (unstructured), over which a `*this` operates, is composed of those</span></div>
<div class="line"><a id="l00177" name="l00177"></a><span class="lineno">  177</span><span class="comment"> * lower-level transports, namely Blob_sender, Blob_receiver, etc., impls bundled in a certain way.  We sit at the</span></div>
<div class="line"><a id="l00178" name="l00178"></a><span class="lineno">  178</span><span class="comment"> * next-higher layer (structured layer).  We operate a protocol (multiple cooperating protocols actually) on top</span></div>
<div class="line"><a id="l00179" name="l00179"></a><span class="lineno">  179</span><span class="comment"> * of the protocol(s) at that unstructured layer, and that protocol can evolve (gain versions) over time too.</span></div>
<div class="line"><a id="l00180" name="l00180"></a><span class="lineno">  180</span><span class="comment"> * The question is how to arrange forward-compatible (in some sense) protocol negotiation at this higher layer.</span></div>
<div class="line"><a id="l00181" name="l00181"></a><span class="lineno">  181</span><span class="comment"> *</span></div>
<div class="line"><a id="l00182" name="l00182"></a><span class="lineno">  182</span><span class="comment"> * One approach would be to not add independent protocol versioning/negotiation at our layer at all and simply rely</span></div>
<div class="line"><a id="l00183" name="l00183"></a><span class="lineno">  183</span><span class="comment"> * on that work done already at the aforementioned unstructured (lower) layer.  Certainly that would mean less code</span></div>
<div class="line"><a id="l00184" name="l00184"></a><span class="lineno">  184</span><span class="comment"> * for us and a bit of perf/reponsiveness gain from not adding more negotiation traffic (that part not being super</span></div>
<div class="line"><a id="l00185" name="l00185"></a><span class="lineno">  185</span><span class="comment"> * significant, as this is all only at the start of a channel&#39;s lifetime).  The negative shows up in the scenario</span></div>
<div class="line"><a id="l00186" name="l00186"></a><span class="lineno">  186</span><span class="comment"> * where the low-level protocol needs no change, but our higher-level protocol does.  Now we have to bump up the</span></div>
<div class="line"><a id="l00187" name="l00187"></a><span class="lineno">  187</span><span class="comment"> * version for the lower layer, explaining this is only to support differences at unrelated higher layers.</span></div>
<div class="line"><a id="l00188" name="l00188"></a><span class="lineno">  188</span><span class="comment"> * (Formally speaking the lower-layer APIs can be used without as at all, and there are surely use cases for that.)</span></div>
<div class="line"><a id="l00189" name="l00189"></a><span class="lineno">  189</span><span class="comment"> * Moreover -- we don&#39;t often talk about this outside the top-level common.hpp -- but the `ipc_core` module</span></div>
<div class="line"><a id="l00190" name="l00190"></a><span class="lineno">  190</span><span class="comment"> * is (as of this writing) a separate library from ours, `ipc_transport_structured`; so one would need to change the</span></div>
<div class="line"><a id="l00191" name="l00191"></a><span class="lineno">  191</span><span class="comment"> * code in a different library, release it, etc., despite no other behavior changes in that library.  That&#39;s not great.</span></div>
<div class="line"><a id="l00192" name="l00192"></a><span class="lineno">  192</span><span class="comment"> *</span></div>
<div class="line"><a id="l00193" name="l00193"></a><span class="lineno">  193</span><span class="comment"> * So we&#39;ve decided to keep it clean (if more complex and involving more code and designing) and have each layer do its</span></div>
<div class="line"><a id="l00194" name="l00194"></a><span class="lineno">  194</span><span class="comment"> * own negotiation.</span></div>
<div class="line"><a id="l00195" name="l00195"></a><span class="lineno">  195</span><span class="comment"> *</span></div>
<div class="line"><a id="l00196" name="l00196"></a><span class="lineno">  196</span><span class="comment"> * Well, no problem.  Having read about this as recommended above, you&#39;ll know it&#39;s just a matter of keeping a</span></div>
<div class="line"><a id="l00197" name="l00197"></a><span class="lineno">  197</span><span class="comment"> * Protocol_negotiator object in a `*this` and sending and receiving a message/payload before any other message/payload.</span></div>
<div class="line"><a id="l00198" name="l00198"></a><span class="lineno">  198</span><span class="comment"> * As of this writing there *is* only the initial version of the protocol (1), so we don&#39;t yet need to worry about</span></div>
<div class="line"><a id="l00199" name="l00199"></a><span class="lineno">  199</span><span class="comment"> * potential backward-compatibility/knowing which version to actually speak from a range of 2 or more; etc.</span></div>
<div class="line"><a id="l00200" name="l00200"></a><span class="lineno">  200</span><span class="comment"> *</span></div>
<div class="line"><a id="l00201" name="l00201"></a><span class="lineno">  201</span><span class="comment"> * That said, the challenge here is more subtle than that.  Sure, we can negotiate *a* version at this layer, no</span></div>
<div class="line"><a id="l00202" name="l00202"></a><span class="lineno">  202</span><span class="comment"> * problem.  The problem: there are *multiple* protocols operating at this layer.  There are at least two:</span></div>
<div class="line"><a id="l00203" name="l00203"></a><span class="lineno">  203</span><span class="comment"> *   -# How do blob/handle pairs transmitted over the transport::Channel translated into structured capnp messages?</span></div>
<div class="line"><a id="l00204" name="l00204"></a><span class="lineno">  204</span><span class="comment"> *      This even depends on template params `Struct_builder_config` and `Struct_reader_config`: As of this writing</span></div>
<div class="line"><a id="l00205" name="l00205"></a><span class="lineno">  205</span><span class="comment"> *      there are at least:</span></div>
<div class="line"><a id="l00206" name="l00206"></a><span class="lineno">  206</span><span class="comment"> *      - Heap_fixed_builder + Heap_reader: Heap-based arrangement, wherein all messages are transmitted directly</span></div>
<div class="line"><a id="l00207" name="l00207"></a><span class="lineno">  207</span><span class="comment"> *        (via copy) as blobs going through the unstructured `Channel`: The lead message blob is a capnp</span></div>
<div class="line"><a id="l00208" name="l00208"></a><span class="lineno">  208</span><span class="comment"> *        `struct StructuredMessage`, potentially followed by N (where N &gt;= 1 and is communicated via</span></div>
<div class="line"><a id="l00209" name="l00209"></a><span class="lineno">  209</span><span class="comment"> *        that `StructuredMessage`) blobs, each representing a capnp-segment, those segments together making up</span></div>
<div class="line"><a id="l00210" name="l00210"></a><span class="lineno">  210</span><span class="comment"> *        a user message&#39;s serialization.</span></div>
<div class="line"><a id="l00211" name="l00211"></a><span class="lineno">  211</span><span class="comment"> *      - shm::Builder + shm::Reader: SHM-based arrangement, wherein all messages are transmitted</span></div>
<div class="line"><a id="l00212" name="l00212"></a><span class="lineno">  212</span><span class="comment"> *        as tiny SHM-handle-only-storing blobs, and then on the receiving side each such SHM-handle is taken</span></div>
<div class="line"><a id="l00213" name="l00213"></a><span class="lineno">  213</span><span class="comment"> *        to point to a list-of-capnp-segments (living in SHM), those segments together making up a</span></div>
<div class="line"><a id="l00214" name="l00214"></a><span class="lineno">  214</span><span class="comment"> *        user message&#39;s serialization.  (Hence end-to-end zero-copy, only the SHM-handles actually transmitted</span></div>
<div class="line"><a id="l00215" name="l00215"></a><span class="lineno">  215</span><span class="comment"> *        via the underlying unstructured `Channel`.)</span></div>
<div class="line"><a id="l00216" name="l00216"></a><span class="lineno">  216</span><span class="comment"> *   -# The capnp messages aren&#39;t just user messages either; internally we have internal messages and, more</span></div>
<div class="line"><a id="l00217" name="l00217"></a><span class="lineno">  217</span><span class="comment"> *      more importantly, the metadata-bearing leading messages containing key stuff like the message ID,</span></div>
<div class="line"><a id="l00218" name="l00218"></a><span class="lineno">  218</span><span class="comment"> *      notification/response info, etc.  The (internally used) schema in structured_msg.capnp is a protocol;</span></div>
<div class="line"><a id="l00219" name="l00219"></a><span class="lineno">  219</span><span class="comment"> *      certainly it could change over time: E.g., more types of internal messages might be added.</span></div>
<div class="line"><a id="l00220" name="l00220"></a><span class="lineno">  220</span><span class="comment"> *</span></div>
<div class="line"><a id="l00221" name="l00221"></a><span class="lineno">  221</span><span class="comment"> * This implementation is (we hope) thoughfully layered, but the question of where exactly lies the separation</span></div>
<div class="line"><a id="l00222" name="l00222"></a><span class="lineno">  222</span><span class="comment"> * between various protocols is a tough one.  These aren&#39;t just &quot;wire protocols&quot; anymore; there&#39;s a programmatic</span></div>
<div class="line"><a id="l00223" name="l00223"></a><span class="lineno">  223</span><span class="comment"> * element to it involving the Struct_builder and Struct_reader concepts.  So should there be a separate</span></div>
<div class="line"><a id="l00224" name="l00224"></a><span class="lineno">  224</span><span class="comment"> * negotiation/version for each of these protocols?  Which protocols, even?  How would this work?</span></div>
<div class="line"><a id="l00225" name="l00225"></a><span class="lineno">  225</span><span class="comment"> *</span></div>
<div class="line"><a id="l00226" name="l00226"></a><span class="lineno">  226</span><span class="comment"> * That&#39;s probably the wrong question, we think.  Let&#39;s instead be pragmatic.  Firstly, as of this writing, there *is*</span></div>
<div class="line"><a id="l00227" name="l00227"></a><span class="lineno">  227</span><span class="comment"> * only version 1 of everything; so it&#39;s all moot, until more versions pop up.  So all we&#39;re trying to do here is</span></div>
<div class="line"><a id="l00228" name="l00228"></a><span class="lineno">  228</span><span class="comment"> * not &quot;shoot ourselves in the foot&quot;: Provide some kind of negotiation protocol &quot;base&quot; that all future versions of</span></div>
<div class="line"><a id="l00229" name="l00229"></a><span class="lineno">  229</span><span class="comment"> * the software can count on safely (in the same way we did for the lowest layer).  So, really, what we want here</span></div>
<div class="line"><a id="l00230" name="l00230"></a><span class="lineno">  230</span><span class="comment"> * is to have *enough separate protocol versions to negotiate* to be reasonably future-proof, so that future software</span></div>
<div class="line"><a id="l00231" name="l00231"></a><span class="lineno">  231</span><span class="comment"> * won&#39;t need component X to be changed even though a protocol in component Y is the one that is changing.  So,</span></div>
<div class="line"><a id="l00232" name="l00232"></a><span class="lineno">  232</span><span class="comment"> * pragmatically, speaking:</span></div>
<div class="line"><a id="l00233" name="l00233"></a><span class="lineno">  233</span><span class="comment"> *   - We know that just *one* Protocol_negotiator at the struc::sync_io::Channel layer is *sufficient*: In the worst</span></div>
<div class="line"><a id="l00234" name="l00234"></a><span class="lineno">  234</span><span class="comment"> *     case the version in it will need to be bumped up without struc::sync_io::Channel code otherwise needing it, but</span></div>
<div class="line"><a id="l00235" name="l00235"></a><span class="lineno">  235</span><span class="comment"> *     on account of something outside that class needing a protocol change (e.g., if shm::Builder + shm::Reader encode</span></div>
<div class="line"><a id="l00236" name="l00236"></a><span class="lineno">  236</span><span class="comment"> *     SHM stuff differently in the future).  So any other `Protocol_negotiator`s we add around here are gravy.</span></div>
<div class="line"><a id="l00237" name="l00237"></a><span class="lineno">  237</span><span class="comment"> *   - Exchanging more version numbers (via more `Protocol_negotiator`s) at the same time is nice and efficient and</span></div>
<div class="line"><a id="l00238" name="l00238"></a><span class="lineno">  238</span><span class="comment"> *     simple, if indeed we do want the aforementioned &quot;gravy.&quot;  We just need to identify likely candidates for</span></div>
<div class="line"><a id="l00239" name="l00239"></a><span class="lineno">  239</span><span class="comment"> *     future protocol changes.  However many such versions we&#39;ll decide upon, we can have those Protocol_negotiator</span></div>
<div class="line"><a id="l00240" name="l00240"></a><span class="lineno">  240</span><span class="comment"> *     members (at least 1; more for the &quot;gravy&quot;) inside `*this`, and we can compactly exchange these in a leading</span></div>
<div class="line"><a id="l00241" name="l00241"></a><span class="lineno">  241</span><span class="comment"> *     message sent in either direction.  E.g., if there are 3 `Protocol_negotiator`s, we&#39;ll send 3 versions</span></div>
<div class="line"><a id="l00242" name="l00242"></a><span class="lineno">  242</span><span class="comment"> *     (as of this writing `1`, `1`, `1`) and expect 3 versions to be received similarly.  (As usual, on receipt,</span></div>
<div class="line"><a id="l00243" name="l00243"></a><span class="lineno">  243</span><span class="comment"> *     each Protocol_negotiator::compute_negotiated_proto_ver() will determine the version to speak -- as of this</span></div>
<div class="line"><a id="l00244" name="l00244"></a><span class="lineno">  244</span><span class="comment"> *     writing either 1, or *explode the channel due to negotiation failure*.)</span></div>
<div class="line"><a id="l00245" name="l00245"></a><span class="lineno">  245</span><span class="comment"> *   - To identify the likely candidates, we should think of it in terms of pieces of software/modules that would</span></div>
<div class="line"><a id="l00246" name="l00246"></a><span class="lineno">  246</span><span class="comment"> *     change -- as opposed to the highly subjective notion of which things constitute separate protocols.</span></div>
<div class="line"><a id="l00247" name="l00247"></a><span class="lineno">  247</span><span class="comment"> *     This is really not so daunting:</span></div>
<div class="line"><a id="l00248" name="l00248"></a><span class="lineno">  248</span><span class="comment"> *     - There is *us*: struc::sync_io::Channel, and the satellite code, especially structured_msg.capnp.</span></div>
<div class="line"><a id="l00249" name="l00249"></a><span class="lineno">  249</span><span class="comment"> *       This covers a ton of stuff/logic/concepts/terminology; really everything up to but not including the</span></div>
<div class="line"><a id="l00250" name="l00250"></a><span class="lineno">  250</span><span class="comment"> *       zero-copy/SHM layer(s) *potentially* also involved.</span></div>
<div class="line"><a id="l00251" name="l00251"></a><span class="lineno">  251</span><span class="comment"> *       - It *does* include Heap_fixed_builder and Heap_reader.  Sure, they&#39;re &quot;merely&quot; impls of the concepts</span></div>
<div class="line"><a id="l00252" name="l00252"></a><span class="lineno">  252</span><span class="comment"> *         Struct_builder and Struct_reader, respectively, but those heap-based impls (1) live in our same namespace</span></div>
<div class="line"><a id="l00253" name="l00253"></a><span class="lineno">  253</span><span class="comment"> *         ipc::transport::struc and in the same module/library `ipc_transport_structured`; and (2) in practice</span></div>
<div class="line"><a id="l00254" name="l00254"></a><span class="lineno">  254</span><span class="comment"> *         are essentially-necessary building blocks for any zero-copy-based `Struct_*er`s including</span></div>
<div class="line"><a id="l00255" name="l00255"></a><span class="lineno">  255</span><span class="comment"> *         shm::Builder and shm::Reader.  That is to say, there is no point in having some kind of separate version</span></div>
<div class="line"><a id="l00256" name="l00256"></a><span class="lineno">  256</span><span class="comment"> *         for struc::sync_io::Channel and co., versus `struc::Heap_*er`.</span></div>
<div class="line"><a id="l00257" name="l00257"></a><span class="lineno">  257</span><span class="comment"> *     - There is our sub-namespace, transport::struc::shm -- especially shm::Builder and shm::Reader: this protocol</span></div>
<div class="line"><a id="l00258" name="l00258"></a><span class="lineno">  258</span><span class="comment"> *       determines how SHM handles are encoded inside the unstructured blobs transmitted via unstructured `Channel`,</span></div>
<div class="line"><a id="l00259" name="l00259"></a><span class="lineno">  259</span><span class="comment"> *       and how they are then interpreted as capnp messages (whether internal or user ones).</span></div>
<div class="line"><a id="l00260" name="l00260"></a><span class="lineno">  260</span><span class="comment"> *       - Formally speaking, though, all that is determined at compile time via `Struct_*er_config` template params</span></div>
<div class="line"><a id="l00261" name="l00261"></a><span class="lineno">  261</span><span class="comment"> *         to `*this`.  As of this writing those are likely to just be either vanilla `&quot;Heap_*er::Config&quot;`, or</span></div>
<div class="line"><a id="l00262" name="l00262"></a><span class="lineno">  262</span><span class="comment"> *         shm::Builder::Config + shm::Reader::Config; but formally any Struct_builder / Struct_reader concept impls</span></div>
<div class="line"><a id="l00263" name="l00263"></a><span class="lineno">  263</span><span class="comment"> *         are allowed.  (The user may well implement their own fanciness.)</span></div>
<div class="line"><a id="l00264" name="l00264"></a><span class="lineno">  264</span><span class="comment"> *       - So really it&#39;s not about transport::struc::shm specifically but more like, formally speaking,</span></div>
<div class="line"><a id="l00265" name="l00265"></a><span class="lineno">  265</span><span class="comment"> *         `Struct_builder_config` + `Struct_reader_config` protocol code, excluding the base/vanilla</span></div>
<div class="line"><a id="l00266" name="l00266"></a><span class="lineno">  266</span><span class="comment"> *         Heap_fixed_builder and Heap_reader (which, we&#39;ve established, are already covered by the first, non-gravy</span></div>
<div class="line"><a id="l00267" name="l00267"></a><span class="lineno">  267</span><span class="comment"> *         Protocol_negotiator).</span></div>
<div class="line"><a id="l00268" name="l00268"></a><span class="lineno">  268</span><span class="comment"> *</span></div>
<div class="line"><a id="l00269" name="l00269"></a><span class="lineno">  269</span><span class="comment"> * Thus it should be sufficient to have:</span></div>
<div class="line"><a id="l00270" name="l00270"></a><span class="lineno">  270</span><span class="comment"> *   - Protocol_negotiator for us.  That is #m_protocol_negotiator.</span></div>
<div class="line"><a id="l00271" name="l00271"></a><span class="lineno">  271</span><span class="comment"> *   - (Possibly unused) Protocol_negotiator for any additional protocol(s) involved in `Struct_*er_config` layer,</span></div>
<div class="line"><a id="l00272" name="l00272"></a><span class="lineno">  272</span><span class="comment"> *     such as the existing shm::Builder and shm::Reader.  That is #m_protocol_negotiator_aux.</span></div>
<div class="line"><a id="l00273" name="l00273"></a><span class="lineno">  273</span><span class="comment"> *     The actual preferred (highest) and lowest-supported Protocol_negotiator::proto_ver_t values shall</span></div>
<div class="line"><a id="l00274" name="l00274"></a><span class="lineno">  274</span><span class="comment"> *     as of this writing simply be 1; but once that changes we&#39;ll likely add some `static constexpr` values</span></div>
<div class="line"><a id="l00275" name="l00275"></a><span class="lineno">  275</span><span class="comment"> *     in Struct_builder and Struct_reader concepts (and impls), and `*this` will pass those to Protocol_negotiator</span></div>
<div class="line"><a id="l00276" name="l00276"></a><span class="lineno">  276</span><span class="comment"> *     ctor (instead of simply passing `1`s).</span></div>
<div class="line"><a id="l00277" name="l00277"></a><span class="lineno">  277</span><span class="comment"> *     - (Depending on whether the hypothetical multi-version protocol(s) support backwards-compatibility with</span></div>
<div class="line"><a id="l00278" name="l00278"></a><span class="lineno">  278</span><span class="comment"> *       earlier protocol-versions (i.e., a given version range is not [V, V]), we might need more logic/APIs,</span></div>
<div class="line"><a id="l00279" name="l00279"></a><span class="lineno">  279</span><span class="comment"> *       so that a given module knows which protocol-version to in fact speak.  To reiterate, currently, we need not</span></div>
<div class="line"><a id="l00280" name="l00280"></a><span class="lineno">  280</span><span class="comment"> *       worry about it: just don&#39;t shoot selves in foot in this version 1 of everything.)</span></div>
<div class="line"><a id="l00281" name="l00281"></a><span class="lineno">  281</span><span class="comment"> *</span></div>
<div class="line"><a id="l00282" name="l00282"></a><span class="lineno">  282</span><span class="comment"> * Of course even *more* protocols may be involved inside `Struct_*er_config` layer; as of this writing there isn&#39;t --</span></div>
<div class="line"><a id="l00283" name="l00283"></a><span class="lineno">  283</span><span class="comment"> * it&#39;s just shm::Builder and shm::Reader in practice -- but there can be other `Struct_*er` concept impls which</span></div>
<div class="line"><a id="l00284" name="l00284"></a><span class="lineno">  284</span><span class="comment"> * could be arbitrarily complex.  However, we needn&#39;t invent some complicated ultra-dynamic/future-proof thing to cover</span></div>
<div class="line"><a id="l00285" name="l00285"></a><span class="lineno">  285</span><span class="comment"> * those possibilities: if it comes down to it, more protocol negotiation can be coded within those protocols themselves</span></div>
<div class="line"><a id="l00286" name="l00286"></a><span class="lineno">  286</span><span class="comment"> * as needed, or one can just bump up the #m_protocol_negotiator_aux version to cover all protocol changes at that</span></div>
<div class="line"><a id="l00287" name="l00287"></a><span class="lineno">  287</span><span class="comment"> * layer.</span></div>
<div class="line"><a id="l00288" name="l00288"></a><span class="lineno">  288</span><span class="comment"> *</span></div>
<div class="line"><a id="l00289" name="l00289"></a><span class="lineno">  289</span><span class="comment"> * That brings us to the mechanics of actually exchanging the highest-protocol-version for each of</span></div>
<div class="line"><a id="l00290" name="l00290"></a><span class="lineno">  290</span><span class="comment"> * #m_protocol_negotiator and #m_protocol_negotiator_aux.  We choose to use a very simple and small</span></div>
<div class="line"><a id="l00291" name="l00291"></a><span class="lineno">  291</span><span class="comment"> * capnp-backed (see `struct ProtocolNegotiation` in structured_msg.capnp) blob sent before any other out-messages</span></div>
<div class="line"><a id="l00292" name="l00292"></a><span class="lineno">  292</span><span class="comment"> * (and therefore expected before any in-messages).  Following the lead of the lower levels:</span></div>
<div class="line"><a id="l00293" name="l00293"></a><span class="lineno">  293</span><span class="comment"> *   - Outgoing: ASAP (so start_ops()), `.send_blob/native_handle()` the `ProtocolNegotiation`-storing blob.  The</span></div>
<div class="line"><a id="l00294" name="l00294"></a><span class="lineno">  294</span><span class="comment"> *     `.send*()`s are all non-blocking and synchronous, so that&#39;s simple.</span></div>
<div class="line"><a id="l00295" name="l00295"></a><span class="lineno">  295</span><span class="comment"> *   - Incoming: Just before invoking the first receive API (`.async_receive_blob()`, `.async_receive_native_handle()`)</span></div>
<div class="line"><a id="l00296" name="l00296"></a><span class="lineno">  296</span><span class="comment"> *     -- which occurs in start_and_poll() -- on #m_channel, `.async_receive_blob()` the `ProtocolNegotiation`-storing</span></div>
<div class="line"><a id="l00297" name="l00297"></a><span class="lineno">  297</span><span class="comment"> *     blob.  Only proceed with the first &quot;real&quot; receive on successful async-receive of the</span></div>
<div class="line"><a id="l00298" name="l00298"></a><span class="lineno">  298</span><span class="comment"> *     `ProtocolNegotiation`-storing blob.  (Note: all this begins in start_and_poll().)</span></div>
<div class="line"><a id="l00299" name="l00299"></a><span class="lineno">  299</span><span class="comment"> *</span></div>
<div class="line"><a id="l00300" name="l00300"></a><span class="lineno">  300</span><span class="comment"> * There is one slight complication there: underlying #Owned_channel might have 2 pipes (at compile-time), one for</span></div>
<div class="line"><a id="l00301" name="l00301"></a><span class="lineno">  301</span><span class="comment"> * native-handle-bearing messages, one for the converse.  The unlikely-but-possible racing of messages being sent</span></div>
<div class="line"><a id="l00302" name="l00302"></a><span class="lineno">  302</span><span class="comment"> * over 2 pipes in ~parallel is normally resolved via message IDs (sequence numbers), but of course we don&#39;t want to</span></div>
<div class="line"><a id="l00303" name="l00303"></a><span class="lineno">  303</span><span class="comment"> * include these trivial negotiating leading messages in that mechanism.  So: we simply send (and expect)</span></div>
<div class="line"><a id="l00304" name="l00304"></a><span class="lineno">  304</span><span class="comment"> * the negotiation message along *each* pipe, before any others in that pipe.  Chronologically speaking, then, the 1st</span></div>
<div class="line"><a id="l00305" name="l00305"></a><span class="lineno">  305</span><span class="comment"> * negotiation-in-message to be received is processed; the other ignored (and trusted to be duplicate of the winner).</span></div>
<div class="line"><a id="l00306" name="l00306"></a><span class="lineno">  306</span><span class="comment"> * There&#39;s a bit of negligible overhead, but the important thing is that no &quot;real&quot; messages are processed before</span></div>
<div class="line"><a id="l00307" name="l00307"></a><span class="lineno">  307</span><span class="comment"> * protocol-negotiation phase passes.</span></div>
<div class="line"><a id="l00308" name="l00308"></a><span class="lineno">  308</span><span class="comment"> *</span></div>
<div class="line"><a id="l00309" name="l00309"></a><span class="lineno">  309</span><span class="comment"> * @endinternal</span></div>
<div class="line"><a id="l00310" name="l00310"></a><span class="lineno">  310</span><span class="comment"> *</span></div>
<div class="line"><a id="l00311" name="l00311"></a><span class="lineno">  311</span><span class="comment"> * @tparam Channel_obj</span></div>
<div class="line"><a id="l00312" name="l00312"></a><span class="lineno">  312</span><span class="comment"> *         See #Async_io_obj doc header.</span></div>
<div class="line"><a id="l00313" name="l00313"></a><span class="lineno">  313</span><span class="comment"> * @tparam Message_body</span></div>
<div class="line"><a id="l00314" name="l00314"></a><span class="lineno">  314</span><span class="comment"> *         See #Async_io_obj doc header.</span></div>
<div class="line"><a id="l00315" name="l00315"></a><span class="lineno">  315</span><span class="comment"> * @tparam Struct_builder_config</span></div>
<div class="line"><a id="l00316" name="l00316"></a><span class="lineno">  316</span><span class="comment"> *         See #Async_io_obj doc header.</span></div>
<div class="line"><a id="l00317" name="l00317"></a><span class="lineno">  317</span><span class="comment"> * @tparam Struct_reader_config</span></div>
<div class="line"><a id="l00318" name="l00318"></a><span class="lineno">  318</span><span class="comment"> *         See #Async_io_obj doc header.</span></div>
<div class="line"><a id="l00319" name="l00319"></a><span class="lineno">  319</span><span class="comment"> */</span></div>
<div class="line"><a id="l00320" name="l00320"></a><span class="lineno">  320</span><span class="keyword">template</span>&lt;<span class="keyword">typename</span> Channel_obj, <span class="keyword">typename</span> Message_body,</div>
<div class="line"><a id="l00321" name="l00321"></a><span class="lineno">  321</span>         <span class="keyword">typename</span> Struct_builder_config, <span class="keyword">typename</span> Struct_reader_config&gt;</div>
<div class="line"><a id="l00322" name="l00322"></a><span class="lineno"><a class="line" href="classipc_1_1transport_1_1struc_1_1sync__io_1_1Channel.html">  322</a></span><span class="keyword">class </span><a class="code hl_class" href="classipc_1_1transport_1_1struc_1_1sync__io_1_1Channel.html">Channel</a> :</div>
<div class="line"><a id="l00323" name="l00323"></a><span class="lineno">  323</span>  <span class="keyword">public</span> <a class="code hl_class" href="classipc_1_1transport_1_1struc_1_1Channel__base.html">Channel_base</a>,</div>
<div class="line"><a id="l00324" name="l00324"></a><span class="lineno">  324</span>  <span class="keyword">private</span> boost::noncopyable,</div>
<div class="line"><a id="l00325" name="l00325"></a><span class="lineno">  325</span>  <span class="keyword">public</span> flow::log::Log_context</div>
<div class="line"><a id="l00326" name="l00326"></a><span class="lineno">  326</span>{</div>
<div class="line"><a id="l00327" name="l00327"></a><span class="lineno">  327</span><span class="keyword">public</span>:</div>
<div class="line"><a id="l00328" name="l00328"></a><span class="lineno">  328</span>  <span class="comment">// Types.</span></div>
<div class="line"><a id="l00329" name="l00329"></a><span class="lineno">  329</span><span class="comment"></span> </div>
<div class="line"><a id="l00330" name="l00330"></a><span class="lineno">  330</span><span class="comment">  /// Useful for generic programming, the async-I/O-pattern counterpart to `*this` type.</span></div>
<div class="line"><a id="l00331" name="l00331"></a><span class="lineno"><a class="line" href="classipc_1_1transport_1_1struc_1_1sync__io_1_1Channel.html#a6dc83bd6057b7f00a19c5947d6baa7b7">  331</a></span><span class="comment"></span>  <span class="keyword">using </span><a class="code hl_class" href="classipc_1_1transport_1_1struc_1_1Channel.html">Async_io_obj</a> = <a class="code hl_class" href="classipc_1_1transport_1_1struc_1_1Channel.html">transport::struc::Channel</a>&lt;Channel_obj, Message_body,</div>
<div class="line"><a id="l00332" name="l00332"></a><span class="lineno">  332</span>                                                 Struct_builder_config, Struct_reader_config&gt;;<span class="comment"></span></div>
<div class="line"><a id="l00333" name="l00333"></a><span class="lineno">  333</span><span class="comment">  /// You may disregard.</span></div>
<div class="line"><a id="l00334" name="l00334"></a><span class="lineno"><a class="line" href="classipc_1_1transport_1_1struc_1_1sync__io_1_1Channel.html#a5bb15c142ca501fe5fdfa8068d076e36">  334</a></span><span class="comment"></span>  <span class="keyword">using </span><a class="code hl_class" href="classipc_1_1transport_1_1Null__peer.html">Sync_io_obj</a> = <a class="code hl_class" href="classipc_1_1transport_1_1Null__peer.html">Null_peer</a>;</div>
<div class="line"><a id="l00335" name="l00335"></a><span class="lineno">  335</span><span class="comment"></span> </div>
<div class="line"><a id="l00336" name="l00336"></a><span class="lineno">  336</span><span class="comment">  /// See #Async_io_obj counterpart.</span></div>
<div class="line"><a id="l00337" name="l00337"></a><span class="lineno"><a class="line" href="classipc_1_1transport_1_1struc_1_1sync__io_1_1Channel.html#a4abac89dbd4d26c79b7915990f751a76">  337</a></span><span class="comment"></span>  <span class="keyword">using </span><a class="code hl_typedef" href="classipc_1_1transport_1_1struc_1_1sync__io_1_1Channel.html#a4abac89dbd4d26c79b7915990f751a76">Owned_channel</a> = Channel_obj;</div>
<div class="line"><a id="l00338" name="l00338"></a><span class="lineno">  338</span> </div>
<div class="line"><a id="l00339" name="l00339"></a><span class="lineno">  339</span>  <span class="keyword">static_assert</span>(Owned_channel::S_IS_SYNC_IO_OBJ,</div>
<div class="line"><a id="l00340" name="l00340"></a><span class="lineno">  340</span>                <span class="stringliteral">&quot;struc::Channel (whether sync_io or async-I/O) subsumes sync_io-pattern-peer-bearing &quot;</span></div>
<div class="line"><a id="l00341" name="l00341"></a><span class="lineno">  341</span>                  <span class="stringliteral">&quot;`Channel`s only.  Fortunately ipc::session at least emits such `Channel`s.&quot;</span>);</div>
<div class="line"><a id="l00342" name="l00342"></a><span class="lineno">  342</span><span class="comment"></span> </div>
<div class="line"><a id="l00343" name="l00343"></a><span class="lineno">  343</span><span class="comment">  /// See #Async_io_obj counterpart.</span></div>
<div class="line"><a id="l00344" name="l00344"></a><span class="lineno"><a class="line" href="classipc_1_1transport_1_1struc_1_1sync__io_1_1Channel.html#a8a59bbc3c6a7191b316b23661d8ba6e3">  344</a></span><span class="comment"></span>  <span class="keyword">using </span><a class="code hl_typedef" href="classipc_1_1transport_1_1struc_1_1sync__io_1_1Channel.html#a8a59bbc3c6a7191b316b23661d8ba6e3">Builder_config</a> = Struct_builder_config;<span class="comment"></span></div>
<div class="line"><a id="l00345" name="l00345"></a><span class="lineno">  345</span><span class="comment">  /// See #Async_io_obj counterpart.</span></div>
<div class="line"><a id="l00346" name="l00346"></a><span class="lineno"><a class="line" href="classipc_1_1transport_1_1struc_1_1sync__io_1_1Channel.html#a14a7166b2f8c117ce6ddafe943d036fa">  346</a></span><span class="comment"></span>  <span class="keyword">using </span><a class="code hl_typedef" href="classipc_1_1transport_1_1struc_1_1sync__io_1_1Channel.html#a14a7166b2f8c117ce6ddafe943d036fa">Reader_config</a> = Struct_reader_config;</div>
<div class="line"><a id="l00347" name="l00347"></a><span class="lineno">  347</span><span class="comment"></span> </div>
<div class="line"><a id="l00348" name="l00348"></a><span class="lineno">  348</span><span class="comment">  /// See #Async_io_obj counterpart.</span></div>
<div class="line"><a id="l00349" name="l00349"></a><span class="lineno"><a class="line" href="classipc_1_1transport_1_1struc_1_1sync__io_1_1Channel.html#a34e183c252390f369f121074772c14c4">  349</a></span><span class="comment"></span>  <span class="keyword">using </span><a class="code hl_typedef" href="classipc_1_1transport_1_1struc_1_1sync__io_1_1Channel.html#a34e183c252390f369f121074772c14c4">Msg_body</a> = Message_body;</div>
<div class="line"><a id="l00350" name="l00350"></a><span class="lineno">  350</span><span class="comment"></span> </div>
<div class="line"><a id="l00351" name="l00351"></a><span class="lineno">  351</span><span class="comment">  /// See #Async_io_obj counterpart.</span></div>
<div class="line"><a id="l00352" name="l00352"></a><span class="lineno"><a class="line" href="classipc_1_1transport_1_1struc_1_1sync__io_1_1Channel.html#a1572a1b1cb4a72ea57f7841a5e78759b">  352</a></span><span class="comment"></span>  <span class="keyword">using </span><a class="code hl_typedef" href="classipc_1_1transport_1_1struc_1_1sync__io_1_1Channel.html#a1572a1b1cb4a72ea57f7841a5e78759b">Msg_which</a> = <span class="keyword">typename</span> Message_body::Which;</div>
<div class="line"><a id="l00353" name="l00353"></a><span class="lineno">  353</span><span class="comment"></span> </div>
<div class="line"><a id="l00354" name="l00354"></a><span class="lineno">  354</span><span class="comment">  /// See #Async_io_obj counterpart.</span></div>
<div class="line"><a id="l00355" name="l00355"></a><span class="lineno"><a class="line" href="classipc_1_1transport_1_1struc_1_1sync__io_1_1Channel.html#aa40c3ec3f45cdfea9360f7f35b9ade3c">  355</a></span><span class="comment"></span>  <span class="keyword">using </span><a class="code hl_typedef" href="classipc_1_1transport_1_1struc_1_1sync__io_1_1Channel.html#aa40c3ec3f45cdfea9360f7f35b9ade3c">Msg_which_in</a> = <a class="code hl_typedef" href="classipc_1_1transport_1_1struc_1_1sync__io_1_1Channel.html#a1572a1b1cb4a72ea57f7841a5e78759b">Msg_which</a>;</div>
<div class="line"><a id="l00356" name="l00356"></a><span class="lineno">  356</span><span class="comment"></span> </div>
<div class="line"><a id="l00357" name="l00357"></a><span class="lineno">  357</span><span class="comment">  /// See #Async_io_obj counterpart.</span></div>
<div class="line"><a id="l00358" name="l00358"></a><span class="lineno"><a class="line" href="classipc_1_1transport_1_1struc_1_1sync__io_1_1Channel.html#a7a731cdae5217ed9e867fb80c1fb0fd9">  358</a></span><span class="comment"></span>  <span class="keyword">using </span><a class="code hl_typedef" href="classipc_1_1transport_1_1struc_1_1sync__io_1_1Channel.html#a7a731cdae5217ed9e867fb80c1fb0fd9">Msg_which_out</a> = <a class="code hl_typedef" href="classipc_1_1transport_1_1struc_1_1sync__io_1_1Channel.html#a1572a1b1cb4a72ea57f7841a5e78759b">Msg_which</a>;</div>
<div class="line"><a id="l00359" name="l00359"></a><span class="lineno">  359</span><span class="comment"></span> </div>
<div class="line"><a id="l00360" name="l00360"></a><span class="lineno">  360</span><span class="comment">  /// See #Async_io_obj counterpart.</span></div>
<div class="line"><a id="l00361" name="l00361"></a><span class="lineno"><a class="line" href="classipc_1_1transport_1_1struc_1_1sync__io_1_1Channel.html#a83fb4462a8d4045bdb56b694bf80393c">  361</a></span><span class="comment"></span>  <span class="keyword">using </span><a class="code hl_class" href="classipc_1_1transport_1_1struc_1_1Msg__out.html">Msg_out</a> = <a class="code hl_class" href="classipc_1_1transport_1_1struc_1_1Msg__out.html">struc::Msg_out&lt;Msg_body, typename Builder_config::Builder&gt;</a>;</div>
<div class="line"><a id="l00362" name="l00362"></a><span class="lineno">  362</span><span class="comment"></span> </div>
<div class="line"><a id="l00363" name="l00363"></a><span class="lineno">  363</span><span class="comment">  /// See #Async_io_obj counterpart.</span></div>
<div class="line"><a id="l00364" name="l00364"></a><span class="lineno"><a class="line" href="classipc_1_1transport_1_1struc_1_1sync__io_1_1Channel.html#ac3da0ac1306b63c9e38c47b8c31e3cd2">  364</a></span><span class="comment"></span>  <span class="keyword">using </span><a class="code hl_class" href="classipc_1_1transport_1_1struc_1_1Msg__in.html">Msg_in</a> = <a class="code hl_class" href="classipc_1_1transport_1_1struc_1_1Msg__in.html">struc::Msg_in&lt;Msg_body, Reader_config&gt;</a>;</div>
<div class="line"><a id="l00365" name="l00365"></a><span class="lineno">  365</span><span class="comment"></span> </div>
<div class="line"><a id="l00366" name="l00366"></a><span class="lineno">  366</span><span class="comment">  /// See #Async_io_obj counterpart.</span></div>
<div class="line"><a id="l00367" name="l00367"></a><span class="lineno"><a class="line" href="classipc_1_1transport_1_1struc_1_1sync__io_1_1Channel.html#acde2b3866547a30958035203d9d89928">  367</a></span><span class="comment"></span>  <span class="keyword">using </span><a class="code hl_typedef" href="classipc_1_1transport_1_1struc_1_1sync__io_1_1Channel.html#acde2b3866547a30958035203d9d89928">Msg_in_ptr</a> = boost::shared_ptr&lt;Msg_in&gt;;</div>
<div class="line"><a id="l00368" name="l00368"></a><span class="lineno">  368</span><span class="comment"></span> </div>
<div class="line"><a id="l00369" name="l00369"></a><span class="lineno">  369</span><span class="comment">  /// List of in-messages used in certain APIs like expect_msgs() to synchronously emit cached in-messages.</span></div>
<div class="line"><a id="l00370" name="l00370"></a><span class="lineno"><a class="line" href="classipc_1_1transport_1_1struc_1_1sync__io_1_1Channel.html#a4ab778bce8d7e6e84788879fedc62745">  370</a></span><span class="comment"></span>  <span class="keyword">using </span><a class="code hl_typedef" href="classipc_1_1transport_1_1struc_1_1sync__io_1_1Channel.html#a4ab778bce8d7e6e84788879fedc62745">Msgs_in</a> = std::vector&lt;Msg_in_ptr&gt;;</div>
<div class="line"><a id="l00371" name="l00371"></a><span class="lineno">  371</span><span class="comment"></span> </div>
<div class="line"><a id="l00372" name="l00372"></a><span class="lineno">  372</span><span class="comment">  /// See #Async_io_obj counterpart.</span></div>
<div class="line"><a id="l00373" name="l00373"></a><span class="lineno"><a class="line" href="classipc_1_1transport_1_1struc_1_1sync__io_1_1Channel.html#a9b5d17887c9ad1e37081bf4ae4a70e65">  373</a></span><span class="comment"></span>  <span class="keyword">using </span><a class="code hl_typedef" href="classipc_1_1transport_1_1struc_1_1Channel__base.html#adcf24fa51747ed83c4b6427fbf44fecf">msg_id_out_t</a> = <a class="code hl_typedef" href="classipc_1_1transport_1_1struc_1_1Channel__base.html#adcf24fa51747ed83c4b6427fbf44fecf">Channel_base::msg_id_out_t</a>;</div>
<div class="line"><a id="l00374" name="l00374"></a><span class="lineno">  374</span> </div>
<div class="line"><a id="l00375" name="l00375"></a><span class="lineno">  375</span>  <span class="comment">// Constructors/destructor.</span></div>
<div class="line"><a id="l00376" name="l00376"></a><span class="lineno">  376</span><span class="comment"></span> </div>
<div class="line"><a id="l00377" name="l00377"></a><span class="lineno">  377</span><span class="comment">  /**</span></div>
<div class="line"><a id="l00378" name="l00378"></a><span class="lineno">  378</span><span class="comment">   * Non-tag, no-log-in ctor form: Creates structured channel peer with no log-in phase (log-in phase must have occurred</span></div>
<div class="line"><a id="l00379" name="l00379"></a><span class="lineno">  379</span><span class="comment">   * in a preceding struc::Channel called *session master channel*), the session token already known and passed-in</span></div>
<div class="line"><a id="l00380" name="l00380"></a><span class="lineno">  380</span><span class="comment">   * to this ctor.  Consider also:</span></div>
<div class="line"><a id="l00381" name="l00381"></a><span class="lineno">  381</span><span class="comment">   *   - A tag-form ctor (usually simpler than manually cting `struct_builder_config` and</span></div>
<div class="line"><a id="l00382" name="l00382"></a><span class="lineno">  382</span><span class="comment">   *     `struct_reader_config`).</span></div>
<div class="line"><a id="l00383" name="l00383"></a><span class="lineno">  383</span><span class="comment">   *   - With-log-in ctor (usually needed for session master channel only).</span></div>
<div class="line"><a id="l00384" name="l00384"></a><span class="lineno">  384</span><span class="comment">   *</span></div>
<div class="line"><a id="l00385" name="l00385"></a><span class="lineno">  385</span><span class="comment">   * @note This ctor form is forwarded-to from #Async_io_obj ctor.  Documentation below applies to both ctors</span></div>
<div class="line"><a id="l00386" name="l00386"></a><span class="lineno">  386</span><span class="comment">   *       except where noted.</span></div>
<div class="line"><a id="l00387" name="l00387"></a><span class="lineno">  387</span><span class="comment">   *</span></div>
<div class="line"><a id="l00388" name="l00388"></a><span class="lineno">  388</span><span class="comment">   * If `*this` ctor is for sync_io::Channel: You&#39;ll need to start_ops() (possibly preceded by</span></div>
<div class="line"><a id="l00389" name="l00389"></a><span class="lineno">  389</span><span class="comment">   * replace_event_wait_handles()) per `sync_io` pattern.  (If `*this` ctor is for #Async_io_obj: not applicable.)</span></div>
<div class="line"><a id="l00390" name="l00390"></a><span class="lineno">  390</span><span class="comment">   * Then:</span></div>
<div class="line"><a id="l00391" name="l00391"></a><span class="lineno">  391</span><span class="comment">   *</span></div>
<div class="line"><a id="l00392" name="l00392"></a><span class="lineno">  392</span><span class="comment">   * You may send() (et al) immediately after this.  However no in-messages shall be emitted, regardless of registered</span></div>
<div class="line"><a id="l00393" name="l00393"></a><span class="lineno">  393</span><span class="comment">   * expectations such as via expect_msg(), until you invoke start_and_poll().  (For #Async_io_obj:</span></div>
<div class="line"><a id="l00394" name="l00394"></a><span class="lineno">  394</span><span class="comment">   * transport::struc::Channel::start().)</span></div>
<div class="line"><a id="l00395" name="l00395"></a><span class="lineno">  395</span><span class="comment">   *</span></div>
<div class="line"><a id="l00396" name="l00396"></a><span class="lineno">  396</span><span class="comment">   * Consider, also, `owned_channel_mutable()-&gt;auto_ping()` and/or `owned_channel_mutable()-&gt;idle_timer_run()`,</span></div>
<div class="line"><a id="l00397" name="l00397"></a><span class="lineno">  397</span><span class="comment">   * if you desire these features to be ambiently enabled.  See Channel::auto_ping(), Channel::idle_timer_run()</span></div>
<div class="line"><a id="l00398" name="l00398"></a><span class="lineno">  398</span><span class="comment">   * for background.</span></div>
<div class="line"><a id="l00399" name="l00399"></a><span class="lineno">  399</span><span class="comment">   *</span></div>
<div class="line"><a id="l00400" name="l00400"></a><span class="lineno">  400</span><span class="comment">   * ### How/whether to obtain a #Builder_config `struct_builder_config` (and related) ###</span></div>
<div class="line"><a id="l00401" name="l00401"></a><span class="lineno">  401</span><span class="comment">   * It is easiest, usually, to use a different ctor form instead; namely use a tagged-ctor version that will</span></div>
<div class="line"><a id="l00402" name="l00402"></a><span class="lineno">  402</span><span class="comment">   * set everything up.  See `Channel_base::Serialize_via_*`.  Only use the present ctor form:</span></div>
<div class="line"><a id="l00403" name="l00403"></a><span class="lineno">  403</span><span class="comment">   *   - IF: your serialization strategy of choice is simply not covered by the tagged-ctor versions available</span></div>
<div class="line"><a id="l00404" name="l00404"></a><span class="lineno">  404</span><span class="comment">   *     (you have a custom builder/reader you want to use for advanced purposes).  OR:</span></div>
<div class="line"><a id="l00405" name="l00405"></a><span class="lineno">  405</span><span class="comment">   *   - IF: you want to use a different serialization strategy in the outgoing direction versus incoming direction:</span></div>
<div class="line"><a id="l00406" name="l00406"></a><span class="lineno">  406</span><span class="comment">   *     e.g., this side sends only short things -- and you want to use Heap_fixed_builder here and</span></div>
<div class="line"><a id="l00407" name="l00407"></a><span class="lineno">  407</span><span class="comment">   *     Heap_reader there; but the other side sends huge things, so you want SHM-based serialization there</span></div>
<div class="line"><a id="l00408" name="l00408"></a><span class="lineno">  408</span><span class="comment">   *     and deserialization here.  The tag ctors assume symmetry and don&#39;t support this.</span></div>
<div class="line"><a id="l00409" name="l00409"></a><span class="lineno">  409</span><span class="comment">   *</span></div>
<div class="line"><a id="l00410" name="l00410"></a><span class="lineno">  410</span><span class="comment">   * If you&#39;ve chosen to use this ctor form:</span></div>
<div class="line"><a id="l00411" name="l00411"></a><span class="lineno">  411</span><span class="comment">   *</span></div>
<div class="line"><a id="l00412" name="l00412"></a><span class="lineno">  412</span><span class="comment">   * Formally speaking it&#39;s simply up to you to construct these args before calling this ctor; see the docs for</span></div>
<div class="line"><a id="l00413" name="l00413"></a><span class="lineno">  413</span><span class="comment">   * the particular #Builder_config class of choice.  Informally: if you&#39;re constructing the #Builder_config</span></div>
<div class="line"><a id="l00414" name="l00414"></a><span class="lineno">  414</span><span class="comment">   * and/or specifying `struct_lender_session` (less so #Reader_config, but for consistency it too) directly, you&#39;re</span></div>
<div class="line"><a id="l00415" name="l00415"></a><span class="lineno">  415</span><span class="comment">   * probably not doing the right thing.  The following places are available to obtain tese for safety and</span></div>
<div class="line"><a id="l00416" name="l00416"></a><span class="lineno">  416</span><span class="comment">   * efficiency (and code maintainability):</span></div>
<div class="line"><a id="l00417" name="l00417"></a><span class="lineno">  417</span><span class="comment">   *   - From another, compatible, `Channel` via struct_builder_config(), struct_lender_session(),</span></div>
<div class="line"><a id="l00418" name="l00418"></a><span class="lineno">  418</span><span class="comment">   *     struct_reader_config().</span></div>
<div class="line"><a id="l00419" name="l00419"></a><span class="lineno">  419</span><span class="comment">   *   - Heap-backed:</span></div>
<div class="line"><a id="l00420" name="l00420"></a><span class="lineno">  420</span><span class="comment">   *     - `struct_lender_session` is always `NULL_SESSION`.  As for the other 2:</span></div>
<div class="line"><a id="l00421" name="l00421"></a><span class="lineno">  421</span><span class="comment">   *     - If you have the target #Owned_channel: via `static` heap_fixed_builder_config() and heap_reader_config().</span></div>
<div class="line"><a id="l00422" name="l00422"></a><span class="lineno">  422</span><span class="comment">   *     - Otherwise: session::Session_mv::heap_fixed_builder_config() (`static` or non-`static`),</span></div>
<div class="line"><a id="l00423" name="l00423"></a><span class="lineno">  423</span><span class="comment">   *       session::Session_mv::heap_reader_config() (ditto).</span></div>
<div class="line"><a id="l00424" name="l00424"></a><span class="lineno">  424</span><span class="comment">   *   - SHM-backed (using SHM-classic as example):</span></div>
<div class="line"><a id="l00425" name="l00425"></a><span class="lineno">  425</span><span class="comment">   *     - session::shm::classic::Session_mv::session_shm_builder_config() (ditto reader),</span></div>
<div class="line"><a id="l00426" name="l00426"></a><span class="lineno">  426</span><span class="comment">   *       session::shm::classic::Session_mv::session_shm_lender_session(),</span></div>
<div class="line"><a id="l00427" name="l00427"></a><span class="lineno">  427</span><span class="comment">   *       session::shm::classic::Session_mv::app_shm_builder_config() (ditto reader),</span></div>
<div class="line"><a id="l00428" name="l00428"></a><span class="lineno">  428</span><span class="comment">   *       session::shm::classic::Session_mv::app_shm_lender_session().  Requires a `Session` object.</span></div>
<div class="line"><a id="l00429" name="l00429"></a><span class="lineno">  429</span><span class="comment">   *     - session::shm::classic::Session_server::app_shm_builder_config() (requires session::Client_app).</span></div>
<div class="line"><a id="l00430" name="l00430"></a><span class="lineno">  430</span><span class="comment">   *       Server-only; if a `Session` is not available or applicable.</span></div>
<div class="line"><a id="l00431" name="l00431"></a><span class="lineno">  431</span><span class="comment">   *</span></div>
<div class="line"><a id="l00432" name="l00432"></a><span class="lineno">  432</span><span class="comment">   * @param logger_ptr</span></div>
<div class="line"><a id="l00433" name="l00433"></a><span class="lineno">  433</span><span class="comment">   *        Logger to use for logging subsequently.</span></div>
<div class="line"><a id="l00434" name="l00434"></a><span class="lineno">  434</span><span class="comment">   * @param channel</span></div>
<div class="line"><a id="l00435" name="l00435"></a><span class="lineno">  435</span><span class="comment">   *        Channel in PEER state with no prior traffic.  All configurations (1 pipe, 2 pipes) are supported.</span></div>
<div class="line"><a id="l00436" name="l00436"></a><span class="lineno">  436</span><span class="comment">   *        If `channel.initialized()` is `false`, behavior is undefined (assertion may trip): suggest</span></div>
<div class="line"><a id="l00437" name="l00437"></a><span class="lineno">  437</span><span class="comment">   *        sanity-checking this prior to this ctor.</span></div>
<div class="line"><a id="l00438" name="l00438"></a><span class="lineno">  438</span><span class="comment">   *        Behavior is undefined if it is not in PEER state or has had prior traffic.  (Reminder: PEER state</span></div>
<div class="line"><a id="l00439" name="l00439"></a><span class="lineno">  439</span><span class="comment">   *        does not mean it isn&#39;t hosed from error/whatever: This is handled gracefully.)</span></div>
<div class="line"><a id="l00440" name="l00440"></a><span class="lineno">  440</span><span class="comment">   *        The channel is moved-into `*this`.</span></div>
<div class="line"><a id="l00441" name="l00441"></a><span class="lineno">  441</span><span class="comment">   * @param struct_builder_config</span></div>
<div class="line"><a id="l00442" name="l00442"></a><span class="lineno">  442</span><span class="comment">   *        The serialization engine config to use for serializing out-messages.  This small object is copied.</span></div>
<div class="line"><a id="l00443" name="l00443"></a><span class="lineno">  443</span><span class="comment">   * @param struct_lender_session</span></div>
<div class="line"><a id="l00444" name="l00444"></a><span class="lineno">  444</span><span class="comment">   *        See Struct_builder::Session (and/or Struct_builder::emit_serialization()) concept doc header.</span></div>
<div class="line"><a id="l00445" name="l00445"></a><span class="lineno">  445</span><span class="comment">   *        This small value (typically a pointer) is copied; or the type may be Null_session which is empty;</span></div>
<div class="line"><a id="l00446" name="l00446"></a><span class="lineno">  446</span><span class="comment">   *        then there is nothing to even copy.</span></div>
<div class="line"><a id="l00447" name="l00447"></a><span class="lineno">  447</span><span class="comment">   * @param struct_reader_config</span></div>
<div class="line"><a id="l00448" name="l00448"></a><span class="lineno">  448</span><span class="comment">   *        The deserialization engine config to use for deserializing in-messages.  This small object is copied.</span></div>
<div class="line"><a id="l00449" name="l00449"></a><span class="lineno">  449</span><span class="comment">   * @param session_token_non_nil</span></div>
<div class="line"><a id="l00450" name="l00450"></a><span class="lineno">  450</span><span class="comment">   *        The session token to place into all out-messages and for which value to check against all in-messages.</span></div>
<div class="line"><a id="l00451" name="l00451"></a><span class="lineno">  451</span><span class="comment">   *        If a check fails, the channel is hosed immediately.  Behavior undefined if it equals nil</span></div>
<div class="line"><a id="l00452" name="l00452"></a><span class="lineno">  452</span><span class="comment">   *        (assertion may trip).  See class doc header regarding how to obtain the value to pass-in here.</span></div>
<div class="line"><a id="l00453" name="l00453"></a><span class="lineno">  453</span><span class="comment">   */</span></div>
<div class="line"><a id="l00454" name="l00454"></a><span class="lineno">  454</span>  <span class="keyword">explicit</span> <a class="code hl_function" href="classipc_1_1transport_1_1struc_1_1sync__io_1_1Channel.html#a9385752ed00263dec5c5080b67ce0960">Channel</a>(flow::log::Logger* logger_ptr, <a class="code hl_typedef" href="classipc_1_1transport_1_1struc_1_1sync__io_1_1Channel.html#a4abac89dbd4d26c79b7915990f751a76">Owned_channel</a>&amp;&amp; channel,</div>
<div class="line"><a id="l00455" name="l00455"></a><span class="lineno">  455</span>                   <span class="keyword">const</span> <a class="code hl_typedef" href="classipc_1_1transport_1_1struc_1_1sync__io_1_1Channel.html#a8a59bbc3c6a7191b316b23661d8ba6e3">Builder_config</a>&amp; <a class="code hl_function" href="classipc_1_1transport_1_1struc_1_1sync__io_1_1Channel.html#a48a8fd167c1fe6ae95d8fc80b6a6e67f">struct_builder_config</a>,</div>
<div class="line"><a id="l00456" name="l00456"></a><span class="lineno">  456</span>                   <span class="keyword">const</span> <span class="keyword">typename</span> Builder_config::Builder::Session&amp; <a class="code hl_function" href="classipc_1_1transport_1_1struc_1_1sync__io_1_1Channel.html#a43fa0b77781376edd13b742b832572e1">struct_lender_session</a>,</div>
<div class="line"><a id="l00457" name="l00457"></a><span class="lineno">  457</span>                   <span class="keyword">const</span> <a class="code hl_typedef" href="classipc_1_1transport_1_1struc_1_1sync__io_1_1Channel.html#a14a7166b2f8c117ce6ddafe943d036fa">Reader_config</a>&amp; <a class="code hl_function" href="classipc_1_1transport_1_1struc_1_1sync__io_1_1Channel.html#a7efbfbcce0d4d426b7df9b6d6fd1e373">struct_reader_config</a>,</div>
<div class="line"><a id="l00458" name="l00458"></a><span class="lineno">  458</span>                   <span class="keyword">const</span> <a class="code hl_typedef" href="namespaceipc_1_1transport_1_1struc.html#a6751c05fb6582a34c7c47ac470c4a48b">Session_token</a>&amp; session_token_non_nil);</div>
<div class="line"><a id="l00459" name="l00459"></a><span class="lineno">  459</span><span class="comment"></span> </div>
<div class="line"><a id="l00460" name="l00460"></a><span class="lineno">  460</span><span class="comment">  /**</span></div>
<div class="line"><a id="l00461" name="l00461"></a><span class="lineno">  461</span><span class="comment">   * Non-tag, with-log-in ctor form: Creates structured channel peer (endpoint of the *session master channel*)</span></div>
<div class="line"><a id="l00462" name="l00462"></a><span class="lineno">  462</span><span class="comment">   * with a log-in phase, this peer being the *server* or *client* depending on the arg `is_server`.  Consider also:</span></div>
<div class="line"><a id="l00463" name="l00463"></a><span class="lineno">  463</span><span class="comment">   *   - A tag-form ctor (usually simpler than manually cting `struct_builder_config` and</span></div>
<div class="line"><a id="l00464" name="l00464"></a><span class="lineno">  464</span><span class="comment">   *     `struct_reader_config`).</span></div>
<div class="line"><a id="l00465" name="l00465"></a><span class="lineno">  465</span><span class="comment">   *   - No-log-in ctor (since present ctor is usually needed for session master channel only).</span></div>
<div class="line"><a id="l00466" name="l00466"></a><span class="lineno">  466</span><span class="comment">   *</span></div>
<div class="line"><a id="l00467" name="l00467"></a><span class="lineno">  467</span><span class="comment">   * No general user communication can occur until the log-in phase is completed.  As such `*this` would be</span></div>
<div class="line"><a id="l00468" name="l00468"></a><span class="lineno">  468</span><span class="comment">   * the *session master channel* with, presumably, exactly 1 such `*this` in the entire process at a given time.</span></div>
<div class="line"><a id="l00469" name="l00469"></a><span class="lineno">  469</span><span class="comment">   * See #Async_io_obj class doc header for background.</span></div>
<div class="line"><a id="l00470" name="l00470"></a><span class="lineno">  470</span><span class="comment">   *</span></div>
<div class="line"><a id="l00471" name="l00471"></a><span class="lineno">  471</span><span class="comment">   * @note This ctor form is forwarded-to from #Async_io_obj ctor.  Documentation below applies to both ctors</span></div>
<div class="line"><a id="l00472" name="l00472"></a><span class="lineno">  472</span><span class="comment">   *       except where noted.</span></div>
<div class="line"><a id="l00473" name="l00473"></a><span class="lineno">  473</span><span class="comment">   *</span></div>
<div class="line"><a id="l00474" name="l00474"></a><span class="lineno">  474</span><span class="comment">   * If `*this` ctor is for sync_io::Channel: You&#39;ll need to start_ops() (possibly preceded by</span></div>
<div class="line"><a id="l00475" name="l00475"></a><span class="lineno">  475</span><span class="comment">   * replace_event_wait_handles()) per `sync_io` pattern.  (If `*this` ctor is for #Async_io_obj: not applicable.)</span></div>
<div class="line"><a id="l00476" name="l00476"></a><span class="lineno">  476</span><span class="comment">   * Then:</span></div>
<div class="line"><a id="l00477" name="l00477"></a><span class="lineno">  477</span><span class="comment">   *</span></div>
<div class="line"><a id="l00478" name="l00478"></a><span class="lineno">  478</span><span class="comment">   * You may send() (et al) immediately after this.  However no in-messages shall be emitted, regardless of registered</span></div>
<div class="line"><a id="l00479" name="l00479"></a><span class="lineno">  479</span><span class="comment">   * expectations such as via expect_msg(), until you invoke start_and_poll().  (For #Async_io_obj:</span></div>
<div class="line"><a id="l00480" name="l00480"></a><span class="lineno">  480</span><span class="comment">   * transport::struc::Channel::start().)</span></div>
<div class="line"><a id="l00481" name="l00481"></a><span class="lineno">  481</span><span class="comment">   *</span></div>
<div class="line"><a id="l00482" name="l00482"></a><span class="lineno">  482</span><span class="comment">   * Consider, also, `owned_channel_mutable()-&gt;auto_ping()` and/or `owned_channel_mutable()-&gt;idle_timer_run()`,</span></div>
<div class="line"><a id="l00483" name="l00483"></a><span class="lineno">  483</span><span class="comment">   * if you desire these features to be ambiently enabled.  See Channel::auto_ping(), Channel::idle_timer_run()</span></div>
<div class="line"><a id="l00484" name="l00484"></a><span class="lineno">  484</span><span class="comment">   * for background.</span></div>
<div class="line"><a id="l00485" name="l00485"></a><span class="lineno">  485</span><span class="comment">   *</span></div>
<div class="line"><a id="l00486" name="l00486"></a><span class="lineno">  486</span><span class="comment">   * ### As server ###</span></div>
<div class="line"><a id="l00487" name="l00487"></a><span class="lineno">  487</span><span class="comment">   * To begin the log-in phase -- and thus start to move to the logged-in phase, in which general traffic can</span></div>
<div class="line"><a id="l00488" name="l00488"></a><span class="lineno">  488</span><span class="comment">   * occur -- you must use expect_log_in_request().  `*this` will proceed to logged-in phase automatically once</span></div>
<div class="line"><a id="l00489" name="l00489"></a><span class="lineno">  489</span><span class="comment">   * the log-in request message `M` arrives, and you then invoke `send(X, M)`, where `X` is the log-in response</span></div>
<div class="line"><a id="l00490" name="l00490"></a><span class="lineno">  490</span><span class="comment">   * out-message you create/fill-out.  To be clear the phase change occurs as the last step in that</span></div>
<div class="line"><a id="l00491" name="l00491"></a><span class="lineno">  491</span><span class="comment">   * successful send().</span></div>
<div class="line"><a id="l00492" name="l00492"></a><span class="lineno">  492</span><span class="comment">   *</span></div>
<div class="line"><a id="l00493" name="l00493"></a><span class="lineno">  493</span><span class="comment">   * ### As client ###</span></div>
<div class="line"><a id="l00494" name="l00494"></a><span class="lineno">  494</span><span class="comment">   * To begin the log-in phase -- and thus start to move to the logged-in phase, in which general traffic can</span></div>
<div class="line"><a id="l00495" name="l00495"></a><span class="lineno">  495</span><span class="comment">   * occur -- you must `send(X, nullptr, nullptr, F)`, where `X` is the log-in request out-message you create/fill-out,</span></div>
<div class="line"><a id="l00496" name="l00496"></a><span class="lineno">  496</span><span class="comment">   * while `F()` is the handler for the log-in response.  `*this` will proceed to logged-in phase</span></div>
<div class="line"><a id="l00497" name="l00497"></a><span class="lineno">  497</span><span class="comment">   * automatically once the response to X arrives; and will then invoke `F()` for any further validation the</span></div>
<div class="line"><a id="l00498" name="l00498"></a><span class="lineno">  498</span><span class="comment">   * user may desire.</span></div>
<div class="line"><a id="l00499" name="l00499"></a><span class="lineno">  499</span><span class="comment">   *</span></div>
<div class="line"><a id="l00500" name="l00500"></a><span class="lineno">  500</span><span class="comment">   * ### How/whether to obtain a #Builder_config `struct_builder_config` (and #Reader_config similarly) ###</span></div>
<div class="line"><a id="l00501" name="l00501"></a><span class="lineno">  501</span><span class="comment">   * See notes for the other (no-log-in) non-tag ctor overload.</span></div>
<div class="line"><a id="l00502" name="l00502"></a><span class="lineno">  502</span><span class="comment">   *</span></div>
<div class="line"><a id="l00503" name="l00503"></a><span class="lineno">  503</span><span class="comment">   * @param logger_ptr</span></div>
<div class="line"><a id="l00504" name="l00504"></a><span class="lineno">  504</span><span class="comment">   *        See other ctor overload.</span></div>
<div class="line"><a id="l00505" name="l00505"></a><span class="lineno">  505</span><span class="comment">   * @param channel</span></div>
<div class="line"><a id="l00506" name="l00506"></a><span class="lineno">  506</span><span class="comment">   *        See other ctor overload.</span></div>
<div class="line"><a id="l00507" name="l00507"></a><span class="lineno">  507</span><span class="comment">   * @param struct_builder_config</span></div>
<div class="line"><a id="l00508" name="l00508"></a><span class="lineno">  508</span><span class="comment">   *        See other ctor overload.</span></div>
<div class="line"><a id="l00509" name="l00509"></a><span class="lineno">  509</span><span class="comment">   * @param struct_lender_session</span></div>
<div class="line"><a id="l00510" name="l00510"></a><span class="lineno">  510</span><span class="comment">   *        See other ctor overload.</span></div>
<div class="line"><a id="l00511" name="l00511"></a><span class="lineno">  511</span><span class="comment">   * @param struct_reader_config</span></div>
<div class="line"><a id="l00512" name="l00512"></a><span class="lineno">  512</span><span class="comment">   *        See other ctor overload.</span></div>
<div class="line"><a id="l00513" name="l00513"></a><span class="lineno">  513</span><span class="comment">   * @param is_server</span></div>
<div class="line"><a id="l00514" name="l00514"></a><span class="lineno">  514</span><span class="comment">   *        See above.</span></div>
<div class="line"><a id="l00515" name="l00515"></a><span class="lineno">  515</span><span class="comment">   */</span></div>
<div class="line"><a id="l00516" name="l00516"></a><span class="lineno">  516</span>  <span class="keyword">explicit</span> <a class="code hl_function" href="classipc_1_1transport_1_1struc_1_1sync__io_1_1Channel.html#a9385752ed00263dec5c5080b67ce0960">Channel</a>(flow::log::Logger* logger_ptr, <a class="code hl_typedef" href="classipc_1_1transport_1_1struc_1_1sync__io_1_1Channel.html#a4abac89dbd4d26c79b7915990f751a76">Owned_channel</a>&amp;&amp; channel,</div>
<div class="line"><a id="l00517" name="l00517"></a><span class="lineno">  517</span>                   <span class="keyword">const</span> <a class="code hl_typedef" href="classipc_1_1transport_1_1struc_1_1sync__io_1_1Channel.html#a8a59bbc3c6a7191b316b23661d8ba6e3">Builder_config</a>&amp; <a class="code hl_function" href="classipc_1_1transport_1_1struc_1_1sync__io_1_1Channel.html#a48a8fd167c1fe6ae95d8fc80b6a6e67f">struct_builder_config</a>,</div>
<div class="line"><a id="l00518" name="l00518"></a><span class="lineno">  518</span>                   <span class="keyword">const</span> <span class="keyword">typename</span> Builder_config::Builder::Session&amp; <a class="code hl_function" href="classipc_1_1transport_1_1struc_1_1sync__io_1_1Channel.html#a43fa0b77781376edd13b742b832572e1">struct_lender_session</a>,</div>
<div class="line"><a id="l00519" name="l00519"></a><span class="lineno">  519</span>                   <span class="keyword">const</span> <a class="code hl_typedef" href="classipc_1_1transport_1_1struc_1_1sync__io_1_1Channel.html#a14a7166b2f8c117ce6ddafe943d036fa">Reader_config</a>&amp; <a class="code hl_function" href="classipc_1_1transport_1_1struc_1_1sync__io_1_1Channel.html#a7efbfbcce0d4d426b7df9b6d6fd1e373">struct_reader_config</a>,</div>
<div class="line"><a id="l00520" name="l00520"></a><span class="lineno">  520</span>                   <span class="keywordtype">bool</span> is_server);</div>
<div class="line"><a id="l00521" name="l00521"></a><span class="lineno">  521</span><span class="comment"></span> </div>
<div class="line"><a id="l00522" name="l00522"></a><span class="lineno">  522</span><span class="comment">  /**</span></div>
<div class="line"><a id="l00523" name="l00523"></a><span class="lineno">  523</span><span class="comment">   * Tag version of non-tag, no-log-in ctor:</span></div>
<div class="line"><a id="l00524" name="l00524"></a><span class="lineno">  524</span><span class="comment">   * Serialize_via_heap (bidirectional heap-based, non-zero-copy message serialization).</span></div>
<div class="line"><a id="l00525" name="l00525"></a><span class="lineno">  525</span><span class="comment">   *</span></div>
<div class="line"><a id="l00526" name="l00526"></a><span class="lineno">  526</span><span class="comment">   * @see Serialize_via_heap doc header for serialization-related background.</span></div>
<div class="line"><a id="l00527" name="l00527"></a><span class="lineno">  527</span><span class="comment">   * @see non-tag, no-log-in ctor.  As directed there, use the present form whenever sufficient, and indeed</span></div>
<div class="line"><a id="l00528" name="l00528"></a><span class="lineno">  528</span><span class="comment">   *      you want this type of serialization setup.  Consider also the other tag forms for other serialization</span></div>
<div class="line"><a id="l00529" name="l00529"></a><span class="lineno">  529</span><span class="comment">   *      methods which may match your requirements better.</span></div>
<div class="line"><a id="l00530" name="l00530"></a><span class="lineno">  530</span><span class="comment">   *</span></div>
<div class="line"><a id="l00531" name="l00531"></a><span class="lineno">  531</span><span class="comment">   * @param logger_ptr</span></div>
<div class="line"><a id="l00532" name="l00532"></a><span class="lineno">  532</span><span class="comment">   *        See non-tag ctor form.</span></div>
<div class="line"><a id="l00533" name="l00533"></a><span class="lineno">  533</span><span class="comment">   * @param channel</span></div>
<div class="line"><a id="l00534" name="l00534"></a><span class="lineno">  534</span><span class="comment">   *        See non-tag ctor form.</span></div>
<div class="line"><a id="l00535" name="l00535"></a><span class="lineno">  535</span><span class="comment">   * @param tag</span></div>
<div class="line"><a id="l00536" name="l00536"></a><span class="lineno">  536</span><span class="comment">   *        Ctor-selecting tag.</span></div>
<div class="line"><a id="l00537" name="l00537"></a><span class="lineno">  537</span><span class="comment">   * @param session_token_non_nil</span></div>
<div class="line"><a id="l00538" name="l00538"></a><span class="lineno">  538</span><span class="comment">   *        See non-tag ctor form.</span></div>
<div class="line"><a id="l00539" name="l00539"></a><span class="lineno">  539</span><span class="comment">   */</span></div>
<div class="line"><a id="l00540" name="l00540"></a><span class="lineno">  540</span>  <span class="keyword">explicit</span> <a class="code hl_function" href="classipc_1_1transport_1_1struc_1_1sync__io_1_1Channel.html#a9385752ed00263dec5c5080b67ce0960">Channel</a>(flow::log::Logger* logger_ptr, <a class="code hl_typedef" href="classipc_1_1transport_1_1struc_1_1sync__io_1_1Channel.html#a4abac89dbd4d26c79b7915990f751a76">Owned_channel</a>&amp;&amp; channel,</div>
<div class="line"><a id="l00541" name="l00541"></a><span class="lineno">  541</span>                   <a class="code hl_struct" href="structipc_1_1transport_1_1struc_1_1Channel__base_1_1Serialize__via__heap.html">Serialize_via_heap</a> tag,</div>
<div class="line"><a id="l00542" name="l00542"></a><span class="lineno">  542</span>                   <span class="keyword">const</span> <a class="code hl_typedef" href="namespaceipc_1_1transport_1_1struc.html#a6751c05fb6582a34c7c47ac470c4a48b">Session_token</a>&amp; session_token_non_nil);</div>
<div class="line"><a id="l00543" name="l00543"></a><span class="lineno">  543</span><span class="comment"></span> </div>
<div class="line"><a id="l00544" name="l00544"></a><span class="lineno">  544</span><span class="comment">  /**</span></div>
<div class="line"><a id="l00545" name="l00545"></a><span class="lineno">  545</span><span class="comment">   * Tag version of non-tag, with-log-in ctor:</span></div>
<div class="line"><a id="l00546" name="l00546"></a><span class="lineno">  546</span><span class="comment">   * Serialize_via_heap (bidirectional heap-based, non-zero-copy message serialization).</span></div>
<div class="line"><a id="l00547" name="l00547"></a><span class="lineno">  547</span><span class="comment">   *</span></div>
<div class="line"><a id="l00548" name="l00548"></a><span class="lineno">  548</span><span class="comment">   * @see Serialize_via_heap doc header for serialization-related background.</span></div>
<div class="line"><a id="l00549" name="l00549"></a><span class="lineno">  549</span><span class="comment">   * @see non-tag, with-log-in ctor.  As directed there, use the present form whenever sufficient, and indeed</span></div>
<div class="line"><a id="l00550" name="l00550"></a><span class="lineno">  550</span><span class="comment">   *      you want this type of serialization setup.  Consider also the other tag forms for other serialization</span></div>
<div class="line"><a id="l00551" name="l00551"></a><span class="lineno">  551</span><span class="comment">   *      methods which may match your requirements better.</span></div>
<div class="line"><a id="l00552" name="l00552"></a><span class="lineno">  552</span><span class="comment">   *</span></div>
<div class="line"><a id="l00553" name="l00553"></a><span class="lineno">  553</span><span class="comment">   * @param logger_ptr</span></div>
<div class="line"><a id="l00554" name="l00554"></a><span class="lineno">  554</span><span class="comment">   *        See non-tag ctor form.</span></div>
<div class="line"><a id="l00555" name="l00555"></a><span class="lineno">  555</span><span class="comment">   * @param channel</span></div>
<div class="line"><a id="l00556" name="l00556"></a><span class="lineno">  556</span><span class="comment">   *        See non-tag ctor form.</span></div>
<div class="line"><a id="l00557" name="l00557"></a><span class="lineno">  557</span><span class="comment">   * @param tag</span></div>
<div class="line"><a id="l00558" name="l00558"></a><span class="lineno">  558</span><span class="comment">   *        Ctor-selecting tag.</span></div>
<div class="line"><a id="l00559" name="l00559"></a><span class="lineno">  559</span><span class="comment">   * @param is_server</span></div>
<div class="line"><a id="l00560" name="l00560"></a><span class="lineno">  560</span><span class="comment">   *        See non-tag ctor form.</span></div>
<div class="line"><a id="l00561" name="l00561"></a><span class="lineno">  561</span><span class="comment">   */</span></div>
<div class="line"><a id="l00562" name="l00562"></a><span class="lineno">  562</span>  <span class="keyword">explicit</span> <a class="code hl_function" href="classipc_1_1transport_1_1struc_1_1sync__io_1_1Channel.html#a9385752ed00263dec5c5080b67ce0960">Channel</a>(flow::log::Logger* logger_ptr, <a class="code hl_typedef" href="classipc_1_1transport_1_1struc_1_1sync__io_1_1Channel.html#a4abac89dbd4d26c79b7915990f751a76">Owned_channel</a>&amp;&amp; channel,</div>
<div class="line"><a id="l00563" name="l00563"></a><span class="lineno">  563</span>                   <a class="code hl_struct" href="structipc_1_1transport_1_1struc_1_1Channel__base_1_1Serialize__via__heap.html">Serialize_via_heap</a> tag,</div>
<div class="line"><a id="l00564" name="l00564"></a><span class="lineno">  564</span>                   <span class="keywordtype">bool</span> is_server);</div>
<div class="line"><a id="l00565" name="l00565"></a><span class="lineno">  565</span><span class="comment"></span> </div>
<div class="line"><a id="l00566" name="l00566"></a><span class="lineno">  566</span><span class="comment">  /**</span></div>
<div class="line"><a id="l00567" name="l00567"></a><span class="lineno">  567</span><span class="comment">   * Tag version of non-tag, no-log-in ctor:</span></div>
<div class="line"><a id="l00568" name="l00568"></a><span class="lineno">  568</span><span class="comment">   * Serialize_via_session_shm (bidirectional SHM-based provider, zero-copy message serialization,</span></div>
<div class="line"><a id="l00569" name="l00569"></a><span class="lineno">  569</span><span class="comment">   * per-session-scope arena).</span></div>
<div class="line"><a id="l00570" name="l00570"></a><span class="lineno">  570</span><span class="comment">   *</span></div>
<div class="line"><a id="l00571" name="l00571"></a><span class="lineno">  571</span><span class="comment">   * @see Serialize_via_session_shm doc header for serialization-related background.</span></div>
<div class="line"><a id="l00572" name="l00572"></a><span class="lineno">  572</span><span class="comment">   * @see non-tag, no-log-in ctor.  As directed there, use the present form whenever sufficient, and indeed</span></div>
<div class="line"><a id="l00573" name="l00573"></a><span class="lineno">  573</span><span class="comment">   *      you want this type of serialization setup.  Consider also the other tag forms for other serialization</span></div>
<div class="line"><a id="l00574" name="l00574"></a><span class="lineno">  574</span><span class="comment">   *      methods which may match your requirements better.</span></div>
<div class="line"><a id="l00575" name="l00575"></a><span class="lineno">  575</span><span class="comment">   *</span></div>
<div class="line"><a id="l00576" name="l00576"></a><span class="lineno">  576</span><span class="comment">   * @tparam Session</span></div>
<div class="line"><a id="l00577" name="l00577"></a><span class="lineno">  577</span><span class="comment">   *         One of, at least:</span></div>
<div class="line"><a id="l00578" name="l00578"></a><span class="lineno">  578</span><span class="comment">   *         session::shm::classic::Client_session, session::shm::classic::Server_session,</span></div>
<div class="line"><a id="l00579" name="l00579"></a><span class="lineno">  579</span><span class="comment">   *         session::shm::arena_lend::jemalloc::Client_session, session::shm::arena_lend::jemalloc::Server_session.</span></div>
<div class="line"><a id="l00580" name="l00580"></a><span class="lineno">  580</span><span class="comment">   * @param logger_ptr</span></div>
<div class="line"><a id="l00581" name="l00581"></a><span class="lineno">  581</span><span class="comment">   *        See non-tag ctor form.</span></div>
<div class="line"><a id="l00582" name="l00582"></a><span class="lineno">  582</span><span class="comment">   * @param channel</span></div>
<div class="line"><a id="l00583" name="l00583"></a><span class="lineno">  583</span><span class="comment">   *        See non-tag ctor form.</span></div>
<div class="line"><a id="l00584" name="l00584"></a><span class="lineno">  584</span><span class="comment">   * @param tag</span></div>
<div class="line"><a id="l00585" name="l00585"></a><span class="lineno">  585</span><span class="comment">   *        Ctor-selecting tag.</span></div>
<div class="line"><a id="l00586" name="l00586"></a><span class="lineno">  586</span><span class="comment">   * @param session</span></div>
<div class="line"><a id="l00587" name="l00587"></a><span class="lineno">  587</span><span class="comment">   *        `session-&gt;session_shm()` shall be used as the backing SHM space.</span></div>
<div class="line"><a id="l00588" name="l00588"></a><span class="lineno">  588</span><span class="comment">   *        `*session` must be in PEER state, or behavior is undefined.</span></div>
<div class="line"><a id="l00589" name="l00589"></a><span class="lineno">  589</span><span class="comment">   * @param session_token_explicit</span></div>
<div class="line"><a id="l00590" name="l00590"></a><span class="lineno">  590</span><span class="comment">   *        See non-tag ctor form.  However, for convenience, if you instead supply value equal to</span></div>
<div class="line"><a id="l00591" name="l00591"></a><span class="lineno">  591</span><span class="comment">   *        `NULL_SESSION_TOKEN` (i.e., nil) (which is default), then `session-&gt;session_token()` shall</span></div>
<div class="line"><a id="l00592" name="l00592"></a><span class="lineno">  592</span><span class="comment">   *        be used.  After all... why not?  That&#39;s probably what you want.</span></div>
<div class="line"><a id="l00593" name="l00593"></a><span class="lineno">  593</span><span class="comment">   */</span></div>
<div class="line"><a id="l00594" name="l00594"></a><span class="lineno">  594</span>  <span class="keyword">template</span>&lt;<span class="keyword">typename</span> Session&gt;</div>
<div class="line"><a id="l00595" name="l00595"></a><span class="lineno">  595</span>  <span class="keyword">explicit</span> <a class="code hl_function" href="classipc_1_1transport_1_1struc_1_1sync__io_1_1Channel.html#a9385752ed00263dec5c5080b67ce0960">Channel</a>(flow::log::Logger* logger_ptr, <a class="code hl_typedef" href="classipc_1_1transport_1_1struc_1_1sync__io_1_1Channel.html#a4abac89dbd4d26c79b7915990f751a76">Owned_channel</a>&amp;&amp; channel,</div>
<div class="line"><a id="l00596" name="l00596"></a><span class="lineno">  596</span>                   <a class="code hl_struct" href="structipc_1_1transport_1_1struc_1_1Channel__base_1_1Serialize__via__session__shm.html">Serialize_via_session_shm</a> tag, Session* session,</div>
<div class="line"><a id="l00597" name="l00597"></a><span class="lineno">  597</span>                   <span class="keyword">const</span> <a class="code hl_typedef" href="namespaceipc_1_1transport_1_1struc.html#a6751c05fb6582a34c7c47ac470c4a48b">Session_token</a>&amp; session_token_explicit = <a class="code hl_variable" href="namespaceipc_1_1transport_1_1struc.html#ad556d20a2aa2d52b83c7afb73951d47d">NULL_SESSION_TOKEN</a>);</div>
<div class="line"><a id="l00598" name="l00598"></a><span class="lineno">  598</span><span class="comment"></span> </div>
<div class="line"><a id="l00599" name="l00599"></a><span class="lineno">  599</span><span class="comment">  /**</span></div>
<div class="line"><a id="l00600" name="l00600"></a><span class="lineno">  600</span><span class="comment">   * Tag version of non-tag, with-log-in ctor:</span></div>
<div class="line"><a id="l00601" name="l00601"></a><span class="lineno">  601</span><span class="comment">   * Serialize_via_session_shm (bidirectional SHM-based provider, zero-copy message serialization,</span></div>
<div class="line"><a id="l00602" name="l00602"></a><span class="lineno">  602</span><span class="comment">   * per-session-scope arena).</span></div>
<div class="line"><a id="l00603" name="l00603"></a><span class="lineno">  603</span><span class="comment">   *</span></div>
<div class="line"><a id="l00604" name="l00604"></a><span class="lineno">  604</span><span class="comment">   * @see Serialize_via_session_shm doc header for serialization-related background.</span></div>
<div class="line"><a id="l00605" name="l00605"></a><span class="lineno">  605</span><span class="comment">   * @see non-tag, no-log-in ctor.  As directed there, use the present form whenever sufficient, and indeed</span></div>
<div class="line"><a id="l00606" name="l00606"></a><span class="lineno">  606</span><span class="comment">   *      you want this type of serialization setup.  Consider also the other tag forms for other serialization</span></div>
<div class="line"><a id="l00607" name="l00607"></a><span class="lineno">  607</span><span class="comment">   *      methods which may match your requirements better.</span></div>
<div class="line"><a id="l00608" name="l00608"></a><span class="lineno">  608</span><span class="comment">   *</span></div>
<div class="line"><a id="l00609" name="l00609"></a><span class="lineno">  609</span><span class="comment">   * @tparam Session</span></div>
<div class="line"><a id="l00610" name="l00610"></a><span class="lineno">  610</span><span class="comment">   *         One of, at least:</span></div>
<div class="line"><a id="l00611" name="l00611"></a><span class="lineno">  611</span><span class="comment">   *         session::shm::classic::Client_session, session::shm::classic::Server_session,</span></div>
<div class="line"><a id="l00612" name="l00612"></a><span class="lineno">  612</span><span class="comment">   *         session::shm::arena_lend::jemalloc::Client_session, session::shm::arena_lend::jemalloc::Server_session.</span></div>
<div class="line"><a id="l00613" name="l00613"></a><span class="lineno">  613</span><span class="comment">   * @param logger_ptr</span></div>
<div class="line"><a id="l00614" name="l00614"></a><span class="lineno">  614</span><span class="comment">   *        See non-tag ctor form.</span></div>
<div class="line"><a id="l00615" name="l00615"></a><span class="lineno">  615</span><span class="comment">   * @param channel</span></div>
<div class="line"><a id="l00616" name="l00616"></a><span class="lineno">  616</span><span class="comment">   *        See non-tag ctor form.</span></div>
<div class="line"><a id="l00617" name="l00617"></a><span class="lineno">  617</span><span class="comment">   * @param tag</span></div>
<div class="line"><a id="l00618" name="l00618"></a><span class="lineno">  618</span><span class="comment">   *        Ctor-selecting tag.</span></div>
<div class="line"><a id="l00619" name="l00619"></a><span class="lineno">  619</span><span class="comment">   * @param session</span></div>
<div class="line"><a id="l00620" name="l00620"></a><span class="lineno">  620</span><span class="comment">   *        `session-&gt;session_shm()` shall be used as the backing SHM space.</span></div>
<div class="line"><a id="l00621" name="l00621"></a><span class="lineno">  621</span><span class="comment">   *        `*session` must be in PEER state, or behavior is undefined.</span></div>
<div class="line"><a id="l00622" name="l00622"></a><span class="lineno">  622</span><span class="comment">   * @param is_server</span></div>
<div class="line"><a id="l00623" name="l00623"></a><span class="lineno">  623</span><span class="comment">   *        See non-tag ctor form.</span></div>
<div class="line"><a id="l00624" name="l00624"></a><span class="lineno">  624</span><span class="comment">   */</span></div>
<div class="line"><a id="l00625" name="l00625"></a><span class="lineno">  625</span>  <span class="keyword">template</span>&lt;<span class="keyword">typename</span> Session&gt;</div>
<div class="line"><a id="l00626" name="l00626"></a><span class="lineno">  626</span>  <span class="keyword">explicit</span> <a class="code hl_function" href="classipc_1_1transport_1_1struc_1_1sync__io_1_1Channel.html#a9385752ed00263dec5c5080b67ce0960">Channel</a>(flow::log::Logger* logger_ptr, <a class="code hl_typedef" href="classipc_1_1transport_1_1struc_1_1sync__io_1_1Channel.html#a4abac89dbd4d26c79b7915990f751a76">Owned_channel</a>&amp;&amp; channel,</div>
<div class="line"><a id="l00627" name="l00627"></a><span class="lineno">  627</span>                   <a class="code hl_struct" href="structipc_1_1transport_1_1struc_1_1Channel__base_1_1Serialize__via__session__shm.html">Serialize_via_session_shm</a> tag, Session* session,</div>
<div class="line"><a id="l00628" name="l00628"></a><span class="lineno">  628</span>                   <span class="keywordtype">bool</span> is_server);</div>
<div class="line"><a id="l00629" name="l00629"></a><span class="lineno">  629</span><span class="comment"></span> </div>
<div class="line"><a id="l00630" name="l00630"></a><span class="lineno">  630</span><span class="comment">  /**</span></div>
<div class="line"><a id="l00631" name="l00631"></a><span class="lineno">  631</span><span class="comment">   * Tag version of non-tag, no-log-in ctor:</span></div>
<div class="line"><a id="l00632" name="l00632"></a><span class="lineno">  632</span><span class="comment">   * Serialize_via_app_shm (bidirectional SHM-based provider, zero-copy message serialization,</span></div>
<div class="line"><a id="l00633" name="l00633"></a><span class="lineno">  633</span><span class="comment">   * per-app-scope arena).</span></div>
<div class="line"><a id="l00634" name="l00634"></a><span class="lineno">  634</span><span class="comment">   *</span></div>
<div class="line"><a id="l00635" name="l00635"></a><span class="lineno">  635</span><span class="comment">   * @see Serialize_via_app_shm doc header for serialization-related background.</span></div>
<div class="line"><a id="l00636" name="l00636"></a><span class="lineno">  636</span><span class="comment">   * @see non-tag, no-log-in ctor.  As directed there, use the present form whenever sufficient, and indeed</span></div>
<div class="line"><a id="l00637" name="l00637"></a><span class="lineno">  637</span><span class="comment">   *      you want this type of serialization setup.  Consider also the other tag forms for other serialization</span></div>
<div class="line"><a id="l00638" name="l00638"></a><span class="lineno">  638</span><span class="comment">   *      methods which may match your requirements better.</span></div>
<div class="line"><a id="l00639" name="l00639"></a><span class="lineno">  639</span><span class="comment">   *</span></div>
<div class="line"><a id="l00640" name="l00640"></a><span class="lineno">  640</span><span class="comment">   * @tparam Session</span></div>
<div class="line"><a id="l00641" name="l00641"></a><span class="lineno">  641</span><span class="comment">   *         One of, at least:</span></div>
<div class="line"><a id="l00642" name="l00642"></a><span class="lineno">  642</span><span class="comment">   *         session::shm::classic::Client_session, session::shm::classic::Server_session,</span></div>
<div class="line"><a id="l00643" name="l00643"></a><span class="lineno">  643</span><span class="comment">   *         session::shm::arena_lend::jemalloc::Server_session (not</span></div>
<div class="line"><a id="l00644" name="l00644"></a><span class="lineno">  644</span><span class="comment">   *         session::shm::arena_lend::jemalloc::Client_session -- will not compile).</span></div>
<div class="line"><a id="l00645" name="l00645"></a><span class="lineno">  645</span><span class="comment">   * @param logger_ptr</span></div>
<div class="line"><a id="l00646" name="l00646"></a><span class="lineno">  646</span><span class="comment">   *        See non-tag ctor form.</span></div>
<div class="line"><a id="l00647" name="l00647"></a><span class="lineno">  647</span><span class="comment">   * @param channel</span></div>
<div class="line"><a id="l00648" name="l00648"></a><span class="lineno">  648</span><span class="comment">   *        See non-tag ctor form.</span></div>
<div class="line"><a id="l00649" name="l00649"></a><span class="lineno">  649</span><span class="comment">   * @param tag</span></div>
<div class="line"><a id="l00650" name="l00650"></a><span class="lineno">  650</span><span class="comment">   *        Ctor-selecting tag.</span></div>
<div class="line"><a id="l00651" name="l00651"></a><span class="lineno">  651</span><span class="comment">   * @param session</span></div>
<div class="line"><a id="l00652" name="l00652"></a><span class="lineno">  652</span><span class="comment">   *        `session-&gt;app_shm()` shall be used as the backing SHM space.</span></div>
<div class="line"><a id="l00653" name="l00653"></a><span class="lineno">  653</span><span class="comment">   *        `*session` must be in PEER state, or behavior is undefined.</span></div>
<div class="line"><a id="l00654" name="l00654"></a><span class="lineno">  654</span><span class="comment">   * @param session_token_explicit</span></div>
<div class="line"><a id="l00655" name="l00655"></a><span class="lineno">  655</span><span class="comment">   *        See `session_token_explicit` in the Serialize_via_session_shm counterpart to this ctor form.</span></div>
<div class="line"><a id="l00656" name="l00656"></a><span class="lineno">  656</span><span class="comment">   *        Spoiler alert: probably you&#39;ll want to leave this at default.</span></div>
<div class="line"><a id="l00657" name="l00657"></a><span class="lineno">  657</span><span class="comment">   */</span></div>
<div class="line"><a id="l00658" name="l00658"></a><span class="lineno">  658</span>  <span class="keyword">template</span>&lt;<span class="keyword">typename</span> Session&gt;</div>
<div class="line"><a id="l00659" name="l00659"></a><span class="lineno">  659</span>  <span class="keyword">explicit</span> <a class="code hl_function" href="classipc_1_1transport_1_1struc_1_1sync__io_1_1Channel.html#a9385752ed00263dec5c5080b67ce0960">Channel</a>(flow::log::Logger* logger_ptr, <a class="code hl_typedef" href="classipc_1_1transport_1_1struc_1_1sync__io_1_1Channel.html#a4abac89dbd4d26c79b7915990f751a76">Owned_channel</a>&amp;&amp; channel,</div>
<div class="line"><a id="l00660" name="l00660"></a><span class="lineno">  660</span>                   <a class="code hl_struct" href="structipc_1_1transport_1_1struc_1_1Channel__base_1_1Serialize__via__app__shm.html">Serialize_via_app_shm</a> tag, Session* session,</div>
<div class="line"><a id="l00661" name="l00661"></a><span class="lineno">  661</span>                   <span class="keyword">const</span> <a class="code hl_typedef" href="namespaceipc_1_1transport_1_1struc.html#a6751c05fb6582a34c7c47ac470c4a48b">Session_token</a>&amp; session_token_explicit = <a class="code hl_variable" href="namespaceipc_1_1transport_1_1struc.html#ad556d20a2aa2d52b83c7afb73951d47d">NULL_SESSION_TOKEN</a>);</div>
<div class="line"><a id="l00662" name="l00662"></a><span class="lineno">  662</span><span class="comment"></span> </div>
<div class="line"><a id="l00663" name="l00663"></a><span class="lineno">  663</span><span class="comment">  /**</span></div>
<div class="line"><a id="l00664" name="l00664"></a><span class="lineno">  664</span><span class="comment">   * Tag version of non-tag, no-log-in ctor:</span></div>
<div class="line"><a id="l00665" name="l00665"></a><span class="lineno">  665</span><span class="comment">   * Serialize_via_app_shm (bidirectional SHM-based provider, zero-copy message serialization,</span></div>
<div class="line"><a id="l00666" name="l00666"></a><span class="lineno">  666</span><span class="comment">   * per-app-scope arena).</span></div>
<div class="line"><a id="l00667" name="l00667"></a><span class="lineno">  667</span><span class="comment">   *</span></div>
<div class="line"><a id="l00668" name="l00668"></a><span class="lineno">  668</span><span class="comment">   * @see Serialize_via_app_shm doc header for serialization-related background.</span></div>
<div class="line"><a id="l00669" name="l00669"></a><span class="lineno">  669</span><span class="comment">   * @see non-tag, no-log-in ctor.  As directed there, use the present form whenever sufficient, and indeed</span></div>
<div class="line"><a id="l00670" name="l00670"></a><span class="lineno">  670</span><span class="comment">   *      you want this type of serialization setup.  Consider also the other tag forms for other serialization</span></div>
<div class="line"><a id="l00671" name="l00671"></a><span class="lineno">  671</span><span class="comment">   *      methods which may match your requirements better.</span></div>
<div class="line"><a id="l00672" name="l00672"></a><span class="lineno">  672</span><span class="comment">   *</span></div>
<div class="line"><a id="l00673" name="l00673"></a><span class="lineno">  673</span><span class="comment">   * @tparam Session</span></div>
<div class="line"><a id="l00674" name="l00674"></a><span class="lineno">  674</span><span class="comment">   *         One of, at least:</span></div>
<div class="line"><a id="l00675" name="l00675"></a><span class="lineno">  675</span><span class="comment">   *         session::shm::classic::Client_session, session::shm::classic::Server_session,</span></div>
<div class="line"><a id="l00676" name="l00676"></a><span class="lineno">  676</span><span class="comment">   *         session::shm::arena_lend::jemalloc::Server_session (not</span></div>
<div class="line"><a id="l00677" name="l00677"></a><span class="lineno">  677</span><span class="comment">   *         ession::shm::arena_lend::jemalloc::Client_session -- will not compile).</span></div>
<div class="line"><a id="l00678" name="l00678"></a><span class="lineno">  678</span><span class="comment">   * @param logger_ptr</span></div>
<div class="line"><a id="l00679" name="l00679"></a><span class="lineno">  679</span><span class="comment">   *        See non-tag ctor form.</span></div>
<div class="line"><a id="l00680" name="l00680"></a><span class="lineno">  680</span><span class="comment">   * @param channel</span></div>
<div class="line"><a id="l00681" name="l00681"></a><span class="lineno">  681</span><span class="comment">   *        See non-tag ctor form.</span></div>
<div class="line"><a id="l00682" name="l00682"></a><span class="lineno">  682</span><span class="comment">   * @param tag</span></div>
<div class="line"><a id="l00683" name="l00683"></a><span class="lineno">  683</span><span class="comment">   *        Ctor-selecting tag.</span></div>
<div class="line"><a id="l00684" name="l00684"></a><span class="lineno">  684</span><span class="comment">   * @param session</span></div>
<div class="line"><a id="l00685" name="l00685"></a><span class="lineno">  685</span><span class="comment">   *        `session-&gt;app_shm()` shall be used as the backing SHM space.</span></div>
<div class="line"><a id="l00686" name="l00686"></a><span class="lineno">  686</span><span class="comment">   *        `*session` must be in PEER state, or behavior is undefined.</span></div>
<div class="line"><a id="l00687" name="l00687"></a><span class="lineno">  687</span><span class="comment">   * @param is_server</span></div>
<div class="line"><a id="l00688" name="l00688"></a><span class="lineno">  688</span><span class="comment">   *        See non-tag ctor form.</span></div>
<div class="line"><a id="l00689" name="l00689"></a><span class="lineno">  689</span><span class="comment">   */</span></div>
<div class="line"><a id="l00690" name="l00690"></a><span class="lineno">  690</span>  <span class="keyword">template</span>&lt;<span class="keyword">typename</span> Session&gt;</div>
<div class="line"><a id="l00691" name="l00691"></a><span class="lineno">  691</span>  <span class="keyword">explicit</span> <a class="code hl_function" href="classipc_1_1transport_1_1struc_1_1sync__io_1_1Channel.html#a9385752ed00263dec5c5080b67ce0960">Channel</a>(flow::log::Logger* logger_ptr, <a class="code hl_typedef" href="classipc_1_1transport_1_1struc_1_1sync__io_1_1Channel.html#a4abac89dbd4d26c79b7915990f751a76">Owned_channel</a>&amp;&amp; channel,</div>
<div class="line"><a id="l00692" name="l00692"></a><span class="lineno">  692</span>                   <a class="code hl_struct" href="structipc_1_1transport_1_1struc_1_1Channel__base_1_1Serialize__via__app__shm.html">Serialize_via_app_shm</a> tag, Session* session,</div>
<div class="line"><a id="l00693" name="l00693"></a><span class="lineno">  693</span>                   <span class="keywordtype">bool</span> is_server);</div>
<div class="line"><a id="l00694" name="l00694"></a><span class="lineno">  694</span><span class="comment"></span> </div>
<div class="line"><a id="l00695" name="l00695"></a><span class="lineno">  695</span><span class="comment">  /**</span></div>
<div class="line"><a id="l00696" name="l00696"></a><span class="lineno">  696</span><span class="comment">   * Invokes the destructor on the #Owned_channel.</span></div>
<div class="line"><a id="l00697" name="l00697"></a><span class="lineno">  697</span><span class="comment">   *</span></div>
<div class="line"><a id="l00698" name="l00698"></a><span class="lineno">  698</span><span class="comment">   * Reminder: It is recommended, before invoking this destructor, to:</span></div>
<div class="line"><a id="l00699" name="l00699"></a><span class="lineno">  699</span><span class="comment">   *   - Call `async_end_sending(F)`.</span></div>
<div class="line"><a id="l00700" name="l00700"></a><span class="lineno">  700</span><span class="comment">   *   - Invoke this destructor once `F()` fires.</span></div>
<div class="line"><a id="l00701" name="l00701"></a><span class="lineno">  701</span><span class="comment">   *</span></div>
<div class="line"><a id="l00702" name="l00702"></a><span class="lineno">  702</span><span class="comment">   * See discussion in async_end_sending() doc header or shorter version in class doc header.</span></div>
<div class="line"><a id="l00703" name="l00703"></a><span class="lineno">  703</span><span class="comment">   */</span></div>
<div class="line"><a id="l00704" name="l00704"></a><span class="lineno">  704</span>  <a class="code hl_function" href="classipc_1_1transport_1_1struc_1_1sync__io_1_1Channel.html#aac7386bca503f1457d93c65e1bfdf71f">~Channel</a>();</div>
<div class="line"><a id="l00705" name="l00705"></a><span class="lineno">  705</span> </div>
<div class="line"><a id="l00706" name="l00706"></a><span class="lineno">  706</span>  <span class="comment">// Methods.</span></div>
<div class="line"><a id="l00707" name="l00707"></a><span class="lineno">  707</span><span class="comment"></span> </div>
<div class="line"><a id="l00708" name="l00708"></a><span class="lineno">  708</span><span class="comment">  /**</span></div>
<div class="line"><a id="l00709" name="l00709"></a><span class="lineno">  709</span><span class="comment">   * Analogous to transport::sync_io::Native_handle_sender::replace_event_wait_handles().</span></div>
<div class="line"><a id="l00710" name="l00710"></a><span class="lineno">  710</span><span class="comment">   *</span></div>
<div class="line"><a id="l00711" name="l00711"></a><span class="lineno">  711</span><span class="comment">   * @tparam Create_ev_wait_hndl_func</span></div>
<div class="line"><a id="l00712" name="l00712"></a><span class="lineno">  712</span><span class="comment">   *         See above.</span></div>
<div class="line"><a id="l00713" name="l00713"></a><span class="lineno">  713</span><span class="comment">   * @param create_ev_wait_hndl_func</span></div>
<div class="line"><a id="l00714" name="l00714"></a><span class="lineno">  714</span><span class="comment">   *        See above.</span></div>
<div class="line"><a id="l00715" name="l00715"></a><span class="lineno">  715</span><span class="comment">   * @return See above.</span></div>
<div class="line"><a id="l00716" name="l00716"></a><span class="lineno">  716</span><span class="comment">   */</span></div>
<div class="line"><a id="l00717" name="l00717"></a><span class="lineno">  717</span>  <span class="keyword">template</span>&lt;<span class="keyword">typename</span> Create_ev_wait_hndl_func&gt;</div>
<div class="line"><a id="l00718" name="l00718"></a><span class="lineno">  718</span>  <span class="keywordtype">bool</span> <a class="code hl_function" href="classipc_1_1transport_1_1struc_1_1sync__io_1_1Channel.html#a543aa806ec21b8550f9f440e59767d52">replace_event_wait_handles</a>(<span class="keyword">const</span> Create_ev_wait_hndl_func&amp; create_ev_wait_hndl_func);</div>
<div class="line"><a id="l00719" name="l00719"></a><span class="lineno">  719</span><span class="comment"></span> </div>
<div class="line"><a id="l00720" name="l00720"></a><span class="lineno">  720</span><span class="comment">  /**</span></div>
<div class="line"><a id="l00721" name="l00721"></a><span class="lineno">  721</span><span class="comment">   * Sets up the `sync_io`-pattern interaction between `*this` and the user&#39;s event loop; required before</span></div>
<div class="line"><a id="l00722" name="l00722"></a><span class="lineno">  722</span><span class="comment">   * async_accept() will work (as opposed to no-op/return `false`).</span></div>
<div class="line"><a id="l00723" name="l00723"></a><span class="lineno">  723</span><span class="comment">   *</span></div>
<div class="line"><a id="l00724" name="l00724"></a><span class="lineno">  724</span><span class="comment">   * `ev_wait_func()` -- with signature matching util::sync_io::Event_wait_func -- is a key function memorized</span></div>
<div class="line"><a id="l00725" name="l00725"></a><span class="lineno">  725</span><span class="comment">   * by `*this`.  It shall be invoked by `*this` operations when some op cannot complete synchronously and requires</span></div>
<div class="line"><a id="l00726" name="l00726"></a><span class="lineno">  726</span><span class="comment">   * a certain event (readable/writable) to be active on a certain native-handle.</span></div>
<div class="line"><a id="l00727" name="l00727"></a><span class="lineno">  727</span><span class="comment">   *</span></div>
<div class="line"><a id="l00728" name="l00728"></a><span class="lineno">  728</span><span class="comment">   * @see util::sync_io::Event_wait_func doc header for useful and complete instructions on how to write an</span></div>
<div class="line"><a id="l00729" name="l00729"></a><span class="lineno">  729</span><span class="comment">   *      `ev_wait_func()` properly.  Doing so correctly is the crux of using the `sync_io` pattern.</span></div>
<div class="line"><a id="l00730" name="l00730"></a><span class="lineno">  730</span><span class="comment">   *</span></div>
<div class="line"><a id="l00731" name="l00731"></a><span class="lineno">  731</span><span class="comment">   * This is a standard `sync_io`-pattern API per util::sync_io doc header.</span></div>
<div class="line"><a id="l00732" name="l00732"></a><span class="lineno">  732</span><span class="comment">   *</span></div>
<div class="line"><a id="l00733" name="l00733"></a><span class="lineno">  733</span><span class="comment">   * @tparam Event_wait_func_t</span></div>
<div class="line"><a id="l00734" name="l00734"></a><span class="lineno">  734</span><span class="comment">   *         Function type matching util::sync_io::Event_wait_func.</span></div>
<div class="line"><a id="l00735" name="l00735"></a><span class="lineno">  735</span><span class="comment">   * @param ev_wait_func</span></div>
<div class="line"><a id="l00736" name="l00736"></a><span class="lineno">  736</span><span class="comment">   *        See above.</span></div>
<div class="line"><a id="l00737" name="l00737"></a><span class="lineno">  737</span><span class="comment">   * @return `false` if this has already been invoked; no-op logging aside.  `true` otherwise.</span></div>
<div class="line"><a id="l00738" name="l00738"></a><span class="lineno">  738</span><span class="comment">   */</span></div>
<div class="line"><a id="l00739" name="l00739"></a><span class="lineno">  739</span>  <span class="keyword">template</span>&lt;<span class="keyword">typename</span> Event_wait_func_t&gt;</div>
<div class="line"><a id="l00740" name="l00740"></a><span class="lineno">  740</span>  <span class="keywordtype">bool</span> <a class="code hl_function" href="classipc_1_1transport_1_1struc_1_1sync__io_1_1Channel.html#a6e4f8c4207fcf678b4cfc785707d3dce">start_ops</a>(Event_wait_func_t&amp;&amp; ev_wait_func);</div>
<div class="line"><a id="l00741" name="l00741"></a><span class="lineno">  741</span><span class="comment"></span> </div>
<div class="line"><a id="l00742" name="l00742"></a><span class="lineno">  742</span><span class="comment">  /**</span></div>
<div class="line"><a id="l00743" name="l00743"></a><span class="lineno">  743</span><span class="comment">   * Permanently memorizes the incoming-direction on-error handler, thus authorizing the emission of any</span></div>
<div class="line"><a id="l00744" name="l00744"></a><span class="lineno">  744</span><span class="comment">   * in-messages (and/or an error) to handlers registered via this call, `expect_*()`, async_request(),</span></div>
<div class="line"><a id="l00745" name="l00745"></a><span class="lineno">  745</span><span class="comment">   * `set_*unexpected_response_handler()`; and *synchronously* executes any immediately relevant such handlers</span></div>
<div class="line"><a id="l00746" name="l00746"></a><span class="lineno">  746</span><span class="comment">   * due to pending in-traffic.</span></div>
<div class="line"><a id="l00747" name="l00747"></a><span class="lineno">  747</span><span class="comment">   *</span></div>
<div class="line"><a id="l00748" name="l00748"></a><span class="lineno">  748</span><span class="comment">   * To be clear: the caller must be ready for 0+ (potentially many) handlers to be synchronously invoked by</span></div>
<div class="line"><a id="l00749" name="l00749"></a><span class="lineno">  749</span><span class="comment">   * this call.  Even `on_err_func()` itself may be executed.  That said, recursive-mayhem is unlikely to be a concern,</span></div>
<div class="line"><a id="l00750" name="l00750"></a><span class="lineno">  750</span><span class="comment">   * since start_and_poll() itself is a one-time operation for a given `*this`.</span></div>
<div class="line"><a id="l00751" name="l00751"></a><span class="lineno">  751</span><span class="comment">   *</span></div>
<div class="line"><a id="l00752" name="l00752"></a><span class="lineno">  752</span><span class="comment">   * Until this is invoked, any incoming lower-level traffic is nevertheless saved in this process&#39;s or</span></div>
<div class="line"><a id="l00753" name="l00753"></a><span class="lineno">  753</span><span class="comment">   * opposing process&#39;s user RAM to be emitted as required by, and after, start_and_poll().  Therefore there is no</span></div>
<div class="line"><a id="l00754" name="l00754"></a><span class="lineno">  754</span><span class="comment">   * need to worry about in-traffic disappearing without a trace due to start_and_poll() being invoked too late.</span></div>
<div class="line"><a id="l00755" name="l00755"></a><span class="lineno">  755</span><span class="comment">   *</span></div>
<div class="line"><a id="l00756" name="l00756"></a><span class="lineno">  756</span><span class="comment">   * @tparam Task_err</span></div>
<div class="line"><a id="l00757" name="l00757"></a><span class="lineno">  757</span><span class="comment">   *         Handler type matching signature of `flow::async::Task_asio_err`.</span></div>
<div class="line"><a id="l00758" name="l00758"></a><span class="lineno">  758</span><span class="comment">   * @param on_err_func</span></div>
<div class="line"><a id="l00759" name="l00759"></a><span class="lineno">  759</span><span class="comment">   *        The permanent on-channel-hosed error handler.  See class doc header for discussion of error semantics.</span></div>
<div class="line"><a id="l00760" name="l00760"></a><span class="lineno">  760</span><span class="comment">   * @return `true` on success; `false` if start_ops() not yet called, or if already `start_and_poll()`ed, or if a</span></div>
<div class="line"><a id="l00761" name="l00761"></a><span class="lineno">  761</span><span class="comment">   *         prior error outgoing-direction error has hosed the owned Channel (then no-op).</span></div>
<div class="line"><a id="l00762" name="l00762"></a><span class="lineno">  762</span><span class="comment">   */</span></div>
<div class="line"><a id="l00763" name="l00763"></a><span class="lineno">  763</span>  <span class="keyword">template</span>&lt;<span class="keyword">typename</span> Task_err&gt;</div>
<div class="line"><a id="l00764" name="l00764"></a><span class="lineno">  764</span>  <span class="keywordtype">bool</span> <a class="code hl_function" href="classipc_1_1transport_1_1struc_1_1sync__io_1_1Channel.html#a0c00bab2dad604dde176c4190553915c">start_and_poll</a>(Task_err&amp;&amp; on_err_func);</div>
<div class="line"><a id="l00765" name="l00765"></a><span class="lineno">  765</span><span class="comment"></span> </div>
<div class="line"><a id="l00766" name="l00766"></a><span class="lineno">  766</span><span class="comment">  /**</span></div>
<div class="line"><a id="l00767" name="l00767"></a><span class="lineno">  767</span><span class="comment">   * See #Async_io_obj counterpart.</span></div>
<div class="line"><a id="l00768" name="l00768"></a><span class="lineno">  768</span><span class="comment">   * @return See above.</span></div>
<div class="line"><a id="l00769" name="l00769"></a><span class="lineno">  769</span><span class="comment">   */</span></div>
<div class="line"><a id="l00770" name="l00770"></a><span class="lineno">  770</span>  <span class="keyword">const</span> <a class="code hl_typedef" href="classipc_1_1transport_1_1struc_1_1sync__io_1_1Channel.html#a8a59bbc3c6a7191b316b23661d8ba6e3">Builder_config</a>&amp; <a class="code hl_function" href="classipc_1_1transport_1_1struc_1_1sync__io_1_1Channel.html#a48a8fd167c1fe6ae95d8fc80b6a6e67f">struct_builder_config</a>() <span class="keyword">const</span>;</div>
<div class="line"><a id="l00771" name="l00771"></a><span class="lineno">  771</span><span class="comment"></span> </div>
<div class="line"><a id="l00772" name="l00772"></a><span class="lineno">  772</span><span class="comment">  /**</span></div>
<div class="line"><a id="l00773" name="l00773"></a><span class="lineno">  773</span><span class="comment">   * See #Async_io_obj counterpart.</span></div>
<div class="line"><a id="l00774" name="l00774"></a><span class="lineno">  774</span><span class="comment">   * @return See above.</span></div>
<div class="line"><a id="l00775" name="l00775"></a><span class="lineno">  775</span><span class="comment">   */</span></div>
<div class="line"><a id="l00776" name="l00776"></a><span class="lineno">  776</span>  <span class="keyword">const</span> <span class="keyword">typename</span> Builder_config::Builder::Session&amp; <a class="code hl_function" href="classipc_1_1transport_1_1struc_1_1sync__io_1_1Channel.html#a43fa0b77781376edd13b742b832572e1">struct_lender_session</a>() <span class="keyword">const</span>;</div>
<div class="line"><a id="l00777" name="l00777"></a><span class="lineno">  777</span><span class="comment"></span> </div>
<div class="line"><a id="l00778" name="l00778"></a><span class="lineno">  778</span><span class="comment">  /**</span></div>
<div class="line"><a id="l00779" name="l00779"></a><span class="lineno">  779</span><span class="comment">   * See #Async_io_obj counterpart.</span></div>
<div class="line"><a id="l00780" name="l00780"></a><span class="lineno">  780</span><span class="comment">   * @return See above.</span></div>
<div class="line"><a id="l00781" name="l00781"></a><span class="lineno">  781</span><span class="comment">   */</span></div>
<div class="line"><a id="l00782" name="l00782"></a><span class="lineno">  782</span>  <span class="keyword">const</span> <a class="code hl_typedef" href="classipc_1_1transport_1_1struc_1_1sync__io_1_1Channel.html#a14a7166b2f8c117ce6ddafe943d036fa">Reader_config</a>&amp; <a class="code hl_function" href="classipc_1_1transport_1_1struc_1_1sync__io_1_1Channel.html#a7efbfbcce0d4d426b7df9b6d6fd1e373">struct_reader_config</a>() <span class="keyword">const</span>;</div>
<div class="line"><a id="l00783" name="l00783"></a><span class="lineno">  783</span><span class="comment"></span> </div>
<div class="line"><a id="l00784" name="l00784"></a><span class="lineno">  784</span><span class="comment">  /**</span></div>
<div class="line"><a id="l00785" name="l00785"></a><span class="lineno">  785</span><span class="comment">   * See #Async_io_obj counterpart.</span></div>
<div class="line"><a id="l00786" name="l00786"></a><span class="lineno">  786</span><span class="comment">   * @return See above.</span></div>
<div class="line"><a id="l00787" name="l00787"></a><span class="lineno">  787</span><span class="comment">   */</span></div>
<div class="line"><a id="l00788" name="l00788"></a><span class="lineno">  788</span>  <span class="keyword">const</span> <a class="code hl_typedef" href="classipc_1_1transport_1_1struc_1_1sync__io_1_1Channel.html#a4abac89dbd4d26c79b7915990f751a76">Owned_channel</a>&amp; <a class="code hl_function" href="classipc_1_1transport_1_1struc_1_1sync__io_1_1Channel.html#a759e1993bc61abb41380219b254ca410">owned_channel</a>() <span class="keyword">const</span>;</div>
<div class="line"><a id="l00789" name="l00789"></a><span class="lineno">  789</span><span class="comment"></span> </div>
<div class="line"><a id="l00790" name="l00790"></a><span class="lineno">  790</span><span class="comment">  /**</span></div>
<div class="line"><a id="l00791" name="l00791"></a><span class="lineno">  791</span><span class="comment">   * See #Async_io_obj counterpart.  Reminder: can be useful for `-&gt;auto_ping()` and `-&gt;idle_timer_run()`.</span></div>
<div class="line"><a id="l00792" name="l00792"></a><span class="lineno">  792</span><span class="comment">   * @return See above.</span></div>
<div class="line"><a id="l00793" name="l00793"></a><span class="lineno">  793</span><span class="comment">   */</span></div>
<div class="line"><a id="l00794" name="l00794"></a><span class="lineno">  794</span>  <a class="code hl_typedef" href="classipc_1_1transport_1_1struc_1_1sync__io_1_1Channel.html#a4abac89dbd4d26c79b7915990f751a76">Owned_channel</a>* <a class="code hl_function" href="classipc_1_1transport_1_1struc_1_1sync__io_1_1Channel.html#a9d97a5900bd517596b763db2d6b27b45">owned_channel_mutable</a>();</div>
<div class="line"><a id="l00795" name="l00795"></a><span class="lineno">  795</span><span class="comment"></span> </div>
<div class="line"><a id="l00796" name="l00796"></a><span class="lineno">  796</span><span class="comment">  /**</span></div>
<div class="line"><a id="l00797" name="l00797"></a><span class="lineno">  797</span><span class="comment">   * See #Async_io_obj counterpart.</span></div>
<div class="line"><a id="l00798" name="l00798"></a><span class="lineno">  798</span><span class="comment">   * @return See above.</span></div>
<div class="line"><a id="l00799" name="l00799"></a><span class="lineno">  799</span><span class="comment">   */</span></div>
<div class="line"><a id="l00800" name="l00800"></a><span class="lineno">  800</span>  <span class="keyword">const</span> <a class="code hl_typedef" href="namespaceipc_1_1transport_1_1struc.html#a6751c05fb6582a34c7c47ac470c4a48b">Session_token</a>&amp; <a class="code hl_function" href="classipc_1_1transport_1_1struc_1_1sync__io_1_1Channel.html#a021bb07a76c54837619c7a91dbd5de03">session_token</a>() <span class="keyword">const</span>;</div>
<div class="line"><a id="l00801" name="l00801"></a><span class="lineno">  801</span><span class="comment"></span> </div>
<div class="line"><a id="l00802" name="l00802"></a><span class="lineno">  802</span><span class="comment">  /**</span></div>
<div class="line"><a id="l00803" name="l00803"></a><span class="lineno">  803</span><span class="comment">   * See #Async_io_obj counterpart.</span></div>
<div class="line"><a id="l00804" name="l00804"></a><span class="lineno">  804</span><span class="comment">   *</span></div>
<div class="line"><a id="l00805" name="l00805"></a><span class="lineno">  805</span><span class="comment">   * @param hndl_or_null</span></div>
<div class="line"><a id="l00806" name="l00806"></a><span class="lineno">  806</span><span class="comment">   *        See above.</span></div>
<div class="line"><a id="l00807" name="l00807"></a><span class="lineno">  807</span><span class="comment">   * @return See above.</span></div>
<div class="line"><a id="l00808" name="l00808"></a><span class="lineno">  808</span><span class="comment">   */</span></div>
<div class="line"><a id="l00809" name="l00809"></a><span class="lineno">  809</span>  <a class="code hl_class" href="classipc_1_1transport_1_1struc_1_1Msg__out.html">Msg_out</a> <a class="code hl_function" href="classipc_1_1transport_1_1struc_1_1sync__io_1_1Channel.html#a426ecae27b4ea5cf7e666e56bad6afe5">create_msg</a>(<a class="code hl_struct" href="structipc_1_1util_1_1Native__handle.html">Native_handle</a>&amp;&amp; hndl_or_null = <a class="code hl_typedef" href="namespaceipc_1_1transport.html#a7ee4551983d9df16ec16a3139bac50e8">Native_handle</a>()) <span class="keyword">const</span>;</div>
<div class="line"><a id="l00810" name="l00810"></a><span class="lineno">  810</span><span class="comment"></span> </div>
<div class="line"><a id="l00811" name="l00811"></a><span class="lineno">  811</span><span class="comment">  /**</span></div>
<div class="line"><a id="l00812" name="l00812"></a><span class="lineno">  812</span><span class="comment">   * Registers the expectation (which may be immediately met) of up to 1 *notification* in-message</span></div>
<div class="line"><a id="l00813" name="l00813"></a><span class="lineno">  813</span><span class="comment">   * whose #Msg_which equals `which`.  No-op and return `false` if `which` is already being expected, if log-in phase</span></div>
<div class="line"><a id="l00814" name="l00814"></a><span class="lineno">  814</span><span class="comment">   * is not yet completed, or if a prior error has hosed the owned Channel.</span></div>
<div class="line"><a id="l00815" name="l00815"></a><span class="lineno">  815</span><span class="comment">   *</span></div>
<div class="line"><a id="l00816" name="l00816"></a><span class="lineno">  816</span><span class="comment">   * The expectation is unregistered upon receipt of the applicable in-message (and firing it with that in-message</span></div>
<div class="line"><a id="l00817" name="l00817"></a><span class="lineno">  817</span><span class="comment">   * #Msg_in_ptr as arg).  In addition:</span></div>
<div class="line"><a id="l00818" name="l00818"></a><span class="lineno">  818</span><span class="comment">   *</span></div>
<div class="line"><a id="l00819" name="l00819"></a><span class="lineno">  819</span><span class="comment">   * The 1 expected in-message may already be available synchronously.  In that case:</span></div>
<div class="line"><a id="l00820" name="l00820"></a><span class="lineno">  820</span><span class="comment">   *   - `*qd_msg` shall be loaded with that message; and it is purged from `*this`.  You must handle it as you see</span></div>
<div class="line"><a id="l00821" name="l00821"></a><span class="lineno">  821</span><span class="comment">   *     fit upon return from this method.</span></div>
<div class="line"><a id="l00822" name="l00822"></a><span class="lineno">  822</span><span class="comment">   *   - The expectation is immediately unregistered.</span></div>
<div class="line"><a id="l00823" name="l00823"></a><span class="lineno">  823</span><span class="comment">   *   - `on_msg_func` is ignored (it is not memorized).</span></div>
<div class="line"><a id="l00824" name="l00824"></a><span class="lineno">  824</span><span class="comment">   *</span></div>
<div class="line"><a id="l00825" name="l00825"></a><span class="lineno">  825</span><span class="comment">   * Therefore `on_msg_func()` can *only* execute upon a future `sync_io`-pattern async-wait firing its</span></div>
<div class="line"><a id="l00826" name="l00826"></a><span class="lineno">  826</span><span class="comment">   * `(*on_active_ev_func)()`.</span></div>
<div class="line"><a id="l00827" name="l00827"></a><span class="lineno">  827</span><span class="comment">   *</span></div>
<div class="line"><a id="l00828" name="l00828"></a><span class="lineno">  828</span><span class="comment">   * @tparam On_msg_handler</span></div>
<div class="line"><a id="l00829" name="l00829"></a><span class="lineno">  829</span><span class="comment">   *         Handler type for in-messages; see class doc header for in-message handling signature.</span></div>
<div class="line"><a id="l00830" name="l00830"></a><span class="lineno">  830</span><span class="comment">   * @param which</span></div>
<div class="line"><a id="l00831" name="l00831"></a><span class="lineno">  831</span><span class="comment">   *        Top-level #Msg_body union `which()` value to expect.</span></div>
<div class="line"><a id="l00832" name="l00832"></a><span class="lineno">  832</span><span class="comment">   * @param qd_msg</span></div>
<div class="line"><a id="l00833" name="l00833"></a><span class="lineno">  833</span><span class="comment">   *        `*qd_msg` is set to null if no message is immediately available; else set to that message (see above).</span></div>
<div class="line"><a id="l00834" name="l00834"></a><span class="lineno">  834</span><span class="comment">   * @param on_msg_func</span></div>
<div class="line"><a id="l00835" name="l00835"></a><span class="lineno">  835</span><span class="comment">   *        `on_msg_func(M)` shall be invoked in the manner explained in class doc header,</span></div>
<div class="line"><a id="l00836" name="l00836"></a><span class="lineno">  836</span><span class="comment">   *        on receipt of message with `which() == which`; unless it is immediately available and</span></div>
<div class="line"><a id="l00837" name="l00837"></a><span class="lineno">  837</span><span class="comment">   *        therefore loaded into `*qd_msg`.</span></div>
<div class="line"><a id="l00838" name="l00838"></a><span class="lineno">  838</span><span class="comment">   * @return `true` on success; `false` due to one of the above conditions.</span></div>
<div class="line"><a id="l00839" name="l00839"></a><span class="lineno">  839</span><span class="comment">   */</span></div>
<div class="line"><a id="l00840" name="l00840"></a><span class="lineno">  840</span>  <span class="keyword">template</span>&lt;<span class="keyword">typename</span> On_msg_handler&gt;</div>
<div class="line"><a id="l00841" name="l00841"></a><span class="lineno">  841</span>  <span class="keywordtype">bool</span> <a class="code hl_function" href="classipc_1_1transport_1_1struc_1_1sync__io_1_1Channel.html#a5fc489b9abefe5ab676f6991d6d03f0d">expect_msg</a>(<a class="code hl_typedef" href="classipc_1_1transport_1_1struc_1_1sync__io_1_1Channel.html#aa40c3ec3f45cdfea9360f7f35b9ade3c">Msg_which_in</a> which, <a class="code hl_typedef" href="classipc_1_1transport_1_1struc_1_1sync__io_1_1Channel.html#acde2b3866547a30958035203d9d89928">Msg_in_ptr</a>* qd_msg, On_msg_handler&amp;&amp; on_msg_func);</div>
<div class="line"><a id="l00842" name="l00842"></a><span class="lineno">  842</span><span class="comment"></span> </div>
<div class="line"><a id="l00843" name="l00843"></a><span class="lineno">  843</span><span class="comment">  /**</span></div>
<div class="line"><a id="l00844" name="l00844"></a><span class="lineno">  844</span><span class="comment">   * In log-in phase as server only: Registers the expectation (which may be immediately met) of up to 1</span></div>
<div class="line"><a id="l00845" name="l00845"></a><span class="lineno">  845</span><span class="comment">   * *log-in request* in-message whose #Msg_which equals `which`.  No-op and return `false` if</span></div>
<div class="line"><a id="l00846" name="l00846"></a><span class="lineno">  846</span><span class="comment">   * expect_log_in_request() has already been invoked, if log-in phase is</span></div>
<div class="line"><a id="l00847" name="l00847"></a><span class="lineno">  847</span><span class="comment">   * not active or active in the client role, or if a prior error has hosed the owned Channel.</span></div>
<div class="line"><a id="l00848" name="l00848"></a><span class="lineno">  848</span><span class="comment">   *</span></div>
<div class="line"><a id="l00849" name="l00849"></a><span class="lineno">  849</span><span class="comment">   * The expectation is unregistered upon receipt of the applicable in-message (and firing it with that in-message</span></div>
<div class="line"><a id="l00850" name="l00850"></a><span class="lineno">  850</span><span class="comment">   * #Msg_in_ptr as arg).  In addition:</span></div>
<div class="line"><a id="l00851" name="l00851"></a><span class="lineno">  851</span><span class="comment">   *</span></div>
<div class="line"><a id="l00852" name="l00852"></a><span class="lineno">  852</span><span class="comment">   * The 1 expected in-message may already be available synchronously.  In that case:</span></div>
<div class="line"><a id="l00853" name="l00853"></a><span class="lineno">  853</span><span class="comment">   *   - `*qd_msg` shall be loaded with that message; and it is purged from `*this`.  You must handle it as you see</span></div>
<div class="line"><a id="l00854" name="l00854"></a><span class="lineno">  854</span><span class="comment">   *     fit upon return from this method.</span></div>
<div class="line"><a id="l00855" name="l00855"></a><span class="lineno">  855</span><span class="comment">   *   - The expectation is immediately unregistered.</span></div>
<div class="line"><a id="l00856" name="l00856"></a><span class="lineno">  856</span><span class="comment">   *   - `on_log_in_req_func` is ignored (it is not memorized).</span></div>
<div class="line"><a id="l00857" name="l00857"></a><span class="lineno">  857</span><span class="comment">   *</span></div>
<div class="line"><a id="l00858" name="l00858"></a><span class="lineno">  858</span><span class="comment">   * Therefore `on_log_in_req_func()` can *only* execute upon a future `sync_io`-pattern async-wait firing its</span></div>
<div class="line"><a id="l00859" name="l00859"></a><span class="lineno">  859</span><span class="comment">   * `(*on_active_ev_func)()`.</span></div>
<div class="line"><a id="l00860" name="l00860"></a><span class="lineno">  860</span><span class="comment">   *</span></div>
<div class="line"><a id="l00861" name="l00861"></a><span class="lineno">  861</span><span class="comment">   * ### Tips ###</span></div>
<div class="line"><a id="l00862" name="l00862"></a><span class="lineno">  862</span><span class="comment">   * Informally the proper behavior is:</span></div>
<div class="line"><a id="l00863" name="l00863"></a><span class="lineno">  863</span><span class="comment">   *   -# Construct in log-in-as-server phase.</span></div>
<div class="line"><a id="l00864" name="l00864"></a><span class="lineno">  864</span><span class="comment">   *   -# Invoke expect_log_in_request().</span></div>
<div class="line"><a id="l00865" name="l00865"></a><span class="lineno">  865</span><span class="comment">   *   -# Await `on_log_in_req_func(X&amp;&amp;)` firing, or immediate delivery of `X` via `*qd_msg`,</span></div>
<div class="line"><a id="l00866" name="l00866"></a><span class="lineno">  866</span><span class="comment">   *      where X is the log-in request.</span></div>
<div class="line"><a id="l00867" name="l00867"></a><span class="lineno">  867</span><span class="comment">   *   -# After `on_log_in_req_func(X&amp;&amp;)` handler, or immediate delivery pf `X` via `*qd_msg`:</span></div>
<div class="line"><a id="l00868" name="l00868"></a><span class="lineno">  868</span><span class="comment">   *      check X for correctness (such as process identity checks).</span></div>
<div class="line"><a id="l00869" name="l00869"></a><span class="lineno">  869</span><span class="comment">   *      If it fails checks, destroy `*this`; else:</span></div>
<div class="line"><a id="l00870" name="l00870"></a><span class="lineno">  870</span><span class="comment">   *   -# Fill out `X = this-&gt;create_msg()` (the log-in response) as needed via `X-&gt;body_root()`.</span></div>
<div class="line"><a id="l00871" name="l00871"></a><span class="lineno">  871</span><span class="comment">   *   -# `send(X)`.  The latter automatically moves `*this` to logged-in phase locally: the bulk of the</span></div>
<div class="line"><a id="l00872" name="l00872"></a><span class="lineno">  872</span><span class="comment">   *      API becomes available.</span></div>
<div class="line"><a id="l00873" name="l00873"></a><span class="lineno">  873</span><span class="comment">   *</span></div>
<div class="line"><a id="l00874" name="l00874"></a><span class="lineno">  874</span><span class="comment">   * @tparam On_msg_handler</span></div>
<div class="line"><a id="l00875" name="l00875"></a><span class="lineno">  875</span><span class="comment">   *         See expect_msg().</span></div>
<div class="line"><a id="l00876" name="l00876"></a><span class="lineno">  876</span><span class="comment">   * @param which</span></div>
<div class="line"><a id="l00877" name="l00877"></a><span class="lineno">  877</span><span class="comment">   *        See expect_msg().</span></div>
<div class="line"><a id="l00878" name="l00878"></a><span class="lineno">  878</span><span class="comment">   * @param qd_msg</span></div>
<div class="line"><a id="l00879" name="l00879"></a><span class="lineno">  879</span><span class="comment">   *        See expect_msg().</span></div>
<div class="line"><a id="l00880" name="l00880"></a><span class="lineno">  880</span><span class="comment">   * @param on_log_in_req_func</span></div>
<div class="line"><a id="l00881" name="l00881"></a><span class="lineno">  881</span><span class="comment">   *        See above.</span></div>
<div class="line"><a id="l00882" name="l00882"></a><span class="lineno">  882</span><span class="comment">   * @return `true` on success; `false` due to one of the above conditions.</span></div>
<div class="line"><a id="l00883" name="l00883"></a><span class="lineno">  883</span><span class="comment">   */</span></div>
<div class="line"><a id="l00884" name="l00884"></a><span class="lineno">  884</span>  <span class="keyword">template</span>&lt;<span class="keyword">typename</span> On_msg_handler&gt;</div>
<div class="line"><a id="l00885" name="l00885"></a><span class="lineno">  885</span>  <span class="keywordtype">bool</span> <a class="code hl_function" href="classipc_1_1transport_1_1struc_1_1sync__io_1_1Channel.html#a996e06f75024e10987eb9cf62e096eec">expect_log_in_request</a>(<a class="code hl_typedef" href="classipc_1_1transport_1_1struc_1_1sync__io_1_1Channel.html#aa40c3ec3f45cdfea9360f7f35b9ade3c">Msg_which_in</a> which, <a class="code hl_typedef" href="classipc_1_1transport_1_1struc_1_1sync__io_1_1Channel.html#acde2b3866547a30958035203d9d89928">Msg_in_ptr</a>* qd_msg, On_msg_handler&amp;&amp; on_log_in_req_func);</div>
<div class="line"><a id="l00886" name="l00886"></a><span class="lineno">  886</span><span class="comment"></span> </div>
<div class="line"><a id="l00887" name="l00887"></a><span class="lineno">  887</span><span class="comment">  /**</span></div>
<div class="line"><a id="l00888" name="l00888"></a><span class="lineno">  888</span><span class="comment">   * Registers the expectation (some of which may be immediately met) of 0+ *notification* in-messages whose</span></div>
<div class="line"><a id="l00889" name="l00889"></a><span class="lineno">  889</span><span class="comment">   * #Msg_which equals `which`.  No-op and return `false` if `which` is already being expected, if log-in phase</span></div>
<div class="line"><a id="l00890" name="l00890"></a><span class="lineno">  890</span><span class="comment">   * is not yet completed, or if a prior error has hosed the owned Channel.</span></div>
<div class="line"><a id="l00891" name="l00891"></a><span class="lineno">  891</span><span class="comment">   *</span></div>
<div class="line"><a id="l00892" name="l00892"></a><span class="lineno">  892</span><span class="comment">   * The expectation is unregistered upon subsequent `undo_expect_msgs(which)`.</span></div>
<div class="line"><a id="l00893" name="l00893"></a><span class="lineno">  893</span><span class="comment">   *</span></div>
<div class="line"><a id="l00894" name="l00894"></a><span class="lineno">  894</span><span class="comment">   * 1+ expected in-messages may already be available synchronously.  In that case:</span></div>
<div class="line"><a id="l00895" name="l00895"></a><span class="lineno">  895</span><span class="comment">   *   - `*qd_msgs` is loaded with those messages; and they are purged from `*this`.  You must handle them as you</span></div>
<div class="line"><a id="l00896" name="l00896"></a><span class="lineno">  896</span><span class="comment">   *     see fit upon return from this method.</span></div>
<div class="line"><a id="l00897" name="l00897"></a><span class="lineno">  897</span><span class="comment">   *   - The expectation continues to be registered; `on_msg_func()` may be invoked in the future.</span></div>
<div class="line"><a id="l00898" name="l00898"></a><span class="lineno">  898</span><span class="comment">   *</span></div>
<div class="line"><a id="l00899" name="l00899"></a><span class="lineno">  899</span><span class="comment">   * Therefore `on_msg_func()` can *only* execute upon a future `sync_io`-pattern async-wait firing its</span></div>
<div class="line"><a id="l00900" name="l00900"></a><span class="lineno">  900</span><span class="comment">   * `(*on_active_ev_func)()`.</span></div>
<div class="line"><a id="l00901" name="l00901"></a><span class="lineno">  901</span><span class="comment">   *</span></div>
<div class="line"><a id="l00902" name="l00902"></a><span class="lineno">  902</span><span class="comment">   * @tparam On_msg_handler</span></div>
<div class="line"><a id="l00903" name="l00903"></a><span class="lineno">  903</span><span class="comment">   *         See expect_msg().</span></div>
<div class="line"><a id="l00904" name="l00904"></a><span class="lineno">  904</span><span class="comment">   * @param which</span></div>
<div class="line"><a id="l00905" name="l00905"></a><span class="lineno">  905</span><span class="comment">   *        See expect_msg().</span></div>
<div class="line"><a id="l00906" name="l00906"></a><span class="lineno">  906</span><span class="comment">   * @param qd_msgs</span></div>
<div class="line"><a id="l00907" name="l00907"></a><span class="lineno">  907</span><span class="comment">   *        `*qd_msgs` is cleared; then filled with any messages (possibly none) immediately available.</span></div>
<div class="line"><a id="l00908" name="l00908"></a><span class="lineno">  908</span><span class="comment">   * @param on_msg_func</span></div>
<div class="line"><a id="l00909" name="l00909"></a><span class="lineno">  909</span><span class="comment">   *        See above and expect_msg().</span></div>
<div class="line"><a id="l00910" name="l00910"></a><span class="lineno">  910</span><span class="comment">   * @return See expect_msg().</span></div>
<div class="line"><a id="l00911" name="l00911"></a><span class="lineno">  911</span><span class="comment">   */</span></div>
<div class="line"><a id="l00912" name="l00912"></a><span class="lineno">  912</span>  <span class="keyword">template</span>&lt;<span class="keyword">typename</span> On_msg_handler&gt;</div>
<div class="line"><a id="l00913" name="l00913"></a><span class="lineno">  913</span>  <span class="keywordtype">bool</span> <a class="code hl_function" href="classipc_1_1transport_1_1struc_1_1sync__io_1_1Channel.html#a62f52488ba20dd6c69dfc1abadb2d69f">expect_msgs</a>(<a class="code hl_typedef" href="classipc_1_1transport_1_1struc_1_1sync__io_1_1Channel.html#aa40c3ec3f45cdfea9360f7f35b9ade3c">Msg_which_in</a> which, <a class="code hl_typedef" href="classipc_1_1transport_1_1struc_1_1sync__io_1_1Channel.html#a4ab778bce8d7e6e84788879fedc62745">Msgs_in</a>* qd_msgs, On_msg_handler&amp;&amp; on_msg_func);</div>
<div class="line"><a id="l00914" name="l00914"></a><span class="lineno">  914</span><span class="comment"></span> </div>
<div class="line"><a id="l00915" name="l00915"></a><span class="lineno">  915</span><span class="comment">  /**</span></div>
<div class="line"><a id="l00916" name="l00916"></a><span class="lineno">  916</span><span class="comment">   * See #Async_io_obj counterpart.</span></div>
<div class="line"><a id="l00917" name="l00917"></a><span class="lineno">  917</span><span class="comment">   *</span></div>
<div class="line"><a id="l00918" name="l00918"></a><span class="lineno">  918</span><span class="comment">   * @param which</span></div>
<div class="line"><a id="l00919" name="l00919"></a><span class="lineno">  919</span><span class="comment">   *        See above.</span></div>
<div class="line"><a id="l00920" name="l00920"></a><span class="lineno">  920</span><span class="comment">   * @return See above.</span></div>
<div class="line"><a id="l00921" name="l00921"></a><span class="lineno">  921</span><span class="comment">   */</span></div>
<div class="line"><a id="l00922" name="l00922"></a><span class="lineno">  922</span>  <span class="keywordtype">bool</span> <a class="code hl_function" href="classipc_1_1transport_1_1struc_1_1sync__io_1_1Channel.html#ac8ba5f1a26a9f3e881b4871b0f6aa990">undo_expect_msgs</a>(<a class="code hl_typedef" href="classipc_1_1transport_1_1struc_1_1sync__io_1_1Channel.html#aa40c3ec3f45cdfea9360f7f35b9ade3c">Msg_which_in</a> which);</div>
<div class="line"><a id="l00923" name="l00923"></a><span class="lineno">  923</span><span class="comment"></span> </div>
<div class="line"><a id="l00924" name="l00924"></a><span class="lineno">  924</span><span class="comment">  /**</span></div>
<div class="line"><a id="l00925" name="l00925"></a><span class="lineno">  925</span><span class="comment">   * See #Async_io_obj counterpart.</span></div>
<div class="line"><a id="l00926" name="l00926"></a><span class="lineno">  926</span><span class="comment">   *</span></div>
<div class="line"><a id="l00927" name="l00927"></a><span class="lineno">  927</span><span class="comment">   * @param msg</span></div>
<div class="line"><a id="l00928" name="l00928"></a><span class="lineno">  928</span><span class="comment">   *        See above.</span></div>
<div class="line"><a id="l00929" name="l00929"></a><span class="lineno">  929</span><span class="comment">   * @param originating_msg_or_null</span></div>
<div class="line"><a id="l00930" name="l00930"></a><span class="lineno">  930</span><span class="comment">   *        See above.</span></div>
<div class="line"><a id="l00931" name="l00931"></a><span class="lineno">  931</span><span class="comment">   * @param err_code</span></div>
<div class="line"><a id="l00932" name="l00932"></a><span class="lineno">  932</span><span class="comment">   *        See above.</span></div>
<div class="line"><a id="l00933" name="l00933"></a><span class="lineno">  933</span><span class="comment">   * @return See above.  In addition `false` returned if called before start_ops().</span></div>
<div class="line"><a id="l00934" name="l00934"></a><span class="lineno">  934</span><span class="comment">   */</span></div>
<div class="line"><a id="l00935" name="l00935"></a><span class="lineno">  935</span>  <span class="keywordtype">bool</span> <a class="code hl_function" href="classipc_1_1transport_1_1struc_1_1sync__io_1_1Channel.html#a0dc388e18b0fc0fa2d8ad0a6953fb039">send</a>(<span class="keyword">const</span> <a class="code hl_class" href="classipc_1_1transport_1_1struc_1_1Msg__out.html">Msg_out</a>&amp; msg, <span class="keyword">const</span> <a class="code hl_class" href="classipc_1_1transport_1_1struc_1_1Msg__in.html">Msg_in</a>* originating_msg_or_null = 0, <a class="code hl_typedef" href="namespaceipc.html#aa3192e586cc45d3e7c22463bf2760f89">Error_code</a>* err_code = 0);</div>
<div class="line"><a id="l00936" name="l00936"></a><span class="lineno">  936</span><span class="comment"></span> </div>
<div class="line"><a id="l00937" name="l00937"></a><span class="lineno">  937</span><span class="comment">  /**</span></div>
<div class="line"><a id="l00938" name="l00938"></a><span class="lineno">  938</span><span class="comment">   * See #Async_io_obj counterpart; though naturally `on_rsp_func()` is invoked in the `sync_io`-pattern fashion.</span></div>
<div class="line"><a id="l00939" name="l00939"></a><span class="lineno">  939</span><span class="comment">   * There is no possibility of the response expectation being immediately (synchronously) met.</span></div>
<div class="line"><a id="l00940" name="l00940"></a><span class="lineno">  940</span><span class="comment">   *</span></div>
<div class="line"><a id="l00941" name="l00941"></a><span class="lineno">  941</span><span class="comment">   * @tparam On_msg_handler</span></div>
<div class="line"><a id="l00942" name="l00942"></a><span class="lineno">  942</span><span class="comment">   *         See expect_msg().</span></div>
<div class="line"><a id="l00943" name="l00943"></a><span class="lineno">  943</span><span class="comment">   * @param msg</span></div>
<div class="line"><a id="l00944" name="l00944"></a><span class="lineno">  944</span><span class="comment">   *        See above.</span></div>
<div class="line"><a id="l00945" name="l00945"></a><span class="lineno">  945</span><span class="comment">   * @param originating_msg_or_null</span></div>
<div class="line"><a id="l00946" name="l00946"></a><span class="lineno">  946</span><span class="comment">   *        See above.</span></div>
<div class="line"><a id="l00947" name="l00947"></a><span class="lineno">  947</span><span class="comment">   * @param id_unless_one_off</span></div>
<div class="line"><a id="l00948" name="l00948"></a><span class="lineno">  948</span><span class="comment">   *        See above.</span></div>
<div class="line"><a id="l00949" name="l00949"></a><span class="lineno">  949</span><span class="comment">   * @param on_rsp_func</span></div>
<div class="line"><a id="l00950" name="l00950"></a><span class="lineno">  950</span><span class="comment">   *        See above.</span></div>
<div class="line"><a id="l00951" name="l00951"></a><span class="lineno">  951</span><span class="comment">   * @param err_code</span></div>
<div class="line"><a id="l00952" name="l00952"></a><span class="lineno">  952</span><span class="comment">   *        See above.</span></div>
<div class="line"><a id="l00953" name="l00953"></a><span class="lineno">  953</span><span class="comment">   * @return See above.  In addition `false` returned if called before start_ops().</span></div>
<div class="line"><a id="l00954" name="l00954"></a><span class="lineno">  954</span><span class="comment">   */</span></div>
<div class="line"><a id="l00955" name="l00955"></a><span class="lineno">  955</span>  <span class="keyword">template</span>&lt;<span class="keyword">typename</span> On_msg_handler&gt;</div>
<div class="line"><a id="l00956" name="l00956"></a><span class="lineno">  956</span>  <span class="keywordtype">bool</span> <a class="code hl_function" href="classipc_1_1transport_1_1struc_1_1sync__io_1_1Channel.html#a26dc83067e005be38567199cbedd7f19">async_request</a>(<span class="keyword">const</span> <a class="code hl_class" href="classipc_1_1transport_1_1struc_1_1Msg__out.html">Msg_out</a>&amp; msg, <span class="keyword">const</span> <a class="code hl_class" href="classipc_1_1transport_1_1struc_1_1Msg__in.html">Msg_in</a>* originating_msg_or_null,</div>
<div class="line"><a id="l00957" name="l00957"></a><span class="lineno">  957</span>                     <a class="code hl_typedef" href="classipc_1_1transport_1_1struc_1_1Channel__base.html#adcf24fa51747ed83c4b6427fbf44fecf">msg_id_out_t</a>* id_unless_one_off, On_msg_handler&amp;&amp; on_rsp_func, <a class="code hl_typedef" href="namespaceipc.html#aa3192e586cc45d3e7c22463bf2760f89">Error_code</a>* err_code = 0);</div>
<div class="line"><a id="l00958" name="l00958"></a><span class="lineno">  958</span><span class="comment"></span> </div>
<div class="line"><a id="l00959" name="l00959"></a><span class="lineno">  959</span><span class="comment">  /**</span></div>
<div class="line"><a id="l00960" name="l00960"></a><span class="lineno">  960</span><span class="comment">   * See #Async_io_obj counterpart.</span></div>
<div class="line"><a id="l00961" name="l00961"></a><span class="lineno">  961</span><span class="comment">   *</span></div>
<div class="line"><a id="l00962" name="l00962"></a><span class="lineno">  962</span><span class="comment">   * @param originating_msg_id</span></div>
<div class="line"><a id="l00963" name="l00963"></a><span class="lineno">  963</span><span class="comment">   *        See above.</span></div>
<div class="line"><a id="l00964" name="l00964"></a><span class="lineno">  964</span><span class="comment">   * @return See above.</span></div>
<div class="line"><a id="l00965" name="l00965"></a><span class="lineno">  965</span><span class="comment">   */</span></div>
<div class="line"><a id="l00966" name="l00966"></a><span class="lineno">  966</span>  <span class="keywordtype">bool</span> <a class="code hl_function" href="classipc_1_1transport_1_1struc_1_1sync__io_1_1Channel.html#a5aae7a7f907f56fa07a230eadec2fedf">undo_expect_responses</a>(<a class="code hl_typedef" href="classipc_1_1transport_1_1struc_1_1Channel__base.html#adcf24fa51747ed83c4b6427fbf44fecf">msg_id_out_t</a> originating_msg_id);</div>
<div class="line"><a id="l00967" name="l00967"></a><span class="lineno">  967</span><span class="comment"></span> </div>
<div class="line"><a id="l00968" name="l00968"></a><span class="lineno">  968</span><span class="comment">  /**</span></div>
<div class="line"><a id="l00969" name="l00969"></a><span class="lineno">  969</span><span class="comment">   * See #Async_io_obj counterpart; though naturally `on_func()` is invoked in the `sync_io`-pattern fashion.</span></div>
<div class="line"><a id="l00970" name="l00970"></a><span class="lineno">  970</span><span class="comment">   *</span></div>
<div class="line"><a id="l00971" name="l00971"></a><span class="lineno">  971</span><span class="comment">   * @tparam On_unexpected_response_handler</span></div>
<div class="line"><a id="l00972" name="l00972"></a><span class="lineno">  972</span><span class="comment">   *         See above.</span></div>
<div class="line"><a id="l00973" name="l00973"></a><span class="lineno">  973</span><span class="comment">   * @param on_func</span></div>
<div class="line"><a id="l00974" name="l00974"></a><span class="lineno">  974</span><span class="comment">   *        See above.</span></div>
<div class="line"><a id="l00975" name="l00975"></a><span class="lineno">  975</span><span class="comment">   * @return See above.</span></div>
<div class="line"><a id="l00976" name="l00976"></a><span class="lineno">  976</span><span class="comment">   */</span></div>
<div class="line"><a id="l00977" name="l00977"></a><span class="lineno">  977</span>  <span class="keyword">template</span>&lt;<span class="keyword">typename</span> On_unexpected_response_handler&gt;</div>
<div class="line"><a id="l00978" name="l00978"></a><span class="lineno">  978</span>  <span class="keywordtype">bool</span> <a class="code hl_function" href="classipc_1_1transport_1_1struc_1_1sync__io_1_1Channel.html#a5c62d2a374a3a98e7fa0aef01bf8a774">set_unexpected_response_handler</a>(On_unexpected_response_handler&amp;&amp; on_func);</div>
<div class="line"><a id="l00979" name="l00979"></a><span class="lineno">  979</span><span class="comment"></span> </div>
<div class="line"><a id="l00980" name="l00980"></a><span class="lineno">  980</span><span class="comment">  /**</span></div>
<div class="line"><a id="l00981" name="l00981"></a><span class="lineno">  981</span><span class="comment">   * See #Async_io_obj counterpart.</span></div>
<div class="line"><a id="l00982" name="l00982"></a><span class="lineno">  982</span><span class="comment">   * @return See above.</span></div>
<div class="line"><a id="l00983" name="l00983"></a><span class="lineno">  983</span><span class="comment">   */</span></div>
<div class="line"><a id="l00984" name="l00984"></a><span class="lineno">  984</span>  <span class="keywordtype">bool</span> <a class="code hl_function" href="classipc_1_1transport_1_1struc_1_1sync__io_1_1Channel.html#a1f226e506cc5c04584e11480426b19da">unset_unexpected_response_handler</a>();</div>
<div class="line"><a id="l00985" name="l00985"></a><span class="lineno">  985</span><span class="comment"></span> </div>
<div class="line"><a id="l00986" name="l00986"></a><span class="lineno">  986</span><span class="comment">  /**</span></div>
<div class="line"><a id="l00987" name="l00987"></a><span class="lineno">  987</span><span class="comment">   * See #Async_io_obj counterpart; though naturally `on_func()` is invoked in the `sync_io`-pattern fashion.</span></div>
<div class="line"><a id="l00988" name="l00988"></a><span class="lineno">  988</span><span class="comment">   *</span></div>
<div class="line"><a id="l00989" name="l00989"></a><span class="lineno">  989</span><span class="comment">   * @tparam On_remote_unexpected_response_handler</span></div>
<div class="line"><a id="l00990" name="l00990"></a><span class="lineno">  990</span><span class="comment">   *         See above.</span></div>
<div class="line"><a id="l00991" name="l00991"></a><span class="lineno">  991</span><span class="comment">   * @param on_func</span></div>
<div class="line"><a id="l00992" name="l00992"></a><span class="lineno">  992</span><span class="comment">   *        See above.</span></div>
<div class="line"><a id="l00993" name="l00993"></a><span class="lineno">  993</span><span class="comment">   * @return See above.</span></div>
<div class="line"><a id="l00994" name="l00994"></a><span class="lineno">  994</span><span class="comment">   */</span></div>
<div class="line"><a id="l00995" name="l00995"></a><span class="lineno">  995</span>  <span class="keyword">template</span>&lt;<span class="keyword">typename</span> On_remote_unexpected_response_handler&gt;</div>
<div class="line"><a id="l00996" name="l00996"></a><span class="lineno">  996</span>  <span class="keywordtype">bool</span> <a class="code hl_function" href="classipc_1_1transport_1_1struc_1_1sync__io_1_1Channel.html#a3fda370cc97c89a62f77a6fcf639cfd7">set_remote_unexpected_response_handler</a>(On_remote_unexpected_response_handler&amp;&amp; on_func);</div>
<div class="line"><a id="l00997" name="l00997"></a><span class="lineno">  997</span><span class="comment"></span> </div>
<div class="line"><a id="l00998" name="l00998"></a><span class="lineno">  998</span><span class="comment">  /**</span></div>
<div class="line"><a id="l00999" name="l00999"></a><span class="lineno">  999</span><span class="comment">   * See #Async_io_obj counterpart.</span></div>
<div class="line"><a id="l01000" name="l01000"></a><span class="lineno"> 1000</span><span class="comment">   * @return See above.</span></div>
<div class="line"><a id="l01001" name="l01001"></a><span class="lineno"> 1001</span><span class="comment">   */</span></div>
<div class="line"><a id="l01002" name="l01002"></a><span class="lineno"> 1002</span>  <span class="keywordtype">bool</span> <a class="code hl_function" href="classipc_1_1transport_1_1struc_1_1sync__io_1_1Channel.html#a24382a751a2c03e00c5140c89aba2c62">unset_remote_unexpected_response_handler</a>();</div>
<div class="line"><a id="l01003" name="l01003"></a><span class="lineno"> 1003</span><span class="comment"></span> </div>
<div class="line"><a id="l01004" name="l01004"></a><span class="lineno"> 1004</span><span class="comment">  /**</span></div>
<div class="line"><a id="l01005" name="l01005"></a><span class="lineno"> 1005</span><span class="comment">   * See #Async_io_obj counterpart; except (1) naturally `on_done_func()` is invoked in the `sync_io`-pattern fashion,</span></div>
<div class="line"><a id="l01006" name="l01006"></a><span class="lineno"> 1006</span><span class="comment">   * and (2) the operation may (and is very likely to) complete synchronously and thus ignore `on_done_func`.</span></div>
<div class="line"><a id="l01007" name="l01007"></a><span class="lineno"> 1007</span><span class="comment">   *</span></div>
<div class="line"><a id="l01008" name="l01008"></a><span class="lineno"> 1008</span><span class="comment">   * @note It is highly recommended to read the #Async_io_obj transport::struc::Channel::async_end_sending()</span></div>
<div class="line"><a id="l01009" name="l01009"></a><span class="lineno"> 1009</span><span class="comment">   *       doc header&#39;s recommendations on how/when/why to use the method.</span></div>
<div class="line"><a id="l01010" name="l01010"></a><span class="lineno"> 1010</span><span class="comment">   *</span></div>
<div class="line"><a id="l01011" name="l01011"></a><span class="lineno"> 1011</span><span class="comment">   * The sync-versus-async-completion dichotomy is exactly forwarded from #Owned_channel, and you can read</span></div>
<div class="line"><a id="l01012" name="l01012"></a><span class="lineno"> 1012</span><span class="comment">   * the details in sync_io::Native_handle_sender::async_end_sending() doc header.</span></div>
<div class="line"><a id="l01013" name="l01013"></a><span class="lineno"> 1013</span><span class="comment">   *</span></div>
<div class="line"><a id="l01014" name="l01014"></a><span class="lineno"> 1014</span><span class="comment">   * @tparam Task_err</span></div>
<div class="line"><a id="l01015" name="l01015"></a><span class="lineno"> 1015</span><span class="comment">   *         See above.</span></div>
<div class="line"><a id="l01016" name="l01016"></a><span class="lineno"> 1016</span><span class="comment">   * @param sync_err_code</span></div>
<div class="line"><a id="l01017" name="l01017"></a><span class="lineno"> 1017</span><span class="comment">   *        See above.</span></div>
<div class="line"><a id="l01018" name="l01018"></a><span class="lineno"> 1018</span><span class="comment">   * @param on_done_func</span></div>
<div class="line"><a id="l01019" name="l01019"></a><span class="lineno"> 1019</span><span class="comment">   *        See above.</span></div>
<div class="line"><a id="l01020" name="l01020"></a><span class="lineno"> 1020</span><span class="comment">   * @return See above.  In addition `false` returned if called before start_ops().</span></div>
<div class="line"><a id="l01021" name="l01021"></a><span class="lineno"> 1021</span><span class="comment">   */</span></div>
<div class="line"><a id="l01022" name="l01022"></a><span class="lineno"> 1022</span>  <span class="keyword">template</span>&lt;<span class="keyword">typename</span> Task_err&gt;</div>
<div class="line"><a id="l01023" name="l01023"></a><span class="lineno"> 1023</span>  <span class="keywordtype">bool</span> <a class="code hl_function" href="classipc_1_1transport_1_1struc_1_1sync__io_1_1Channel.html#ae4a2a63dc88722d96ee9f3ed68cf7b86">async_end_sending</a>(<a class="code hl_typedef" href="namespaceipc.html#aa3192e586cc45d3e7c22463bf2760f89">Error_code</a>* sync_err_code, Task_err&amp;&amp; on_done_func);</div>
<div class="line"><a id="l01024" name="l01024"></a><span class="lineno"> 1024</span> </div>
<div class="line"><a id="l01025" name="l01025"></a><span class="lineno"> 1025</span><span class="keyword">private</span>:</div>
<div class="line"><a id="l01026" name="l01026"></a><span class="lineno"> 1026</span>  <span class="comment">// Types.</span></div>
<div class="line"><a id="l01027" name="l01027"></a><span class="lineno"> 1027</span><span class="comment"></span> </div>
<div class="line"><a id="l01028" name="l01028"></a><span class="lineno"> 1028</span><span class="comment">  /// Exact equivalent of #Msg_out but with the internal-use (intended for us!) interface exposed.</span></div>
<div class="line"><a id="l01029" name="l01029"></a><span class="lineno"><a class="line" href="classipc_1_1transport_1_1struc_1_1sync__io_1_1Channel.html#a984b6afa0f437c72aca5a1ba97f33a7f"> 1029</a></span><span class="comment"></span>  <span class="keyword">using </span><a class="code hl_class" href="classipc_1_1transport_1_1struc_1_1Msg__out__impl.html">Msg_out_impl</a> = <a class="code hl_class" href="classipc_1_1transport_1_1struc_1_1Msg__out__impl.html">struc::Msg_out_impl&lt;Msg_body, typename Builder_config::Builder&gt;</a>;</div>
<div class="line"><a id="l01030" name="l01030"></a><span class="lineno"> 1030</span><span class="comment"></span> </div>
<div class="line"><a id="l01031" name="l01031"></a><span class="lineno"> 1031</span><span class="comment">  /// Exact equivalent of #Msg_in but with the internal-use (intended for us!) interface exposed.</span></div>
<div class="line"><a id="l01032" name="l01032"></a><span class="lineno"><a class="line" href="classipc_1_1transport_1_1struc_1_1sync__io_1_1Channel.html#acb6922fb543bd544a2244412e4835e82"> 1032</a></span><span class="comment"></span>  <span class="keyword">using </span><a class="code hl_class" href="classipc_1_1transport_1_1struc_1_1Msg__in__impl.html">Msg_in_impl</a> = <a class="code hl_class" href="classipc_1_1transport_1_1struc_1_1Msg__in__impl.html">struc::Msg_in_impl&lt;Msg_body, Reader_config&gt;</a>;</div>
<div class="line"><a id="l01033" name="l01033"></a><span class="lineno"> 1033</span><span class="comment"></span> </div>
<div class="line"><a id="l01034" name="l01034"></a><span class="lineno"> 1034</span><span class="comment">  /**</span></div>
<div class="line"><a id="l01035" name="l01035"></a><span class="lineno"> 1035</span><span class="comment">   * Metadata message: internal-use out-message describing the associated #Msg_out; or describing/containing</span></div>
<div class="line"><a id="l01036" name="l01036"></a><span class="lineno"> 1036</span><span class="comment">   * internal message body (then not associated with a user-message).</span></div>
<div class="line"><a id="l01037" name="l01037"></a><span class="lineno"> 1037</span><span class="comment">   */</span></div>
<div class="line"><a id="l01038" name="l01038"></a><span class="lineno"><a class="line" href="classipc_1_1transport_1_1struc_1_1sync__io_1_1Channel.html#acbf3e5dbf6879e358f0596633e1428e0"> 1038</a></span>  <span class="keyword">using </span><a class="code hl_class" href="classipc_1_1transport_1_1struc_1_1Msg__mdt__out.html">Msg_mdt_out</a> = <a class="code hl_class" href="classipc_1_1transport_1_1struc_1_1Msg__mdt__out.html">struc::Msg_mdt_out&lt;Builder_config&gt;</a>;</div>
<div class="line"><a id="l01039" name="l01039"></a><span class="lineno"> 1039</span><span class="comment"></span> </div>
<div class="line"><a id="l01040" name="l01040"></a><span class="lineno"> 1040</span><span class="comment">  /// Clarifying short-hand for incoming-message IDs.</span></div>
<div class="line"><a id="l01041" name="l01041"></a><span class="lineno"><a class="line" href="classipc_1_1transport_1_1struc_1_1sync__io_1_1Channel.html#ad77261f31055f4151c70225c3fa1da2e"> 1041</a></span><span class="comment"></span>  <span class="keyword">using </span><a class="code hl_typedef" href="classipc_1_1transport_1_1struc_1_1sync__io_1_1Channel.html#ad77261f31055f4151c70225c3fa1da2e">msg_id_in_t</a> = <a class="code hl_typedef" href="namespaceipc_1_1transport_1_1struc.html#af7f35fc7588d97a838274fa25700ead9">msg_id_t</a>;</div>
<div class="line"><a id="l01042" name="l01042"></a><span class="lineno"> 1042</span><span class="comment"></span> </div>
<div class="line"><a id="l01043" name="l01043"></a><span class="lineno"> 1043</span><span class="comment">  /// Concrete type corresponding to `On_msg_handler` template param: in-message handler.</span></div>
<div class="line"><a id="l01044" name="l01044"></a><span class="lineno"><a class="line" href="classipc_1_1transport_1_1struc_1_1sync__io_1_1Channel.html#a26121a19c67c5bf5c338441502d9d6f7"> 1044</a></span><span class="comment"></span>  <span class="keyword">using </span><a class="code hl_typedef" href="classipc_1_1transport_1_1struc_1_1sync__io_1_1Channel.html#a26121a19c67c5bf5c338441502d9d6f7">On_msg_func</a> = <a class="code hl_typedef" href="namespaceipc.html#aa455c7f045059736578ca275fc1a851f">Function</a>&lt;void (<a class="code hl_typedef" href="classipc_1_1transport_1_1struc_1_1sync__io_1_1Channel.html#acde2b3866547a30958035203d9d89928">Msg_in_ptr</a>&amp;&amp; msg)&gt;;</div>
<div class="line"><a id="l01045" name="l01045"></a><span class="lineno"> 1045</span><span class="comment"></span> </div>
<div class="line"><a id="l01046" name="l01046"></a><span class="lineno"> 1046</span><span class="comment">  /// Ref-counted wrapper of #On_msg_func.</span></div>
<div class="line"><a id="l01047" name="l01047"></a><span class="lineno"><a class="line" href="classipc_1_1transport_1_1struc_1_1sync__io_1_1Channel.html#a583ccd4bb6b1aefb09d77e5709aef5b4"> 1047</a></span><span class="comment"></span>  <span class="keyword">using </span><a class="code hl_typedef" href="classipc_1_1transport_1_1struc_1_1sync__io_1_1Channel.html#a583ccd4bb6b1aefb09d77e5709aef5b4">On_msg_func_ptr</a> = boost::shared_ptr&lt;On_msg_func&gt;;</div>
<div class="line"><a id="l01048" name="l01048"></a><span class="lineno"> 1048</span><span class="comment"></span> </div>
<div class="line"><a id="l01049" name="l01049"></a><span class="lineno"> 1049</span><span class="comment">  /**</span></div>
<div class="line"><a id="l01050" name="l01050"></a><span class="lineno"> 1050</span><span class="comment">   * Concrete type corresponding to `On_unexpected_response_handler` template param</span></div>
<div class="line"><a id="l01051" name="l01051"></a><span class="lineno"> 1051</span><span class="comment">   * (see set_unexpected_response_handler()).</span></div>
<div class="line"><a id="l01052" name="l01052"></a><span class="lineno"> 1052</span><span class="comment">   */</span></div>
<div class="line"><a id="l01053" name="l01053"></a><span class="lineno"><a class="line" href="classipc_1_1transport_1_1struc_1_1sync__io_1_1Channel.html#abb3be9330a898ce542afd778d8e42a49"> 1053</a></span>  <span class="keyword">using </span><a class="code hl_typedef" href="classipc_1_1transport_1_1struc_1_1sync__io_1_1Channel.html#abb3be9330a898ce542afd778d8e42a49">On_unexpected_response_func</a> = <a class="code hl_typedef" href="namespaceipc.html#aa455c7f045059736578ca275fc1a851f">Function</a>&lt;void (<a class="code hl_typedef" href="classipc_1_1transport_1_1struc_1_1sync__io_1_1Channel.html#acde2b3866547a30958035203d9d89928">Msg_in_ptr</a>&amp;&amp; msg)&gt;;</div>
<div class="line"><a id="l01054" name="l01054"></a><span class="lineno"> 1054</span><span class="comment"></span> </div>
<div class="line"><a id="l01055" name="l01055"></a><span class="lineno"> 1055</span><span class="comment">  /**</span></div>
<div class="line"><a id="l01056" name="l01056"></a><span class="lineno"> 1056</span><span class="comment">   * Concrete type corresponding to `On_remote_unexpected_response_handler` template param</span></div>
<div class="line"><a id="l01057" name="l01057"></a><span class="lineno"> 1057</span><span class="comment">   * (see set_remote_unexpected_response_handler()).</span></div>
<div class="line"><a id="l01058" name="l01058"></a><span class="lineno"> 1058</span><span class="comment">   */</span></div>
<div class="line"><a id="l01059" name="l01059"></a><span class="lineno"><a class="line" href="classipc_1_1transport_1_1struc_1_1sync__io_1_1Channel.html#a86342fa9838aea7d49bbf3dd344445e2"> 1059</a></span>  <span class="keyword">using </span><a class="code hl_typedef" href="classipc_1_1transport_1_1struc_1_1sync__io_1_1Channel.html#a86342fa9838aea7d49bbf3dd344445e2">On_remote_unexpected_response_func</a> = <a class="code hl_typedef" href="namespaceipc.html#aa455c7f045059736578ca275fc1a851f">Function</a>&lt;void (<a class="code hl_typedef" href="classipc_1_1transport_1_1struc_1_1Channel__base.html#adcf24fa51747ed83c4b6427fbf44fecf">msg_id_out_t</a> msg_id_out,</div>
<div class="line"><a id="l01060" name="l01060"></a><span class="lineno"> 1060</span>                                                            std::string&amp;&amp; msg_metadata_text)&gt;;</div>
<div class="line"><a id="l01061" name="l01061"></a><span class="lineno"> 1061</span><span class="comment"></span> </div>
<div class="line"><a id="l01062" name="l01062"></a><span class="lineno"> 1062</span><span class="comment">  /// The state of `*this` (given start_ops() success); see #m_phase.</span></div>
<div class="line"><a id="l01063" name="l01063"></a><span class="lineno"><a class="line" href="classipc_1_1transport_1_1struc_1_1sync__io_1_1Channel.html#a5a3833cd141802041551db21198ac319"> 1063</a></span><span class="comment"></span>  <span class="keyword">enum class</span> <a class="code hl_enumeration" href="classipc_1_1transport_1_1struc_1_1sync__io_1_1Channel.html#a5a3833cd141802041551db21198ac319">Phase</a></div>
<div class="line"><a id="l01064" name="l01064"></a><span class="lineno"> 1064</span>  {<span class="comment"></span></div>
<div class="line"><a id="l01065" name="l01065"></a><span class="lineno"> 1065</span><span class="comment">    /**</span></div>
<div class="line"><a id="l01066" name="l01066"></a><span class="lineno"> 1066</span><span class="comment">     * Regular-operation phase: the general API (expect_msg(), etc.) is available.  Most `struc::Channel`s</span></div>
<div class="line"><a id="l01067" name="l01067"></a><span class="lineno"> 1067</span><span class="comment">     * begin in this phase, via ctor that takes `session_token_non_nil`.  This is the terminal phase.</span></div>
<div class="line"><a id="l01068" name="l01068"></a><span class="lineno"> 1068</span><span class="comment">     * Phases that lead to it are `S_SRV_LOG_IN` and `S_CLI_LOG_IN`.</span></div>
<div class="line"><a id="l01069" name="l01069"></a><span class="lineno"> 1069</span><span class="comment">     */</span></div>
<div class="line"><a id="l01070" name="l01070"></a><span class="lineno"> 1070</span>    S_LOGGED_IN,</div>
<div class="line"><a id="l01071" name="l01071"></a><span class="lineno"> 1071</span><span class="comment"></span> </div>
<div class="line"><a id="l01072" name="l01072"></a><span class="lineno"> 1072</span><span class="comment">    /**</span></div>
<div class="line"><a id="l01073" name="l01073"></a><span class="lineno"> 1073</span><span class="comment">     * Logging-in phase, as server process: The general API (expect_msg(), etc.) is unavailable; only</span></div>
<div class="line"><a id="l01074" name="l01074"></a><span class="lineno"> 1074</span><span class="comment">     * expect_log_in_request() and send() are available.  This is an initial phase for a *session master channel*,</span></div>
<div class="line"><a id="l01075" name="l01075"></a><span class="lineno"> 1075</span><span class="comment">     * via ctor that does not take `session_token_non_nil` and has `is_server == true`.  Leads to `S_LOGGED_IN`.</span></div>
<div class="line"><a id="l01076" name="l01076"></a><span class="lineno"> 1076</span><span class="comment">     */</span></div>
<div class="line"><a id="l01077" name="l01077"></a><span class="lineno"> 1077</span>    S_SRV_LOG_IN,</div>
<div class="line"><a id="l01078" name="l01078"></a><span class="lineno"> 1078</span><span class="comment"></span> </div>
<div class="line"><a id="l01079" name="l01079"></a><span class="lineno"> 1079</span><span class="comment">    /**</span></div>
<div class="line"><a id="l01080" name="l01080"></a><span class="lineno"> 1080</span><span class="comment">     * Logging-in phase, as client process: The general API (expect_msg(), etc.) is unavailable; only</span></div>
<div class="line"><a id="l01081" name="l01081"></a><span class="lineno"> 1081</span><span class="comment">     * create_msg() and send() (response-expecting form) are available.  This is an initial phase for</span></div>
<div class="line"><a id="l01082" name="l01082"></a><span class="lineno"> 1082</span><span class="comment">     * a *session master channel*, via ctor that does not take `session_token_non_nil` and has `is_server == false`.</span></div>
<div class="line"><a id="l01083" name="l01083"></a><span class="lineno"> 1083</span><span class="comment">     * Leads to `S_LOGGED_IN`.</span></div>
<div class="line"><a id="l01084" name="l01084"></a><span class="lineno"> 1084</span><span class="comment">     */</span></div>
<div class="line"><a id="l01085" name="l01085"></a><span class="lineno"> 1085</span>    S_CLI_LOG_IN</div>
<div class="line"><a id="l01086" name="l01086"></a><span class="lineno"> 1086</span>  }; <span class="comment">// enum class Phase</span></div>
<div class="line"><a id="l01087" name="l01087"></a><span class="lineno"> 1087</span><span class="comment"></span> </div>
<div class="line"><a id="l01088" name="l01088"></a><span class="lineno"> 1088</span><span class="comment">  /**</span></div>
<div class="line"><a id="l01089" name="l01089"></a><span class="lineno"> 1089</span><span class="comment">   * Policy for how to act upon receiving a response in-message that indicates its originating out-message is</span></div>
<div class="line"><a id="l01090" name="l01090"></a><span class="lineno"> 1090</span><span class="comment">   * the message associated with this object in #Expecting_response_map.</span></div>
<div class="line"><a id="l01091" name="l01091"></a><span class="lineno"> 1091</span><span class="comment">   */</span></div>
<div class="line"><a id="l01092" name="l01092"></a><span class="lineno"><a class="line" href="structipc_1_1transport_1_1struc_1_1sync__io_1_1Channel_1_1Expecting__response.html"> 1092</a></span>  <span class="keyword">struct </span><a class="code hl_struct" href="structipc_1_1transport_1_1struc_1_1sync__io_1_1Channel_1_1Expecting__response.html">Expecting_response</a></div>
<div class="line"><a id="l01093" name="l01093"></a><span class="lineno"> 1093</span>  {</div>
<div class="line"><a id="l01094" name="l01094"></a><span class="lineno"> 1094</span>    <span class="comment">// Types.</span></div>
<div class="line"><a id="l01095" name="l01095"></a><span class="lineno"> 1095</span><span class="comment"></span> </div>
<div class="line"><a id="l01096" name="l01096"></a><span class="lineno"> 1096</span><span class="comment">    /// Short-hand to cheap handle type.</span></div>
<div class="line"><a id="l01097" name="l01097"></a><span class="lineno"><a class="line" href="structipc_1_1transport_1_1struc_1_1sync__io_1_1Channel_1_1Expecting__response.html#a5f68a8c574bf52f8fce42ea01c564923"> 1097</a></span><span class="comment"></span>    <span class="keyword">using </span><a class="code hl_typedef" href="structipc_1_1transport_1_1struc_1_1sync__io_1_1Channel_1_1Expecting__response.html#a5f68a8c574bf52f8fce42ea01c564923">Ptr</a> = boost::movelib::unique_ptr&lt;Expecting_response&gt;;</div>
<div class="line"><a id="l01098" name="l01098"></a><span class="lineno"> 1098</span> </div>
<div class="line"><a id="l01099" name="l01099"></a><span class="lineno"> 1099</span>    <span class="comment">// Data.</span></div>
<div class="line"><a id="l01100" name="l01100"></a><span class="lineno"> 1100</span><span class="comment"></span> </div>
<div class="line"><a id="l01101" name="l01101"></a><span class="lineno"> 1101</span><span class="comment">    /**</span></div>
<div class="line"><a id="l01102" name="l01102"></a><span class="lineno"> 1102</span><span class="comment">     * `true` if receiving a response means request is satisfied; `false` if undo_expect_responses() must be invoked</span></div>
<div class="line"><a id="l01103" name="l01103"></a><span class="lineno"> 1103</span><span class="comment">     * to mark request satisfied.  This controls the mechanism by which an Expecting_response is removed</span></div>
<div class="line"><a id="l01104" name="l01104"></a><span class="lineno"> 1104</span><span class="comment">     * from the expected-responses map, freeing the non-zero RAM (at least) resource involved.</span></div>
<div class="line"><a id="l01105" name="l01105"></a><span class="lineno"> 1105</span><span class="comment">     */</span></div>
<div class="line"><a id="l01106" name="l01106"></a><span class="lineno"><a class="line" href="structipc_1_1transport_1_1struc_1_1sync__io_1_1Channel_1_1Expecting__response.html#a615b5613ac4e2bc93be88b8835e6a22c"> 1106</a></span>    <span class="keywordtype">bool</span> <a class="code hl_variable" href="structipc_1_1transport_1_1struc_1_1sync__io_1_1Channel_1_1Expecting__response.html#a615b5613ac4e2bc93be88b8835e6a22c">m_one_expected</a>;</div>
<div class="line"><a id="l01107" name="l01107"></a><span class="lineno"> 1107</span><span class="comment"></span> </div>
<div class="line"><a id="l01108" name="l01108"></a><span class="lineno"> 1108</span><span class="comment">    /**</span></div>
<div class="line"><a id="l01109" name="l01109"></a><span class="lineno"> 1109</span><span class="comment">     * The handler to invoke on receiving a response to the requesting #Msg_out (see send() response-expecting form).</span></div>
<div class="line"><a id="l01110" name="l01110"></a><span class="lineno"> 1110</span><span class="comment">     *</span></div>
<div class="line"><a id="l01111" name="l01111"></a><span class="lineno"> 1111</span><span class="comment">     * The `shared_ptr` wrapper is because in case of #m_one_expected being `false` we have to copy it when</span></div>
<div class="line"><a id="l01112" name="l01112"></a><span class="lineno"> 1112</span><span class="comment">     * `handlers_post()`ing; `move()` could destroy it (leave it `.empty()`) instead.</span></div>
<div class="line"><a id="l01113" name="l01113"></a><span class="lineno"> 1113</span><span class="comment">     */</span></div>
<div class="line"><a id="l01114" name="l01114"></a><span class="lineno"><a class="line" href="structipc_1_1transport_1_1struc_1_1sync__io_1_1Channel_1_1Expecting__response.html#a410ae0ef77010cfb5f90de9a90b25e92"> 1114</a></span>    <a class="code hl_typedef" href="classipc_1_1transport_1_1struc_1_1sync__io_1_1Channel.html#a583ccd4bb6b1aefb09d77e5709aef5b4">On_msg_func_ptr</a> <a class="code hl_variable" href="structipc_1_1transport_1_1struc_1_1sync__io_1_1Channel_1_1Expecting__response.html#a410ae0ef77010cfb5f90de9a90b25e92">m_on_msg_func</a>;</div>
<div class="line"><a id="l01115" name="l01115"></a><span class="lineno"> 1115</span>  }; <span class="comment">// struct Expecting_response</span></div>
<div class="line"><a id="l01116" name="l01116"></a><span class="lineno"> 1116</span><span class="comment"></span> </div>
<div class="line"><a id="l01117" name="l01117"></a><span class="lineno"> 1117</span><span class="comment">  /**</span></div>
<div class="line"><a id="l01118" name="l01118"></a><span class="lineno"> 1118</span><span class="comment">   * Policy for how to act upon receiving an in-message whose top-level-union #Msg_which_in `enum` equals the</span></div>
<div class="line"><a id="l01119" name="l01119"></a><span class="lineno"> 1119</span><span class="comment">   * #Msg_which_in associated with this object in #Expecting_msg_map.</span></div>
<div class="line"><a id="l01120" name="l01120"></a><span class="lineno"> 1120</span><span class="comment">   *</span></div>
<div class="line"><a id="l01121" name="l01121"></a><span class="lineno"> 1121</span><span class="comment">   * It is aliased to Expecting_response for brevity, since that `struct`&#39;s fields are easily reworked</span></div>
<div class="line"><a id="l01122" name="l01122"></a><span class="lineno"> 1122</span><span class="comment">   * to the present application.</span></div>
<div class="line"><a id="l01123" name="l01123"></a><span class="lineno"> 1123</span><span class="comment">   *   - `m_one_expected` is repurposed to apply to undo_expect_msgs().</span></div>
<div class="line"><a id="l01124" name="l01124"></a><span class="lineno"> 1124</span><span class="comment">   *   - `m_on_msg_func` is repurposed as the handler for a #Msg_which_in value (see expect_msg(), expect_msgs()).</span></div>
<div class="line"><a id="l01125" name="l01125"></a><span class="lineno"> 1125</span><span class="comment">   */</span></div>
<div class="line"><a id="l01126" name="l01126"></a><span class="lineno"><a class="line" href="classipc_1_1transport_1_1struc_1_1sync__io_1_1Channel.html#adccd6372c0284a7f3198ac00c0935002"> 1126</a></span>  <span class="keyword">using </span><a class="code hl_struct" href="structipc_1_1transport_1_1struc_1_1sync__io_1_1Channel_1_1Expecting__response.html">Expecting_msg</a> = <a class="code hl_struct" href="structipc_1_1transport_1_1struc_1_1sync__io_1_1Channel_1_1Expecting__response.html">Expecting_response</a>;</div>
<div class="line"><a id="l01127" name="l01127"></a><span class="lineno"> 1127</span><span class="comment"></span> </div>
<div class="line"><a id="l01128" name="l01128"></a><span class="lineno"> 1128</span><span class="comment">  /**</span></div>
<div class="line"><a id="l01129" name="l01129"></a><span class="lineno"> 1129</span><span class="comment">   * Table mapping originating out-message to the policy for handling an in-message that indicates that out-message</span></div>
<div class="line"><a id="l01130" name="l01130"></a><span class="lineno"> 1130</span><span class="comment">   * as the originating message (via message ID -- *after* the out-message is sent via send()).</span></div>
<div class="line"><a id="l01131" name="l01131"></a><span class="lineno"> 1131</span><span class="comment">   */</span></div>
<div class="line"><a id="l01132" name="l01132"></a><span class="lineno"><a class="line" href="classipc_1_1transport_1_1struc_1_1sync__io_1_1Channel.html#a3d4c8da3dd620d113479f5c6a3f96c3a"> 1132</a></span>  <span class="keyword">using </span><a class="code hl_typedef" href="classipc_1_1transport_1_1struc_1_1sync__io_1_1Channel.html#a3d4c8da3dd620d113479f5c6a3f96c3a">Expecting_response_map</a> = boost::unordered_map&lt;msg_id_out_t, typename Expecting_response::Ptr&gt;;</div>
<div class="line"><a id="l01133" name="l01133"></a><span class="lineno"> 1133</span><span class="comment"></span> </div>
<div class="line"><a id="l01134" name="l01134"></a><span class="lineno"> 1134</span><span class="comment">  /**</span></div>
<div class="line"><a id="l01135" name="l01135"></a><span class="lineno"> 1135</span><span class="comment">   * Table mapping in-message #Msg_which_in `enum` value to the policy for handling an in-message with that</span></div>
<div class="line"><a id="l01136" name="l01136"></a><span class="lineno"> 1136</span><span class="comment">   * `which()` value.</span></div>
<div class="line"><a id="l01137" name="l01137"></a><span class="lineno"> 1137</span><span class="comment">   */</span></div>
<div class="line"><a id="l01138" name="l01138"></a><span class="lineno"><a class="line" href="classipc_1_1transport_1_1struc_1_1sync__io_1_1Channel.html#a8d1ffe78546eb31fd41df6784a26868c"> 1138</a></span>  <span class="keyword">using </span><a class="code hl_typedef" href="classipc_1_1transport_1_1struc_1_1sync__io_1_1Channel.html#a8d1ffe78546eb31fd41df6784a26868c">Expecting_msg_map</a> = boost::unordered_map&lt;Msg_which_in, typename Expecting_msg::Ptr&gt;;</div>
<div class="line"><a id="l01139" name="l01139"></a><span class="lineno"> 1139</span><span class="comment"></span> </div>
<div class="line"><a id="l01140" name="l01140"></a><span class="lineno"> 1140</span><span class="comment">  /// Like #Msg_in_ptr but `unique_ptr` instead of `shared_ptr`.  Note the latter can upgrade-from a `move()`d former.</span></div>
<div class="line"><a id="l01141" name="l01141"></a><span class="lineno"><a class="line" href="classipc_1_1transport_1_1struc_1_1sync__io_1_1Channel.html#a84287334d14f54c97f7dbb0d5b04cca5"> 1141</a></span><span class="comment"></span>  <span class="keyword">using </span><a class="code hl_typedef" href="classipc_1_1transport_1_1struc_1_1sync__io_1_1Channel.html#a84287334d14f54c97f7dbb0d5b04cca5">Msg_in_ptr_uniq</a> = boost::movelib::unique_ptr&lt;Msg_in_impl&gt;;</div>
<div class="line"><a id="l01142" name="l01142"></a><span class="lineno"> 1142</span><span class="comment"></span> </div>
<div class="line"><a id="l01143" name="l01143"></a><span class="lineno"> 1143</span><span class="comment">  /// Short-hand for queue (FIFO) of in-messages.</span></div>
<div class="line"><a id="l01144" name="l01144"></a><span class="lineno"><a class="line" href="classipc_1_1transport_1_1struc_1_1sync__io_1_1Channel.html#a2eed5db328a8c45ab16a875617a172c7"> 1144</a></span><span class="comment"></span>  <span class="keyword">using </span><a class="code hl_typedef" href="classipc_1_1transport_1_1struc_1_1sync__io_1_1Channel.html#a2eed5db328a8c45ab16a875617a172c7">Msg_in_q</a> = std::queue&lt;Msg_in_ptr_uniq&gt;;</div>
<div class="line"><a id="l01145" name="l01145"></a><span class="lineno"> 1145</span><span class="comment"></span> </div>
<div class="line"><a id="l01146" name="l01146"></a><span class="lineno"> 1146</span><span class="comment">  /**</span></div>
<div class="line"><a id="l01147" name="l01147"></a><span class="lineno"> 1147</span><span class="comment">   * Reassembly queue type: &quot;queue&quot; of all in-messages with #msg_id_in_t exceeding #m_rcv_msg_next_id, sorted</span></div>
<div class="line"><a id="l01148" name="l01148"></a><span class="lineno"> 1148</span><span class="comment">   * in increasing order by that #msg_id_in_t (sequence #).  Relevant only if `Owned_channel::S_HAS_2_PIPES == true`.</span></div>
<div class="line"><a id="l01149" name="l01149"></a><span class="lineno"> 1149</span><span class="comment">   */</span></div>
<div class="line"><a id="l01150" name="l01150"></a><span class="lineno"><a class="line" href="classipc_1_1transport_1_1struc_1_1sync__io_1_1Channel.html#a26594894094e4fa03b3c1dacd2e0f351"> 1150</a></span>  <span class="keyword">using </span><a class="code hl_typedef" href="classipc_1_1transport_1_1struc_1_1sync__io_1_1Channel.html#a26594894094e4fa03b3c1dacd2e0f351">Reassembly_q</a> = std::map&lt;msg_id_in_t, Msg_in_ptr_uniq&gt;;</div>
<div class="line"><a id="l01151" name="l01151"></a><span class="lineno"> 1151</span><span class="comment"></span> </div>
<div class="line"><a id="l01152" name="l01152"></a><span class="lineno"> 1152</span><span class="comment">  /**</span></div>
<div class="line"><a id="l01153" name="l01153"></a><span class="lineno"> 1153</span><span class="comment">   * Data and policy with respect to receipt of the next/currently-incomplete in-message.  Depending on whether</span></div>
<div class="line"><a id="l01154" name="l01154"></a><span class="lineno"> 1154</span><span class="comment">   * 1 or 2 in-pipes are enabled in #Owned_channel, and in the former case what kind of in-pipe it is</span></div>
<div class="line"><a id="l01155" name="l01155"></a><span class="lineno"> 1155</span><span class="comment">   * (see Channel::S_HAS_BLOB_PIPE, Channel::S_HAS_NATIVE_HANDLE_PIPE, and similar), there</span></div>
<div class="line"><a id="l01156" name="l01156"></a><span class="lineno"> 1156</span><span class="comment">   * may be 1 or 2 of these objects (sets of policy + state) in `*this`.  See #m_rcv_pipes</span></div>
<div class="line"><a id="l01157" name="l01157"></a><span class="lineno"> 1157</span><span class="comment">   * (`std::optional` being used to permanently disable up to 1 of them) of this type.</span></div>
<div class="line"><a id="l01158" name="l01158"></a><span class="lineno"> 1158</span><span class="comment">   *</span></div>
<div class="line"><a id="l01159" name="l01159"></a><span class="lineno"> 1159</span><span class="comment">   * ### Algorithm/background ###</span></div>
<div class="line"><a id="l01160" name="l01160"></a><span class="lineno"> 1160</span><span class="comment">   * #Owned_channel, potentially being a Native_handle_receiver,</span></div>
<div class="line"><a id="l01161" name="l01161"></a><span class="lineno"> 1161</span><span class="comment">   * is possibly capable of receiving unstructured messages, each</span></div>
<div class="line"><a id="l01162" name="l01162"></a><span class="lineno"> 1162</span><span class="comment">   * message bearing a blob and, optionally, a #Native_handle.  Suppose the opposing peer wants to send</span></div>
<div class="line"><a id="l01163" name="l01163"></a><span class="lineno"> 1163</span><span class="comment">   * a structured message M, plus #Native_handle S.  The latter can just be sent in a single message.</span></div>
<div class="line"><a id="l01164" name="l01164"></a><span class="lineno"> 1164</span><span class="comment">   * The former (M) is serialized into 1 or 2+ RAM blobs (a/k/a segments in capnp parlance), depending on its</span></div>
<div class="line"><a id="l01165" name="l01165"></a><span class="lineno"> 1165</span><span class="comment">   * size.  This shall *always* be 1 if we are SHM-backed.</span></div>
<div class="line"><a id="l01166" name="l01166"></a><span class="lineno"> 1166</span><span class="comment">   *</span></div>
<div class="line"><a id="l01167" name="l01167"></a><span class="lineno"> 1167</span><span class="comment">   * Then: the whole structured message M + #Native_handle S shall be sent as:</span></div>
<div class="line"><a id="l01168" name="l01168"></a><span class="lineno"> 1168</span><span class="comment">   *   - 1 *lead* message containing mandatory metadata (containing notably the message ID); *and* S;</span></div>
<div class="line"><a id="l01169" name="l01169"></a><span class="lineno"> 1169</span><span class="comment">   *   - 1 *continuation* message containing the 1st segment serializing M itself;</span></div>
<div class="line"><a id="l01170" name="l01170"></a><span class="lineno"> 1170</span><span class="comment">   *   - 0+ further *continuation* messages serializing the rest of M.  (Usually 0; always 0 if SHM-backed.)</span></div>
<div class="line"><a id="l01171" name="l01171"></a><span class="lineno"> 1171</span><span class="comment">   *</span></div>
<div class="line"><a id="l01172" name="l01172"></a><span class="lineno"> 1172</span><span class="comment">   * There are also internal messages -- presumed rare.  These are represented by the 1st bullet point only:</span></div>
<div class="line"><a id="l01173" name="l01173"></a><span class="lineno"> 1173</span><span class="comment">   * there are no continuation messages at all.  The algorithm here operates, therefore, under the assumption</span></div>
<div class="line"><a id="l01174" name="l01174"></a><span class="lineno"> 1174</span><span class="comment">   * that each structured message = 1 lead message; plus 0+ continuation messages.  However in perf analysis</span></div>
<div class="line"><a id="l01175" name="l01175"></a><span class="lineno"> 1175</span><span class="comment">   * one should assume 1 continuation message, as most messages are user messages, and those usually are serializable</span></div>
<div class="line"><a id="l01176" name="l01176"></a><span class="lineno"> 1176</span><span class="comment">   * as 1 continuation message each.</span></div>
<div class="line"><a id="l01177" name="l01177"></a><span class="lineno"> 1177</span><span class="comment">   *</span></div>
<div class="line"><a id="l01178" name="l01178"></a><span class="lineno"> 1178</span><span class="comment">   * If M = just a lead message (internal-message case): then it is simply</span></div>
<div class="line"><a id="l01179" name="l01179"></a><span class="lineno"> 1179</span><span class="comment">   * sent in one unstructured message, received in a single async_receive_native_handle() call.  In this case</span></div>
<div class="line"><a id="l01180" name="l01180"></a><span class="lineno"> 1180</span><span class="comment">   * `m_incomplete_msg` is created just before that async-read, completed fully just upon completing that async-read,</span></div>
<div class="line"><a id="l01181" name="l01181"></a><span class="lineno"> 1181</span><span class="comment">   * and constructed/assigned again (and then the next async-read is executed).  S is S, and the internal-message</span></div>
<div class="line"><a id="l01182" name="l01182"></a><span class="lineno"> 1182</span><span class="comment">   * is deserialized from the 1 segment.  (As of this writing there never is an S paired with an internal message;</span></div>
<div class="line"><a id="l01183" name="l01183"></a><span class="lineno"> 1183</span><span class="comment">   * but to future-proof this let&#39;s assume it is possible.)</span></div>
<div class="line"><a id="l01184" name="l01184"></a><span class="lineno"> 1184</span><span class="comment">   *</span></div>
<div class="line"><a id="l01185" name="l01185"></a><span class="lineno"> 1185</span><span class="comment">   * Otherwise (user-message case): the sender shall send:</span></div>
<div class="line"><a id="l01186" name="l01186"></a><span class="lineno"> 1186</span><span class="comment">   *   -# *Lead* message (containing amother other things how many continuation messages are coming next; and S);</span></div>
<div class="line"><a id="l01187" name="l01187"></a><span class="lineno"> 1187</span><span class="comment">   *   -# 1+ *continuation* message(s), the first containing the first segment (blob); the rest (if any) containing</span></div>
<div class="line"><a id="l01188" name="l01188"></a><span class="lineno"> 1188</span><span class="comment">   *      the rest of them.  S is never paired with a continuation message.</span></div>
<div class="line"><a id="l01189" name="l01189"></a><span class="lineno"> 1189</span><span class="comment">   *</span></div>
<div class="line"><a id="l01190" name="l01190"></a><span class="lineno"> 1190</span><span class="comment">   * `m_incomplete_msg` shall store that state across the 2+ async-reads, up until the last of the N segments has</span></div>
<div class="line"><a id="l01191" name="l01191"></a><span class="lineno"> 1191</span><span class="comment">   * been received (then it is constructed/assigned again, and then the next async-read is executed).</span></div>
<div class="line"><a id="l01192" name="l01192"></a><span class="lineno"> 1192</span><span class="comment">   * As with the lead-message-only case, just before being replaced with a new one, `m_incomplete_msg` is fed into the</span></div>
<div class="line"><a id="l01193" name="l01193"></a><span class="lineno"> 1193</span><span class="comment">   * next layer within `*this`, where the structured message is fed to the user, etc.</span></div>
<div class="line"><a id="l01194" name="l01194"></a><span class="lineno"> 1194</span><span class="comment">   *</span></div>
<div class="line"><a id="l01195" name="l01195"></a><span class="lineno"> 1195</span><span class="comment">   * Which pipe is used for these 2+ messages?</span></div>
<div class="line"><a id="l01196" name="l01196"></a><span class="lineno"> 1196</span><span class="comment">   *   - If Channel::S_HAS_BLOB_PIPE_ONLY is `true`, it is a fatal error.  No #Native_handle can be transmitted.</span></div>
<div class="line"><a id="l01197" name="l01197"></a><span class="lineno"> 1197</span><span class="comment">   *   - If Channel::S_HAS_NATIVE_HANDLE_PIPE_ONLY is `true`, then naturally the handles pipe is used</span></div>
<div class="line"><a id="l01198" name="l01198"></a><span class="lineno"> 1198</span><span class="comment">   *     (Channel::async_receive_native_handle()) -- it&#39;s the only pipe available at any rate.</span></div>
<div class="line"><a id="l01199" name="l01199"></a><span class="lineno"> 1199</span><span class="comment">   *   - If Channel::S_HAS_2_PIPES is `true`, then:</span></div>
<div class="line"><a id="l01200" name="l01200"></a><span class="lineno"> 1200</span><span class="comment">   *     - The lead message is expected over the handles pipe (Channel::async_receive_native_handle()), as it&#39;s the</span></div>
<div class="line"><a id="l01201" name="l01201"></a><span class="lineno"> 1201</span><span class="comment">   *       only pipe capable of transporting S.</span></div>
<div class="line"><a id="l01202" name="l01202"></a><span class="lineno"> 1202</span><span class="comment">   *     - (Attn: subtlety!) The continuation messages are *also* expected over that pipe, even though</span></div>
<div class="line"><a id="l01203" name="l01203"></a><span class="lineno"> 1203</span><span class="comment">   *       the blobs pipe *is* capable of transporting these.  Why?  Answer: At this stage we&#39;re not dealing with</span></div>
<div class="line"><a id="l01204" name="l01204"></a><span class="lineno"> 1204</span><span class="comment">   *       the structured layer yet (pre-deserialization which isn&#39;t yet possible), so there are no sequence numbers.</span></div>
<div class="line"><a id="l01205" name="l01205"></a><span class="lineno"> 1205</span><span class="comment">   *       It would require absurd contraptions to distinguish a non-handle-bearing continuation message</span></div>
<div class="line"><a id="l01206" name="l01206"></a><span class="lineno"> 1206</span><span class="comment">   *       with a handle-bearing lead message from a non-handle-bearing lead message;</span></div>
<div class="line"><a id="l01207" name="l01207"></a><span class="lineno"> 1207</span><span class="comment">   *       to resolve races between the 2 parallel in-pipes; etc.  More on this around the to-do below.</span></div>
<div class="line"><a id="l01208" name="l01208"></a><span class="lineno"> 1208</span><span class="comment">   *</span></div>
<div class="line"><a id="l01209" name="l01209"></a><span class="lineno"> 1209</span><span class="comment">   * Now assume no #Native_handle S wants to be sent with M.  The serialization logic is all the same -- there&#39;s</span></div>
<div class="line"><a id="l01210" name="l01210"></a><span class="lineno"> 1210</span><span class="comment">   * just no S transmitted along with the lead message.  The transport media are different; as any pipe can</span></div>
<div class="line"><a id="l01211" name="l01211"></a><span class="lineno"> 1211</span><span class="comment">   * transmit these unstructured messages, not needing to transmit these strange native handle thingies.  So then</span></div>
<div class="line"><a id="l01212" name="l01212"></a><span class="lineno"> 1212</span><span class="comment">   * which pipe is used for these messages?</span></div>
<div class="line"><a id="l01213" name="l01213"></a><span class="lineno"> 1213</span><span class="comment">   *   - If Channel::S_HAS_BLOB_PIPE_ONLY is `true`, then naturally the blobs pipe is used -- being the only 1 avail.</span></div>
<div class="line"><a id="l01214" name="l01214"></a><span class="lineno"> 1214</span><span class="comment">   *   - If Channel::S_HAS_NATIVE_HANDLE_PIPE_ONLY is `true`, then the handles pipe is used -- being the only 1 avail</span></div>
<div class="line"><a id="l01215" name="l01215"></a><span class="lineno"> 1215</span><span class="comment">   *     (and perfectly capable of transmitting just-blobs).</span></div>
<div class="line"><a id="l01216" name="l01216"></a><span class="lineno"> 1216</span><span class="comment">   *   - If Channel::S_HAS_2_PIPES is `true`, then: Although either pipe *could* be used, we use the</span></div>
<div class="line"><a id="l01217" name="l01217"></a><span class="lineno"> 1217</span><span class="comment">   *     blobs pipe; the idea being that the only reason to configure both pipes in a Channel is for performance</span></div>
<div class="line"><a id="l01218" name="l01218"></a><span class="lineno"> 1218</span><span class="comment">   *     (certainly it doesn&#39;t make anything *simpler* after all), and since the handles-pipe alone was deemed</span></div>
<div class="line"><a id="l01219" name="l01219"></a><span class="lineno"> 1219</span><span class="comment">   *     insufficient, we&#39;ll reserve it for handle-bearing structured user messages only.</span></div>
<div class="line"><a id="l01220" name="l01220"></a><span class="lineno"> 1220</span><span class="comment">   *     - Perf caveat: Isn&#39;t it &quot;giving away&quot; perf to (for the sake of simplicity) send messages</span></div>
<div class="line"><a id="l01221" name="l01221"></a><span class="lineno"> 1221</span><span class="comment">   *       pertaining to sans-handle lead messages along the handles pipe (and not the blobs pipe)?</span></div>
<div class="line"><a id="l01222" name="l01222"></a><span class="lineno"> 1222</span><span class="comment">   *       Well, yes, at least a bit.  In practice every user message has a lead message -- the metadata-bearing</span></div>
<div class="line"><a id="l01223" name="l01223"></a><span class="lineno"> 1223</span><span class="comment">   *       one (with message ID, originating-message-if-any ID, etc.), and at least 1 continuation message</span></div>
<div class="line"><a id="l01224" name="l01224"></a><span class="lineno"> 1224</span><span class="comment">   *       (the actual user message -- plus, if the message is so big it can&#39;t fit into 1 segment, then more</span></div>
<div class="line"><a id="l01225" name="l01225"></a><span class="lineno"> 1225</span><span class="comment">   *       message(s) to carry the serialization).  (Let&#39;s assume usually there&#39;s only 1 continuation message:</span></div>
<div class="line"><a id="l01226" name="l01226"></a><span class="lineno"> 1226</span><span class="comment">   *       if too-big messages are common, much more impact-heavy perf measures are necessary anyway -- namely</span></div>
<div class="line"><a id="l01227" name="l01227"></a><span class="lineno"> 1227</span><span class="comment">   *       using SHM-aware serialization which will *never* transmit bulk data.  Those measures are available and</span></div>
<div class="line"><a id="l01228" name="l01228"></a><span class="lineno"> 1228</span><span class="comment">   *       encouraged!)  So typically, if the user message is indeed handle-bearing, we&#39;ll send the metadata</span></div>
<div class="line"><a id="l01229" name="l01229"></a><span class="lineno"> 1229</span><span class="comment">   *       pre-message along the handles pipe (with a handle) immediately followed by the user payload</span></div>
<div class="line"><a id="l01230" name="l01230"></a><span class="lineno"> 1230</span><span class="comment">   *       (without handle).  The user continuation message could indeed have been sent over the blobs pipe, so we</span></div>
<div class="line"><a id="l01231" name="l01231"></a><span class="lineno"> 1231</span><span class="comment">   *       are giving away a bit of perf with every message.  I (ygoldfel) simply did not deem this giveaway</span></div>
<div class="line"><a id="l01232" name="l01232"></a><span class="lineno"> 1232</span><span class="comment">   *       worth the complexity in the reassembly logic needed to compensate for this.  It could be something to</span></div>
<div class="line"><a id="l01233" name="l01233"></a><span class="lineno"> 1233</span><span class="comment">   *       look at when/if a perf deficit is identified, or we&#39;re doing a hardcore optimization pass at this code.</span></div>
<div class="line"><a id="l01234" name="l01234"></a><span class="lineno"> 1234</span><span class="comment">   *       (That said -- this only applies to handle-bearing user messages in the first place.  Further, again,</span></div>
<div class="line"><a id="l01235" name="l01235"></a><span class="lineno"> 1235</span><span class="comment">   *       we are talking about the low-level perf of copying small amounts of data after already being backed</span></div>
<div class="line"><a id="l01236" name="l01236"></a><span class="lineno"> 1236</span><span class="comment">   *       by SHM to essentially eliminate bulk copying.  Intuitively this should be minor in the big picture.)</span></div>
<div class="line"><a id="l01237" name="l01237"></a><span class="lineno"> 1237</span><span class="comment">   *       Here&#39;s the to-do:</span></div>
<div class="line"><a id="l01238" name="l01238"></a><span class="lineno"> 1238</span><span class="comment">   *</span></div>
<div class="line"><a id="l01239" name="l01239"></a><span class="lineno"> 1239</span><span class="comment">   * @todo Look into the algorithm documented in Channel::Msg_in_pipe wherein (with 2 pipes in the channel)</span></div>
<div class="line"><a id="l01240" name="l01240"></a><span class="lineno"> 1240</span><span class="comment">   * some low-level messages associated with handle-bearing user structured messages are sent over the (presumably</span></div>
<div class="line"><a id="l01241" name="l01241"></a><span class="lineno"> 1241</span><span class="comment">   * somewhat slower) handles pipe despite, themselves, not containing a native handle being transmitted.  See text just</span></div>
<div class="line"><a id="l01242" name="l01242"></a><span class="lineno"> 1242</span><span class="comment">   * above this to-do in the code.</span></div>
<div class="line"><a id="l01243" name="l01243"></a><span class="lineno"> 1243</span><span class="comment">   *</span></div>
<div class="line"><a id="l01244" name="l01244"></a><span class="lineno"> 1244</span><span class="comment">   * That describes what happens for each structured message M, paired with #Native_handle S -- or not paired with it.</span></div>
<div class="line"><a id="l01245" name="l01245"></a><span class="lineno"> 1245</span><span class="comment">   * So the question is how to make these possibilities work together.  Answer:</span></div>
<div class="line"><a id="l01246" name="l01246"></a><span class="lineno"> 1246</span><span class="comment">   *</span></div>
<div class="line"><a id="l01247" name="l01247"></a><span class="lineno"> 1247</span><span class="comment">   * To get this to work, depending entirely on `Channel::S_HAS_*`, there are 1 or 2 `Msg_in_pipe`s:</span></div>
<div class="line"><a id="l01248" name="l01248"></a><span class="lineno"> 1248</span><span class="comment">   * #m_rcv_pipes, each one&#39;s Msg_in_pipe::m_lead_msg_mode (which is `const`!)</span></div>
<div class="line"><a id="l01249" name="l01249"></a><span class="lineno"> 1249</span><span class="comment">   * determining (1) which `async_receive_*()` API will be called; and (2) how the async non-error</span></div>
<div class="line"><a id="l01250" name="l01250"></a><span class="lineno"> 1250</span><span class="comment">   * result will be handled.  (See start_and_poll() where this is kicked off for the first time,</span></div>
<div class="line"><a id="l01251" name="l01251"></a><span class="lineno"> 1251</span><span class="comment">   * meaning each of the 2 `Msg_in_pipe`s is cted, setting #m_lead_msg_mode forever.)</span></div>
<div class="line"><a id="l01252" name="l01252"></a><span class="lineno"> 1252</span><span class="comment">   *   - For a given Msg_in_pipe: when no incomplete message is in-progress (such as the start of `*this`):</span></div>
<div class="line"><a id="l01253" name="l01253"></a><span class="lineno"> 1253</span><span class="comment">   *     create empty structured #Msg_in (assign to `m_incomplete_msg`), do the appropriate</span></div>
<div class="line"><a id="l01254" name="l01254"></a><span class="lineno"> 1254</span><span class="comment">   *     `m_channel.async_receive_*()`; then when it async-yields result store the first segment blob</span></div>
<div class="line"><a id="l01255" name="l01255"></a><span class="lineno"> 1255</span><span class="comment">   *     in it (and native handle if any).  If no more segments</span></div>
<div class="line"><a id="l01256" name="l01256"></a><span class="lineno"> 1256</span><span class="comment">   *     are expected for this structured message, done (`*m_incomplete_msg` can be fed to the next layer).</span></div>
<div class="line"><a id="l01257" name="l01257"></a><span class="lineno"> 1257</span><span class="comment">   *     Repeat this bullet point (create new #Msg_in, async-read, etc.).  Otherwise:</span></div>
<div class="line"><a id="l01258" name="l01258"></a><span class="lineno"> 1258</span><span class="comment">   *   - `m_incomplete_msg` stays (it is still incomplete).  `m_channel.async_receive_blob()` (meaning expect</span></div>
<div class="line"><a id="l01259" name="l01259"></a><span class="lineno"> 1259</span><span class="comment">   *     an unstructured continuation in-message, and if it somehow includes a #Native_handle, then it&#39;s a low-level</span></div>
<div class="line"><a id="l01260" name="l01260"></a><span class="lineno"> 1260</span><span class="comment">   *     `Channel`-hosing error).  When it async-yields result, add it to the structured message</span></div>
<div class="line"><a id="l01261" name="l01261"></a><span class="lineno"> 1261</span><span class="comment">   *     #Msg_in #m_incomplete_msg.  Repeat this bullet point until it is completed, at which point</span></div>
<div class="line"><a id="l01262" name="l01262"></a><span class="lineno"> 1262</span><span class="comment">   *     done -- #m_incomplete_msg can be fed to the next layer; back to the preceding bullet point</span></div>
<div class="line"><a id="l01263" name="l01263"></a><span class="lineno"> 1263</span><span class="comment">   *     (create new #Msg_in, async-read, etc.).</span></div>
<div class="line"><a id="l01264" name="l01264"></a><span class="lineno"> 1264</span><span class="comment">   *</span></div>
<div class="line"><a id="l01265" name="l01265"></a><span class="lineno"> 1265</span><span class="comment">   * If `Owned_channel::S_HAS_2_PIPES`, then 2 `async_receive_*()`s are possible simultaneously,</span></div>
<div class="line"><a id="l01266" name="l01266"></a><span class="lineno"> 1266</span><span class="comment">   * and there are indeed 2x Msg_in_pipe in `*this`; one for</span></div>
<div class="line"><a id="l01267" name="l01267"></a><span class="lineno"> 1267</span><span class="comment">   * just blobs (Msg_in_pipe::S_RCV_SANS_HNDL_ONLY), one for just blob-and-handle combos</span></div>
<div class="line"><a id="l01268" name="l01268"></a><span class="lineno"> 1268</span><span class="comment">   * (Msg_in_pipe::S_RCV_WITH_HNDL_ELSE_ERROR).  They can be interleaved.</span></div>
<div class="line"><a id="l01269" name="l01269"></a><span class="lineno"> 1269</span><span class="comment">   * Otherwise there&#39;s only 1 Msg_in_pipe, namely:</span></div>
<div class="line"><a id="l01270" name="l01270"></a><span class="lineno"> 1270</span><span class="comment">   *   - If the 1 pipe is blobs-only, `Owned_channel::S_HAS_BLOB_PIPE_ONLY`: it&#39;s, obviously, for just</span></div>
<div class="line"><a id="l01271" name="l01271"></a><span class="lineno"> 1271</span><span class="comment">   *     blobs (Msg_in_pipe::S_RCV_SANS_HNDL_ONLY).</span></div>
<div class="line"><a id="l01272" name="l01272"></a><span class="lineno"> 1272</span><span class="comment">   *   - If the 1 pipe is blobs-and-handles, `Owned_channel::S_HAS_NATIVE_HANDLE_PIPE_ONLY`: it&#39;s for</span></div>
<div class="line"><a id="l01273" name="l01273"></a><span class="lineno"> 1273</span><span class="comment">   *     both types of messages (Msg_in_pipe::S_RCV_WITH_OR_SANS_HNDL_DEMUX).</span></div>
<div class="line"><a id="l01274" name="l01274"></a><span class="lineno"> 1274</span><span class="comment">   */</span></div>
<div class="line"><a id="l01275" name="l01275"></a><span class="lineno"><a class="line" href="structipc_1_1transport_1_1struc_1_1sync__io_1_1Channel_1_1Msg__in__pipe.html"> 1275</a></span>  <span class="keyword">struct </span><a class="code hl_struct" href="structipc_1_1transport_1_1struc_1_1sync__io_1_1Channel_1_1Msg__in__pipe.html">Msg_in_pipe</a></div>
<div class="line"><a id="l01276" name="l01276"></a><span class="lineno"> 1276</span>  {</div>
<div class="line"><a id="l01277" name="l01277"></a><span class="lineno"> 1277</span>    <span class="comment">// Data.</span></div>
<div class="line"><a id="l01278" name="l01278"></a><span class="lineno"> 1278</span><span class="comment"></span> </div>
<div class="line"><a id="l01279" name="l01279"></a><span class="lineno"> 1279</span><span class="comment">    /**</span></div>
<div class="line"><a id="l01280" name="l01280"></a><span class="lineno"> 1280</span><span class="comment">     * The immutable mode of behavior along this pipe, which must be enabled: Whether to use</span></div>
<div class="line"><a id="l01281" name="l01281"></a><span class="lineno"> 1281</span><span class="comment">     * Native_handle_receiver::async_receive_native_handle() or Blob_receiver::async_receive_blob();</span></div>
<div class="line"><a id="l01282" name="l01282"></a><span class="lineno"> 1282</span><span class="comment">     * and what to accept/do on receipt.</span></div>
<div class="line"><a id="l01283" name="l01283"></a><span class="lineno"> 1283</span><span class="comment">     *</span></div>
<div class="line"><a id="l01284" name="l01284"></a><span class="lineno"> 1284</span><span class="comment">     * See start_and_poll() for background discussion to clarify this nicely.</span></div>
<div class="line"><a id="l01285" name="l01285"></a><span class="lineno"> 1285</span><span class="comment">     */</span></div>
<div class="line"><a id="l01286" name="l01286"></a><span class="lineno"> 1286</span>    <span class="keyword">enum</span></div>
<div class="line"><a id="l01287" name="l01287"></a><span class="lineno"> 1287</span>    {<span class="comment"></span></div>
<div class="line"><a id="l01288" name="l01288"></a><span class="lineno"> 1288</span><span class="comment">      /**</span></div>
<div class="line"><a id="l01289" name="l01289"></a><span class="lineno"> 1289</span><span class="comment">       * Use Native_handle_receiver::async_receive_native_handle(); accept with-handle and sans-handle</span></div>
<div class="line"><a id="l01290" name="l01290"></a><span class="lineno"> 1290</span><span class="comment">       * lead in-message; then demultiplex into the slightly different async code path 1 or 2 depending on which</span></div>
<div class="line"><a id="l01291" name="l01291"></a><span class="lineno"> 1291</span><span class="comment">       * occurred.  (However, any continuation message along either code path must be sans-handle.)</span></div>
<div class="line"><a id="l01292" name="l01292"></a><span class="lineno"> 1292</span><span class="comment">       */</span></div>
<div class="line"><a id="l01293" name="l01293"></a><span class="lineno"><a class="line" href="structipc_1_1transport_1_1struc_1_1sync__io_1_1Channel_1_1Msg__in__pipe.html#af253db32507ef0191eef0fc926a65f54a2909901e853fa702041678e01f37f7de"> 1293</a></span>      <a class="code hl_enumvalue" href="structipc_1_1transport_1_1struc_1_1sync__io_1_1Channel_1_1Msg__in__pipe.html#af253db32507ef0191eef0fc926a65f54a2909901e853fa702041678e01f37f7de">S_RCV_WITH_OR_SANS_HNDL_DEMUX</a>,</div>
<div class="line"><a id="l01294" name="l01294"></a><span class="lineno"> 1294</span><span class="comment"></span> </div>
<div class="line"><a id="l01295" name="l01295"></a><span class="lineno"> 1295</span><span class="comment">      /**</span></div>
<div class="line"><a id="l01296" name="l01296"></a><span class="lineno"> 1296</span><span class="comment">       * Use Native_handle_receiver::async_receive_native_handle(); accept with-handle message only;</span></div>
<div class="line"><a id="l01297" name="l01297"></a><span class="lineno"> 1297</span><span class="comment">       * sans-handle message means fatally hosed `*this`.  (However, any continuation message</span></div>
<div class="line"><a id="l01298" name="l01298"></a><span class="lineno"> 1298</span><span class="comment">       * must be sans-handle.)</span></div>
<div class="line"><a id="l01299" name="l01299"></a><span class="lineno"> 1299</span><span class="comment">       *</span></div>
<div class="line"><a id="l01300" name="l01300"></a><span class="lineno"> 1300</span><span class="comment">       * @note For context: If this is in use, then another Msg_in_pipe must be in `S_RCV_SANS_HNDL_ONLY`</span></div>
<div class="line"><a id="l01301" name="l01301"></a><span class="lineno"> 1301</span><span class="comment">       * #m_lead_msg_mode also (in `*this`).</span></div>
<div class="line"><a id="l01302" name="l01302"></a><span class="lineno"> 1302</span><span class="comment">       */</span></div>
<div class="line"><a id="l01303" name="l01303"></a><span class="lineno"><a class="line" href="structipc_1_1transport_1_1struc_1_1sync__io_1_1Channel_1_1Msg__in__pipe.html#af253db32507ef0191eef0fc926a65f54ae237f1213d4bbf83cf354afb87238ecf"> 1303</a></span>      <a class="code hl_enumvalue" href="structipc_1_1transport_1_1struc_1_1sync__io_1_1Channel_1_1Msg__in__pipe.html#af253db32507ef0191eef0fc926a65f54ae237f1213d4bbf83cf354afb87238ecf">S_RCV_WITH_HNDL_ELSE_ERROR</a>,</div>
<div class="line"><a id="l01304" name="l01304"></a><span class="lineno"> 1304</span><span class="comment"></span> </div>
<div class="line"><a id="l01305" name="l01305"></a><span class="lineno"> 1305</span><span class="comment">      /**</span></div>
<div class="line"><a id="l01306" name="l01306"></a><span class="lineno"> 1306</span><span class="comment">       * Use Blob_receiver::async_receive_blob(); accept sans-handle message only;</span></div>
<div class="line"><a id="l01307" name="l01307"></a><span class="lineno"> 1307</span><span class="comment">       * with-handle message means fatally hosed `*this` automatically at the lower level (inside Channel).</span></div>
<div class="line"><a id="l01308" name="l01308"></a><span class="lineno"> 1308</span><span class="comment">       * (Any continuation message must be sans-handle as well.)</span></div>
<div class="line"><a id="l01309" name="l01309"></a><span class="lineno"> 1309</span><span class="comment">       *</span></div>
<div class="line"><a id="l01310" name="l01310"></a><span class="lineno"> 1310</span><span class="comment">       * @note For context: If this is in use, then another Msg_in_pipe *might* be in `S_RCV_SANS_HNDL_ONLY`</span></div>
<div class="line"><a id="l01311" name="l01311"></a><span class="lineno"> 1311</span><span class="comment">       * #m_lead_msg_mode also (in `*this`).  It also might *not* exist; namely if Channel::S_HAS_BLOB_PIPE_ONLY.</span></div>
<div class="line"><a id="l01312" name="l01312"></a><span class="lineno"> 1312</span><span class="comment">       * Then, simply, `*this` can never receive native handles (which is an entirely possible use).</span></div>
<div class="line"><a id="l01313" name="l01313"></a><span class="lineno"> 1313</span><span class="comment">       */</span></div>
<div class="line"><a id="l01314" name="l01314"></a><span class="lineno"> 1314</span>      <a class="code hl_enumvalue" href="structipc_1_1transport_1_1struc_1_1sync__io_1_1Channel_1_1Msg__in__pipe.html#af253db32507ef0191eef0fc926a65f54af9cda4dc28baebac6ea0b91401fefeaa">S_RCV_SANS_HNDL_ONLY</a></div>
<div class="line"><a id="l01315" name="l01315"></a><span class="lineno"><a class="line" href="structipc_1_1transport_1_1struc_1_1sync__io_1_1Channel_1_1Msg__in__pipe.html#a3d239c5a1e29bd6db1ee7c4764616549"> 1315</a></span>    } <a class="code hl_variable" href="structipc_1_1transport_1_1struc_1_1sync__io_1_1Channel_1_1Msg__in__pipe.html#a3d239c5a1e29bd6db1ee7c4764616549">m_lead_msg_mode</a>;</div>
<div class="line"><a id="l01316" name="l01316"></a><span class="lineno"> 1316</span><span class="comment"></span> </div>
<div class="line"><a id="l01317" name="l01317"></a><span class="lineno"> 1317</span><span class="comment">    /**</span></div>
<div class="line"><a id="l01318" name="l01318"></a><span class="lineno"> 1318</span><span class="comment">     * During an async-read (note: given start_and_poll() and until channel is hosed, there is *always* an async-read</span></div>
<div class="line"><a id="l01319" name="l01319"></a><span class="lineno"> 1319</span><span class="comment">     * happening): the number of segments needed *after* the currently-async-awaited next segment does arrive</span></div>
<div class="line"><a id="l01320" name="l01320"></a><span class="lineno"> 1320</span><span class="comment">     * to complete the message.  When the lead in-message is being async-read, this shall be set to 0.</span></div>
<div class="line"><a id="l01321" name="l01321"></a><span class="lineno"> 1321</span><span class="comment">     * (If that lead in-message indicates the total # of *further* segments to expect is 0, then the 0 is &quot;correct&quot;;</span></div>
<div class="line"><a id="l01322" name="l01322"></a><span class="lineno"> 1322</span><span class="comment">     * if the # is 1+, then this member is &quot;corrected&quot; to equal that #.  Before each continuation async-read</span></div>
<div class="line"><a id="l01323" name="l01323"></a><span class="lineno"> 1323</span><span class="comment">     * it is decremented by 1, including ahead of the first continuation async-read.  So if original seg-count is 1,</span></div>
<div class="line"><a id="l01324" name="l01324"></a><span class="lineno"> 1324</span><span class="comment">     * then this is 0 ahead of lead read, 0 ahead of continuation read.  If it&#39;s 2, then this is 0 ahead of lead read,</span></div>
<div class="line"><a id="l01325" name="l01325"></a><span class="lineno"> 1325</span><span class="comment">     * 1 ahead of continuation read one, 0 ahead of continuation read two.  And so on.)</span></div>
<div class="line"><a id="l01326" name="l01326"></a><span class="lineno"> 1326</span><span class="comment">     */</span></div>
<div class="line"><a id="l01327" name="l01327"></a><span class="lineno"><a class="line" href="structipc_1_1transport_1_1struc_1_1sync__io_1_1Channel_1_1Msg__in__pipe.html#a1b6834c271148af382c46ef948d1faab"> 1327</a></span>    <span class="keywordtype">size_t</span> <a class="code hl_variable" href="structipc_1_1transport_1_1struc_1_1sync__io_1_1Channel_1_1Msg__in__pipe.html#a1b6834c271148af382c46ef948d1faab">m_n_segs_left_after_this_read</a>;</div>
<div class="line"><a id="l01328" name="l01328"></a><span class="lineno"> 1328</span><span class="comment"></span> </div>
<div class="line"><a id="l01329" name="l01329"></a><span class="lineno"> 1329</span><span class="comment">    /**</span></div>
<div class="line"><a id="l01330" name="l01330"></a><span class="lineno"> 1330</span><span class="comment">     * Target buffer for the `async_receive_*()` operation in-progress.  (Note: given start_and_poll() and until channel</span></div>
<div class="line"><a id="l01331" name="l01331"></a><span class="lineno"> 1331</span><span class="comment">     * is hosed, there is *always* an async-read in-progress.)</span></div>
<div class="line"><a id="l01332" name="l01332"></a><span class="lineno"> 1332</span><span class="comment">     * `m_target_blob.capacity()` is always a positive constant, the max length accepted along the underlying</span></div>
<div class="line"><a id="l01333" name="l01333"></a><span class="lineno"> 1333</span><span class="comment">     * Channel in-pipe.  `m_target_blob-&gt;capacity() == m_target_blob-&gt;size()`,</span></div>
<div class="line"><a id="l01334" name="l01334"></a><span class="lineno"> 1334</span><span class="comment">     * and the async-receive was passed `m_target_blob-&gt;mutable_buffer()` with that `.size()`.</span></div>
<div class="line"><a id="l01335" name="l01335"></a><span class="lineno"> 1335</span><span class="comment">     * If it is completed, then `m_target_blob-&gt;size()` is &quot;corrected&quot; to the # of bytes (successfully) received in</span></div>
<div class="line"><a id="l01336" name="l01336"></a><span class="lineno"> 1336</span><span class="comment">     * the unstructured message -- and `m_target_blob` is immediately re-assigned to point to the *next* `Blob.</span></div>
<div class="line"><a id="l01337" name="l01337"></a><span class="lineno"> 1337</span><span class="comment">     *</span></div>
<div class="line"><a id="l01338" name="l01338"></a><span class="lineno"> 1338</span><span class="comment">     * To be clear: #m_target_blob points to a `Blob` inside `*m_incomplete_msg`.  The #Msg_in is in charge of</span></div>
<div class="line"><a id="l01339" name="l01339"></a><span class="lineno"> 1339</span><span class="comment">     * supplying memory area to read-to; depending on the deserialization engine it might be obtaining that memory</span></div>
<div class="line"><a id="l01340" name="l01340"></a><span class="lineno"> 1340</span><span class="comment">     * from the regular heap, or some pool, or....</span></div>
<div class="line"><a id="l01341" name="l01341"></a><span class="lineno"> 1341</span><span class="comment">     *</span></div>
<div class="line"><a id="l01342" name="l01342"></a><span class="lineno"> 1342</span><span class="comment">     * So when `m_target_blob-&gt;size()` is &quot;corrected,&quot; the correction is as required by the #Msg_in contract</span></div>
<div class="line"><a id="l01343" name="l01343"></a><span class="lineno"> 1343</span><span class="comment">     * for Msg_in::add_serialization_segment().  That way it knows the actual size of the segment</span></div>
<div class="line"><a id="l01344" name="l01344"></a><span class="lineno"> 1344</span><span class="comment">     * within the serialization, as opposed to the max size of such a segment.</span></div>
<div class="line"><a id="l01345" name="l01345"></a><span class="lineno"> 1345</span><span class="comment">     */</span></div>
<div class="line"><a id="l01346" name="l01346"></a><span class="lineno"><a class="line" href="structipc_1_1transport_1_1struc_1_1sync__io_1_1Channel_1_1Msg__in__pipe.html#af73c6fcead6a866df1524e01b5654222"> 1346</a></span>    flow::util::Blob* <a class="code hl_variable" href="structipc_1_1transport_1_1struc_1_1sync__io_1_1Channel_1_1Msg__in__pipe.html#af73c6fcead6a866df1524e01b5654222">m_target_blob</a>;</div>
<div class="line"><a id="l01347" name="l01347"></a><span class="lineno"> 1347</span><span class="comment"></span> </div>
<div class="line"><a id="l01348" name="l01348"></a><span class="lineno"> 1348</span><span class="comment">    /**</span></div>
<div class="line"><a id="l01349" name="l01349"></a><span class="lineno"> 1349</span><span class="comment">     * Target #Native_handle for the `async_receive_native_handle()` operation in-progress or last-completed;</span></div>
<div class="line"><a id="l01350" name="l01350"></a><span class="lineno"> 1350</span><span class="comment">     * null if the last or in-progress operation is `async_receive_blob()`.</span></div>
<div class="line"><a id="l01351" name="l01351"></a><span class="lineno"> 1351</span><span class="comment">     *</span></div>
<div class="line"><a id="l01352" name="l01352"></a><span class="lineno"> 1352</span><span class="comment">     * Therefore, regardless of which async-receive just completed, one can view pair (#m_target_blob, #m_target_hndl)</span></div>
<div class="line"><a id="l01353" name="l01353"></a><span class="lineno"> 1353</span><span class="comment">     * as its result (it shall be null if and only if the received message is sans-handle -- in any context).</span></div>
<div class="line"><a id="l01354" name="l01354"></a><span class="lineno"> 1354</span><span class="comment">     *</span></div>
<div class="line"><a id="l01355" name="l01355"></a><span class="lineno"> 1355</span><span class="comment">     * Analogously to #m_target_blob, this member is reinitialized immediately upon successful async-read;</span></div>
<div class="line"><a id="l01356" name="l01356"></a><span class="lineno"> 1356</span><span class="comment">     * if it is non-null, then it is moved-into #m_incomplete_msg (and thus nullified); if it is null, then...</span></div>
<div class="line"><a id="l01357" name="l01357"></a><span class="lineno"> 1357</span><span class="comment">     * it remains null (a `.null()` #Native_handle moved-to another #Native_handle simply remains `.null()`).</span></div>
<div class="line"><a id="l01358" name="l01358"></a><span class="lineno"> 1358</span><span class="comment">     */</span></div>
<div class="line"><a id="l01359" name="l01359"></a><span class="lineno"><a class="line" href="structipc_1_1transport_1_1struc_1_1sync__io_1_1Channel_1_1Msg__in__pipe.html#ad27cbaa9b01823f31fb2ae47835974df"> 1359</a></span>    <a class="code hl_struct" href="structipc_1_1util_1_1Native__handle.html">Native_handle</a> <a class="code hl_variable" href="structipc_1_1transport_1_1struc_1_1sync__io_1_1Channel_1_1Msg__in__pipe.html#ad27cbaa9b01823f31fb2ae47835974df">m_target_hndl</a>;</div>
<div class="line"><a id="l01360" name="l01360"></a><span class="lineno"> 1360</span><span class="comment"></span> </div>
<div class="line"><a id="l01361" name="l01361"></a><span class="lineno"> 1361</span><span class="comment">    /**</span></div>
<div class="line"><a id="l01362" name="l01362"></a><span class="lineno"> 1362</span><span class="comment">     * Target (incomplete) in-message for the `async_receive_*()` operation in-progress; one is always in-progress</span></div>
<div class="line"><a id="l01363" name="l01363"></a><span class="lineno"> 1363</span><span class="comment">     * once `start_and_poll()` has been called, until the pipe is hosed.  It&#39;s used as follows:</span></div>
<div class="line"><a id="l01364" name="l01364"></a><span class="lineno"> 1364</span><span class="comment">     *   - When the async-read for the lead unstructured in-message is about to be called, this is constructed,</span></div>
<div class="line"><a id="l01365" name="l01365"></a><span class="lineno"> 1365</span><span class="comment">     *     and its `add_serialization_segment()` returns a `Blob*` to the next blob (inside `*m_incomplete_msg`)</span></div>
<div class="line"><a id="l01366" name="l01366"></a><span class="lineno"> 1366</span><span class="comment">     *     to async-read-into.  That `Blob*` is saved to #m_target_blob, and the async-read begins.</span></div>
<div class="line"><a id="l01367" name="l01367"></a><span class="lineno"> 1367</span><span class="comment">     *   - Once it is complete, `*m_target_blob` is `resize()`d to account for the actual segment size.</span></div>
<div class="line"><a id="l01368" name="l01368"></a><span class="lineno"> 1368</span><span class="comment">     *     - If the message consists of only 1 segment, done.  Emit completed structured in-message to</span></div>
<div class="line"><a id="l01369" name="l01369"></a><span class="lineno"> 1369</span><span class="comment">     *       the next layer; and go back to step 1 (get next lead message).  Else</span></div>
<div class="line"><a id="l01370" name="l01370"></a><span class="lineno"> 1370</span><span class="comment">     *       must get first continuation message:</span></div>
<div class="line"><a id="l01371" name="l01371"></a><span class="lineno"> 1371</span><span class="comment">     *   - Call `add_serialization_segment()` again; save the returned `Blob*` into #m_target_blob again;</span></div>
<div class="line"><a id="l01372" name="l01372"></a><span class="lineno"> 1372</span><span class="comment">     *     begin async-read again.</span></div>
<div class="line"><a id="l01373" name="l01373"></a><span class="lineno"> 1373</span><span class="comment">     *   - Once it is complete, `*m_target_blob` is `resize()`d again to account for the actual seg-size again.</span></div>
<div class="line"><a id="l01374" name="l01374"></a><span class="lineno"> 1374</span><span class="comment">     *     - If that&#39;s the last segment, done.  Emit completed structured in-message to</span></div>
<div class="line"><a id="l01375" name="l01375"></a><span class="lineno"> 1375</span><span class="comment">     *       the next layer; and go back to step 1 (get next lead message).  Go back to step 1 (get the next</span></div>
<div class="line"><a id="l01376" name="l01376"></a><span class="lineno"> 1376</span><span class="comment">     *       lead message).  Else must get next continuation message: Go to step 3 again.</span></div>
<div class="line"><a id="l01377" name="l01377"></a><span class="lineno"> 1377</span><span class="comment">     *</span></div>
<div class="line"><a id="l01378" name="l01378"></a><span class="lineno"> 1378</span><span class="comment">     * Subtlety: It&#39;s a `unique_ptr` (not #Msg_in_ptr `shared_ptr`) for anti-leak safety/perf.</span></div>
<div class="line"><a id="l01379" name="l01379"></a><span class="lineno"> 1379</span><span class="comment">     * It is moved and thus upgraded to a `shared_ptr` (#Msg_in_ptr) when message completed.</span></div>
<div class="line"><a id="l01380" name="l01380"></a><span class="lineno"> 1380</span><span class="comment">     */</span></div>
<div class="line"><a id="l01381" name="l01381"></a><span class="lineno"><a class="line" href="structipc_1_1transport_1_1struc_1_1sync__io_1_1Channel_1_1Msg__in__pipe.html#aa02a4835e4bd31cd5f6ea9bbd37eeff4"> 1381</a></span>    <a class="code hl_typedef" href="classipc_1_1transport_1_1struc_1_1sync__io_1_1Channel.html#a84287334d14f54c97f7dbb0d5b04cca5">Msg_in_ptr_uniq</a> <a class="code hl_variable" href="structipc_1_1transport_1_1struc_1_1sync__io_1_1Channel_1_1Msg__in__pipe.html#aa02a4835e4bd31cd5f6ea9bbd37eeff4">m_incomplete_msg</a>;</div>
<div class="line"><a id="l01382" name="l01382"></a><span class="lineno"> 1382</span><span class="comment"></span> </div>
<div class="line"><a id="l01383" name="l01383"></a><span class="lineno"> 1383</span><span class="comment">    /**</span></div>
<div class="line"><a id="l01384" name="l01384"></a><span class="lineno"> 1384</span><span class="comment">     * Used only for the first in-message in the pipe, before any #m_incomplete_msg, when doing protocol negotiation:</span></div>
<div class="line"><a id="l01385" name="l01385"></a><span class="lineno"> 1385</span><span class="comment">     * this is analogous to #m_target_blob but for the simple/small `ProtocolNegotiation` capnp-`struct`.</span></div>
<div class="line"><a id="l01386" name="l01386"></a><span class="lineno"> 1386</span><span class="comment">     */</span></div>
<div class="line"><a id="l01387" name="l01387"></a><span class="lineno"><a class="line" href="structipc_1_1transport_1_1struc_1_1sync__io_1_1Channel_1_1Msg__in__pipe.html#a56c1f9cdcfd2a145114ab080199eb704"> 1387</a></span>    flow::util::Blob* <a class="code hl_variable" href="structipc_1_1transport_1_1struc_1_1sync__io_1_1Channel_1_1Msg__in__pipe.html#a56c1f9cdcfd2a145114ab080199eb704">m_proto_neg_blob</a>;</div>
<div class="line"><a id="l01388" name="l01388"></a><span class="lineno"> 1388</span><span class="comment"></span> </div>
<div class="line"><a id="l01389" name="l01389"></a><span class="lineno"> 1389</span><span class="comment">    /**</span></div>
<div class="line"><a id="l01390" name="l01390"></a><span class="lineno"> 1390</span><span class="comment">     * Used only for the first in-message in the pipe, before any #m_incomplete_msg, when doing protocol negotiation:</span></div>
<div class="line"><a id="l01391" name="l01391"></a><span class="lineno"> 1391</span><span class="comment">     * this is analogous to #m_target_hndl.  However such protocol-negotiation messages shall never include any</span></div>
<div class="line"><a id="l01392" name="l01392"></a><span class="lineno"> 1392</span><span class="comment">     * non-null `Native_handle`; but we still need a place to put it for the `.async_receive_native_handle()` API.</span></div>
<div class="line"><a id="l01393" name="l01393"></a><span class="lineno"> 1393</span><span class="comment">     */</span></div>
<div class="line"><a id="l01394" name="l01394"></a><span class="lineno"><a class="line" href="structipc_1_1transport_1_1struc_1_1sync__io_1_1Channel_1_1Msg__in__pipe.html#a83b9a3a7ddee7b6bfe14724bfccfc6ba"> 1394</a></span>    <a class="code hl_struct" href="structipc_1_1util_1_1Native__handle.html">Native_handle</a> <a class="code hl_variable" href="structipc_1_1transport_1_1struc_1_1sync__io_1_1Channel_1_1Msg__in__pipe.html#a83b9a3a7ddee7b6bfe14724bfccfc6ba">m_proto_neg_hndl</a>;</div>
<div class="line"><a id="l01395" name="l01395"></a><span class="lineno"> 1395</span><span class="comment"></span> </div>
<div class="line"><a id="l01396" name="l01396"></a><span class="lineno"> 1396</span><span class="comment">    /**</span></div>
<div class="line"><a id="l01397" name="l01397"></a><span class="lineno"> 1397</span><span class="comment">     * Used only for the first in-message in the pipe, before any #m_incomplete_msg, when doing protocol negotiation:</span></div>
<div class="line"><a id="l01398" name="l01398"></a><span class="lineno"> 1398</span><span class="comment">     * this is analogous to #m_incomplete_msg but for the simple/small `ProtocolNegotiation` capnp-`struct`.</span></div>
<div class="line"><a id="l01399" name="l01399"></a><span class="lineno"> 1399</span><span class="comment">     * It is simpler though: we expect 1 segment, always heap-based, and don&#39;t need the `Msg_in` niceties; so we</span></div>
<div class="line"><a id="l01400" name="l01400"></a><span class="lineno"> 1400</span><span class="comment">     * use a `Heap_reader` directly.  This is `.reset()` after protocol-negotiation completes to save some RAM.</span></div>
<div class="line"><a id="l01401" name="l01401"></a><span class="lineno"> 1401</span><span class="comment">     */</span></div>
<div class="line"><a id="l01402" name="l01402"></a><span class="lineno"><a class="line" href="structipc_1_1transport_1_1struc_1_1sync__io_1_1Channel_1_1Msg__in__pipe.html#a58b72930ddbf7e45936f8c8f34105324"> 1402</a></span>    boost::movelib::unique_ptr&lt;Heap_reader&gt; <a class="code hl_variable" href="structipc_1_1transport_1_1struc_1_1sync__io_1_1Channel_1_1Msg__in__pipe.html#a58b72930ddbf7e45936f8c8f34105324">m_proto_neg_reader_in</a>;</div>
<div class="line"><a id="l01403" name="l01403"></a><span class="lineno"> 1403</span>  }; <span class="comment">// struct Msg_in_pipe</span></div>
<div class="line"><a id="l01404" name="l01404"></a><span class="lineno"> 1404</span><span class="comment"></span> </div>
<div class="line"><a id="l01405" name="l01405"></a><span class="lineno"> 1405</span><span class="comment">  /**</span></div>
<div class="line"><a id="l01406" name="l01406"></a><span class="lineno"> 1406</span><span class="comment">   * Upon receiving an unstructured message along 1 given pipe of #Owned_channel this indicates the next such message</span></div>
<div class="line"><a id="l01407" name="l01407"></a><span class="lineno"> 1407</span><span class="comment">   * expected if any.</span></div>
<div class="line"><a id="l01408" name="l01408"></a><span class="lineno"> 1408</span><span class="comment">   */</span></div>
<div class="line"><a id="l01409" name="l01409"></a><span class="lineno"><a class="line" href="classipc_1_1transport_1_1struc_1_1sync__io_1_1Channel.html#a9d3344a97644dad136bb47e852dda6fd"> 1409</a></span>  <span class="keyword">enum class</span> <a class="code hl_enumeration" href="classipc_1_1transport_1_1struc_1_1sync__io_1_1Channel.html#a9d3344a97644dad136bb47e852dda6fd">Rcv_next_step</a></div>
<div class="line"><a id="l01410" name="l01410"></a><span class="lineno"> 1410</span>  {<span class="comment"></span></div>
<div class="line"><a id="l01411" name="l01411"></a><span class="lineno"> 1411</span><span class="comment">    /**</span></div>
<div class="line"><a id="l01412" name="l01412"></a><span class="lineno"> 1412</span><span class="comment">     * Next message is lead message.  The case in these situations:</span></div>
<div class="line"><a id="l01413" name="l01413"></a><span class="lineno"> 1413</span><span class="comment">     *   - Initial state (start_and_poll()).</span></div>
<div class="line"><a id="l01414" name="l01414"></a><span class="lineno"> 1414</span><span class="comment">     *   - The last message was lead unstructured message comprised by a structured internal message.</span></div>
<div class="line"><a id="l01415" name="l01415"></a><span class="lineno"> 1415</span><span class="comment">     *     (An internal structured message = always 1 unstructured lead message.)</span></div>
<div class="line"><a id="l01416" name="l01416"></a><span class="lineno"> 1416</span><span class="comment">     *   - The last message was continuation unstructured message N of N comprised by a structured user message&#39;s</span></div>
<div class="line"><a id="l01417" name="l01417"></a><span class="lineno"> 1417</span><span class="comment">     *     serialization; where N is the segment count for the serialization of the user message.  N itself is</span></div>
<div class="line"><a id="l01418" name="l01418"></a><span class="lineno"> 1418</span><span class="comment">     *     communicated in the lead unstructured message (the metadata).  Ideally, and typically, N=1.</span></div>
<div class="line"><a id="l01419" name="l01419"></a><span class="lineno"> 1419</span><span class="comment">     */</span></div>
<div class="line"><a id="l01420" name="l01420"></a><span class="lineno"> 1420</span>    S_READ_LEAD_MSG,</div>
<div class="line"><a id="l01421" name="l01421"></a><span class="lineno"> 1421</span><span class="comment"></span> </div>
<div class="line"><a id="l01422" name="l01422"></a><span class="lineno"> 1422</span><span class="comment">    /**</span></div>
<div class="line"><a id="l01423" name="l01423"></a><span class="lineno"> 1423</span><span class="comment">     * Next message is continuation message.  The case in these situations:</span></div>
<div class="line"><a id="l01424" name="l01424"></a><span class="lineno"> 1424</span><span class="comment">     *   - The last message was lead unstructured message comprised by a structured user message message.</span></div>
<div class="line"><a id="l01425" name="l01425"></a><span class="lineno"> 1425</span><span class="comment">     *     (An user structured message = always 1 unstructured lead message containing metadata + 1+</span></div>
<div class="line"><a id="l01426" name="l01426"></a><span class="lineno"> 1426</span><span class="comment">     *     continuation messages comprised by structured user message&#39;s serialization.)</span></div>
<div class="line"><a id="l01427" name="l01427"></a><span class="lineno"> 1427</span><span class="comment">     *   - The last message was continuation unstructured message less-than-N of N comprised by a structured user</span></div>
<div class="line"><a id="l01428" name="l01428"></a><span class="lineno"> 1428</span><span class="comment">     *     message&#39;s serialization; where N is the segment count for the serialization of the user message.</span></div>
<div class="line"><a id="l01429" name="l01429"></a><span class="lineno"> 1429</span><span class="comment">     *     N itself is communicated in the lead unstructured message.  Ideally, and typically, N=1.</span></div>
<div class="line"><a id="l01430" name="l01430"></a><span class="lineno"> 1430</span><span class="comment">     */</span></div>
<div class="line"><a id="l01431" name="l01431"></a><span class="lineno"> 1431</span>    S_READ_CONT_MSG,</div>
<div class="line"><a id="l01432" name="l01432"></a><span class="lineno"> 1432</span><span class="comment"></span> </div>
<div class="line"><a id="l01433" name="l01433"></a><span class="lineno"> 1433</span><span class="comment">    /// The pipe should no longer be read-from ever (the case on error).</span></div>
<div class="line"><a id="l01434" name="l01434"></a><span class="lineno"> 1434</span><span class="comment"></span>    S_STOP</div>
<div class="line"><a id="l01435" name="l01435"></a><span class="lineno"> 1435</span>  }; <span class="comment">// enum class Rcv_next_step</span></div>
<div class="line"><a id="l01436" name="l01436"></a><span class="lineno"> 1436</span> </div>
<div class="line"><a id="l01437" name="l01437"></a><span class="lineno"> 1437</span>  <span class="comment">// Methods.</span></div>
<div class="line"><a id="l01438" name="l01438"></a><span class="lineno"> 1438</span><span class="comment"></span> </div>
<div class="line"><a id="l01439" name="l01439"></a><span class="lineno"> 1439</span><span class="comment">  /**</span></div>
<div class="line"><a id="l01440" name="l01440"></a><span class="lineno"> 1440</span><span class="comment">   * Record handler to invoke in handlers_poll() soon.  The context for this is: we&#39;re scanning an unstructured</span></div>
<div class="line"><a id="l01441" name="l01441"></a><span class="lineno"> 1441</span><span class="comment">   * (low-level) message received along a pipe of #Owned_channel; and it completed something such that the user</span></div>
<div class="line"><a id="l01442" name="l01442"></a><span class="lineno"> 1442</span><span class="comment">   * shall be informed of this via a completion handler they had registered.  As of this writing the relevant</span></div>
<div class="line"><a id="l01443" name="l01443"></a><span class="lineno"> 1443</span><span class="comment">   * completion handlers are:</span></div>
<div class="line"><a id="l01444" name="l01444"></a><span class="lineno"> 1444</span><span class="comment">   *   - those from `expect_*()`;</span></div>
<div class="line"><a id="l01445" name="l01445"></a><span class="lineno"> 1445</span><span class="comment">   *   - those from async_request();</span></div>
<div class="line"><a id="l01446" name="l01446"></a><span class="lineno"> 1446</span><span class="comment">   *   - those from `set_*unexpected_response_handler()`.</span></div>
<div class="line"><a id="l01447" name="l01447"></a><span class="lineno"> 1447</span><span class="comment">   *</span></div>
<div class="line"><a id="l01448" name="l01448"></a><span class="lineno"> 1448</span><span class="comment">   * (async_end_sending() completion handler is a separate, lower-level thing.)</span></div>
<div class="line"><a id="l01449" name="l01449"></a><span class="lineno"> 1449</span><span class="comment">   *</span></div>
<div class="line"><a id="l01450" name="l01450"></a><span class="lineno"> 1450</span><span class="comment">   * @see Doc header for #m_sync_io_handlers which discusses the design+trade-offs here.</span></div>
<div class="line"><a id="l01451" name="l01451"></a><span class="lineno"> 1451</span><span class="comment">   *</span></div>
<div class="line"><a id="l01452" name="l01452"></a><span class="lineno"> 1452</span><span class="comment">   * @tparam Task</span></div>
<div class="line"><a id="l01453" name="l01453"></a><span class="lineno"> 1453</span><span class="comment">   *         Function type matching `void F()`.</span></div>
<div class="line"><a id="l01454" name="l01454"></a><span class="lineno"> 1454</span><span class="comment">   * @param context</span></div>
<div class="line"><a id="l01455" name="l01455"></a><span class="lineno"> 1455</span><span class="comment">   *        Brief context string for logging.</span></div>
<div class="line"><a id="l01456" name="l01456"></a><span class="lineno"> 1456</span><span class="comment">   * @param handler</span></div>
<div class="line"><a id="l01457" name="l01457"></a><span class="lineno"> 1457</span><span class="comment">   *        Code to run in handlers_poll().</span></div>
<div class="line"><a id="l01458" name="l01458"></a><span class="lineno"> 1458</span><span class="comment">   */</span></div>
<div class="line"><a id="l01459" name="l01459"></a><span class="lineno"> 1459</span>  <span class="keyword">template</span>&lt;<span class="keyword">typename</span> Task&gt;</div>
<div class="line"><a id="l01460" name="l01460"></a><span class="lineno"> 1460</span>  <span class="keywordtype">void</span> <a class="code hl_function" href="classipc_1_1transport_1_1struc_1_1sync__io_1_1Channel.html#a126c0d7ee5fcab20dc8c87884fdd7597">handlers_post</a>(<a class="code hl_typedef" href="namespaceipc_1_1util.html#ae6ac47812a90d1287c61e0b7de7bc4f5">util::String_view</a> context, <a class="code hl_typedef" href="namespaceipc_1_1util.html#a31e67d3a017477a04b313927e2f2c733">Task</a>&amp;&amp; handler);</div>
<div class="line"><a id="l01461" name="l01461"></a><span class="lineno"> 1461</span><span class="comment"></span> </div>
<div class="line"><a id="l01462" name="l01462"></a><span class="lineno"> 1462</span><span class="comment">  /**</span></div>
<div class="line"><a id="l01463" name="l01463"></a><span class="lineno"> 1463</span><span class="comment">   * Executes what was recorded recently in handlers_post().  As of this writing this is done after scanning</span></div>
<div class="line"><a id="l01464" name="l01464"></a><span class="lineno"> 1464</span><span class="comment">   * each unstructured (low-level) in-message.  If Channel::S_HAS_2_PIPES is `true`, then 1+ handlers may</span></div>
<div class="line"><a id="l01465" name="l01465"></a><span class="lineno"> 1465</span><span class="comment">   * execute here; otherwise at most 1 can execute here.</span></div>
<div class="line"><a id="l01466" name="l01466"></a><span class="lineno"> 1466</span><span class="comment">   *</span></div>
<div class="line"><a id="l01467" name="l01467"></a><span class="lineno"> 1467</span><span class="comment">   * @see Doc header for #m_sync_io_handlers which discusses the design+trade-offs here.</span></div>
<div class="line"><a id="l01468" name="l01468"></a><span class="lineno"> 1468</span><span class="comment">   *</span></div>
<div class="line"><a id="l01469" name="l01469"></a><span class="lineno"> 1469</span><span class="comment">   * @param context</span></div>
<div class="line"><a id="l01470" name="l01470"></a><span class="lineno"> 1470</span><span class="comment">   *        Brief context string for logging.</span></div>
<div class="line"><a id="l01471" name="l01471"></a><span class="lineno"> 1471</span><span class="comment">   */</span></div>
<div class="line"><a id="l01472" name="l01472"></a><span class="lineno"> 1472</span>  <span class="keywordtype">void</span> <a class="code hl_function" href="classipc_1_1transport_1_1struc_1_1sync__io_1_1Channel.html#a3a0adf8ce8fc29ec55b4c8c30886c1fc">handlers_poll</a>(<a class="code hl_typedef" href="namespaceipc_1_1util.html#ae6ac47812a90d1287c61e0b7de7bc4f5">util::String_view</a> context);</div>
<div class="line"><a id="l01473" name="l01473"></a><span class="lineno"> 1473</span><span class="comment"></span> </div>
<div class="line"><a id="l01474" name="l01474"></a><span class="lineno"> 1474</span><span class="comment">  /**</span></div>
<div class="line"><a id="l01475" name="l01475"></a><span class="lineno"> 1475</span><span class="comment">   * Helper that returns the max receive-buffer size for any async-read into a given Msg_in_pipe.</span></div>
<div class="line"><a id="l01476" name="l01476"></a><span class="lineno"> 1476</span><span class="comment">   *</span></div>
<div class="line"><a id="l01477" name="l01477"></a><span class="lineno"> 1477</span><span class="comment">   * @param mode</span></div>
<div class="line"><a id="l01478" name="l01478"></a><span class="lineno"> 1478</span><span class="comment">   *        Msg_in_pipe::m_lead_msg_mode.  The reason we don&#39;t take a `const Msg_in_pipe&amp;` here is that</span></div>
<div class="line"><a id="l01479" name="l01479"></a><span class="lineno"> 1479</span><span class="comment">   *        there is a use case where this value is necessary just before the Msg_in_pipe is actually constructed.</span></div>
<div class="line"><a id="l01480" name="l01480"></a><span class="lineno"> 1480</span><span class="comment">   * @return See above.</span></div>
<div class="line"><a id="l01481" name="l01481"></a><span class="lineno"> 1481</span><span class="comment">   */</span></div>
<div class="line"><a id="l01482" name="l01482"></a><span class="lineno"> 1482</span>  <span class="keywordtype">size_t</span> <a class="code hl_function" href="classipc_1_1transport_1_1struc_1_1sync__io_1_1Channel.html#a9b6cda20adb82073a1d7cf1b5cbfa865">rcv_blob_max_size</a>(<span class="keyword">decltype</span>(<a class="code hl_variable" href="structipc_1_1transport_1_1struc_1_1sync__io_1_1Channel_1_1Msg__in__pipe.html#a3d239c5a1e29bd6db1ee7c4764616549">Msg_in_pipe::m_lead_msg_mode</a>) mode) <span class="keyword">const</span>;</div>
<div class="line"><a id="l01483" name="l01483"></a><span class="lineno"> 1483</span><span class="comment"></span> </div>
<div class="line"><a id="l01484" name="l01484"></a><span class="lineno"> 1484</span><span class="comment">  /**</span></div>
<div class="line"><a id="l01485" name="l01485"></a><span class="lineno"> 1485</span><span class="comment">   * Acts on the pre-condition that the given in-pipe has just started (thus not known to be in would-block state);</span></div>
<div class="line"><a id="l01486" name="l01486"></a><span class="lineno"> 1486</span><span class="comment">   * and therefore we should read (and process) as many unstructured in-messages as synchronously possible</span></div>
<div class="line"><a id="l01487" name="l01487"></a><span class="lineno"> 1487</span><span class="comment">   * -- starting with the protocol-negotiation in-message -- until reaching would-block state, at which point we</span></div>
<div class="line"><a id="l01488" name="l01488"></a><span class="lineno"> 1488</span><span class="comment">   * should `return` with a pending async-wait/read on that in-pipe.  Either synchronously or asynchronously</span></div>
<div class="line"><a id="l01489" name="l01489"></a><span class="lineno"> 1489</span><span class="comment">   * (across an async-wait) this will ultimately invoke rcv_on_async_read_proto_neg_msg() which, in the best case</span></div>
<div class="line"><a id="l01490" name="l01490"></a><span class="lineno"> 1490</span><span class="comment">   * scenario, will move on to the &quot;real work&quot;: `rcv_async_read_lead_or_continuation_msg(pipe, true)`.</span></div>
<div class="line"><a id="l01491" name="l01491"></a><span class="lineno"> 1491</span><span class="comment">   *</span></div>
<div class="line"><a id="l01492" name="l01492"></a><span class="lineno"> 1492</span><span class="comment">   * This shall be called in exactly the following situation: start_and_poll().</span></div>
<div class="line"><a id="l01493" name="l01493"></a><span class="lineno"> 1493</span><span class="comment">   *</span></div>
<div class="line"><a id="l01494" name="l01494"></a><span class="lineno"> 1494</span><span class="comment">   * @param pipe</span></div>
<div class="line"><a id="l01495" name="l01495"></a><span class="lineno"> 1495</span><span class="comment">   *        Pointer into #m_rcv_pipes array.</span></div>
<div class="line"><a id="l01496" name="l01496"></a><span class="lineno"> 1496</span><span class="comment">   */</span></div>
<div class="line"><a id="l01497" name="l01497"></a><span class="lineno"> 1497</span>  <span class="keywordtype">void</span> <a class="code hl_function" href="classipc_1_1transport_1_1struc_1_1sync__io_1_1Channel.html#a50fb95469fcf9d5aadfb37c7117b8abb">rcv_async_read_proto_neg_msg</a>(Msg_in_pipe* pipe);</div>
<div class="line"><a id="l01498" name="l01498"></a><span class="lineno"> 1498</span><span class="comment"></span> </div>
<div class="line"><a id="l01499" name="l01499"></a><span class="lineno"> 1499</span><span class="comment">  /**</span></div>
<div class="line"><a id="l01500" name="l01500"></a><span class="lineno"> 1500</span><span class="comment">   * To execute upon completing an `m_channel.async_receive_*()` of the expected protocol-negotiation message along</span></div>
<div class="line"><a id="l01501" name="l01501"></a><span class="lineno"> 1501</span><span class="comment">   * the given in-pipe, this processes the result (message or error) and continues the read chain (on negotiation</span></div>
<div class="line"><a id="l01502" name="l01502"></a><span class="lineno"> 1502</span><span class="comment">   * success) or ends it (on any failure).  It *will* invoke handlers_poll() if appropriate (namely on error).</span></div>
<div class="line"><a id="l01503" name="l01503"></a><span class="lineno"> 1503</span><span class="comment">   *</span></div>
<div class="line"><a id="l01504" name="l01504"></a><span class="lineno"> 1504</span><span class="comment">   * @param pipe</span></div>
<div class="line"><a id="l01505" name="l01505"></a><span class="lineno"> 1505</span><span class="comment">   *        See rcv_async_read_proto_neg_msg().</span></div>
<div class="line"><a id="l01506" name="l01506"></a><span class="lineno"> 1506</span><span class="comment">   *        `*pipe-&gt;m_proto_neg_blob` and `*pipe-&gt;m_proto_neg_hndl` may have been received-into.</span></div>
<div class="line"><a id="l01507" name="l01507"></a><span class="lineno"> 1507</span><span class="comment">   * @param err_code</span></div>
<div class="line"><a id="l01508" name="l01508"></a><span class="lineno"> 1508</span><span class="comment">   *        From `Channel::async_receive_*()`.</span></div>
<div class="line"><a id="l01509" name="l01509"></a><span class="lineno"> 1509</span><span class="comment">   * @param sz</span></div>
<div class="line"><a id="l01510" name="l01510"></a><span class="lineno"> 1510</span><span class="comment">   *        From `Channel::async_receive_*()`.</span></div>
<div class="line"><a id="l01511" name="l01511"></a><span class="lineno"> 1511</span><span class="comment">   */</span></div>
<div class="line"><a id="l01512" name="l01512"></a><span class="lineno"> 1512</span>  <span class="keywordtype">void</span> <a class="code hl_function" href="classipc_1_1transport_1_1struc_1_1sync__io_1_1Channel.html#a05207484f4183cafebfe2c0681bd3332">rcv_on_async_read_proto_neg_msg</a>(Msg_in_pipe* pipe, <a class="code hl_typedef" href="namespaceipc.html#aa3192e586cc45d3e7c22463bf2760f89">Error_code</a> err_code, <span class="keywordtype">size_t</span> sz);</div>
<div class="line"><a id="l01513" name="l01513"></a><span class="lineno"> 1513</span><span class="comment"></span> </div>
<div class="line"><a id="l01514" name="l01514"></a><span class="lineno"> 1514</span><span class="comment">  /**</span></div>
<div class="line"><a id="l01515" name="l01515"></a><span class="lineno"> 1515</span><span class="comment">   * This key method acts on the pre-condition that the given in-pipe is not known to be in would-block state;</span></div>
<div class="line"><a id="l01516" name="l01516"></a><span class="lineno"> 1516</span><span class="comment">   * and therefore we should read (and process) as many unstructured in-messages as synchronously possible</span></div>
<div class="line"><a id="l01517" name="l01517"></a><span class="lineno"> 1517</span><span class="comment">   * until reaching would-block state, at which point we should `return` with a pending async-wait/read on</span></div>
<div class="line"><a id="l01518" name="l01518"></a><span class="lineno"> 1518</span><span class="comment">   * that in-pipe.</span></div>
<div class="line"><a id="l01519" name="l01519"></a><span class="lineno"> 1519</span><span class="comment">   *</span></div>
<div class="line"><a id="l01520" name="l01520"></a><span class="lineno"> 1520</span><span class="comment">   * This shall be called in exactly the following situations:</span></div>
<div class="line"><a id="l01521" name="l01521"></a><span class="lineno"> 1521</span><span class="comment">   *   - initially (start_and_poll());</span></div>
<div class="line"><a id="l01522" name="l01522"></a><span class="lineno"> 1522</span><span class="comment">   *   - upon this sequence occurring:</span></div>
<div class="line"><a id="l01523" name="l01523"></a><span class="lineno"> 1523</span><span class="comment">   *     -# An async-read (from this very method) yielded would-block.</span></div>
<div class="line"><a id="l01524" name="l01524"></a><span class="lineno"> 1524</span><span class="comment">   *     -# The would-block ended -- a message was received asynchronously.</span></div>
<div class="line"><a id="l01525" name="l01525"></a><span class="lineno"> 1525</span><span class="comment">   *     -# rcv_on_async_read_lead_msg() or rcv_on_async_read_continuation_msg() processed that in-message and</span></div>
<div class="line"><a id="l01526" name="l01526"></a><span class="lineno"> 1526</span><span class="comment">   *        would like to now read as many in-messages as possible that follow it (synchronously).</span></div>
<div class="line"><a id="l01527" name="l01527"></a><span class="lineno"> 1527</span><span class="comment">   *</span></div>
<div class="line"><a id="l01528" name="l01528"></a><span class="lineno"> 1528</span><span class="comment">   * To avoid growing the stack proportionally to the # of pending in-messages on the low-level transport, this</span></div>
<div class="line"><a id="l01529" name="l01529"></a><span class="lineno"> 1529</span><span class="comment">   * method does not call itself -- it reads all available messages in a loop until would-block or pipe-hosing error.</span></div>
<div class="line"><a id="l01530" name="l01530"></a><span class="lineno"> 1530</span><span class="comment">   * Therefore the following is *not* a trigger for calling this method:</span></div>
<div class="line"><a id="l01531" name="l01531"></a><span class="lineno"> 1531</span><span class="comment">   *   - we&#39;ve executed an async-read, and it yielded an in-message synchronously, which we then processed;</span></div>
<div class="line"><a id="l01532" name="l01532"></a><span class="lineno"> 1532</span><span class="comment">   *     and would like to now read as many in-messages as possible that follow it (synchronously).</span></div>
<div class="line"><a id="l01533" name="l01533"></a><span class="lineno"> 1533</span><span class="comment">   *</span></div>
<div class="line"><a id="l01534" name="l01534"></a><span class="lineno"> 1534</span><span class="comment">   * @param lead_else_cont</span></div>
<div class="line"><a id="l01535" name="l01535"></a><span class="lineno"> 1535</span><span class="comment">   *        `true` if seeking lead unstructured in-message; `false` if continuation.</span></div>
<div class="line"><a id="l01536" name="l01536"></a><span class="lineno"> 1536</span><span class="comment">   *        It may be helpful to look at Rcv_next_step docs for brief overview of when it would be one versus</span></div>
<div class="line"><a id="l01537" name="l01537"></a><span class="lineno"> 1537</span><span class="comment">   *        the other.  Or if you love reading and being confused by ygoldfel&#39;s verbiage then Msg_in_pipe doc</span></div>
<div class="line"><a id="l01538" name="l01538"></a><span class="lineno"> 1538</span><span class="comment">   *        header.  (The preceding sentence was written by ygoldfel.  Self-shade only.)</span></div>
<div class="line"><a id="l01539" name="l01539"></a><span class="lineno"> 1539</span><span class="comment">   * @param pipe</span></div>
<div class="line"><a id="l01540" name="l01540"></a><span class="lineno"> 1540</span><span class="comment">   *        Pointer into #m_rcv_pipes array.</span></div>
<div class="line"><a id="l01541" name="l01541"></a><span class="lineno"> 1541</span><span class="comment">   */</span></div>
<div class="line"><a id="l01542" name="l01542"></a><span class="lineno"> 1542</span>  <span class="keywordtype">void</span> <a class="code hl_function" href="classipc_1_1transport_1_1struc_1_1sync__io_1_1Channel.html#a252e43676b8a41a706df0655f887be63">rcv_async_read_lead_or_continuation_msg</a>(Msg_in_pipe* pipe, <span class="keywordtype">bool</span> lead_else_cont);</div>
<div class="line"><a id="l01543" name="l01543"></a><span class="lineno"> 1543</span><span class="comment"></span> </div>
<div class="line"><a id="l01544" name="l01544"></a><span class="lineno"> 1544</span><span class="comment">  /**</span></div>
<div class="line"><a id="l01545" name="l01545"></a><span class="lineno"> 1545</span><span class="comment">   * To execute upon completing an `m_channel.async_receive_*()` of an expected lead message along the given in-pipe,</span></div>
<div class="line"><a id="l01546" name="l01546"></a><span class="lineno"> 1546</span><span class="comment">   * this processes the result (message or error) and returns what should be done next; does *not* invoke</span></div>
<div class="line"><a id="l01547" name="l01547"></a><span class="lineno"> 1547</span><span class="comment">   * handlers_poll().</span></div>
<div class="line"><a id="l01548" name="l01548"></a><span class="lineno"> 1548</span><span class="comment">   *</span></div>
<div class="line"><a id="l01549" name="l01549"></a><span class="lineno"> 1549</span><span class="comment">   * @param pipe</span></div>
<div class="line"><a id="l01550" name="l01550"></a><span class="lineno"> 1550</span><span class="comment">   *        See rcv_async_read_lead_or_continuation_msg().</span></div>
<div class="line"><a id="l01551" name="l01551"></a><span class="lineno"> 1551</span><span class="comment">   *        `*pipe-&gt;m_target_blob` and `*pipe-&gt;m_target_hndl` may have been</span></div>
<div class="line"><a id="l01552" name="l01552"></a><span class="lineno"> 1552</span><span class="comment">   *        received-into.</span></div>
<div class="line"><a id="l01553" name="l01553"></a><span class="lineno"> 1553</span><span class="comment">   * @param err_code</span></div>
<div class="line"><a id="l01554" name="l01554"></a><span class="lineno"> 1554</span><span class="comment">   *        From `Channel::async_receive_*()`.</span></div>
<div class="line"><a id="l01555" name="l01555"></a><span class="lineno"> 1555</span><span class="comment">   * @param sz</span></div>
<div class="line"><a id="l01556" name="l01556"></a><span class="lineno"> 1556</span><span class="comment">   *        From `Channel::async_receive_*()`.</span></div>
<div class="line"><a id="l01557" name="l01557"></a><span class="lineno"> 1557</span><span class="comment">   * @return What to do next: read another lead message; read continuation message; or stop (pipe-hosing error).</span></div>
<div class="line"><a id="l01558" name="l01558"></a><span class="lineno"> 1558</span><span class="comment">   */</span></div>
<div class="line"><a id="l01559" name="l01559"></a><span class="lineno"> 1559</span>  <a class="code hl_enumeration" href="classipc_1_1transport_1_1struc_1_1sync__io_1_1Channel.html#a9d3344a97644dad136bb47e852dda6fd">Rcv_next_step</a> <a class="code hl_function" href="classipc_1_1transport_1_1struc_1_1sync__io_1_1Channel.html#af546fc0ab4d0ddca0a857c57decd0620">rcv_on_async_read_lead_msg</a>(Msg_in_pipe* pipe, <span class="keyword">const</span> <a class="code hl_typedef" href="namespaceipc.html#aa3192e586cc45d3e7c22463bf2760f89">Error_code</a>&amp; err_code, <span class="keywordtype">size_t</span> sz);</div>
<div class="line"><a id="l01560" name="l01560"></a><span class="lineno"> 1560</span><span class="comment"></span> </div>
<div class="line"><a id="l01561" name="l01561"></a><span class="lineno"> 1561</span><span class="comment">  /**</span></div>
<div class="line"><a id="l01562" name="l01562"></a><span class="lineno"> 1562</span><span class="comment">   * Same as rcv_on_async_read_lead_msg() but for an expected continuation message instead of lead.</span></div>
<div class="line"><a id="l01563" name="l01563"></a><span class="lineno"> 1563</span><span class="comment">   *</span></div>
<div class="line"><a id="l01564" name="l01564"></a><span class="lineno"> 1564</span><span class="comment">   * @param pipe</span></div>
<div class="line"><a id="l01565" name="l01565"></a><span class="lineno"> 1565</span><span class="comment">   *        See rcv_on_async_read_lead_msg().</span></div>
<div class="line"><a id="l01566" name="l01566"></a><span class="lineno"> 1566</span><span class="comment">   * @param err_code</span></div>
<div class="line"><a id="l01567" name="l01567"></a><span class="lineno"> 1567</span><span class="comment">   *        See rcv_on_async_read_lead_msg().</span></div>
<div class="line"><a id="l01568" name="l01568"></a><span class="lineno"> 1568</span><span class="comment">   * @param sz</span></div>
<div class="line"><a id="l01569" name="l01569"></a><span class="lineno"> 1569</span><span class="comment">   *        See rcv_on_async_read_lead_msg().</span></div>
<div class="line"><a id="l01570" name="l01570"></a><span class="lineno"> 1570</span><span class="comment">   * @return What to do next: read another continuation message; read lead message; or stop (pipe-hosing error).</span></div>
<div class="line"><a id="l01571" name="l01571"></a><span class="lineno"> 1571</span><span class="comment">   */</span></div>
<div class="line"><a id="l01572" name="l01572"></a><span class="lineno"> 1572</span>  <a class="code hl_enumeration" href="classipc_1_1transport_1_1struc_1_1sync__io_1_1Channel.html#a9d3344a97644dad136bb47e852dda6fd">Rcv_next_step</a> <a class="code hl_function" href="classipc_1_1transport_1_1struc_1_1sync__io_1_1Channel.html#aa83fd6e35057876e2f5173df53e73371">rcv_on_async_read_continuation_msg</a>(Msg_in_pipe* pipe, <span class="keyword">const</span> <a class="code hl_typedef" href="namespaceipc.html#aa3192e586cc45d3e7c22463bf2760f89">Error_code</a>&amp; err_code, <span class="keywordtype">size_t</span> sz);</div>
<div class="line"><a id="l01573" name="l01573"></a><span class="lineno"> 1573</span><span class="comment"></span> </div>
<div class="line"><a id="l01574" name="l01574"></a><span class="lineno"> 1574</span><span class="comment">  /**</span></div>
<div class="line"><a id="l01575" name="l01575"></a><span class="lineno"> 1575</span><span class="comment">   * Helper from `rcv_on_async_read_*()`, processes a newly completed structured in-message, as it exits</span></div>
<div class="line"><a id="l01576" name="l01576"></a><span class="lineno"> 1576</span><span class="comment">   * the `Channel`-layer and enters into the structured-layer of processing.</span></div>
<div class="line"><a id="l01577" name="l01577"></a><span class="lineno"> 1577</span><span class="comment">   *</span></div>
<div class="line"><a id="l01578" name="l01578"></a><span class="lineno"> 1578</span><span class="comment">   * #m_channel_err_code_or_ok must be falsy.</span></div>
<div class="line"><a id="l01579" name="l01579"></a><span class="lineno"> 1579</span><span class="comment">   *</span></div>
<div class="line"><a id="l01580" name="l01580"></a><span class="lineno"> 1580</span><span class="comment">   * @param msg_in</span></div>
<div class="line"><a id="l01581" name="l01581"></a><span class="lineno"> 1581</span><span class="comment">   *        The completed structured in-message: after Msg_in::deserialize_mdt() but before</span></div>
<div class="line"><a id="l01582" name="l01582"></a><span class="lineno"> 1582</span><span class="comment">   *        Msg_in::deserialize_body().</span></div>
<div class="line"><a id="l01583" name="l01583"></a><span class="lineno"> 1583</span><span class="comment">   * @return `false` if something in `msg_in` triggers truthy #m_channel_err_code_or_ok; hence</span></div>
<div class="line"><a id="l01584" name="l01584"></a><span class="lineno"> 1584</span><span class="comment">   *          the async-read chain must end now.  Otherwise `true`.</span></div>
<div class="line"><a id="l01585" name="l01585"></a><span class="lineno"> 1585</span><span class="comment">   */</span></div>
<div class="line"><a id="l01586" name="l01586"></a><span class="lineno"> 1586</span>  <span class="keywordtype">bool</span> <a class="code hl_function" href="classipc_1_1transport_1_1struc_1_1sync__io_1_1Channel.html#aa210976b523c04042dd083f054182441">rcv_struct_new_msg_in</a>(<a class="code hl_typedef" href="classipc_1_1transport_1_1struc_1_1sync__io_1_1Channel.html#a84287334d14f54c97f7dbb0d5b04cca5">Msg_in_ptr_uniq</a>&amp;&amp; msg_in);</div>
<div class="line"><a id="l01587" name="l01587"></a><span class="lineno"> 1587</span><span class="comment"></span> </div>
<div class="line"><a id="l01588" name="l01588"></a><span class="lineno"> 1588</span><span class="comment">  /**</span></div>
<div class="line"><a id="l01589" name="l01589"></a><span class="lineno"> 1589</span><span class="comment">   * Helper from `rcv_struct_new_msg_in()`: the case where the in-message has a sentinel message ID value, indicating</span></div>
<div class="line"><a id="l01590" name="l01590"></a><span class="lineno"> 1590</span><span class="comment">   * an internal message rather that one from a user send() (et al).</span></div>
<div class="line"><a id="l01591" name="l01591"></a><span class="lineno"> 1591</span><span class="comment">   *</span></div>
<div class="line"><a id="l01592" name="l01592"></a><span class="lineno"> 1592</span><span class="comment">   * #m_channel_err_code_or_ok must be falsy.</span></div>
<div class="line"><a id="l01593" name="l01593"></a><span class="lineno"> 1593</span><span class="comment">   *</span></div>
<div class="line"><a id="l01594" name="l01594"></a><span class="lineno"> 1594</span><span class="comment">   * @param msg_in</span></div>
<div class="line"><a id="l01595" name="l01595"></a><span class="lineno"> 1595</span><span class="comment">   *        Deserialized in-message with sentinel message ID value.</span></div>
<div class="line"><a id="l01596" name="l01596"></a><span class="lineno"> 1596</span><span class="comment">   * @return See rcv_struct_new_msg_in().</span></div>
<div class="line"><a id="l01597" name="l01597"></a><span class="lineno"> 1597</span><span class="comment">   */</span></div>
<div class="line"><a id="l01598" name="l01598"></a><span class="lineno"> 1598</span>  <span class="keywordtype">bool</span> <a class="code hl_function" href="classipc_1_1transport_1_1struc_1_1sync__io_1_1Channel.html#ab8bfe06a0aecb261dd11624c4ddec518">rcv_struct_new_internal_msg_in</a>(<span class="keyword">const</span> <a class="code hl_class" href="classipc_1_1transport_1_1struc_1_1Msg__in__impl.html">Msg_in_impl</a>&amp; msg_in);</div>
<div class="line"><a id="l01599" name="l01599"></a><span class="lineno"> 1599</span><span class="comment"></span> </div>
<div class="line"><a id="l01600" name="l01600"></a><span class="lineno"> 1600</span><span class="comment">  /**</span></div>
<div class="line"><a id="l01601" name="l01601"></a><span class="lineno"> 1601</span><span class="comment">   * Helper from `rcv_struct_new_msg_in()`: the case where #m_phase is Phase::S_CLI_LOG_IN, and the in-message has</span></div>
<div class="line"><a id="l01602" name="l01602"></a><span class="lineno"> 1602</span><span class="comment">   * the log-in-response value 1 + session-token=nil as required: Processes the in-message according to the rigid</span></div>
<div class="line"><a id="l01603" name="l01603"></a><span class="lineno"> 1603</span><span class="comment">   * log-in phase algorithm.  rcv_struct_new_msg_in() returns what this returns, immediately.</span></div>
<div class="line"><a id="l01604" name="l01604"></a><span class="lineno"> 1604</span><span class="comment">   *</span></div>
<div class="line"><a id="l01605" name="l01605"></a><span class="lineno"> 1605</span><span class="comment">   * #m_channel_err_code_or_ok must be falsy.</span></div>
<div class="line"><a id="l01606" name="l01606"></a><span class="lineno"> 1606</span><span class="comment">   *</span></div>
<div class="line"><a id="l01607" name="l01607"></a><span class="lineno"> 1607</span><span class="comment">   * @param msg_in</span></div>
<div class="line"><a id="l01608" name="l01608"></a><span class="lineno"> 1608</span><span class="comment">   *        Deserialized in-message with message ID 1 and session-token=nil.</span></div>
<div class="line"><a id="l01609" name="l01609"></a><span class="lineno"> 1609</span><span class="comment">   * @return See rcv_struct_new_msg_in().</span></div>
<div class="line"><a id="l01610" name="l01610"></a><span class="lineno"> 1610</span><span class="comment">   */</span></div>
<div class="line"><a id="l01611" name="l01611"></a><span class="lineno"> 1611</span>  <span class="keywordtype">bool</span> <a class="code hl_function" href="classipc_1_1transport_1_1struc_1_1sync__io_1_1Channel.html#aff04d908fa53c7df582f3b2b6e51cfce">rcv_struct_new_msg_in_during_log_in_as_cli</a>(<a class="code hl_typedef" href="classipc_1_1transport_1_1struc_1_1sync__io_1_1Channel.html#a84287334d14f54c97f7dbb0d5b04cca5">Msg_in_ptr_uniq</a>&amp;&amp; msg_in);</div>
<div class="line"><a id="l01612" name="l01612"></a><span class="lineno"> 1612</span><span class="comment"></span> </div>
<div class="line"><a id="l01613" name="l01613"></a><span class="lineno"> 1613</span><span class="comment">  /**</span></div>
<div class="line"><a id="l01614" name="l01614"></a><span class="lineno"> 1614</span><span class="comment">   * Like rcv_struct_new_msg_in_during_log_in_as_cli() but for Phase::S_SRV_LOG_IN instead of CLI_LOG_IN.</span></div>
<div class="line"><a id="l01615" name="l01615"></a><span class="lineno"> 1615</span><span class="comment">   *</span></div>
<div class="line"><a id="l01616" name="l01616"></a><span class="lineno"> 1616</span><span class="comment">   * @param msg_in</span></div>
<div class="line"><a id="l01617" name="l01617"></a><span class="lineno"> 1617</span><span class="comment">   *        See rcv_struct_new_msg_in_during_log_in_as_cli().</span></div>
<div class="line"><a id="l01618" name="l01618"></a><span class="lineno"> 1618</span><span class="comment">   * @return See rcv_struct_new_msg_in_during_log_in_as_cli().</span></div>
<div class="line"><a id="l01619" name="l01619"></a><span class="lineno"> 1619</span><span class="comment">   */</span></div>
<div class="line"><a id="l01620" name="l01620"></a><span class="lineno"> 1620</span>  <span class="keywordtype">bool</span> <a class="code hl_function" href="classipc_1_1transport_1_1struc_1_1sync__io_1_1Channel.html#a9174c694ee8437605c089965ecea2ebf">rcv_struct_new_msg_in_during_log_in_as_srv</a>(<a class="code hl_typedef" href="classipc_1_1transport_1_1struc_1_1sync__io_1_1Channel.html#a84287334d14f54c97f7dbb0d5b04cca5">Msg_in_ptr_uniq</a>&amp;&amp; msg_in);</div>
<div class="line"><a id="l01621" name="l01621"></a><span class="lineno"> 1621</span><span class="comment"></span> </div>
<div class="line"><a id="l01622" name="l01622"></a><span class="lineno"> 1622</span><span class="comment">  /**</span></div>
<div class="line"><a id="l01623" name="l01623"></a><span class="lineno"> 1623</span><span class="comment">   * Helper from `rcv_struct_new_msg_in()` (possibly indirectly): the case where the in-message&#39;s session-token</span></div>
<div class="line"><a id="l01624" name="l01624"></a><span class="lineno"> 1624</span><span class="comment">   * and message ID have been validated (and the latter indicates a user, not internal, message), and</span></div>
<div class="line"><a id="l01625" name="l01625"></a><span class="lineno"> 1625</span><span class="comment">   * the message ID (seq #) indicates this is the next expected in-order message (hence #m_rcv_msg_next_id was</span></div>
<div class="line"><a id="l01626" name="l01626"></a><span class="lineno"> 1626</span><span class="comment">   * just `++`ed).  #m_phase may be any of the 3 values; but the special processing in</span></div>
<div class="line"><a id="l01627" name="l01627"></a><span class="lineno"> 1627</span><span class="comment">   * rcv_struct_new_msg_in_during_log_in_as_cli() or rcv_struct_new_msg_in_during_log_in_as_srv() must have</span></div>
<div class="line"><a id="l01628" name="l01628"></a><span class="lineno"> 1628</span><span class="comment">   * already completed if not LOGGED_IN.</span></div>
<div class="line"><a id="l01629" name="l01629"></a><span class="lineno"> 1629</span><span class="comment">   *</span></div>
<div class="line"><a id="l01630" name="l01630"></a><span class="lineno"> 1630</span><span class="comment">   * Assuming no detected error therein, this method processes taking `msg_in` from the lower 2-3 layers</span></div>
<div class="line"><a id="l01631" name="l01631"></a><span class="lineno"> 1631</span><span class="comment">   * (Channel-layer, structured message layer, possibly reassembly queue layer) into the next 1-2</span></div>
<div class="line"><a id="l01632" name="l01632"></a><span class="lineno"> 1632</span><span class="comment">   * (possibly caching in #m_rcv_pending_msgs, emission to user).</span></div>
<div class="line"><a id="l01633" name="l01633"></a><span class="lineno"> 1633</span><span class="comment">   *</span></div>
<div class="line"><a id="l01634" name="l01634"></a><span class="lineno"> 1634</span><span class="comment">   * Handles just `msg_in` itself: Does not check whether the gap to any messages in #m_rcv_reassembly_q</span></div>
<div class="line"><a id="l01635" name="l01635"></a><span class="lineno"> 1635</span><span class="comment">   * has been filled by this.  That is, it&#39;s not self-perpetuating: caller must call us again for any</span></div>
<div class="line"><a id="l01636" name="l01636"></a><span class="lineno"> 1636</span><span class="comment">   * messages dequeued from #m_rcv_reassembly_q.</span></div>
<div class="line"><a id="l01637" name="l01637"></a><span class="lineno"> 1637</span><span class="comment">   *</span></div>
<div class="line"><a id="l01638" name="l01638"></a><span class="lineno"> 1638</span><span class="comment">   * #m_channel_err_code_or_ok must be falsy.</span></div>
<div class="line"><a id="l01639" name="l01639"></a><span class="lineno"> 1639</span><span class="comment">   *</span></div>
<div class="line"><a id="l01640" name="l01640"></a><span class="lineno"> 1640</span><span class="comment">   * @param msg_in</span></div>
<div class="line"><a id="l01641" name="l01641"></a><span class="lineno"> 1641</span><span class="comment">   *        Deserialized in-message with sentinel message ID value.</span></div>
<div class="line"><a id="l01642" name="l01642"></a><span class="lineno"> 1642</span><span class="comment">   * @return See rcv_struct_new_msg_in().</span></div>
<div class="line"><a id="l01643" name="l01643"></a><span class="lineno"> 1643</span><span class="comment">   */</span></div>
<div class="line"><a id="l01644" name="l01644"></a><span class="lineno"> 1644</span>  <span class="keywordtype">bool</span> <a class="code hl_function" href="classipc_1_1transport_1_1struc_1_1sync__io_1_1Channel.html#a134966e02297d141b9e6d5e0d2ca3a7b">rcv_struct_new_msg_in_is_next_expected</a>(<a class="code hl_typedef" href="classipc_1_1transport_1_1struc_1_1sync__io_1_1Channel.html#a84287334d14f54c97f7dbb0d5b04cca5">Msg_in_ptr_uniq</a>&amp;&amp; msg_in);</div>
<div class="line"><a id="l01645" name="l01645"></a><span class="lineno"> 1645</span><span class="comment"></span> </div>
<div class="line"><a id="l01646" name="l01646"></a><span class="lineno"> 1646</span><span class="comment">  /**</span></div>
<div class="line"><a id="l01647" name="l01647"></a><span class="lineno"> 1647</span><span class="comment">   * Helper from rcv_struct_new_msg_in_is_next_expected() that reacts to receiving an otherwise valid</span></div>
<div class="line"><a id="l01648" name="l01648"></a><span class="lineno"> 1648</span><span class="comment">   * reponse in-message when no such response is expected.  Hence it deals with</span></div>
<div class="line"><a id="l01649" name="l01649"></a><span class="lineno"> 1649</span><span class="comment">   * set_unexpected_response_handler() (if set) handler invocation and informing the opposing side, so that</span></div>
<div class="line"><a id="l01650" name="l01650"></a><span class="lineno"> 1650</span><span class="comment">   * it might invoke its set_remote_unexpected_response_handler() (if set) handler.</span></div>
<div class="line"><a id="l01651" name="l01651"></a><span class="lineno"> 1651</span><span class="comment">   *</span></div>
<div class="line"><a id="l01652" name="l01652"></a><span class="lineno"> 1652</span><span class="comment">   * @param msg_in</span></div>
<div class="line"><a id="l01653" name="l01653"></a><span class="lineno"> 1653</span><span class="comment">   *        See rcv_struct_new_msg_in_is_next_expected().</span></div>
<div class="line"><a id="l01654" name="l01654"></a><span class="lineno"> 1654</span><span class="comment">   */</span></div>
<div class="line"><a id="l01655" name="l01655"></a><span class="lineno"> 1655</span>  <span class="keywordtype">void</span> <a class="code hl_function" href="classipc_1_1transport_1_1struc_1_1sync__io_1_1Channel.html#a795baef6fefbc4749daf5ceda52943c1">rcv_struct_inform_of_unexpected_response</a>(<a class="code hl_typedef" href="classipc_1_1transport_1_1struc_1_1sync__io_1_1Channel.html#a84287334d14f54c97f7dbb0d5b04cca5">Msg_in_ptr_uniq</a>&amp;&amp; msg_in);</div>
<div class="line"><a id="l01656" name="l01656"></a><span class="lineno"> 1656</span><span class="comment"></span> </div>
<div class="line"><a id="l01657" name="l01657"></a><span class="lineno"> 1657</span><span class="comment">  /**</span></div>
<div class="line"><a id="l01658" name="l01658"></a><span class="lineno"> 1658</span><span class="comment">   * Helper for async handlers:</span></div>
<div class="line"><a id="l01659" name="l01659"></a><span class="lineno"> 1659</span><span class="comment">   * returns `true` if and only if `err_code` indicates a new error or #m_channel_err_code_or_ok</span></div>
<div class="line"><a id="l01660" name="l01660"></a><span class="lineno"> 1660</span><span class="comment">   * indicates a previously-occurred one or both; updates #m_channel_err_code_or_ok to `err_code` in the</span></div>
<div class="line"><a id="l01661" name="l01661"></a><span class="lineno"> 1661</span><span class="comment">   * former case.  Logs appropriately.</span></div>
<div class="line"><a id="l01662" name="l01662"></a><span class="lineno"> 1662</span><span class="comment">   *</span></div>
<div class="line"><a id="l01663" name="l01663"></a><span class="lineno"> 1663</span><span class="comment">   * @param err_code</span></div>
<div class="line"><a id="l01664" name="l01664"></a><span class="lineno"> 1664</span><span class="comment">   *        Code from the async op.</span></div>
<div class="line"><a id="l01665" name="l01665"></a><span class="lineno"> 1665</span><span class="comment">   * @param context</span></div>
<div class="line"><a id="l01666" name="l01666"></a><span class="lineno"> 1666</span><span class="comment">   *        Brief context string for logging.</span></div>
<div class="line"><a id="l01667" name="l01667"></a><span class="lineno"> 1667</span><span class="comment">   * @return `true` if `err_code` or a prior condition indicate the channel is hosed; `false` otherwise.</span></div>
<div class="line"><a id="l01668" name="l01668"></a><span class="lineno"> 1668</span><span class="comment">   */</span></div>
<div class="line"><a id="l01669" name="l01669"></a><span class="lineno"> 1669</span>  <span class="keywordtype">bool</span> <a class="code hl_function" href="classipc_1_1transport_1_1struc_1_1sync__io_1_1Channel.html#ab17b00ae995cf634c721420cd85fdef2">handle_async_err_code</a>(<span class="keyword">const</span> <a class="code hl_typedef" href="namespaceipc.html#aa3192e586cc45d3e7c22463bf2760f89">Error_code</a>&amp; err_code, <a class="code hl_typedef" href="namespaceipc_1_1util.html#ae6ac47812a90d1287c61e0b7de7bc4f5">util::String_view</a> context);</div>
<div class="line"><a id="l01670" name="l01670"></a><span class="lineno"> 1670</span><span class="comment"></span> </div>
<div class="line"><a id="l01671" name="l01671"></a><span class="lineno"> 1671</span><span class="comment">  /**</span></div>
<div class="line"><a id="l01672" name="l01672"></a><span class="lineno"> 1672</span><span class="comment">   * Helper that handles the situation where #m_channel_err_code_or_ok is falsy, and processing has</span></div>
<div class="line"><a id="l01673" name="l01673"></a><span class="lineno"> 1673</span><span class="comment">   * found a new error condition.  Sets #m_channel_err_code_or_ok accordingly and emits to on-error handler.</span></div>
<div class="line"><a id="l01674" name="l01674"></a><span class="lineno"> 1674</span><span class="comment">   *</span></div>
<div class="line"><a id="l01675" name="l01675"></a><span class="lineno"> 1675</span><span class="comment">   * Do *not* use when synchronously emitting an error (send_core() only as of this writing).</span></div>
<div class="line"><a id="l01676" name="l01676"></a><span class="lineno"> 1676</span><span class="comment">   *</span></div>
<div class="line"><a id="l01677" name="l01677"></a><span class="lineno"> 1677</span><span class="comment">   * @param err_code_not_ok</span></div>
<div class="line"><a id="l01678" name="l01678"></a><span class="lineno"> 1678</span><span class="comment">   *        Truthy code (or assertion may trip).</span></div>
<div class="line"><a id="l01679" name="l01679"></a><span class="lineno"> 1679</span><span class="comment">   * @param context</span></div>
<div class="line"><a id="l01680" name="l01680"></a><span class="lineno"> 1680</span><span class="comment">   *        Brief context string for logging.</span></div>
<div class="line"><a id="l01681" name="l01681"></a><span class="lineno"> 1681</span><span class="comment">   */</span></div>
<div class="line"><a id="l01682" name="l01682"></a><span class="lineno"> 1682</span>  <span class="keywordtype">void</span> <a class="code hl_function" href="classipc_1_1transport_1_1struc_1_1sync__io_1_1Channel.html#ad3f5d174c65db9d5ec3b14769fb9574a">handle_new_error</a>(<span class="keyword">const</span> <a class="code hl_typedef" href="namespaceipc.html#aa3192e586cc45d3e7c22463bf2760f89">Error_code</a>&amp; err_code_not_ok, <a class="code hl_typedef" href="namespaceipc_1_1util.html#ae6ac47812a90d1287c61e0b7de7bc4f5">util::String_view</a> context);</div>
<div class="line"><a id="l01683" name="l01683"></a><span class="lineno"> 1683</span><span class="comment"></span> </div>
<div class="line"><a id="l01684" name="l01684"></a><span class="lineno"> 1684</span><span class="comment">  /**</span></div>
<div class="line"><a id="l01685" name="l01685"></a><span class="lineno"> 1685</span><span class="comment">   * Helper that returns `true` if and only if start_ops() has not yet been called.  This guard is required for</span></div>
<div class="line"><a id="l01686" name="l01686"></a><span class="lineno"> 1686</span><span class="comment">   * APIs that trigger #m_channel transmission API calls.  Outgoing-direction such calls would be, e.g.,</span></div>
<div class="line"><a id="l01687" name="l01687"></a><span class="lineno"> 1687</span><span class="comment">   * send() and async_end_sending().  Incoming-direction transmission is all triggered by start_and_poll() (which</span></div>
<div class="line"><a id="l01688" name="l01688"></a><span class="lineno"> 1688</span><span class="comment">   * begins the async-read chain(s) indefinitely.)</span></div>
<div class="line"><a id="l01689" name="l01689"></a><span class="lineno"> 1689</span><span class="comment">   *</span></div>
<div class="line"><a id="l01690" name="l01690"></a><span class="lineno"> 1690</span><span class="comment">   * @param context</span></div>
<div class="line"><a id="l01691" name="l01691"></a><span class="lineno"> 1691</span><span class="comment">   *        Brief context string for logging.</span></div>
<div class="line"><a id="l01692" name="l01692"></a><span class="lineno"> 1692</span><span class="comment">   * @return `true` if not started (do not proceed); else `false`.</span></div>
<div class="line"><a id="l01693" name="l01693"></a><span class="lineno"> 1693</span><span class="comment">   */</span></div>
<div class="line"><a id="l01694" name="l01694"></a><span class="lineno"> 1694</span>  <span class="keywordtype">bool</span> <a class="code hl_function" href="classipc_1_1transport_1_1struc_1_1sync__io_1_1Channel.html#ae2a7cdf855b3cdcab1a2e1cd74834cc4">check_not_started_ops</a>(<a class="code hl_typedef" href="namespaceipc_1_1util.html#ae6ac47812a90d1287c61e0b7de7bc4f5">util::String_view</a> context) <span class="keyword">const</span>;</div>
<div class="line"><a id="l01695" name="l01695"></a><span class="lineno"> 1695</span><span class="comment"></span> </div>
<div class="line"><a id="l01696" name="l01696"></a><span class="lineno"> 1696</span><span class="comment">  /**</span></div>
<div class="line"><a id="l01697" name="l01697"></a><span class="lineno"> 1697</span><span class="comment">   * Helper for some public APIs to use at the top: ensures that no prior error has been detected</span></div>
<div class="line"><a id="l01698" name="l01698"></a><span class="lineno"> 1698</span><span class="comment">   * (by incoming-direction processing or send()); returns `true` if not; `false` if so.</span></div>
<div class="line"><a id="l01699" name="l01699"></a><span class="lineno"> 1699</span><span class="comment">   * I.e., please no-op if returns `true`.</span></div>
<div class="line"><a id="l01700" name="l01700"></a><span class="lineno"> 1700</span><span class="comment">   *</span></div>
<div class="line"><a id="l01701" name="l01701"></a><span class="lineno"> 1701</span><span class="comment">   * @param context</span></div>
<div class="line"><a id="l01702" name="l01702"></a><span class="lineno"> 1702</span><span class="comment">   *        Brief context string for logging.</span></div>
<div class="line"><a id="l01703" name="l01703"></a><span class="lineno"> 1703</span><span class="comment">   * @return See above.  `true` bad.  `false` good.</span></div>
<div class="line"><a id="l01704" name="l01704"></a><span class="lineno"> 1704</span><span class="comment">   */</span></div>
<div class="line"><a id="l01705" name="l01705"></a><span class="lineno"> 1705</span>  <span class="keywordtype">bool</span> <a class="code hl_function" href="classipc_1_1transport_1_1struc_1_1sync__io_1_1Channel.html#abeb37ac07422166123553920393d5ab4">check_prior_error</a>(<a class="code hl_typedef" href="namespaceipc_1_1util.html#ae6ac47812a90d1287c61e0b7de7bc4f5">util::String_view</a> context) <span class="keyword">const</span>;</div>
<div class="line"><a id="l01706" name="l01706"></a><span class="lineno"> 1706</span><span class="comment"></span> </div>
<div class="line"><a id="l01707" name="l01707"></a><span class="lineno"> 1707</span><span class="comment">  /**</span></div>
<div class="line"><a id="l01708" name="l01708"></a><span class="lineno"> 1708</span><span class="comment">   * Helper for most public APIs to use at the top: ensures check_prior_error() passes, and that #m_phase equals</span></div>
<div class="line"><a id="l01709" name="l01709"></a><span class="lineno"> 1709</span><span class="comment">   * `required_phase`; returns `true` if not; `false` if so.  I.e., please no-op if returns `true`.</span></div>
<div class="line"><a id="l01710" name="l01710"></a><span class="lineno"> 1710</span><span class="comment">   *</span></div>
<div class="line"><a id="l01711" name="l01711"></a><span class="lineno"> 1711</span><span class="comment">   * @param required_phase</span></div>
<div class="line"><a id="l01712" name="l01712"></a><span class="lineno"> 1712</span><span class="comment">   *        #m_phase must equal this to return `false`.</span></div>
<div class="line"><a id="l01713" name="l01713"></a><span class="lineno"> 1713</span><span class="comment">   * @param context</span></div>
<div class="line"><a id="l01714" name="l01714"></a><span class="lineno"> 1714</span><span class="comment">   *        Brief context string for logging.</span></div>
<div class="line"><a id="l01715" name="l01715"></a><span class="lineno"> 1715</span><span class="comment">   * @return See above.  `true` bad.  `false` good.</span></div>
<div class="line"><a id="l01716" name="l01716"></a><span class="lineno"> 1716</span><span class="comment">   */</span></div>
<div class="line"><a id="l01717" name="l01717"></a><span class="lineno"> 1717</span>  <span class="keywordtype">bool</span> <a class="code hl_function" href="classipc_1_1transport_1_1struc_1_1sync__io_1_1Channel.html#ae6b2691d6471330d8b7cc7e8e9320054">check_phase_and_prior_error</a>(<a class="code hl_enumeration" href="classipc_1_1transport_1_1struc_1_1sync__io_1_1Channel.html#a5a3833cd141802041551db21198ac319">Phase</a> required_phase, <a class="code hl_typedef" href="namespaceipc_1_1util.html#ae6ac47812a90d1287c61e0b7de7bc4f5">util::String_view</a> context) <span class="keyword">const</span>;</div>
<div class="line"><a id="l01718" name="l01718"></a><span class="lineno"> 1718</span><span class="comment"></span> </div>
<div class="line"><a id="l01719" name="l01719"></a><span class="lineno"> 1719</span><span class="comment">  /**</span></div>
<div class="line"><a id="l01720" name="l01720"></a><span class="lineno"> 1720</span><span class="comment">   * Core of expect_msg(), expect_msgs(), and expect_log_in_request().  Records the expectation of the given</span></div>
<div class="line"><a id="l01721" name="l01721"></a><span class="lineno"> 1721</span><span class="comment">   * message type (`which`) in #m_rcv_pending_msgs; then scans messages queued-up in #m_rcv_pending_msgs with matching</span></div>
<div class="line"><a id="l01722" name="l01722"></a><span class="lineno"> 1722</span><span class="comment">   * #Msg_which_in, in order.  It async-emits one (if `one_off`) or all (otherwise) such messages into `*qd_msgs`</span></div>
<div class="line"><a id="l01723" name="l01723"></a><span class="lineno"> 1723</span><span class="comment">   * out-arg.</span></div>
<div class="line"><a id="l01724" name="l01724"></a><span class="lineno"> 1724</span><span class="comment">   *</span></div>
<div class="line"><a id="l01725" name="l01725"></a><span class="lineno"> 1725</span><span class="comment">   * Note that, if `one_off`, and a matching in-message is queued, #m_rcv_pending_msgs will not have changed</span></div>
<div class="line"><a id="l01726" name="l01726"></a><span class="lineno"> 1726</span><span class="comment">   * when comparing pre- and post-state.</span></div>
<div class="line"><a id="l01727" name="l01727"></a><span class="lineno"> 1727</span><span class="comment">   *</span></div>
<div class="line"><a id="l01728" name="l01728"></a><span class="lineno"> 1728</span><span class="comment">   * @param qd_msgs</span></div>
<div class="line"><a id="l01729" name="l01729"></a><span class="lineno"> 1729</span><span class="comment">   *        See expect_msgs() and similar.</span></div>
<div class="line"><a id="l01730" name="l01730"></a><span class="lineno"> 1730</span><span class="comment">   * @param one_off</span></div>
<div class="line"><a id="l01731" name="l01731"></a><span class="lineno"> 1731</span><span class="comment">   *        `true` for expect_msg() and expect_log_in_request() (which are almost identical); `false`</span></div>
<div class="line"><a id="l01732" name="l01732"></a><span class="lineno"> 1732</span><span class="comment">   *        for expect_msgs().  In the latter case undo_expect_msgs() is a thing.</span></div>
<div class="line"><a id="l01733" name="l01733"></a><span class="lineno"> 1733</span><span class="comment">   * @param which</span></div>
<div class="line"><a id="l01734" name="l01734"></a><span class="lineno"> 1734</span><span class="comment">   *        Message type to expect.</span></div>
<div class="line"><a id="l01735" name="l01735"></a><span class="lineno"> 1735</span><span class="comment">   * @param on_msg_func</span></div>
<div class="line"><a id="l01736" name="l01736"></a><span class="lineno"> 1736</span><span class="comment">   *        See expect_msg() among others.</span></div>
<div class="line"><a id="l01737" name="l01737"></a><span class="lineno"> 1737</span><span class="comment">   * @return `true` usually; `false` if `which` expectation is already in #m_rcv_pending_msgs; or if</span></div>
<div class="line"><a id="l01738" name="l01738"></a><span class="lineno"> 1738</span><span class="comment">   *         #m_phase is LOGGED_IN, and #m_rcv_pending_msgs does contain a queued-up in-message already,</span></div>
<div class="line"><a id="l01739" name="l01739"></a><span class="lineno"> 1739</span><span class="comment">   *         *and* its #Msg_which_in does not equal `which`.  The latter indicates that the logging-in opposing peer</span></div>
<div class="line"><a id="l01740" name="l01740"></a><span class="lineno"> 1740</span><span class="comment">   *         disagrees with the expected protocol and issued a log-in request of unexpected type;</span></div>
<div class="line"><a id="l01741" name="l01741"></a><span class="lineno"> 1741</span><span class="comment">   *         the on-error handler shall fire asynchronously+immediately, similarly to having received</span></div>
<div class="line"><a id="l01742" name="l01742"></a><span class="lineno"> 1742</span><span class="comment">   *         the erroneous in-message *after* expect_msgs_impl() returns.</span></div>
<div class="line"><a id="l01743" name="l01743"></a><span class="lineno"> 1743</span><span class="comment">   */</span></div>
<div class="line"><a id="l01744" name="l01744"></a><span class="lineno"> 1744</span>  <span class="keywordtype">bool</span> <a class="code hl_function" href="classipc_1_1transport_1_1struc_1_1sync__io_1_1Channel.html#a2552eada8012c4a8c4d2fc5f02e9f69b">expect_msgs_impl</a>(<a class="code hl_typedef" href="classipc_1_1transport_1_1struc_1_1sync__io_1_1Channel.html#a4ab778bce8d7e6e84788879fedc62745">Msgs_in</a>* qd_msgs, <span class="keywordtype">bool</span> one_off, <a class="code hl_typedef" href="classipc_1_1transport_1_1struc_1_1sync__io_1_1Channel.html#aa40c3ec3f45cdfea9360f7f35b9ade3c">Msg_which_in</a> which, <a class="code hl_typedef" href="classipc_1_1transport_1_1struc_1_1sync__io_1_1Channel.html#a583ccd4bb6b1aefb09d77e5709aef5b4">On_msg_func_ptr</a>&amp;&amp; on_msg_func);</div>
<div class="line"><a id="l01745" name="l01745"></a><span class="lineno"> 1745</span><span class="comment"></span> </div>
<div class="line"><a id="l01746" name="l01746"></a><span class="lineno"> 1746</span><span class="comment">  /**</span></div>
<div class="line"><a id="l01747" name="l01747"></a><span class="lineno"> 1747</span><span class="comment">   * send() and async_request() implementation.</span></div>
<div class="line"><a id="l01748" name="l01748"></a><span class="lineno"> 1748</span><span class="comment">   * Note this is still the higher-level, public send() or async_request() really;</span></div>
<div class="line"><a id="l01749" name="l01749"></a><span class="lineno"> 1749</span><span class="comment">   * it handles *user* messages; and once it has decided to indeed attempt the actual sending over</span></div>
<div class="line"><a id="l01750" name="l01750"></a><span class="lineno"> 1750</span><span class="comment">   * #Owned_channel, it synchronously invokes send_core().  To send an internal message use send_core()</span></div>
<div class="line"><a id="l01751" name="l01751"></a><span class="lineno"> 1751</span><span class="comment">   * directly.</span></div>
<div class="line"><a id="l01752" name="l01752"></a><span class="lineno"> 1752</span><span class="comment">   *</span></div>
<div class="line"><a id="l01753" name="l01753"></a><span class="lineno"> 1753</span><span class="comment">   * `check_unsendable(msg)` and `check_prior_error()` must have returned `false`.</span></div>
<div class="line"><a id="l01754" name="l01754"></a><span class="lineno"> 1754</span><span class="comment">   *</span></div>
<div class="line"><a id="l01755" name="l01755"></a><span class="lineno"> 1755</span><span class="comment">   * @param msg</span></div>
<div class="line"><a id="l01756" name="l01756"></a><span class="lineno"> 1756</span><span class="comment">   *        See send() and sync_request().</span></div>
<div class="line"><a id="l01757" name="l01757"></a><span class="lineno"> 1757</span><span class="comment">   * @param originating_msg_or_null</span></div>
<div class="line"><a id="l01758" name="l01758"></a><span class="lineno"> 1758</span><span class="comment">   *        See send() and sync_request().</span></div>
<div class="line"><a id="l01759" name="l01759"></a><span class="lineno"> 1759</span><span class="comment">   * @param err_code</span></div>
<div class="line"><a id="l01760" name="l01760"></a><span class="lineno"> 1760</span><span class="comment">   *        Non-null target #Error_code.</span></div>
<div class="line"><a id="l01761" name="l01761"></a><span class="lineno"> 1761</span><span class="comment">   * @param on_rsp_func_or_null</span></div>
<div class="line"><a id="l01762" name="l01762"></a><span class="lineno"> 1762</span><span class="comment">   *        For async_request() non-null pointer to `on_rsp_func`; else null.</span></div>
<div class="line"><a id="l01763" name="l01763"></a><span class="lineno"> 1763</span><span class="comment">   * @param id_unless_one_off</span></div>
<div class="line"><a id="l01764" name="l01764"></a><span class="lineno"> 1764</span><span class="comment">   *        Ignored if `on_rsp_func_or_null` is null: See async_request().</span></div>
<div class="line"><a id="l01765" name="l01765"></a><span class="lineno"> 1765</span><span class="comment">   * @return See send() and async_request().</span></div>
<div class="line"><a id="l01766" name="l01766"></a><span class="lineno"> 1766</span><span class="comment">   */</span></div>
<div class="line"><a id="l01767" name="l01767"></a><span class="lineno"> 1767</span>  <span class="keywordtype">bool</span> <a class="code hl_function" href="classipc_1_1transport_1_1struc_1_1sync__io_1_1Channel.html#aafaf244b9483c724eaba1d6bee561035">send_impl</a>(<span class="keyword">const</span> <a class="code hl_class" href="classipc_1_1transport_1_1struc_1_1Msg__out.html">Msg_out</a>&amp; msg, <span class="keyword">const</span> <a class="code hl_class" href="classipc_1_1transport_1_1struc_1_1Msg__in.html">Msg_in</a>* originating_msg_or_null, <a class="code hl_typedef" href="namespaceipc.html#aa3192e586cc45d3e7c22463bf2760f89">Error_code</a>* err_code,</div>
<div class="line"><a id="l01768" name="l01768"></a><span class="lineno"> 1768</span>                 <span class="keyword">const</span> <a class="code hl_typedef" href="classipc_1_1transport_1_1struc_1_1sync__io_1_1Channel.html#a583ccd4bb6b1aefb09d77e5709aef5b4">On_msg_func_ptr</a>&amp; on_rsp_func_or_null, <a class="code hl_typedef" href="classipc_1_1transport_1_1struc_1_1sync__io_1_1Channel.html#a9b5d17887c9ad1e37081bf4ae4a70e65">msg_id_out_t</a>* id_unless_one_off);</div>
<div class="line"><a id="l01769" name="l01769"></a><span class="lineno"> 1769</span><span class="comment"></span> </div>
<div class="line"><a id="l01770" name="l01770"></a><span class="lineno"> 1770</span><span class="comment">  /**</span></div>
<div class="line"><a id="l01771" name="l01771"></a><span class="lineno"> 1771</span><span class="comment">   * Core of send() or internal-message-send: Serializes the given structured out-messages (metadata out-message;</span></div>
<div class="line"><a id="l01772" name="l01772"></a><span class="lineno"> 1772</span><span class="comment">   * user out-message optionally) and `Owned_channel::send*()`s the result (synchronously).</span></div>
<div class="line"><a id="l01773" name="l01773"></a><span class="lineno"> 1773</span><span class="comment">   *</span></div>
<div class="line"><a id="l01774" name="l01774"></a><span class="lineno"> 1774</span><span class="comment">   * This is the last step of send() and async_request() (for user out-messages) or an internal attempt to send</span></div>
<div class="line"><a id="l01775" name="l01775"></a><span class="lineno"> 1775</span><span class="comment">   * internal out-message.  As such (being the last step):</span></div>
<div class="line"><a id="l01776" name="l01776"></a><span class="lineno"> 1776</span><span class="comment">   * If user message (`msg` not null), and send_core() succeeds in Phase::S_SRV_LOG_IN, #m_phase moves to</span></div>
<div class="line"><a id="l01777" name="l01777"></a><span class="lineno"> 1777</span><span class="comment">   * Phase::S_LOGGED_IN within this method.</span></div>
<div class="line"><a id="l01778" name="l01778"></a><span class="lineno"> 1778</span><span class="comment">   *</span></div>
<div class="line"><a id="l01779" name="l01779"></a><span class="lineno"> 1779</span><span class="comment">   * As of this writing `msg` being null (internal message) means</span></div>
<div class="line"><a id="l01780" name="l01780"></a><span class="lineno"> 1780</span><span class="comment">   * we are logged-in; behavior is undefined (assertion may trip) otherwise.  Rationale: We aim to keep log-in</span></div>
<div class="line"><a id="l01781" name="l01781"></a><span class="lineno"> 1781</span><span class="comment">   * phase very rigid.  This detail could change in the future.</span></div>
<div class="line"><a id="l01782" name="l01782"></a><span class="lineno"> 1782</span><span class="comment">   *</span></div>
<div class="line"><a id="l01783" name="l01783"></a><span class="lineno"> 1783</span><span class="comment">   * @param mdt</span></div>
<div class="line"><a id="l01784" name="l01784"></a><span class="lineno"> 1784</span><span class="comment">   *        Finalized metadata out-message (message about user message; or the internal message itself if it&#39;s not</span></div>
<div class="line"><a id="l01785" name="l01785"></a><span class="lineno"> 1785</span><span class="comment">   *        &quot;about&quot; anything) to serialize and send over #Owned_channel.</span></div>
<div class="line"><a id="l01786" name="l01786"></a><span class="lineno"> 1786</span><span class="comment">   *        If internal message: `msg` shall be null, `mdt`-held ID shall be 0 and a filled-out</span></div>
<div class="line"><a id="l01787" name="l01787"></a><span class="lineno"> 1787</span><span class="comment">   *        Msg_mdt_out::internal_msg_body_root().  Otherwise the opposite of all 3 shall hold.</span></div>
<div class="line"><a id="l01788" name="l01788"></a><span class="lineno"> 1788</span><span class="comment">   * @param msg</span></div>
<div class="line"><a id="l01789" name="l01789"></a><span class="lineno"> 1789</span><span class="comment">   *        Pointer to user out-message (as from create_msg() or direct #Msg_out ction); or null</span></div>
<div class="line"><a id="l01790" name="l01790"></a><span class="lineno"> 1790</span><span class="comment">   *        is this is an internal message send.</span></div>
<div class="line"><a id="l01791" name="l01791"></a><span class="lineno"> 1791</span><span class="comment">   * @param err_code_or_ignore</span></div>
<div class="line"><a id="l01792" name="l01792"></a><span class="lineno"> 1792</span><span class="comment">   *        See send_impl() (analogous meaning, even if send_impl() is not calling send_core() in this case).</span></div>
<div class="line"><a id="l01793" name="l01793"></a><span class="lineno"> 1793</span><span class="comment">   *        Or, additionally, leave it null to ignore errors as follows:</span></div>
<div class="line"><a id="l01794" name="l01794"></a><span class="lineno"> 1794</span><span class="comment">   *        #m_channel_err_code_or_ok is not touched even on error; the idea being this is a best-effort</span></div>
<div class="line"><a id="l01795" name="l01795"></a><span class="lineno"> 1795</span><span class="comment">   *        internal message; and if it exposes error on an #m_channel out-pipe, then the next user send</span></div>
<div class="line"><a id="l01796" name="l01796"></a><span class="lineno"> 1796</span><span class="comment">   *        will just see the same error and emit it that time.  Otherwise an internal error could detect</span></div>
<div class="line"><a id="l01797" name="l01797"></a><span class="lineno"> 1797</span><span class="comment">   *        the problem -- and our caller would not emit it.  Thus it would get lost.</span></div>
<div class="line"><a id="l01798" name="l01798"></a><span class="lineno"> 1798</span><span class="comment">   * @return See send_impl() (analogous meaning, even if send_impl() is not calling send_core() in this case).</span></div>
<div class="line"><a id="l01799" name="l01799"></a><span class="lineno"> 1799</span><span class="comment">   *         As of this writing, at this stage, there is only one remaining reason this might return `false`:</span></div>
<div class="line"><a id="l01800" name="l01800"></a><span class="lineno"> 1800</span><span class="comment">   *         `Owned_channel::send*()` yielded transport::error::Code::S_SENDS_FINISHED_CANNOT_SEND.</span></div>
<div class="line"><a id="l01801" name="l01801"></a><span class="lineno"> 1801</span><span class="comment">   */</span></div>
<div class="line"><a id="l01802" name="l01802"></a><span class="lineno"> 1802</span>  <span class="keywordtype">bool</span> <a class="code hl_function" href="classipc_1_1transport_1_1struc_1_1sync__io_1_1Channel.html#a0550bcab7578fcd9aa90a4add39eb3c7">send_core</a>(<span class="keyword">const</span> <a class="code hl_class" href="classipc_1_1transport_1_1struc_1_1Msg__mdt__out.html">Msg_mdt_out</a>&amp; mdt, <span class="keyword">const</span> <a class="code hl_class" href="classipc_1_1transport_1_1struc_1_1Msg__out__impl.html">Msg_out_impl</a>* msg, <a class="code hl_typedef" href="namespaceipc.html#aa3192e586cc45d3e7c22463bf2760f89">Error_code</a>* err_code_or_ignore);</div>
<div class="line"><a id="l01803" name="l01803"></a><span class="lineno"> 1803</span><span class="comment"></span> </div>
<div class="line"><a id="l01804" name="l01804"></a><span class="lineno"> 1804</span><span class="comment">  /**</span></div>
<div class="line"><a id="l01805" name="l01805"></a><span class="lineno"> 1805</span><span class="comment">   * Essentially a much-cut-down version of send_core() that specifically sends, along all #Owned_channel pipes,</span></div>
<div class="line"><a id="l01806" name="l01806"></a><span class="lineno"> 1806</span><span class="comment">   * the `ProtocolNegotiation` message -- the first payload required along each pipe.  As of this writing invoked</span></div>
<div class="line"><a id="l01807" name="l01807"></a><span class="lineno"> 1807</span><span class="comment">   * from start_ops(), meaning before start_and_poll() or any send()/async_request().</span></div>
<div class="line"><a id="l01808" name="l01808"></a><span class="lineno"> 1808</span><span class="comment">   *</span></div>
<div class="line"><a id="l01809" name="l01809"></a><span class="lineno"> 1809</span><span class="comment">   * Post-condition: #m_proto_neg_err_code_or_ok is falsy if there was no problem sending; else the error to emit</span></div>
<div class="line"><a id="l01810" name="l01810"></a><span class="lineno"> 1810</span><span class="comment">   * from subsequent start_and_poll() or send() or async_request() (whichever is called first).</span></div>
<div class="line"><a id="l01811" name="l01811"></a><span class="lineno"> 1811</span><span class="comment">   */</span></div>
<div class="line"><a id="l01812" name="l01812"></a><span class="lineno"> 1812</span>  <span class="keywordtype">void</span> <a class="code hl_function" href="classipc_1_1transport_1_1struc_1_1sync__io_1_1Channel.html#a8fc989561ed62604dd50f942655daea0">send_proto_neg</a>();</div>
<div class="line"><a id="l01813" name="l01813"></a><span class="lineno"> 1813</span><span class="comment"></span> </div>
<div class="line"><a id="l01814" name="l01814"></a><span class="lineno"> 1814</span><span class="comment">  /**</span></div>
<div class="line"><a id="l01815" name="l01815"></a><span class="lineno"> 1815</span><span class="comment">   * send() and async_request() helper that returns `true` if and only if `msg` contains a native handle, but</span></div>
<div class="line"><a id="l01816" name="l01816"></a><span class="lineno"> 1816</span><span class="comment">   * #Owned_channel is compile-time-incapable of transporting them.  No `*this` state other than</span></div>
<div class="line"><a id="l01817" name="l01817"></a><span class="lineno"> 1817</span><span class="comment">   * logging context is accessed.</span></div>
<div class="line"><a id="l01818" name="l01818"></a><span class="lineno"> 1818</span><span class="comment">   *</span></div>
<div class="line"><a id="l01819" name="l01819"></a><span class="lineno"> 1819</span><span class="comment">   * @param msg</span></div>
<div class="line"><a id="l01820" name="l01820"></a><span class="lineno"> 1820</span><span class="comment">   *        See, e.g., send().</span></div>
<div class="line"><a id="l01821" name="l01821"></a><span class="lineno"> 1821</span><span class="comment">   * @return `true` if unsendable; else `false`.</span></div>
<div class="line"><a id="l01822" name="l01822"></a><span class="lineno"> 1822</span><span class="comment">   */</span></div>
<div class="line"><a id="l01823" name="l01823"></a><span class="lineno"> 1823</span>  <span class="keywordtype">bool</span> <a class="code hl_function" href="classipc_1_1transport_1_1struc_1_1sync__io_1_1Channel.html#ae43681c46951acd7e3c06d3cd73854f6">check_unsendable</a>(<span class="keyword">const</span> <a class="code hl_class" href="classipc_1_1transport_1_1struc_1_1Msg__out.html">Msg_out</a>&amp; msg) <span class="keyword">const</span>;</div>
<div class="line"><a id="l01824" name="l01824"></a><span class="lineno"> 1824</span> </div>
<div class="line"><a id="l01825" name="l01825"></a><span class="lineno"> 1825</span>  <span class="comment">// Data.</span></div>
<div class="line"><a id="l01826" name="l01826"></a><span class="lineno"> 1826</span><span class="comment"></span> </div>
<div class="line"><a id="l01827" name="l01827"></a><span class="lineno"> 1827</span><span class="comment">  /**</span></div>
<div class="line"><a id="l01828" name="l01828"></a><span class="lineno"> 1828</span><span class="comment">   * The builder engine config for out-messages: Small data store, such that the Struct_builder</span></div>
<div class="line"><a id="l01829" name="l01829"></a><span class="lineno"> 1829</span><span class="comment">   * `Builder_config::Builder` (really the containing class of #Builder_config) main-ctor</span></div>
<div class="line"><a id="l01830" name="l01830"></a><span class="lineno"> 1830</span><span class="comment">   * takes an object of this type, its contents being knobs controlling the behavior of the resulting Struct_builder.</span></div>
<div class="line"><a id="l01831" name="l01831"></a><span class="lineno"> 1831</span><span class="comment">   *   - The *type* #Builder_config (a template parameter) determines the logic part of the serialization policy:</span></div>
<div class="line"><a id="l01832" name="l01832"></a><span class="lineno"> 1832</span><span class="comment">   *     what is the source of RAM for segments (heap? SHM?), as the user mutates an out-message?  How big is each</span></div>
<div class="line"><a id="l01833" name="l01833"></a><span class="lineno"> 1833</span><span class="comment">   *     segment?</span></div>
<div class="line"><a id="l01834" name="l01834"></a><span class="lineno"> 1834</span><span class="comment">   *   - The *members* inside #m_struct_builder_config further tweak the application of that logic by being</span></div>
<div class="line"><a id="l01835" name="l01835"></a><span class="lineno"> 1835</span><span class="comment">   *     knobs: Should prefix/postfix space be left in the serialization?  How quickly should the segments grow?</span></div>
<div class="line"><a id="l01836" name="l01836"></a><span class="lineno"> 1836</span><span class="comment">   *     Where to log?</span></div>
<div class="line"><a id="l01837" name="l01837"></a><span class="lineno"> 1837</span><span class="comment">   *     - This `Config` is passed to `Builder` ctor to configure it.</span></div>
<div class="line"><a id="l01838" name="l01838"></a><span class="lineno"> 1838</span><span class="comment">   *</span></div>
<div class="line"><a id="l01839" name="l01839"></a><span class="lineno"> 1839</span><span class="comment">   * ### Rationale ###</span></div>
<div class="line"><a id="l01840" name="l01840"></a><span class="lineno"> 1840</span><span class="comment">   * By storing this value, copied from the one passed to ctor, we delegate the policy decision (as to what kind</span></div>
<div class="line"><a id="l01841" name="l01841"></a><span class="lineno"> 1841</span><span class="comment">   * of capnp-structured-to-binary serialization engine to use) to the `*this` config (user).  The knobs</span></div>
<div class="line"><a id="l01842" name="l01842"></a><span class="lineno"> 1842</span><span class="comment">   * controlling the configuration of that engine, each time it&#39;s created for a given out-message, depend</span></div>
<div class="line"><a id="l01843" name="l01843"></a><span class="lineno"> 1843</span><span class="comment">   * on the builder concrete type, so we don&#39;t know what they are or even their nature or number.</span></div>
<div class="line"><a id="l01844" name="l01844"></a><span class="lineno"> 1844</span><span class="comment">   * They are stored opaquely (to us) inside this item.</span></div>
<div class="line"><a id="l01845" name="l01845"></a><span class="lineno"> 1845</span><span class="comment">   *</span></div>
<div class="line"><a id="l01846" name="l01846"></a><span class="lineno"> 1846</span><span class="comment">   * This member is used in two ways.</span></div>
<div class="line"><a id="l01847" name="l01847"></a><span class="lineno"> 1847</span><span class="comment">   *   - Every out-message (whether user-created or an internal one) is accompanied by/is an internal-use</span></div>
<div class="line"><a id="l01848" name="l01848"></a><span class="lineno"> 1848</span><span class="comment">   *     *metadata* message, which is just another Msg_out albeit with an internal friendly API, Msg_mdt_out,</span></div>
<div class="line"><a id="l01849" name="l01849"></a><span class="lineno"> 1849</span><span class="comment">   *     tailored to the stuff we need to put into these.  The builder config used to create this</span></div>
<div class="line"><a id="l01850" name="l01850"></a><span class="lineno"> 1850</span><span class="comment">   *     is #m_struct_builder_config.</span></div>
<div class="line"><a id="l01851" name="l01851"></a><span class="lineno"> 1851</span><span class="comment">   *     - So the schema template param is the internal-use metadata stuff from structured_msg.capnp.</span></div>
<div class="line"><a id="l01852" name="l01852"></a><span class="lineno"> 1852</span><span class="comment">   *   - Every user out-message created via create_msg() is supplied by the latter with #m_struct_builder_config</span></div>
<div class="line"><a id="l01853" name="l01853"></a><span class="lineno"> 1853</span><span class="comment">   *     as the builder config.</span></div>
<div class="line"><a id="l01854" name="l01854"></a><span class="lineno"> 1854</span><span class="comment">   *     - So the schema template param is `&lt;Message_body&gt;`, the `Channel` template param from the user.</span></div>
<div class="line"><a id="l01855" name="l01855"></a><span class="lineno"> 1855</span><span class="comment">   *     - The user is allowed to simply direct-construct the #Msg_out without any create_msg().  They have to</span></div>
<div class="line"><a id="l01856" name="l01856"></a><span class="lineno"> 1856</span><span class="comment">   *       supply the builder config themselves again, though.  It has to be the same type as</span></div>
<div class="line"><a id="l01857" name="l01857"></a><span class="lineno"> 1857</span><span class="comment">   *       #m_struct_builder_config, or it won&#39;t compile; but in theory it could have different knob values.</span></div>
<div class="line"><a id="l01858" name="l01858"></a><span class="lineno"> 1858</span><span class="comment">   *       E.g., it could have a null `Logger`, while `*this` one logs-galore.  Usually one would want to keep</span></div>
<div class="line"><a id="l01859" name="l01859"></a><span class="lineno"> 1859</span><span class="comment">   *       it equal (but certainly need not be the same actual #Builder_config object).</span></div>
<div class="line"><a id="l01860" name="l01860"></a><span class="lineno"> 1860</span><span class="comment">   *</span></div>
<div class="line"><a id="l01861" name="l01861"></a><span class="lineno"> 1861</span><span class="comment">   * So it&#39;s an important member, but arguably its type is more important than its contents (knobs).</span></div>
<div class="line"><a id="l01862" name="l01862"></a><span class="lineno"> 1862</span><span class="comment">   */</span></div>
<div class="line"><a id="l01863" name="l01863"></a><span class="lineno"><a class="line" href="classipc_1_1transport_1_1struc_1_1sync__io_1_1Channel.html#a47816a05b0af2d8b5c26ecaf01b89b1f"> 1863</a></span>  <span class="keyword">const</span> <a class="code hl_typedef" href="classipc_1_1transport_1_1struc_1_1sync__io_1_1Channel.html#a8a59bbc3c6a7191b316b23661d8ba6e3">Builder_config</a> <a class="code hl_variable" href="classipc_1_1transport_1_1struc_1_1sync__io_1_1Channel.html#a47816a05b0af2d8b5c26ecaf01b89b1f">m_struct_builder_config</a>;</div>
<div class="line"><a id="l01864" name="l01864"></a><span class="lineno"> 1864</span><span class="comment"></span> </div>
<div class="line"><a id="l01865" name="l01865"></a><span class="lineno"> 1865</span><span class="comment">  /**</span></div>
<div class="line"><a id="l01866" name="l01866"></a><span class="lineno"> 1866</span><span class="comment">   * Value (possibly of size 0 depending on this type) to pass to Msg_out::emit_serialization()</span></div>
<div class="line"><a id="l01867" name="l01867"></a><span class="lineno"> 1867</span><span class="comment">   * to indicate the opposing side of the #Owned_channel.  If the type is Null_session (zero-sized), then</span></div>
<div class="line"><a id="l01868" name="l01868"></a><span class="lineno"> 1868</span><span class="comment">   * no information is necessary to indicate this.</span></div>
<div class="line"><a id="l01869" name="l01869"></a><span class="lineno"> 1869</span><span class="comment">   */</span></div>
<div class="line"><a id="l01870" name="l01870"></a><span class="lineno"><a class="line" href="classipc_1_1transport_1_1struc_1_1sync__io_1_1Channel.html#aa4cd0e7c721ee3af4d1faa2ada5ad646"> 1870</a></span>  <span class="keyword">const</span> <span class="keyword">typename</span> Builder_config::Builder::Session <a class="code hl_variable" href="classipc_1_1transport_1_1struc_1_1sync__io_1_1Channel.html#aa4cd0e7c721ee3af4d1faa2ada5ad646">m_struct_lender_session</a>;</div>
<div class="line"><a id="l01871" name="l01871"></a><span class="lineno"> 1871</span><span class="comment"></span> </div>
<div class="line"><a id="l01872" name="l01872"></a><span class="lineno"> 1872</span><span class="comment">  /**</span></div>
<div class="line"><a id="l01873" name="l01873"></a><span class="lineno"> 1873</span><span class="comment">   * Analogous to #m_struct_builder_config but for deserialization.</span></div>
<div class="line"><a id="l01874" name="l01874"></a><span class="lineno"> 1874</span><span class="comment">   * @see #m_struct_builder_config</span></div>
<div class="line"><a id="l01875" name="l01875"></a><span class="lineno"> 1875</span><span class="comment">   */</span></div>
<div class="line"><a id="l01876" name="l01876"></a><span class="lineno"><a class="line" href="classipc_1_1transport_1_1struc_1_1sync__io_1_1Channel.html#af7ac60b2b7a7baf26a96cf4635d4c320"> 1876</a></span>  <span class="keyword">const</span> <a class="code hl_typedef" href="classipc_1_1transport_1_1struc_1_1sync__io_1_1Channel.html#a14a7166b2f8c117ce6ddafe943d036fa">Reader_config</a> <a class="code hl_variable" href="classipc_1_1transport_1_1struc_1_1sync__io_1_1Channel.html#af7ac60b2b7a7baf26a96cf4635d4c320">m_struct_reader_config</a>;</div>
<div class="line"><a id="l01877" name="l01877"></a><span class="lineno"> 1877</span><span class="comment"></span> </div>
<div class="line"><a id="l01878" name="l01878"></a><span class="lineno"> 1878</span><span class="comment">  /**</span></div>
<div class="line"><a id="l01879" name="l01879"></a><span class="lineno"> 1879</span><span class="comment">   * Handles the protocol negotiation at the start of the pipe, as pertains to algorithms perpetuated by</span></div>
<div class="line"><a id="l01880" name="l01880"></a><span class="lineno"> 1880</span><span class="comment">   * `*this` class&#39;s code.</span></div>
<div class="line"><a id="l01881" name="l01881"></a><span class="lineno"> 1881</span><span class="comment">   *</span></div>
<div class="line"><a id="l01882" name="l01882"></a><span class="lineno"> 1882</span><span class="comment">   * @see Protocol_negotiator doc header for key background on the topic.</span></div>
<div class="line"><a id="l01883" name="l01883"></a><span class="lineno"> 1883</span><span class="comment">   */</span></div>
<div class="line"><a id="l01884" name="l01884"></a><span class="lineno"><a class="line" href="classipc_1_1transport_1_1struc_1_1sync__io_1_1Channel.html#aad25fed4c22117bf07c45240f790d306"> 1884</a></span>  <a class="code hl_class" href="classipc_1_1transport_1_1Protocol__negotiator.html">Protocol_negotiator</a> <a class="code hl_variable" href="classipc_1_1transport_1_1struc_1_1sync__io_1_1Channel.html#aad25fed4c22117bf07c45240f790d306">m_protocol_negotiator</a>;</div>
<div class="line"><a id="l01885" name="l01885"></a><span class="lineno"> 1885</span><span class="comment"></span> </div>
<div class="line"><a id="l01886" name="l01886"></a><span class="lineno"> 1886</span><span class="comment">  /**</span></div>
<div class="line"><a id="l01887" name="l01887"></a><span class="lineno"> 1887</span><span class="comment">   * Handles the protocol negotiation at the start of the pipe, as pertains to algorithms perpetuated outside</span></div>
<div class="line"><a id="l01888" name="l01888"></a><span class="lineno"> 1888</span><span class="comment">   * of `*this` class&#39;s code but instead in #Builder_config #m_struct_builder_config and</span></div>
<div class="line"><a id="l01889" name="l01889"></a><span class="lineno"> 1889</span><span class="comment">   * #Reader_config #m_struct_reader_config and related.</span></div>
<div class="line"><a id="l01890" name="l01890"></a><span class="lineno"> 1890</span><span class="comment">   *</span></div>
<div class="line"><a id="l01891" name="l01891"></a><span class="lineno"> 1891</span><span class="comment">   * @see Protocol_negotiator doc header for key background on the topic.</span></div>
<div class="line"><a id="l01892" name="l01892"></a><span class="lineno"> 1892</span><span class="comment">   */</span></div>
<div class="line"><a id="l01893" name="l01893"></a><span class="lineno"><a class="line" href="classipc_1_1transport_1_1struc_1_1sync__io_1_1Channel.html#a9d7fc428bc293e993fe96428c44bfb4c"> 1893</a></span>  <a class="code hl_class" href="classipc_1_1transport_1_1Protocol__negotiator.html">Protocol_negotiator</a> <a class="code hl_variable" href="classipc_1_1transport_1_1struc_1_1sync__io_1_1Channel.html#a9d7fc428bc293e993fe96428c44bfb4c">m_protocol_negotiator_aux</a>;</div>
<div class="line"><a id="l01894" name="l01894"></a><span class="lineno"> 1894</span><span class="comment"></span> </div>
<div class="line"><a id="l01895" name="l01895"></a><span class="lineno"> 1895</span><span class="comment">  /**</span></div>
<div class="line"><a id="l01896" name="l01896"></a><span class="lineno"> 1896</span><span class="comment">   * Error, or lack thereof, recorded by start_ops() (having returned `true`) when synchronously sending out</span></div>
<div class="line"><a id="l01897" name="l01897"></a><span class="lineno"> 1897</span><span class="comment">   * protocol-negotiation message(s).  More specifically send_proto_neg() sets it.</span></div>
<div class="line"><a id="l01898" name="l01898"></a><span class="lineno"> 1898</span><span class="comment">   * If truthy, subsequent start_and_poll(), send(), or async_request() (whichever happens first) will promote it</span></div>
<div class="line"><a id="l01899" name="l01899"></a><span class="lineno"> 1899</span><span class="comment">   * to  #m_channel_err_code_or_ok and emit it in the normal fashion.</span></div>
<div class="line"><a id="l01900" name="l01900"></a><span class="lineno"> 1900</span><span class="comment">   */</span></div>
<div class="line"><a id="l01901" name="l01901"></a><span class="lineno"><a class="line" href="classipc_1_1transport_1_1struc_1_1sync__io_1_1Channel.html#a515bbf752a9021ba8e0cec34d30f24b9"> 1901</a></span>  <a class="code hl_typedef" href="namespaceipc.html#aa3192e586cc45d3e7c22463bf2760f89">Error_code</a> <a class="code hl_variable" href="classipc_1_1transport_1_1struc_1_1sync__io_1_1Channel.html#a515bbf752a9021ba8e0cec34d30f24b9">m_proto_neg_err_code_or_ok</a>;</div>
<div class="line"><a id="l01902" name="l01902"></a><span class="lineno"> 1902</span><span class="comment"></span> </div>
<div class="line"><a id="l01903" name="l01903"></a><span class="lineno"> 1903</span><span class="comment">  /**</span></div>
<div class="line"><a id="l01904" name="l01904"></a><span class="lineno"> 1904</span><span class="comment">   * Whether start_ops() has been called yet or not.  We could&#39;ve used #m_channel built-in guards against that,</span></div>
<div class="line"><a id="l01905" name="l01905"></a><span class="lineno"> 1905</span><span class="comment">   * but then as of this writing there&#39;s no way to check that at the top of our own various APIs</span></div>
<div class="line"><a id="l01906" name="l01906"></a><span class="lineno"> 1906</span><span class="comment">   * (check_not_started_ops()).</span></div>
<div class="line"><a id="l01907" name="l01907"></a><span class="lineno"> 1907</span><span class="comment">   */</span></div>
<div class="line"><a id="l01908" name="l01908"></a><span class="lineno"><a class="line" href="classipc_1_1transport_1_1struc_1_1sync__io_1_1Channel.html#a9a63c3620852f2354fe145364a73c688"> 1908</a></span>  <span class="keywordtype">bool</span> <a class="code hl_variable" href="classipc_1_1transport_1_1struc_1_1sync__io_1_1Channel.html#a9a63c3620852f2354fe145364a73c688">m_started_ops</a>;</div>
<div class="line"><a id="l01909" name="l01909"></a><span class="lineno"> 1909</span><span class="comment"></span> </div>
<div class="line"><a id="l01910" name="l01910"></a><span class="lineno"> 1910</span><span class="comment">  /**</span></div>
<div class="line"><a id="l01911" name="l01911"></a><span class="lineno"> 1911</span><span class="comment">   * The channel-hosed error reporting handler.  See start_and_poll() + class doc header for discussion of</span></div>
<div class="line"><a id="l01912" name="l01912"></a><span class="lineno"> 1912</span><span class="comment">   * error semantics.</span></div>
<div class="line"><a id="l01913" name="l01913"></a><span class="lineno"> 1913</span><span class="comment">   */</span></div>
<div class="line"><a id="l01914" name="l01914"></a><span class="lineno"><a class="line" href="classipc_1_1transport_1_1struc_1_1sync__io_1_1Channel.html#ad1fcc872d76e6a59321f5d67b2e0a70b"> 1914</a></span>  flow::async::Task_asio_err <a class="code hl_variable" href="classipc_1_1transport_1_1struc_1_1sync__io_1_1Channel.html#ad1fcc872d76e6a59321f5d67b2e0a70b">m_on_err_func</a>;</div>
<div class="line"><a id="l01915" name="l01915"></a><span class="lineno"> 1915</span><span class="comment"></span> </div>
<div class="line"><a id="l01916" name="l01916"></a><span class="lineno"> 1916</span><span class="comment">  /**</span></div>
<div class="line"><a id="l01917" name="l01917"></a><span class="lineno"> 1917</span><span class="comment">   * 1 or 2 active (via `optional`) `struct`s containing policy and state w/r/t receipt of low-level</span></div>
<div class="line"><a id="l01918" name="l01918"></a><span class="lineno"> 1918</span><span class="comment">   * (unstructured) messages with the aim to complete the next structured in-message(s).</span></div>
<div class="line"><a id="l01919" name="l01919"></a><span class="lineno"> 1919</span><span class="comment">   *</span></div>
<div class="line"><a id="l01920" name="l01920"></a><span class="lineno"> 1920</span><span class="comment">   * @see Msg_in_pipe doc header for detailed algorithm overview.</span></div>
<div class="line"><a id="l01921" name="l01921"></a><span class="lineno"> 1921</span><span class="comment">   */</span></div>
<div class="line"><a id="l01922" name="l01922"></a><span class="lineno"><a class="line" href="classipc_1_1transport_1_1struc_1_1sync__io_1_1Channel.html#a9c04f15d4d17cd43aca70136119e1d28"> 1922</a></span>  boost::array&lt;std::optional&lt;Msg_in_pipe&gt;, 2&gt; <a class="code hl_variable" href="classipc_1_1transport_1_1struc_1_1sync__io_1_1Channel.html#a9c04f15d4d17cd43aca70136119e1d28">m_rcv_pipes</a>;</div>
<div class="line"><a id="l01923" name="l01923"></a><span class="lineno"> 1923</span><span class="comment"></span> </div>
<div class="line"><a id="l01924" name="l01924"></a><span class="lineno"> 1924</span><span class="comment">  /// See set_unexpected_response_handler().</span></div>
<div class="line"><a id="l01925" name="l01925"></a><span class="lineno"><a class="line" href="classipc_1_1transport_1_1struc_1_1sync__io_1_1Channel.html#a0986d9820ae3a1203014d94c193b4ca4"> 1925</a></span><span class="comment"></span>  <a class="code hl_typedef" href="classipc_1_1transport_1_1struc_1_1sync__io_1_1Channel.html#abb3be9330a898ce542afd778d8e42a49">On_unexpected_response_func</a> <a class="code hl_variable" href="classipc_1_1transport_1_1struc_1_1sync__io_1_1Channel.html#a0986d9820ae3a1203014d94c193b4ca4">m_on_unexpected_response_func_or_empty</a>;</div>
<div class="line"><a id="l01926" name="l01926"></a><span class="lineno"> 1926</span><span class="comment"></span> </div>
<div class="line"><a id="l01927" name="l01927"></a><span class="lineno"> 1927</span><span class="comment">  /// See set_remote_unexpected_response_handler().</span></div>
<div class="line"><a id="l01928" name="l01928"></a><span class="lineno"><a class="line" href="classipc_1_1transport_1_1struc_1_1sync__io_1_1Channel.html#a491a1a9eff4e277f3e5cd32c0178adbf"> 1928</a></span><span class="comment"></span>  <a class="code hl_typedef" href="classipc_1_1transport_1_1struc_1_1sync__io_1_1Channel.html#a86342fa9838aea7d49bbf3dd344445e2">On_remote_unexpected_response_func</a> <a class="code hl_variable" href="classipc_1_1transport_1_1struc_1_1sync__io_1_1Channel.html#a491a1a9eff4e277f3e5cd32c0178adbf">m_on_remote_unexpected_response_func_or_empty</a>;</div>
<div class="line"><a id="l01929" name="l01929"></a><span class="lineno"> 1929</span><span class="comment"></span> </div>
<div class="line"><a id="l01930" name="l01930"></a><span class="lineno"> 1930</span><span class="comment">  /**</span></div>
<div class="line"><a id="l01931" name="l01931"></a><span class="lineno"> 1931</span><span class="comment">   * Session token: in Phase::S_LOGGED_IN to send in every out-message and check-against every in-message;</span></div>
<div class="line"><a id="l01932" name="l01932"></a><span class="lineno"> 1932</span><span class="comment">   * in log-in phase *as client* equals nil; in log-in phase *as server* it is auto-generated at construction.</span></div>
<div class="line"><a id="l01933" name="l01933"></a><span class="lineno"> 1933</span><span class="comment">   * In non-log-in phase, it&#39;s either provided by user in ctor (if log-in phase skipped), or:</span></div>
<div class="line"><a id="l01934" name="l01934"></a><span class="lineno"> 1934</span><span class="comment">   *   - inherited from log-in phase (if *as server*);</span></div>
<div class="line"><a id="l01935" name="l01935"></a><span class="lineno"> 1935</span><span class="comment">   *   - deserialized from the log-in response (if *as client*).</span></div>
<div class="line"><a id="l01936" name="l01936"></a><span class="lineno"> 1936</span><span class="comment">   *</span></div>
<div class="line"><a id="l01937" name="l01937"></a><span class="lineno"> 1937</span><span class="comment">   * It&#39;s used in 2 ways:</span></div>
<div class="line"><a id="l01938" name="l01938"></a><span class="lineno"> 1938</span><span class="comment">   *   - It is sent in every (structured) message -- namely in the lead unstructured message.</span></div>
<div class="line"><a id="l01939" name="l01939"></a><span class="lineno"> 1939</span><span class="comment">   *     SO whenever an `mdt` message is created, we load #m_session_token into it at that time.</span></div>
<div class="line"><a id="l01940" name="l01940"></a><span class="lineno"> 1940</span><span class="comment">   *   - Every message is checked against it (if not correct, channel is hosed immediately).</span></div>
<div class="line"><a id="l01941" name="l01941"></a><span class="lineno"> 1941</span><span class="comment">   *     - There is exactly one exception to this: The log-in request (received in log-in phase *as server*)</span></div>
<div class="line"><a id="l01942" name="l01942"></a><span class="lineno"> 1942</span><span class="comment">   *       must have nil session token: we have not yet sent #m_session_token (which we generated at ction)</span></div>
<div class="line"><a id="l01943" name="l01943"></a><span class="lineno"> 1943</span><span class="comment">   *       to it in the response message, so the client could not have known it.</span></div>
<div class="line"><a id="l01944" name="l01944"></a><span class="lineno"> 1944</span><span class="comment">   */</span></div>
<div class="line"><a id="l01945" name="l01945"></a><span class="lineno"><a class="line" href="classipc_1_1transport_1_1struc_1_1sync__io_1_1Channel.html#a49e257338f9b20fd70c42142eb2db4f0"> 1945</a></span>  <a class="code hl_typedef" href="namespaceipc_1_1transport_1_1struc.html#a6751c05fb6582a34c7c47ac470c4a48b">Session_token</a> <a class="code hl_variable" href="classipc_1_1transport_1_1struc_1_1sync__io_1_1Channel.html#a49e257338f9b20fd70c42142eb2db4f0">m_session_token</a>;</div>
<div class="line"><a id="l01946" name="l01946"></a><span class="lineno"> 1946</span><span class="comment"></span> </div>
<div class="line"><a id="l01947" name="l01947"></a><span class="lineno"> 1947</span><span class="comment">  /// Next out-message ID (for the next send() or async_request()).</span></div>
<div class="line"><a id="l01948" name="l01948"></a><span class="lineno"><a class="line" href="classipc_1_1transport_1_1struc_1_1sync__io_1_1Channel.html#a5132d96a55a628a7830c19c630390582"> 1948</a></span><span class="comment"></span>  <a class="code hl_typedef" href="classipc_1_1transport_1_1struc_1_1Channel__base.html#adcf24fa51747ed83c4b6427fbf44fecf">msg_id_out_t</a> <a class="code hl_variable" href="classipc_1_1transport_1_1struc_1_1sync__io_1_1Channel.html#a5132d96a55a628a7830c19c630390582">m_snd_msg_next_id</a>;</div>
<div class="line"><a id="l01949" name="l01949"></a><span class="lineno"> 1949</span><span class="comment"></span> </div>
<div class="line"><a id="l01950" name="l01950"></a><span class="lineno"> 1950</span><span class="comment">  /**</span></div>
<div class="line"><a id="l01951" name="l01951"></a><span class="lineno"> 1951</span><span class="comment">   * Phase (w/r/t log-in or lack thereof) of `*this` peer.  It is either Phase::S_LOGGED_IN throughout; or</span></div>
<div class="line"><a id="l01952" name="l01952"></a><span class="lineno"> 1952</span><span class="comment">   * starts as one of the other 2 values, then is assigned LOGGED_IN and unmodified further.</span></div>
<div class="line"><a id="l01953" name="l01953"></a><span class="lineno"> 1953</span><span class="comment">   *</span></div>
<div class="line"><a id="l01954" name="l01954"></a><span class="lineno"> 1954</span><span class="comment">   * If not LOGGED_IN from the start (see ctors) then it is written exactly once:</span></div>
<div class="line"><a id="l01955" name="l01955"></a><span class="lineno"> 1955</span><span class="comment">   *   - Phase::S_SRV_LOG_IN =&gt; Phase::S_LOGGED_IN (see ctors): When send() of the log-in response is invoked.</span></div>
<div class="line"><a id="l01956" name="l01956"></a><span class="lineno"> 1956</span><span class="comment">   *   - Phase::S_CLI_LOG_IN =&gt; Phase::S_LOGGED_IN (see ctors): When response to the async_request() of the</span></div>
<div class="line"><a id="l01957" name="l01957"></a><span class="lineno"> 1957</span><span class="comment">   *     log-in request is received.</span></div>
<div class="line"><a id="l01958" name="l01958"></a><span class="lineno"> 1958</span><span class="comment">   *</span></div>
<div class="line"><a id="l01959" name="l01959"></a><span class="lineno"> 1959</span><span class="comment">   * It is generally checked at the start of all or most APIs (check_phase_and_prior_error()).</span></div>
<div class="line"><a id="l01960" name="l01960"></a><span class="lineno"> 1960</span><span class="comment">   * In particular many APIs, such as expect_msg(), no-op and return sentinel unless LOGGED_IN; ~one</span></div>
<div class="line"><a id="l01961" name="l01961"></a><span class="lineno"> 1961</span><span class="comment">   * (expect_log_in_request()) does the same unless in a proper `*_LOG_IN` phase.</span></div>
<div class="line"><a id="l01962" name="l01962"></a><span class="lineno"> 1962</span><span class="comment">   * If the user is acting sanely, they would invoke the log-in APIs before</span></div>
<div class="line"><a id="l01963" name="l01963"></a><span class="lineno"> 1963</span><span class="comment">   * entry to LOGGED_IN and vice versa for the logged-in APIs; namely:</span></div>
<div class="line"><a id="l01964" name="l01964"></a><span class="lineno"> 1964</span><span class="comment">   *   - SRV_LOG_IN -&gt; LOGGED_IN: After send() of the log-in response, which itself would be only</span></div>
<div class="line"><a id="l01965" name="l01965"></a><span class="lineno"> 1965</span><span class="comment">   *     after the handler passed to expect_log_in_request() fires.</span></div>
<div class="line"><a id="l01966" name="l01966"></a><span class="lineno"> 1966</span><span class="comment">   *   - CLI_LOG_IN -&gt; LOGGED_IN: After the handler, passed to async_request() along with log-in request out-message,</span></div>
<div class="line"><a id="l01967" name="l01967"></a><span class="lineno"> 1967</span><span class="comment">   *     fires indicating receiving the expected log-in response.</span></div>
<div class="line"><a id="l01968" name="l01968"></a><span class="lineno"> 1968</span><span class="comment">   *</span></div>
<div class="line"><a id="l01969" name="l01969"></a><span class="lineno"> 1969</span><span class="comment">   * If the user disregards these best practices and invokes a logged-in API before those points, then they&#39;re</span></div>
<div class="line"><a id="l01970" name="l01970"></a><span class="lineno"> 1970</span><span class="comment">   * engaging in a race.  Worst-case, they&#39;ll get an unexpected sentinel return of something like expect_msg() --</span></div>
<div class="line"><a id="l01971" name="l01971"></a><span class="lineno"> 1971</span><span class="comment">   * their own fault.</span></div>
<div class="line"><a id="l01972" name="l01972"></a><span class="lineno"> 1972</span><span class="comment">   */</span></div>
<div class="line"><a id="l01973" name="l01973"></a><span class="lineno"><a class="line" href="classipc_1_1transport_1_1struc_1_1sync__io_1_1Channel.html#afca9a3012b2f41d635381a5a13ddd7c1"> 1973</a></span>  <a class="code hl_enumeration" href="classipc_1_1transport_1_1struc_1_1sync__io_1_1Channel.html#a5a3833cd141802041551db21198ac319">Phase</a> <a class="code hl_variable" href="classipc_1_1transport_1_1struc_1_1sync__io_1_1Channel.html#afca9a3012b2f41d635381a5a13ddd7c1">m_phase</a>;</div>
<div class="line"><a id="l01974" name="l01974"></a><span class="lineno"> 1974</span><span class="comment"></span> </div>
<div class="line"><a id="l01975" name="l01975"></a><span class="lineno"> 1975</span><span class="comment">  /**</span></div>
<div class="line"><a id="l01976" name="l01976"></a><span class="lineno"> 1976</span><span class="comment">   * Used when #m_phase is Phase::S_SRV_LOG_IN, this starts `false` and is changed</span></div>
<div class="line"><a id="l01977" name="l01977"></a><span class="lineno"> 1977</span><span class="comment">   * to `true` at thread-U call of expect_log_in_request(); if already `true` then a 2nd (illegal)</span></div>
<div class="line"><a id="l01978" name="l01978"></a><span class="lineno"> 1978</span><span class="comment">   * expect_log_in_request() call has been made and shall be ignored (no-op, return sentinel).</span></div>
<div class="line"><a id="l01979" name="l01979"></a><span class="lineno"> 1979</span><span class="comment">   */</span></div>
<div class="line"><a id="l01980" name="l01980"></a><span class="lineno"><a class="line" href="classipc_1_1transport_1_1struc_1_1sync__io_1_1Channel.html#aa14373afb4601567d1640f7b0b3faa45"> 1980</a></span>  <span class="keywordtype">bool</span> <a class="code hl_variable" href="classipc_1_1transport_1_1struc_1_1sync__io_1_1Channel.html#aa14373afb4601567d1640f7b0b3faa45">m_phase_log_in_started</a>;</div>
<div class="line"><a id="l01981" name="l01981"></a><span class="lineno"> 1981</span><span class="comment"></span> </div>
<div class="line"><a id="l01982" name="l01982"></a><span class="lineno"> 1982</span><span class="comment">  /**</span></div>
<div class="line"><a id="l01983" name="l01983"></a><span class="lineno"> 1983</span><span class="comment">   * Starts falsy; becomes forever truthy (with a specific #Error_code that will not change thereafter)</span></div>
<div class="line"><a id="l01984" name="l01984"></a><span class="lineno"> 1984</span><span class="comment">   * when one of the following detects the first channel-hosing condition: send() or async_request(), on-receive</span></div>
<div class="line"><a id="l01985" name="l01985"></a><span class="lineno"> 1985</span><span class="comment">   * handler rcv_on_async_read_lead_msg() or rcv_on_async_read_continuation_msg().  Once that becomes the case:</span></div>
<div class="line"><a id="l01986" name="l01986"></a><span class="lineno"> 1986</span><span class="comment">   *   - Any *subsequent* on-receive handler (possibly none but at most one per ongoing async-read chain, of which</span></div>
<div class="line"><a id="l01987" name="l01987"></a><span class="lineno"> 1987</span><span class="comment">   *     there are 1-2) will immediately no-op and end async chain.</span></div>
<div class="line"><a id="l01988" name="l01988"></a><span class="lineno"> 1988</span><span class="comment">   *   - Any *subsequent* send() or async_request() will immediately no-op and return `false`.</span></div>
<div class="line"><a id="l01989" name="l01989"></a><span class="lineno"> 1989</span><span class="comment">   *   - Any subsequent other mutable-state-touching API -- e.g., session_token(), expect_msg() -- will immediately</span></div>
<div class="line"><a id="l01990" name="l01990"></a><span class="lineno"> 1990</span><span class="comment">   *     no-op and return `false`/null/sentinel value.  Exception: async_end_sending() (see below).</span></div>
<div class="line"><a id="l01991" name="l01991"></a><span class="lineno"> 1991</span><span class="comment">   *     create_msg() is a convenience thing that does not touch mutable state, so it won&#39;t care either.</span></div>
<div class="line"><a id="l01992" name="l01992"></a><span class="lineno"> 1992</span><span class="comment">   *</span></div>
<div class="line"><a id="l01993" name="l01993"></a><span class="lineno"> 1993</span><span class="comment">   * @note async_end_sending() is orthogonal to this.  It is a Channel-level call that (per its doc header) simply</span></div>
<div class="line"><a id="l01994" name="l01994"></a><span class="lineno"> 1994</span><span class="comment">   *       forwards to Channel::async_end_sending(), no questions asked.  The `F()` passed to async_end_sending()</span></div>
<div class="line"><a id="l01995" name="l01995"></a><span class="lineno"> 1995</span><span class="comment">   *       may well trigger synchronous emission of `E`, with `E == m_channel_err_code_or_ok`; or not; but nothing</span></div>
<div class="line"><a id="l01996" name="l01996"></a><span class="lineno"> 1996</span><span class="comment">   *       should or does count on this.</span></div>
<div class="line"><a id="l01997" name="l01997"></a><span class="lineno"> 1997</span><span class="comment">   */</span></div>
<div class="line"><a id="l01998" name="l01998"></a><span class="lineno"><a class="line" href="classipc_1_1transport_1_1struc_1_1sync__io_1_1Channel.html#a95cfe30e685e828d62318c9b2bc4b137"> 1998</a></span>  <a class="code hl_typedef" href="namespaceipc.html#aa3192e586cc45d3e7c22463bf2760f89">Error_code</a> <a class="code hl_variable" href="classipc_1_1transport_1_1struc_1_1sync__io_1_1Channel.html#a95cfe30e685e828d62318c9b2bc4b137">m_channel_err_code_or_ok</a>;</div>
<div class="line"><a id="l01999" name="l01999"></a><span class="lineno"> 1999</span><span class="comment"></span> </div>
<div class="line"><a id="l02000" name="l02000"></a><span class="lineno"> 2000</span><span class="comment">  /// Map storing current policy for expecting responses.  See #Expecting_response_map doc header for details.</span></div>
<div class="line"><a id="l02001" name="l02001"></a><span class="lineno"><a class="line" href="classipc_1_1transport_1_1struc_1_1sync__io_1_1Channel.html#abf9a2118d887439717e17d0515be3e43"> 2001</a></span><span class="comment"></span>  <a class="code hl_typedef" href="classipc_1_1transport_1_1struc_1_1sync__io_1_1Channel.html#a3d4c8da3dd620d113479f5c6a3f96c3a">Expecting_response_map</a> <a class="code hl_variable" href="classipc_1_1transport_1_1struc_1_1sync__io_1_1Channel.html#abf9a2118d887439717e17d0515be3e43">m_rcv_expecting_response_map</a>;</div>
<div class="line"><a id="l02002" name="l02002"></a><span class="lineno"> 2002</span><span class="comment"></span> </div>
<div class="line"><a id="l02003" name="l02003"></a><span class="lineno"> 2003</span><span class="comment">  /**</span></div>
<div class="line"><a id="l02004" name="l02004"></a><span class="lineno"> 2004</span><span class="comment">   * Map storing current policy for expecting non-response messages.  See #Expecting_msg_map and #Expecting_msg</span></div>
<div class="line"><a id="l02005" name="l02005"></a><span class="lineno"> 2005</span><span class="comment">   * doc headers for details.</span></div>
<div class="line"><a id="l02006" name="l02006"></a><span class="lineno"> 2006</span><span class="comment">   */</span></div>
<div class="line"><a id="l02007" name="l02007"></a><span class="lineno"><a class="line" href="classipc_1_1transport_1_1struc_1_1sync__io_1_1Channel.html#a072fb8667ba55ff69230fd48d400ee88"> 2007</a></span>  <a class="code hl_typedef" href="classipc_1_1transport_1_1struc_1_1sync__io_1_1Channel.html#a8d1ffe78546eb31fd41df6784a26868c">Expecting_msg_map</a> <a class="code hl_variable" href="classipc_1_1transport_1_1struc_1_1sync__io_1_1Channel.html#a072fb8667ba55ff69230fd48d400ee88">m_rcv_expecting_msg_map</a>;</div>
<div class="line"><a id="l02008" name="l02008"></a><span class="lineno"> 2008</span><span class="comment"></span> </div>
<div class="line"><a id="l02009" name="l02009"></a><span class="lineno"> 2009</span><span class="comment">  /**</span></div>
<div class="line"><a id="l02010" name="l02010"></a><span class="lineno"> 2010</span><span class="comment">   * Next expected in-message ID (sequence #), incremented from initial value 1 to 2, 3, ... on in-order message</span></div>
<div class="line"><a id="l02011" name="l02011"></a><span class="lineno"> 2011</span><span class="comment">   * receipt.  It is used purely for sanity checking of the opposing sender&#39;s payloads, when #Owned_channel stores</span></div>
<div class="line"><a id="l02012" name="l02012"></a><span class="lineno"> 2012</span><span class="comment">   * only 1 pipe (Channel::S_HAS_2_PIPES is `false`).  Or: it is used with</span></div>
<div class="line"><a id="l02013" name="l02013"></a><span class="lineno"> 2013</span><span class="comment">   * #m_rcv_reassembly_q if #Owned_channel stores 2 pipes (Channel::S_HAS_2_PIPES is `true`).</span></div>
<div class="line"><a id="l02014" name="l02014"></a><span class="lineno"> 2014</span><span class="comment">   *</span></div>
<div class="line"><a id="l02015" name="l02015"></a><span class="lineno"> 2015</span><span class="comment">   * ### Algorithm summary: 2 in-pipes ###</span></div>
<div class="line"><a id="l02016" name="l02016"></a><span class="lineno"> 2016</span><span class="comment">   * In that latter case a handle-less in-message may arrive along the blobs in-pipe;</span></div>
<div class="line"><a id="l02017" name="l02017"></a><span class="lineno"> 2017</span><span class="comment">   * while a handle-paired message may arrive along the handles in-pipe; and since the two might race, the one</span></div>
<div class="line"><a id="l02018" name="l02018"></a><span class="lineno"> 2018</span><span class="comment">   * sent 1st might arrive 2nd, and vice versa.  Then the out-of-order one would be stored temporarily in</span></div>
<div class="line"><a id="l02019" name="l02019"></a><span class="lineno"> 2019</span><span class="comment">   * #m_rcv_reassembly_q.  (In theory this could occur for several in-messages.)  This is detected by noting that</span></div>
<div class="line"><a id="l02020" name="l02020"></a><span class="lineno"> 2020</span><span class="comment">   * an in-message&#39;s message ID (sequence number) exceeds #m_rcv_msg_next_id.  If it equals it, then it is in-order</span></div>
<div class="line"><a id="l02021" name="l02021"></a><span class="lineno"> 2021</span><span class="comment">   * and skips #m_rcv_reassembly_q.  If it is lower, then that is misbehavior by the opposing peer and hoses</span></div>
<div class="line"><a id="l02022" name="l02022"></a><span class="lineno"> 2022</span><span class="comment">   * the pipe.</span></div>
<div class="line"><a id="l02023" name="l02023"></a><span class="lineno"> 2023</span><span class="comment">   *</span></div>
<div class="line"><a id="l02024" name="l02024"></a><span class="lineno"> 2024</span><span class="comment">   * Technically we could be more stringent in our sanity checking: while races may occur between the 2 in-pipes,</span></div>
<div class="line"><a id="l02025" name="l02025"></a><span class="lineno"> 2025</span><span class="comment">   * for a *given* 1 of 2 pipes (the blobs pipe; the handles pipe), the message IDs must always be increasing,</span></div>
<div class="line"><a id="l02026" name="l02026"></a><span class="lineno"> 2026</span><span class="comment">   * as these are reliable, in-order pipes.  However we choose to not worry about this enforcement; in-order</span></div>
<div class="line"><a id="l02027" name="l02027"></a><span class="lineno"> 2027</span><span class="comment">   * behavior of our various transports shall (possibly) be checked elsewhere and is a hard assumption.  On</span></div>
<div class="line"><a id="l02028" name="l02028"></a><span class="lineno"> 2028</span><span class="comment">   * the other hand it is cheap to check for non-repeating (always increasing) message IDs along the totality of</span></div>
<div class="line"><a id="l02029" name="l02029"></a><span class="lineno"> 2029</span><span class="comment">   * the pipes, so we do.</span></div>
<div class="line"><a id="l02030" name="l02030"></a><span class="lineno"> 2030</span><span class="comment">   *</span></div>
<div class="line"><a id="l02031" name="l02031"></a><span class="lineno"> 2031</span><span class="comment">   * ### Algorithm summary: 1 in-pipe ###</span></div>
<div class="line"><a id="l02032" name="l02032"></a><span class="lineno"> 2032</span><span class="comment">   * Each message received must contain ID, in fact, equal #m_rcv_msg_next_id which is then incremented.  There is no</span></div>
<div class="line"><a id="l02033" name="l02033"></a><span class="lineno"> 2033</span><span class="comment">   * reassembly, as there is only 1 in-pipe, and it must be in-order.  This is (as noted just above) easy to</span></div>
<div class="line"><a id="l02034" name="l02034"></a><span class="lineno"> 2034</span><span class="comment">   * sanity-check.</span></div>
<div class="line"><a id="l02035" name="l02035"></a><span class="lineno"> 2035</span><span class="comment">   */</span></div>
<div class="line"><a id="l02036" name="l02036"></a><span class="lineno"><a class="line" href="classipc_1_1transport_1_1struc_1_1sync__io_1_1Channel.html#a26d39d4e1e2c304ef803b3721bde86f0"> 2036</a></span>  <a class="code hl_typedef" href="classipc_1_1transport_1_1struc_1_1sync__io_1_1Channel.html#ad77261f31055f4151c70225c3fa1da2e">msg_id_in_t</a> <a class="code hl_variable" href="classipc_1_1transport_1_1struc_1_1sync__io_1_1Channel.html#a26d39d4e1e2c304ef803b3721bde86f0">m_rcv_msg_next_id</a>;</div>
<div class="line"><a id="l02037" name="l02037"></a><span class="lineno"> 2037</span><span class="comment"></span> </div>
<div class="line"><a id="l02038" name="l02038"></a><span class="lineno"> 2038</span><span class="comment">  /**</span></div>
<div class="line"><a id="l02039" name="l02039"></a><span class="lineno"> 2039</span><span class="comment">   * When `Owned_channel::S_HAS_2_PIPES`, stores the reassembly queue of in-messages to feed into</span></div>
<div class="line"><a id="l02040" name="l02040"></a><span class="lineno"> 2040</span><span class="comment">   * #m_rcv_pending_msgs once in-messages filling the #msg_id_in_t (sequence #) gap between</span></div>
<div class="line"><a id="l02041" name="l02041"></a><span class="lineno"> 2041</span><span class="comment">   * #m_rcv_msg_next_id and `m_rcv_reassembly_q.front()` is filled.  Once that occurs, the maximally long</span></div>
<div class="line"><a id="l02042" name="l02042"></a><span class="lineno"> 2042</span><span class="comment">   * sequence of in-messages at the front of this queue are moved into #m_rcv_pending_msgs (or fed to waiting</span></div>
<div class="line"><a id="l02043" name="l02043"></a><span class="lineno"> 2043</span><span class="comment">   * handlers immediately if possible).  Left uninitialized if `!S_HAS_2_PIPES`.</span></div>
<div class="line"><a id="l02044" name="l02044"></a><span class="lineno"> 2044</span><span class="comment">   *</span></div>
<div class="line"><a id="l02045" name="l02045"></a><span class="lineno"> 2045</span><span class="comment">   * @see #m_rcv_msg_next_id for algorithm summary; #Reassembly_q doc header for data structure details.</span></div>
<div class="line"><a id="l02046" name="l02046"></a><span class="lineno"> 2046</span><span class="comment">   */</span></div>
<div class="line"><a id="l02047" name="l02047"></a><span class="lineno"><a class="line" href="classipc_1_1transport_1_1struc_1_1sync__io_1_1Channel.html#a1218e59c91d08758cd997d77913abd5a"> 2047</a></span>  std::optional&lt;Reassembly_q&gt; <a class="code hl_variable" href="classipc_1_1transport_1_1struc_1_1sync__io_1_1Channel.html#a1218e59c91d08758cd997d77913abd5a">m_rcv_reassembly_q</a>;</div>
<div class="line"><a id="l02048" name="l02048"></a><span class="lineno"> 2048</span><span class="comment"></span> </div>
<div class="line"><a id="l02049" name="l02049"></a><span class="lineno"> 2049</span><span class="comment">  /**</span></div>
<div class="line"><a id="l02050" name="l02050"></a><span class="lineno"> 2050</span><span class="comment">   * Queues of in-messages, keyed by #Msg_which_in, each in #msg_id_in_t (sequence #) order, for which no</span></div>
<div class="line"><a id="l02051" name="l02051"></a><span class="lineno"> 2051</span><span class="comment">   * #Msg_which_in handler has yet been registered by the user (expect_msg(), expect_msgs(), expect_log_in_request()).</span></div>
<div class="line"><a id="l02052" name="l02052"></a><span class="lineno"> 2052</span><span class="comment">   * They&#39;ll stay there until such a thing is indeed registered; once it is, that queue&#39;s elements are fed, in order,</span></div>
<div class="line"><a id="l02053" name="l02053"></a><span class="lineno"> 2053</span><span class="comment">   * to that handler, and the element is removed from #m_rcv_pending_msgs.</span></div>
<div class="line"><a id="l02054" name="l02054"></a><span class="lineno"> 2054</span><span class="comment">   *</span></div>
<div class="line"><a id="l02055" name="l02055"></a><span class="lineno"> 2055</span><span class="comment">   * ### Corner case: a response arrives to an originating out-message for which no response is expected ###</span></div>
<div class="line"><a id="l02056" name="l02056"></a><span class="lineno"> 2056</span><span class="comment">   * It is relatively normal, if ideally avoided (informally speaking), that there is no #Msg_which_in</span></div>
<div class="line"><a id="l02057" name="l02057"></a><span class="lineno"> 2057</span><span class="comment">   * listener yet registered for a given in-message.  (One can be registered later: then such messages will be</span></div>
<div class="line"><a id="l02058" name="l02058"></a><span class="lineno"> 2058</span><span class="comment">   * flushed to that handler.)  By contrast: It is a *user protocol* error that a response</span></div>
<div class="line"><a id="l02059" name="l02059"></a><span class="lineno"> 2059</span><span class="comment">   * arrives unexpectedly.  Let&#39;s break down the realistic possibilities for how that might happen:</span></div>
<div class="line"><a id="l02060" name="l02060"></a><span class="lineno"> 2060</span><span class="comment">   *   - A response arrives to message M, but the local user never issued a request for that message as</span></div>
<div class="line"><a id="l02061" name="l02061"></a><span class="lineno"> 2061</span><span class="comment">   *     triggered by async_request().  The opposing user must have erroneously issued a response to</span></div>
<div class="line"><a id="l02062" name="l02062"></a><span class="lineno"> 2062</span><span class="comment">   *     a non-request.</span></div>
<div class="line"><a id="l02063" name="l02063"></a><span class="lineno"> 2063</span><span class="comment">   *   - A response arrives to message M, and the local user *did* issue an async_request() for that message;</span></div>
<div class="line"><a id="l02064" name="l02064"></a><span class="lineno"> 2064</span><span class="comment">   *     but either it was a one-off request -- and this is the 2nd/3rd/...</span></div>
<div class="line"><a id="l02065" name="l02065"></a><span class="lineno"> 2065</span><span class="comment">   *     response -- or it was an open-ended request, but the local user called undo_expect_responses() for it since.</span></div>
<div class="line"><a id="l02066" name="l02066"></a><span class="lineno"> 2066</span><span class="comment">   *     Typically this is a miscommunication at the user level: e.g., opposing user indicated a previous</span></div>
<div class="line"><a id="l02067" name="l02067"></a><span class="lineno"> 2067</span><span class="comment">   *     response was the last one but then erroneously sent another response anyway.  Or, more simply,</span></div>
<div class="line"><a id="l02068" name="l02068"></a><span class="lineno"> 2068</span><span class="comment">   *     it sent 2+ responses to a one-off request (again erroneously).</span></div>
<div class="line"><a id="l02069" name="l02069"></a><span class="lineno"> 2069</span><span class="comment">   *</span></div>
<div class="line"><a id="l02070" name="l02070"></a><span class="lineno"> 2070</span><span class="comment">   * Both situations involve non-trivial user-level protocol mistakes.  What to do?</span></div>
<div class="line"><a id="l02071" name="l02071"></a><span class="lineno"> 2071</span><span class="comment">   *   - We could hose the whole channel: fire all handlers with some fatal #Error_code and disallow further work.</span></div>
<div class="line"><a id="l02072" name="l02072"></a><span class="lineno"> 2072</span><span class="comment">   *     This feels too draconian and inflexible at such a high layer.</span></div>
<div class="line"><a id="l02073" name="l02073"></a><span class="lineno"> 2073</span><span class="comment">   *   - Or we could inform the user of the problem.</span></div>
<div class="line"><a id="l02074" name="l02074"></a><span class="lineno"> 2074</span><span class="comment">   *</span></div>
<div class="line"><a id="l02075" name="l02075"></a><span class="lineno"> 2075</span><span class="comment">   * We choose the latter.  In particular:</span></div>
<div class="line"><a id="l02076" name="l02076"></a><span class="lineno"> 2076</span><span class="comment">   *   - We fire the user-protocol-error handler (see start_and_poll()) locally.  We feed them the problem</span></div>
<div class="line"><a id="l02077" name="l02077"></a><span class="lineno"> 2077</span><span class="comment">   *     in-message and then forget that message: they can do with it as they wish.</span></div>
<div class="line"><a id="l02078" name="l02078"></a><span class="lineno"> 2078</span><span class="comment">   *   - We send an internal message to the opposing peer indicating the issue including the triggering</span></div>
<div class="line"><a id="l02079" name="l02079"></a><span class="lineno"> 2079</span><span class="comment">   *     in-message ID (to them, out-message ID).  The opposing peer `Channel` shall fire their own</span></div>
<div class="line"><a id="l02080" name="l02080"></a><span class="lineno"> 2080</span><span class="comment">   *     user-protocol-error handler similarly.</span></div>
<div class="line"><a id="l02081" name="l02081"></a><span class="lineno"> 2081</span><span class="comment">   *</span></div>
<div class="line"><a id="l02082" name="l02082"></a><span class="lineno"> 2082</span><span class="comment">   * Other than that the channel continues operating.  The user can choose to close it, or ignore the problem,</span></div>
<div class="line"><a id="l02083" name="l02083"></a><span class="lineno"> 2083</span><span class="comment">   * or alert, or whatever.</span></div>
<div class="line"><a id="l02084" name="l02084"></a><span class="lineno"> 2084</span><span class="comment">   *</span></div>
<div class="line"><a id="l02085" name="l02085"></a><span class="lineno"> 2085</span><span class="comment">   * To wit:</span></div>
<div class="line"><a id="l02086" name="l02086"></a><span class="lineno"> 2086</span><span class="comment">   * @see set_unexpected_response_handler().</span></div>
<div class="line"><a id="l02087" name="l02087"></a><span class="lineno"> 2087</span><span class="comment">   * @see set_remote_unexpected_response_handler().</span></div>
<div class="line"><a id="l02088" name="l02088"></a><span class="lineno"> 2088</span><span class="comment">   */</span></div>
<div class="line"><a id="l02089" name="l02089"></a><span class="lineno"><a class="line" href="classipc_1_1transport_1_1struc_1_1sync__io_1_1Channel.html#ae9f5a798718d98523342acf55400d628"> 2089</a></span>  boost::unordered_map&lt;Msg_which_in, Msg_in_q&gt; <a class="code hl_variable" href="classipc_1_1transport_1_1struc_1_1sync__io_1_1Channel.html#ae9f5a798718d98523342acf55400d628">m_rcv_pending_msgs</a>;</div>
<div class="line"><a id="l02090" name="l02090"></a><span class="lineno"> 2090</span> </div>
<div class="line"><a id="l02091" name="l02091"></a><span class="lineno"> 2091</span>  <span class="comment">// (End of m_rcv_* section.)</span></div>
<div class="line"><a id="l02092" name="l02092"></a><span class="lineno"> 2092</span><span class="comment"></span> </div>
<div class="line"><a id="l02093" name="l02093"></a><span class="lineno"> 2093</span><span class="comment">  /**</span></div>
<div class="line"><a id="l02094" name="l02094"></a><span class="lineno"> 2094</span><span class="comment">   * The Channel taken-over in ctor, lifetime until dtor.</span></div>
<div class="line"><a id="l02095" name="l02095"></a><span class="lineno"> 2095</span><span class="comment">   *</span></div>
<div class="line"><a id="l02096" name="l02096"></a><span class="lineno"> 2096</span><span class="comment">   * @see also #m_channel_err_code_or_ok.</span></div>
<div class="line"><a id="l02097" name="l02097"></a><span class="lineno"> 2097</span><span class="comment">   */</span></div>
<div class="line"><a id="l02098" name="l02098"></a><span class="lineno"><a class="line" href="classipc_1_1transport_1_1struc_1_1sync__io_1_1Channel.html#abe17c6f98af890eaf522c97eb21e2e35"> 2098</a></span>  <a class="code hl_typedef" href="classipc_1_1transport_1_1struc_1_1sync__io_1_1Channel.html#a4abac89dbd4d26c79b7915990f751a76">Owned_channel</a> <a class="code hl_variable" href="classipc_1_1transport_1_1struc_1_1sync__io_1_1Channel.html#abe17c6f98af890eaf522c97eb21e2e35">m_channel</a>;</div>
<div class="line"><a id="l02099" name="l02099"></a><span class="lineno"> 2099</span><span class="comment"></span> </div>
<div class="line"><a id="l02100" name="l02100"></a><span class="lineno"> 2100</span><span class="comment">  /**</span></div>
<div class="line"><a id="l02101" name="l02101"></a><span class="lineno"> 2101</span><span class="comment">   * The handlers as pushed by handlers_post() to be flushed via handlers_poll() (internally by `*this`).</span></div>
<div class="line"><a id="l02102" name="l02102"></a><span class="lineno"> 2102</span><span class="comment">   *</span></div>
<div class="line"><a id="l02103" name="l02103"></a><span class="lineno"> 2103</span><span class="comment">   * handlers_poll() is only called internally as opposed to from a user API: there is no method the user</span></div>
<div class="line"><a id="l02104" name="l02104"></a><span class="lineno"> 2104</span><span class="comment">   * can invoke that is immediately servable; except:</span></div>
<div class="line"><a id="l02105" name="l02105"></a><span class="lineno"> 2105</span><span class="comment">   *   - `expect_*()` (all going through expect_msg_impl()): But they emit immediate results avoiding the</span></div>
<div class="line"><a id="l02106" name="l02106"></a><span class="lineno"> 2106</span><span class="comment">   *     handler function.</span></div>
<div class="line"><a id="l02107" name="l02107"></a><span class="lineno"> 2107</span><span class="comment">   *   - async_sync_end_sending(): Same.</span></div>
<div class="line"><a id="l02108" name="l02108"></a><span class="lineno"> 2108</span><span class="comment">   *</span></div>
<div class="line"><a id="l02109" name="l02109"></a><span class="lineno"> 2109</span><span class="comment">   * Unlike the core-layer guys, which always deal with at most 1 in-message at a given time, we have a situation</span></div>
<div class="line"><a id="l02110" name="l02110"></a><span class="lineno"> 2110</span><span class="comment">   * where there can be more than 1 handler pending at a time; so this is a list as opposed to just 1 item.</span></div>
<div class="line"><a id="l02111" name="l02111"></a><span class="lineno"> 2111</span><span class="comment">   * That said, there is indeed only 1 at a time if Channel::S_HAS_2_PIPES is `false`; but 1+ may be saved, and</span></div>
<div class="line"><a id="l02112" name="l02112"></a><span class="lineno"> 2112</span><span class="comment">   * fired in handlers_poll() soon, if HAS_2_PIPES is `true`.  At the risk of verbosity to try to help understanding</span></div>
<div class="line"><a id="l02113" name="l02113"></a><span class="lineno"> 2113</span><span class="comment">   * let&#39;s examine each case.</span></div>
<div class="line"><a id="l02114" name="l02114"></a><span class="lineno"> 2114</span><span class="comment">   *</span></div>
<div class="line"><a id="l02115" name="l02115"></a><span class="lineno"> 2115</span><span class="comment">   * ### `HAS_2_PIPES = false`: How do we keep it to 1 handler (or 0) at a time? ###</span></div>
<div class="line"><a id="l02116" name="l02116"></a><span class="lineno"> 2116</span><span class="comment">   * Well, why do handlers fire?  Answer:</span></div>
<div class="line"><a id="l02117" name="l02117"></a><span class="lineno"> 2117</span><span class="comment">   *   - If a user is expecting an in-message (a notification via `expect_*()` or a response via async_request()),</span></div>
<div class="line"><a id="l02118" name="l02118"></a><span class="lineno"> 2118</span><span class="comment">   *     and that message arrives, then a saved handler shall fire.</span></div>
<div class="line"><a id="l02119" name="l02119"></a><span class="lineno"> 2119</span><span class="comment">   *   - If a user is not expecting a response, but one arrives, then a special handler shall fire if set.</span></div>
<div class="line"><a id="l02120" name="l02120"></a><span class="lineno"> 2120</span><span class="comment">   *   - If the *opposing* user is not expecting a response, but one arrives, then they send an internal</span></div>
<div class="line"><a id="l02121" name="l02121"></a><span class="lineno"> 2121</span><span class="comment">   *     message which arrives to *us*, and then a special handler *here* shall fire if set.</span></div>
<div class="line"><a id="l02122" name="l02122"></a><span class="lineno"> 2122</span><span class="comment">   *   - If something bad is reported to an `async_receive_*()` handler via `Error_code`, then the channel is</span></div>
<div class="line"><a id="l02123" name="l02123"></a><span class="lineno"> 2123</span><span class="comment">   *     hosed, and #m_on_err_func shall fire.</span></div>
<div class="line"><a id="l02124" name="l02124"></a><span class="lineno"> 2124</span><span class="comment">   *</span></div>
<div class="line"><a id="l02125" name="l02125"></a><span class="lineno"> 2125</span><span class="comment">   * Now, as noted, any cached in-messages to `expect_*()` are not a part of this equation (they are reported</span></div>
<div class="line"><a id="l02126" name="l02126"></a><span class="lineno"> 2126</span><span class="comment">   * differently); nor is the special case of the #m_channel async_end_sending() stuff which is</span></div>
<div class="line"><a id="l02127" name="l02127"></a><span class="lineno"> 2127</span><span class="comment">   * at a lower level and handled separately.  So the above 4 bullet points are the only relevant things.</span></div>
<div class="line"><a id="l02128" name="l02128"></a><span class="lineno"> 2128</span><span class="comment">   *</span></div>
<div class="line"><a id="l02129" name="l02129"></a><span class="lineno"> 2129</span><span class="comment">   * Naturally, then, a handler can fire only as a reaction to an `m_channel.async_receive_*()` receiving an</span></div>
<div class="line"><a id="l02130" name="l02130"></a><span class="lineno"> 2130</span><span class="comment">   * unstructured msg which then completes a structured message (either by itself or by combining with a preceding one).</span></div>
<div class="line"><a id="l02131" name="l02131"></a><span class="lineno"> 2131</span><span class="comment">   * So we choose to fire (synchronously call) any such handler immediately upon processing an unstructured message&#39;s</span></div>
<div class="line"><a id="l02132" name="l02132"></a><span class="lineno"> 2132</span><span class="comment">   * contents.  You can see this in rcv_async_read_lead_or_continuation_msg().  So we handlers_post() while</span></div>
<div class="line"><a id="l02133" name="l02133"></a><span class="lineno"> 2133</span><span class="comment">   * processing it... then handlers_poll() right after finishing doing so.</span></div>
<div class="line"><a id="l02134" name="l02134"></a><span class="lineno"> 2134</span><span class="comment">   *</span></div>
<div class="line"><a id="l02135" name="l02135"></a><span class="lineno"> 2135</span><span class="comment">   * That leaves the possibility of said processing `handlers_post()`ing 2+ handlers.  However, no, that is</span></div>
<div class="line"><a id="l02136" name="l02136"></a><span class="lineno"> 2136</span><span class="comment">   * not possible as of this writing:</span></div>
<div class="line"><a id="l02137" name="l02137"></a><span class="lineno"> 2137</span><span class="comment">   *   - If an in-message is a response (it either is or isn&#39;t: it is a metadata header), then either</span></div>
<div class="line"><a id="l02138" name="l02138"></a><span class="lineno"> 2138</span><span class="comment">   *     - it is a response to a message earlier marked as awaiting response; or</span></div>
<div class="line"><a id="l02139" name="l02139"></a><span class="lineno"> 2139</span><span class="comment">   *     - it is not -- and it is invalid and is reported (if so configured) via unexpected-response handler.</span></div>
<div class="line"><a id="l02140" name="l02140"></a><span class="lineno"> 2140</span><span class="comment">   *   - If it is not a response, then either</span></div>
<div class="line"><a id="l02141" name="l02141"></a><span class="lineno"> 2141</span><span class="comment">   *     - it is expected via earlier expect_msg_impl() (fire handler); or</span></div>
<div class="line"><a id="l02142" name="l02142"></a><span class="lineno"> 2142</span><span class="comment">   *     - it is not expected (cache it for later non-handler-emission, possibly, via expect_msg_impl()).</span></div>
<div class="line"><a id="l02143" name="l02143"></a><span class="lineno"> 2143</span><span class="comment">   *   - Otherwise it is malformed somehow (internal protocol error a/k/a bug here or in opposing guy).</span></div>
<div class="line"><a id="l02144" name="l02144"></a><span class="lineno"> 2144</span><span class="comment">   *</span></div>
<div class="line"><a id="l02145" name="l02145"></a><span class="lineno"> 2145</span><span class="comment">   * Therefore you can see the fate of a given message is to go down one of these paths, each of which ends</span></div>
<div class="line"><a id="l02146" name="l02146"></a><span class="lineno"> 2146</span><span class="comment">   * either with no handler being posted; or one being posted.</span></div>
<div class="line"><a id="l02147" name="l02147"></a><span class="lineno"> 2147</span><span class="comment">   *</span></div>
<div class="line"><a id="l02148" name="l02148"></a><span class="lineno"> 2148</span><span class="comment">   * Then we handlers_poll() it before trying to read the next unstructured message (or stopping forever).</span></div>
<div class="line"><a id="l02149" name="l02149"></a><span class="lineno"> 2149</span><span class="comment">   *</span></div>
<div class="line"><a id="l02150" name="l02150"></a><span class="lineno"> 2150</span><span class="comment">   * ### `HAS_2_PIPES = true`: Why there can be 1+ handlers at a time ###</span></div>
<div class="line"><a id="l02151" name="l02151"></a><span class="lineno"> 2151</span><span class="comment">   * The key difference is just after the structured message has been fully deserialized but before it is then</span></div>
<div class="line"><a id="l02152" name="l02152"></a><span class="lineno"> 2152</span><span class="comment">   * given to the layer where its structured contents are either cached or emitted to the user.  Namely, we check</span></div>
<div class="line"><a id="l02153" name="l02153"></a><span class="lineno"> 2153</span><span class="comment">   * its ID against the next expected ID (sequence number).  If there is only 1 pipe, it must always have the</span></div>
<div class="line"><a id="l02154" name="l02154"></a><span class="lineno"> 2154</span><span class="comment">   * next expected ID.  However if there are 2, as is the case here, then the seq # may exceed the expected ID</span></div>
<div class="line"><a id="l02155" name="l02155"></a><span class="lineno"> 2155</span><span class="comment">   * causing message to be stored in #m_rcv_reassembly_q.  No problem so far....</span></div>
<div class="line"><a id="l02156" name="l02156"></a><span class="lineno"> 2156</span><span class="comment">   *</span></div>
<div class="line"><a id="l02157" name="l02157"></a><span class="lineno"> 2157</span><span class="comment">   * Now say an in-message arrives that closes the gap between the next expected seq # and the lowest seq #</span></div>
<div class="line"><a id="l02158" name="l02158"></a><span class="lineno"> 2158</span><span class="comment">   * in #m_rcv_reassembly_q.  Now potentially the entire #m_rcv_reassembly_q must be emitted to the user!</span></div>
<div class="line"><a id="l02159" name="l02159"></a><span class="lineno"> 2159</span><span class="comment">   * E.g., if we receive 1, 2, 4, 5, 6, 7, 3, then after 3 we must emit 4-5-6-7 as well.  So in total upon</span></div>
<div class="line"><a id="l02160" name="l02160"></a><span class="lineno"> 2160</span><span class="comment">   * receiving 1 unstructured message (the last continuation message comprised by structured message 3, we then</span></div>
<div class="line"><a id="l02161" name="l02161"></a><span class="lineno"> 2161</span><span class="comment">   * emit five messages in one go).</span></div>
<div class="line"><a id="l02162" name="l02162"></a><span class="lineno"> 2162</span><span class="comment">   *</span></div>
<div class="line"><a id="l02163" name="l02163"></a><span class="lineno"> 2163</span><span class="comment">   * So that&#39;s why there can be multiple handlers.</span></div>
<div class="line"><a id="l02164" name="l02164"></a><span class="lineno"> 2164</span><span class="comment">   *</span></div>
<div class="line"><a id="l02165" name="l02165"></a><span class="lineno"> 2165</span><span class="comment">   * ### Rationale: Expressing this as a function object ###</span></div>
<div class="line"><a id="l02166" name="l02166"></a><span class="lineno"> 2166</span><span class="comment">   * I (ygoldfel) suspect the semantics of this guy and handlers_post() and</span></div>
<div class="line"><a id="l02167" name="l02167"></a><span class="lineno"> 2167</span><span class="comment">   * handlers_poll() might be confusing.  It may look like some sort of</span></div>
<div class="line"><a id="l02168" name="l02168"></a><span class="lineno"> 2168</span><span class="comment">   * generalized boost.asio-`post()`-lite scheme, but in reality it is much simpler than that.  In actual reality:</span></div>
<div class="line"><a id="l02169" name="l02169"></a><span class="lineno"> 2169</span><span class="comment">   * we read an in-message; as a result we either need to do nothing user-handler-wise, or we need to invoke</span></div>
<div class="line"><a id="l02170" name="l02170"></a><span class="lineno"> 2170</span><span class="comment">   * 1 relevant handler.  (As of this writing no one in-message can mean 2+ user handlers are applicable.  See above.</span></div>
<div class="line"><a id="l02171" name="l02171"></a><span class="lineno"> 2171</span><span class="comment">   * Conceivably that could change but....)  This calling-of-user-handler just needs to occur a few stack frames up</span></div>
<div class="line"><a id="l02172" name="l02172"></a><span class="lineno"> 2172</span><span class="comment">   * (synchronously at that) and can be triggered by all manner of situations a few stack frames down.  So, really,</span></div>
<div class="line"><a id="l02173" name="l02173"></a><span class="lineno"> 2173</span><span class="comment">   * this could be communicated in some kind of union-enumeration combo.  Expressing it as an actual function to</span></div>
<div class="line"><a id="l02174" name="l02174"></a><span class="lineno"> 2174</span><span class="comment">   * run just seemed like the most code-economical way to express it.  It&#39;s easier to code &quot;execute this&quot; rather than</span></div>
<div class="line"><a id="l02175" name="l02175"></a><span class="lineno"> 2175</span><span class="comment">   * &quot;decode this union-enumeration thing to tell you what you should execute.&quot;  Perf-wise it might be worse... maybe...</span></div>
<div class="line"><a id="l02176" name="l02176"></a><span class="lineno"> 2176</span><span class="comment">   * as `Function&lt;&gt;` is a polymorphic data structure.  (Premature optimization is the root of all ev... and so on.)</span></div>
<div class="line"><a id="l02177" name="l02177"></a><span class="lineno"> 2177</span><span class="comment">   *</span></div>
<div class="line"><a id="l02178" name="l02178"></a><span class="lineno"> 2178</span><span class="comment">   * ### Rationale: Communicating this via handlers_post() to handlers_poll() ###</span></div>
<div class="line"><a id="l02179" name="l02179"></a><span class="lineno"> 2179</span><span class="comment">   * Orthogonally, saving it (whether a union-enumeration thing or a callback) in this data structure</span></div>
<div class="line"><a id="l02180" name="l02180"></a><span class="lineno"> 2180</span><span class="comment">   * (#m_sync_io_handlers) *felt* more economical (in terms of lines of code) than returning it</span></div>
<div class="line"><a id="l02181" name="l02181"></a><span class="lineno"> 2181</span><span class="comment">   * up a function-call chain.  On the other hand, though, the algorithm would be more rigid-looking and robust</span></div>
<div class="line"><a id="l02182" name="l02182"></a><span class="lineno"> 2182</span><span class="comment">   * that other way; generally speaking I (ygoldfel) always prefer to keep less state and be more functional</span></div>
<div class="line"><a id="l02183" name="l02183"></a><span class="lineno"> 2183</span><span class="comment">   * in style -- this here going against that.  Indeed Native_socket_stream::Impl does it that more-functional way</span></div>
<div class="line"><a id="l02184" name="l02184"></a><span class="lineno"> 2184</span><span class="comment">   * albeit in a totally different setting.  Well, we&#39;ll see.  Anyway it works at least.</span></div>
<div class="line"><a id="l02185" name="l02185"></a><span class="lineno"> 2185</span><span class="comment">   */</span></div>
<div class="line"><a id="l02186" name="l02186"></a><span class="lineno"><a class="line" href="classipc_1_1transport_1_1struc_1_1sync__io_1_1Channel.html#a2c0013237f845e5589cf0063886c7431"> 2186</a></span>  std::vector&lt;boost::movelib::unique_ptr&lt;util::Task&gt;&gt; <a class="code hl_variable" href="classipc_1_1transport_1_1struc_1_1sync__io_1_1Channel.html#a2c0013237f845e5589cf0063886c7431">m_sync_io_handlers</a>;</div>
<div class="line"><a id="l02187" name="l02187"></a><span class="lineno"> 2187</span>}; <span class="comment">// class Channel</span></div>
<div class="line"><a id="l02188" name="l02188"></a><span class="lineno"> 2188</span> </div>
<div class="line"><a id="l02189" name="l02189"></a><span class="lineno"> 2189</span><span class="comment">// Free functions: in *_fwd.hpp.</span></div>
<div class="line"><a id="l02190" name="l02190"></a><span class="lineno"> 2190</span> </div>
<div class="line"><a id="l02191" name="l02191"></a><span class="lineno"> 2191</span><span class="comment">// Template implementations.</span></div>
<div class="line"><a id="l02192" name="l02192"></a><span class="lineno"> 2192</span><span class="comment"></span> </div>
<div class="line"><a id="l02193" name="l02193"></a><span class="lineno"> 2193</span><span class="comment">/// Internally used macro; public API users should disregard (same deal as in ../structured_channel.hpp).</span></div>
<div class="line"><a id="l02194" name="l02194"></a><span class="lineno"><a class="line" href="ipc__transport__structured_2src_2ipc_2transport_2struc_2sync__io_2channel_8hpp.html#a50e1bb663274c68c760263342ddfdcbc"> 2194</a></span><span class="comment"></span><span class="preprocessor">#define TEMPLATE_SIO_STRUCT_CHANNEL \</span></div>
<div class="line"><a id="l02195" name="l02195"></a><span class="lineno"> 2195</span><span class="preprocessor">  template&lt;typename Channel_obj, typename Message_body, \</span></div>
<div class="line"><a id="l02196" name="l02196"></a><span class="lineno"> 2196</span><span class="preprocessor">           typename Struct_builder_config, typename Struct_reader_config&gt;</span><span class="comment"></span></div>
<div class="line"><a id="l02197" name="l02197"></a><span class="lineno"> 2197</span><span class="comment">/// Internally used macro; public API users should disregard (same deal as in ../structured_channel.hpp).</span></div>
<div class="line"><a id="l02198" name="l02198"></a><span class="lineno"><a class="line" href="ipc__transport__structured_2src_2ipc_2transport_2struc_2sync__io_2channel_8hpp.html#aefc68934c89912e7b5d0706bdb2be6e5"> 2198</a></span><span class="comment"></span><span class="preprocessor">#define CLASS_SIO_STRUCT_CHANNEL \</span></div>
<div class="line"><a id="l02199" name="l02199"></a><span class="lineno"> 2199</span><span class="preprocessor">  Channel&lt;Channel_obj, Message_body, Struct_builder_config, Struct_reader_config&gt;</span></div>
<div class="line"><a id="l02200" name="l02200"></a><span class="lineno"> 2200</span> </div>
<div class="line"><a id="l02201" name="l02201"></a><span class="lineno"> 2201</span><a class="code hl_define" href="ipc__transport__structured_2src_2ipc_2transport_2struc_2sync__io_2channel_8hpp.html#a50e1bb663274c68c760263342ddfdcbc">TEMPLATE_SIO_STRUCT_CHANNEL</a></div>
<div class="line"><a id="l02202" name="l02202"></a><span class="lineno"><a class="line" href="classipc_1_1transport_1_1struc_1_1sync__io_1_1Channel.html#a9385752ed00263dec5c5080b67ce0960"> 2202</a></span><a class="code hl_typedef" href="namespaceipc_1_1transport_1_1struc_1_1shm_1_1classic.html#ac543b500a85f556564e592cbbefb6185">CLASS_SIO_STRUCT_CHANNEL::Channel</a>(flow::log::Logger* logger_ptr, Channel_obj&amp;&amp; channel,</div>
<div class="line"><a id="l02203" name="l02203"></a><span class="lineno"> 2203</span>                                  <span class="keyword">const</span> <a class="code hl_typedef" href="classipc_1_1transport_1_1struc_1_1sync__io_1_1Channel.html#a8a59bbc3c6a7191b316b23661d8ba6e3">Builder_config</a>&amp; struct_builder_config,</div>
<div class="line"><a id="l02204" name="l02204"></a><span class="lineno"> 2204</span>                                  <span class="keyword">const</span> <span class="keyword">typename</span> Builder_config::Builder::Session&amp; struct_lender_session,</div>
<div class="line"><a id="l02205" name="l02205"></a><span class="lineno"> 2205</span>                                  <span class="keyword">const</span> <a class="code hl_typedef" href="classipc_1_1transport_1_1struc_1_1sync__io_1_1Channel.html#a14a7166b2f8c117ce6ddafe943d036fa">Reader_config</a>&amp; struct_reader_config,</div>
<div class="line"><a id="l02206" name="l02206"></a><span class="lineno"> 2206</span>                                  <span class="keyword">const</span> <a class="code hl_typedef" href="namespaceipc_1_1transport_1_1struc.html#a6751c05fb6582a34c7c47ac470c4a48b">Session_token</a>&amp; session_token_non_nil) :</div>
<div class="line"><a id="l02207" name="l02207"></a><span class="lineno"> 2207</span>  flow::log::Log_context(logger_ptr, <a class="code hl_enumeration" href="namespaceipc.html#a4ccdeed058222c635745a4dc830e99f7">Log_component</a>::S_TRANSPORT),</div>
<div class="line"><a id="l02208" name="l02208"></a><span class="lineno"> 2208</span>  m_struct_builder_config(struct_builder_config),</div>
<div class="line"><a id="l02209" name="l02209"></a><span class="lineno"> 2209</span>  m_struct_lender_session(struct_lender_session),</div>
<div class="line"><a id="l02210" name="l02210"></a><span class="lineno"> 2210</span>  m_struct_reader_config(struct_reader_config),</div>
<div class="line"><a id="l02211" name="l02211"></a><span class="lineno"> 2211</span> </div>
<div class="line"><a id="l02212" name="l02212"></a><span class="lineno"> 2212</span>  <span class="comment">/* Initial protocol = 1!</span></div>
<div class="line"><a id="l02213" name="l02213"></a><span class="lineno"> 2213</span><span class="comment">   * @todo This will get quite a bit more complex, especially for m_protocol_negotiator_aux,</span></div>
<div class="line"><a id="l02214" name="l02214"></a><span class="lineno"> 2214</span><span class="comment">   *       once at least one relevant protocol gains a version 2.  See class doc header for discussion. */</span></div>
<div class="line"><a id="l02215" name="l02215"></a><span class="lineno"> 2215</span>  m_protocol_negotiator(get_logger(), std::string(<span class="stringliteral">&quot;struc-&quot;</span>) + channel.nickname(), 1, 1),</div>
<div class="line"><a id="l02216" name="l02216"></a><span class="lineno"> 2216</span>  m_protocol_negotiator_aux(get_logger(), std::string(<span class="stringliteral">&quot;struc-aux-&quot;</span>) + channel.nickname(), 1, 1),</div>
<div class="line"><a id="l02217" name="l02217"></a><span class="lineno"> 2217</span> </div>
<div class="line"><a id="l02218" name="l02218"></a><span class="lineno"> 2218</span>  m_started_ops(false),</div>
<div class="line"><a id="l02219" name="l02219"></a><span class="lineno"> 2219</span> </div>
<div class="line"><a id="l02220" name="l02220"></a><span class="lineno"> 2220</span>  <span class="comment">// Skip log-in phase.  Ready to rock immediately.</span></div>
<div class="line"><a id="l02221" name="l02221"></a><span class="lineno"> 2221</span>  m_session_token(session_token_non_nil),</div>
<div class="line"><a id="l02222" name="l02222"></a><span class="lineno"> 2222</span>  m_snd_msg_next_id(1),</div>
<div class="line"><a id="l02223" name="l02223"></a><span class="lineno"> 2223</span> </div>
<div class="line"><a id="l02224" name="l02224"></a><span class="lineno"> 2224</span>  m_phase(<a class="code hl_enumeration" href="classipc_1_1transport_1_1struc_1_1sync__io_1_1Channel.html#a5a3833cd141802041551db21198ac319">Phase</a>::S_LOGGED_IN),</div>
<div class="line"><a id="l02225" name="l02225"></a><span class="lineno"> 2225</span> </div>
<div class="line"><a id="l02226" name="l02226"></a><span class="lineno"> 2226</span>  m_rcv_msg_next_id(1),</div>
<div class="line"><a id="l02227" name="l02227"></a><span class="lineno"> 2227</span> </div>
<div class="line"><a id="l02228" name="l02228"></a><span class="lineno"> 2228</span>  m_channel(std::move(channel))</div>
<div class="line"><a id="l02229" name="l02229"></a><span class="lineno"> 2229</span>{</div>
<div class="line"><a id="l02230" name="l02230"></a><span class="lineno"> 2230</span>  <span class="comment">// (Deets on m_channel are in printing *this.)</span></div>
<div class="line"><a id="l02231" name="l02231"></a><span class="lineno"> 2231</span>  FLOW_LOG_INFO(<span class="stringliteral">&quot;struc::Channel [&quot;</span> &lt;&lt; *<span class="keyword">this</span> &lt;&lt; <span class="stringliteral">&quot;]: Created, owning the aforementioned (SIO) Channel.  &quot;</span></div>
<div class="line"><a id="l02232" name="l02232"></a><span class="lineno"> 2232</span>                <span class="stringliteral">&quot;Log-in phase bypassed; session token = [&quot;</span> &lt;&lt; <a class="code hl_variable" href="classipc_1_1transport_1_1struc_1_1sync__io_1_1Channel.html#a49e257338f9b20fd70c42142eb2db4f0">m_session_token</a> &lt;&lt; <span class="stringliteral">&quot;].  &quot;</span></div>
<div class="line"><a id="l02233" name="l02233"></a><span class="lineno"> 2233</span>                <span class="stringliteral">&quot;(User must invoke start_ops() and (if needed) replace_event_wait_handles().  Assume it occurs soon.)  &quot;</span></div>
<div class="line"><a id="l02234" name="l02234"></a><span class="lineno"> 2234</span>                <span class="stringliteral">&quot;Async-read chain will not start until start_and_poll().  Sends possible now.&quot;</span>);</div>
<div class="line"><a id="l02235" name="l02235"></a><span class="lineno"> 2235</span> </div>
<div class="line"><a id="l02236" name="l02236"></a><span class="lineno"> 2236</span>  <span class="keywordflow">if</span> <span class="keyword">constexpr</span>(Owned_channel::S_HAS_2_PIPES)</div>
<div class="line"><a id="l02237" name="l02237"></a><span class="lineno"> 2237</span>  {</div>
<div class="line"><a id="l02238" name="l02238"></a><span class="lineno"> 2238</span>    <a class="code hl_variable" href="classipc_1_1transport_1_1struc_1_1sync__io_1_1Channel.html#a1218e59c91d08758cd997d77913abd5a">m_rcv_reassembly_q</a>.emplace();</div>
<div class="line"><a id="l02239" name="l02239"></a><span class="lineno"> 2239</span>  }</div>
<div class="line"><a id="l02240" name="l02240"></a><span class="lineno"> 2240</span>  <span class="comment">// else { Leave the optional&lt;&gt; uninitialized forever. }</span></div>
<div class="line"><a id="l02241" name="l02241"></a><span class="lineno"> 2241</span> </div>
<div class="line"><a id="l02242" name="l02242"></a><span class="lineno"> 2242</span>  assert((!session_token_non_nil.is_nil())</div>
<div class="line"><a id="l02243" name="l02243"></a><span class="lineno"> 2243</span>           &amp;&amp; <span class="stringliteral">&quot;Pre-logged-in channel must be supplied a non-nil session token, presumably &quot;</span></div>
<div class="line"><a id="l02244" name="l02244"></a><span class="lineno"> 2244</span>                <span class="stringliteral">&quot;from session master channel.&quot;</span>);</div>
<div class="line"><a id="l02245" name="l02245"></a><span class="lineno"> 2245</span>} <span class="comment">// Channel::Channel()</span></div>
<div class="line"><a id="l02246" name="l02246"></a><span class="lineno"> 2246</span> </div>
<div class="line"><a id="l02247" name="l02247"></a><span class="lineno"> 2247</span><a class="code hl_define" href="ipc__transport__structured_2src_2ipc_2transport_2struc_2sync__io_2channel_8hpp.html#a50e1bb663274c68c760263342ddfdcbc">TEMPLATE_SIO_STRUCT_CHANNEL</a></div>
<div class="line"><a id="l02248" name="l02248"></a><span class="lineno"><a class="line" href="classipc_1_1transport_1_1struc_1_1sync__io_1_1Channel.html#a5b863cba6eec77f20236d1e8c8d006a3"> 2248</a></span><a class="code hl_typedef" href="namespaceipc_1_1transport_1_1struc_1_1shm_1_1classic.html#ac543b500a85f556564e592cbbefb6185">CLASS_SIO_STRUCT_CHANNEL::Channel</a>(flow::log::Logger* logger_ptr, Channel_obj&amp;&amp; channel,</div>
<div class="line"><a id="l02249" name="l02249"></a><span class="lineno"> 2249</span>                                  <span class="keyword">const</span> <a class="code hl_typedef" href="classipc_1_1transport_1_1struc_1_1sync__io_1_1Channel.html#a8a59bbc3c6a7191b316b23661d8ba6e3">Builder_config</a>&amp; struct_builder_config,</div>
<div class="line"><a id="l02250" name="l02250"></a><span class="lineno"> 2250</span>                                  <span class="keyword">const</span> <span class="keyword">typename</span> Builder_config::Builder::Session&amp; struct_lender_session,</div>
<div class="line"><a id="l02251" name="l02251"></a><span class="lineno"> 2251</span>                                  <span class="keyword">const</span> <a class="code hl_typedef" href="classipc_1_1transport_1_1struc_1_1sync__io_1_1Channel.html#a14a7166b2f8c117ce6ddafe943d036fa">Reader_config</a>&amp; struct_reader_config,</div>
<div class="line"><a id="l02252" name="l02252"></a><span class="lineno"> 2252</span>                                  <span class="keywordtype">bool</span> is_server) :</div>
<div class="line"><a id="l02253" name="l02253"></a><span class="lineno"> 2253</span>  flow::log::Log_context(logger_ptr, <a class="code hl_enumeration" href="namespaceipc.html#a4ccdeed058222c635745a4dc830e99f7">Log_component</a>::S_TRANSPORT),</div>
<div class="line"><a id="l02254" name="l02254"></a><span class="lineno"> 2254</span>  m_struct_builder_config(struct_builder_config),</div>
<div class="line"><a id="l02255" name="l02255"></a><span class="lineno"> 2255</span>  m_struct_lender_session(struct_lender_session),</div>
<div class="line"><a id="l02256" name="l02256"></a><span class="lineno"> 2256</span>  m_struct_reader_config(struct_reader_config),</div>
<div class="line"><a id="l02257" name="l02257"></a><span class="lineno"> 2257</span> </div>
<div class="line"><a id="l02258" name="l02258"></a><span class="lineno"> 2258</span>  <span class="comment">// See comment in earlier Channel::Channel().  @todo Code reuse?</span></div>
<div class="line"><a id="l02259" name="l02259"></a><span class="lineno"> 2259</span>  m_protocol_negotiator(get_logger(), std::string(<span class="stringliteral">&quot;struc-&quot;</span>) + channel.nickname(), 1, 1),</div>
<div class="line"><a id="l02260" name="l02260"></a><span class="lineno"> 2260</span>  m_protocol_negotiator_aux(get_logger(), std::string(<span class="stringliteral">&quot;struc-aux-&quot;</span>) + channel.nickname(), 1, 1),</div>
<div class="line"><a id="l02261" name="l02261"></a><span class="lineno"> 2261</span> </div>
<div class="line"><a id="l02262" name="l02262"></a><span class="lineno"> 2262</span>  m_started_ops(false),</div>
<div class="line"><a id="l02263" name="l02263"></a><span class="lineno"> 2263</span> </div>
<div class="line"><a id="l02264" name="l02264"></a><span class="lineno"> 2264</span>  <span class="comment">// Start in log-in phase.  They can use only the small (log-in-related) part of the public API for now.</span></div>
<div class="line"><a id="l02265" name="l02265"></a><span class="lineno"> 2265</span>  m_session_token(is_server</div>
<div class="line"><a id="l02266" name="l02266"></a><span class="lineno"> 2266</span>                    <span class="comment">/* @todo In practice this is done rarely per process, probably, but docs do suggest to</span></div>
<div class="line"><a id="l02267" name="l02267"></a><span class="lineno"> 2267</span><span class="comment">                     * save the uuids::random_generator &quot;if you can&quot; due to possible non-trivial startup cost.</span></div>
<div class="line"><a id="l02268" name="l02268"></a><span class="lineno"> 2268</span><span class="comment">                     * We&#39;d have to deal with thread safety + static then though.  Again in reality log-in</span></div>
<div class="line"><a id="l02269" name="l02269"></a><span class="lineno"> 2269</span><span class="comment">                     * probably occurs in only one channel per process and quite rarely. */</span></div>
<div class="line"><a id="l02270" name="l02270"></a><span class="lineno"> 2270</span>                    ? boost::uuids::random_generator()() <span class="comment">// Server *creates* the UUID (later sends it to client).</span></div>
<div class="line"><a id="l02271" name="l02271"></a><span class="lineno"> 2271</span>                    : <a class="code hl_variable" href="namespaceipc_1_1transport_1_1struc.html#ad556d20a2aa2d52b83c7afb73951d47d">NULL_SESSION_TOKEN</a>), <span class="comment">// Client lacks UUID until server sends it in log-in reponse.</span></div>
<div class="line"><a id="l02272" name="l02272"></a><span class="lineno"> 2272</span>  m_snd_msg_next_id(1),</div>
<div class="line"><a id="l02273" name="l02273"></a><span class="lineno"> 2273</span>  m_phase(is_server ? <a class="code hl_enumeration" href="classipc_1_1transport_1_1struc_1_1sync__io_1_1Channel.html#a5a3833cd141802041551db21198ac319">Phase</a>::S_SRV_LOG_IN : <a class="code hl_enumeration" href="classipc_1_1transport_1_1struc_1_1sync__io_1_1Channel.html#a5a3833cd141802041551db21198ac319">Phase</a>::S_CLI_LOG_IN),</div>
<div class="line"><a id="l02274" name="l02274"></a><span class="lineno"> 2274</span>  m_phase_log_in_started(false),</div>
<div class="line"><a id="l02275" name="l02275"></a><span class="lineno"> 2275</span> </div>
<div class="line"><a id="l02276" name="l02276"></a><span class="lineno"> 2276</span>  m_rcv_msg_next_id(1),</div>
<div class="line"><a id="l02277" name="l02277"></a><span class="lineno"> 2277</span> </div>
<div class="line"><a id="l02278" name="l02278"></a><span class="lineno"> 2278</span>  m_channel(std::move(channel))</div>
<div class="line"><a id="l02279" name="l02279"></a><span class="lineno"> 2279</span>{</div>
<div class="line"><a id="l02280" name="l02280"></a><span class="lineno"> 2280</span>  <span class="comment">// (Deets on m_channel are in printing *this.)</span></div>
<div class="line"><a id="l02281" name="l02281"></a><span class="lineno"> 2281</span>  FLOW_LOG_INFO(<span class="stringliteral">&quot;struc::Channel [&quot;</span> &lt;&lt; *<span class="keyword">this</span> &lt;&lt; <span class="stringliteral">&quot;]: Created, owning the aforementioned (SIO) Channel.  &quot;</span></div>
<div class="line"><a id="l02282" name="l02282"></a><span class="lineno"> 2282</span>                <span class="stringliteral">&quot;Log-in phase [&quot;</span> &lt;&lt; (is_server ? <span class="stringliteral">&quot;server&quot;</span> : <span class="stringliteral">&quot;client&quot;</span>) &lt;&lt; <span class="stringliteral">&quot;] in effect; session token is nil &quot;</span></div>
<div class="line"><a id="l02283" name="l02283"></a><span class="lineno"> 2283</span>                <span class="stringliteral">&quot;until log-in phase completes.  &quot;</span></div>
<div class="line"><a id="l02284" name="l02284"></a><span class="lineno"> 2284</span>                <span class="stringliteral">&quot;(User must invoke start_ops() and (if needed) replace_event_wait_handles().  Assume it occurs soon.)  &quot;</span></div>
<div class="line"><a id="l02285" name="l02285"></a><span class="lineno"> 2285</span>                <span class="stringliteral">&quot;Async-read chain will not start until start_and_poll().  Sends possible now.&quot;</span>);</div>
<div class="line"><a id="l02286" name="l02286"></a><span class="lineno"> 2286</span> </div>
<div class="line"><a id="l02287" name="l02287"></a><span class="lineno"> 2287</span>  <span class="keywordflow">if</span> <span class="keyword">constexpr</span>(Owned_channel::S_HAS_2_PIPES)</div>
<div class="line"><a id="l02288" name="l02288"></a><span class="lineno"> 2288</span>  {</div>
<div class="line"><a id="l02289" name="l02289"></a><span class="lineno"> 2289</span>    <a class="code hl_variable" href="classipc_1_1transport_1_1struc_1_1sync__io_1_1Channel.html#a1218e59c91d08758cd997d77913abd5a">m_rcv_reassembly_q</a>.emplace();</div>
<div class="line"><a id="l02290" name="l02290"></a><span class="lineno"> 2290</span>  }</div>
<div class="line"><a id="l02291" name="l02291"></a><span class="lineno"> 2291</span>  <span class="comment">// else { Leave the optional&lt;&gt; uninitialized forever. }</span></div>
<div class="line"><a id="l02292" name="l02292"></a><span class="lineno"> 2292</span>} <span class="comment">// Channel::Channel()</span></div>
<div class="line"><a id="l02293" name="l02293"></a><span class="lineno"> 2293</span> </div>
<div class="line"><a id="l02294" name="l02294"></a><span class="lineno"> 2294</span><a class="code hl_define" href="ipc__transport__structured_2src_2ipc_2transport_2struc_2sync__io_2channel_8hpp.html#a50e1bb663274c68c760263342ddfdcbc">TEMPLATE_SIO_STRUCT_CHANNEL</a></div>
<div class="line"><a id="l02295" name="l02295"></a><span class="lineno"><a class="line" href="classipc_1_1transport_1_1struc_1_1sync__io_1_1Channel.html#a81c366280bf0f3cd711eba0a9f81698f"> 2295</a></span><a class="code hl_typedef" href="namespaceipc_1_1transport_1_1struc_1_1shm_1_1classic.html#ac543b500a85f556564e592cbbefb6185">CLASS_SIO_STRUCT_CHANNEL::Channel</a>(flow::log::Logger* logger_ptr, Channel_obj&amp;&amp; channel,</div>
<div class="line"><a id="l02296" name="l02296"></a><span class="lineno"> 2296</span>                                  <a class="code hl_struct" href="structipc_1_1transport_1_1struc_1_1Channel__base_1_1Serialize__via__heap.html">Serialize_via_heap</a>,</div>
<div class="line"><a id="l02297" name="l02297"></a><span class="lineno"> 2297</span>                                  <span class="keyword">const</span> <a class="code hl_typedef" href="namespaceipc_1_1transport_1_1struc.html#a6751c05fb6582a34c7c47ac470c4a48b">Session_token</a>&amp; session_token_non_nil) :</div>
<div class="line"><a id="l02298" name="l02298"></a><span class="lineno"> 2298</span>  <a class="code hl_class" href="classipc_1_1transport_1_1struc_1_1sync__io_1_1Channel.html">Channel</a>(logger_ptr, std::move(channel),</div>
<div class="line"><a id="l02299" name="l02299"></a><span class="lineno"> 2299</span>          <a class="code hl_class" href="classipc_1_1transport_1_1struc_1_1Channel.html">Async_io_obj</a>::heap_fixed_builder_config(channel), <a class="code hl_variable" href="namespaceipc_1_1transport_1_1struc.html#ac70446757444f864afa21a5062bc5b0d">NULL_SESSION</a>,</div>
<div class="line"><a id="l02300" name="l02300"></a><span class="lineno"> 2300</span>          <a class="code hl_class" href="classipc_1_1transport_1_1struc_1_1Channel.html">Async_io_obj</a>::heap_reader_config(channel),</div>
<div class="line"><a id="l02301" name="l02301"></a><span class="lineno"> 2301</span>          session_token_non_nil)</div>
<div class="line"><a id="l02302" name="l02302"></a><span class="lineno"> 2302</span>{</div>
<div class="line"><a id="l02303" name="l02303"></a><span class="lineno"> 2303</span>  <span class="comment">// Delegated.</span></div>
<div class="line"><a id="l02304" name="l02304"></a><span class="lineno"> 2304</span>}</div>
<div class="line"><a id="l02305" name="l02305"></a><span class="lineno"> 2305</span> </div>
<div class="line"><a id="l02306" name="l02306"></a><span class="lineno"> 2306</span><a class="code hl_define" href="ipc__transport__structured_2src_2ipc_2transport_2struc_2sync__io_2channel_8hpp.html#a50e1bb663274c68c760263342ddfdcbc">TEMPLATE_SIO_STRUCT_CHANNEL</a></div>
<div class="line"><a id="l02307" name="l02307"></a><span class="lineno"><a class="line" href="classipc_1_1transport_1_1struc_1_1sync__io_1_1Channel.html#aeb834160e2f34931c50291485d2d7d04"> 2307</a></span><a class="code hl_typedef" href="namespaceipc_1_1transport_1_1struc_1_1shm_1_1classic.html#ac543b500a85f556564e592cbbefb6185">CLASS_SIO_STRUCT_CHANNEL::Channel</a>(flow::log::Logger* logger_ptr, Channel_obj&amp;&amp; channel,</div>
<div class="line"><a id="l02308" name="l02308"></a><span class="lineno"> 2308</span>                                  <a class="code hl_struct" href="structipc_1_1transport_1_1struc_1_1Channel__base_1_1Serialize__via__heap.html">Serialize_via_heap</a>,</div>
<div class="line"><a id="l02309" name="l02309"></a><span class="lineno"> 2309</span>                                  <span class="keywordtype">bool</span> is_server) :</div>
<div class="line"><a id="l02310" name="l02310"></a><span class="lineno"> 2310</span>  <a class="code hl_class" href="classipc_1_1transport_1_1struc_1_1sync__io_1_1Channel.html">Channel</a>(logger_ptr, std::move(channel),</div>
<div class="line"><a id="l02311" name="l02311"></a><span class="lineno"> 2311</span>          <a class="code hl_class" href="classipc_1_1transport_1_1struc_1_1Channel.html">Async_io_obj</a>::heap_fixed_builder_config(channel), <a class="code hl_variable" href="namespaceipc_1_1transport_1_1struc.html#ac70446757444f864afa21a5062bc5b0d">NULL_SESSION</a>,</div>
<div class="line"><a id="l02312" name="l02312"></a><span class="lineno"> 2312</span>          <a class="code hl_class" href="classipc_1_1transport_1_1struc_1_1Channel.html">Async_io_obj</a>::heap_reader_config(channel),</div>
<div class="line"><a id="l02313" name="l02313"></a><span class="lineno"> 2313</span>          is_server)</div>
<div class="line"><a id="l02314" name="l02314"></a><span class="lineno"> 2314</span>{</div>
<div class="line"><a id="l02315" name="l02315"></a><span class="lineno"> 2315</span>  <span class="comment">// Delegated.</span></div>
<div class="line"><a id="l02316" name="l02316"></a><span class="lineno"> 2316</span>}</div>
<div class="line"><a id="l02317" name="l02317"></a><span class="lineno"> 2317</span> </div>
<div class="line"><a id="l02318" name="l02318"></a><span class="lineno"> 2318</span><a class="code hl_define" href="ipc__transport__structured_2src_2ipc_2transport_2struc_2sync__io_2channel_8hpp.html#a50e1bb663274c68c760263342ddfdcbc">TEMPLATE_SIO_STRUCT_CHANNEL</a></div>
<div class="line"><a id="l02319" name="l02319"></a><span class="lineno"> 2319</span><span class="keyword">template</span>&lt;<span class="keyword">typename</span> Session&gt;</div>
<div class="line"><a id="l02320" name="l02320"></a><span class="lineno"><a class="line" href="classipc_1_1transport_1_1struc_1_1sync__io_1_1Channel.html#a37296f3ac6713bd36d0c7b13d5f78fb7"> 2320</a></span><a class="code hl_typedef" href="namespaceipc_1_1transport_1_1struc_1_1shm_1_1classic.html#ac543b500a85f556564e592cbbefb6185">CLASS_SIO_STRUCT_CHANNEL::Channel</a>(flow::log::Logger* logger_ptr, Channel_obj&amp;&amp; channel,</div>
<div class="line"><a id="l02321" name="l02321"></a><span class="lineno"> 2321</span>                                             <a class="code hl_struct" href="structipc_1_1transport_1_1struc_1_1Channel__base_1_1Serialize__via__session__shm.html">Serialize_via_session_shm</a>, Session* session,</div>
<div class="line"><a id="l02322" name="l02322"></a><span class="lineno"> 2322</span>                                             <span class="keyword">const</span> <a class="code hl_typedef" href="namespaceipc_1_1transport_1_1struc.html#a6751c05fb6582a34c7c47ac470c4a48b">Session_token</a>&amp; session_token_explicit) :</div>
<div class="line"><a id="l02323" name="l02323"></a><span class="lineno"> 2323</span>  <a class="code hl_class" href="classipc_1_1transport_1_1struc_1_1sync__io_1_1Channel.html">Channel</a>(logger_ptr, std::move(channel),</div>
<div class="line"><a id="l02324" name="l02324"></a><span class="lineno"> 2324</span>          session-&gt;session_shm_builder_config(), session-&gt;session_shm_lender_session(),</div>
<div class="line"><a id="l02325" name="l02325"></a><span class="lineno"> 2325</span>          session-&gt;session_shm_reader_config(),</div>
<div class="line"><a id="l02326" name="l02326"></a><span class="lineno"> 2326</span>          (session_token_explicit == <a class="code hl_variable" href="namespaceipc_1_1transport_1_1struc.html#ad556d20a2aa2d52b83c7afb73951d47d">NULL_SESSION_TOKEN</a>)</div>
<div class="line"><a id="l02327" name="l02327"></a><span class="lineno"> 2327</span>            ? session-&gt;session_token()</div>
<div class="line"><a id="l02328" name="l02328"></a><span class="lineno"> 2328</span>            : session_token_explicit)</div>
<div class="line"><a id="l02329" name="l02329"></a><span class="lineno"> 2329</span>{</div>
<div class="line"><a id="l02330" name="l02330"></a><span class="lineno"> 2330</span>  <span class="comment">// Delegated.</span></div>
<div class="line"><a id="l02331" name="l02331"></a><span class="lineno"> 2331</span>}</div>
<div class="line"><a id="l02332" name="l02332"></a><span class="lineno"> 2332</span> </div>
<div class="line"><a id="l02333" name="l02333"></a><span class="lineno"> 2333</span><a class="code hl_define" href="ipc__transport__structured_2src_2ipc_2transport_2struc_2sync__io_2channel_8hpp.html#a50e1bb663274c68c760263342ddfdcbc">TEMPLATE_SIO_STRUCT_CHANNEL</a></div>
<div class="line"><a id="l02334" name="l02334"></a><span class="lineno"> 2334</span><span class="keyword">template</span>&lt;<span class="keyword">typename</span> Session&gt;</div>
<div class="line"><a id="l02335" name="l02335"></a><span class="lineno"><a class="line" href="classipc_1_1transport_1_1struc_1_1sync__io_1_1Channel.html#a2ec1232d7b9c59526f7d1a3c62483269"> 2335</a></span><a class="code hl_typedef" href="namespaceipc_1_1transport_1_1struc_1_1shm_1_1classic.html#ac543b500a85f556564e592cbbefb6185">CLASS_SIO_STRUCT_CHANNEL::Channel</a>(flow::log::Logger* logger_ptr, Channel_obj&amp;&amp; channel,</div>
<div class="line"><a id="l02336" name="l02336"></a><span class="lineno"> 2336</span>                                             <a class="code hl_struct" href="structipc_1_1transport_1_1struc_1_1Channel__base_1_1Serialize__via__session__shm.html">Serialize_via_session_shm</a>, Session* session,</div>
<div class="line"><a id="l02337" name="l02337"></a><span class="lineno"> 2337</span>                                             <span class="keywordtype">bool</span> is_server) :</div>
<div class="line"><a id="l02338" name="l02338"></a><span class="lineno"> 2338</span>  <a class="code hl_class" href="classipc_1_1transport_1_1struc_1_1sync__io_1_1Channel.html">Channel</a>(logger_ptr, std::move(channel),</div>
<div class="line"><a id="l02339" name="l02339"></a><span class="lineno"> 2339</span>          session-&gt;session_shm_builder_config(), session-&gt;session_shm_lender_session(),</div>
<div class="line"><a id="l02340" name="l02340"></a><span class="lineno"> 2340</span>          session-&gt;session_shm_reader_config(),</div>
<div class="line"><a id="l02341" name="l02341"></a><span class="lineno"> 2341</span>          is_server)</div>
<div class="line"><a id="l02342" name="l02342"></a><span class="lineno"> 2342</span>{</div>
<div class="line"><a id="l02343" name="l02343"></a><span class="lineno"> 2343</span>  <span class="comment">// Delegated.</span></div>
<div class="line"><a id="l02344" name="l02344"></a><span class="lineno"> 2344</span>}</div>
<div class="line"><a id="l02345" name="l02345"></a><span class="lineno"> 2345</span> </div>
<div class="line"><a id="l02346" name="l02346"></a><span class="lineno"> 2346</span><a class="code hl_define" href="ipc__transport__structured_2src_2ipc_2transport_2struc_2sync__io_2channel_8hpp.html#a50e1bb663274c68c760263342ddfdcbc">TEMPLATE_SIO_STRUCT_CHANNEL</a></div>
<div class="line"><a id="l02347" name="l02347"></a><span class="lineno"> 2347</span><span class="keyword">template</span>&lt;<span class="keyword">typename</span> Session&gt;</div>
<div class="line"><a id="l02348" name="l02348"></a><span class="lineno"><a class="line" href="classipc_1_1transport_1_1struc_1_1sync__io_1_1Channel.html#a454d0ced89cda0b092d4f86897400e1c"> 2348</a></span><a class="code hl_typedef" href="namespaceipc_1_1transport_1_1struc_1_1shm_1_1classic.html#ac543b500a85f556564e592cbbefb6185">CLASS_SIO_STRUCT_CHANNEL::Channel</a>(flow::log::Logger* logger_ptr, Channel_obj&amp;&amp; channel,</div>
<div class="line"><a id="l02349" name="l02349"></a><span class="lineno"> 2349</span>                                             <a class="code hl_struct" href="structipc_1_1transport_1_1struc_1_1Channel__base_1_1Serialize__via__app__shm.html">Serialize_via_app_shm</a>, Session* session,</div>
<div class="line"><a id="l02350" name="l02350"></a><span class="lineno"> 2350</span>                                             <span class="keyword">const</span> <a class="code hl_typedef" href="namespaceipc_1_1transport_1_1struc.html#a6751c05fb6582a34c7c47ac470c4a48b">Session_token</a>&amp; session_token_explicit) :</div>
<div class="line"><a id="l02351" name="l02351"></a><span class="lineno"> 2351</span>  <a class="code hl_class" href="classipc_1_1transport_1_1struc_1_1sync__io_1_1Channel.html">Channel</a>(logger_ptr, std::move(channel),</div>
<div class="line"><a id="l02352" name="l02352"></a><span class="lineno"> 2352</span>          session-&gt;app_shm_builder_config(), session-&gt;app_shm_lender_session(),</div>
<div class="line"><a id="l02353" name="l02353"></a><span class="lineno"> 2353</span>          session-&gt;app_shm_reader_config(),</div>
<div class="line"><a id="l02354" name="l02354"></a><span class="lineno"> 2354</span>          (session_token_explicit == <a class="code hl_variable" href="namespaceipc_1_1transport_1_1struc.html#ad556d20a2aa2d52b83c7afb73951d47d">NULL_SESSION_TOKEN</a>)</div>
<div class="line"><a id="l02355" name="l02355"></a><span class="lineno"> 2355</span>            ? session-&gt;session_token()</div>
<div class="line"><a id="l02356" name="l02356"></a><span class="lineno"> 2356</span>            : session_token_explicit)</div>
<div class="line"><a id="l02357" name="l02357"></a><span class="lineno"> 2357</span>{</div>
<div class="line"><a id="l02358" name="l02358"></a><span class="lineno"> 2358</span>  <span class="comment">// Delegated.</span></div>
<div class="line"><a id="l02359" name="l02359"></a><span class="lineno"> 2359</span>}</div>
<div class="line"><a id="l02360" name="l02360"></a><span class="lineno"> 2360</span> </div>
<div class="line"><a id="l02361" name="l02361"></a><span class="lineno"> 2361</span><a class="code hl_define" href="ipc__transport__structured_2src_2ipc_2transport_2struc_2sync__io_2channel_8hpp.html#a50e1bb663274c68c760263342ddfdcbc">TEMPLATE_SIO_STRUCT_CHANNEL</a></div>
<div class="line"><a id="l02362" name="l02362"></a><span class="lineno"> 2362</span><span class="keyword">template</span>&lt;<span class="keyword">typename</span> Session&gt;</div>
<div class="line"><a id="l02363" name="l02363"></a><span class="lineno"><a class="line" href="classipc_1_1transport_1_1struc_1_1sync__io_1_1Channel.html#ac056b37680ded4b3c26dd4c6941a72c6"> 2363</a></span><a class="code hl_typedef" href="namespaceipc_1_1transport_1_1struc_1_1shm_1_1classic.html#ac543b500a85f556564e592cbbefb6185">CLASS_SIO_STRUCT_CHANNEL::Channel</a>(flow::log::Logger* logger_ptr, Channel_obj&amp;&amp; channel,</div>
<div class="line"><a id="l02364" name="l02364"></a><span class="lineno"> 2364</span>                                             <a class="code hl_struct" href="structipc_1_1transport_1_1struc_1_1Channel__base_1_1Serialize__via__app__shm.html">Serialize_via_app_shm</a>, Session* session,</div>
<div class="line"><a id="l02365" name="l02365"></a><span class="lineno"> 2365</span>                                             <span class="keywordtype">bool</span> is_server) :</div>
<div class="line"><a id="l02366" name="l02366"></a><span class="lineno"> 2366</span>  <a class="code hl_class" href="classipc_1_1transport_1_1struc_1_1sync__io_1_1Channel.html">Channel</a>(logger_ptr, std::move(channel),</div>
<div class="line"><a id="l02367" name="l02367"></a><span class="lineno"> 2367</span>          session-&gt;app_shm_builder_config(), session-&gt;app_shm_lender_session(),</div>
<div class="line"><a id="l02368" name="l02368"></a><span class="lineno"> 2368</span>          session-&gt;app_shm_reader_config(),</div>
<div class="line"><a id="l02369" name="l02369"></a><span class="lineno"> 2369</span>          is_server)</div>
<div class="line"><a id="l02370" name="l02370"></a><span class="lineno"> 2370</span>{</div>
<div class="line"><a id="l02371" name="l02371"></a><span class="lineno"> 2371</span>  <span class="comment">// Delegated.</span></div>
<div class="line"><a id="l02372" name="l02372"></a><span class="lineno"> 2372</span>}</div>
<div class="line"><a id="l02373" name="l02373"></a><span class="lineno"> 2373</span> </div>
<div class="line"><a id="l02374" name="l02374"></a><span class="lineno"> 2374</span><a class="code hl_define" href="ipc__transport__structured_2src_2ipc_2transport_2struc_2sync__io_2channel_8hpp.html#a50e1bb663274c68c760263342ddfdcbc">TEMPLATE_SIO_STRUCT_CHANNEL</a></div>
<div class="line"><a id="l02375" name="l02375"></a><span class="lineno"><a class="line" href="classipc_1_1transport_1_1struc_1_1sync__io_1_1Channel.html#aac7386bca503f1457d93c65e1bfdf71f"> 2375</a></span>CLASS_SIO_STRUCT_CHANNEL::~Channel()</div>
<div class="line"><a id="l02376" name="l02376"></a><span class="lineno"> 2376</span>{</div>
<div class="line"><a id="l02377" name="l02377"></a><span class="lineno"> 2377</span>  FLOW_LOG_INFO(<span class="stringliteral">&quot;struc::Channel [&quot;</span> &lt;&lt; *<span class="keyword">this</span> &lt;&lt; <span class="stringliteral">&quot;]: Shutting down.  &quot;</span></div>
<div class="line"><a id="l02378" name="l02378"></a><span class="lineno"> 2378</span>                <span class="stringliteral">&quot;Owned-channel and async-worker shall shut down presently.&quot;</span>);</div>
<div class="line"><a id="l02379" name="l02379"></a><span class="lineno"> 2379</span>}</div>
<div class="line"><a id="l02380" name="l02380"></a><span class="lineno"> 2380</span> </div>
<div class="line"><a id="l02381" name="l02381"></a><span class="lineno"> 2381</span><a class="code hl_define" href="ipc__transport__structured_2src_2ipc_2transport_2struc_2sync__io_2channel_8hpp.html#a50e1bb663274c68c760263342ddfdcbc">TEMPLATE_SIO_STRUCT_CHANNEL</a></div>
<div class="line"><a id="l02382" name="l02382"></a><span class="lineno"> 2382</span><span class="keyword">template</span>&lt;<span class="keyword">typename</span> Create_ev_wait_hndl_func&gt;</div>
<div class="line"><a id="l02383" name="l02383"></a><span class="lineno"><a class="line" href="classipc_1_1transport_1_1struc_1_1sync__io_1_1Channel.html#a543aa806ec21b8550f9f440e59767d52"> 2383</a></span><span class="keywordtype">bool</span> CLASS_SIO_STRUCT_CHANNEL::replace_event_wait_handles(<span class="keyword">const</span> Create_ev_wait_hndl_func&amp; create_ev_wait_hndl_func)</div>
<div class="line"><a id="l02384" name="l02384"></a><span class="lineno"> 2384</span>{</div>
<div class="line"><a id="l02385" name="l02385"></a><span class="lineno"> 2385</span>  <span class="keywordflow">return</span> m_channel.replace_event_wait_handles(create_ev_wait_hndl_func);</div>
<div class="line"><a id="l02386" name="l02386"></a><span class="lineno"> 2386</span>}</div>
<div class="line"><a id="l02387" name="l02387"></a><span class="lineno"> 2387</span> </div>
<div class="line"><a id="l02388" name="l02388"></a><span class="lineno"> 2388</span><a class="code hl_define" href="ipc__transport__structured_2src_2ipc_2transport_2struc_2sync__io_2channel_8hpp.html#a50e1bb663274c68c760263342ddfdcbc">TEMPLATE_SIO_STRUCT_CHANNEL</a></div>
<div class="line"><a id="l02389" name="l02389"></a><span class="lineno"> 2389</span><span class="keyword">template</span>&lt;<span class="keyword">typename</span> Event_wait_func_t&gt;</div>
<div class="line"><a id="l02390" name="l02390"></a><span class="lineno"><a class="line" href="classipc_1_1transport_1_1struc_1_1sync__io_1_1Channel.html#a6e4f8c4207fcf678b4cfc785707d3dce"> 2390</a></span><span class="keywordtype">bool</span> CLASS_SIO_STRUCT_CHANNEL::start_ops(Event_wait_func_t&amp;&amp; ev_wait_func)</div>
<div class="line"><a id="l02391" name="l02391"></a><span class="lineno"> 2391</span>{</div>
<div class="line"><a id="l02392" name="l02392"></a><span class="lineno"> 2392</span>  <span class="keyword">using </span><a class="code hl_class" href="classipc_1_1util_1_1sync__io_1_1Asio__waitable__native__handle.html">util::sync_io::Asio_waitable_native_handle</a>;</div>
<div class="line"><a id="l02393" name="l02393"></a><span class="lineno"> 2393</span>  <span class="keyword">using </span><a class="code hl_typedef" href="namespaceipc_1_1util_1_1sync__io.html#ac6973c71fc70c6d867b0f2255c642532">util::sync_io::Task_ptr</a>;</div>
<div class="line"><a id="l02394" name="l02394"></a><span class="lineno"> 2394</span> </div>
<div class="line"><a id="l02395" name="l02395"></a><span class="lineno"> 2395</span>  <span class="keywordflow">if</span> (m_started_ops)</div>
<div class="line"><a id="l02396" name="l02396"></a><span class="lineno"> 2396</span>  {</div>
<div class="line"><a id="l02397" name="l02397"></a><span class="lineno"> 2397</span>    FLOW_LOG_WARNING(<span class="stringliteral">&quot;struc::Channel [&quot;</span> &lt;&lt; *<span class="keyword">this</span> &lt;&lt; <span class="stringliteral">&quot;]: Start-ops requested, but they were already started.  &quot;</span></div>
<div class="line"><a id="l02398" name="l02398"></a><span class="lineno"> 2398</span>                     <span class="stringliteral">&quot;Ignoring.&quot;</span>);</div>
<div class="line"><a id="l02399" name="l02399"></a><span class="lineno"> 2399</span>    <span class="keywordflow">return</span> <span class="keyword">false</span>;</div>
<div class="line"><a id="l02400" name="l02400"></a><span class="lineno"> 2400</span>  }</div>
<div class="line"><a id="l02401" name="l02401"></a><span class="lineno"> 2401</span>  <span class="comment">// else</span></div>
<div class="line"><a id="l02402" name="l02402"></a><span class="lineno"> 2402</span>  m_started_ops = <span class="keyword">true</span>;</div>
<div class="line"><a id="l02403" name="l02403"></a><span class="lineno"> 2403</span> </div>
<div class="line"><a id="l02404" name="l02404"></a><span class="lineno"> 2404</span>  FLOW_LOG_INFO(<span class="stringliteral">&quot;struc::Channel [&quot;</span> &lt;&lt; *<span class="keyword">this</span> &lt;&lt; <span class="stringliteral">&quot;]: Start-ops requested.  Accordingly we forward start-ops &quot;</span></div>
<div class="line"><a id="l02405" name="l02405"></a><span class="lineno"> 2405</span>                <span class="stringliteral">&quot;requests to owned channel [&quot;</span> &lt;&lt; m_channel &lt;&lt; <span class="stringliteral">&quot;] peers.&quot;</span>);</div>
<div class="line"><a id="l02406" name="l02406"></a><span class="lineno"> 2406</span>  <span class="comment">/* @todo Maybe Channel should offer a start_ops() that&#39;ll do what we do?  At the moment one must do it individually</span></div>
<div class="line"><a id="l02407" name="l02407"></a><span class="lineno"> 2407</span><span class="comment">   * peer-by-peer; and that must exist, so that one can lock a different mutex per pipe or whatever -- or formally</span></div>
<div class="line"><a id="l02408" name="l02408"></a><span class="lineno"> 2408</span><span class="comment">   * for it to continue implementing the 4 sync_io::_sender/receiver concepts.  However for a case like ours, where</span></div>
<div class="line"><a id="l02409" name="l02409"></a><span class="lineno"> 2409</span><span class="comment">   * all the op-types are handled by the same code, it would be nice to add a start_ops().  Then what we do here</span></div>
<div class="line"><a id="l02410" name="l02410"></a><span class="lineno"> 2410</span><span class="comment">   * would be available for other Channel users. */</span></div>
<div class="line"><a id="l02411" name="l02411"></a><span class="lineno"> 2411</span> </div>
<div class="line"><a id="l02412" name="l02412"></a><span class="lineno"> 2412</span><span class="preprocessor">#ifndef NDEBUG</span></div>
<div class="line"><a id="l02413" name="l02413"></a><span class="lineno"> 2413</span>  <span class="keywordtype">bool</span> ok;</div>
<div class="line"><a id="l02414" name="l02414"></a><span class="lineno"> 2414</span><span class="preprocessor">#endif</span></div>
<div class="line"><a id="l02415" name="l02415"></a><span class="lineno"> 2415</span>  <span class="keyword">constexpr</span> <span class="keyword">auto</span> HAS_BLOB = Owned_channel::S_HAS_BLOB_PIPE;</div>
<div class="line"><a id="l02416" name="l02416"></a><span class="lineno"> 2416</span>  <span class="keyword">constexpr</span> <span class="keyword">auto</span> HAS_HNDL = Owned_channel::S_HAS_NATIVE_HANDLE_PIPE;</div>
<div class="line"><a id="l02417" name="l02417"></a><span class="lineno"> 2417</span>  <span class="keywordflow">if</span> <span class="keyword">constexpr</span>(HAS_BLOB)</div>
<div class="line"><a id="l02418" name="l02418"></a><span class="lineno"> 2418</span>  {</div>
<div class="line"><a id="l02419" name="l02419"></a><span class="lineno"> 2419</span><span class="preprocessor">#ifndef NDEBUG</span></div>
<div class="line"><a id="l02420" name="l02420"></a><span class="lineno"> 2420</span>    ok =</div>
<div class="line"><a id="l02421" name="l02421"></a><span class="lineno"> 2421</span><span class="preprocessor">#endif</span></div>
<div class="line"><a id="l02422" name="l02422"></a><span class="lineno"> 2422</span>    m_channel.start_send_blob_ops([<span class="keyword">this</span>,</div>
<div class="line"><a id="l02423" name="l02423"></a><span class="lineno"> 2423</span>                                   ev_wait_func] <span class="comment">// Capture a copy (no choice; we need to reuse it below).</span></div>
<div class="line"><a id="l02424" name="l02424"></a><span class="lineno"> 2424</span>                                    (Asio_waitable_native_handle* hndl_of_interest,</div>
<div class="line"><a id="l02425" name="l02425"></a><span class="lineno"> 2425</span>                                     <span class="keywordtype">bool</span> ev_of_interest_snd_else_rcv,</div>
<div class="line"><a id="l02426" name="l02426"></a><span class="lineno"> 2426</span>                                     <a class="code hl_typedef" href="namespaceipc_1_1util_1_1sync__io.html#ac6973c71fc70c6d867b0f2255c642532">Task_ptr</a>&amp;&amp; on_active_ev_func) <span class="keyword">mutable</span></div>
<div class="line"><a id="l02427" name="l02427"></a><span class="lineno"> 2427</span>    {</div>
<div class="line"><a id="l02428" name="l02428"></a><span class="lineno"> 2428</span>      FLOW_LOG_TRACE(<span class="stringliteral">&quot;struc::Channel [&quot;</span> &lt;&lt; *<span class="keyword">this</span> &lt;&lt; <span class="stringliteral">&quot;]: SIO blob-pipe send-op module: event-wait requested.&quot;</span>);</div>
<div class="line"><a id="l02429" name="l02429"></a><span class="lineno"> 2429</span>      ev_wait_func(hndl_of_interest, ev_of_interest_snd_else_rcv, std::move(on_active_ev_func));</div>
<div class="line"><a id="l02430" name="l02430"></a><span class="lineno"> 2430</span>    });</div>
<div class="line"><a id="l02431" name="l02431"></a><span class="lineno"> 2431</span>    assert(ok &amp;&amp; <span class="stringliteral">&quot;m_started_ops should have guarded against this failing.&quot;</span>);</div>
<div class="line"><a id="l02432" name="l02432"></a><span class="lineno"> 2432</span>    <span class="comment">/* This added compile-time branching is to optimize away the copying of ev_wait_func if not needed again below.</span></div>
<div class="line"><a id="l02433" name="l02433"></a><span class="lineno"> 2433</span><span class="comment">     * This is not a perf-critical path, probably, but this code isn&#39;t that long.  Might as well.</span></div>
<div class="line"><a id="l02434" name="l02434"></a><span class="lineno"> 2434</span><span class="comment">     * I (ygoldfel) don&#39;t think the capture can be conditionally specified to use the move-ctor</span></div>
<div class="line"><a id="l02435" name="l02435"></a><span class="lineno"> 2435</span><span class="comment">     * using some compile-time ternary thing.  So wordy `if constexpr()` it is. */</span></div>
<div class="line"><a id="l02436" name="l02436"></a><span class="lineno"> 2436</span>    <span class="keywordflow">if</span> <span class="keyword">constexpr</span>(HAS_HNDL)</div>
<div class="line"><a id="l02437" name="l02437"></a><span class="lineno"> 2437</span>    {</div>
<div class="line"><a id="l02438" name="l02438"></a><span class="lineno"> 2438</span><span class="preprocessor">#ifndef NDEBUG</span></div>
<div class="line"><a id="l02439" name="l02439"></a><span class="lineno"> 2439</span>      ok =</div>
<div class="line"><a id="l02440" name="l02440"></a><span class="lineno"> 2440</span><span class="preprocessor">#endif</span></div>
<div class="line"><a id="l02441" name="l02441"></a><span class="lineno"> 2441</span>      m_channel.start_receive_blob_ops([<span class="keyword">this</span>,</div>
<div class="line"><a id="l02442" name="l02442"></a><span class="lineno"> 2442</span>                                        ev_wait_func] <span class="comment">// Copy again.</span></div>
<div class="line"><a id="l02443" name="l02443"></a><span class="lineno"> 2443</span>                                         (Asio_waitable_native_handle* hndl_of_interest,</div>
<div class="line"><a id="l02444" name="l02444"></a><span class="lineno"> 2444</span>                                          <span class="keywordtype">bool</span> ev_of_interest_snd_else_rcv, <a class="code hl_typedef" href="namespaceipc_1_1util_1_1sync__io.html#ac6973c71fc70c6d867b0f2255c642532">Task_ptr</a>&amp;&amp; on_active_ev_func) <span class="keyword">mutable</span></div>
<div class="line"><a id="l02445" name="l02445"></a><span class="lineno"> 2445</span>      {</div>
<div class="line"><a id="l02446" name="l02446"></a><span class="lineno"> 2446</span>        FLOW_LOG_TRACE(<span class="stringliteral">&quot;struc::Channel [&quot;</span> &lt;&lt; *<span class="keyword">this</span> &lt;&lt; <span class="stringliteral">&quot;]: SIO blob-pipe receive-op module: event-wait requested.&quot;</span>);</div>
<div class="line"><a id="l02447" name="l02447"></a><span class="lineno"> 2447</span>        ev_wait_func(hndl_of_interest, ev_of_interest_snd_else_rcv, std::move(on_active_ev_func));</div>
<div class="line"><a id="l02448" name="l02448"></a><span class="lineno"> 2448</span>      });</div>
<div class="line"><a id="l02449" name="l02449"></a><span class="lineno"> 2449</span>      assert(ok &amp;&amp; <span class="stringliteral">&quot;m_started_ops should have guarded against this failing.&quot;</span>);</div>
<div class="line"><a id="l02450" name="l02450"></a><span class="lineno"> 2450</span>    }</div>
<div class="line"><a id="l02451" name="l02451"></a><span class="lineno"> 2451</span>    <span class="keywordflow">else</span></div>
<div class="line"><a id="l02452" name="l02452"></a><span class="lineno"> 2452</span>    {</div>
<div class="line"><a id="l02453" name="l02453"></a><span class="lineno"> 2453</span><span class="preprocessor">#ifndef NDEBUG</span></div>
<div class="line"><a id="l02454" name="l02454"></a><span class="lineno"> 2454</span>      ok =</div>
<div class="line"><a id="l02455" name="l02455"></a><span class="lineno"> 2455</span><span class="preprocessor">#endif</span></div>
<div class="line"><a id="l02456" name="l02456"></a><span class="lineno"> 2456</span>      m_channel.start_receive_blob_ops([<span class="keyword">this</span>,</div>
<div class="line"><a id="l02457" name="l02457"></a><span class="lineno"> 2457</span>                                        ev_wait_func = std::move(ev_wait_func)] <span class="comment">// Do not copy.</span></div>
<div class="line"><a id="l02458" name="l02458"></a><span class="lineno"> 2458</span>                                         (Asio_waitable_native_handle* hndl_of_interest,</div>
<div class="line"><a id="l02459" name="l02459"></a><span class="lineno"> 2459</span>                                          <span class="keywordtype">bool</span> ev_of_interest_snd_else_rcv, <a class="code hl_typedef" href="namespaceipc_1_1util_1_1sync__io.html#ac6973c71fc70c6d867b0f2255c642532">Task_ptr</a>&amp;&amp; on_active_ev_func) <span class="keyword">mutable</span></div>
<div class="line"><a id="l02460" name="l02460"></a><span class="lineno"> 2460</span>      {</div>
<div class="line"><a id="l02461" name="l02461"></a><span class="lineno"> 2461</span>        FLOW_LOG_TRACE(<span class="stringliteral">&quot;struc::Channel [&quot;</span> &lt;&lt; *<span class="keyword">this</span> &lt;&lt; <span class="stringliteral">&quot;]: SIO blob-pipe receive-op module: event-wait requested.&quot;</span>);</div>
<div class="line"><a id="l02462" name="l02462"></a><span class="lineno"> 2462</span>        ev_wait_func(hndl_of_interest, ev_of_interest_snd_else_rcv, std::move(on_active_ev_func));</div>
<div class="line"><a id="l02463" name="l02463"></a><span class="lineno"> 2463</span>      });</div>
<div class="line"><a id="l02464" name="l02464"></a><span class="lineno"> 2464</span>      assert(ok &amp;&amp; <span class="stringliteral">&quot;m_started_ops should have guarded against this failing.&quot;</span>);</div>
<div class="line"><a id="l02465" name="l02465"></a><span class="lineno"> 2465</span>    }</div>
<div class="line"><a id="l02466" name="l02466"></a><span class="lineno"> 2466</span>  } <span class="comment">// if constexpr(HAS_BLOB)</span></div>
<div class="line"><a id="l02467" name="l02467"></a><span class="lineno"> 2467</span>  <span class="keywordflow">if</span> <span class="keyword">constexpr</span>(HAS_HNDL)</div>
<div class="line"><a id="l02468" name="l02468"></a><span class="lineno"> 2468</span>  {</div>
<div class="line"><a id="l02469" name="l02469"></a><span class="lineno"> 2469</span><span class="preprocessor">#ifndef NDEBUG</span></div>
<div class="line"><a id="l02470" name="l02470"></a><span class="lineno"> 2470</span>    ok =</div>
<div class="line"><a id="l02471" name="l02471"></a><span class="lineno"> 2471</span><span class="preprocessor">#endif</span></div>
<div class="line"><a id="l02472" name="l02472"></a><span class="lineno"> 2472</span>    m_channel.start_send_native_handle_ops([<span class="keyword">this</span>,</div>
<div class="line"><a id="l02473" name="l02473"></a><span class="lineno"> 2473</span>                                            ev_wait_func] <span class="comment">// See above.</span></div>
<div class="line"><a id="l02474" name="l02474"></a><span class="lineno"> 2474</span>                                             (Asio_waitable_native_handle* hndl_of_interest,</div>
<div class="line"><a id="l02475" name="l02475"></a><span class="lineno"> 2475</span>                                              <span class="keywordtype">bool</span> ev_of_interest_snd_else_rcv,</div>
<div class="line"><a id="l02476" name="l02476"></a><span class="lineno"> 2476</span>                                              <a class="code hl_typedef" href="namespaceipc_1_1util_1_1sync__io.html#ac6973c71fc70c6d867b0f2255c642532">Task_ptr</a>&amp;&amp; on_active_ev_func) <span class="keyword">mutable</span></div>
<div class="line"><a id="l02477" name="l02477"></a><span class="lineno"> 2477</span>    {</div>
<div class="line"><a id="l02478" name="l02478"></a><span class="lineno"> 2478</span>      FLOW_LOG_TRACE(<span class="stringliteral">&quot;struc::Channel [&quot;</span> &lt;&lt; *<span class="keyword">this</span> &lt;&lt; <span class="stringliteral">&quot;]: SIO handle-pipe send-op module: event-wait requested.&quot;</span>);</div>
<div class="line"><a id="l02479" name="l02479"></a><span class="lineno"> 2479</span>      ev_wait_func(hndl_of_interest, ev_of_interest_snd_else_rcv, std::move(on_active_ev_func));</div>
<div class="line"><a id="l02480" name="l02480"></a><span class="lineno"> 2480</span>    });</div>
<div class="line"><a id="l02481" name="l02481"></a><span class="lineno"> 2481</span>    assert(ok &amp;&amp; <span class="stringliteral">&quot;m_started_ops should have guarded against this failing.&quot;</span>);</div>
<div class="line"><a id="l02482" name="l02482"></a><span class="lineno"> 2482</span><span class="preprocessor">#ifndef NDEBUG</span></div>
<div class="line"><a id="l02483" name="l02483"></a><span class="lineno"> 2483</span>    ok =</div>
<div class="line"><a id="l02484" name="l02484"></a><span class="lineno"> 2484</span><span class="preprocessor">#endif</span></div>
<div class="line"><a id="l02485" name="l02485"></a><span class="lineno"> 2485</span>    m_channel.start_receive_native_handle_ops([<span class="keyword">this</span>,</div>
<div class="line"><a id="l02486" name="l02486"></a><span class="lineno"> 2486</span>                                               ev_wait_func = std::move(ev_wait_func)] <span class="comment">// Don&#39;t need it again.  Eat it.</span></div>
<div class="line"><a id="l02487" name="l02487"></a><span class="lineno"> 2487</span>                                                (Asio_waitable_native_handle* hndl_of_interest,</div>
<div class="line"><a id="l02488" name="l02488"></a><span class="lineno"> 2488</span>                                                 <span class="keywordtype">bool</span> ev_of_interest_snd_else_rcv,</div>
<div class="line"><a id="l02489" name="l02489"></a><span class="lineno"> 2489</span>                                                 <a class="code hl_typedef" href="namespaceipc_1_1util_1_1sync__io.html#ac6973c71fc70c6d867b0f2255c642532">Task_ptr</a>&amp;&amp; on_active_ev_func) <span class="keyword">mutable</span></div>
<div class="line"><a id="l02490" name="l02490"></a><span class="lineno"> 2490</span>    {</div>
<div class="line"><a id="l02491" name="l02491"></a><span class="lineno"> 2491</span>      FLOW_LOG_TRACE(<span class="stringliteral">&quot;struc::Channel [&quot;</span> &lt;&lt; *<span class="keyword">this</span> &lt;&lt; <span class="stringliteral">&quot;]: SIO handle-pipe receive-op module: event-wait requested.&quot;</span>);</div>
<div class="line"><a id="l02492" name="l02492"></a><span class="lineno"> 2492</span>      ev_wait_func(hndl_of_interest, ev_of_interest_snd_else_rcv, std::move(on_active_ev_func));</div>
<div class="line"><a id="l02493" name="l02493"></a><span class="lineno"> 2493</span>    });</div>
<div class="line"><a id="l02494" name="l02494"></a><span class="lineno"> 2494</span>    assert(ok &amp;&amp; <span class="stringliteral">&quot;m_started_ops should have guarded against this failing.&quot;</span>);</div>
<div class="line"><a id="l02495" name="l02495"></a><span class="lineno"> 2495</span>  } <span class="comment">// if constexpr(HAS_HNDL)</span></div>
<div class="line"><a id="l02496" name="l02496"></a><span class="lineno"> 2496</span> </div>
<div class="line"><a id="l02497" name="l02497"></a><span class="lineno"> 2497</span>  FLOW_LOG_INFO(<span class="stringliteral">&quot;struc::Channel [&quot;</span> &lt;&lt; *<span class="keyword">this</span> &lt;&lt; <span class="stringliteral">&quot;]: Start-ops requested.  Done.&quot;</span>);</div>
<div class="line"><a id="l02498" name="l02498"></a><span class="lineno"> 2498</span> </div>
<div class="line"><a id="l02499" name="l02499"></a><span class="lineno"> 2499</span>  <span class="comment">// We can, and must (see &quot;Protocol negotiation&quot; in class doc header), now send out the outgoing protocol-negotiation.</span></div>
<div class="line"><a id="l02500" name="l02500"></a><span class="lineno"> 2500</span>  send_proto_neg();</div>
<div class="line"><a id="l02501" name="l02501"></a><span class="lineno"> 2501</span>  <span class="comment">/* That may have set truthy m_proto_neg_err_code_or_ok; in which case start_and_poll()/send()/async_request() will</span></div>
<div class="line"><a id="l02502" name="l02502"></a><span class="lineno"> 2502</span><span class="comment">   * pick it up (whichever happens first). */</span></div>
<div class="line"><a id="l02503" name="l02503"></a><span class="lineno"> 2503</span> </div>
<div class="line"><a id="l02504" name="l02504"></a><span class="lineno"> 2504</span>  <span class="keywordflow">return</span> <span class="keyword">true</span>;</div>
<div class="line"><a id="l02505" name="l02505"></a><span class="lineno"> 2505</span>} <span class="comment">// Channel::start_ops()</span></div>
<div class="line"><a id="l02506" name="l02506"></a><span class="lineno"> 2506</span> </div>
<div class="line"><a id="l02507" name="l02507"></a><span class="lineno"> 2507</span><a class="code hl_define" href="ipc__transport__structured_2src_2ipc_2transport_2struc_2sync__io_2channel_8hpp.html#a50e1bb663274c68c760263342ddfdcbc">TEMPLATE_SIO_STRUCT_CHANNEL</a></div>
<div class="line"><a id="l02508" name="l02508"></a><span class="lineno"><a class="line" href="classipc_1_1transport_1_1struc_1_1sync__io_1_1Channel.html#ae2a7cdf855b3cdcab1a2e1cd74834cc4"> 2508</a></span><span class="keywordtype">bool</span> CLASS_SIO_STRUCT_CHANNEL::check_not_started_ops(<a class="code hl_typedef" href="namespaceipc_1_1util.html#ae6ac47812a90d1287c61e0b7de7bc4f5">util::String_view</a> context)<span class="keyword"> const</span></div>
<div class="line"><a id="l02509" name="l02509"></a><span class="lineno"> 2509</span><span class="keyword"></span>{</div>
<div class="line"><a id="l02510" name="l02510"></a><span class="lineno"> 2510</span>  <span class="keywordflow">if</span> (!m_started_ops)</div>
<div class="line"><a id="l02511" name="l02511"></a><span class="lineno"> 2511</span>  {</div>
<div class="line"><a id="l02512" name="l02512"></a><span class="lineno"> 2512</span>    FLOW_LOG_WARNING(<span class="stringliteral">&quot;struc::Channel [&quot;</span> &lt;&lt; *<span class="keyword">this</span> &lt;&lt; <span class="stringliteral">&quot;]: This operation (context [&quot;</span> &lt;&lt; context &lt;&lt; <span class="stringliteral">&quot;]) requires &quot;</span></div>
<div class="line"><a id="l02513" name="l02513"></a><span class="lineno"> 2513</span>                     <span class="stringliteral">&quot;start-*-ops which has not been invoked.  Ignoring.&quot;</span>);</div>
<div class="line"><a id="l02514" name="l02514"></a><span class="lineno"> 2514</span>    <span class="keywordflow">return</span> <span class="keyword">true</span>; <span class="comment">// [sic]</span></div>
<div class="line"><a id="l02515" name="l02515"></a><span class="lineno"> 2515</span>  }</div>
<div class="line"><a id="l02516" name="l02516"></a><span class="lineno"> 2516</span>  <span class="keywordflow">return</span> <span class="keyword">false</span>;</div>
<div class="line"><a id="l02517" name="l02517"></a><span class="lineno"> 2517</span>}</div>
<div class="line"><a id="l02518" name="l02518"></a><span class="lineno"> 2518</span> </div>
<div class="line"><a id="l02519" name="l02519"></a><span class="lineno"> 2519</span><a class="code hl_define" href="ipc__transport__structured_2src_2ipc_2transport_2struc_2sync__io_2channel_8hpp.html#a50e1bb663274c68c760263342ddfdcbc">TEMPLATE_SIO_STRUCT_CHANNEL</a></div>
<div class="line"><a id="l02520" name="l02520"></a><span class="lineno"> 2520</span><span class="keyword">template</span>&lt;<span class="keyword">typename</span> Task_err&gt;</div>
<div class="line"><a id="l02521" name="l02521"></a><span class="lineno"><a class="line" href="classipc_1_1transport_1_1struc_1_1sync__io_1_1Channel.html#a0c00bab2dad604dde176c4190553915c"> 2521</a></span><span class="keywordtype">bool</span> CLASS_SIO_STRUCT_CHANNEL::start_and_poll(Task_err&amp;&amp; on_err_func)</div>
<div class="line"><a id="l02522" name="l02522"></a><span class="lineno"> 2522</span>{</div>
<div class="line"><a id="l02523" name="l02523"></a><span class="lineno"> 2523</span>  <span class="keyword">using </span>flow::util::Blob;</div>
<div class="line"><a id="l02524" name="l02524"></a><span class="lineno"> 2524</span>  <span class="keyword">using </span>boost::movelib::make_unique;</div>
<div class="line"><a id="l02525" name="l02525"></a><span class="lineno"> 2525</span> </div>
<div class="line"><a id="l02526" name="l02526"></a><span class="lineno"> 2526</span>  <span class="keywordflow">if</span> (check_not_started_ops(<span class="stringliteral">&quot;start_and_poll()&quot;</span>))</div>
<div class="line"><a id="l02527" name="l02527"></a><span class="lineno"> 2527</span>  {</div>
<div class="line"><a id="l02528" name="l02528"></a><span class="lineno"> 2528</span>    <span class="keywordflow">return</span> <span class="keyword">false</span>;</div>
<div class="line"><a id="l02529" name="l02529"></a><span class="lineno"> 2529</span>  }</div>
<div class="line"><a id="l02530" name="l02530"></a><span class="lineno"> 2530</span>  <span class="comment">// else</span></div>
<div class="line"><a id="l02531" name="l02531"></a><span class="lineno"> 2531</span> </div>
<div class="line"><a id="l02532" name="l02532"></a><span class="lineno"> 2532</span>  <span class="keywordflow">if</span> (!m_on_err_func.empty())</div>
<div class="line"><a id="l02533" name="l02533"></a><span class="lineno"> 2533</span>  {</div>
<div class="line"><a id="l02534" name="l02534"></a><span class="lineno"> 2534</span>    FLOW_LOG_WARNING(<span class="stringliteral">&quot;struc::Channel [&quot;</span> &lt;&lt; *<span class="keyword">this</span> &lt;&lt; <span class="stringliteral">&quot;]: Start requested, but we have already started.  Ignoring.&quot;</span>);</div>
<div class="line"><a id="l02535" name="l02535"></a><span class="lineno"> 2535</span>    <span class="keywordflow">return</span> <span class="keyword">false</span>;</div>
<div class="line"><a id="l02536" name="l02536"></a><span class="lineno"> 2536</span>  }</div>
<div class="line"><a id="l02537" name="l02537"></a><span class="lineno"> 2537</span>  <span class="comment">// else</span></div>
<div class="line"><a id="l02538" name="l02538"></a><span class="lineno"> 2538</span> </div>
<div class="line"><a id="l02539" name="l02539"></a><span class="lineno"> 2539</span>  <span class="keywordflow">if</span> (m_channel_err_code_or_ok)</div>
<div class="line"><a id="l02540" name="l02540"></a><span class="lineno"> 2540</span>  {</div>
<div class="line"><a id="l02541" name="l02541"></a><span class="lineno"> 2541</span>    <span class="comment">// As promised do not re-emit: just follow the no-op contingency.</span></div>
<div class="line"><a id="l02542" name="l02542"></a><span class="lineno"> 2542</span>    FLOW_LOG_WARNING(<span class="stringliteral">&quot;struc::Channel [&quot;</span> &lt;&lt; *<span class="keyword">this</span> &lt;&lt; <span class="stringliteral">&quot;]: Start requested, but the error &quot;</span></div>
<div class="line"><a id="l02543" name="l02543"></a><span class="lineno"> 2543</span>                     <span class="stringliteral">&quot;[&quot;</span> &lt;&lt; m_channel_err_code_or_ok &lt;&lt; <span class="stringliteral">&quot;] [&quot;</span> &lt;&lt; m_channel_err_code_or_ok.message() &lt;&lt; <span class="stringliteral">&quot;] &quot;</span></div>
<div class="line"><a id="l02544" name="l02544"></a><span class="lineno"> 2544</span>                     <span class="stringliteral">&quot;was previously emitted by another send()/similar.  Ignoring.&quot;</span>);</div>
<div class="line"><a id="l02545" name="l02545"></a><span class="lineno"> 2545</span>    <span class="keywordflow">return</span> <span class="keyword">false</span>;</div>
<div class="line"><a id="l02546" name="l02546"></a><span class="lineno"> 2546</span>  } <span class="comment">// else</span></div>
<div class="line"><a id="l02547" name="l02547"></a><span class="lineno"> 2547</span> </div>
<div class="line"><a id="l02548" name="l02548"></a><span class="lineno"> 2548</span>  m_on_err_func = std::move(on_err_func);</div>
<div class="line"><a id="l02549" name="l02549"></a><span class="lineno"> 2549</span>  assert(!m_on_err_func.empty());</div>
<div class="line"><a id="l02550" name="l02550"></a><span class="lineno"> 2550</span> </div>
<div class="line"><a id="l02551" name="l02551"></a><span class="lineno"> 2551</span>  FLOW_LOG_INFO(<span class="stringliteral">&quot;struc::Channel [&quot;</span> &lt;&lt; *<span class="keyword">this</span> &lt;&lt; <span class="stringliteral">&quot;]: Start requested.  Proceeding to start &quot;</span></div>
<div class="line"><a id="l02552" name="l02552"></a><span class="lineno"> 2552</span>                <span class="stringliteral">&quot;async-receive chain(s).  On-receive handlers may now execute.&quot;</span>);</div>
<div class="line"><a id="l02553" name="l02553"></a><span class="lineno"> 2553</span> </div>
<div class="line"><a id="l02554" name="l02554"></a><span class="lineno"> 2554</span>  <span class="comment">// send_proto_neg() explains this.  Essentially think of it as a channel-hosing condition that was *just* discovered.</span></div>
<div class="line"><a id="l02555" name="l02555"></a><span class="lineno"> 2555</span>  <span class="keywordflow">if</span> (m_proto_neg_err_code_or_ok)</div>
<div class="line"><a id="l02556" name="l02556"></a><span class="lineno"> 2556</span>  {</div>
<div class="line"><a id="l02557" name="l02557"></a><span class="lineno"> 2557</span>    FLOW_LOG_WARNING(<span class="stringliteral">&quot;struc::Channel [&quot;</span> &lt;&lt; *<span class="keyword">this</span> &lt;&lt; <span class="stringliteral">&quot;]: Start requested, but the error &quot;</span></div>
<div class="line"><a id="l02558" name="l02558"></a><span class="lineno"> 2558</span>                     <span class="stringliteral">&quot;[&quot;</span> &lt;&lt; m_proto_neg_err_code_or_ok &lt;&lt; <span class="stringliteral">&quot;] [&quot;</span> &lt;&lt; m_proto_neg_err_code_or_ok.message() &lt;&lt; <span class="stringliteral">&quot;] &quot;</span></div>
<div class="line"><a id="l02559" name="l02559"></a><span class="lineno"> 2559</span>                     <span class="stringliteral">&quot;was previously detected when trying to internally send protocol-negotiation message over a &quot;</span></div>
<div class="line"><a id="l02560" name="l02560"></a><span class="lineno"> 2560</span>                     <span class="stringliteral">&quot;pipe (details likely logged earlier).  Emitting channel-hosing error.&quot;</span>);</div>
<div class="line"><a id="l02561" name="l02561"></a><span class="lineno"> 2561</span>    handle_new_error(m_proto_neg_err_code_or_ok, <span class="stringliteral">&quot;start_and_poll()&quot;</span>);</div>
<div class="line"><a id="l02562" name="l02562"></a><span class="lineno"> 2562</span>    <span class="keywordflow">return</span> <span class="keyword">true</span>;</div>
<div class="line"><a id="l02563" name="l02563"></a><span class="lineno"> 2563</span>  }</div>
<div class="line"><a id="l02564" name="l02564"></a><span class="lineno"> 2564</span>  <span class="comment">// else</span></div>
<div class="line"><a id="l02565" name="l02565"></a><span class="lineno"> 2565</span> </div>
<div class="line"><a id="l02566" name="l02566"></a><span class="lineno"> 2566</span>  <span class="comment">/* This is a new structured channel.  So our goal is to receive our 1st structured in-message sans handle</span></div>
<div class="line"><a id="l02567" name="l02567"></a><span class="lineno"> 2567</span><span class="comment">   * or 1st structured in-message with handle -- we have to be ready for both.  This is where we initialize</span></div>
<div class="line"><a id="l02568" name="l02568"></a><span class="lineno"> 2568</span><span class="comment">   * that algorithm forever by setting up m_rcv_pipes 2-array of optional&lt;&gt;s (currently both storing nothing).</span></div>
<div class="line"><a id="l02569" name="l02569"></a><span class="lineno"> 2569</span><span class="comment">   * From that point on, there will be 1 or 2 async-read chains going, and each will get -- and keep passing along</span></div>
<div class="line"><a id="l02570" name="l02570"></a><span class="lineno"> 2570</span><span class="comment">   * via captures and function-args -- one pointer into m_rcv_pipes.</span></div>
<div class="line"><a id="l02571" name="l02571"></a><span class="lineno"> 2571</span><span class="comment">   *</span></div>
<div class="line"><a id="l02572" name="l02572"></a><span class="lineno"> 2572</span><span class="comment">   * See Msg_in_pipe doc header.  Then come back here.  This should be clear then.  Hope you like reading! */</span></div>
<div class="line"><a id="l02573" name="l02573"></a><span class="lineno"> 2573</span> </div>
<div class="line"><a id="l02574" name="l02574"></a><span class="lineno"> 2574</span>  <span class="keyword">static_assert</span>(<span class="keyword">decltype</span>(m_rcv_pipes)::size() == 2, <span class="stringliteral">&quot;Maintenance bug?!  m_rcv_pipes[] array must have size 2.&quot;</span>);</div>
<div class="line"><a id="l02575" name="l02575"></a><span class="lineno"> 2575</span> </div>
<div class="line"><a id="l02576" name="l02576"></a><span class="lineno"> 2576</span>  <span class="comment">// Little helper.</span></div>
<div class="line"><a id="l02577" name="l02577"></a><span class="lineno"> 2577</span>  <span class="keyword">const</span> <span class="keyword">auto</span> make_proto_neg_reader_in</div>
<div class="line"><a id="l02578" name="l02578"></a><span class="lineno"> 2578</span>    = [<span class="keyword">this</span>]() -&gt; <span class="keyword">auto</span> { <span class="keywordflow">return</span> make_unique&lt;Heap_reader&gt;(<a class="code hl_struct" href="structipc_1_1transport_1_1struc_1_1Heap__reader_1_1Config.html">Heap_reader::Config</a>{ get_logger(), 1 }); };</div>
<div class="line"><a id="l02579" name="l02579"></a><span class="lineno"> 2579</span> </div>
<div class="line"><a id="l02580" name="l02580"></a><span class="lineno"> 2580</span>  <span class="keywordflow">if</span> <span class="keyword">constexpr</span>(Owned_channel::S_HAS_BLOB_PIPE_ONLY)</div>
<div class="line"><a id="l02581" name="l02581"></a><span class="lineno"> 2581</span>  {</div>
<div class="line"><a id="l02582" name="l02582"></a><span class="lineno"> 2582</span>    <span class="comment">// Always start with empty message and a fresh Blob, enough for a lead mdt-message (including segment count).</span></div>
<div class="line"><a id="l02583" name="l02583"></a><span class="lineno"> 2583</span>    <span class="keyword">auto</span> msg_in = make_unique&lt;Msg_in_impl&gt;(m_struct_reader_config);</div>
<div class="line"><a id="l02584" name="l02584"></a><span class="lineno"> 2584</span>    <span class="keyword">const</span> <span class="keyword">auto</span> sz = rcv_blob_max_size(Msg_in_pipe::S_RCV_SANS_HNDL_ONLY);</div>
<div class="line"><a id="l02585" name="l02585"></a><span class="lineno"> 2585</span>    <span class="keyword">auto</span> proto_neg_reader_in = make_proto_neg_reader_in();</div>
<div class="line"><a id="l02586" name="l02586"></a><span class="lineno"> 2586</span>    m_rcv_pipes.front()</div>
<div class="line"><a id="l02587" name="l02587"></a><span class="lineno"> 2587</span>      = {</div>
<div class="line"><a id="l02588" name="l02588"></a><span class="lineno"> 2588</span>          <span class="comment">// Always use m_channel.async_receive_blob(); if sender sends a handle it&#39;s internal Channel fatal error.</span></div>
<div class="line"><a id="l02589" name="l02589"></a><span class="lineno"> 2589</span>          Msg_in_pipe::S_RCV_SANS_HNDL_ONLY,</div>
<div class="line"><a id="l02590" name="l02590"></a><span class="lineno"> 2590</span>          0, <span class="comment">// Segment count unknown until lead message received.</span></div>
<div class="line"><a id="l02591" name="l02591"></a><span class="lineno"> 2591</span>          msg_in-&gt;add_serialization_segment(sz),</div>
<div class="line"><a id="l02592" name="l02592"></a><span class="lineno"> 2592</span>          <a class="code hl_typedef" href="namespaceipc_1_1transport.html#a7ee4551983d9df16ec16a3139bac50e8">Native_handle</a>(), <span class="comment">// Always start with null target handle; in this case will remain that way always.</span></div>
<div class="line"><a id="l02593" name="l02593"></a><span class="lineno"> 2593</span>          std::move(msg_in),</div>
<div class="line"><a id="l02594" name="l02594"></a><span class="lineno"> 2594</span>          <span class="comment">// Prepare the simple one-time protocol-negotiation read/serialize op for this pipe.</span></div>
<div class="line"><a id="l02595" name="l02595"></a><span class="lineno"> 2595</span>          proto_neg_reader_in-&gt;add_serialization_segment(sz), <a class="code hl_typedef" href="namespaceipc_1_1transport.html#a7ee4551983d9df16ec16a3139bac50e8">Native_handle</a>(), std::move(proto_neg_reader_in)</div>
<div class="line"><a id="l02596" name="l02596"></a><span class="lineno"> 2596</span>        };</div>
<div class="line"><a id="l02597" name="l02597"></a><span class="lineno"> 2597</span>    <span class="keywordflow">if</span> (!m_rcv_pipes.front()-&gt;m_target_blob) <span class="comment">// I.e., if add_serialization_segment() returned null:</span></div>
<div class="line"><a id="l02598" name="l02598"></a><span class="lineno"> 2598</span>    {</div>
<div class="line"><a id="l02599" name="l02599"></a><span class="lineno"> 2599</span>      FLOW_LOG_WARNING(<span class="stringliteral">&quot;struc::Channel [&quot;</span> &lt;&lt; *<span class="keyword">this</span> &lt;&lt; <span class="stringliteral">&quot;]: Unable to obtain the first lead unstructured &quot;</span></div>
<div class="line"><a id="l02600" name="l02600"></a><span class="lineno"> 2600</span>                       <span class="stringliteral">&quot;in-message&#39;s target blob from in-message builder engine (details likely logged above).  &quot;</span></div>
<div class="line"><a id="l02601" name="l02601"></a><span class="lineno"> 2601</span>                       <span class="stringliteral">&quot;Emitting channel-hosing error.&quot;</span>);</div>
<div class="line"><a id="l02602" name="l02602"></a><span class="lineno"> 2602</span>      handle_new_error(<a class="code hl_enumvalue" href="namespaceipc_1_1transport_1_1struc_1_1error.html#a990b9ff850cf9aaf354efdd07d86a71dade89b3f5038a04f02d8f4ae68698a069">error::Code::S_INTERNAL_ERROR_DESERIALIZE_TARGET_ALLOC_FAILED</a>,</div>
<div class="line"><a id="l02603" name="l02603"></a><span class="lineno"> 2603</span>                       <span class="stringliteral">&quot;start_and_poll()&quot;</span>);</div>
<div class="line"><a id="l02604" name="l02604"></a><span class="lineno"> 2604</span>      <span class="keywordflow">return</span> <span class="keyword">true</span>; <span class="comment">// We (the async-read chain) died before we could be born.</span></div>
<div class="line"><a id="l02605" name="l02605"></a><span class="lineno"> 2605</span>    }</div>
<div class="line"><a id="l02606" name="l02606"></a><span class="lineno"> 2606</span>    <span class="comment">// else</span></div>
<div class="line"><a id="l02607" name="l02607"></a><span class="lineno"> 2607</span> </div>
<div class="line"><a id="l02608" name="l02608"></a><span class="lineno"> 2608</span>    rcv_async_read_proto_neg_msg(&amp;(*(m_rcv_pipes.front())));</div>
<div class="line"><a id="l02609" name="l02609"></a><span class="lineno"> 2609</span>    <span class="comment">// `*` gets Msg_in_pipe&amp;; `&amp;` converts ref to ptr. --^</span></div>
<div class="line"><a id="l02610" name="l02610"></a><span class="lineno"> 2610</span> </div>
<div class="line"><a id="l02611" name="l02611"></a><span class="lineno"> 2611</span>    assert(!m_rcv_pipes.back());</div>
<div class="line"><a id="l02612" name="l02612"></a><span class="lineno"> 2612</span>  }</div>
<div class="line"><a id="l02613" name="l02613"></a><span class="lineno"> 2613</span>  <span class="keywordflow">else</span> <span class="keywordflow">if</span> <span class="keyword">constexpr</span>(Owned_channel::S_HAS_NATIVE_HANDLE_PIPE_ONLY)</div>
<div class="line"><a id="l02614" name="l02614"></a><span class="lineno"> 2614</span>  {</div>
<div class="line"><a id="l02615" name="l02615"></a><span class="lineno"> 2615</span>    <span class="comment">// As above.</span></div>
<div class="line"><a id="l02616" name="l02616"></a><span class="lineno"> 2616</span>    <span class="keyword">auto</span> msg_in = make_unique&lt;Msg_in_impl&gt;(m_struct_reader_config);</div>
<div class="line"><a id="l02617" name="l02617"></a><span class="lineno"> 2617</span>    <span class="keyword">const</span> <span class="keyword">auto</span> sz = rcv_blob_max_size(Msg_in_pipe::S_RCV_WITH_OR_SANS_HNDL_DEMUX);</div>
<div class="line"><a id="l02618" name="l02618"></a><span class="lineno"> 2618</span>    <span class="keyword">auto</span> proto_neg_reader_in = make_proto_neg_reader_in();</div>
<div class="line"><a id="l02619" name="l02619"></a><span class="lineno"> 2619</span>    m_rcv_pipes.front()</div>
<div class="line"><a id="l02620" name="l02620"></a><span class="lineno"> 2620</span>      = {</div>
<div class="line"><a id="l02621" name="l02621"></a><span class="lineno"> 2621</span>          <span class="comment">// Always use m_channel.async_receive_native_handle(); accept both with- and sans-handle lead messages.</span></div>
<div class="line"><a id="l02622" name="l02622"></a><span class="lineno"> 2622</span>          Msg_in_pipe::S_RCV_WITH_OR_SANS_HNDL_DEMUX,</div>
<div class="line"><a id="l02623" name="l02623"></a><span class="lineno"> 2623</span>          0, <span class="comment">// As above.</span></div>
<div class="line"><a id="l02624" name="l02624"></a><span class="lineno"> 2624</span>          msg_in-&gt;add_serialization_segment(sz),</div>
<div class="line"><a id="l02625" name="l02625"></a><span class="lineno"> 2625</span>          <a class="code hl_typedef" href="namespaceipc_1_1transport.html#a7ee4551983d9df16ec16a3139bac50e8">Native_handle</a>(), <span class="comment">// Always start with null target handle; may remain that way or not (per async-receive).</span></div>
<div class="line"><a id="l02626" name="l02626"></a><span class="lineno"> 2626</span>          std::move(msg_in),</div>
<div class="line"><a id="l02627" name="l02627"></a><span class="lineno"> 2627</span>          proto_neg_reader_in-&gt;add_serialization_segment(sz), <a class="code hl_typedef" href="namespaceipc_1_1transport.html#a7ee4551983d9df16ec16a3139bac50e8">Native_handle</a>(), std::move(proto_neg_reader_in)</div>
<div class="line"><a id="l02628" name="l02628"></a><span class="lineno"> 2628</span>        };</div>
<div class="line"><a id="l02629" name="l02629"></a><span class="lineno"> 2629</span>    <span class="keywordflow">if</span> (!m_rcv_pipes.front()-&gt;m_target_blob) <span class="comment">// I.e., if add_serialization_segment() returned null:</span></div>
<div class="line"><a id="l02630" name="l02630"></a><span class="lineno"> 2630</span>    {</div>
<div class="line"><a id="l02631" name="l02631"></a><span class="lineno"> 2631</span>      FLOW_LOG_WARNING(<span class="stringliteral">&quot;struc::Channel [&quot;</span> &lt;&lt; *<span class="keyword">this</span> &lt;&lt; <span class="stringliteral">&quot;]: Unable to obtain the first lead unstructured &quot;</span></div>
<div class="line"><a id="l02632" name="l02632"></a><span class="lineno"> 2632</span>                       <span class="stringliteral">&quot;in-message&#39;s target blob from in-message builder engine (details likely logged above).  &quot;</span></div>
<div class="line"><a id="l02633" name="l02633"></a><span class="lineno"> 2633</span>                       <span class="stringliteral">&quot;Emitting channel-hosing error.&quot;</span>);</div>
<div class="line"><a id="l02634" name="l02634"></a><span class="lineno"> 2634</span>      handle_new_error(<a class="code hl_enumvalue" href="namespaceipc_1_1transport_1_1struc_1_1error.html#a990b9ff850cf9aaf354efdd07d86a71dade89b3f5038a04f02d8f4ae68698a069">error::Code::S_INTERNAL_ERROR_DESERIALIZE_TARGET_ALLOC_FAILED</a>,</div>
<div class="line"><a id="l02635" name="l02635"></a><span class="lineno"> 2635</span>                       <span class="stringliteral">&quot;start_and_poll()&quot;</span>);</div>
<div class="line"><a id="l02636" name="l02636"></a><span class="lineno"> 2636</span>      <span class="keywordflow">return</span> <span class="keyword">true</span>; <span class="comment">// We (the async-read chain) died before we could be born.</span></div>
<div class="line"><a id="l02637" name="l02637"></a><span class="lineno"> 2637</span>    }</div>
<div class="line"><a id="l02638" name="l02638"></a><span class="lineno"> 2638</span>    <span class="comment">// else</span></div>
<div class="line"><a id="l02639" name="l02639"></a><span class="lineno"> 2639</span> </div>
<div class="line"><a id="l02640" name="l02640"></a><span class="lineno"> 2640</span>    rcv_async_read_proto_neg_msg(&amp;(*(m_rcv_pipes.front()))); <span class="comment">// As above.</span></div>
<div class="line"><a id="l02641" name="l02641"></a><span class="lineno"> 2641</span> </div>
<div class="line"><a id="l02642" name="l02642"></a><span class="lineno"> 2642</span>    assert(!m_rcv_pipes.back());</div>
<div class="line"><a id="l02643" name="l02643"></a><span class="lineno"> 2643</span>  }</div>
<div class="line"><a id="l02644" name="l02644"></a><span class="lineno"> 2644</span>  <span class="keywordflow">else</span> <span class="comment">// Reminder: The following is only compiled if the above two compile-time conditions are false.</span></div>
<div class="line"><a id="l02645" name="l02645"></a><span class="lineno"> 2645</span>  {</div>
<div class="line"><a id="l02646" name="l02646"></a><span class="lineno"> 2646</span>    <span class="keyword">static_assert</span>(Owned_channel::S_HAS_2_PIPES, <span class="stringliteral">&quot;Maintenance bug?!  Channel must have 1 blobs, 1 handles pipe/both.&quot;</span>);</div>
<div class="line"><a id="l02647" name="l02647"></a><span class="lineno"> 2647</span> </div>
<div class="line"><a id="l02648" name="l02648"></a><span class="lineno"> 2648</span>    <span class="comment">// As above.</span></div>
<div class="line"><a id="l02649" name="l02649"></a><span class="lineno"> 2649</span>    <span class="keyword">auto</span> msg_in = make_unique&lt;Msg_in_impl&gt;(m_struct_reader_config);</div>
<div class="line"><a id="l02650" name="l02650"></a><span class="lineno"> 2650</span>    <span class="keyword">auto</span> sz = rcv_blob_max_size(Msg_in_pipe::S_RCV_WITH_HNDL_ELSE_ERROR);</div>
<div class="line"><a id="l02651" name="l02651"></a><span class="lineno"> 2651</span>    <span class="keyword">auto</span> proto_neg_reader_in = make_proto_neg_reader_in();</div>
<div class="line"><a id="l02652" name="l02652"></a><span class="lineno"> 2652</span>    m_rcv_pipes.front()</div>
<div class="line"><a id="l02653" name="l02653"></a><span class="lineno"> 2653</span>      = {</div>
<div class="line"><a id="l02654" name="l02654"></a><span class="lineno"> 2654</span>          <span class="comment">/* Always use m_channel.async_receive_native_handle(); accept only with-handle lead messages.</span></div>
<div class="line"><a id="l02655" name="l02655"></a><span class="lineno"> 2655</span><span class="comment">           * The m_rcv_pipes.back() below will in-parallel handle sans-handle lead messages. */</span></div>
<div class="line"><a id="l02656" name="l02656"></a><span class="lineno"> 2656</span>          Msg_in_pipe::S_RCV_WITH_HNDL_ELSE_ERROR,</div>
<div class="line"><a id="l02657" name="l02657"></a><span class="lineno"> 2657</span>          0, <span class="comment">// As above.</span></div>
<div class="line"><a id="l02658" name="l02658"></a><span class="lineno"> 2658</span>          msg_in-&gt;add_serialization_segment(sz),</div>
<div class="line"><a id="l02659" name="l02659"></a><span class="lineno"> 2659</span>          <a class="code hl_typedef" href="namespaceipc_1_1transport.html#a7ee4551983d9df16ec16a3139bac50e8">Native_handle</a>(), <span class="comment">// Always start with null target handle; won&#39;t remain that way per async-receive.</span></div>
<div class="line"><a id="l02660" name="l02660"></a><span class="lineno"> 2660</span>          std::move(msg_in),</div>
<div class="line"><a id="l02661" name="l02661"></a><span class="lineno"> 2661</span>          proto_neg_reader_in-&gt;add_serialization_segment(sz), <a class="code hl_typedef" href="namespaceipc_1_1transport.html#a7ee4551983d9df16ec16a3139bac50e8">Native_handle</a>(), std::move(proto_neg_reader_in)</div>
<div class="line"><a id="l02662" name="l02662"></a><span class="lineno"> 2662</span>        };</div>
<div class="line"><a id="l02663" name="l02663"></a><span class="lineno"> 2663</span> </div>
<div class="line"><a id="l02664" name="l02664"></a><span class="lineno"> 2664</span>    <span class="keywordflow">if</span> (m_rcv_pipes.front()-&gt;m_target_blob) <span class="comment">// (Just skip this if that guy&#39;s add_serialization_segment() failed.)</span></div>
<div class="line"><a id="l02665" name="l02665"></a><span class="lineno"> 2665</span>    {</div>
<div class="line"><a id="l02666" name="l02666"></a><span class="lineno"> 2666</span>      <span class="comment">// As above.</span></div>
<div class="line"><a id="l02667" name="l02667"></a><span class="lineno"> 2667</span>      msg_in = make_unique&lt;Msg_in_impl&gt;(m_struct_reader_config);</div>
<div class="line"><a id="l02668" name="l02668"></a><span class="lineno"> 2668</span>      sz = rcv_blob_max_size(Msg_in_pipe::S_RCV_SANS_HNDL_ONLY);</div>
<div class="line"><a id="l02669" name="l02669"></a><span class="lineno"> 2669</span>      <span class="keyword">auto</span> proto_neg_reader_in = make_proto_neg_reader_in();</div>
<div class="line"><a id="l02670" name="l02670"></a><span class="lineno"> 2670</span>      m_rcv_pipes.back()</div>
<div class="line"><a id="l02671" name="l02671"></a><span class="lineno"> 2671</span>        = {</div>
<div class="line"><a id="l02672" name="l02672"></a><span class="lineno"> 2672</span>            <span class="comment">// Always use m_channel.async_receive_blob(); if sender sends a handle it&#39;s internal Channel fatal error.</span></div>
<div class="line"><a id="l02673" name="l02673"></a><span class="lineno"> 2673</span>            Msg_in_pipe::S_RCV_SANS_HNDL_ONLY,</div>
<div class="line"><a id="l02674" name="l02674"></a><span class="lineno"> 2674</span>            0, <span class="comment">// As above.</span></div>
<div class="line"><a id="l02675" name="l02675"></a><span class="lineno"> 2675</span>            msg_in-&gt;add_serialization_segment(sz),</div>
<div class="line"><a id="l02676" name="l02676"></a><span class="lineno"> 2676</span>            <a class="code hl_typedef" href="namespaceipc_1_1transport.html#a7ee4551983d9df16ec16a3139bac50e8">Native_handle</a>(), <span class="comment">// Always start with null target handle; in this case will remain that way always.</span></div>
<div class="line"><a id="l02677" name="l02677"></a><span class="lineno"> 2677</span>            std::move(msg_in),</div>
<div class="line"><a id="l02678" name="l02678"></a><span class="lineno"> 2678</span>            proto_neg_reader_in-&gt;add_serialization_segment(sz), <a class="code hl_typedef" href="namespaceipc_1_1transport.html#a7ee4551983d9df16ec16a3139bac50e8">Native_handle</a>(), std::move(proto_neg_reader_in)</div>
<div class="line"><a id="l02679" name="l02679"></a><span class="lineno"> 2679</span>          };</div>
<div class="line"><a id="l02680" name="l02680"></a><span class="lineno"> 2680</span>    } <span class="comment">// if (m_rcv_pipes.front()-&gt;m_target_blob)</span></div>
<div class="line"><a id="l02681" name="l02681"></a><span class="lineno"> 2681</span> </div>
<div class="line"><a id="l02682" name="l02682"></a><span class="lineno"> 2682</span>    <span class="keywordflow">if</span> ((!m_rcv_pipes.front()-&gt;m_target_blob) <span class="comment">// I.e., if an add_serialization_segment() returned null:</span></div>
<div class="line"><a id="l02683" name="l02683"></a><span class="lineno"> 2683</span>        || (!m_rcv_pipes.back()-&gt;m_target_blob))</div>
<div class="line"><a id="l02684" name="l02684"></a><span class="lineno"> 2684</span>    {</div>
<div class="line"><a id="l02685" name="l02685"></a><span class="lineno"> 2685</span>      FLOW_LOG_WARNING(<span class="stringliteral">&quot;struc::Channel [&quot;</span> &lt;&lt; *<span class="keyword">this</span> &lt;&lt; <span class="stringliteral">&quot;]: Unable to obtain a first lead unstructured &quot;</span></div>
<div class="line"><a id="l02686" name="l02686"></a><span class="lineno"> 2686</span>                       <span class="stringliteral">&quot;in-message&#39;s target blob from in-message builder engine (details likely logged above).  &quot;</span></div>
<div class="line"><a id="l02687" name="l02687"></a><span class="lineno"> 2687</span>                       <span class="stringliteral">&quot;Emitting channel-hosing error.&quot;</span>);</div>
<div class="line"><a id="l02688" name="l02688"></a><span class="lineno"> 2688</span>      handle_new_error(<a class="code hl_enumvalue" href="namespaceipc_1_1transport_1_1struc_1_1error.html#a990b9ff850cf9aaf354efdd07d86a71dade89b3f5038a04f02d8f4ae68698a069">error::Code::S_INTERNAL_ERROR_DESERIALIZE_TARGET_ALLOC_FAILED</a>,</div>
<div class="line"><a id="l02689" name="l02689"></a><span class="lineno"> 2689</span>                       <span class="stringliteral">&quot;start_and_poll()&quot;</span>);</div>
<div class="line"><a id="l02690" name="l02690"></a><span class="lineno"> 2690</span>      <span class="keywordflow">return</span> <span class="keyword">true</span>; <span class="comment">// We (the async-read chain) died before we could be born.</span></div>
<div class="line"><a id="l02691" name="l02691"></a><span class="lineno"> 2691</span>    }</div>
<div class="line"><a id="l02692" name="l02692"></a><span class="lineno"> 2692</span>    <span class="comment">// else</span></div>
<div class="line"><a id="l02693" name="l02693"></a><span class="lineno"> 2693</span> </div>
<div class="line"><a id="l02694" name="l02694"></a><span class="lineno"> 2694</span>    rcv_async_read_proto_neg_msg(&amp;(*(m_rcv_pipes.front()))); <span class="comment">// As above.</span></div>
<div class="line"><a id="l02695" name="l02695"></a><span class="lineno"> 2695</span>    rcv_async_read_proto_neg_msg(&amp;(*(m_rcv_pipes.back()))); <span class="comment">// As above.</span></div>
<div class="line"><a id="l02696" name="l02696"></a><span class="lineno"> 2696</span>  } <span class="comment">// else if (Owned_channel::S_HAS_2_PIPES)</span></div>
<div class="line"><a id="l02697" name="l02697"></a><span class="lineno"> 2697</span> </div>
<div class="line"><a id="l02698" name="l02698"></a><span class="lineno"> 2698</span>  <span class="keywordflow">return</span> <span class="keyword">true</span>;</div>
<div class="line"><a id="l02699" name="l02699"></a><span class="lineno"> 2699</span>} <span class="comment">// Channel::start_and_poll()</span></div>
<div class="line"><a id="l02700" name="l02700"></a><span class="lineno"> 2700</span> </div>
<div class="line"><a id="l02701" name="l02701"></a><span class="lineno"> 2701</span><a class="code hl_define" href="ipc__transport__structured_2src_2ipc_2transport_2struc_2sync__io_2channel_8hpp.html#a50e1bb663274c68c760263342ddfdcbc">TEMPLATE_SIO_STRUCT_CHANNEL</a></div>
<div class="line"><a id="l02702" name="l02702"></a><span class="lineno"><a class="line" href="classipc_1_1transport_1_1struc_1_1sync__io_1_1Channel.html#a9b6cda20adb82073a1d7cf1b5cbfa865"> 2702</a></span><span class="keywordtype">size_t</span> CLASS_SIO_STRUCT_CHANNEL::rcv_blob_max_size(<span class="keyword">decltype</span>(Msg_in_pipe::m_lead_msg_mode) mode)<span class="keyword"> const</span></div>
<div class="line"><a id="l02703" name="l02703"></a><span class="lineno"> 2703</span><span class="keyword"></span>{</div>
<div class="line"><a id="l02704" name="l02704"></a><span class="lineno"> 2704</span>  <span class="keywordflow">switch</span> (mode)</div>
<div class="line"><a id="l02705" name="l02705"></a><span class="lineno"> 2705</span>  {</div>
<div class="line"><a id="l02706" name="l02706"></a><span class="lineno"> 2706</span>  <span class="keywordflow">case</span> Msg_in_pipe::S_RCV_WITH_OR_SANS_HNDL_DEMUX:</div>
<div class="line"><a id="l02707" name="l02707"></a><span class="lineno"> 2707</span>  <span class="keywordflow">case</span> Msg_in_pipe::S_RCV_WITH_HNDL_ELSE_ERROR:</div>
<div class="line"><a id="l02708" name="l02708"></a><span class="lineno"> 2708</span>    <span class="keywordflow">if</span> <span class="keyword">constexpr</span>(Owned_channel::S_HAS_NATIVE_HANDLE_PIPE)</div>
<div class="line"><a id="l02709" name="l02709"></a><span class="lineno"> 2709</span>    {</div>
<div class="line"><a id="l02710" name="l02710"></a><span class="lineno"> 2710</span>      <span class="keywordflow">return</span> m_channel.receive_meta_blob_max_size();</div>
<div class="line"><a id="l02711" name="l02711"></a><span class="lineno"> 2711</span>    }</div>
<div class="line"><a id="l02712" name="l02712"></a><span class="lineno"> 2712</span>    <span class="keywordflow">else</span></div>
<div class="line"><a id="l02713" name="l02713"></a><span class="lineno"> 2713</span>    {</div>
<div class="line"><a id="l02714" name="l02714"></a><span class="lineno"> 2714</span>      assert(<span class="keyword">false</span> &amp;&amp; <span class="stringliteral">&quot;Should never reach this code path.&quot;</span>);</div>
<div class="line"><a id="l02715" name="l02715"></a><span class="lineno"> 2715</span>    }</div>
<div class="line"><a id="l02716" name="l02716"></a><span class="lineno"> 2716</span>    <span class="keywordflow">break</span>;</div>
<div class="line"><a id="l02717" name="l02717"></a><span class="lineno"> 2717</span>  <span class="keywordflow">case</span> Msg_in_pipe::S_RCV_SANS_HNDL_ONLY:</div>
<div class="line"><a id="l02718" name="l02718"></a><span class="lineno"> 2718</span>    <span class="keywordflow">if</span> <span class="keyword">constexpr</span>(Owned_channel::S_HAS_BLOB_PIPE)</div>
<div class="line"><a id="l02719" name="l02719"></a><span class="lineno"> 2719</span>    {</div>
<div class="line"><a id="l02720" name="l02720"></a><span class="lineno"> 2720</span>      <span class="keywordflow">return</span> m_channel.receive_blob_max_size();</div>
<div class="line"><a id="l02721" name="l02721"></a><span class="lineno"> 2721</span>    }</div>
<div class="line"><a id="l02722" name="l02722"></a><span class="lineno"> 2722</span>    <span class="keywordflow">else</span></div>
<div class="line"><a id="l02723" name="l02723"></a><span class="lineno"> 2723</span>    {</div>
<div class="line"><a id="l02724" name="l02724"></a><span class="lineno"> 2724</span>      assert(<span class="keyword">false</span> &amp;&amp; <span class="stringliteral">&quot;Should never reach this code path.&quot;</span>);</div>
<div class="line"><a id="l02725" name="l02725"></a><span class="lineno"> 2725</span>    }</div>
<div class="line"><a id="l02726" name="l02726"></a><span class="lineno"> 2726</span>  } <span class="comment">// switch (mode)</span></div>
<div class="line"><a id="l02727" name="l02727"></a><span class="lineno"> 2727</span>  assert(<span class="keyword">false</span> &amp;&amp; <span class="stringliteral">&quot;Did compiler not warn about missed enum value in switch?&quot;</span>);</div>
<div class="line"><a id="l02728" name="l02728"></a><span class="lineno"> 2728</span>  <span class="keywordflow">return</span> 0;</div>
<div class="line"><a id="l02729" name="l02729"></a><span class="lineno"> 2729</span>} <span class="comment">// Channel::rcv_blob_max_size()</span></div>
<div class="line"><a id="l02730" name="l02730"></a><span class="lineno"> 2730</span> </div>
<div class="line"><a id="l02731" name="l02731"></a><span class="lineno"> 2731</span><a class="code hl_define" href="ipc__transport__structured_2src_2ipc_2transport_2struc_2sync__io_2channel_8hpp.html#a50e1bb663274c68c760263342ddfdcbc">TEMPLATE_SIO_STRUCT_CHANNEL</a></div>
<div class="line"><a id="l02732" name="l02732"></a><span class="lineno"><a class="line" href="classipc_1_1transport_1_1struc_1_1sync__io_1_1Channel.html#a252e43676b8a41a706df0655f887be63"> 2732</a></span><span class="keywordtype">void</span> CLASS_SIO_STRUCT_CHANNEL::rcv_async_read_lead_or_continuation_msg(<a class="code hl_struct" href="structipc_1_1transport_1_1struc_1_1sync__io_1_1Channel_1_1Msg__in__pipe.html">Msg_in_pipe</a>* pipe, <span class="keywordtype">bool</span> lead_else_cont)</div>
<div class="line"><a id="l02733" name="l02733"></a><span class="lineno"> 2733</span>{</div>
<div class="line"><a id="l02734" name="l02734"></a><span class="lineno"> 2734</span>  <span class="comment">/* Our basic algorithm along each *pipe is:</span></div>
<div class="line"><a id="l02735" name="l02735"></a><span class="lineno"> 2735</span><span class="comment">   *   - Read unstructured message:</span></div>
<div class="line"><a id="l02736" name="l02736"></a><span class="lineno"> 2736</span><span class="comment">   *     [ m_channel.async_receive_&lt;pipe&gt;() ]</span></div>
<div class="line"><a id="l02737" name="l02737"></a><span class="lineno"> 2737</span><span class="comment">   *   - Deal with it (might post handlers via handlers_post() -- might need another message to do so -- etc.):</span></div>
<div class="line"><a id="l02738" name="l02738"></a><span class="lineno"> 2738</span><span class="comment">   *     [ rcv_on_async_read_lead/continuation_msg() ]</span></div>
<div class="line"><a id="l02739" name="l02739"></a><span class="lineno"> 2739</span><span class="comment">   *   - Run the handlers that were handlers_post()ed:</span></div>
<div class="line"><a id="l02740" name="l02740"></a><span class="lineno"> 2740</span><span class="comment">   *     [ handlers_poll() ]</span></div>
<div class="line"><a id="l02741" name="l02741"></a><span class="lineno"> 2741</span><span class="comment">   *   - Back to step 1, unless we should stop (details below).</span></div>
<div class="line"><a id="l02742" name="l02742"></a><span class="lineno"> 2742</span><span class="comment">   *</span></div>
<div class="line"><a id="l02743" name="l02743"></a><span class="lineno"> 2743</span><span class="comment">   * Suppose 1,000 messages are queued in the in-pipe at this time.  Then the above algorithm would look just</span></div>
<div class="line"><a id="l02744" name="l02744"></a><span class="lineno"> 2744</span><span class="comment">   * like that in code, synchronously: do { ...that stuff... } while (&lt;no more&gt;).</span></div>
<div class="line"><a id="l02745" name="l02745"></a><span class="lineno"> 2745</span><span class="comment">   *</span></div>
<div class="line"><a id="l02746" name="l02746"></a><span class="lineno"> 2746</span><span class="comment">   * Small complication: rcv_on_async_read_lead/continuation_msg() returns whether the next expected message</span></div>
<div class="line"><a id="l02747" name="l02747"></a><span class="lineno"> 2747</span><span class="comment">   * is lead or continuation, meaning it decides which of those 2 use on the *next* message.  Next small</span></div>
<div class="line"><a id="l02748" name="l02748"></a><span class="lineno"> 2748</span><span class="comment">   * complication: on error (whether from the async_receive_*() or due to contents of message or ???) it can specify</span></div>
<div class="line"><a id="l02749" name="l02749"></a><span class="lineno"> 2749</span><span class="comment">   * to stop the chain (forever).  So all in all it returns one of READ_LEAD/CONT_MSG or STOP; STOP ends the</span></div>
<div class="line"><a id="l02750" name="l02750"></a><span class="lineno"> 2750</span><span class="comment">   * loop.</span></div>
<div class="line"><a id="l02751" name="l02751"></a><span class="lineno"> 2751</span><span class="comment">   *</span></div>
<div class="line"><a id="l02752" name="l02752"></a><span class="lineno"> 2752</span><span class="comment">   * Large complication: There may not be 1,000 messages; there may 0, or 3, or 1, say.  And eventually we</span></div>
<div class="line"><a id="l02753" name="l02753"></a><span class="lineno"> 2753</span><span class="comment">   * run out, so step 1 up there will yield sync_err_code=would-block, meaning it started an async-wait,</span></div>
<div class="line"><a id="l02754" name="l02754"></a><span class="lineno"> 2754</span><span class="comment">   * and we need to resume the algorithm from that point on once the async-wait yields a message or channel-hosing</span></div>
<div class="line"><a id="l02755" name="l02755"></a><span class="lineno"> 2755</span><span class="comment">   * error.  So that makes step 1 more like:</span></div>
<div class="line"><a id="l02756" name="l02756"></a><span class="lineno"> 2756</span><span class="comment">   *   - read unstructured message:</span></div>
<div class="line"><a id="l02757" name="l02757"></a><span class="lineno"> 2757</span><span class="comment">   *     [ m_channel.async_receive_&lt;pipe&gt;() ]</span></div>
<div class="line"><a id="l02758" name="l02758"></a><span class="lineno"> 2758</span><span class="comment">   *     - If not would-block, then yeah, continue as written above synchronously.</span></div>
<div class="line"><a id="l02759" name="l02759"></a><span class="lineno"> 2759</span><span class="comment">   *     - Otherwise, next step *here* is STOP.  But on completed async-receive resume above algorithm:</span></div>
<div class="line"><a id="l02760" name="l02760"></a><span class="lineno"> 2760</span><span class="comment">   *       - Deal with it (might post handlers via handlers_post() -- might need another message to do so -- etc.):</span></div>
<div class="line"><a id="l02761" name="l02761"></a><span class="lineno"> 2761</span><span class="comment">   *         [ rcv_on_async_read_lead/continuation_msg() ]</span></div>
<div class="line"><a id="l02762" name="l02762"></a><span class="lineno"> 2762</span><span class="comment">   *       - Run the handlers that were handlers_post()ed:</span></div>
<div class="line"><a id="l02763" name="l02763"></a><span class="lineno"> 2763</span><span class="comment">   *         [ handlers_poll() ]</span></div>
<div class="line"><a id="l02764" name="l02764"></a><span class="lineno"> 2764</span><span class="comment">   *        - If it decided STOP, exit algorithm.</span></div>
<div class="line"><a id="l02765" name="l02765"></a><span class="lineno"> 2765</span><span class="comment">   *   - Back to step 1.</span></div>
<div class="line"><a id="l02766" name="l02766"></a><span class="lineno"> 2766</span><span class="comment">   *     [ Call us!  rcv_async_read_lead_or_continuation_msg()! ]</span></div>
<div class="line"><a id="l02767" name="l02767"></a><span class="lineno"> 2767</span><span class="comment">   *</span></div>
<div class="line"><a id="l02768" name="l02768"></a><span class="lineno"> 2768</span><span class="comment">   * Now to do it. */</span></div>
<div class="line"><a id="l02769" name="l02769"></a><span class="lineno"> 2769</span> </div>
<div class="line"><a id="l02770" name="l02770"></a><span class="lineno"> 2770</span>  <span class="comment">// We know the type of the first message.  Then upon processing it we&#39;ll decide the next expected type.</span></div>
<div class="line"><a id="l02771" name="l02771"></a><span class="lineno"> 2771</span>  <span class="keyword">auto</span> next_step = lead_else_cont ? Rcv_next_step::S_READ_LEAD_MSG : Rcv_next_step::S_READ_CONT_MSG;</div>
<div class="line"><a id="l02772" name="l02772"></a><span class="lineno"> 2772</span>  <span class="keywordflow">do</span></div>
<div class="line"><a id="l02773" name="l02773"></a><span class="lineno"> 2773</span>  {</div>
<div class="line"><a id="l02774" name="l02774"></a><span class="lineno"> 2774</span>    <a class="code hl_typedef" href="namespaceipc.html#aa3192e586cc45d3e7c22463bf2760f89">Error_code</a> sync_err_code;</div>
<div class="line"><a id="l02775" name="l02775"></a><span class="lineno"> 2775</span>    <span class="keywordtype">size_t</span> sync_sz;</div>
<div class="line"><a id="l02776" name="l02776"></a><span class="lineno"> 2776</span> </div>
<div class="line"><a id="l02777" name="l02777"></a><span class="lineno"> 2777</span>    <span class="comment">/* These conditions are documented in Msg_in_pipe doc header.  We hereby decide that they are to always be</span></div>
<div class="line"><a id="l02778" name="l02778"></a><span class="lineno"> 2778</span><span class="comment">     * re-upped immediately upon becoming false -- so in the receive handlers: not here.  Initially they&#39;re set</span></div>
<div class="line"><a id="l02779" name="l02779"></a><span class="lineno"> 2779</span><span class="comment">     * this way in start_and_poll(). */</span></div>
<div class="line"><a id="l02780" name="l02780"></a><span class="lineno"> 2780</span>    assert((pipe-&gt;<a class="code hl_variable" href="structipc_1_1transport_1_1struc_1_1sync__io_1_1Channel_1_1Msg__in__pipe.html#af73c6fcead6a866df1524e01b5654222">m_target_blob</a> &amp;&amp; (!pipe-&gt;<a class="code hl_variable" href="structipc_1_1transport_1_1struc_1_1sync__io_1_1Channel_1_1Msg__in__pipe.html#af73c6fcead6a866df1524e01b5654222">m_target_blob</a>-&gt;zero()))</div>
<div class="line"><a id="l02781" name="l02781"></a><span class="lineno"> 2781</span>           &amp;&amp; <span class="stringliteral">&quot;Bug: m_target_blob must always point to the fresh one from add_serialization_segment().&quot;</span>);</div>
<div class="line"><a id="l02782" name="l02782"></a><span class="lineno"> 2782</span>    assert((pipe-&gt;<a class="code hl_variable" href="structipc_1_1transport_1_1struc_1_1sync__io_1_1Channel_1_1Msg__in__pipe.html#af73c6fcead6a866df1524e01b5654222">m_target_blob</a>-&gt;size() == pipe-&gt;<a class="code hl_variable" href="structipc_1_1transport_1_1struc_1_1sync__io_1_1Channel_1_1Msg__in__pipe.html#af73c6fcead6a866df1524e01b5654222">m_target_blob</a>-&gt;capacity())</div>
<div class="line"><a id="l02783" name="l02783"></a><span class="lineno"> 2783</span>           &amp;&amp; <span class="stringliteral">&quot;Bug: m_target_blob must always be sized=capacity upon assignment.&quot;</span>);</div>
<div class="line"><a id="l02784" name="l02784"></a><span class="lineno"> 2784</span>    assert(pipe-&gt;<a class="code hl_variable" href="structipc_1_1transport_1_1struc_1_1sync__io_1_1Channel_1_1Msg__in__pipe.html#ad27cbaa9b01823f31fb2ae47835974df">m_target_hndl</a>.<a class="code hl_function" href="structipc_1_1util_1_1Native__handle.html#a11bd62ce0a7bef4bdfe666201c26d4dc">null</a>()</div>
<div class="line"><a id="l02785" name="l02785"></a><span class="lineno"> 2785</span>           &amp;&amp; <span class="stringliteral">&quot;Bug: m_target_hndl must always be moved-from (become null) immediately upon Native_handle receipt.&quot;</span>);</div>
<div class="line"><a id="l02786" name="l02786"></a><span class="lineno"> 2786</span>    assert(((next_step == Rcv_next_step::S_READ_CONT_MSG)</div>
<div class="line"><a id="l02787" name="l02787"></a><span class="lineno"> 2787</span>            || ((pipe-&gt;<a class="code hl_variable" href="structipc_1_1transport_1_1struc_1_1sync__io_1_1Channel_1_1Msg__in__pipe.html#a1b6834c271148af382c46ef948d1faab">m_n_segs_left_after_this_read</a>) == 0))</div>
<div class="line"><a id="l02788" name="l02788"></a><span class="lineno"> 2788</span>           &amp;&amp; <span class="stringliteral">&quot;Bug: m_n_segs_left_after_this_read must be unknown (zero) before async-reading lead msg.&quot;</span>);</div>
<div class="line"><a id="l02789" name="l02789"></a><span class="lineno"> 2789</span> </div>
<div class="line"><a id="l02790" name="l02790"></a><span class="lineno"> 2790</span>    <span class="comment">// This is the &quot;But on completed async-receive resume above algorithm:&quot; part in the pseudocode above.</span></div>
<div class="line"><a id="l02791" name="l02791"></a><span class="lineno"> 2791</span>    <span class="keyword">auto</span> on_recv_func = [<span class="keyword">this</span>, pipe, next_step]</div>
<div class="line"><a id="l02792" name="l02792"></a><span class="lineno"> 2792</span>                          (<span class="keyword">const</span> <a class="code hl_typedef" href="namespaceipc.html#aa3192e586cc45d3e7c22463bf2760f89">Error_code</a>&amp; err_code, <span class="keywordtype">size_t</span> sz) <span class="keyword">mutable</span></div>
<div class="line"><a id="l02793" name="l02793"></a><span class="lineno"> 2793</span>    {</div>
<div class="line"><a id="l02794" name="l02794"></a><span class="lineno"> 2794</span>      <span class="comment">// &quot;Deal with it.&quot;</span></div>
<div class="line"><a id="l02795" name="l02795"></a><span class="lineno"> 2795</span>      next_step</div>
<div class="line"><a id="l02796" name="l02796"></a><span class="lineno"> 2796</span>        = (next_step == Rcv_next_step::S_READ_LEAD_MSG)</div>
<div class="line"><a id="l02797" name="l02797"></a><span class="lineno"> 2797</span>            ? rcv_on_async_read_lead_msg(pipe, err_code, sz)</div>
<div class="line"><a id="l02798" name="l02798"></a><span class="lineno"> 2798</span>            : rcv_on_async_read_continuation_msg(pipe, err_code, sz);</div>
<div class="line"><a id="l02799" name="l02799"></a><span class="lineno"> 2799</span> </div>
<div class="line"><a id="l02800" name="l02800"></a><span class="lineno"> 2800</span>      <span class="keyword">const</span> <span class="keywordtype">bool</span> stop = next_step == Rcv_next_step::S_STOP;</div>
<div class="line"><a id="l02801" name="l02801"></a><span class="lineno"> 2801</span>      FLOW_LOG_TRACE(<span class="stringliteral">&quot;struc::Channel [&quot;</span> &lt;&lt; *<span class="keyword">this</span> &lt;&lt; <span class="stringliteral">&quot;]: The above on-received-message logic was invoked &quot;</span></div>
<div class="line"><a id="l02802" name="l02802"></a><span class="lineno"> 2802</span>                     <span class="stringliteral">&quot;after an async-wait.  Therefore read chain continues synchronously unless stopping on error &quot;</span></div>
<div class="line"><a id="l02803" name="l02803"></a><span class="lineno"> 2803</span>                     <span class="stringliteral">&quot;(are we? = [&quot;</span> &lt;&lt; stop &lt;&lt; <span class="stringliteral">&quot;]).  Invoking result handlers (if any) now.&quot;</span>);</div>
<div class="line"><a id="l02804" name="l02804"></a><span class="lineno"> 2804</span> </div>
<div class="line"><a id="l02805" name="l02805"></a><span class="lineno"> 2805</span>      <span class="comment">// &quot;Run the handlers.&quot;</span></div>
<div class="line"><a id="l02806" name="l02806"></a><span class="lineno"> 2806</span>      handlers_poll(<span class="stringliteral">&quot;rcv_async_read_lead_or_continuation_msg(1)&quot;</span>); <span class="comment">// !!!</span></div>
<div class="line"><a id="l02807" name="l02807"></a><span class="lineno"> 2807</span> </div>
<div class="line"><a id="l02808" name="l02808"></a><span class="lineno"> 2808</span>      <span class="keywordflow">if</span> (stop)</div>
<div class="line"><a id="l02809" name="l02809"></a><span class="lineno"> 2809</span>      {</div>
<div class="line"><a id="l02810" name="l02810"></a><span class="lineno"> 2810</span>        <span class="comment">// It&#39;s over.  Get out of the loop and function and read chain.</span></div>
<div class="line"><a id="l02811" name="l02811"></a><span class="lineno"> 2811</span>        <span class="keywordflow">return</span>;</div>
<div class="line"><a id="l02812" name="l02812"></a><span class="lineno"> 2812</span>      }</div>
<div class="line"><a id="l02813" name="l02813"></a><span class="lineno"> 2813</span>      <span class="comment">// else</span></div>
<div class="line"><a id="l02814" name="l02814"></a><span class="lineno"> 2814</span> </div>
<div class="line"><a id="l02815" name="l02815"></a><span class="lineno"> 2815</span>      <span class="comment">// &quot;Back to step 1.&quot;</span></div>
<div class="line"><a id="l02816" name="l02816"></a><span class="lineno"> 2816</span>      FLOW_LOG_TRACE(<span class="stringliteral">&quot;struc::Channel [&quot;</span> &lt;&lt; *<span class="keyword">this</span> &lt;&lt; <span class="stringliteral">&quot;]: Performing next async-read.&quot;</span>);</div>
<div class="line"><a id="l02817" name="l02817"></a><span class="lineno"> 2817</span>      (next_step == Rcv_next_step::S_READ_LEAD_MSG)</div>
<div class="line"><a id="l02818" name="l02818"></a><span class="lineno"> 2818</span>        ? rcv_async_read_lead_or_continuation_msg(pipe, <span class="keyword">true</span>)</div>
<div class="line"><a id="l02819" name="l02819"></a><span class="lineno"> 2819</span>        : rcv_async_read_lead_or_continuation_msg(pipe, <span class="keyword">false</span>);</div>
<div class="line"><a id="l02820" name="l02820"></a><span class="lineno"> 2820</span>    }; <span class="comment">// auto on_recv_func =</span></div>
<div class="line"><a id="l02821" name="l02821"></a><span class="lineno"> 2821</span> </div>
<div class="line"><a id="l02822" name="l02822"></a><span class="lineno"> 2822</span>    <span class="comment">// With that in mind, here in sync-land: &quot;Read unstructured message.&quot;</span></div>
<div class="line"><a id="l02823" name="l02823"></a><span class="lineno"> 2823</span> </div>
<div class="line"><a id="l02824" name="l02824"></a><span class="lineno"> 2824</span>    <span class="keywordflow">switch</span> (pipe-&gt;<a class="code hl_variable" href="structipc_1_1transport_1_1struc_1_1sync__io_1_1Channel_1_1Msg__in__pipe.html#a3d239c5a1e29bd6db1ee7c4764616549">m_lead_msg_mode</a>)</div>
<div class="line"><a id="l02825" name="l02825"></a><span class="lineno"> 2825</span>    {</div>
<div class="line"><a id="l02826" name="l02826"></a><span class="lineno"> 2826</span>    <span class="keywordflow">case</span> Msg_in_pipe::S_RCV_WITH_OR_SANS_HNDL_DEMUX:</div>
<div class="line"><a id="l02827" name="l02827"></a><span class="lineno"> 2827</span>    <span class="keywordflow">case</span> Msg_in_pipe::S_RCV_WITH_HNDL_ELSE_ERROR:</div>
<div class="line"><a id="l02828" name="l02828"></a><span class="lineno"> 2828</span>      <span class="keywordflow">if</span> <span class="keyword">constexpr</span>(Owned_channel::S_HAS_NATIVE_HANDLE_PIPE) <span class="comment">// `#if 0` code that wouldn&#39;t compile (and never runs).</span></div>
<div class="line"><a id="l02829" name="l02829"></a><span class="lineno"> 2829</span>      {</div>
<div class="line"><a id="l02830" name="l02830"></a><span class="lineno"> 2830</span>        <span class="keywordflow">if</span> (next_step == Rcv_next_step::S_READ_LEAD_MSG)</div>
<div class="line"><a id="l02831" name="l02831"></a><span class="lineno"> 2831</span>        {</div>
<div class="line"><a id="l02832" name="l02832"></a><span class="lineno"> 2832</span>          FLOW_LOG_TRACE(<span class="stringliteral">&quot;struc::Channel [&quot;</span> &lt;&lt; *<span class="keyword">this</span> &lt;&lt; <span class="stringliteral">&quot;]: Async-read starting for next lead message; &quot;</span></div>
<div class="line"><a id="l02833" name="l02833"></a><span class="lineno"> 2833</span>                         <span class="stringliteral">&quot;with-handle messages accepted only? = &quot;</span></div>
<div class="line"><a id="l02834" name="l02834"></a><span class="lineno"> 2834</span>                         <span class="stringliteral">&quot;[&quot;</span> &lt;&lt; (pipe-&gt;<a class="code hl_variable" href="structipc_1_1transport_1_1struc_1_1sync__io_1_1Channel_1_1Msg__in__pipe.html#a3d239c5a1e29bd6db1ee7c4764616549">m_lead_msg_mode</a> == Msg_in_pipe::S_RCV_WITH_HNDL_ELSE_ERROR) &lt;&lt; <span class="stringliteral">&quot;].&quot;</span>);</div>
<div class="line"><a id="l02835" name="l02835"></a><span class="lineno"> 2835</span>        }</div>
<div class="line"><a id="l02836" name="l02836"></a><span class="lineno"> 2836</span>        <span class="keywordflow">else</span></div>
<div class="line"><a id="l02837" name="l02837"></a><span class="lineno"> 2837</span>        {</div>
<div class="line"><a id="l02838" name="l02838"></a><span class="lineno"> 2838</span>          FLOW_LOG_TRACE(<span class="stringliteral">&quot;struc::Channel [&quot;</span> &lt;&lt; *<span class="keyword">this</span> &lt;&lt; <span class="stringliteral">&quot;]: Async-read starting for continuation message; &quot;</span></div>
<div class="line"><a id="l02839" name="l02839"></a><span class="lineno"> 2839</span>                         <span class="stringliteral">&quot;with-handle *lead* messages accepted only? = &quot;</span></div>
<div class="line"><a id="l02840" name="l02840"></a><span class="lineno"> 2840</span>                         <span class="stringliteral">&quot;[&quot;</span> &lt;&lt; (pipe-&gt;<a class="code hl_variable" href="structipc_1_1transport_1_1struc_1_1sync__io_1_1Channel_1_1Msg__in__pipe.html#a3d239c5a1e29bd6db1ee7c4764616549">m_lead_msg_mode</a> == Msg_in_pipe::S_RCV_WITH_HNDL_ELSE_ERROR) &lt;&lt; <span class="stringliteral">&quot;].&quot;</span>);</div>
<div class="line"><a id="l02841" name="l02841"></a><span class="lineno"> 2841</span>        }</div>
<div class="line"><a id="l02842" name="l02842"></a><span class="lineno"> 2842</span> </div>
<div class="line"><a id="l02843" name="l02843"></a><span class="lineno"> 2843</span><span class="preprocessor">#ifndef NDEBUG</span></div>
<div class="line"><a id="l02844" name="l02844"></a><span class="lineno"> 2844</span>        <span class="keyword">const</span> <span class="keywordtype">bool</span> ok =</div>
<div class="line"><a id="l02845" name="l02845"></a><span class="lineno"> 2845</span><span class="preprocessor">#endif</span></div>
<div class="line"><a id="l02846" name="l02846"></a><span class="lineno"> 2846</span>        m_channel.async_receive_native_handle(&amp;pipe-&gt;<a class="code hl_variable" href="structipc_1_1transport_1_1struc_1_1sync__io_1_1Channel_1_1Msg__in__pipe.html#ad27cbaa9b01823f31fb2ae47835974df">m_target_hndl</a>, pipe-&gt;<a class="code hl_variable" href="structipc_1_1transport_1_1struc_1_1sync__io_1_1Channel_1_1Msg__in__pipe.html#af73c6fcead6a866df1524e01b5654222">m_target_blob</a>-&gt;mutable_buffer(),</div>
<div class="line"><a id="l02847" name="l02847"></a><span class="lineno"> 2847</span>                                              &amp;sync_err_code, &amp;sync_sz,</div>
<div class="line"><a id="l02848" name="l02848"></a><span class="lineno"> 2848</span>                                              std::move(on_recv_func));</div>
<div class="line"><a id="l02849" name="l02849"></a><span class="lineno"> 2849</span>        assert(ok); <span class="comment">// PEER state is an advertised pre-condition for `*this` ctor.</span></div>
<div class="line"><a id="l02850" name="l02850"></a><span class="lineno"> 2850</span>        <span class="keywordflow">break</span>;</div>
<div class="line"><a id="l02851" name="l02851"></a><span class="lineno"> 2851</span>      }</div>
<div class="line"><a id="l02852" name="l02852"></a><span class="lineno"> 2852</span>      <span class="keywordflow">else</span> <span class="comment">// if constexpr()</span></div>
<div class="line"><a id="l02853" name="l02853"></a><span class="lineno"> 2853</span>      {</div>
<div class="line"><a id="l02854" name="l02854"></a><span class="lineno"> 2854</span>        assert(<span class="keyword">false</span> &amp;&amp; <span class="stringliteral">&quot;Should never get here with this type of low-level transports configured.&quot;</span>);</div>
<div class="line"><a id="l02855" name="l02855"></a><span class="lineno"> 2855</span>      }</div>
<div class="line"><a id="l02856" name="l02856"></a><span class="lineno"> 2856</span>    <span class="keywordflow">case</span> Msg_in_pipe::S_RCV_SANS_HNDL_ONLY:</div>
<div class="line"><a id="l02857" name="l02857"></a><span class="lineno"> 2857</span>      <span class="keywordflow">if</span> <span class="keyword">constexpr</span>(Owned_channel::S_HAS_BLOB_PIPE) <span class="comment">// `#if 0` code that wouldn&#39;t compile (and never runs).</span></div>
<div class="line"><a id="l02858" name="l02858"></a><span class="lineno"> 2858</span>      {</div>
<div class="line"><a id="l02859" name="l02859"></a><span class="lineno"> 2859</span>        <span class="keywordflow">if</span> (next_step == Rcv_next_step::S_READ_LEAD_MSG)</div>
<div class="line"><a id="l02860" name="l02860"></a><span class="lineno"> 2860</span>        {</div>
<div class="line"><a id="l02861" name="l02861"></a><span class="lineno"> 2861</span>          FLOW_LOG_TRACE(<span class="stringliteral">&quot;struc::Channel [&quot;</span> &lt;&lt; *<span class="keyword">this</span> &lt;&lt; <span class="stringliteral">&quot;]: Async-read starting for next lead message; &quot;</span></div>
<div class="line"><a id="l02862" name="l02862"></a><span class="lineno"> 2862</span>                         <span class="stringliteral">&quot;sans-handle messages accepted only? = yep.&quot;</span>);</div>
<div class="line"><a id="l02863" name="l02863"></a><span class="lineno"> 2863</span>        }</div>
<div class="line"><a id="l02864" name="l02864"></a><span class="lineno"> 2864</span>        <span class="keywordflow">else</span></div>
<div class="line"><a id="l02865" name="l02865"></a><span class="lineno"> 2865</span>        {</div>
<div class="line"><a id="l02866" name="l02866"></a><span class="lineno"> 2866</span>          FLOW_LOG_TRACE(<span class="stringliteral">&quot;struc::Channel [&quot;</span> &lt;&lt; *<span class="keyword">this</span> &lt;&lt; <span class="stringliteral">&quot;]: Async-read starting for continuation message; &quot;</span></div>
<div class="line"><a id="l02867" name="l02867"></a><span class="lineno"> 2867</span>                         <span class="stringliteral">&quot;sans-handle messages accepted only? = yep.&quot;</span>);</div>
<div class="line"><a id="l02868" name="l02868"></a><span class="lineno"> 2868</span>        }</div>
<div class="line"><a id="l02869" name="l02869"></a><span class="lineno"> 2869</span> </div>
<div class="line"><a id="l02870" name="l02870"></a><span class="lineno"> 2870</span><span class="preprocessor">#ifndef NDEBUG</span></div>
<div class="line"><a id="l02871" name="l02871"></a><span class="lineno"> 2871</span>        <span class="keyword">const</span> <span class="keywordtype">bool</span> ok =</div>
<div class="line"><a id="l02872" name="l02872"></a><span class="lineno"> 2872</span><span class="preprocessor">#endif</span></div>
<div class="line"><a id="l02873" name="l02873"></a><span class="lineno"> 2873</span>        m_channel.async_receive_blob(pipe-&gt;<a class="code hl_variable" href="structipc_1_1transport_1_1struc_1_1sync__io_1_1Channel_1_1Msg__in__pipe.html#af73c6fcead6a866df1524e01b5654222">m_target_blob</a>-&gt;mutable_buffer(), &amp;sync_err_code, &amp;sync_sz,</div>
<div class="line"><a id="l02874" name="l02874"></a><span class="lineno"> 2874</span>                                     std::move(on_recv_func));</div>
<div class="line"><a id="l02875" name="l02875"></a><span class="lineno"> 2875</span>        assert(ok); <span class="comment">// Same as above.</span></div>
<div class="line"><a id="l02876" name="l02876"></a><span class="lineno"> 2876</span>      }</div>
<div class="line"><a id="l02877" name="l02877"></a><span class="lineno"> 2877</span>      <span class="keywordflow">else</span> <span class="comment">// if constexpr()</span></div>
<div class="line"><a id="l02878" name="l02878"></a><span class="lineno"> 2878</span>      {</div>
<div class="line"><a id="l02879" name="l02879"></a><span class="lineno"> 2879</span>        assert(<span class="keyword">false</span> &amp;&amp; <span class="stringliteral">&quot;Should never get here with this type of low-level transports configured.&quot;</span>);</div>
<div class="line"><a id="l02880" name="l02880"></a><span class="lineno"> 2880</span>      }</div>
<div class="line"><a id="l02881" name="l02881"></a><span class="lineno"> 2881</span>    <span class="comment">// default: Compiler should warn.</span></div>
<div class="line"><a id="l02882" name="l02882"></a><span class="lineno"> 2882</span>    } <span class="comment">// switch (m_lead_msg_mode)</span></div>
<div class="line"><a id="l02883" name="l02883"></a><span class="lineno"> 2883</span> </div>
<div class="line"><a id="l02884" name="l02884"></a><span class="lineno"> 2884</span>    <span class="keywordflow">if</span> (sync_err_code == <a class="code hl_enumvalue" href="namespaceipc_1_1transport_1_1error.html#adfef15ef4e76cc55d652fbd9c2797297aa667487757f9d6300f6888bac40bcc24">transport::error::Code::S_SYNC_IO_WOULD_BLOCK</a>)</div>
<div class="line"><a id="l02885" name="l02885"></a><span class="lineno"> 2885</span>    {</div>
<div class="line"><a id="l02886" name="l02886"></a><span class="lineno"> 2886</span>      next_step = Rcv_next_step::S_STOP;</div>
<div class="line"><a id="l02887" name="l02887"></a><span class="lineno"> 2887</span>      <span class="keywordflow">continue</span>; <span class="comment">// Loop will end.  Live to fight another day: async-wait outstanding.</span></div>
<div class="line"><a id="l02888" name="l02888"></a><span class="lineno"> 2888</span>    }</div>
<div class="line"><a id="l02889" name="l02889"></a><span class="lineno"> 2889</span>    <span class="comment">// else: Got a message or error synchronously.  Handle it right here (a-la on_recv_func() which won&#39;t run).</span></div>
<div class="line"><a id="l02890" name="l02890"></a><span class="lineno"> 2890</span> </div>
<div class="line"><a id="l02891" name="l02891"></a><span class="lineno"> 2891</span>    <span class="comment">// &quot;Deal with it.&quot;</span></div>
<div class="line"><a id="l02892" name="l02892"></a><span class="lineno"> 2892</span>    next_step</div>
<div class="line"><a id="l02893" name="l02893"></a><span class="lineno"> 2893</span>      = (next_step == Rcv_next_step::S_READ_LEAD_MSG)</div>
<div class="line"><a id="l02894" name="l02894"></a><span class="lineno"> 2894</span>          ? rcv_on_async_read_lead_msg(pipe, sync_err_code, sync_sz)</div>
<div class="line"><a id="l02895" name="l02895"></a><span class="lineno"> 2895</span>          : rcv_on_async_read_continuation_msg(pipe, sync_err_code, sync_sz);</div>
<div class="line"><a id="l02896" name="l02896"></a><span class="lineno"> 2896</span> </div>
<div class="line"><a id="l02897" name="l02897"></a><span class="lineno"> 2897</span>    FLOW_LOG_TRACE(<span class="stringliteral">&quot;struc::Channel [&quot;</span> &lt;&lt; *<span class="keyword">this</span> &lt;&lt; <span class="stringliteral">&quot;]: The above on-received-message logic was invoked &quot;</span></div>
<div class="line"><a id="l02898" name="l02898"></a><span class="lineno"> 2898</span>                   <span class="stringliteral">&quot;synchronously (message was immediately pending).  Therefore read chain continues &quot;</span></div>
<div class="line"><a id="l02899" name="l02899"></a><span class="lineno"> 2899</span>                   <span class="stringliteral">&quot;synchronously unless stopping on error (are we? = &quot;</span></div>
<div class="line"><a id="l02900" name="l02900"></a><span class="lineno"> 2900</span>                   <span class="stringliteral">&quot;[&quot;</span> &lt;&lt; (next_step == Rcv_next_step::S_STOP) &lt;&lt; <span class="stringliteral">&quot;]).  Invoking result handlers (if any) now.&quot;</span>);</div>
<div class="line"><a id="l02901" name="l02901"></a><span class="lineno"> 2901</span> </div>
<div class="line"><a id="l02902" name="l02902"></a><span class="lineno"> 2902</span>    <span class="comment">// &quot;Run the handlers.&quot;</span></div>
<div class="line"><a id="l02903" name="l02903"></a><span class="lineno"> 2903</span>    handlers_poll(<span class="stringliteral">&quot;rcv_async_read_lead_or_continuation_msg(2)&quot;</span>); <span class="comment">// !!!</span></div>
<div class="line"><a id="l02904" name="l02904"></a><span class="lineno"> 2904</span> </div>
<div class="line"><a id="l02905" name="l02905"></a><span class="lineno"> 2905</span>    <span class="comment">// &quot;Back to step 1 (unless we should stop).&quot;</span></div>
<div class="line"><a id="l02906" name="l02906"></a><span class="lineno"> 2906</span>  }</div>
<div class="line"><a id="l02907" name="l02907"></a><span class="lineno"> 2907</span>  <span class="keywordflow">while</span> (next_step != Rcv_next_step::S_STOP);</div>
<div class="line"><a id="l02908" name="l02908"></a><span class="lineno"> 2908</span>} <span class="comment">// Channel::rcv_async_read_lead_or_continuation_msg()</span></div>
<div class="line"><a id="l02909" name="l02909"></a><span class="lineno"> 2909</span> </div>
<div class="line"><a id="l02910" name="l02910"></a><span class="lineno"> 2910</span><a class="code hl_define" href="ipc__transport__structured_2src_2ipc_2transport_2struc_2sync__io_2channel_8hpp.html#a50e1bb663274c68c760263342ddfdcbc">TEMPLATE_SIO_STRUCT_CHANNEL</a></div>
<div class="line"><a id="l02911" name="l02911"></a><span class="lineno"> 2911</span><span class="keyword">typename</span> CLASS_SIO_STRUCT_CHANNEL::Rcv_next_step</div>
<div class="line"><a id="l02912" name="l02912"></a><span class="lineno"><a class="line" href="classipc_1_1transport_1_1struc_1_1sync__io_1_1Channel.html#af546fc0ab4d0ddca0a857c57decd0620"> 2912</a></span>  CLASS_SIO_STRUCT_CHANNEL::rcv_on_async_read_lead_msg(<a class="code hl_struct" href="structipc_1_1transport_1_1struc_1_1sync__io_1_1Channel_1_1Msg__in__pipe.html">Msg_in_pipe</a>* pipe, <span class="keyword">const</span> <a class="code hl_typedef" href="namespaceipc.html#aa3192e586cc45d3e7c22463bf2760f89">Error_code</a>&amp; err_code, <span class="keywordtype">size_t</span> sz)</div>
<div class="line"><a id="l02913" name="l02913"></a><span class="lineno"> 2913</span>{</div>
<div class="line"><a id="l02914" name="l02914"></a><span class="lineno"> 2914</span>  <span class="keyword">using </span>flow::util::Blob;</div>
<div class="line"><a id="l02915" name="l02915"></a><span class="lineno"> 2915</span>  <span class="keyword">using </span>boost::movelib::make_unique;</div>
<div class="line"><a id="l02916" name="l02916"></a><span class="lineno"> 2916</span> </div>
<div class="line"><a id="l02917" name="l02917"></a><span class="lineno"> 2917</span>  assert(err_code != <a class="code hl_enumvalue" href="namespaceipc_1_1transport_1_1error.html#adfef15ef4e76cc55d652fbd9c2797297afe29343445a7bf167cc186a44bd2c6ed">transport::error::Code::S_OBJECT_SHUTDOWN_ABORTED_COMPLETION_HANDLER</a>); <span class="comment">// sync_io must not do this.</span></div>
<div class="line"><a id="l02918" name="l02918"></a><span class="lineno"> 2918</span>  assert(err_code != boost::asio::error::operation_aborted); <span class="comment">// Or definitely this.</span></div>
<div class="line"><a id="l02919" name="l02919"></a><span class="lineno"> 2919</span> </div>
<div class="line"><a id="l02920" name="l02920"></a><span class="lineno"> 2920</span>  FLOW_LOG_TRACE(<span class="stringliteral">&quot;struc::Channel [&quot;</span> &lt;&lt; *<span class="keyword">this</span> &lt;&lt; <span class="stringliteral">&quot;]: Async-receive handler for would-be lead unstructured &quot;</span></div>
<div class="line"><a id="l02921" name="l02921"></a><span class="lineno"> 2921</span>                 <span class="stringliteral">&quot;in-message invoked; result [&quot;</span> &lt;&lt; err_code &lt;&lt; <span class="stringliteral">&quot;] [&quot;</span> &lt;&lt; err_code.message() &lt;&lt; <span class="stringliteral">&quot;]; size received = &quot;</span></div>
<div class="line"><a id="l02922" name="l02922"></a><span class="lineno"> 2922</span>                 <span class="stringliteral">&quot;[&quot;</span> &lt;&lt; sz &lt;&lt; <span class="stringliteral">&quot;].&quot;</span>);</div>
<div class="line"><a id="l02923" name="l02923"></a><span class="lineno"> 2923</span> </div>
<div class="line"><a id="l02924" name="l02924"></a><span class="lineno"> 2924</span>  <span class="keywordflow">if</span> (handle_async_err_code(err_code, <span class="stringliteral">&quot;rcv_on_async_read_lead_msg()&quot;</span>))</div>
<div class="line"><a id="l02925" name="l02925"></a><span class="lineno"> 2925</span>  {</div>
<div class="line"><a id="l02926" name="l02926"></a><span class="lineno"> 2926</span>    <span class="keywordflow">return</span> Rcv_next_step::S_STOP; <span class="comment">// It&#39;s over, either because of us or an earlier pipe hosing.</span></div>
<div class="line"><a id="l02927" name="l02927"></a><span class="lineno"> 2927</span>  }</div>
<div class="line"><a id="l02928" name="l02928"></a><span class="lineno"> 2928</span>  <span class="comment">// else if (all good (including !err_code)):</span></div>
<div class="line"><a id="l02929" name="l02929"></a><span class="lineno"> 2929</span> </div>
<div class="line"><a id="l02930" name="l02930"></a><span class="lineno"> 2930</span>  <span class="keyword">const</span> <span class="keyword">auto</span> mode = pipe-&gt;<a class="code hl_variable" href="structipc_1_1transport_1_1struc_1_1sync__io_1_1Channel_1_1Msg__in__pipe.html#a3d239c5a1e29bd6db1ee7c4764616549">m_lead_msg_mode</a>;</div>
<div class="line"><a id="l02931" name="l02931"></a><span class="lineno"> 2931</span>  <span class="keyword">const</span> <span class="keywordtype">bool</span> got_hndl = !(pipe-&gt;<a class="code hl_variable" href="structipc_1_1transport_1_1struc_1_1sync__io_1_1Channel_1_1Msg__in__pipe.html#ad27cbaa9b01823f31fb2ae47835974df">m_target_hndl</a>.<a class="code hl_function" href="structipc_1_1util_1_1Native__handle.html#a11bd62ce0a7bef4bdfe666201c26d4dc">null</a>());</div>
<div class="line"><a id="l02932" name="l02932"></a><span class="lineno"> 2932</span>  assert((!((mode == Msg_in_pipe::S_RCV_SANS_HNDL_ONLY) &amp;&amp; got_hndl))</div>
<div class="line"><a id="l02933" name="l02933"></a><span class="lineno"> 2933</span>         &amp;&amp; <span class="stringliteral">&quot;Bug?  Somehow we have truthy target_hndl yet should&#39;ve invoked async_receive_blob() which can&#39;t do that.&quot;</span>);</div>
<div class="line"><a id="l02934" name="l02934"></a><span class="lineno"> 2934</span>  <span class="keywordflow">if</span> ((mode == Msg_in_pipe::S_RCV_WITH_HNDL_ELSE_ERROR) &amp;&amp; (!got_hndl))</div>
<div class="line"><a id="l02935" name="l02935"></a><span class="lineno"> 2935</span>  {</div>
<div class="line"><a id="l02936" name="l02936"></a><span class="lineno"> 2936</span>    <span class="comment">/* This is possible but only due to remote-peer misbehavior (sending us weird stuff/over wrong channel).</span></div>
<div class="line"><a id="l02937" name="l02937"></a><span class="lineno"> 2937</span><span class="comment">     * So it&#39;s not an assert() situation firstly.  What it&#39;s similar-ish to is when, say, a lower-level</span></div>
<div class="line"><a id="l02938" name="l02938"></a><span class="lineno"> 2938</span><span class="comment">     * Native_socket_stream (not that it has to be in Owned_channel -- just using it as an example/foil)</span></div>
<div class="line"><a id="l02939" name="l02939"></a><span class="lineno"> 2939</span><span class="comment">     * was invoked with async_receive_blob() but internally detected a Native_handle arrived too.</span></div>
<div class="line"><a id="l02940" name="l02940"></a><span class="lineno"> 2940</span><span class="comment">     * It&#39;s a protocol misbehavior on the part of the user of the low-level/unstructured Channel.</span></div>
<div class="line"><a id="l02941" name="l02941"></a><span class="lineno"> 2941</span><span class="comment">     * In our case it is also that (we are the user of said Channel); it&#39;s just that Channel cannot detect that</span></div>
<div class="line"><a id="l02942" name="l02942"></a><span class="lineno"> 2942</span><span class="comment">     * for us by itself (it simply lacks the API for &quot;require Native_handle!&quot;).  If it had that capability,</span></div>
<div class="line"><a id="l02943" name="l02943"></a><span class="lineno"> 2943</span><span class="comment">     * it would&#39;ve emitted the err_code stating that (as it does in the analogy scenario:</span></div>
<div class="line"><a id="l02944" name="l02944"></a><span class="lineno"> 2944</span><span class="comment">     * error::Code::S_BLOB_RECEIVER_GOT_NON_BLOB).  So: we&#39;ll do just that ourselves. */</span></div>
<div class="line"><a id="l02945" name="l02945"></a><span class="lineno"> 2945</span>    FLOW_LOG_WARNING(<span class="stringliteral">&quot;struc::Channel [&quot;</span> &lt;&lt; *<span class="keyword">this</span> &lt;&lt; <span class="stringliteral">&quot;]: Async-receive handler for would-be lead unstructured &quot;</span></div>
<div class="line"><a id="l02946" name="l02946"></a><span class="lineno"> 2946</span>                     <span class="stringliteral">&quot;in-message invoked sans low-level error; but received sans-handle low-level message &quot;</span></div>
<div class="line"><a id="l02947" name="l02947"></a><span class="lineno"> 2947</span>                     <span class="stringliteral">&quot;along the handles-only pipe (of 2 pipes).  Other side misbehaved?&quot;</span>);</div>
<div class="line"><a id="l02948" name="l02948"></a><span class="lineno"> 2948</span>    handle_new_error(<a class="code hl_enumvalue" href="namespaceipc_1_1transport_1_1struc_1_1error.html#a990b9ff850cf9aaf354efdd07d86a71dadaf85866b948217cbf039a7b4f89dbd3">error::Code::S_STRUCT_CHANNEL_INTERNAL_PROTOCOL_MISMATCH_GOT_NO_HNDL</a>,</div>
<div class="line"><a id="l02949" name="l02949"></a><span class="lineno"> 2949</span>                     <span class="stringliteral">&quot;rcv_on_async_read_lead_msg()&quot;</span>);</div>
<div class="line"><a id="l02950" name="l02950"></a><span class="lineno"> 2950</span>    <span class="keywordflow">return</span> Rcv_next_step::S_STOP;</div>
<div class="line"><a id="l02951" name="l02951"></a><span class="lineno"> 2951</span>  }</div>
<div class="line"><a id="l02952" name="l02952"></a><span class="lineno"> 2952</span>  <span class="comment">/* else if (still all good): All other combinations of `mode` and got_hndl (etc.) are legal.</span></div>
<div class="line"><a id="l02953" name="l02953"></a><span class="lineno"> 2953</span><span class="comment">   * No need to worry about `mode` now; just handle whatever it is (even if certain possibilities, like</span></div>
<div class="line"><a id="l02954" name="l02954"></a><span class="lineno"> 2954</span><span class="comment">   * got_hndl being true with a certain `mode` are not possible).  That is, `if (&lt;must be false&gt;)` is no biggie. */</span></div>
<div class="line"><a id="l02955" name="l02955"></a><span class="lineno"> 2955</span> </div>
<div class="line"><a id="l02956" name="l02956"></a><span class="lineno"> 2956</span>  <span class="comment">/* Another corner case is a message with an empty blob.  At the transport::Channel (unstructured, low) level it&#39;s</span></div>
<div class="line"><a id="l02957" name="l02957"></a><span class="lineno"> 2957</span><span class="comment">   * allowed.  We (struc::Channel) never use this ability however.  It would be a protocol error on the remote peer&#39;s</span></div>
<div class="line"><a id="l02958" name="l02958"></a><span class="lineno"> 2958</span><span class="comment">   * part. */</span></div>
<div class="line"><a id="l02959" name="l02959"></a><span class="lineno"> 2959</span>  <span class="keywordflow">if</span> (sz == 0)</div>
<div class="line"><a id="l02960" name="l02960"></a><span class="lineno"> 2960</span>  {</div>
<div class="line"><a id="l02961" name="l02961"></a><span class="lineno"> 2961</span>    FLOW_LOG_WARNING(<span class="stringliteral">&quot;struc::Channel [&quot;</span> &lt;&lt; *<span class="keyword">this</span> &lt;&lt; <span class="stringliteral">&quot;]: Async-receive handler for would-be lead unstructured &quot;</span></div>
<div class="line"><a id="l02962" name="l02962"></a><span class="lineno"> 2962</span>                     <span class="stringliteral">&quot;in-message invoked sans low-level error; but got no (meta-)blob at all.  Other side misbehaved?&quot;</span>);</div>
<div class="line"><a id="l02963" name="l02963"></a><span class="lineno"> 2963</span>    handle_new_error(<a class="code hl_enumvalue" href="namespaceipc_1_1transport_1_1struc_1_1error.html#a990b9ff850cf9aaf354efdd07d86a71dae77f8d36304752faf1a967c474457569">error::Code::S_STRUCT_CHANNEL_INTERNAL_PROTOCOL_MISMATCH_GOT_NO_BLOB</a>,</div>
<div class="line"><a id="l02964" name="l02964"></a><span class="lineno"> 2964</span>                     <span class="stringliteral">&quot;rcv_on_async_read_lead_msg()&quot;</span>);</div>
<div class="line"><a id="l02965" name="l02965"></a><span class="lineno"> 2965</span>    <span class="keywordflow">return</span> Rcv_next_step::S_STOP;</div>
<div class="line"><a id="l02966" name="l02966"></a><span class="lineno"> 2966</span>  }</div>
<div class="line"><a id="l02967" name="l02967"></a><span class="lineno"> 2967</span>  <span class="comment">// else</span></div>
<div class="line"><a id="l02968" name="l02968"></a><span class="lineno"> 2968</span> </div>
<div class="line"><a id="l02969" name="l02969"></a><span class="lineno"> 2969</span>  <span class="keyword">auto</span>&amp; target_blob = *pipe-&gt;<a class="code hl_variable" href="structipc_1_1transport_1_1struc_1_1sync__io_1_1Channel_1_1Msg__in__pipe.html#af73c6fcead6a866df1524e01b5654222">m_target_blob</a>;</div>
<div class="line"><a id="l02970" name="l02970"></a><span class="lineno"> 2970</span>  <span class="keyword">auto</span>&amp; target_hndl = pipe-&gt;<a class="code hl_variable" href="structipc_1_1transport_1_1struc_1_1sync__io_1_1Channel_1_1Msg__in__pipe.html#ad27cbaa9b01823f31fb2ae47835974df">m_target_hndl</a>;</div>
<div class="line"><a id="l02971" name="l02971"></a><span class="lineno"> 2971</span>  <span class="keyword">static_assert</span>(std::is_same_v&lt;<span class="keyword">decltype</span>(target_blob), Blob&amp;&gt;, <span class="stringliteral">&quot;m_target_blob must be Blob container.&quot;</span>);</div>
<div class="line"><a id="l02972" name="l02972"></a><span class="lineno"> 2972</span>  <span class="keyword">static_assert</span>(<span class="keyword">sizeof</span>(Blob::value_type) == 1, <span class="stringliteral">&quot;Blob holds bytes, we assume.&quot;</span>);</div>
<div class="line"><a id="l02973" name="l02973"></a><span class="lineno"> 2973</span> </div>
<div class="line"><a id="l02974" name="l02974"></a><span class="lineno"> 2974</span>  <span class="comment">// Ignore garbage after the received bytes (this is permanent).</span></div>
<div class="line"><a id="l02975" name="l02975"></a><span class="lineno"> 2975</span>  target_blob.resize(sz);</div>
<div class="line"><a id="l02976" name="l02976"></a><span class="lineno"> 2976</span> </div>
<div class="line"><a id="l02977" name="l02977"></a><span class="lineno"> 2977</span>  <span class="comment">// OK, target_blob inside m_incomplete_msg is finalized.  Finalize the Native_handle (if any) in m_incomplete_msg.</span></div>
<div class="line"><a id="l02978" name="l02978"></a><span class="lineno"> 2978</span>  pipe-&gt;<a class="code hl_variable" href="structipc_1_1transport_1_1struc_1_1sync__io_1_1Channel_1_1Msg__in__pipe.html#aa02a4835e4bd31cd5f6ea9bbd37eeff4">m_incomplete_msg</a>-&gt;store_native_handle_or_null(std::move(target_hndl));</div>
<div class="line"><a id="l02979" name="l02979"></a><span class="lineno"> 2979</span>  assert(target_hndl.null() &amp;&amp; <span class="stringliteral">&quot;Moving-from Native_handle should have nullified it.&quot;</span>);</div>
<div class="line"><a id="l02980" name="l02980"></a><span class="lineno"> 2980</span> </div>
<div class="line"><a id="l02981" name="l02981"></a><span class="lineno"> 2981</span>  <span class="comment">// target_blob and target_hndl are ready.  Because of the former we can now access:</span></div>
<div class="line"><a id="l02982" name="l02982"></a><span class="lineno"> 2982</span>  {</div>
<div class="line"><a id="l02983" name="l02983"></a><span class="lineno"> 2983</span>    <a class="code hl_typedef" href="namespaceipc.html#aa3192e586cc45d3e7c22463bf2760f89">Error_code</a> err_code;</div>
<div class="line"><a id="l02984" name="l02984"></a><span class="lineno"> 2984</span> </div>
<div class="line"><a id="l02985" name="l02985"></a><span class="lineno"> 2985</span>    pipe-&gt;<a class="code hl_variable" href="structipc_1_1transport_1_1struc_1_1sync__io_1_1Channel_1_1Msg__in__pipe.html#a1b6834c271148af382c46ef948d1faab">m_n_segs_left_after_this_read</a> = pipe-&gt;<a class="code hl_variable" href="structipc_1_1transport_1_1struc_1_1sync__io_1_1Channel_1_1Msg__in__pipe.html#aa02a4835e4bd31cd5f6ea9bbd37eeff4">m_incomplete_msg</a>-&gt;deserialize_mdt(get_logger(), &amp;err_code);</div>
<div class="line"><a id="l02986" name="l02986"></a><span class="lineno"> 2986</span>    <span class="keywordflow">if</span> (err_code) <span class="comment">// It logged on error.</span></div>
<div class="line"><a id="l02987" name="l02987"></a><span class="lineno"> 2987</span>    {</div>
<div class="line"><a id="l02988" name="l02988"></a><span class="lineno"> 2988</span>      handle_new_error(err_code, <span class="stringliteral">&quot;rcv_on_async_read_lead_msg()&quot;</span>);</div>
<div class="line"><a id="l02989" name="l02989"></a><span class="lineno"> 2989</span>      <span class="keywordflow">return</span> Rcv_next_step::S_STOP;</div>
<div class="line"><a id="l02990" name="l02990"></a><span class="lineno"> 2990</span>    }</div>
<div class="line"><a id="l02991" name="l02991"></a><span class="lineno"> 2991</span>    <span class="comment">// else</span></div>
<div class="line"><a id="l02992" name="l02992"></a><span class="lineno"> 2992</span> </div>
<div class="line"><a id="l02993" name="l02993"></a><span class="lineno"> 2993</span>    <span class="comment">// (W/r/t to the pretty-print -- see any comments near the somewhat-mirrored call in send_core().  May apply here.)</span></div>
<div class="line"><a id="l02994" name="l02994"></a><span class="lineno"> 2994</span>    FLOW_LOG_TRACE(<span class="stringliteral">&quot;struc::Channel [&quot;</span> &lt;&lt; *<span class="keyword">this</span> &lt;&lt; <span class="stringliteral">&quot;]: Deserialized (zero-copy) new structured in-message: &quot;</span></div>
<div class="line"><a id="l02995" name="l02995"></a><span class="lineno"> 2995</span>                   <span class="stringliteral">&quot;mandatory metadata portion; further segment count: &quot;</span></div>
<div class="line"><a id="l02996" name="l02996"></a><span class="lineno"> 2996</span>                   <span class="stringliteral">&quot;[&quot;</span> &lt;&lt; pipe-&gt;<a class="code hl_variable" href="structipc_1_1transport_1_1struc_1_1sync__io_1_1Channel_1_1Msg__in__pipe.html#a1b6834c271148af382c46ef948d1faab">m_n_segs_left_after_this_read</a> &lt;&lt; <span class="stringliteral">&quot;]; &quot;</span></div>
<div class="line"><a id="l02997" name="l02997"></a><span class="lineno"> 2997</span>                   <span class="stringliteral">&quot;here is the metadata header: &quot;</span></div>
<div class="line"><a id="l02998" name="l02998"></a><span class="lineno"> 2998</span>                   <span class="stringliteral">&quot;\n&quot;</span> &lt;&lt; ::capnp::prettyPrint(pipe-&gt;<a class="code hl_variable" href="structipc_1_1transport_1_1struc_1_1sync__io_1_1Channel_1_1Msg__in__pipe.html#aa02a4835e4bd31cd5f6ea9bbd37eeff4">m_incomplete_msg</a>-&gt;mdt_root()).flatten().cStr());</div>
<div class="line"><a id="l02999" name="l02999"></a><span class="lineno"> 2999</span>  }</div>
<div class="line"><a id="l03000" name="l03000"></a><span class="lineno"> 3000</span> </div>
<div class="line"><a id="l03001" name="l03001"></a><span class="lineno"> 3001</span>  <span class="comment">// Now to finalize dealing with the in-message.</span></div>
<div class="line"><a id="l03002" name="l03002"></a><span class="lineno"> 3002</span> </div>
<div class="line"><a id="l03003" name="l03003"></a><span class="lineno"> 3003</span>  <span class="keywordflow">if</span> (pipe-&gt;<a class="code hl_variable" href="structipc_1_1transport_1_1struc_1_1sync__io_1_1Channel_1_1Msg__in__pipe.html#a1b6834c271148af382c46ef948d1faab">m_n_segs_left_after_this_read</a> == 0)</div>
<div class="line"><a id="l03004" name="l03004"></a><span class="lineno"> 3004</span>  {</div>
<div class="line"><a id="l03005" name="l03005"></a><span class="lineno"> 3005</span>    <span class="comment">// Sweet: Lead unstructured message encoded entire structured message.</span></div>
<div class="line"><a id="l03006" name="l03006"></a><span class="lineno"> 3006</span>    <span class="keywordflow">if</span> (!rcv_struct_new_msg_in(std::move(pipe-&gt;<a class="code hl_variable" href="structipc_1_1transport_1_1struc_1_1sync__io_1_1Channel_1_1Msg__in__pipe.html#aa02a4835e4bd31cd5f6ea9bbd37eeff4">m_incomplete_msg</a>)))</div>
<div class="line"><a id="l03007" name="l03007"></a><span class="lineno"> 3007</span>    {</div>
<div class="line"><a id="l03008" name="l03008"></a><span class="lineno"> 3008</span>      <span class="comment">// Channel-hosing deserialization error (it logged).</span></div>
<div class="line"><a id="l03009" name="l03009"></a><span class="lineno"> 3009</span>      <span class="keywordflow">return</span> Rcv_next_step::S_STOP;</div>
<div class="line"><a id="l03010" name="l03010"></a><span class="lineno"> 3010</span>    }</div>
<div class="line"><a id="l03011" name="l03011"></a><span class="lineno"> 3011</span>    <span class="comment">// else</span></div>
<div class="line"><a id="l03012" name="l03012"></a><span class="lineno"> 3012</span> </div>
<div class="line"><a id="l03013" name="l03013"></a><span class="lineno"> 3013</span>    <span class="comment">// So get the next one (async)!  Re-init these similarly to start_and_poll().</span></div>
<div class="line"><a id="l03014" name="l03014"></a><span class="lineno"> 3014</span>    pipe-&gt;<a class="code hl_variable" href="structipc_1_1transport_1_1struc_1_1sync__io_1_1Channel_1_1Msg__in__pipe.html#aa02a4835e4bd31cd5f6ea9bbd37eeff4">m_incomplete_msg</a> = make_unique&lt;Msg_in_impl&gt;(m_struct_reader_config);</div>
<div class="line"><a id="l03015" name="l03015"></a><span class="lineno"> 3015</span> </div>
<div class="line"><a id="l03016" name="l03016"></a><span class="lineno"> 3016</span>    pipe-&gt;<a class="code hl_variable" href="structipc_1_1transport_1_1struc_1_1sync__io_1_1Channel_1_1Msg__in__pipe.html#af73c6fcead6a866df1524e01b5654222">m_target_blob</a></div>
<div class="line"><a id="l03017" name="l03017"></a><span class="lineno"> 3017</span>      = pipe-&gt;<a class="code hl_variable" href="structipc_1_1transport_1_1struc_1_1sync__io_1_1Channel_1_1Msg__in__pipe.html#aa02a4835e4bd31cd5f6ea9bbd37eeff4">m_incomplete_msg</a>-&gt;add_serialization_segment(rcv_blob_max_size(pipe-&gt;<a class="code hl_variable" href="structipc_1_1transport_1_1struc_1_1sync__io_1_1Channel_1_1Msg__in__pipe.html#a3d239c5a1e29bd6db1ee7c4764616549">m_lead_msg_mode</a>));</div>
<div class="line"><a id="l03018" name="l03018"></a><span class="lineno"> 3018</span>    <span class="keywordflow">if</span> (!pipe-&gt;<a class="code hl_variable" href="structipc_1_1transport_1_1struc_1_1sync__io_1_1Channel_1_1Msg__in__pipe.html#af73c6fcead6a866df1524e01b5654222">m_target_blob</a>)</div>
<div class="line"><a id="l03019" name="l03019"></a><span class="lineno"> 3019</span>    {</div>
<div class="line"><a id="l03020" name="l03020"></a><span class="lineno"> 3020</span>      FLOW_LOG_WARNING(<span class="stringliteral">&quot;struc::Channel [&quot;</span> &lt;&lt; *<span class="keyword">this</span> &lt;&lt; <span class="stringliteral">&quot;]: Unable to obtain a lead unstructured &quot;</span></div>
<div class="line"><a id="l03021" name="l03021"></a><span class="lineno"> 3021</span>                       <span class="stringliteral">&quot;in-message&#39;s target blob from in-message builder engine (details likely logged above).  &quot;</span></div>
<div class="line"><a id="l03022" name="l03022"></a><span class="lineno"> 3022</span>                       <span class="stringliteral">&quot;Emitting channel-hosing error.&quot;</span>);</div>
<div class="line"><a id="l03023" name="l03023"></a><span class="lineno"> 3023</span>      handle_new_error(<a class="code hl_enumvalue" href="namespaceipc_1_1transport_1_1struc_1_1error.html#a990b9ff850cf9aaf354efdd07d86a71dade89b3f5038a04f02d8f4ae68698a069">error::Code::S_INTERNAL_ERROR_DESERIALIZE_TARGET_ALLOC_FAILED</a>,</div>
<div class="line"><a id="l03024" name="l03024"></a><span class="lineno"> 3024</span>                       <span class="stringliteral">&quot;rcv_on_async_read_lead_msg()&quot;</span>);</div>
<div class="line"><a id="l03025" name="l03025"></a><span class="lineno"> 3025</span>      <span class="keywordflow">return</span> Rcv_next_step::S_STOP;</div>
<div class="line"><a id="l03026" name="l03026"></a><span class="lineno"> 3026</span>    }</div>
<div class="line"><a id="l03027" name="l03027"></a><span class="lineno"> 3027</span>    <span class="comment">// else</span></div>
<div class="line"><a id="l03028" name="l03028"></a><span class="lineno"> 3028</span> </div>
<div class="line"><a id="l03029" name="l03029"></a><span class="lineno"> 3029</span>    <span class="comment">// And now indeed do the read.</span></div>
<div class="line"><a id="l03030" name="l03030"></a><span class="lineno"> 3030</span>    <span class="keywordflow">return</span> Rcv_next_step::S_READ_LEAD_MSG;</div>
<div class="line"><a id="l03031" name="l03031"></a><span class="lineno"> 3031</span>  } <span class="comment">// if (pipe-&gt;m_n_segs_left_after_this_read == 0)</span></div>
<div class="line"><a id="l03032" name="l03032"></a><span class="lineno"> 3032</span>  <span class="comment">// else if (pipe-&gt;m_n_segs_left_after_this_read &gt;= 1):</span></div>
<div class="line"><a id="l03033" name="l03033"></a><span class="lineno"> 3033</span> </div>
<div class="line"><a id="l03034" name="l03034"></a><span class="lineno"> 3034</span>  <span class="comment">// Need more segments to come in.  Keep m_incomplete_msg, as it&#39;s still incomplete.  Get next blob to async-read-to.</span></div>
<div class="line"><a id="l03035" name="l03035"></a><span class="lineno"> 3035</span>  --pipe-&gt;<a class="code hl_variable" href="structipc_1_1transport_1_1struc_1_1sync__io_1_1Channel_1_1Msg__in__pipe.html#a1b6834c271148af382c46ef948d1faab">m_n_segs_left_after_this_read</a>;</div>
<div class="line"><a id="l03036" name="l03036"></a><span class="lineno"> 3036</span> </div>
<div class="line"><a id="l03037" name="l03037"></a><span class="lineno"> 3037</span>  pipe-&gt;<a class="code hl_variable" href="structipc_1_1transport_1_1struc_1_1sync__io_1_1Channel_1_1Msg__in__pipe.html#af73c6fcead6a866df1524e01b5654222">m_target_blob</a></div>
<div class="line"><a id="l03038" name="l03038"></a><span class="lineno"> 3038</span>    = pipe-&gt;<a class="code hl_variable" href="structipc_1_1transport_1_1struc_1_1sync__io_1_1Channel_1_1Msg__in__pipe.html#aa02a4835e4bd31cd5f6ea9bbd37eeff4">m_incomplete_msg</a>-&gt;add_serialization_segment(rcv_blob_max_size(pipe-&gt;<a class="code hl_variable" href="structipc_1_1transport_1_1struc_1_1sync__io_1_1Channel_1_1Msg__in__pipe.html#a3d239c5a1e29bd6db1ee7c4764616549">m_lead_msg_mode</a>));</div>
<div class="line"><a id="l03039" name="l03039"></a><span class="lineno"> 3039</span>  <span class="keywordflow">if</span> (!pipe-&gt;<a class="code hl_variable" href="structipc_1_1transport_1_1struc_1_1sync__io_1_1Channel_1_1Msg__in__pipe.html#af73c6fcead6a866df1524e01b5654222">m_target_blob</a>)</div>
<div class="line"><a id="l03040" name="l03040"></a><span class="lineno"> 3040</span>  {</div>
<div class="line"><a id="l03041" name="l03041"></a><span class="lineno"> 3041</span>    FLOW_LOG_WARNING(<span class="stringliteral">&quot;struc::Channel [&quot;</span> &lt;&lt; *<span class="keyword">this</span> &lt;&lt; <span class="stringliteral">&quot;]: Unable to obtain the 1st continuation unstructured &quot;</span></div>
<div class="line"><a id="l03042" name="l03042"></a><span class="lineno"> 3042</span>                     <span class="stringliteral">&quot;in-message&#39;s target blob from in-message builder engine (details likely logged above).  &quot;</span></div>
<div class="line"><a id="l03043" name="l03043"></a><span class="lineno"> 3043</span>                     <span class="stringliteral">&quot;Emitting channel-hosing error.&quot;</span>);</div>
<div class="line"><a id="l03044" name="l03044"></a><span class="lineno"> 3044</span>    handle_new_error(<a class="code hl_enumvalue" href="namespaceipc_1_1transport_1_1struc_1_1error.html#a990b9ff850cf9aaf354efdd07d86a71dade89b3f5038a04f02d8f4ae68698a069">error::Code::S_INTERNAL_ERROR_DESERIALIZE_TARGET_ALLOC_FAILED</a>,</div>
<div class="line"><a id="l03045" name="l03045"></a><span class="lineno"> 3045</span>                     <span class="stringliteral">&quot;rcv_on_async_read_lead_msg()&quot;</span>);</div>
<div class="line"><a id="l03046" name="l03046"></a><span class="lineno"> 3046</span>    <span class="keywordflow">return</span> Rcv_next_step::S_STOP;</div>
<div class="line"><a id="l03047" name="l03047"></a><span class="lineno"> 3047</span>  }</div>
<div class="line"><a id="l03048" name="l03048"></a><span class="lineno"> 3048</span>  <span class="comment">// else</span></div>
<div class="line"><a id="l03049" name="l03049"></a><span class="lineno"> 3049</span> </div>
<div class="line"><a id="l03050" name="l03050"></a><span class="lineno"> 3050</span>  <span class="comment">// Get the 1st continuation message!</span></div>
<div class="line"><a id="l03051" name="l03051"></a><span class="lineno"> 3051</span>  <span class="keywordflow">return</span> Rcv_next_step::S_READ_CONT_MSG;</div>
<div class="line"><a id="l03052" name="l03052"></a><span class="lineno"> 3052</span>} <span class="comment">// Channel::rcv_on_async_read_lead_msg()</span></div>
<div class="line"><a id="l03053" name="l03053"></a><span class="lineno"> 3053</span> </div>
<div class="line"><a id="l03054" name="l03054"></a><span class="lineno"> 3054</span><a class="code hl_define" href="ipc__transport__structured_2src_2ipc_2transport_2struc_2sync__io_2channel_8hpp.html#a50e1bb663274c68c760263342ddfdcbc">TEMPLATE_SIO_STRUCT_CHANNEL</a></div>
<div class="line"><a id="l03055" name="l03055"></a><span class="lineno"> 3055</span><span class="keyword">typename</span> CLASS_SIO_STRUCT_CHANNEL::Rcv_next_step</div>
<div class="line"><a id="l03056" name="l03056"></a><span class="lineno"><a class="line" href="classipc_1_1transport_1_1struc_1_1sync__io_1_1Channel.html#aa83fd6e35057876e2f5173df53e73371"> 3056</a></span>  CLASS_SIO_STRUCT_CHANNEL::rcv_on_async_read_continuation_msg(<a class="code hl_struct" href="structipc_1_1transport_1_1struc_1_1sync__io_1_1Channel_1_1Msg__in__pipe.html">Msg_in_pipe</a>* pipe,</div>
<div class="line"><a id="l03057" name="l03057"></a><span class="lineno"> 3057</span>                                                               <span class="keyword">const</span> <a class="code hl_typedef" href="namespaceipc.html#aa3192e586cc45d3e7c22463bf2760f89">Error_code</a>&amp; err_code, <span class="keywordtype">size_t</span> sz)</div>
<div class="line"><a id="l03058" name="l03058"></a><span class="lineno"> 3058</span>{</div>
<div class="line"><a id="l03059" name="l03059"></a><span class="lineno"> 3059</span>  <span class="keyword">using </span>flow::util::Blob;</div>
<div class="line"><a id="l03060" name="l03060"></a><span class="lineno"> 3060</span>  <span class="keyword">using </span>boost::movelib::make_unique;</div>
<div class="line"><a id="l03061" name="l03061"></a><span class="lineno"> 3061</span> </div>
<div class="line"><a id="l03062" name="l03062"></a><span class="lineno"> 3062</span>  assert(err_code != <a class="code hl_enumvalue" href="namespaceipc_1_1transport_1_1error.html#adfef15ef4e76cc55d652fbd9c2797297afe29343445a7bf167cc186a44bd2c6ed">transport::error::Code::S_OBJECT_SHUTDOWN_ABORTED_COMPLETION_HANDLER</a>); <span class="comment">// sync_io must not do this.</span></div>
<div class="line"><a id="l03063" name="l03063"></a><span class="lineno"> 3063</span>  assert(err_code != boost::asio::error::operation_aborted); <span class="comment">// Or definitely this.</span></div>
<div class="line"><a id="l03064" name="l03064"></a><span class="lineno"> 3064</span> </div>
<div class="line"><a id="l03065" name="l03065"></a><span class="lineno"> 3065</span>  <span class="comment">// In its initial basics this method is much like rcv_on_async_read_lead_msg().  Consider reading that one first.</span></div>
<div class="line"><a id="l03066" name="l03066"></a><span class="lineno"> 3066</span> </div>
<div class="line"><a id="l03067" name="l03067"></a><span class="lineno"> 3067</span>  FLOW_LOG_TRACE(<span class="stringliteral">&quot;struc::Channel [&quot;</span> &lt;&lt; *<span class="keyword">this</span> &lt;&lt; <span class="stringliteral">&quot;]: Async-receive handler for would-be continuation unstructured &quot;</span></div>
<div class="line"><a id="l03068" name="l03068"></a><span class="lineno"> 3068</span>                 <span class="stringliteral">&quot;in-message invoked; result [&quot;</span> &lt;&lt; err_code &lt;&lt; <span class="stringliteral">&quot;] [&quot;</span> &lt;&lt; err_code.message() &lt;&lt; <span class="stringliteral">&quot;]; size received = &quot;</span></div>
<div class="line"><a id="l03069" name="l03069"></a><span class="lineno"> 3069</span>                 <span class="stringliteral">&quot;[&quot;</span> &lt;&lt; sz &lt;&lt; <span class="stringliteral">&quot;].&quot;</span>);</div>
<div class="line"><a id="l03070" name="l03070"></a><span class="lineno"> 3070</span> </div>
<div class="line"><a id="l03071" name="l03071"></a><span class="lineno"> 3071</span>  <span class="keywordflow">if</span> (handle_async_err_code(err_code, <span class="stringliteral">&quot;rcv_on_async_read_continuation_msg()&quot;</span>))</div>
<div class="line"><a id="l03072" name="l03072"></a><span class="lineno"> 3072</span>  {</div>
<div class="line"><a id="l03073" name="l03073"></a><span class="lineno"> 3073</span>    <span class="keywordflow">return</span> Rcv_next_step::S_STOP; <span class="comment">// It&#39;s over, either because of us or an earlier pipe hosing.</span></div>
<div class="line"><a id="l03074" name="l03074"></a><span class="lineno"> 3074</span>  }</div>
<div class="line"><a id="l03075" name="l03075"></a><span class="lineno"> 3075</span>  <span class="comment">// else if (all good (including !err_code)):</span></div>
<div class="line"><a id="l03076" name="l03076"></a><span class="lineno"> 3076</span> </div>
<div class="line"><a id="l03077" name="l03077"></a><span class="lineno"> 3077</span>  <span class="keyword">const</span> <span class="keywordtype">bool</span> got_hndl = !(pipe-&gt;<a class="code hl_variable" href="structipc_1_1transport_1_1struc_1_1sync__io_1_1Channel_1_1Msg__in__pipe.html#ad27cbaa9b01823f31fb2ae47835974df">m_target_hndl</a>.<a class="code hl_function" href="structipc_1_1util_1_1Native__handle.html#a11bd62ce0a7bef4bdfe666201c26d4dc">null</a>());</div>
<div class="line"><a id="l03078" name="l03078"></a><span class="lineno"> 3078</span>  assert((!((pipe-&gt;<a class="code hl_variable" href="structipc_1_1transport_1_1struc_1_1sync__io_1_1Channel_1_1Msg__in__pipe.html#a3d239c5a1e29bd6db1ee7c4764616549">m_lead_msg_mode</a> == Msg_in_pipe::S_RCV_SANS_HNDL_ONLY) &amp;&amp; got_hndl))</div>
<div class="line"><a id="l03079" name="l03079"></a><span class="lineno"> 3079</span>         &amp;&amp; <span class="stringliteral">&quot;Bug?  Somehow we have truthy target_hndl yet should&#39;ve invoked async_receive_blob() which can&#39;t do that.&quot;</span>);</div>
<div class="line"><a id="l03080" name="l03080"></a><span class="lineno"> 3080</span>  <span class="keywordflow">if</span> (got_hndl)</div>
<div class="line"><a id="l03081" name="l03081"></a><span class="lineno"> 3081</span>  {</div>
<div class="line"><a id="l03082" name="l03082"></a><span class="lineno"> 3082</span>    FLOW_LOG_WARNING(<span class="stringliteral">&quot;struc::Channel [&quot;</span> &lt;&lt; *<span class="keyword">this</span> &lt;&lt; <span class="stringliteral">&quot;]: Async-receive handler for would-be continuation &quot;</span></div>
<div class="line"><a id="l03083" name="l03083"></a><span class="lineno"> 3083</span>                     <span class="stringliteral">&quot;unstructured in-message invoked sans low-level error; but it contains native handle; &quot;</span></div>
<div class="line"><a id="l03084" name="l03084"></a><span class="lineno"> 3084</span>                     <span class="stringliteral">&quot;this is not allowed for continuation messages by definition.  Other side misbehaved?&quot;</span>);</div>
<div class="line"><a id="l03085" name="l03085"></a><span class="lineno"> 3085</span>    handle_new_error(<a class="code hl_enumvalue" href="namespaceipc_1_1transport_1_1struc_1_1error.html#a990b9ff850cf9aaf354efdd07d86a71da64f092d17e34549f74d37f8f03c98954">error::Code::S_STRUCT_CHANNEL_INTERNAL_PROTOCOL_MISMATCH_GOT_HNDL</a>,</div>
<div class="line"><a id="l03086" name="l03086"></a><span class="lineno"> 3086</span>                     <span class="stringliteral">&quot;rcv_on_async_read_continuation_msg()&quot;</span>);</div>
<div class="line"><a id="l03087" name="l03087"></a><span class="lineno"> 3087</span>    <span class="keywordflow">return</span> Rcv_next_step::S_STOP;</div>
<div class="line"><a id="l03088" name="l03088"></a><span class="lineno"> 3088</span>  }</div>
<div class="line"><a id="l03089" name="l03089"></a><span class="lineno"> 3089</span>  <span class="comment">// else</span></div>
<div class="line"><a id="l03090" name="l03090"></a><span class="lineno"> 3090</span> </div>
<div class="line"><a id="l03091" name="l03091"></a><span class="lineno"> 3091</span>  <span class="comment">// Continuation message is just the blob (we&#39;ve now ensured this), and all of it is simply the next segment.</span></div>
<div class="line"><a id="l03092" name="l03092"></a><span class="lineno"> 3092</span> </div>
<div class="line"><a id="l03093" name="l03093"></a><span class="lineno"> 3093</span>  <span class="keywordflow">if</span> (sz == 0)</div>
<div class="line"><a id="l03094" name="l03094"></a><span class="lineno"> 3094</span>  {</div>
<div class="line"><a id="l03095" name="l03095"></a><span class="lineno"> 3095</span>    FLOW_LOG_WARNING(<span class="stringliteral">&quot;struc::Channel [&quot;</span> &lt;&lt; *<span class="keyword">this</span> &lt;&lt; <span class="stringliteral">&quot;]: Async-receive handler for would-be continuation &quot;</span></div>
<div class="line"><a id="l03096" name="l03096"></a><span class="lineno"> 3096</span>                     <span class="stringliteral">&quot;unstructured in-message invoked sans low-level error; but got no (meta-)blob at all.  &quot;</span></div>
<div class="line"><a id="l03097" name="l03097"></a><span class="lineno"> 3097</span>                     <span class="stringliteral">&quot;Other side misbehaved?&quot;</span>);</div>
<div class="line"><a id="l03098" name="l03098"></a><span class="lineno"> 3098</span>    handle_new_error(<a class="code hl_enumvalue" href="namespaceipc_1_1transport_1_1struc_1_1error.html#a990b9ff850cf9aaf354efdd07d86a71dae77f8d36304752faf1a967c474457569">error::Code::S_STRUCT_CHANNEL_INTERNAL_PROTOCOL_MISMATCH_GOT_NO_BLOB</a>,</div>
<div class="line"><a id="l03099" name="l03099"></a><span class="lineno"> 3099</span>                     <span class="stringliteral">&quot;rcv_on_async_read_continuation_msg()&quot;</span>);</div>
<div class="line"><a id="l03100" name="l03100"></a><span class="lineno"> 3100</span>    <span class="keywordflow">return</span> Rcv_next_step::S_STOP;</div>
<div class="line"><a id="l03101" name="l03101"></a><span class="lineno"> 3101</span>  }</div>
<div class="line"><a id="l03102" name="l03102"></a><span class="lineno"> 3102</span>  <span class="comment">// else</span></div>
<div class="line"><a id="l03103" name="l03103"></a><span class="lineno"> 3103</span> </div>
<div class="line"><a id="l03104" name="l03104"></a><span class="lineno"> 3104</span>  <span class="keyword">auto</span>&amp; target_blob = *pipe-&gt;<a class="code hl_variable" href="structipc_1_1transport_1_1struc_1_1sync__io_1_1Channel_1_1Msg__in__pipe.html#af73c6fcead6a866df1524e01b5654222">m_target_blob</a>;</div>
<div class="line"><a id="l03105" name="l03105"></a><span class="lineno"> 3105</span> </div>
<div class="line"><a id="l03106" name="l03106"></a><span class="lineno"> 3106</span>  <span class="comment">// Ignore garbage after the received bytes (this is permanent).</span></div>
<div class="line"><a id="l03107" name="l03107"></a><span class="lineno"> 3107</span>  target_blob.resize(sz);</div>
<div class="line"><a id="l03108" name="l03108"></a><span class="lineno"> 3108</span>  <span class="comment">// OK, target_blob inside m_incomplete_msg is finalized.</span></div>
<div class="line"><a id="l03109" name="l03109"></a><span class="lineno"> 3109</span> </div>
<div class="line"><a id="l03110" name="l03110"></a><span class="lineno"> 3110</span>  <span class="comment">// target_blob and target_hndl are reset.  Now to finalize dealing with the in-message.</span></div>
<div class="line"><a id="l03111" name="l03111"></a><span class="lineno"> 3111</span>  <span class="keywordflow">if</span> (pipe-&gt;<a class="code hl_variable" href="structipc_1_1transport_1_1struc_1_1sync__io_1_1Channel_1_1Msg__in__pipe.html#a1b6834c271148af382c46ef948d1faab">m_n_segs_left_after_this_read</a> == 0)</div>
<div class="line"><a id="l03112" name="l03112"></a><span class="lineno"> 3112</span>  {</div>
<div class="line"><a id="l03113" name="l03113"></a><span class="lineno"> 3113</span>    <span class="comment">// Sweet: This is the last expected continuation message.</span></div>
<div class="line"><a id="l03114" name="l03114"></a><span class="lineno"> 3114</span>    <span class="keywordflow">if</span> (!rcv_struct_new_msg_in(std::move(pipe-&gt;<a class="code hl_variable" href="structipc_1_1transport_1_1struc_1_1sync__io_1_1Channel_1_1Msg__in__pipe.html#aa02a4835e4bd31cd5f6ea9bbd37eeff4">m_incomplete_msg</a>)))</div>
<div class="line"><a id="l03115" name="l03115"></a><span class="lineno"> 3115</span>    {</div>
<div class="line"><a id="l03116" name="l03116"></a><span class="lineno"> 3116</span>      <span class="comment">// Channel-hosing deserialization error (it logged).</span></div>
<div class="line"><a id="l03117" name="l03117"></a><span class="lineno"> 3117</span>      <span class="keywordflow">return</span> Rcv_next_step::S_STOP;</div>
<div class="line"><a id="l03118" name="l03118"></a><span class="lineno"> 3118</span>    }</div>
<div class="line"><a id="l03119" name="l03119"></a><span class="lineno"> 3119</span>    <span class="comment">// else</span></div>
<div class="line"><a id="l03120" name="l03120"></a><span class="lineno"> 3120</span> </div>
<div class="line"><a id="l03121" name="l03121"></a><span class="lineno"> 3121</span>    <span class="comment">// So get the next one (async)!  Re-init these similarly to start_and_poll().</span></div>
<div class="line"><a id="l03122" name="l03122"></a><span class="lineno"> 3122</span>    pipe-&gt;<a class="code hl_variable" href="structipc_1_1transport_1_1struc_1_1sync__io_1_1Channel_1_1Msg__in__pipe.html#aa02a4835e4bd31cd5f6ea9bbd37eeff4">m_incomplete_msg</a> = make_unique&lt;Msg_in_impl&gt;(m_struct_reader_config);</div>
<div class="line"><a id="l03123" name="l03123"></a><span class="lineno"> 3123</span> </div>
<div class="line"><a id="l03124" name="l03124"></a><span class="lineno"> 3124</span>    pipe-&gt;<a class="code hl_variable" href="structipc_1_1transport_1_1struc_1_1sync__io_1_1Channel_1_1Msg__in__pipe.html#af73c6fcead6a866df1524e01b5654222">m_target_blob</a></div>
<div class="line"><a id="l03125" name="l03125"></a><span class="lineno"> 3125</span>      = pipe-&gt;<a class="code hl_variable" href="structipc_1_1transport_1_1struc_1_1sync__io_1_1Channel_1_1Msg__in__pipe.html#aa02a4835e4bd31cd5f6ea9bbd37eeff4">m_incomplete_msg</a>-&gt;add_serialization_segment(rcv_blob_max_size(pipe-&gt;<a class="code hl_variable" href="structipc_1_1transport_1_1struc_1_1sync__io_1_1Channel_1_1Msg__in__pipe.html#a3d239c5a1e29bd6db1ee7c4764616549">m_lead_msg_mode</a>));</div>
<div class="line"><a id="l03126" name="l03126"></a><span class="lineno"> 3126</span>    <span class="keywordflow">if</span> (!pipe-&gt;<a class="code hl_variable" href="structipc_1_1transport_1_1struc_1_1sync__io_1_1Channel_1_1Msg__in__pipe.html#af73c6fcead6a866df1524e01b5654222">m_target_blob</a>)</div>
<div class="line"><a id="l03127" name="l03127"></a><span class="lineno"> 3127</span>    {</div>
<div class="line"><a id="l03128" name="l03128"></a><span class="lineno"> 3128</span>      FLOW_LOG_WARNING(<span class="stringliteral">&quot;struc::Channel [&quot;</span> &lt;&lt; *<span class="keyword">this</span> &lt;&lt; <span class="stringliteral">&quot;]: Unable to obtain a lead unstructured &quot;</span></div>
<div class="line"><a id="l03129" name="l03129"></a><span class="lineno"> 3129</span>                       <span class="stringliteral">&quot;in-message&#39;s target blob from in-message builder engine (details likely logged above).  &quot;</span></div>
<div class="line"><a id="l03130" name="l03130"></a><span class="lineno"> 3130</span>                       <span class="stringliteral">&quot;Emitting channel-hosing error.&quot;</span>);</div>
<div class="line"><a id="l03131" name="l03131"></a><span class="lineno"> 3131</span>      handle_new_error(<a class="code hl_enumvalue" href="namespaceipc_1_1transport_1_1struc_1_1error.html#a990b9ff850cf9aaf354efdd07d86a71dade89b3f5038a04f02d8f4ae68698a069">error::Code::S_INTERNAL_ERROR_DESERIALIZE_TARGET_ALLOC_FAILED</a>,</div>
<div class="line"><a id="l03132" name="l03132"></a><span class="lineno"> 3132</span>                       <span class="stringliteral">&quot;rcv_on_async_read_continuation_msg()&quot;</span>);</div>
<div class="line"><a id="l03133" name="l03133"></a><span class="lineno"> 3133</span>      <span class="keywordflow">return</span> Rcv_next_step::S_STOP;</div>
<div class="line"><a id="l03134" name="l03134"></a><span class="lineno"> 3134</span>    }</div>
<div class="line"><a id="l03135" name="l03135"></a><span class="lineno"> 3135</span>    <span class="comment">// else</span></div>
<div class="line"><a id="l03136" name="l03136"></a><span class="lineno"> 3136</span> </div>
<div class="line"><a id="l03137" name="l03137"></a><span class="lineno"> 3137</span>    <span class="comment">// And now indeed do the read.</span></div>
<div class="line"><a id="l03138" name="l03138"></a><span class="lineno"> 3138</span>    <span class="keywordflow">return</span> Rcv_next_step::S_READ_LEAD_MSG;</div>
<div class="line"><a id="l03139" name="l03139"></a><span class="lineno"> 3139</span>  } <span class="comment">// if (pipe-&gt;m_n_segs_left_after_this_read == 0)</span></div>
<div class="line"><a id="l03140" name="l03140"></a><span class="lineno"> 3140</span>  <span class="comment">// else if (pipe-&gt;m_n_segs_left_after_this_read &gt;= 1):</span></div>
<div class="line"><a id="l03141" name="l03141"></a><span class="lineno"> 3141</span> </div>
<div class="line"><a id="l03142" name="l03142"></a><span class="lineno"> 3142</span>  <span class="comment">// Need more segments to come in.  Keep m_incomplete_msg, as it&#39;s still incomplete.  Get next blob to async-read-to.</span></div>
<div class="line"><a id="l03143" name="l03143"></a><span class="lineno"> 3143</span>  --pipe-&gt;<a class="code hl_variable" href="structipc_1_1transport_1_1struc_1_1sync__io_1_1Channel_1_1Msg__in__pipe.html#a1b6834c271148af382c46ef948d1faab">m_n_segs_left_after_this_read</a>;</div>
<div class="line"><a id="l03144" name="l03144"></a><span class="lineno"> 3144</span> </div>
<div class="line"><a id="l03145" name="l03145"></a><span class="lineno"> 3145</span>  pipe-&gt;<a class="code hl_variable" href="structipc_1_1transport_1_1struc_1_1sync__io_1_1Channel_1_1Msg__in__pipe.html#af73c6fcead6a866df1524e01b5654222">m_target_blob</a></div>
<div class="line"><a id="l03146" name="l03146"></a><span class="lineno"> 3146</span>    = pipe-&gt;<a class="code hl_variable" href="structipc_1_1transport_1_1struc_1_1sync__io_1_1Channel_1_1Msg__in__pipe.html#aa02a4835e4bd31cd5f6ea9bbd37eeff4">m_incomplete_msg</a>-&gt;add_serialization_segment(rcv_blob_max_size(pipe-&gt;<a class="code hl_variable" href="structipc_1_1transport_1_1struc_1_1sync__io_1_1Channel_1_1Msg__in__pipe.html#a3d239c5a1e29bd6db1ee7c4764616549">m_lead_msg_mode</a>));</div>
<div class="line"><a id="l03147" name="l03147"></a><span class="lineno"> 3147</span>  <span class="keywordflow">if</span> (!pipe-&gt;<a class="code hl_variable" href="structipc_1_1transport_1_1struc_1_1sync__io_1_1Channel_1_1Msg__in__pipe.html#af73c6fcead6a866df1524e01b5654222">m_target_blob</a>)</div>
<div class="line"><a id="l03148" name="l03148"></a><span class="lineno"> 3148</span>  {</div>
<div class="line"><a id="l03149" name="l03149"></a><span class="lineno"> 3149</span>    FLOW_LOG_WARNING(<span class="stringliteral">&quot;struc::Channel [&quot;</span> &lt;&lt; *<span class="keyword">this</span> &lt;&lt; <span class="stringliteral">&quot;]: Unable to obtain the 2nd/3rd/... continuation unstructured &quot;</span></div>
<div class="line"><a id="l03150" name="l03150"></a><span class="lineno"> 3150</span>                     <span class="stringliteral">&quot;in-message&#39;s target blob from in-message builder engine (details likely logged above).  &quot;</span></div>
<div class="line"><a id="l03151" name="l03151"></a><span class="lineno"> 3151</span>                     <span class="stringliteral">&quot;Emitting channel-hosing error.&quot;</span>);</div>
<div class="line"><a id="l03152" name="l03152"></a><span class="lineno"> 3152</span>    handle_new_error(<a class="code hl_enumvalue" href="namespaceipc_1_1transport_1_1struc_1_1error.html#a990b9ff850cf9aaf354efdd07d86a71dade89b3f5038a04f02d8f4ae68698a069">error::Code::S_INTERNAL_ERROR_DESERIALIZE_TARGET_ALLOC_FAILED</a>,</div>
<div class="line"><a id="l03153" name="l03153"></a><span class="lineno"> 3153</span>                     <span class="stringliteral">&quot;rcv_on_async_read_continuation_msg()&quot;</span>);</div>
<div class="line"><a id="l03154" name="l03154"></a><span class="lineno"> 3154</span>    <span class="keywordflow">return</span> Rcv_next_step::S_STOP;</div>
<div class="line"><a id="l03155" name="l03155"></a><span class="lineno"> 3155</span>  }</div>
<div class="line"><a id="l03156" name="l03156"></a><span class="lineno"> 3156</span>  <span class="comment">// else</span></div>
<div class="line"><a id="l03157" name="l03157"></a><span class="lineno"> 3157</span> </div>
<div class="line"><a id="l03158" name="l03158"></a><span class="lineno"> 3158</span>  <span class="comment">// Get the next continuation message!</span></div>
<div class="line"><a id="l03159" name="l03159"></a><span class="lineno"> 3159</span>  <span class="keywordflow">return</span> Rcv_next_step::S_READ_CONT_MSG;</div>
<div class="line"><a id="l03160" name="l03160"></a><span class="lineno"> 3160</span>} <span class="comment">// Channel::rcv_on_async_read_continuation_msg()</span></div>
<div class="line"><a id="l03161" name="l03161"></a><span class="lineno"> 3161</span> </div>
<div class="line"><a id="l03162" name="l03162"></a><span class="lineno"> 3162</span><a class="code hl_define" href="ipc__transport__structured_2src_2ipc_2transport_2struc_2sync__io_2channel_8hpp.html#a50e1bb663274c68c760263342ddfdcbc">TEMPLATE_SIO_STRUCT_CHANNEL</a></div>
<div class="line"><a id="l03163" name="l03163"></a><span class="lineno"><a class="line" href="classipc_1_1transport_1_1struc_1_1sync__io_1_1Channel.html#a50fb95469fcf9d5aadfb37c7117b8abb"> 3163</a></span><span class="keywordtype">void</span> CLASS_SIO_STRUCT_CHANNEL::rcv_async_read_proto_neg_msg(<a class="code hl_struct" href="structipc_1_1transport_1_1struc_1_1sync__io_1_1Channel_1_1Msg__in__pipe.html">Msg_in_pipe</a>* pipe)</div>
<div class="line"><a id="l03164" name="l03164"></a><span class="lineno"> 3164</span>{</div>
<div class="line"><a id="l03165" name="l03165"></a><span class="lineno"> 3165</span>  <span class="comment">/* The code here is reasonably easy to follow.  We want to read exactly 1 protocol-negotiation message</span></div>
<div class="line"><a id="l03166" name="l03166"></a><span class="lineno"> 3166</span><span class="comment">   * (see &quot;Protocol negotiation&quot; in class doc header), verify it, and then rcv_async_read_lead_or_continuation_msg(pipe)</span></div>
<div class="line"><a id="l03167" name="l03167"></a><span class="lineno"> 3167</span><span class="comment">   * which does the real work along this pipe, async-reading the first real message (etc.).  If this fails</span></div>
<div class="line"><a id="l03168" name="l03168"></a><span class="lineno"> 3168</span><span class="comment">   * (a read fails, or protocol negotiation fails), then stop the read chain and report error via handlers_poll().</span></div>
<div class="line"><a id="l03169" name="l03169"></a><span class="lineno"> 3169</span><span class="comment">   *</span></div>
<div class="line"><a id="l03170" name="l03170"></a><span class="lineno"> 3170</span><span class="comment">   * That said, it may be interesting to note that this is a much simpler/cut-down version of</span></div>
<div class="line"><a id="l03171" name="l03171"></a><span class="lineno"> 3171</span><span class="comment">   * rcv_async_read_lead_or_continuation_msg(); the main source of simplicity is we want up-to-1-message-or-error;</span></div>
<div class="line"><a id="l03172" name="l03172"></a><span class="lineno"> 3172</span><span class="comment">   * whereas they have an endless loop (conceptually speaking).  Nevertheless, modulo those differences, this code</span></div>
<div class="line"><a id="l03173" name="l03173"></a><span class="lineno"> 3173</span><span class="comment">   * is based on that code. */</span></div>
<div class="line"><a id="l03174" name="l03174"></a><span class="lineno"> 3174</span> </div>
<div class="line"><a id="l03175" name="l03175"></a><span class="lineno"> 3175</span>  <a class="code hl_typedef" href="namespaceipc.html#aa3192e586cc45d3e7c22463bf2760f89">Error_code</a> sync_err_code;</div>
<div class="line"><a id="l03176" name="l03176"></a><span class="lineno"> 3176</span>  <span class="keywordtype">size_t</span> sync_sz;</div>
<div class="line"><a id="l03177" name="l03177"></a><span class="lineno"> 3177</span> </div>
<div class="line"><a id="l03178" name="l03178"></a><span class="lineno"> 3178</span>  <span class="comment">// What happens if (and only if) our synchronous/non-blocking async_receive_*() yields message/error, not would-block.</span></div>
<div class="line"><a id="l03179" name="l03179"></a><span class="lineno"> 3179</span>  <span class="keyword">auto</span> on_recv_func = [<span class="keyword">this</span>, pipe](<span class="keyword">const</span> <a class="code hl_typedef" href="namespaceipc.html#aa3192e586cc45d3e7c22463bf2760f89">Error_code</a>&amp; err_code, <span class="keywordtype">size_t</span> sz) <span class="keyword">mutable</span></div>
<div class="line"><a id="l03180" name="l03180"></a><span class="lineno"> 3180</span>  {</div>
<div class="line"><a id="l03181" name="l03181"></a><span class="lineno"> 3181</span>    rcv_on_async_read_proto_neg_msg(pipe, err_code, sz);</div>
<div class="line"><a id="l03182" name="l03182"></a><span class="lineno"> 3182</span>  };</div>
<div class="line"><a id="l03183" name="l03183"></a><span class="lineno"> 3183</span> </div>
<div class="line"><a id="l03184" name="l03184"></a><span class="lineno"> 3184</span>  <span class="comment">// With that in mind, here in sync-land: Read unstructured message.</span></div>
<div class="line"><a id="l03185" name="l03185"></a><span class="lineno"> 3185</span> </div>
<div class="line"><a id="l03186" name="l03186"></a><span class="lineno"> 3186</span>  <span class="keywordflow">switch</span> (pipe-&gt;<a class="code hl_variable" href="structipc_1_1transport_1_1struc_1_1sync__io_1_1Channel_1_1Msg__in__pipe.html#a3d239c5a1e29bd6db1ee7c4764616549">m_lead_msg_mode</a>)</div>
<div class="line"><a id="l03187" name="l03187"></a><span class="lineno"> 3187</span>  {</div>
<div class="line"><a id="l03188" name="l03188"></a><span class="lineno"> 3188</span>  <span class="keywordflow">case</span> Msg_in_pipe::S_RCV_WITH_OR_SANS_HNDL_DEMUX:</div>
<div class="line"><a id="l03189" name="l03189"></a><span class="lineno"> 3189</span>  <span class="keywordflow">case</span> Msg_in_pipe::S_RCV_WITH_HNDL_ELSE_ERROR:</div>
<div class="line"><a id="l03190" name="l03190"></a><span class="lineno"> 3190</span>    <span class="keywordflow">if</span> <span class="keyword">constexpr</span>(Owned_channel::S_HAS_NATIVE_HANDLE_PIPE) <span class="comment">// `#if 0` code that wouldn&#39;t compile (and never runs).</span></div>
<div class="line"><a id="l03191" name="l03191"></a><span class="lineno"> 3191</span>    {</div>
<div class="line"><a id="l03192" name="l03192"></a><span class="lineno"> 3192</span>      FLOW_LOG_TRACE(<span class="stringliteral">&quot;struc::Channel [&quot;</span> &lt;&lt; *<span class="keyword">this</span> &lt;&lt; <span class="stringliteral">&quot;]: Async-read starting for protocol-negotiation message &quot;</span></div>
<div class="line"><a id="l03193" name="l03193"></a><span class="lineno"> 3193</span>                     <span class="stringliteral">&quot;along blobs-and-handles pipe.&quot;</span>);</div>
<div class="line"><a id="l03194" name="l03194"></a><span class="lineno"> 3194</span><span class="preprocessor">#ifndef NDEBUG</span></div>
<div class="line"><a id="l03195" name="l03195"></a><span class="lineno"> 3195</span>      <span class="keyword">const</span> <span class="keywordtype">bool</span> ok =</div>
<div class="line"><a id="l03196" name="l03196"></a><span class="lineno"> 3196</span><span class="preprocessor">#endif</span></div>
<div class="line"><a id="l03197" name="l03197"></a><span class="lineno"> 3197</span>      m_channel.async_receive_native_handle(&amp;pipe-&gt;<a class="code hl_variable" href="structipc_1_1transport_1_1struc_1_1sync__io_1_1Channel_1_1Msg__in__pipe.html#a83b9a3a7ddee7b6bfe14724bfccfc6ba">m_proto_neg_hndl</a>, pipe-&gt;<a class="code hl_variable" href="structipc_1_1transport_1_1struc_1_1sync__io_1_1Channel_1_1Msg__in__pipe.html#a56c1f9cdcfd2a145114ab080199eb704">m_proto_neg_blob</a>-&gt;mutable_buffer(),</div>
<div class="line"><a id="l03198" name="l03198"></a><span class="lineno"> 3198</span>                                            &amp;sync_err_code, &amp;sync_sz,</div>
<div class="line"><a id="l03199" name="l03199"></a><span class="lineno"> 3199</span>                                            std::move(on_recv_func));</div>
<div class="line"><a id="l03200" name="l03200"></a><span class="lineno"> 3200</span>      assert(ok); <span class="comment">// PEER state is an advertised pre-condition for `*this` ctor.</span></div>
<div class="line"><a id="l03201" name="l03201"></a><span class="lineno"> 3201</span>      <span class="keywordflow">break</span>;</div>
<div class="line"><a id="l03202" name="l03202"></a><span class="lineno"> 3202</span>    }</div>
<div class="line"><a id="l03203" name="l03203"></a><span class="lineno"> 3203</span>    <span class="keywordflow">else</span> <span class="comment">// if constexpr()</span></div>
<div class="line"><a id="l03204" name="l03204"></a><span class="lineno"> 3204</span>    {</div>
<div class="line"><a id="l03205" name="l03205"></a><span class="lineno"> 3205</span>      assert(<span class="keyword">false</span> &amp;&amp; <span class="stringliteral">&quot;Should never get here with this type of low-level transports configured.&quot;</span>);</div>
<div class="line"><a id="l03206" name="l03206"></a><span class="lineno"> 3206</span>    }</div>
<div class="line"><a id="l03207" name="l03207"></a><span class="lineno"> 3207</span>  <span class="keywordflow">case</span> Msg_in_pipe::S_RCV_SANS_HNDL_ONLY:</div>
<div class="line"><a id="l03208" name="l03208"></a><span class="lineno"> 3208</span>    <span class="keywordflow">if</span> <span class="keyword">constexpr</span>(Owned_channel::S_HAS_BLOB_PIPE) <span class="comment">// `#if 0` code that wouldn&#39;t compile (and never runs).</span></div>
<div class="line"><a id="l03209" name="l03209"></a><span class="lineno"> 3209</span>    {</div>
<div class="line"><a id="l03210" name="l03210"></a><span class="lineno"> 3210</span>      FLOW_LOG_TRACE(<span class="stringliteral">&quot;struc::Channel [&quot;</span> &lt;&lt; *<span class="keyword">this</span> &lt;&lt; <span class="stringliteral">&quot;]: Async-read starting for protocol-negotiation message &quot;</span></div>
<div class="line"><a id="l03211" name="l03211"></a><span class="lineno"> 3211</span>                     <span class="stringliteral">&quot;along blobs-only pipe.&quot;</span>);</div>
<div class="line"><a id="l03212" name="l03212"></a><span class="lineno"> 3212</span><span class="preprocessor">#ifndef NDEBUG</span></div>
<div class="line"><a id="l03213" name="l03213"></a><span class="lineno"> 3213</span>      <span class="keyword">const</span> <span class="keywordtype">bool</span> ok =</div>
<div class="line"><a id="l03214" name="l03214"></a><span class="lineno"> 3214</span><span class="preprocessor">#endif</span></div>
<div class="line"><a id="l03215" name="l03215"></a><span class="lineno"> 3215</span>      m_channel.async_receive_blob(pipe-&gt;<a class="code hl_variable" href="structipc_1_1transport_1_1struc_1_1sync__io_1_1Channel_1_1Msg__in__pipe.html#a56c1f9cdcfd2a145114ab080199eb704">m_proto_neg_blob</a>-&gt;mutable_buffer(), &amp;sync_err_code, &amp;sync_sz,</div>
<div class="line"><a id="l03216" name="l03216"></a><span class="lineno"> 3216</span>                                   std::move(on_recv_func));</div>
<div class="line"><a id="l03217" name="l03217"></a><span class="lineno"> 3217</span>      assert(ok); <span class="comment">// Same as above.</span></div>
<div class="line"><a id="l03218" name="l03218"></a><span class="lineno"> 3218</span>    }</div>
<div class="line"><a id="l03219" name="l03219"></a><span class="lineno"> 3219</span>    <span class="keywordflow">else</span> <span class="comment">// if constexpr()</span></div>
<div class="line"><a id="l03220" name="l03220"></a><span class="lineno"> 3220</span>    {</div>
<div class="line"><a id="l03221" name="l03221"></a><span class="lineno"> 3221</span>      assert(<span class="keyword">false</span> &amp;&amp; <span class="stringliteral">&quot;Should never get here with this type of low-level transports configured.&quot;</span>);</div>
<div class="line"><a id="l03222" name="l03222"></a><span class="lineno"> 3222</span>    }</div>
<div class="line"><a id="l03223" name="l03223"></a><span class="lineno"> 3223</span>  <span class="comment">// default: Compiler should warn.</span></div>
<div class="line"><a id="l03224" name="l03224"></a><span class="lineno"> 3224</span>  } <span class="comment">// switch (m_lead_msg_mode)</span></div>
<div class="line"><a id="l03225" name="l03225"></a><span class="lineno"> 3225</span> </div>
<div class="line"><a id="l03226" name="l03226"></a><span class="lineno"> 3226</span>  <span class="keywordflow">if</span> (sync_err_code == <a class="code hl_enumvalue" href="namespaceipc_1_1transport_1_1error.html#adfef15ef4e76cc55d652fbd9c2797297aa667487757f9d6300f6888bac40bcc24">transport::error::Code::S_SYNC_IO_WOULD_BLOCK</a>)</div>
<div class="line"><a id="l03227" name="l03227"></a><span class="lineno"> 3227</span>  {</div>
<div class="line"><a id="l03228" name="l03228"></a><span class="lineno"> 3228</span>    <span class="keywordflow">return</span>; <span class="comment">// Live to fight another day: async-wait outstanding.</span></div>
<div class="line"><a id="l03229" name="l03229"></a><span class="lineno"> 3229</span>  }</div>
<div class="line"><a id="l03230" name="l03230"></a><span class="lineno"> 3230</span>  <span class="comment">// else: Got a message or error synchronously.  Handle it right here (a-la on_recv_func() which won&#39;t run).</span></div>
<div class="line"><a id="l03231" name="l03231"></a><span class="lineno"> 3231</span> </div>
<div class="line"><a id="l03232" name="l03232"></a><span class="lineno"> 3232</span>  rcv_on_async_read_proto_neg_msg(pipe, sync_err_code, sync_sz);</div>
<div class="line"><a id="l03233" name="l03233"></a><span class="lineno"> 3233</span>} <span class="comment">// Channel::rcv_async_read_proto_neg_msg()</span></div>
<div class="line"><a id="l03234" name="l03234"></a><span class="lineno"> 3234</span> </div>
<div class="line"><a id="l03235" name="l03235"></a><span class="lineno"> 3235</span><a class="code hl_define" href="ipc__transport__structured_2src_2ipc_2transport_2struc_2sync__io_2channel_8hpp.html#a50e1bb663274c68c760263342ddfdcbc">TEMPLATE_SIO_STRUCT_CHANNEL</a></div>
<div class="line"><a id="l03236" name="l03236"></a><span class="lineno"><a class="line" href="classipc_1_1transport_1_1struc_1_1sync__io_1_1Channel.html#a05207484f4183cafebfe2c0681bd3332"> 3236</a></span><span class="keywordtype">void</span> CLASS_SIO_STRUCT_CHANNEL::rcv_on_async_read_proto_neg_msg(<a class="code hl_struct" href="structipc_1_1transport_1_1struc_1_1sync__io_1_1Channel_1_1Msg__in__pipe.html">Msg_in_pipe</a>* pipe, <a class="code hl_typedef" href="namespaceipc.html#aa3192e586cc45d3e7c22463bf2760f89">Error_code</a> err_code, <span class="keywordtype">size_t</span> sz)</div>
<div class="line"><a id="l03237" name="l03237"></a><span class="lineno"> 3237</span>{</div>
<div class="line"><a id="l03238" name="l03238"></a><span class="lineno"> 3238</span>  <span class="keyword">using </span>flow::util::Blob;</div>
<div class="line"><a id="l03239" name="l03239"></a><span class="lineno"> 3239</span> </div>
<div class="line"><a id="l03240" name="l03240"></a><span class="lineno"> 3240</span>  <span class="keywordflow">if</span> (handle_async_err_code(err_code, <span class="stringliteral">&quot;rcv_on_async_read_proto_neg_msg()&quot;</span>))</div>
<div class="line"><a id="l03241" name="l03241"></a><span class="lineno"> 3241</span>  {</div>
<div class="line"><a id="l03242" name="l03242"></a><span class="lineno"> 3242</span>    handlers_poll(<span class="stringliteral">&quot;rcv_on_async_read_proto_neg_msg(1)&quot;</span>); <span class="comment">// !!!</span></div>
<div class="line"><a id="l03243" name="l03243"></a><span class="lineno"> 3243</span>    pipe-&gt;<a class="code hl_variable" href="structipc_1_1transport_1_1struc_1_1sync__io_1_1Channel_1_1Msg__in__pipe.html#a58b72930ddbf7e45936f8c8f34105324">m_proto_neg_reader_in</a>.reset(); <span class="comment">// Might as well free the memory.</span></div>
<div class="line"><a id="l03244" name="l03244"></a><span class="lineno"> 3244</span> </div>
<div class="line"><a id="l03245" name="l03245"></a><span class="lineno"> 3245</span>    <span class="keywordflow">return</span>; <span class="comment">// It&#39;s over, either because of us or an earlier pipe hosing.</span></div>
<div class="line"><a id="l03246" name="l03246"></a><span class="lineno"> 3246</span>  }</div>
<div class="line"><a id="l03247" name="l03247"></a><span class="lineno"> 3247</span>  <span class="comment">// else if (all good (including !err_code)):</span></div>
<div class="line"><a id="l03248" name="l03248"></a><span class="lineno"> 3248</span> </div>
<div class="line"><a id="l03249" name="l03249"></a><span class="lineno"> 3249</span>  <span class="keywordflow">if</span> (m_protocol_negotiator.negotiated_proto_ver() != <a class="code hl_variable" href="classipc_1_1transport_1_1Protocol__negotiator.html#aa7e47f4f6a700aeaa9600a5426a17292">Protocol_negotiator::S_VER_UNKNOWN</a>)</div>
<div class="line"><a id="l03250" name="l03250"></a><span class="lineno"> 3250</span>  {</div>
<div class="line"><a id="l03251" name="l03251"></a><span class="lineno"> 3251</span>    FLOW_LOG_TRACE(<span class="stringliteral">&quot;struc::Channel [&quot;</span> &lt;&lt; *<span class="keyword">this</span> &lt;&lt; <span class="stringliteral">&quot;]: Async-receive handler for would-be protocol-negotiation &quot;</span></div>
<div class="line"><a id="l03252" name="l03252"></a><span class="lineno"> 3252</span>                   <span class="stringliteral">&quot;in-message invoked; size received = [&quot;</span> &lt;&lt; sz &lt;&lt; <span class="stringliteral">&quot;].  However, the &quot;</span></div>
<div class="line"><a id="l03253" name="l03253"></a><span class="lineno"> 3253</span>                   <span class="stringliteral">&quot;negotiation already succeeded along the other pipe; assuming &quot;</span></div>
<div class="line"><a id="l03254" name="l03254"></a><span class="lineno"> 3254</span>                   <span class="stringliteral">&quot;this is the same information; ignoring; will continue read chain (do real work along this pipe).&quot;</span>);</div>
<div class="line"><a id="l03255" name="l03255"></a><span class="lineno"> 3255</span>    pipe-&gt;<a class="code hl_variable" href="structipc_1_1transport_1_1struc_1_1sync__io_1_1Channel_1_1Msg__in__pipe.html#a58b72930ddbf7e45936f8c8f34105324">m_proto_neg_reader_in</a>.reset(); <span class="comment">// As above.</span></div>
<div class="line"><a id="l03256" name="l03256"></a><span class="lineno"> 3256</span> </div>
<div class="line"><a id="l03257" name="l03257"></a><span class="lineno"> 3257</span>    rcv_async_read_lead_or_continuation_msg(pipe, <span class="keyword">true</span>);</div>
<div class="line"><a id="l03258" name="l03258"></a><span class="lineno"> 3258</span>    <span class="keywordflow">return</span>;</div>
<div class="line"><a id="l03259" name="l03259"></a><span class="lineno"> 3259</span>  }</div>
<div class="line"><a id="l03260" name="l03260"></a><span class="lineno"> 3260</span>  <span class="comment">// else</span></div>
<div class="line"><a id="l03261" name="l03261"></a><span class="lineno"> 3261</span> </div>
<div class="line"><a id="l03262" name="l03262"></a><span class="lineno"> 3262</span>  <a class="code hl_typedef" href="classipc_1_1transport_1_1Protocol__negotiator.html#a35fb3885d39f11d0c1f7860e64194592">Protocol_negotiator::proto_ver_t</a> proto_ver = <a class="code hl_variable" href="classipc_1_1transport_1_1Protocol__negotiator.html#aa7e47f4f6a700aeaa9600a5426a17292">Protocol_negotiator::S_VER_UNKNOWN</a>;</div>
<div class="line"><a id="l03263" name="l03263"></a><span class="lineno"> 3263</span>  <a class="code hl_typedef" href="classipc_1_1transport_1_1Protocol__negotiator.html#a35fb3885d39f11d0c1f7860e64194592">Protocol_negotiator::proto_ver_t</a> proto_ver_aux = <a class="code hl_variable" href="classipc_1_1transport_1_1Protocol__negotiator.html#aa7e47f4f6a700aeaa9600a5426a17292">Protocol_negotiator::S_VER_UNKNOWN</a>;</div>
<div class="line"><a id="l03264" name="l03264"></a><span class="lineno"> 3264</span> </div>
<div class="line"><a id="l03265" name="l03265"></a><span class="lineno"> 3265</span>  <span class="keywordflow">if</span> (!pipe-&gt;<a class="code hl_variable" href="structipc_1_1transport_1_1struc_1_1sync__io_1_1Channel_1_1Msg__in__pipe.html#a83b9a3a7ddee7b6bfe14724bfccfc6ba">m_proto_neg_hndl</a>.<a class="code hl_function" href="structipc_1_1util_1_1Native__handle.html#a11bd62ce0a7bef4bdfe666201c26d4dc">null</a>())</div>
<div class="line"><a id="l03266" name="l03266"></a><span class="lineno"> 3266</span>  {</div>
<div class="line"><a id="l03267" name="l03267"></a><span class="lineno"> 3267</span>    FLOW_LOG_WARNING(<span class="stringliteral">&quot;struc::Channel [&quot;</span> &lt;&lt; *<span class="keyword">this</span> &lt;&lt; <span class="stringliteral">&quot;]: Async-receive handler for would-be protocol-negotiation &quot;</span></div>
<div class="line"><a id="l03268" name="l03268"></a><span class="lineno"> 3268</span>                     <span class="stringliteral">&quot;in-message invoked; size received = [&quot;</span> &lt;&lt; sz &lt;&lt; <span class="stringliteral">&quot;].  The message contains a native handle; &quot;</span></div>
<div class="line"><a id="l03269" name="l03269"></a><span class="lineno"> 3269</span>                     <span class="stringliteral">&quot;this is wrong in this context -- bug somewhere, possibly in opposing process?  &quot;</span></div>
<div class="line"><a id="l03270" name="l03270"></a><span class="lineno"> 3270</span>                     <span class="stringliteral">&quot;Protocol negotiation will fail.&quot;</span>);</div>
<div class="line"><a id="l03271" name="l03271"></a><span class="lineno"> 3271</span>  }</div>
<div class="line"><a id="l03272" name="l03272"></a><span class="lineno"> 3272</span>  <span class="keywordflow">else</span></div>
<div class="line"><a id="l03273" name="l03273"></a><span class="lineno"> 3273</span>  {</div>
<div class="line"><a id="l03274" name="l03274"></a><span class="lineno"> 3274</span>    <span class="comment">// Interpret the received protocol-negotiation in-message.</span></div>
<div class="line"><a id="l03275" name="l03275"></a><span class="lineno"> 3275</span> </div>
<div class="line"><a id="l03276" name="l03276"></a><span class="lineno"> 3276</span>    <span class="keyword">auto</span>&amp; blob = *pipe-&gt;<a class="code hl_variable" href="structipc_1_1transport_1_1struc_1_1sync__io_1_1Channel_1_1Msg__in__pipe.html#a56c1f9cdcfd2a145114ab080199eb704">m_proto_neg_blob</a>;</div>
<div class="line"><a id="l03277" name="l03277"></a><span class="lineno"> 3277</span>    <span class="keyword">static_assert</span>(std::is_same_v&lt;<span class="keyword">decltype</span>(blob), Blob&amp;&gt;, <span class="stringliteral">&quot;m_proto_neg_blob must be Blob container.&quot;</span>);</div>
<div class="line"><a id="l03278" name="l03278"></a><span class="lineno"> 3278</span>    <span class="keyword">static_assert</span>(<span class="keyword">sizeof</span>(Blob::value_type) == 1, <span class="stringliteral">&quot;Blob holds bytes, we assume.&quot;</span>);</div>
<div class="line"><a id="l03279" name="l03279"></a><span class="lineno"> 3279</span> </div>
<div class="line"><a id="l03280" name="l03280"></a><span class="lineno"> 3280</span>    <span class="comment">// Ignore garbage after the received bytes (this is permanent).  After that we can access capnp-encoded msg.</span></div>
<div class="line"><a id="l03281" name="l03281"></a><span class="lineno"> 3281</span>    blob.resize(sz);</div>
<div class="line"><a id="l03282" name="l03282"></a><span class="lineno"> 3282</span> </div>
<div class="line"><a id="l03283" name="l03283"></a><span class="lineno"> 3283</span>    <span class="keyword">const</span> <span class="keyword">auto</span> root = pipe-&gt;<a class="code hl_variable" href="structipc_1_1transport_1_1struc_1_1sync__io_1_1Channel_1_1Msg__in__pipe.html#a58b72930ddbf7e45936f8c8f34105324">m_proto_neg_reader_in</a>-&gt;template deserialization</div>
<div class="line"><a id="l03284" name="l03284"></a><span class="lineno"> 3284</span>                                                     &lt;schema::detail::ProtocolNegotiation&gt;(&amp;err_code);</div>
<div class="line"><a id="l03285" name="l03285"></a><span class="lineno"> 3285</span>    assert((!err_code) &amp;&amp; <span class="stringliteral">&quot;It should be a small single-segment simple message; no possible Error_code makes sense.&quot;</span>);</div>
<div class="line"><a id="l03286" name="l03286"></a><span class="lineno"> 3286</span> </div>
<div class="line"><a id="l03287" name="l03287"></a><span class="lineno"> 3287</span>    proto_ver = root.getMaxProtoVer();</div>
<div class="line"><a id="l03288" name="l03288"></a><span class="lineno"> 3288</span>    proto_ver_aux = root.getMaxProtoVerAux();</div>
<div class="line"><a id="l03289" name="l03289"></a><span class="lineno"> 3289</span>  }</div>
<div class="line"><a id="l03290" name="l03290"></a><span class="lineno"> 3290</span>  pipe-&gt;<a class="code hl_variable" href="structipc_1_1transport_1_1struc_1_1sync__io_1_1Channel_1_1Msg__in__pipe.html#a58b72930ddbf7e45936f8c8f34105324">m_proto_neg_reader_in</a>.reset(); <span class="comment">// As above.</span></div>
<div class="line"><a id="l03291" name="l03291"></a><span class="lineno"> 3291</span> </div>
<div class="line"><a id="l03292" name="l03292"></a><span class="lineno"> 3292</span>  <span class="comment">/* Now to negotiate (or intentionally fail, if that weird WARNING-inducing thing above happened).</span></div>
<div class="line"><a id="l03293" name="l03293"></a><span class="lineno"> 3293</span><span class="comment">   * Protocol_negotiator handles everything (invalid value, incompatible range...). */</span></div>
<div class="line"><a id="l03294" name="l03294"></a><span class="lineno"> 3294</span><span class="preprocessor">#ifndef NDEBUG</span></div>
<div class="line"><a id="l03295" name="l03295"></a><span class="lineno"> 3295</span>  <span class="keywordtype">bool</span> ok =</div>
<div class="line"><a id="l03296" name="l03296"></a><span class="lineno"> 3296</span><span class="preprocessor">#endif</span></div>
<div class="line"><a id="l03297" name="l03297"></a><span class="lineno"> 3297</span>  m_protocol_negotiator.compute_negotiated_proto_ver(proto_ver, &amp;err_code);</div>
<div class="line"><a id="l03298" name="l03298"></a><span class="lineno"> 3298</span>  assert(ok &amp;&amp; <span class="stringliteral">&quot;Protocol_negotiator breaking contract?  Bug?&quot;</span>);</div>
<div class="line"><a id="l03299" name="l03299"></a><span class="lineno"> 3299</span>  <span class="keywordflow">if</span> (!err_code)</div>
<div class="line"><a id="l03300" name="l03300"></a><span class="lineno"> 3300</span>  {</div>
<div class="line"><a id="l03301" name="l03301"></a><span class="lineno"> 3301</span><span class="preprocessor">#ifndef NDEBUG</span></div>
<div class="line"><a id="l03302" name="l03302"></a><span class="lineno"> 3302</span>    ok =</div>
<div class="line"><a id="l03303" name="l03303"></a><span class="lineno"> 3303</span><span class="preprocessor">#endif</span></div>
<div class="line"><a id="l03304" name="l03304"></a><span class="lineno"> 3304</span>    m_protocol_negotiator_aux.compute_negotiated_proto_ver(proto_ver_aux, &amp;err_code);</div>
<div class="line"><a id="l03305" name="l03305"></a><span class="lineno"> 3305</span>    assert(ok &amp;&amp; <span class="stringliteral">&quot;Protocol_negotiator breaking contract?  Bug?&quot;</span>);</div>
<div class="line"><a id="l03306" name="l03306"></a><span class="lineno"> 3306</span>  }</div>
<div class="line"><a id="l03307" name="l03307"></a><span class="lineno"> 3307</span> </div>
<div class="line"><a id="l03308" name="l03308"></a><span class="lineno"> 3308</span>  <span class="keywordflow">if</span> (err_code)</div>
<div class="line"><a id="l03309" name="l03309"></a><span class="lineno"> 3309</span>  {</div>
<div class="line"><a id="l03310" name="l03310"></a><span class="lineno"> 3310</span>    handle_new_error(err_code, <span class="stringliteral">&quot;rcv_on_async_read_proto_neg_msg()&quot;</span>);</div>
<div class="line"><a id="l03311" name="l03311"></a><span class="lineno"> 3311</span>    handlers_poll(<span class="stringliteral">&quot;rcv_on_async_read_proto_neg_msg(2)&quot;</span>); <span class="comment">// !!!</span></div>
<div class="line"><a id="l03312" name="l03312"></a><span class="lineno"> 3312</span>    <span class="keywordflow">return</span>; <span class="comment">// It&#39;s over.</span></div>
<div class="line"><a id="l03313" name="l03313"></a><span class="lineno"> 3313</span>  }</div>
<div class="line"><a id="l03314" name="l03314"></a><span class="lineno"> 3314</span>  <span class="comment">// else</span></div>
<div class="line"><a id="l03315" name="l03315"></a><span class="lineno"> 3315</span> </div>
<div class="line"><a id="l03316" name="l03316"></a><span class="lineno"> 3316</span>  FLOW_LOG_TRACE(<span class="stringliteral">&quot;struc::Channel [&quot;</span> &lt;&lt; *<span class="keyword">this</span> &lt;&lt; <span class="stringliteral">&quot;]: Async-receive handler for would-be protocol-negotiation &quot;</span></div>
<div class="line"><a id="l03317" name="l03317"></a><span class="lineno"> 3317</span>                 <span class="stringliteral">&quot;in-message invoked; size received = [&quot;</span> &lt;&lt; sz &lt;&lt; <span class="stringliteral">&quot;].  Negotiation passed.  &quot;</span></div>
<div class="line"><a id="l03318" name="l03318"></a><span class="lineno"> 3318</span>                 <span class="stringliteral">&quot;Will continue read chain (do real work along this pipe).&quot;</span>);</div>
<div class="line"><a id="l03319" name="l03319"></a><span class="lineno"> 3319</span>  rcv_async_read_lead_or_continuation_msg(pipe, <span class="keyword">true</span>);</div>
<div class="line"><a id="l03320" name="l03320"></a><span class="lineno"> 3320</span>} <span class="comment">// Channel::rcv_on_async_read_proto_neg_msg()</span></div>
<div class="line"><a id="l03321" name="l03321"></a><span class="lineno"> 3321</span> </div>
<div class="line"><a id="l03322" name="l03322"></a><span class="lineno"> 3322</span><a class="code hl_define" href="ipc__transport__structured_2src_2ipc_2transport_2struc_2sync__io_2channel_8hpp.html#a50e1bb663274c68c760263342ddfdcbc">TEMPLATE_SIO_STRUCT_CHANNEL</a></div>
<div class="line"><a id="l03323" name="l03323"></a><span class="lineno"><a class="line" href="classipc_1_1transport_1_1struc_1_1sync__io_1_1Channel.html#aa210976b523c04042dd083f054182441"> 3323</a></span><span class="keywordtype">bool</span> CLASS_SIO_STRUCT_CHANNEL::rcv_struct_new_msg_in(<a class="code hl_typedef" href="classipc_1_1transport_1_1struc_1_1sync__io_1_1Channel.html#a84287334d14f54c97f7dbb0d5b04cca5">Msg_in_ptr_uniq</a>&amp;&amp; msg_in_moved)</div>
<div class="line"><a id="l03324" name="l03324"></a><span class="lineno"> 3324</span>{</div>
<div class="line"><a id="l03325" name="l03325"></a><span class="lineno"> 3325</span>  <a class="code hl_typedef" href="classipc_1_1transport_1_1struc_1_1sync__io_1_1Channel.html#a84287334d14f54c97f7dbb0d5b04cca5">Msg_in_ptr_uniq</a> msg_in(std::move(msg_in_moved));</div>
<div class="line"><a id="l03326" name="l03326"></a><span class="lineno"> 3326</span>  <span class="comment">// msg_in_moved is now nullified as promised.  We own the Msg_in.</span></div>
<div class="line"><a id="l03327" name="l03327"></a><span class="lineno"> 3327</span>  <span class="keyword">auto</span>&amp; msg_in_privileged = *msg_in;</div>
<div class="line"><a id="l03328" name="l03328"></a><span class="lineno"> 3328</span> </div>
<div class="line"><a id="l03329" name="l03329"></a><span class="lineno"> 3329</span>  <span class="comment">/* Pre-condition: msg_in is with-handle or sans-handle; and has all the serialization segments inside it that</span></div>
<div class="line"><a id="l03330" name="l03330"></a><span class="lineno"> 3330</span><span class="comment">   * the remote peer alleged are needed for deserialization to work; and msg_in.deserialize_msg() has already</span></div>
<div class="line"><a id="l03331" name="l03331"></a><span class="lineno"> 3331</span><span class="comment">   * successfully executed.  So let us attempt to deserialize the body -- if any.</span></div>
<div class="line"><a id="l03332" name="l03332"></a><span class="lineno"> 3332</span><span class="comment">   * Reminder: This does not involve copying or heavy-weight decoding operations, at its core: It initializes</span></div>
<div class="line"><a id="l03333" name="l03333"></a><span class="lineno"> 3333</span><span class="comment">   * a capnp-generated Reader class that simply reads bits out of those segments in RAM.</span></div>
<div class="line"><a id="l03334" name="l03334"></a><span class="lineno"> 3334</span><span class="comment">   *</span></div>
<div class="line"><a id="l03335" name="l03335"></a><span class="lineno"> 3335</span><span class="comment">   * That&#39;s the core thing.  But the preceding .deserialize_mdt() call does perform checks on the basics, namely</span></div>
<div class="line"><a id="l03336" name="l03336"></a><span class="lineno"> 3336</span><span class="comment">   * everything that:</span></div>
<div class="line"><a id="l03337" name="l03337"></a><span class="lineno"> 3337</span><span class="comment">   *   - doesn&#39;t require knowledge of other in-messages and out-messages; and</span></div>
<div class="line"><a id="l03338" name="l03338"></a><span class="lineno"> 3338</span><span class="comment">   *   - doesn&#39;t require going *inside* .body_root() or .internal_msg_body_root() (whichever is applicable).</span></div>
<div class="line"><a id="l03339" name="l03339"></a><span class="lineno"> 3339</span><span class="comment">   *</span></div>
<div class="line"><a id="l03340" name="l03340"></a><span class="lineno"> 3340</span><span class="comment">   * Anyway, that&#39;s the rule of thumb, but in practice when we&#39;re checking some piece of data via</span></div>
<div class="line"><a id="l03341" name="l03341"></a><span class="lineno"> 3341</span><span class="comment">   * accessors after deserialize_*(), we must simply be aware whether a particular correctness has already been</span></div>
<div class="line"><a id="l03342" name="l03342"></a><span class="lineno"> 3342</span><span class="comment">   * ensured by deserialize_*(); if so great; if not either add it in there (if it fits the above rule of thumb)</span></div>
<div class="line"><a id="l03343" name="l03343"></a><span class="lineno"> 3343</span><span class="comment">   * or ensure it in `*this` code. */</span></div>
<div class="line"><a id="l03344" name="l03344"></a><span class="lineno"> 3344</span> </div>
<div class="line"><a id="l03345" name="l03345"></a><span class="lineno"> 3345</span>  <span class="keywordflow">if</span> (msg_in_privileged.id_or_none() != 0)</div>
<div class="line"><a id="l03346" name="l03346"></a><span class="lineno"> 3346</span>  {</div>
<div class="line"><a id="l03347" name="l03347"></a><span class="lineno"> 3347</span>    FLOW_LOG_TRACE(<span class="stringliteral">&quot;struc::Channel [&quot;</span> &lt;&lt; *<span class="keyword">this</span> &lt;&lt; <span class="stringliteral">&quot;]: About to deserialize (zero-copy) new structured in-message: &quot;</span></div>
<div class="line"><a id="l03348" name="l03348"></a><span class="lineno"> 3348</span>                   <span class="stringliteral">&quot;optional user-message-body portion.&quot;</span>);</div>
<div class="line"><a id="l03349" name="l03349"></a><span class="lineno"> 3349</span> </div>
<div class="line"><a id="l03350" name="l03350"></a><span class="lineno"> 3350</span>    <a class="code hl_typedef" href="namespaceipc.html#aa3192e586cc45d3e7c22463bf2760f89">Error_code</a> err_code;</div>
<div class="line"><a id="l03351" name="l03351"></a><span class="lineno"> 3351</span>    msg_in_privileged.deserialize_body(&amp;err_code);</div>
<div class="line"><a id="l03352" name="l03352"></a><span class="lineno"> 3352</span>    <span class="keywordflow">if</span> (err_code)</div>
<div class="line"><a id="l03353" name="l03353"></a><span class="lineno"> 3353</span>    {</div>
<div class="line"><a id="l03354" name="l03354"></a><span class="lineno"> 3354</span>      handle_new_error(err_code, <span class="stringliteral">&quot;rcv_struct_new_msg_in()&quot;</span>);</div>
<div class="line"><a id="l03355" name="l03355"></a><span class="lineno"> 3355</span>      <span class="keywordflow">return</span> <span class="keyword">false</span>;</div>
<div class="line"><a id="l03356" name="l03356"></a><span class="lineno"> 3356</span>    }</div>
<div class="line"><a id="l03357" name="l03357"></a><span class="lineno"> 3357</span>    <span class="comment">// else</span></div>
<div class="line"><a id="l03358" name="l03358"></a><span class="lineno"> 3358</span> </div>
<div class="line"><a id="l03359" name="l03359"></a><span class="lineno"> 3359</span>    <span class="comment">// (W/r/t to the pretty-print -- see any comments near the somewhat-mirrored calls in send_core().  May apply here.)</span></div>
<div class="line"><a id="l03360" name="l03360"></a><span class="lineno"> 3360</span>    FLOW_LOG_TRACE(<span class="stringliteral">&quot;struc::Channel [&quot;</span> &lt;&lt; *<span class="keyword">this</span> &lt;&lt; <span class="stringliteral">&quot;]: Deserialized user message [&quot;</span> &lt;&lt; msg_in_privileged &lt;&lt; <span class="stringliteral">&quot;].&quot;</span>);</div>
<div class="line"><a id="l03361" name="l03361"></a><span class="lineno"> 3361</span>    FLOW_LOG_DATA(<span class="stringliteral">&quot;struc::Channel [&quot;</span> &lt;&lt; *<span class="keyword">this</span> &lt;&lt; <span class="stringliteral">&quot;]: The complete user message: &quot;</span></div>
<div class="line"><a id="l03362" name="l03362"></a><span class="lineno"> 3362</span>                  <span class="stringliteral">&quot;\n&quot;</span> &lt;&lt; ::capnp::prettyPrint(msg_in_privileged.body_root()).flatten().cStr());</div>
<div class="line"><a id="l03363" name="l03363"></a><span class="lineno"> 3363</span>  }</div>
<div class="line"><a id="l03364" name="l03364"></a><span class="lineno"> 3364</span>  <span class="comment">// else { msg_in-&gt;body_root() will never be accessed (internal message). }</span></div>
<div class="line"><a id="l03365" name="l03365"></a><span class="lineno"> 3365</span> </div>
<div class="line"><a id="l03366" name="l03366"></a><span class="lineno"> 3366</span>  <span class="comment">/* ASAP let&#39;s make the famous session-token check that is required for all in-messages.</span></div>
<div class="line"><a id="l03367" name="l03367"></a><span class="lineno"> 3367</span><span class="comment">   * First refer to structured_msg.capnp StructuredMessage.AuthHeader.sessionToken and the mandated rules</span></div>
<div class="line"><a id="l03368" name="l03368"></a><span class="lineno"> 3368</span><span class="comment">   * for checking.  They&#39;re important, so restating them here in our context:</span></div>
<div class="line"><a id="l03369" name="l03369"></a><span class="lineno"> 3369</span><span class="comment">   *   - Each Channel is either LOGGED_IN from ction; or starts SRV_LOG_IN/CLI_LOG_IN and</span></div>
<div class="line"><a id="l03370" name="l03370"></a><span class="lineno"> 3370</span><span class="comment">   *     enters LOGGED_IN once a very rigid log-in exchange occurs OK.</span></div>
<div class="line"><a id="l03371" name="l03371"></a><span class="lineno"> 3371</span><span class="comment">   *   - When *_LOG_IN: only two messages are allowed in the world; call them LogInReq and LogInRsp</span></div>
<div class="line"><a id="l03372" name="l03372"></a><span class="lineno"> 3372</span><span class="comment">   *     in this comment.</span></div>
<div class="line"><a id="l03373" name="l03373"></a><span class="lineno"> 3373</span><span class="comment">   *     - SRV_LOG_IN:</span></div>
<div class="line"><a id="l03374" name="l03374"></a><span class="lineno"> 3374</span><span class="comment">   *       - m_session_token is (randomly) generated locally and remains unchanged throughout `*this`;</span></div>
<div class="line"><a id="l03375" name="l03375"></a><span class="lineno"> 3375</span><span class="comment">   *       - LogInReq is the only in-message allowed -- exactly 1 of them -- and its .sessionToken *must* be nil.</span></div>
<div class="line"><a id="l03376" name="l03376"></a><span class="lineno"> 3376</span><span class="comment">   *     - CLI_LOG_IN:</span></div>
<div class="line"><a id="l03377" name="l03377"></a><span class="lineno"> 3377</span><span class="comment">   *       - m_session_token is nil throughout this phase; it is changed to non-nil just before LOGGED_IN entry.</span></div>
<div class="line"><a id="l03378" name="l03378"></a><span class="lineno"> 3378</span><span class="comment">   *       - LogInRsp is the only in-message allowed -- exactly 1 of them -- and its .sessionToken *must* not</span></div>
<div class="line"><a id="l03379" name="l03379"></a><span class="lineno"> 3379</span><span class="comment">   *         be nil; but there is no *correct* value beyond that against which to check.</span></div>
<div class="line"><a id="l03380" name="l03380"></a><span class="lineno"> 3380</span><span class="comment">   *   - When LOGGED_IN:</span></div>
<div class="line"><a id="l03381" name="l03381"></a><span class="lineno"> 3381</span><span class="comment">   *     - m_session_token is non-nil and unchanged throughout this phase (until `*this` dies).</span></div>
<div class="line"><a id="l03382" name="l03382"></a><span class="lineno"> 3382</span><span class="comment">   *     - Every in-message must have .sessionToken equal to m_session_token.</span></div>
<div class="line"><a id="l03383" name="l03383"></a><span class="lineno"> 3383</span><span class="comment">   *</span></div>
<div class="line"><a id="l03384" name="l03384"></a><span class="lineno"> 3384</span><span class="comment">   * Due to the way our state is set up, then, we can confidently perform the following check early and simply.</span></div>
<div class="line"><a id="l03385" name="l03385"></a><span class="lineno"> 3385</span><span class="comment">   * (E.g., we need not worry about sequence #s yet -- can check this right away.) */</span></div>
<div class="line"><a id="l03386" name="l03386"></a><span class="lineno"> 3386</span>  <span class="keyword">const</span> <span class="keyword">auto</span>&amp; session_token = msg_in_privileged.session_token();</div>
<div class="line"><a id="l03387" name="l03387"></a><span class="lineno"> 3387</span>  <span class="keywordflow">if</span> (m_phase == Phase::S_SRV_LOG_IN)</div>
<div class="line"><a id="l03388" name="l03388"></a><span class="lineno"> 3388</span>  {</div>
<div class="line"><a id="l03389" name="l03389"></a><span class="lineno"> 3389</span>    <span class="keywordflow">if</span> (!session_token.is_nil())</div>
<div class="line"><a id="l03390" name="l03390"></a><span class="lineno"> 3390</span>    {</div>
<div class="line"><a id="l03391" name="l03391"></a><span class="lineno"> 3391</span>      FLOW_LOG_WARNING(<span class="stringliteral">&quot;struc::Channel [&quot;</span> &lt;&lt; *<span class="keyword">this</span> &lt;&lt; <span class="stringliteral">&quot;]: Log-in (as server): Deserialized new structured &quot;</span></div>
<div class="line"><a id="l03392" name="l03392"></a><span class="lineno"> 3392</span>                       <span class="stringliteral">&quot;in-message, which must be the log-in request, but the session token is not nil as &quot;</span></div>
<div class="line"><a id="l03393" name="l03393"></a><span class="lineno"> 3393</span>                       <span class="stringliteral">&quot;required (is [&quot;</span> &lt;&lt; session_token &lt;&lt; <span class="stringliteral">&quot;]).  Other side misbehaved?&quot;</span>);</div>
<div class="line"><a id="l03394" name="l03394"></a><span class="lineno"> 3394</span>      handle_new_error(<a class="code hl_enumvalue" href="namespaceipc_1_1transport_1_1struc_1_1error.html#a990b9ff850cf9aaf354efdd07d86a71daab47c241a659164b808ddba23736d02b">error::Code::S_STRUCT_CHANNEL_INTERNAL_PROTOCOL_LOG_IN_MISUSED_SCHEMA</a>,</div>
<div class="line"><a id="l03395" name="l03395"></a><span class="lineno"> 3395</span>                       <span class="stringliteral">&quot;rcv_struct_new_msg_in()&quot;</span>);</div>
<div class="line"><a id="l03396" name="l03396"></a><span class="lineno"> 3396</span>      <span class="keywordflow">return</span> <span class="keyword">false</span>;</div>
<div class="line"><a id="l03397" name="l03397"></a><span class="lineno"> 3397</span>    }</div>
<div class="line"><a id="l03398" name="l03398"></a><span class="lineno"> 3398</span>    <span class="comment">// else: OK.</span></div>
<div class="line"><a id="l03399" name="l03399"></a><span class="lineno"> 3399</span>  }</div>
<div class="line"><a id="l03400" name="l03400"></a><span class="lineno"> 3400</span>  <span class="keywordflow">else</span> <span class="keywordflow">if</span> (m_phase == Phase::S_CLI_LOG_IN)</div>
<div class="line"><a id="l03401" name="l03401"></a><span class="lineno"> 3401</span>  {</div>
<div class="line"><a id="l03402" name="l03402"></a><span class="lineno"> 3402</span>    <span class="keywordflow">if</span> (session_token.is_nil())</div>
<div class="line"><a id="l03403" name="l03403"></a><span class="lineno"> 3403</span>    {</div>
<div class="line"><a id="l03404" name="l03404"></a><span class="lineno"> 3404</span>      FLOW_LOG_WARNING(<span class="stringliteral">&quot;struc::Channel [&quot;</span> &lt;&lt; *<span class="keyword">this</span> &lt;&lt; <span class="stringliteral">&quot;]: Log-in (as client): Deserialized new structured &quot;</span></div>
<div class="line"><a id="l03405" name="l03405"></a><span class="lineno"> 3405</span>                       <span class="stringliteral">&quot;in-message, which must be the log-in response, but the session token is nil and &quot;</span></div>
<div class="line"><a id="l03406" name="l03406"></a><span class="lineno"> 3406</span>                       <span class="stringliteral">&quot;not non-nil as required.  Other side misbehaved?&quot;</span>);</div>
<div class="line"><a id="l03407" name="l03407"></a><span class="lineno"> 3407</span>      handle_new_error(<a class="code hl_enumvalue" href="namespaceipc_1_1transport_1_1struc_1_1error.html#a990b9ff850cf9aaf354efdd07d86a71daab47c241a659164b808ddba23736d02b">error::Code::S_STRUCT_CHANNEL_INTERNAL_PROTOCOL_LOG_IN_MISUSED_SCHEMA</a>,</div>
<div class="line"><a id="l03408" name="l03408"></a><span class="lineno"> 3408</span>                       <span class="stringliteral">&quot;rcv_struct_new_msg_in()&quot;</span>);</div>
<div class="line"><a id="l03409" name="l03409"></a><span class="lineno"> 3409</span>      <span class="keywordflow">return</span> <span class="keyword">false</span>;</div>
<div class="line"><a id="l03410" name="l03410"></a><span class="lineno"> 3410</span>    }</div>
<div class="line"><a id="l03411" name="l03411"></a><span class="lineno"> 3411</span>    <span class="comment">// else: OK.</span></div>
<div class="line"><a id="l03412" name="l03412"></a><span class="lineno"> 3412</span>  }</div>
<div class="line"><a id="l03413" name="l03413"></a><span class="lineno"> 3413</span>  <span class="keywordflow">else</span></div>
<div class="line"><a id="l03414" name="l03414"></a><span class="lineno"> 3414</span>  {</div>
<div class="line"><a id="l03415" name="l03415"></a><span class="lineno"> 3415</span>    assert(m_phase == Phase::S_LOGGED_IN);</div>
<div class="line"><a id="l03416" name="l03416"></a><span class="lineno"> 3416</span>    <span class="keywordflow">if</span> (session_token != m_session_token)</div>
<div class="line"><a id="l03417" name="l03417"></a><span class="lineno"> 3417</span>    {</div>
<div class="line"><a id="l03418" name="l03418"></a><span class="lineno"> 3418</span>      FLOW_LOG_WARNING(<span class="stringliteral">&quot;struc::Channel [&quot;</span> &lt;&lt; *<span class="keyword">this</span> &lt;&lt; <span class="stringliteral">&quot;]: Deserialized new structured &quot;</span></div>
<div class="line"><a id="l03419" name="l03419"></a><span class="lineno"> 3419</span>                       <span class="stringliteral">&quot;in-message, but its session token [&quot;</span> &lt;&lt; session_token &lt;&lt; <span class="stringliteral">&quot;] does not match the &quot;</span></div>
<div class="line"><a id="l03420" name="l03420"></a><span class="lineno"> 3420</span>                       <span class="stringliteral">&quot;established session token [&quot;</span> &lt;&lt; m_session_token &lt;&lt; <span class="stringliteral">&quot;]; auth failed.&quot;</span>);</div>
<div class="line"><a id="l03421" name="l03421"></a><span class="lineno"> 3421</span>      handle_new_error(<a class="code hl_enumvalue" href="namespaceipc_1_1transport_1_1struc_1_1error.html#a990b9ff850cf9aaf354efdd07d86a71da2fba90660c799be216d283a3129f1f63">error::Code::S_STRUCT_CHANNEL_INTERNAL_PROTOCOL_BAD_AUTH</a>,</div>
<div class="line"><a id="l03422" name="l03422"></a><span class="lineno"> 3422</span>                       <span class="stringliteral">&quot;rcv_struct_new_msg_in()&quot;</span>);</div>
<div class="line"><a id="l03423" name="l03423"></a><span class="lineno"> 3423</span>      <span class="keywordflow">return</span> <span class="keyword">false</span>;</div>
<div class="line"><a id="l03424" name="l03424"></a><span class="lineno"> 3424</span>    }</div>
<div class="line"><a id="l03425" name="l03425"></a><span class="lineno"> 3425</span>  }</div>
<div class="line"><a id="l03426" name="l03426"></a><span class="lineno"> 3426</span>  <span class="comment">// Got here: session_token is OK.  On to ID/seq #.</span></div>
<div class="line"><a id="l03427" name="l03427"></a><span class="lineno"> 3427</span> </div>
<div class="line"><a id="l03428" name="l03428"></a><span class="lineno"> 3428</span>  <span class="keyword">const</span> <span class="keyword">auto</span> <span class="keywordtype">id</span> = msg_in_privileged.id_or_none();</div>
<div class="line"><a id="l03429" name="l03429"></a><span class="lineno"> 3429</span>  <span class="keywordflow">if</span> (<span class="keywordtype">id</span> == 0)</div>
<div class="line"><a id="l03430" name="l03430"></a><span class="lineno"> 3430</span>  {</div>
<div class="line"><a id="l03431" name="l03431"></a><span class="lineno"> 3431</span>    <span class="comment">// Internal message.  We&#39;ll deal with the various possibilities in here.</span></div>
<div class="line"><a id="l03432" name="l03432"></a><span class="lineno"> 3432</span>    <span class="keywordflow">return</span> rcv_struct_new_internal_msg_in(msg_in_privileged);</div>
<div class="line"><a id="l03433" name="l03433"></a><span class="lineno"> 3433</span>  }</div>
<div class="line"><a id="l03434" name="l03434"></a><span class="lineno"> 3434</span>  <span class="comment">// else: User message!</span></div>
<div class="line"><a id="l03435" name="l03435"></a><span class="lineno"> 3435</span> </div>
<div class="line"><a id="l03436" name="l03436"></a><span class="lineno"> 3436</span>  <span class="comment">/* Let&#39;s recap.  (All the background info necessary is in the various data member doc headers and possibly class</span></div>
<div class="line"><a id="l03437" name="l03437"></a><span class="lineno"> 3437</span><span class="comment">   * doc header; here we orient ourselves within that body of knowledge.)  We have a valid (in and of itself, maybe</span></div>
<div class="line"><a id="l03438" name="l03438"></a><span class="lineno"> 3438</span><span class="comment">   * not relative to other messages) in-message bearing a user message body.  So it&#39;s in the structured layer</span></div>
<div class="line"><a id="l03439" name="l03439"></a><span class="lineno"> 3439</span><span class="comment">   * for the 1st time.  Where to emit it now?  Ultimately the layers are (goal being to move down this list ASAP):</span></div>
<div class="line"><a id="l03440" name="l03440"></a><span class="lineno"> 3440</span><span class="comment">   *   - Just entered structured layer &lt;- we are here.  We will immediately move it to one of these:</span></div>
<div class="line"><a id="l03441" name="l03441"></a><span class="lineno"> 3441</span><span class="comment">   *   - Reassembly queue m_rcv_reassembly_q.</span></div>
<div class="line"><a id="l03442" name="l03442"></a><span class="lineno"> 3442</span><span class="comment">   *     - Moves in to this layer if: the message&#39;s ID (seq #) is not the next one expected.</span></div>
<div class="line"><a id="l03443" name="l03443"></a><span class="lineno"> 3443</span><span class="comment">   *     - Moves down from this layer when: subsequent in-message(s) bridge(s) the gap to the message&#39;s ID (seq #).</span></div>
<div class="line"><a id="l03444" name="l03444"></a><span class="lineno"> 3444</span><span class="comment">   *     - Skips this layer if: the message&#39;s ID (seq #) *is* the next one expected.</span></div>
<div class="line"><a id="l03445" name="l03445"></a><span class="lineno"> 3445</span><span class="comment">   *       - Note: This is *always* the case unless Owned_channel::S_HAS_2_PIPES.  Otherwise a skipped seq # =</span></div>
<div class="line"><a id="l03446" name="l03446"></a><span class="lineno"> 3446</span><span class="comment">   *         protocol error.</span></div>
<div class="line"><a id="l03447" name="l03447"></a><span class="lineno"> 3447</span><span class="comment">   *       - Side effect: if that also fills the gap to the lowest-seq-# in m_rcv_reassembly_q, then</span></div>
<div class="line"><a id="l03448" name="l03448"></a><span class="lineno"> 3448</span><span class="comment">   *         feed 1+ in-messages in m_rcv_reassembly_q to the next layers.</span></div>
<div class="line"><a id="l03449" name="l03449"></a><span class="lineno"> 3449</span><span class="comment">   *   - Unregistered-Msg_which in-message store m_rcv_pending_msgs.</span></div>
<div class="line"><a id="l03450" name="l03450"></a><span class="lineno"> 3450</span><span class="comment">   *     - Moves in to this layer if: *both* hold:</span></div>
<div class="line"><a id="l03451" name="l03451"></a><span class="lineno"> 3451</span><span class="comment">   *       - the message is not a response (originating_msg_id_or_none() == 0); and</span></div>
<div class="line"><a id="l03452" name="l03452"></a><span class="lineno"> 3452</span><span class="comment">   *       - neither expect_msg() or expect_msgs() has been registered to wait for its body_root().which() yet.</span></div>
<div class="line"><a id="l03453" name="l03453"></a><span class="lineno"> 3453</span><span class="comment">   *     - Moves down from this layer if: expect_msg() or expect_msgs() registers a handler for body_root().which().</span></div>
<div class="line"><a id="l03454" name="l03454"></a><span class="lineno"> 3454</span><span class="comment">   *     - Skips this layer if: the message is a response; or it&#39;s not, and its body_root().which() has a registered</span></div>
<div class="line"><a id="l03455" name="l03455"></a><span class="lineno"> 3455</span><span class="comment">   *       handler from a prior expect_msg() or expect_msgs().</span></div>
<div class="line"><a id="l03456" name="l03456"></a><span class="lineno"> 3456</span><span class="comment">   *   - ONE OF:</span></div>
<div class="line"><a id="l03457" name="l03457"></a><span class="lineno"> 3457</span><span class="comment">   *     - Response handler F in m_rcv_expecting_response_map is called F(msg_in) and (if one-off) then removed</span></div>
<div class="line"><a id="l03458" name="l03458"></a><span class="lineno"> 3458</span><span class="comment">   *       from said map.</span></div>
<div class="line"><a id="l03459" name="l03459"></a><span class="lineno"> 3459</span><span class="comment">   *       - Moves in to this layer if: the message is a response (originating_msg_id_or_none() != 0).</span></div>
<div class="line"><a id="l03460" name="l03460"></a><span class="lineno"> 3460</span><span class="comment">   *         - m_rcv_expecting_response_map[&lt;that ID&gt;] must exist.</span></div>
<div class="line"><a id="l03461" name="l03461"></a><span class="lineno"> 3461</span><span class="comment">   *         - If it doesn&#39;t, then it&#39;s an error at the user&#39;s protocol level and reported as such</span></div>
<div class="line"><a id="l03462" name="l03462"></a><span class="lineno"> 3462</span><span class="comment">   *           (set_unexpected_response_handler()).</span></div>
<div class="line"><a id="l03463" name="l03463"></a><span class="lineno"> 3463</span><span class="comment">   *     - Msg_which-handler F in m_rcv_expecting_msg_map is called F(msg_in) and (if one-off) then removed</span></div>
<div class="line"><a id="l03464" name="l03464"></a><span class="lineno"> 3464</span><span class="comment">   *       from said map.</span></div>
<div class="line"><a id="l03465" name="l03465"></a><span class="lineno"> 3465</span><span class="comment">   *       - Moves in to this layer if: the message is not a response (originating_msg_id_or_none() == 0).</span></div>
<div class="line"><a id="l03466" name="l03466"></a><span class="lineno"> 3466</span><span class="comment">   *         See above.</span></div>
<div class="line"><a id="l03467" name="l03467"></a><span class="lineno"> 3467</span><span class="comment">   *</span></div>
<div class="line"><a id="l03468" name="l03468"></a><span class="lineno"> 3468</span><span class="comment">   * So let&#39;s get to it: Deal with the message ID (seq #). */</span></div>
<div class="line"><a id="l03469" name="l03469"></a><span class="lineno"> 3469</span>  <span class="keywordflow">if</span> (<span class="keywordtype">id</span> != m_rcv_msg_next_id)</div>
<div class="line"><a id="l03470" name="l03470"></a><span class="lineno"> 3470</span>  {</div>
<div class="line"><a id="l03471" name="l03471"></a><span class="lineno"> 3471</span>    <span class="keywordflow">if</span> (<span class="keywordtype">id</span> &lt; m_rcv_msg_next_id)</div>
<div class="line"><a id="l03472" name="l03472"></a><span class="lineno"> 3472</span>    {</div>
<div class="line"><a id="l03473" name="l03473"></a><span class="lineno"> 3473</span>      FLOW_LOG_WARNING(<span class="stringliteral">&quot;struc::Channel [&quot;</span> &lt;&lt; *<span class="keyword">this</span> &lt;&lt; <span class="stringliteral">&quot;]: Deserialized new structured in-message, but its ID &quot;</span></div>
<div class="line"><a id="l03474" name="l03474"></a><span class="lineno"> 3474</span>                       <span class="stringliteral">&quot;[&quot;</span> &lt;&lt; <span class="keywordtype">id</span> &lt;&lt; <span class="stringliteral">&quot;] is duplicate: next expected ID [&quot;</span> &lt;&lt; m_rcv_msg_next_id &lt;&lt; <span class="stringliteral">&quot;] exceeds it.  &quot;</span></div>
<div class="line"><a id="l03475" name="l03475"></a><span class="lineno"> 3475</span>                       <span class="stringliteral">&quot;Other side misbehaved?&quot;</span>);</div>
<div class="line"><a id="l03476" name="l03476"></a><span class="lineno"> 3476</span>      handle_new_error(<a class="code hl_enumvalue" href="namespaceipc_1_1transport_1_1struc_1_1error.html#a990b9ff850cf9aaf354efdd07d86a71da26ab25e100104aeb567d90f794313e3b">error::Code::S_STRUCT_CHANNEL_INTERNAL_PROTOCOL_MISUSED_SCHEMA</a>,</div>
<div class="line"><a id="l03477" name="l03477"></a><span class="lineno"> 3477</span>                       <span class="stringliteral">&quot;rcv_struct_new_msg_in()&quot;</span>);</div>
<div class="line"><a id="l03478" name="l03478"></a><span class="lineno"> 3478</span>      <span class="keywordflow">return</span> <span class="keyword">false</span>;</div>
<div class="line"><a id="l03479" name="l03479"></a><span class="lineno"> 3479</span>    }</div>
<div class="line"><a id="l03480" name="l03480"></a><span class="lineno"> 3480</span>    <span class="comment">// else</span></div>
<div class="line"><a id="l03481" name="l03481"></a><span class="lineno"> 3481</span> </div>
<div class="line"><a id="l03482" name="l03482"></a><span class="lineno"> 3482</span>    <span class="keywordflow">if</span> <span class="keyword">constexpr</span>(!Owned_channel::S_HAS_2_PIPES) <span class="comment">// C++17: #if-like compile-time check.</span></div>
<div class="line"><a id="l03483" name="l03483"></a><span class="lineno"> 3483</span>    {</div>
<div class="line"><a id="l03484" name="l03484"></a><span class="lineno"> 3484</span>      FLOW_LOG_WARNING(<span class="stringliteral">&quot;struc::Channel [&quot;</span> &lt;&lt; *<span class="keyword">this</span> &lt;&lt; <span class="stringliteral">&quot;]: Deserialized new structured in-message, but its ID &quot;</span></div>
<div class="line"><a id="l03485" name="l03485"></a><span class="lineno"> 3485</span>                       <span class="stringliteral">&quot;[&quot;</span> &lt;&lt; <span class="keywordtype">id</span> &lt;&lt; <span class="stringliteral">&quot;] is not sequential to next expected ID [&quot;</span> &lt;&lt; m_rcv_msg_next_id &lt;&lt; <span class="stringliteral">&quot;], even &quot;</span></div>
<div class="line"><a id="l03486" name="l03486"></a><span class="lineno"> 3486</span>                       <span class="stringliteral">&quot;though the channel has only 1 in-pipe.  Other side misbehaved?&quot;</span>);</div>
<div class="line"><a id="l03487" name="l03487"></a><span class="lineno"> 3487</span>      handle_new_error(<a class="code hl_enumvalue" href="namespaceipc_1_1transport_1_1struc_1_1error.html#a990b9ff850cf9aaf354efdd07d86a71da26ab25e100104aeb567d90f794313e3b">error::Code::S_STRUCT_CHANNEL_INTERNAL_PROTOCOL_MISUSED_SCHEMA</a>,</div>
<div class="line"><a id="l03488" name="l03488"></a><span class="lineno"> 3488</span>                       <span class="stringliteral">&quot;rcv_struct_new_msg_in()&quot;</span>);</div>
<div class="line"><a id="l03489" name="l03489"></a><span class="lineno"> 3489</span>      <span class="keywordflow">return</span> <span class="keyword">false</span>;</div>
<div class="line"><a id="l03490" name="l03490"></a><span class="lineno"> 3490</span>    }</div>
<div class="line"><a id="l03491" name="l03491"></a><span class="lineno"> 3491</span>    <span class="keywordflow">else</span> <span class="comment">// if constexpr(Owned_channel::S_HAS_2_PIPES) // Note: it&#39;s like #else; so shouldn&#39;t just omit it after return.</span></div>
<div class="line"><a id="l03492" name="l03492"></a><span class="lineno"> 3492</span>    {</div>
<div class="line"><a id="l03493" name="l03493"></a><span class="lineno"> 3493</span>      <span class="keywordflow">if</span> (m_phase != Phase::S_LOGGED_IN)</div>
<div class="line"><a id="l03494" name="l03494"></a><span class="lineno"> 3494</span>      {</div>
<div class="line"><a id="l03495" name="l03495"></a><span class="lineno"> 3495</span>        FLOW_LOG_WARNING(<span class="stringliteral">&quot;struc::Channel [&quot;</span> &lt;&lt; *<span class="keyword">this</span> &lt;&lt; <span class="stringliteral">&quot;]: Deserialized new structured in-message, but its ID &quot;</span></div>
<div class="line"><a id="l03496" name="l03496"></a><span class="lineno"> 3496</span>                         <span class="stringliteral">&quot;[&quot;</span> &lt;&lt; <span class="keywordtype">id</span> &lt;&lt; <span class="stringliteral">&quot;] is not sequential to next expected ID [&quot;</span> &lt;&lt; m_rcv_msg_next_id &lt;&lt; <span class="stringliteral">&quot;] -- and &quot;</span></div>
<div class="line"><a id="l03497" name="l03497"></a><span class="lineno"> 3497</span>                         <span class="stringliteral">&quot;we are in a log-in phase (during which only the log-in request or response, with seq#=1, &quot;</span></div>
<div class="line"><a id="l03498" name="l03498"></a><span class="lineno"> 3498</span>                         <span class="stringliteral">&quot;is allowed).  Other side misbehaved?&quot;</span>);</div>
<div class="line"><a id="l03499" name="l03499"></a><span class="lineno"> 3499</span>        handle_new_error(<a class="code hl_enumvalue" href="namespaceipc_1_1transport_1_1struc_1_1error.html#a990b9ff850cf9aaf354efdd07d86a71da26ab25e100104aeb567d90f794313e3b">error::Code::S_STRUCT_CHANNEL_INTERNAL_PROTOCOL_MISUSED_SCHEMA</a>,</div>
<div class="line"><a id="l03500" name="l03500"></a><span class="lineno"> 3500</span>                         <span class="stringliteral">&quot;rcv_struct_new_msg_in()&quot;</span>);</div>
<div class="line"><a id="l03501" name="l03501"></a><span class="lineno"> 3501</span>        <span class="keywordflow">return</span> <span class="keyword">false</span>;</div>
<div class="line"><a id="l03502" name="l03502"></a><span class="lineno"> 3502</span>      }</div>
<div class="line"><a id="l03503" name="l03503"></a><span class="lineno"> 3503</span>      <span class="comment">// else</span></div>
<div class="line"><a id="l03504" name="l03504"></a><span class="lineno"> 3504</span> </div>
<div class="line"><a id="l03505" name="l03505"></a><span class="lineno"> 3505</span>      <span class="keyword">const</span> <span class="keyword">auto</span> insert_result = m_rcv_reassembly_q-&gt;emplace(<span class="keywordtype">id</span>, std::move(msg_in));</div>
<div class="line"><a id="l03506" name="l03506"></a><span class="lineno"> 3506</span>      <span class="keywordflow">if</span> (!insert_result.second)</div>
<div class="line"><a id="l03507" name="l03507"></a><span class="lineno"> 3507</span>      {</div>
<div class="line"><a id="l03508" name="l03508"></a><span class="lineno"> 3508</span>        FLOW_LOG_WARNING(<span class="stringliteral">&quot;struc::Channel [&quot;</span> &lt;&lt; *<span class="keyword">this</span> &lt;&lt; <span class="stringliteral">&quot;]: Deserialized new structured in-message, but its ID &quot;</span></div>
<div class="line"><a id="l03509" name="l03509"></a><span class="lineno"> 3509</span>                         <span class="stringliteral">&quot;[&quot;</span> &lt;&lt; <span class="keywordtype">id</span> &lt;&lt; <span class="stringliteral">&quot;] is not sequential to next expected ID [&quot;</span> &lt;&lt; m_rcv_msg_next_id &lt;&lt; <span class="stringliteral">&quot;] -- and &quot;</span></div>
<div class="line"><a id="l03510" name="l03510"></a><span class="lineno"> 3510</span>                         <span class="stringliteral">&quot;the reassembly queue already has an in-message with that ID.  So it&#39;s a duplicate ID.  &quot;</span></div>
<div class="line"><a id="l03511" name="l03511"></a><span class="lineno"> 3511</span>                         <span class="stringliteral">&quot;Other side misbehaved?&quot;</span>);</div>
<div class="line"><a id="l03512" name="l03512"></a><span class="lineno"> 3512</span>        handle_new_error(<a class="code hl_enumvalue" href="namespaceipc_1_1transport_1_1struc_1_1error.html#a990b9ff850cf9aaf354efdd07d86a71da26ab25e100104aeb567d90f794313e3b">error::Code::S_STRUCT_CHANNEL_INTERNAL_PROTOCOL_MISUSED_SCHEMA</a>,</div>
<div class="line"><a id="l03513" name="l03513"></a><span class="lineno"> 3513</span>                         <span class="stringliteral">&quot;rcv_struct_new_msg_in()&quot;</span>);</div>
<div class="line"><a id="l03514" name="l03514"></a><span class="lineno"> 3514</span>        <span class="keywordflow">return</span> <span class="keyword">false</span>;</div>
<div class="line"><a id="l03515" name="l03515"></a><span class="lineno"> 3515</span>      }</div>
<div class="line"><a id="l03516" name="l03516"></a><span class="lineno"> 3516</span>      <span class="comment">// else: inserted OK.  msg_in is now null.</span></div>
<div class="line"><a id="l03517" name="l03517"></a><span class="lineno"> 3517</span>      FLOW_LOG_TRACE(<span class="stringliteral">&quot;struc::Channel [&quot;</span> &lt;&lt; *<span class="keyword">this</span> &lt;&lt; <span class="stringliteral">&quot;]: Deserialized new structured in-message, but its ID &quot;</span></div>
<div class="line"><a id="l03518" name="l03518"></a><span class="lineno"> 3518</span>                     <span class="stringliteral">&quot;[&quot;</span> &lt;&lt; <span class="keywordtype">id</span> &lt;&lt; <span class="stringliteral">&quot;] is not sequential to next expected ID [&quot;</span> &lt;&lt; m_rcv_msg_next_id &lt;&lt; <span class="stringliteral">&quot;]; &quot;</span></div>
<div class="line"><a id="l03519" name="l03519"></a><span class="lineno"> 3519</span>                     <span class="stringliteral">&quot;inserted it into the reassembly queue which now has size &quot;</span></div>
<div class="line"><a id="l03520" name="l03520"></a><span class="lineno"> 3520</span>                     <span class="stringliteral">&quot;[&quot;</span> &lt;&lt; m_rcv_reassembly_q-&gt;size() &lt;&lt; <span class="stringliteral">&quot;].&quot;</span>);</div>
<div class="line"><a id="l03521" name="l03521"></a><span class="lineno"> 3521</span>      <span class="keywordflow">return</span> <span class="keyword">true</span>; <span class="comment">// That&#39;s it for now.  Await the seq # gap to be filled by future in-message(s).</span></div>
<div class="line"><a id="l03522" name="l03522"></a><span class="lineno"> 3522</span>    } <span class="comment">// else if constexpr(Owned_channel::S_HAS_2_PIPES)</span></div>
<div class="line"><a id="l03523" name="l03523"></a><span class="lineno"> 3523</span>    assert(<span class="keyword">false</span> &amp;&amp; <span class="stringliteral">&quot;Either invalid in-message, or it should&#39;ve been inserted into reassembly queue + returned.&quot;</span>);</div>
<div class="line"><a id="l03524" name="l03524"></a><span class="lineno"> 3524</span>  } <span class="comment">// if (id != m_rcv_msg_next_id)</span></div>
<div class="line"><a id="l03525" name="l03525"></a><span class="lineno"> 3525</span>  <span class="comment">// else if (id == m_rcv_msg_next_id):</span></div>
<div class="line"><a id="l03526" name="l03526"></a><span class="lineno"> 3526</span> </div>
<div class="line"><a id="l03527" name="l03527"></a><span class="lineno"> 3527</span>  <span class="comment">// Corner case possibility for IDs &gt;= 2, during non-LOGGED_IN:</span></div>
<div class="line"><a id="l03528" name="l03528"></a><span class="lineno"> 3528</span>  <span class="keywordflow">if</span> ((m_rcv_msg_next_id &gt; 1) &amp;&amp; (m_phase != Phase::S_LOGGED_IN))</div>
<div class="line"><a id="l03529" name="l03529"></a><span class="lineno"> 3529</span>  {</div>
<div class="line"><a id="l03530" name="l03530"></a><span class="lineno"> 3530</span>    assert((m_phase == Phase::S_SRV_LOG_IN)</div>
<div class="line"><a id="l03531" name="l03531"></a><span class="lineno"> 3531</span>           &amp;&amp; <span class="stringliteral">&quot;Phase is CLI_LOG_IN with seq#&gt;=2, but seq#=1 in-message should have immediately moved to &quot;</span></div>
<div class="line"><a id="l03532" name="l03532"></a><span class="lineno"> 3532</span>                <span class="stringliteral">&quot;LOGGED_IN or hosed channel... bug?&quot;</span>);</div>
<div class="line"><a id="l03533" name="l03533"></a><span class="lineno"> 3533</span> </div>
<div class="line"><a id="l03534" name="l03534"></a><span class="lineno"> 3534</span>    FLOW_LOG_WARNING(<span class="stringliteral">&quot;struc::Channel [&quot;</span> &lt;&lt; *<span class="keyword">this</span> &lt;&lt; <span class="stringliteral">&quot;]: Deserialized new structured in-message, and its ID &quot;</span></div>
<div class="line"><a id="l03535" name="l03535"></a><span class="lineno"> 3535</span>                     <span class="stringliteral">&quot;[&quot;</span> &lt;&lt; <span class="keywordtype">id</span> &lt;&lt; <span class="stringliteral">&quot;] is sequential to next expected ID [&quot;</span> &lt;&lt; m_rcv_msg_next_id &lt;&lt; <span class="stringliteral">&quot;] -- but &quot;</span></div>
<div class="line"><a id="l03536" name="l03536"></a><span class="lineno"> 3536</span>                     <span class="stringliteral">&quot;we are in SRV_LOG_IN phase, during which we are to receive at most 1 in-message.  &quot;</span></div>
<div class="line"><a id="l03537" name="l03537"></a><span class="lineno"> 3537</span>                     <span class="stringliteral">&quot;Other side misbehaved?&quot;</span>);</div>
<div class="line"><a id="l03538" name="l03538"></a><span class="lineno"> 3538</span>    handle_new_error(<a class="code hl_enumvalue" href="namespaceipc_1_1transport_1_1struc_1_1error.html#a990b9ff850cf9aaf354efdd07d86a71da26ab25e100104aeb567d90f794313e3b">error::Code::S_STRUCT_CHANNEL_INTERNAL_PROTOCOL_MISUSED_SCHEMA</a>,</div>
<div class="line"><a id="l03539" name="l03539"></a><span class="lineno"> 3539</span>                     <span class="stringliteral">&quot;rcv_struct_new_msg_in()&quot;</span>);</div>
<div class="line"><a id="l03540" name="l03540"></a><span class="lineno"> 3540</span>    <span class="keywordflow">return</span> <span class="keyword">false</span>;</div>
<div class="line"><a id="l03541" name="l03541"></a><span class="lineno"> 3541</span>  }</div>
<div class="line"><a id="l03542" name="l03542"></a><span class="lineno"> 3542</span>  <span class="comment">// else</span></div>
<div class="line"><a id="l03543" name="l03543"></a><span class="lineno"> 3543</span> </div>
<div class="line"><a id="l03544" name="l03544"></a><span class="lineno"> 3544</span>  ++m_rcv_msg_next_id;</div>
<div class="line"><a id="l03545" name="l03545"></a><span class="lineno"> 3545</span> </div>
<div class="line"><a id="l03546" name="l03546"></a><span class="lineno"> 3546</span>  FLOW_LOG_TRACE(<span class="stringliteral">&quot;struc::Channel [&quot;</span> &lt;&lt; *<span class="keyword">this</span> &lt;&lt; <span class="stringliteral">&quot;]: Deserialized new structured in-message, and its ID &quot;</span></div>
<div class="line"><a id="l03547" name="l03547"></a><span class="lineno"> 3547</span>                 <span class="stringliteral">&quot;[&quot;</span> &lt;&lt; <span class="keywordtype">id</span> &lt;&lt; <span class="stringliteral">&quot;] is sequential to next expected ID which has now been incremented to that value.  &quot;</span></div>
<div class="line"><a id="l03548" name="l03548"></a><span class="lineno"> 3548</span>                 <span class="stringliteral">&quot;Handling in-order in-message now.&quot;</span>);</div>
<div class="line"><a id="l03549" name="l03549"></a><span class="lineno"> 3549</span> </div>
<div class="line"><a id="l03550" name="l03550"></a><span class="lineno"> 3550</span>  <span class="comment">/* We have a good, in-order message.  When logged-in: we should indeed handle the bottom 2 layers (see summary above)</span></div>
<div class="line"><a id="l03551" name="l03551"></a><span class="lineno"> 3551</span><span class="comment">   * as written.  But during log-in we have to handle that specific, somewhat rigid message exchange.</span></div>
<div class="line"><a id="l03552" name="l03552"></a><span class="lineno"> 3552</span><span class="comment">   * It is easier to follow if we just handle that in a separate method (where we can assume many simplifications</span></div>
<div class="line"><a id="l03553" name="l03553"></a><span class="lineno"> 3553</span><span class="comment">   * -- e.g., no reassembly queue to deal with) instead of interspersing the general (logged-in) code path with</span></div>
<div class="line"><a id="l03554" name="l03554"></a><span class="lineno"> 3554</span><span class="comment">   * confusing if()finess that handles the somewhat-special log-in messages. So: */</span></div>
<div class="line"><a id="l03555" name="l03555"></a><span class="lineno"> 3555</span>  <span class="keywordflow">switch</span> (m_phase)</div>
<div class="line"><a id="l03556" name="l03556"></a><span class="lineno"> 3556</span>  {</div>
<div class="line"><a id="l03557" name="l03557"></a><span class="lineno"> 3557</span>  <span class="keywordflow">case</span> Phase::S_CLI_LOG_IN:</div>
<div class="line"><a id="l03558" name="l03558"></a><span class="lineno"> 3558</span>    <span class="keywordflow">return</span> rcv_struct_new_msg_in_during_log_in_as_cli(std::move(msg_in));</div>
<div class="line"><a id="l03559" name="l03559"></a><span class="lineno"> 3559</span>  <span class="keywordflow">case</span> Phase::S_SRV_LOG_IN:</div>
<div class="line"><a id="l03560" name="l03560"></a><span class="lineno"> 3560</span>    <span class="keywordflow">return</span> rcv_struct_new_msg_in_during_log_in_as_srv(std::move(msg_in));</div>
<div class="line"><a id="l03561" name="l03561"></a><span class="lineno"> 3561</span>  <span class="keywordflow">case</span> Phase::S_LOGGED_IN:</div>
<div class="line"><a id="l03562" name="l03562"></a><span class="lineno"> 3562</span>    <span class="comment">// Fall through:</span></div>
<div class="line"><a id="l03563" name="l03563"></a><span class="lineno"> 3563</span>    <span class="keywordflow">break</span>;</div>
<div class="line"><a id="l03564" name="l03564"></a><span class="lineno"> 3564</span>  } <span class="comment">// Compiler should warn if we missed an enum value.</span></div>
<div class="line"><a id="l03565" name="l03565"></a><span class="lineno"> 3565</span> </div>
<div class="line"><a id="l03566" name="l03566"></a><span class="lineno"> 3566</span>  <span class="comment">// Yay, this is the mainstream (logged-in) case.</span></div>
<div class="line"><a id="l03567" name="l03567"></a><span class="lineno"> 3567</span> </div>
<div class="line"><a id="l03568" name="l03568"></a><span class="lineno"> 3568</span>  <span class="comment">// This handles the next layers (see summary above) for a given in-order message.</span></div>
<div class="line"><a id="l03569" name="l03569"></a><span class="lineno"> 3569</span>  <span class="keywordflow">if</span> (!rcv_struct_new_msg_in_is_next_expected(std::move(msg_in)))</div>
<div class="line"><a id="l03570" name="l03570"></a><span class="lineno"> 3570</span>  {</div>
<div class="line"><a id="l03571" name="l03571"></a><span class="lineno"> 3571</span>    <span class="keywordflow">return</span> <span class="keyword">false</span>;</div>
<div class="line"><a id="l03572" name="l03572"></a><span class="lineno"> 3572</span>  }</div>
<div class="line"><a id="l03573" name="l03573"></a><span class="lineno"> 3573</span>  <span class="comment">// else</span></div>
<div class="line"><a id="l03574" name="l03574"></a><span class="lineno"> 3574</span> </div>
<div class="line"><a id="l03575" name="l03575"></a><span class="lineno"> 3575</span>  <span class="comment">// As noted in the summary we may have bridged gap to m_rcv_reassembly_q.begin() seq #.  Let&#39;s handle those too.</span></div>
<div class="line"><a id="l03576" name="l03576"></a><span class="lineno"> 3576</span>  <span class="keywordflow">if</span> <span class="keyword">constexpr</span>(Owned_channel::S_HAS_2_PIPES)</div>
<div class="line"><a id="l03577" name="l03577"></a><span class="lineno"> 3577</span>  {</div>
<div class="line"><a id="l03578" name="l03578"></a><span class="lineno"> 3578</span>    <span class="keyword">typename</span> Reassembly_q::iterator first_reassembly_q_it;</div>
<div class="line"><a id="l03579" name="l03579"></a><span class="lineno"> 3579</span>    <span class="keywordflow">while</span> ((!m_rcv_reassembly_q-&gt;empty())</div>
<div class="line"><a id="l03580" name="l03580"></a><span class="lineno"> 3580</span>           &amp;&amp; (first_reassembly_q_it = m_rcv_reassembly_q-&gt;begin())-&gt;first == m_rcv_msg_next_id)</div>
<div class="line"><a id="l03581" name="l03581"></a><span class="lineno"> 3581</span>    {</div>
<div class="line"><a id="l03582" name="l03582"></a><span class="lineno"> 3582</span>      <a class="code hl_typedef" href="classipc_1_1transport_1_1struc_1_1sync__io_1_1Channel.html#a84287334d14f54c97f7dbb0d5b04cca5">Msg_in_ptr_uniq</a> msg_in(std::move(first_reassembly_q_it-&gt;second));</div>
<div class="line"><a id="l03583" name="l03583"></a><span class="lineno"> 3583</span>      m_rcv_reassembly_q-&gt;erase(first_reassembly_q_it);</div>
<div class="line"><a id="l03584" name="l03584"></a><span class="lineno"> 3584</span> </div>
<div class="line"><a id="l03585" name="l03585"></a><span class="lineno"> 3585</span>      ++m_rcv_msg_next_id;</div>
<div class="line"><a id="l03586" name="l03586"></a><span class="lineno"> 3586</span>      FLOW_LOG_TRACE(<span class="stringliteral">&quot;struc::Channel [&quot;</span> &lt;&lt; *<span class="keyword">this</span> &lt;&lt; <span class="stringliteral">&quot;]: ID (sequence #) gap bridged to &quot;</span></div>
<div class="line"><a id="l03587" name="l03587"></a><span class="lineno"> 3587</span>                     <span class="stringliteral">&quot;[&quot;</span> &lt;&lt; m_rcv_msg_next_id &lt;&lt; <span class="stringliteral">&quot;].  Handling in-order in-message now.&quot;</span>);</div>
<div class="line"><a id="l03588" name="l03588"></a><span class="lineno"> 3588</span> </div>
<div class="line"><a id="l03589" name="l03589"></a><span class="lineno"> 3589</span>      <span class="comment">// As above for the new message:</span></div>
<div class="line"><a id="l03590" name="l03590"></a><span class="lineno"> 3590</span>      <span class="keywordflow">if</span> (!rcv_struct_new_msg_in_is_next_expected(std::move(msg_in)))</div>
<div class="line"><a id="l03591" name="l03591"></a><span class="lineno"> 3591</span>      {</div>
<div class="line"><a id="l03592" name="l03592"></a><span class="lineno"> 3592</span>        <span class="keywordflow">return</span> <span class="keyword">false</span>;</div>
<div class="line"><a id="l03593" name="l03593"></a><span class="lineno"> 3593</span>      }</div>
<div class="line"><a id="l03594" name="l03594"></a><span class="lineno"> 3594</span>      <span class="comment">// else: continue.</span></div>
<div class="line"><a id="l03595" name="l03595"></a><span class="lineno"> 3595</span>    } <span class="comment">// while ((!m_rcv_reassembly_q-&gt;empty()) &amp;&amp; (m_rcv_reassembly_q lowest seq # == m_rcv_msg_next_id))</span></div>
<div class="line"><a id="l03596" name="l03596"></a><span class="lineno"> 3596</span>  } <span class="comment">// if constexpr(Owned_channel::S_HAS_2_PIPES)</span></div>
<div class="line"><a id="l03597" name="l03597"></a><span class="lineno"> 3597</span> </div>
<div class="line"><a id="l03598" name="l03598"></a><span class="lineno"> 3598</span>  <span class="keywordflow">return</span> <span class="keyword">true</span>;</div>
<div class="line"><a id="l03599" name="l03599"></a><span class="lineno"> 3599</span>} <span class="comment">// Channel::rcv_struct_new_msg_in()</span></div>
<div class="line"><a id="l03600" name="l03600"></a><span class="lineno"> 3600</span> </div>
<div class="line"><a id="l03601" name="l03601"></a><span class="lineno"> 3601</span><a class="code hl_define" href="ipc__transport__structured_2src_2ipc_2transport_2struc_2sync__io_2channel_8hpp.html#a50e1bb663274c68c760263342ddfdcbc">TEMPLATE_SIO_STRUCT_CHANNEL</a></div>
<div class="line"><a id="l03602" name="l03602"></a><span class="lineno"> 3602</span><span class="keyword">template</span>&lt;<span class="keyword">typename</span> Task&gt;</div>
<div class="line"><a id="l03603" name="l03603"></a><span class="lineno"><a class="line" href="classipc_1_1transport_1_1struc_1_1sync__io_1_1Channel.html#a126c0d7ee5fcab20dc8c87884fdd7597"> 3603</a></span><span class="keywordtype">void</span> CLASS_SIO_STRUCT_CHANNEL::handlers_post(<a class="code hl_typedef" href="namespaceipc_1_1util.html#ae6ac47812a90d1287c61e0b7de7bc4f5">util::String_view</a> context, <a class="code hl_typedef" href="namespaceipc_1_1util.html#a31e67d3a017477a04b313927e2f2c733">Task</a>&amp;&amp; handler)</div>
<div class="line"><a id="l03604" name="l03604"></a><span class="lineno"> 3604</span>{</div>
<div class="line"><a id="l03605" name="l03605"></a><span class="lineno"> 3605</span>  <span class="keyword">using </span><a class="code hl_typedef" href="namespaceipc_1_1util.html#a31e67d3a017477a04b313927e2f2c733">util::Task</a>;</div>
<div class="line"><a id="l03606" name="l03606"></a><span class="lineno"> 3606</span>  <span class="keyword">using </span>boost::movelib::make_unique;</div>
<div class="line"><a id="l03607" name="l03607"></a><span class="lineno"> 3607</span> </div>
<div class="line"><a id="l03608" name="l03608"></a><span class="lineno"> 3608</span>  <span class="keyword">auto</span>&amp; handlers = m_sync_io_handlers;</div>
<div class="line"><a id="l03609" name="l03609"></a><span class="lineno"> 3609</span> </div>
<div class="line"><a id="l03610" name="l03610"></a><span class="lineno"> 3610</span>  FLOW_LOG_TRACE(<span class="stringliteral">&quot;struc::Channel [&quot;</span> &lt;&lt; *<span class="keyword">this</span> &lt;&lt; <span class="stringliteral">&quot;]: Handler added in context &quot;</span></div>
<div class="line"><a id="l03611" name="l03611"></a><span class="lineno"> 3611</span>                 <span class="stringliteral">&quot;[&quot;</span> &lt;&lt; context &lt;&lt; <span class="stringliteral">&quot;]; handlers count will rise to [&quot;</span> &lt;&lt; (handlers.size() + 1) &lt;&lt; <span class="stringliteral">&quot;].&quot;</span>);</div>
<div class="line"><a id="l03612" name="l03612"></a><span class="lineno"> 3612</span> </div>
<div class="line"><a id="l03613" name="l03613"></a><span class="lineno"> 3613</span>  <span class="keywordflow">if</span> <span class="keyword">constexpr</span>(!Owned_channel::S_HAS_2_PIPES)</div>
<div class="line"><a id="l03614" name="l03614"></a><span class="lineno"> 3614</span>  {</div>
<div class="line"><a id="l03615" name="l03615"></a><span class="lineno"> 3615</span>    assert(handlers.empty()</div>
<div class="line"><a id="l03616" name="l03616"></a><span class="lineno"> 3616</span>           &amp;&amp; <span class="stringliteral">&quot;Each low-level in-message can result in at most one handler due to lacking reassembly-queue in one-pipe&quot;</span></div>
<div class="line"><a id="l03617" name="l03617"></a><span class="lineno"> 3617</span>              <span class="stringliteral">&quot;Owned_channel; and we poll handlers after each in-message; &quot;</span></div>
<div class="line"><a id="l03618" name="l03618"></a><span class="lineno"> 3618</span>              <span class="stringliteral">&quot;and no handler can add another handler; so how did we end up with 2+ pending handlers?  Bug?&quot;</span>);</div>
<div class="line"><a id="l03619" name="l03619"></a><span class="lineno"> 3619</span>  }</div>
<div class="line"><a id="l03620" name="l03620"></a><span class="lineno"> 3620</span>  <span class="comment">// else { As explained in m_sync_io_handlers doc header indeed there can be 2+ handlers collected together. }</span></div>
<div class="line"><a id="l03621" name="l03621"></a><span class="lineno"> 3621</span> </div>
<div class="line"><a id="l03622" name="l03622"></a><span class="lineno"> 3622</span>  handlers.emplace_back(make_unique&lt;Task&gt;(std::move(handler)));</div>
<div class="line"><a id="l03623" name="l03623"></a><span class="lineno"> 3623</span>}</div>
<div class="line"><a id="l03624" name="l03624"></a><span class="lineno"> 3624</span> </div>
<div class="line"><a id="l03625" name="l03625"></a><span class="lineno"> 3625</span><a class="code hl_define" href="ipc__transport__structured_2src_2ipc_2transport_2struc_2sync__io_2channel_8hpp.html#a50e1bb663274c68c760263342ddfdcbc">TEMPLATE_SIO_STRUCT_CHANNEL</a></div>
<div class="line"><a id="l03626" name="l03626"></a><span class="lineno"><a class="line" href="classipc_1_1transport_1_1struc_1_1sync__io_1_1Channel.html#a3a0adf8ce8fc29ec55b4c8c30886c1fc"> 3626</a></span><span class="keywordtype">void</span> CLASS_SIO_STRUCT_CHANNEL::handlers_poll(<a class="code hl_typedef" href="namespaceipc_1_1util.html#ae6ac47812a90d1287c61e0b7de7bc4f5">util::String_view</a> context)</div>
<div class="line"><a id="l03627" name="l03627"></a><span class="lineno"> 3627</span>{</div>
<div class="line"><a id="l03628" name="l03628"></a><span class="lineno"> 3628</span>  <span class="keyword">auto</span>&amp; handlers_ref = m_sync_io_handlers;</div>
<div class="line"><a id="l03629" name="l03629"></a><span class="lineno"> 3629</span> </div>
<div class="line"><a id="l03630" name="l03630"></a><span class="lineno"> 3630</span>  <span class="keywordflow">if</span> (handlers_ref.empty())</div>
<div class="line"><a id="l03631" name="l03631"></a><span class="lineno"> 3631</span>  {</div>
<div class="line"><a id="l03632" name="l03632"></a><span class="lineno"> 3632</span>    <span class="keywordflow">return</span>; <span class="comment">// Don&#39;t log even.</span></div>
<div class="line"><a id="l03633" name="l03633"></a><span class="lineno"> 3633</span>  }</div>
<div class="line"><a id="l03634" name="l03634"></a><span class="lineno"> 3634</span>  <span class="comment">// else</span></div>
<div class="line"><a id="l03635" name="l03635"></a><span class="lineno"> 3635</span> </div>
<div class="line"><a id="l03636" name="l03636"></a><span class="lineno"> 3636</span>  <span class="comment">/* Empty it first.  It is possible the handler itself will un-empty it: we don&#39;t want to trip over ourselves.</span></div>
<div class="line"><a id="l03637" name="l03637"></a><span class="lineno"> 3637</span><span class="comment">   * (Well, no, it is not possible actually, and we&#39;ll assert() to that effect below.  However doing it this way</span></div>
<div class="line"><a id="l03638" name="l03638"></a><span class="lineno"> 3638</span><span class="comment">   * is cleaner in terms of future-proofing/maintenance.) */</span></div>
<div class="line"><a id="l03639" name="l03639"></a><span class="lineno"> 3639</span>  <span class="keyword">const</span> <span class="keyword">auto</span> handlers = std::move(handlers_ref);</div>
<div class="line"><a id="l03640" name="l03640"></a><span class="lineno"> 3640</span>  assert(handlers_ref.empty() &amp;&amp; <span class="stringliteral">&quot;The move() should&#39;ve cleared it.&quot;</span>);</div>
<div class="line"><a id="l03641" name="l03641"></a><span class="lineno"> 3641</span> </div>
<div class="line"><a id="l03642" name="l03642"></a><span class="lineno"> 3642</span>  FLOW_LOG_TRACE(<span class="stringliteral">&quot;struc::Channel [&quot;</span> &lt;&lt; *<span class="keyword">this</span> &lt;&lt; <span class="stringliteral">&quot;]: Flushing [&quot;</span> &lt;&lt; handlers.size() &lt;&lt; <span class="stringliteral">&quot;] ready handlers &quot;</span></div>
<div class="line"><a id="l03643" name="l03643"></a><span class="lineno"> 3643</span>                 <span class="stringliteral">&quot;in context [&quot;</span> &lt;&lt; context &lt;&lt; <span class="stringliteral">&quot;].&quot;</span>);</div>
<div class="line"><a id="l03644" name="l03644"></a><span class="lineno"> 3644</span> </div>
<div class="line"><a id="l03645" name="l03645"></a><span class="lineno"> 3645</span>  <span class="keywordflow">for</span> (<span class="keywordtype">size_t</span> idx = 0; idx != handlers.size(); ++idx)</div>
<div class="line"><a id="l03646" name="l03646"></a><span class="lineno"> 3646</span>  {</div>
<div class="line"><a id="l03647" name="l03647"></a><span class="lineno"> 3647</span>    <span class="keyword">const</span> <span class="keyword">auto</span>&amp; handler = *(handlers[idx]);</div>
<div class="line"><a id="l03648" name="l03648"></a><span class="lineno"> 3648</span>    handler();</div>
<div class="line"><a id="l03649" name="l03649"></a><span class="lineno"> 3649</span> </div>
<div class="line"><a id="l03650" name="l03650"></a><span class="lineno"> 3650</span>    FLOW_LOG_TRACE(<span class="stringliteral">&quot;struc::Channel [&quot;</span> &lt;&lt; *<span class="keyword">this</span> &lt;&lt; <span class="stringliteral">&quot;]: Handler [&quot;</span> &lt;&lt; idx &lt;&lt; <span class="stringliteral">&quot;] (0-based) of &quot;</span></div>
<div class="line"><a id="l03651" name="l03651"></a><span class="lineno"> 3651</span>                   <span class="stringliteral">&quot;[&quot;</span> &lt;&lt; handlers.size() &lt;&lt; <span class="stringliteral">&quot;] (1-based) ready handlers: completed.&quot;</span>);</div>
<div class="line"><a id="l03652" name="l03652"></a><span class="lineno"> 3652</span>  } <span class="comment">// for (idx in [0, handlers.size()))</span></div>
<div class="line"><a id="l03653" name="l03653"></a><span class="lineno"> 3653</span> </div>
<div class="line"><a id="l03654" name="l03654"></a><span class="lineno"> 3654</span>  assert(handlers_ref.empty() &amp;&amp; <span class="stringliteral">&quot;Did handler re-push a handler?  Should not be possible with struc::Channel.&quot;</span>);</div>
<div class="line"><a id="l03655" name="l03655"></a><span class="lineno"> 3655</span>} <span class="comment">// Channel::handlers_poll()</span></div>
<div class="line"><a id="l03656" name="l03656"></a><span class="lineno"> 3656</span> </div>
<div class="line"><a id="l03657" name="l03657"></a><span class="lineno"> 3657</span><a class="code hl_define" href="ipc__transport__structured_2src_2ipc_2transport_2struc_2sync__io_2channel_8hpp.html#a50e1bb663274c68c760263342ddfdcbc">TEMPLATE_SIO_STRUCT_CHANNEL</a></div>
<div class="line"><a id="l03658" name="l03658"></a><span class="lineno"><a class="line" href="classipc_1_1transport_1_1struc_1_1sync__io_1_1Channel.html#ab8bfe06a0aecb261dd11624c4ddec518"> 3658</a></span><span class="keywordtype">bool</span> CLASS_SIO_STRUCT_CHANNEL::rcv_struct_new_internal_msg_in(<span class="keyword">const</span> <a class="code hl_class" href="classipc_1_1transport_1_1struc_1_1Msg__in__impl.html">Msg_in_impl</a>&amp; msg_in_privileged)</div>
<div class="line"><a id="l03659" name="l03659"></a><span class="lineno"> 3659</span>{</div>
<div class="line"><a id="l03660" name="l03660"></a><span class="lineno"> 3660</span>  <span class="keyword">using </span>std::string;</div>
<div class="line"><a id="l03661" name="l03661"></a><span class="lineno"> 3661</span> </div>
<div class="line"><a id="l03662" name="l03662"></a><span class="lineno"> 3662</span>  FLOW_LOG_TRACE(<span class="stringliteral">&quot;struc::Channel [&quot;</span> &lt;&lt; *<span class="keyword">this</span> &lt;&lt; <span class="stringliteral">&quot;]: Deserialized new structured in-message: it is an internal &quot;</span></div>
<div class="line"><a id="l03663" name="l03663"></a><span class="lineno"> 3663</span>                 <span class="stringliteral">&quot;message, meaning it does not carry a user-generated body.&quot;</span>);</div>
<div class="line"><a id="l03664" name="l03664"></a><span class="lineno"> 3664</span>  <span class="keyword">const</span> <span class="keyword">auto</span>&amp; root = msg_in_privileged.<a class="code hl_function" href="classipc_1_1transport_1_1struc_1_1Msg__in__impl.html#a1a57abfeb8dc53f43d20cd0a8bb7def7">internal_msg_body_root</a>();</div>
<div class="line"><a id="l03665" name="l03665"></a><span class="lineno"> 3665</span> </div>
<div class="line"><a id="l03666" name="l03666"></a><span class="lineno"> 3666</span>  <span class="comment">/* Maintenance note: When InternalMessageBody becomes a union -- adds more message types --</span></div>
<div class="line"><a id="l03667" name="l03667"></a><span class="lineno"> 3667</span><span class="comment">   * replace the following with `switch (root.which())`.  For now though there&#39;s only one possibility: */</span></div>
<div class="line"><a id="l03668" name="l03668"></a><span class="lineno"> 3668</span> </div>
<div class="line"><a id="l03669" name="l03669"></a><span class="lineno"> 3669</span>  <span class="keywordflow">if</span> (!root.hasUnexpectedResponse())</div>
<div class="line"><a id="l03670" name="l03670"></a><span class="lineno"> 3670</span>  {</div>
<div class="line"><a id="l03671" name="l03671"></a><span class="lineno"> 3671</span>    FLOW_LOG_WARNING(<span class="stringliteral">&quot;struc::Channel [&quot;</span> &lt;&lt; *<span class="keyword">this</span> &lt;&lt; <span class="stringliteral">&quot;]: Deserialized new structured in-message: it is an internal &quot;</span></div>
<div class="line"><a id="l03672" name="l03672"></a><span class="lineno"> 3672</span>                     <span class="stringliteral">&quot;message, but its type is unknown: currently only `unexpectedResponse` is supported.  &quot;</span></div>
<div class="line"><a id="l03673" name="l03673"></a><span class="lineno"> 3673</span>                     <span class="stringliteral">&quot;This should not be possible under proper remote peer behavior, as we maintain a strict &quot;</span></div>
<div class="line"><a id="l03674" name="l03674"></a><span class="lineno"> 3674</span>                     <span class="stringliteral">&quot;protocol version/capability system.  Other side misbehaved?&quot;</span>);</div>
<div class="line"><a id="l03675" name="l03675"></a><span class="lineno"> 3675</span>    handle_new_error(<a class="code hl_enumvalue" href="namespaceipc_1_1transport_1_1struc_1_1error.html#a990b9ff850cf9aaf354efdd07d86a71da86f9bea5b4ceda65e11b2a3ec7e389f7">error::Code::S_STRUCT_CHANNEL_INTERNAL_PROTOCOL_INTERNAL_MSG_TYPE_UNKNOWN</a>,</div>
<div class="line"><a id="l03676" name="l03676"></a><span class="lineno"> 3676</span>                     <span class="stringliteral">&quot;rcv_struct_new_internal_msg_in()&quot;</span>);</div>
<div class="line"><a id="l03677" name="l03677"></a><span class="lineno"> 3677</span>    <span class="keywordflow">return</span> <span class="keyword">false</span>;</div>
<div class="line"><a id="l03678" name="l03678"></a><span class="lineno"> 3678</span>  }</div>
<div class="line"><a id="l03679" name="l03679"></a><span class="lineno"> 3679</span>  <span class="comment">// else</span></div>
<div class="line"><a id="l03680" name="l03680"></a><span class="lineno"> 3680</span> </div>
<div class="line"><a id="l03681" name="l03681"></a><span class="lineno"> 3681</span>  <span class="keyword">const</span> <span class="keyword">auto</span> originating_msg_id = msg_in_privileged.<a class="code hl_function" href="classipc_1_1transport_1_1struc_1_1Msg__in__impl.html#a0cca042534b3ebee0a90e2c6d7c1c7ca">originating_msg_id_or_none</a>();</div>
<div class="line"><a id="l03682" name="l03682"></a><span class="lineno"> 3682</span>  <span class="keyword">const</span> <span class="keyword">auto</span> rsp_root = root.getUnexpectedResponse();</div>
<div class="line"><a id="l03683" name="l03683"></a><span class="lineno"> 3683</span>  <span class="keyword">const</span> <span class="keywordtype">string</span> mdt_text = rsp_root.getOriginatingMessageMetadataText();</div>
<div class="line"><a id="l03684" name="l03684"></a><span class="lineno"> 3684</span>  FLOW_LOG_TRACE(<span class="stringliteral">&quot;Unexpected-response message regarding earlier out-message with ID [&quot;</span> &lt;&lt; originating_msg_id &lt;&lt; <span class="stringliteral">&quot;]; &quot;</span></div>
<div class="line"><a id="l03685" name="l03685"></a><span class="lineno"> 3685</span>                 <span class="stringliteral">&quot;metadata text = [&quot;</span> &lt;&lt; mdt_text &lt;&lt; <span class="stringliteral">&quot;]; will inform user via special handler if registered.&quot;</span>);</div>
<div class="line"><a id="l03686" name="l03686"></a><span class="lineno"> 3686</span> </div>
<div class="line"><a id="l03687" name="l03687"></a><span class="lineno"> 3687</span>  <span class="keywordflow">if</span> (originating_msg_id == 0)</div>
<div class="line"><a id="l03688" name="l03688"></a><span class="lineno"> 3688</span>  {</div>
<div class="line"><a id="l03689" name="l03689"></a><span class="lineno"> 3689</span>    FLOW_LOG_WARNING(<span class="stringliteral">&quot;struc::Channel [&quot;</span> &lt;&lt; *<span class="keyword">this</span> &lt;&lt; <span class="stringliteral">&quot;]: Deserialized new structured in-message: it is an internal &quot;</span></div>
<div class="line"><a id="l03690" name="l03690"></a><span class="lineno"> 3690</span>                     <span class="stringliteral">&quot;message indicating unexpected response out-message, but the ID of that out-message is 0 which &quot;</span></div>
<div class="line"><a id="l03691" name="l03691"></a><span class="lineno"> 3691</span>                     <span class="stringliteral">&quot;is a violation of our internal protocol.  Other side misbehaved?&quot;</span>);</div>
<div class="line"><a id="l03692" name="l03692"></a><span class="lineno"> 3692</span>    handle_new_error(<a class="code hl_enumvalue" href="namespaceipc_1_1transport_1_1struc_1_1error.html#a990b9ff850cf9aaf354efdd07d86a71da26ab25e100104aeb567d90f794313e3b">error::Code::S_STRUCT_CHANNEL_INTERNAL_PROTOCOL_MISUSED_SCHEMA</a>,</div>
<div class="line"><a id="l03693" name="l03693"></a><span class="lineno"> 3693</span>                     <span class="stringliteral">&quot;rcv_struct_new_internal_msg_in()&quot;</span>);</div>
<div class="line"><a id="l03694" name="l03694"></a><span class="lineno"> 3694</span>    <span class="keywordflow">return</span> <span class="keyword">false</span>;</div>
<div class="line"><a id="l03695" name="l03695"></a><span class="lineno"> 3695</span>  }</div>
<div class="line"><a id="l03696" name="l03696"></a><span class="lineno"> 3696</span>  <span class="comment">// else</span></div>
<div class="line"><a id="l03697" name="l03697"></a><span class="lineno"> 3697</span> </div>
<div class="line"><a id="l03698" name="l03698"></a><span class="lineno"> 3698</span>  handlers_post(<span class="stringliteral">&quot;rcv_struct_new_internal_msg_in()&quot;</span>, [<span class="keyword">this</span>, originating_msg_id, mdt_text = std::move(mdt_text)]</div>
<div class="line"><a id="l03699" name="l03699"></a><span class="lineno"> 3699</span>                                                      () <span class="keyword">mutable</span></div>
<div class="line"><a id="l03700" name="l03700"></a><span class="lineno"> 3700</span>  {</div>
<div class="line"><a id="l03701" name="l03701"></a><span class="lineno"> 3701</span>    <span class="keywordflow">if</span> (m_on_remote_unexpected_response_func_or_empty.empty())</div>
<div class="line"><a id="l03702" name="l03702"></a><span class="lineno"> 3702</span>    {</div>
<div class="line"><a id="l03703" name="l03703"></a><span class="lineno"> 3703</span>      FLOW_LOG_TRACE(<span class="stringliteral">&quot;struc::Channel [&quot;</span> &lt;&lt; *this &lt;&lt; <span class="stringliteral">&quot;]: Would invoke on-remote-unexpected-rsp user handler; &quot;</span></div>
<div class="line"><a id="l03704" name="l03704"></a><span class="lineno"> 3704</span>                     <span class="stringliteral">&quot;but none is configured.  Restating the details: &quot;</span></div>
<div class="line"><a id="l03705" name="l03705"></a><span class="lineno"> 3705</span>                     <span class="stringliteral">&quot;out-message with ID [&quot;</span> &lt;&lt; originating_msg_id &lt;&lt; <span class="stringliteral">&quot;]; metadata text = [&quot;</span> &lt;&lt; mdt_text &lt;&lt; <span class="stringliteral">&quot;].&quot;</span>);</div>
<div class="line"><a id="l03706" name="l03706"></a><span class="lineno"> 3706</span>    }</div>
<div class="line"><a id="l03707" name="l03707"></a><span class="lineno"> 3707</span>    <span class="keywordflow">else</span></div>
<div class="line"><a id="l03708" name="l03708"></a><span class="lineno"> 3708</span>    {</div>
<div class="line"><a id="l03709" name="l03709"></a><span class="lineno"> 3709</span>      FLOW_LOG_TRACE(<span class="stringliteral">&quot;struc::Channel [&quot;</span> &lt;&lt; *this &lt;&lt; <span class="stringliteral">&quot;]: Invoking on-remote-unexpected-rsp user handler.&quot;</span>);</div>
<div class="line"><a id="l03710" name="l03710"></a><span class="lineno"> 3710</span>      m_on_remote_unexpected_response_func_or_empty(originating_msg_id, std::move(mdt_text));</div>
<div class="line"><a id="l03711" name="l03711"></a><span class="lineno"> 3711</span>    }</div>
<div class="line"><a id="l03712" name="l03712"></a><span class="lineno"> 3712</span>  }); <span class="comment">// handlers_post()</span></div>
<div class="line"><a id="l03713" name="l03713"></a><span class="lineno"> 3713</span> </div>
<div class="line"><a id="l03714" name="l03714"></a><span class="lineno"> 3714</span>  <span class="keywordflow">return</span> <span class="keyword">true</span>;</div>
<div class="line"><a id="l03715" name="l03715"></a><span class="lineno"> 3715</span>} <span class="comment">// Channel::rcv_struct_new_internal_msg_in()</span></div>
<div class="line"><a id="l03716" name="l03716"></a><span class="lineno"> 3716</span> </div>
<div class="line"><a id="l03717" name="l03717"></a><span class="lineno"> 3717</span><a class="code hl_define" href="ipc__transport__structured_2src_2ipc_2transport_2struc_2sync__io_2channel_8hpp.html#a50e1bb663274c68c760263342ddfdcbc">TEMPLATE_SIO_STRUCT_CHANNEL</a></div>
<div class="line"><a id="l03718" name="l03718"></a><span class="lineno"><a class="line" href="classipc_1_1transport_1_1struc_1_1sync__io_1_1Channel.html#aff04d908fa53c7df582f3b2b6e51cfce"> 3718</a></span><span class="keywordtype">bool</span> CLASS_SIO_STRUCT_CHANNEL::rcv_struct_new_msg_in_during_log_in_as_cli(<a class="code hl_typedef" href="classipc_1_1transport_1_1struc_1_1sync__io_1_1Channel.html#a84287334d14f54c97f7dbb0d5b04cca5">Msg_in_ptr_uniq</a>&amp;&amp; msg_in_moved)</div>
<div class="line"><a id="l03719" name="l03719"></a><span class="lineno"> 3719</span>{</div>
<div class="line"><a id="l03720" name="l03720"></a><span class="lineno"> 3720</span>  <a class="code hl_typedef" href="classipc_1_1transport_1_1struc_1_1sync__io_1_1Channel.html#a84287334d14f54c97f7dbb0d5b04cca5">Msg_in_ptr_uniq</a> msg_in(std::move(msg_in_moved));</div>
<div class="line"><a id="l03721" name="l03721"></a><span class="lineno"> 3721</span>  <span class="comment">// msg_in_moved is now nullified as promised.  We own the Msg_in.</span></div>
<div class="line"><a id="l03722" name="l03722"></a><span class="lineno"> 3722</span>  <span class="keyword">auto</span>&amp; msg_in_privileged = *msg_in;</div>
<div class="line"><a id="l03723" name="l03723"></a><span class="lineno"> 3723</span> </div>
<div class="line"><a id="l03724" name="l03724"></a><span class="lineno"> 3724</span>  <span class="comment">/* We are the logging-in client (CLI_LOG_IN).  During this phase the only message we can receive is</span></div>
<div class="line"><a id="l03725" name="l03725"></a><span class="lineno"> 3725</span><span class="comment">   * a single log-in response to the log-in request we&#39;d earlier sent.  So now we shall ascertain that is</span></div>
<div class="line"><a id="l03726" name="l03726"></a><span class="lineno"> 3726</span><span class="comment">   * what is happening.  Namely:</span></div>
<div class="line"><a id="l03727" name="l03727"></a><span class="lineno"> 3727</span><span class="comment">   *   - m_rcv_expecting_response_map must have exactly 1 registered-for-response message (the log-in).</span></div>
<div class="line"><a id="l03728" name="l03728"></a><span class="lineno"> 3728</span><span class="comment">   *     - How this can break:</span></div>
<div class="line"><a id="l03729" name="l03729"></a><span class="lineno"> 3729</span><span class="comment">   *       - If they hadn&#39;t (successfully, meaning with an on-response handler provided) send()t the log-in request.</span></div>
<div class="line"><a id="l03730" name="l03730"></a><span class="lineno"> 3730</span><span class="comment">   *       - If they hadn&#39;t even constructed the latter at all.</span></div>
<div class="line"><a id="l03731" name="l03731"></a><span class="lineno"> 3731</span><span class="comment">   *   - msg_in is a response, and it indeed indicates the log-in out-message (by necessity having msg_id_out_t = 1)</span></div>
<div class="line"><a id="l03732" name="l03732"></a><span class="lineno"> 3732</span><span class="comment">   *     is the originating message to which it is a response.</span></div>
<div class="line"><a id="l03733" name="l03733"></a><span class="lineno"> 3733</span><span class="comment">   *     - It has a non-nil session-token... which, by the way, we save onto our currently-nil m_session_token!</span></div>
<div class="line"><a id="l03734" name="l03734"></a><span class="lineno"> 3734</span><span class="comment">   *       Oh and m_phase shall go to LOGGED_IN foreva!</span></div>
<div class="line"><a id="l03735" name="l03735"></a><span class="lineno"> 3735</span><span class="comment">   *     - How these can break: By the other side misbehaving.</span></div>
<div class="line"><a id="l03736" name="l03736"></a><span class="lineno"> 3736</span><span class="comment">   *   - Note: We could assert() a bunch of other things (@todo maybe we should), but I&#39;m (ygoldfel) fairly</span></div>
<div class="line"><a id="l03737" name="l03737"></a><span class="lineno"> 3737</span><span class="comment">   *     confident we wouldn&#39;t have allowed any other ways of breaking this; that&#39;s why we prohibit general</span></div>
<div class="line"><a id="l03738" name="l03738"></a><span class="lineno"> 3738</span><span class="comment">   *     expect_msg(), etc., etc., until logged-in phase.</span></div>
<div class="line"><a id="l03739" name="l03739"></a><span class="lineno"> 3739</span><span class="comment">   *</span></div>
<div class="line"><a id="l03740" name="l03740"></a><span class="lineno"> 3740</span><span class="comment">   * Let&#39;s go.... */</span></div>
<div class="line"><a id="l03741" name="l03741"></a><span class="lineno"> 3741</span> </div>
<div class="line"><a id="l03742" name="l03742"></a><span class="lineno"> 3742</span>  <span class="keywordflow">if</span> (m_rcv_expecting_response_map.size() != 1)</div>
<div class="line"><a id="l03743" name="l03743"></a><span class="lineno"> 3743</span>  {</div>
<div class="line"><a id="l03744" name="l03744"></a><span class="lineno"> 3744</span>    FLOW_LOG_WARNING(<span class="stringliteral">&quot;struc::Channel [&quot;</span> &lt;&lt; *<span class="keyword">this</span> &lt;&lt; <span class="stringliteral">&quot;]: Log-in: Would-be log-in response message &quot;</span></div>
<div class="line"><a id="l03745" name="l03745"></a><span class="lineno"> 3745</span>                     <span class="stringliteral">&quot;received outside the situation where we&#39;d sent the log-in request and are awaiting response; &quot;</span></div>
<div class="line"><a id="l03746" name="l03746"></a><span class="lineno"> 3746</span>                     <span class="stringliteral">&quot;the await-rsp map should have 1 element but instead has &quot;</span></div>
<div class="line"><a id="l03747" name="l03747"></a><span class="lineno"> 3747</span>                     <span class="stringliteral">&quot;[&quot;</span> &lt;&lt; m_rcv_expecting_response_map.size() &lt;&lt; <span class="stringliteral">&quot;].  Other side misbehaved?&quot;</span>);</div>
<div class="line"><a id="l03748" name="l03748"></a><span class="lineno"> 3748</span>    handle_new_error(<a class="code hl_enumvalue" href="namespaceipc_1_1transport_1_1struc_1_1error.html#a990b9ff850cf9aaf354efdd07d86a71daab47c241a659164b808ddba23736d02b">error::Code::S_STRUCT_CHANNEL_INTERNAL_PROTOCOL_LOG_IN_MISUSED_SCHEMA</a>,</div>
<div class="line"><a id="l03749" name="l03749"></a><span class="lineno"> 3749</span>                     <span class="stringliteral">&quot;rcv_struct_new_msg_in_during_log_in_as_cli()&quot;</span>);</div>
<div class="line"><a id="l03750" name="l03750"></a><span class="lineno"> 3750</span>    <span class="keywordflow">return</span> <span class="keyword">false</span>;</div>
<div class="line"><a id="l03751" name="l03751"></a><span class="lineno"> 3751</span>  }</div>
<div class="line"><a id="l03752" name="l03752"></a><span class="lineno"> 3752</span>  <span class="comment">// else</span></div>
<div class="line"><a id="l03753" name="l03753"></a><span class="lineno"> 3753</span> </div>
<div class="line"><a id="l03754" name="l03754"></a><span class="lineno"> 3754</span>  assert(flow::util::key_exists(m_rcv_expecting_response_map, 1)</div>
<div class="line"><a id="l03755" name="l03755"></a><span class="lineno"> 3755</span>         &amp;&amp; <span class="stringliteral">&quot;During CLI_LOG_IN the message expecting response must be the log-in request, with ID 1.&quot;</span>);</div>
<div class="line"><a id="l03756" name="l03756"></a><span class="lineno"> 3756</span> </div>
<div class="line"><a id="l03757" name="l03757"></a><span class="lineno"> 3757</span>  <span class="keywordflow">if</span> (msg_in_privileged.originating_msg_id_or_none() != 1)</div>
<div class="line"><a id="l03758" name="l03758"></a><span class="lineno"> 3758</span>  {</div>
<div class="line"><a id="l03759" name="l03759"></a><span class="lineno"> 3759</span>    FLOW_LOG_WARNING(<span class="stringliteral">&quot;struc::Channel [&quot;</span> &lt;&lt; *<span class="keyword">this</span> &lt;&lt; <span class="stringliteral">&quot;]: Log-in: Would-be log-in response message &quot;</span></div>
<div class="line"><a id="l03760" name="l03760"></a><span class="lineno"> 3760</span>                     <span class="stringliteral">&quot;received as expected -- except it does not specify originating message ID=1 as required &quot;</span></div>
<div class="line"><a id="l03761" name="l03761"></a><span class="lineno"> 3761</span>                     <span class="stringliteral">&quot;in this specific situation; it specifies &quot;</span></div>
<div class="line"><a id="l03762" name="l03762"></a><span class="lineno"> 3762</span>                     <span class="stringliteral">&quot;[&quot;</span> &lt;&lt; msg_in_privileged.originating_msg_id_or_none() &lt;&lt; <span class="stringliteral">&quot;].  Other side misbehaved?&quot;</span>);</div>
<div class="line"><a id="l03763" name="l03763"></a><span class="lineno"> 3763</span>    handle_new_error(<a class="code hl_enumvalue" href="namespaceipc_1_1transport_1_1struc_1_1error.html#a990b9ff850cf9aaf354efdd07d86a71daab47c241a659164b808ddba23736d02b">error::Code::S_STRUCT_CHANNEL_INTERNAL_PROTOCOL_LOG_IN_MISUSED_SCHEMA</a>,</div>
<div class="line"><a id="l03764" name="l03764"></a><span class="lineno"> 3764</span>                     <span class="stringliteral">&quot;rcv_struct_new_msg_in_during_log_in_as_cli()&quot;</span>);</div>
<div class="line"><a id="l03765" name="l03765"></a><span class="lineno"> 3765</span>    <span class="keywordflow">return</span> <span class="keyword">false</span>;</div>
<div class="line"><a id="l03766" name="l03766"></a><span class="lineno"> 3766</span>  }</div>
<div class="line"><a id="l03767" name="l03767"></a><span class="lineno"> 3767</span>  <span class="comment">// else</span></div>
<div class="line"><a id="l03768" name="l03768"></a><span class="lineno"> 3768</span> </div>
<div class="line"><a id="l03769" name="l03769"></a><span class="lineno"> 3769</span>  assert(m_session_token.is_nil() &amp;&amp; <span class="stringliteral">&quot;While CLI_LOG_IN our saved session_token must be nil.&quot;</span>);</div>
<div class="line"><a id="l03770" name="l03770"></a><span class="lineno"> 3770</span>  m_session_token = msg_in_privileged.session_token();</div>
<div class="line"><a id="l03771" name="l03771"></a><span class="lineno"> 3771</span>  <span class="keywordflow">if</span> (m_session_token.is_nil())</div>
<div class="line"><a id="l03772" name="l03772"></a><span class="lineno"> 3772</span>  {</div>
<div class="line"><a id="l03773" name="l03773"></a><span class="lineno"> 3773</span>    FLOW_LOG_WARNING(<span class="stringliteral">&quot;struc::Channel [&quot;</span> &lt;&lt; *<span class="keyword">this</span> &lt;&lt; <span class="stringliteral">&quot;]: Log-in: Would-be log-in response message &quot;</span></div>
<div class="line"><a id="l03774" name="l03774"></a><span class="lineno"> 3774</span>                     <span class="stringliteral">&quot;received as expected and is a response to the log-in request; but it lacks a non-nil &quot;</span></div>
<div class="line"><a id="l03775" name="l03775"></a><span class="lineno"> 3775</span>                     <span class="stringliteral">&quot;session-token!  Cannot complete log-in.  Other side misbehaved?&quot;</span>);</div>
<div class="line"><a id="l03776" name="l03776"></a><span class="lineno"> 3776</span>    handle_new_error(<a class="code hl_enumvalue" href="namespaceipc_1_1transport_1_1struc_1_1error.html#a990b9ff850cf9aaf354efdd07d86a71daab47c241a659164b808ddba23736d02b">error::Code::S_STRUCT_CHANNEL_INTERNAL_PROTOCOL_LOG_IN_MISUSED_SCHEMA</a>,</div>
<div class="line"><a id="l03777" name="l03777"></a><span class="lineno"> 3777</span>                     <span class="stringliteral">&quot;rcv_struct_new_msg_in_during_log_in_as_cli()&quot;</span>);</div>
<div class="line"><a id="l03778" name="l03778"></a><span class="lineno"> 3778</span>    <span class="keywordflow">return</span> <span class="keyword">false</span>;</div>
<div class="line"><a id="l03779" name="l03779"></a><span class="lineno"> 3779</span>  }</div>
<div class="line"><a id="l03780" name="l03780"></a><span class="lineno"> 3780</span>  <span class="comment">// else if (we&#39;ve updated m_session_token to its foreva-value):</span></div>
<div class="line"><a id="l03781" name="l03781"></a><span class="lineno"> 3781</span> </div>
<div class="line"><a id="l03782" name="l03782"></a><span class="lineno"> 3782</span>  FLOW_LOG_INFO(<span class="stringliteral">&quot;struc::Channel [&quot;</span> &lt;&lt; *<span class="keyword">this</span> &lt;&lt; <span class="stringliteral">&quot;]: Log-in: Would-be log-in response message &quot;</span></div>
<div class="line"><a id="l03783" name="l03783"></a><span class="lineno"> 3783</span>                <span class="stringliteral">&quot;received as expected and is a response to the log-in request; session token &quot;</span></div>
<div class="line"><a id="l03784" name="l03784"></a><span class="lineno"> 3784</span>                <span class="stringliteral">&quot;[&quot;</span> &lt;&lt; m_session_token &lt;&lt; <span class="stringliteral">&quot;] saved; entering LOGGED_IN phase.&quot;</span>);</div>
<div class="line"><a id="l03785" name="l03785"></a><span class="lineno"> 3785</span>  m_phase = Phase::S_LOGGED_IN;</div>
<div class="line"><a id="l03786" name="l03786"></a><span class="lineno"> 3786</span> </div>
<div class="line"><a id="l03787" name="l03787"></a><span class="lineno"> 3787</span>  <span class="comment">/* Awesome!  So now we can just use the general code path, same as what the logged-in case invokes for the</span></div>
<div class="line"><a id="l03788" name="l03788"></a><span class="lineno"> 3788</span><span class="comment">   * new in-order message (individually -- it doesn&#39;t worry about then scanning the reassembly queue).</span></div>
<div class="line"><a id="l03789" name="l03789"></a><span class="lineno"> 3789</span><span class="comment">   * It will do some slight re-computations like the above is-it-a-response check, but that&#39;s fine; they&#39;re</span></div>
<div class="line"><a id="l03790" name="l03790"></a><span class="lineno"> 3790</span><span class="comment">   * quick and easy, and it&#39;s worth it for the simpler code.</span></div>
<div class="line"><a id="l03791" name="l03791"></a><span class="lineno"> 3791</span><span class="comment">   *</span></div>
<div class="line"><a id="l03792" name="l03792"></a><span class="lineno"> 3792</span><span class="comment">   * We just needed to check that and save the session-token and update m_phase; now everything is normal</span></div>
<div class="line"><a id="l03793" name="l03793"></a><span class="lineno"> 3793</span><span class="comment">   * forever (in the shiny new LOGGED_IN phase). */</span></div>
<div class="line"><a id="l03794" name="l03794"></a><span class="lineno"> 3794</span>  <span class="keywordflow">return</span> rcv_struct_new_msg_in_is_next_expected(std::move(msg_in));</div>
<div class="line"><a id="l03795" name="l03795"></a><span class="lineno"> 3795</span>} <span class="comment">// Channel::rcv_struct_new_msg_in_during_log_in_as_cli()</span></div>
<div class="line"><a id="l03796" name="l03796"></a><span class="lineno"> 3796</span> </div>
<div class="line"><a id="l03797" name="l03797"></a><span class="lineno"> 3797</span><a class="code hl_define" href="ipc__transport__structured_2src_2ipc_2transport_2struc_2sync__io_2channel_8hpp.html#a50e1bb663274c68c760263342ddfdcbc">TEMPLATE_SIO_STRUCT_CHANNEL</a></div>
<div class="line"><a id="l03798" name="l03798"></a><span class="lineno"><a class="line" href="classipc_1_1transport_1_1struc_1_1sync__io_1_1Channel.html#a9174c694ee8437605c089965ecea2ebf"> 3798</a></span><span class="keywordtype">bool</span> CLASS_SIO_STRUCT_CHANNEL::rcv_struct_new_msg_in_during_log_in_as_srv(<a class="code hl_typedef" href="classipc_1_1transport_1_1struc_1_1sync__io_1_1Channel.html#a84287334d14f54c97f7dbb0d5b04cca5">Msg_in_ptr_uniq</a>&amp;&amp; msg_in_moved)</div>
<div class="line"><a id="l03799" name="l03799"></a><span class="lineno"> 3799</span>{</div>
<div class="line"><a id="l03800" name="l03800"></a><span class="lineno"> 3800</span>  <a class="code hl_typedef" href="classipc_1_1transport_1_1struc_1_1sync__io_1_1Channel.html#a84287334d14f54c97f7dbb0d5b04cca5">Msg_in_ptr_uniq</a> msg_in(std::move(msg_in_moved));</div>
<div class="line"><a id="l03801" name="l03801"></a><span class="lineno"> 3801</span>  <span class="comment">// msg_in_moved is now nullified as promised.  We own the Msg_in.</span></div>
<div class="line"><a id="l03802" name="l03802"></a><span class="lineno"> 3802</span>  <span class="keyword">const</span> <span class="keyword">auto</span> which = msg_in-&gt;body_root().which();</div>
<div class="line"><a id="l03803" name="l03803"></a><span class="lineno"> 3803</span>  <span class="keyword">auto</span>&amp; msg_in_privileged = *msg_in;</div>
<div class="line"><a id="l03804" name="l03804"></a><span class="lineno"> 3804</span> </div>
<div class="line"><a id="l03805" name="l03805"></a><span class="lineno"> 3805</span>  <span class="comment">/* We are the logged-in-to server (SRV_LOG_IN).  During this phase the only message we can receive is</span></div>
<div class="line"><a id="l03806" name="l03806"></a><span class="lineno"> 3806</span><span class="comment">   * a single log-in request which either is expected due to expect_log_in_request() -- or isn&#39;t, but then</span></div>
<div class="line"><a id="l03807" name="l03807"></a><span class="lineno"> 3807</span><span class="comment">   * they can call it later (and if so they&#39;ll only be allowed to call it with the Which received here --</span></div>
<div class="line"><a id="l03808" name="l03808"></a><span class="lineno"> 3808</span><span class="comment">   * or it&#39;s a protocol error... but that&#39;s not our problem here).  So now we shall ascertain that is what is</span></div>
<div class="line"><a id="l03809" name="l03809"></a><span class="lineno"> 3809</span><span class="comment">   * happening.  Namely:</span></div>
<div class="line"><a id="l03810" name="l03810"></a><span class="lineno"> 3810</span><span class="comment">   *   - msg_in isn&#39;t a response to anything (is unsolicited: notification or request).</span></div>
<div class="line"><a id="l03811" name="l03811"></a><span class="lineno"> 3811</span><span class="comment">   *     Subtlety: It can&#39;t be a response to anything anyway: in SRV_LOG_IN we cannot send</span></div>
<div class="line"><a id="l03812" name="l03812"></a><span class="lineno"> 3812</span><span class="comment">   *     anything except the log-in response (which cannot happen until we process the present log-in,</span></div>
<div class="line"><a id="l03813" name="l03813"></a><span class="lineno"> 3813</span><span class="comment">   *     by advertised contract of expect_log_in_request()), so there&#39;s nothing to which to respond, and this would</span></div>
<div class="line"><a id="l03814" name="l03814"></a><span class="lineno"> 3814</span><span class="comment">   *     be detected in regular rcv_struct_new_msg_in_is_next_expected() we&#39;d call below.</span></div>
<div class="line"><a id="l03815" name="l03815"></a><span class="lineno"> 3815</span><span class="comment">   *     However, receiving an unexpected response</span></div>
<div class="line"><a id="l03816" name="l03816"></a><span class="lineno"> 3816</span><span class="comment">   *     is not (unlike most mistmatches) considered a pipe-hosing error but instead a user error normally</span></div>
<div class="line"><a id="l03817" name="l03817"></a><span class="lineno"> 3817</span><span class="comment">   *     reported via set_unexpected_response_handler() (etc.) -- which they can treat how they want.</span></div>
<div class="line"><a id="l03818" name="l03818"></a><span class="lineno"> 3818</span><span class="comment">   *     In this case, during log-in, we want to be totally rigid and just outlaw the whole situation totally.</span></div>
<div class="line"><a id="l03819" name="l03819"></a><span class="lineno"> 3819</span><span class="comment">   *     - How this can break: Remote peer could send a reponse.  Actually this wouldn&#39;t be easy: there&#39;s no</span></div>
<div class="line"><a id="l03820" name="l03820"></a><span class="lineno"> 3820</span><span class="comment">   *       API that&#39;ll work for it in the CLI_LOG_IN phase... but who knows what code they have; we err on the</span></div>
<div class="line"><a id="l03821" name="l03821"></a><span class="lineno"> 3821</span><span class="comment">   *       side of &lt;whatever&gt;.</span></div>
<div class="line"><a id="l03822" name="l03822"></a><span class="lineno"> 3822</span><span class="comment">   *   - m_rcv_expecting_msg_map has either 0 or 1 registered expectation.</span></div>
<div class="line"><a id="l03823" name="l03823"></a><span class="lineno"> 3823</span><span class="comment">   *     - If the latter: its Msg_which_in must equal the one in msg_in (in-message received here).</span></div>
<div class="line"><a id="l03824" name="l03824"></a><span class="lineno"> 3824</span><span class="comment">   *       - How this can break: If they called expect_log_in_request() but with a different `which` than</span></div>
<div class="line"><a id="l03825" name="l03825"></a><span class="lineno"> 3825</span><span class="comment">   *         delivered here.  Could be local user error; remote user error; or both.</span></div>
<div class="line"><a id="l03826" name="l03826"></a><span class="lineno"> 3826</span><span class="comment">   *     - If the former: this one will be cached to match up to a future expect_log_in_request() message... but</span></div>
<div class="line"><a id="l03827" name="l03827"></a><span class="lineno"> 3827</span><span class="comment">   *       it must be the only one thus cached (only one log-in request is allowed).</span></div>
<div class="line"><a id="l03828" name="l03828"></a><span class="lineno"> 3828</span><span class="comment">   *       - How this can break: Remote peer could send a request 2x.  Actually this wouldn&#39;t be easy: there&#39;s no</span></div>
<div class="line"><a id="l03829" name="l03829"></a><span class="lineno"> 3829</span><span class="comment">   *         API that&#39;ll work for it in the CLI_LOG_IN phase... but who knows what code they have; we err on the</span></div>
<div class="line"><a id="l03830" name="l03830"></a><span class="lineno"> 3830</span><span class="comment">   *         side of &lt;whatever&gt;.</span></div>
<div class="line"><a id="l03831" name="l03831"></a><span class="lineno"> 3831</span><span class="comment">   *   - Note: We could assert() a bunch of other things (some, we do; @todo maybe we should do more),</span></div>
<div class="line"><a id="l03832" name="l03832"></a><span class="lineno"> 3832</span><span class="comment">   *     but I&#39;m (ygoldfel) fairly confident we wouldn&#39;t have allowed any other ways of breaking this; that&#39;s why</span></div>
<div class="line"><a id="l03833" name="l03833"></a><span class="lineno"> 3833</span><span class="comment">   *     we prohibit general expect_msg(), etc., etc., until logged-in phase.</span></div>
<div class="line"><a id="l03834" name="l03834"></a><span class="lineno"> 3834</span><span class="comment">   *</span></div>
<div class="line"><a id="l03835" name="l03835"></a><span class="lineno"> 3835</span><span class="comment">   * Let&#39;s go.... */</span></div>
<div class="line"><a id="l03836" name="l03836"></a><span class="lineno"> 3836</span> </div>
<div class="line"><a id="l03837" name="l03837"></a><span class="lineno"> 3837</span>  assert(m_rcv_expecting_response_map.empty() &amp;&amp; <span class="stringliteral">&quot;Only a single expect_log_in_request() allowed in SRV_LOG_IN phase.&quot;</span>);</div>
<div class="line"><a id="l03838" name="l03838"></a><span class="lineno"> 3838</span>  <span class="keywordflow">if</span> (msg_in_privileged.originating_msg_id_or_none() != 0)</div>
<div class="line"><a id="l03839" name="l03839"></a><span class="lineno"> 3839</span>  {</div>
<div class="line"><a id="l03840" name="l03840"></a><span class="lineno"> 3840</span>    FLOW_LOG_WARNING(<span class="stringliteral">&quot;struc::Channel [&quot;</span> &lt;&lt; *<span class="keyword">this</span> &lt;&lt; <span class="stringliteral">&quot;]: Log-in: Would-be log-in request message &quot;</span></div>
<div class="line"><a id="l03841" name="l03841"></a><span class="lineno"> 3841</span>                     <span class="stringliteral">&quot;received -- except it&#39;s a response to something; this is illegal.  Other side misbehaved?&quot;</span>);</div>
<div class="line"><a id="l03842" name="l03842"></a><span class="lineno"> 3842</span>    handle_new_error(<a class="code hl_enumvalue" href="namespaceipc_1_1transport_1_1struc_1_1error.html#a990b9ff850cf9aaf354efdd07d86a71daab47c241a659164b808ddba23736d02b">error::Code::S_STRUCT_CHANNEL_INTERNAL_PROTOCOL_LOG_IN_MISUSED_SCHEMA</a>,</div>
<div class="line"><a id="l03843" name="l03843"></a><span class="lineno"> 3843</span>                     <span class="stringliteral">&quot;rcv_struct_new_msg_in_during_log_in_as_srv()&quot;</span>);</div>
<div class="line"><a id="l03844" name="l03844"></a><span class="lineno"> 3844</span>    <span class="keywordflow">return</span> <span class="keyword">false</span>;</div>
<div class="line"><a id="l03845" name="l03845"></a><span class="lineno"> 3845</span>  }</div>
<div class="line"><a id="l03846" name="l03846"></a><span class="lineno"> 3846</span>  <span class="comment">// else if (it&#39;s not a response; is unsolicited): OK, perform the other checks above.</span></div>
<div class="line"><a id="l03847" name="l03847"></a><span class="lineno"> 3847</span> </div>
<div class="line"><a id="l03848" name="l03848"></a><span class="lineno"> 3848</span>  <span class="keywordflow">if</span> (m_rcv_expecting_msg_map.size() == 1)</div>
<div class="line"><a id="l03849" name="l03849"></a><span class="lineno"> 3849</span>  {</div>
<div class="line"><a id="l03850" name="l03850"></a><span class="lineno"> 3850</span>    <span class="keyword">const</span> <span class="keyword">auto</span> exp_which = m_rcv_expecting_msg_map.begin()-&gt;first;</div>
<div class="line"><a id="l03851" name="l03851"></a><span class="lineno"> 3851</span>    <span class="keywordflow">if</span> (exp_which != which)</div>
<div class="line"><a id="l03852" name="l03852"></a><span class="lineno"> 3852</span>    {</div>
<div class="line"><a id="l03853" name="l03853"></a><span class="lineno"> 3853</span>      FLOW_LOG_WARNING(<span class="stringliteral">&quot;struc::Channel [&quot;</span> &lt;&lt; *<span class="keyword">this</span> &lt;&lt; <span class="stringliteral">&quot;]: Log-in: Would-be log-in request message &quot;</span></div>
<div class="line"><a id="l03854" name="l03854"></a><span class="lineno"> 3854</span>                       <span class="stringliteral">&quot;received as expected -- except it does not specify union-which = [&quot;</span> &lt;&lt; <span class="keywordtype">int</span>(exp_which) &lt;&lt; <span class="stringliteral">&quot;] &quot;</span></div>
<div class="line"><a id="l03855" name="l03855"></a><span class="lineno"> 3855</span>                       <span class="stringliteral">&quot;as specified by earlier local expect_log_in_request() call but rather &quot;</span></div>
<div class="line"><a id="l03856" name="l03856"></a><span class="lineno"> 3856</span>                       <span class="stringliteral">&quot;[&quot;</span> &lt;&lt; <span class="keywordtype">int</span>(which) &lt;&lt; <span class="stringliteral">&quot;].  This might be a protocol error on the user&#39;s part on this &quot;</span></div>
<div class="line"><a id="l03857" name="l03857"></a><span class="lineno"> 3857</span>                       <span class="stringliteral">&quot;or other side or both.&quot;</span>);</div>
<div class="line"><a id="l03858" name="l03858"></a><span class="lineno"> 3858</span>      <span class="comment">/* Subtlety: Normally we&#39;d emit S_STRUCT_CHANNEL_INTERNAL_PROTOCOL_LOG_IN_MISUSED_SCHEMA; but that&#39;s for</span></div>
<div class="line"><a id="l03859" name="l03859"></a><span class="lineno"> 3859</span><span class="comment">       * internal errors -- in this case the error can/is the user&#39;s by saying they expect X locally but sending</span></div>
<div class="line"><a id="l03860" name="l03860"></a><span class="lineno"> 3860</span><span class="comment">       * Y remotely; both X and Y are user decisions.  So it&#39;s not an internal error. */</span></div>
<div class="line"><a id="l03861" name="l03861"></a><span class="lineno"> 3861</span>      handle_new_error(<a class="code hl_enumvalue" href="namespaceipc_1_1transport_1_1struc_1_1error.html#a990b9ff850cf9aaf354efdd07d86a71dad88bc7df9bd2dcdf4370585c912a9a61">error::Code::S_STRUCT_CHANNEL_GOT_UNEXPECTED_LOG_IN_REQUEST</a>,</div>
<div class="line"><a id="l03862" name="l03862"></a><span class="lineno"> 3862</span>                       <span class="stringliteral">&quot;rcv_struct_new_msg_in_during_log_in_as_srv()&quot;</span>);</div>
<div class="line"><a id="l03863" name="l03863"></a><span class="lineno"> 3863</span>      <span class="keywordflow">return</span> <span class="keyword">false</span>;</div>
<div class="line"><a id="l03864" name="l03864"></a><span class="lineno"> 3864</span>    }</div>
<div class="line"><a id="l03865" name="l03865"></a><span class="lineno"> 3865</span>    <span class="comment">// else</span></div>
<div class="line"><a id="l03866" name="l03866"></a><span class="lineno"> 3866</span> </div>
<div class="line"><a id="l03867" name="l03867"></a><span class="lineno"> 3867</span>    FLOW_LOG_TRACE(<span class="stringliteral">&quot;struc::Channel [&quot;</span> &lt;&lt; *<span class="keyword">this</span> &lt;&lt; <span class="stringliteral">&quot;]: Log-in: Would-be log-in request message &quot;</span></div>
<div class="line"><a id="l03868" name="l03868"></a><span class="lineno"> 3868</span>                   <span class="stringliteral">&quot;received as expected -- and it specifies union-which = [&quot;</span> &lt;&lt; <span class="keywordtype">int</span>(exp_which) &lt;&lt; <span class="stringliteral">&quot;] &quot;</span></div>
<div class="line"><a id="l03869" name="l03869"></a><span class="lineno"> 3869</span>                   <span class="stringliteral">&quot;as specified by earlier local expect_log_in_request() call.&quot;</span>);</div>
<div class="line"><a id="l03870" name="l03870"></a><span class="lineno"> 3870</span>  } <span class="comment">// if (m_rcv_expecting_msg_map.size() == 1)</span></div>
<div class="line"><a id="l03871" name="l03871"></a><span class="lineno"> 3871</span>  <span class="keywordflow">else</span> <span class="comment">// if (m_rcv_expecting_msg_map.size() == 0, or &gt;= 2)</span></div>
<div class="line"><a id="l03872" name="l03872"></a><span class="lineno"> 3872</span>  {</div>
<div class="line"><a id="l03873" name="l03873"></a><span class="lineno"> 3873</span>    assert(m_rcv_expecting_msg_map.empty() &amp;&amp; <span class="stringliteral">&quot;Only a single expect_log_in_request() allowed in SRV_LOG_IN phase.&quot;</span>);</div>
<div class="line"><a id="l03874" name="l03874"></a><span class="lineno"> 3874</span> </div>
<div class="line"><a id="l03875" name="l03875"></a><span class="lineno"> 3875</span>    <span class="keywordflow">if</span> (!m_rcv_pending_msgs.empty())</div>
<div class="line"><a id="l03876" name="l03876"></a><span class="lineno"> 3876</span>    {</div>
<div class="line"><a id="l03877" name="l03877"></a><span class="lineno"> 3877</span>      FLOW_LOG_WARNING(<span class="stringliteral">&quot;struc::Channel [&quot;</span> &lt;&lt; *<span class="keyword">this</span> &lt;&lt; <span class="stringliteral">&quot;]: Log-in: Would-be log-in request message &quot;</span></div>
<div class="line"><a id="l03878" name="l03878"></a><span class="lineno"> 3878</span>                       <span class="stringliteral">&quot;received as expected -- but no expect_log_in_request() registered yet.  Would await that &quot;</span></div>
<div class="line"><a id="l03879" name="l03879"></a><span class="lineno"> 3879</span>                       <span class="stringliteral">&quot;and ensure its union-which matches -- except apparently such a would-be log-in request &quot;</span></div>
<div class="line"><a id="l03880" name="l03880"></a><span class="lineno"> 3880</span>                       <span class="stringliteral">&quot;has already been received and cached; this is not allowed.  Other side misbehaved?&quot;</span>);</div>
<div class="line"><a id="l03881" name="l03881"></a><span class="lineno"> 3881</span>      handle_new_error(<a class="code hl_enumvalue" href="namespaceipc_1_1transport_1_1struc_1_1error.html#a990b9ff850cf9aaf354efdd07d86a71daab47c241a659164b808ddba23736d02b">error::Code::S_STRUCT_CHANNEL_INTERNAL_PROTOCOL_LOG_IN_MISUSED_SCHEMA</a>,</div>
<div class="line"><a id="l03882" name="l03882"></a><span class="lineno"> 3882</span>                       <span class="stringliteral">&quot;rcv_struct_new_msg_in_during_log_in_as_srv()&quot;</span>);</div>
<div class="line"><a id="l03883" name="l03883"></a><span class="lineno"> 3883</span>      <span class="keywordflow">return</span> <span class="keyword">false</span>;</div>
<div class="line"><a id="l03884" name="l03884"></a><span class="lineno"> 3884</span>    }</div>
<div class="line"><a id="l03885" name="l03885"></a><span class="lineno"> 3885</span>    <span class="comment">// else</span></div>
<div class="line"><a id="l03886" name="l03886"></a><span class="lineno"> 3886</span> </div>
<div class="line"><a id="l03887" name="l03887"></a><span class="lineno"> 3887</span>    FLOW_LOG_TRACE(<span class="stringliteral">&quot;struc::Channel [&quot;</span> &lt;&lt; *<span class="keyword">this</span> &lt;&lt; <span class="stringliteral">&quot;]: Log-in: Would-be log-in request message &quot;</span></div>
<div class="line"><a id="l03888" name="l03888"></a><span class="lineno"> 3888</span>                   <span class="stringliteral">&quot;received as expected -- but no expect_log_in_request() registered yet.  Will await that &quot;</span></div>
<div class="line"><a id="l03889" name="l03889"></a><span class="lineno"> 3889</span>                   <span class="stringliteral">&quot;and ensure its union-which matches.&quot;</span>);</div>
<div class="line"><a id="l03890" name="l03890"></a><span class="lineno"> 3890</span>  } <span class="comment">// else if (m_rcv_expecting_msg_map.size() == 0)</span></div>
<div class="line"><a id="l03891" name="l03891"></a><span class="lineno"> 3891</span> </div>
<div class="line"><a id="l03892" name="l03892"></a><span class="lineno"> 3892</span>  <span class="comment">/* Awesome!  So now we can just use the general code path, same as what the logged-in case invokes for the</span></div>
<div class="line"><a id="l03893" name="l03893"></a><span class="lineno"> 3893</span><span class="comment">   * new in-order message (individually -- it doesn&#39;t worry about then scanning the reassembly queue).</span></div>
<div class="line"><a id="l03894" name="l03894"></a><span class="lineno"> 3894</span><span class="comment">   * It will do some slight re-computations like the above is-it-a-response check, but that&#39;s fine; they&#39;re</span></div>
<div class="line"><a id="l03895" name="l03895"></a><span class="lineno"> 3895</span><span class="comment">   * quick and easy, and it&#39;s worth it for the simpler code.</span></div>
<div class="line"><a id="l03896" name="l03896"></a><span class="lineno"> 3896</span><span class="comment">   *</span></div>
<div class="line"><a id="l03897" name="l03897"></a><span class="lineno"> 3897</span><span class="comment">   * We just needed to check the above.  Though, note, we&#39;re still not in LOGGED_IN phase; that will occur</span></div>
<div class="line"><a id="l03898" name="l03898"></a><span class="lineno"> 3898</span><span class="comment">   * only once they send() their response to this log-in request. */</span></div>
<div class="line"><a id="l03899" name="l03899"></a><span class="lineno"> 3899</span>  <span class="keywordflow">return</span> rcv_struct_new_msg_in_is_next_expected(std::move(msg_in));</div>
<div class="line"><a id="l03900" name="l03900"></a><span class="lineno"> 3900</span>} <span class="comment">// Channel::rcv_struct_new_msg_in_during_log_in_as_srv()</span></div>
<div class="line"><a id="l03901" name="l03901"></a><span class="lineno"> 3901</span> </div>
<div class="line"><a id="l03902" name="l03902"></a><span class="lineno"> 3902</span><a class="code hl_define" href="ipc__transport__structured_2src_2ipc_2transport_2struc_2sync__io_2channel_8hpp.html#a50e1bb663274c68c760263342ddfdcbc">TEMPLATE_SIO_STRUCT_CHANNEL</a></div>
<div class="line"><a id="l03903" name="l03903"></a><span class="lineno"><a class="line" href="classipc_1_1transport_1_1struc_1_1sync__io_1_1Channel.html#a134966e02297d141b9e6d5e0d2ca3a7b"> 3903</a></span><span class="keywordtype">bool</span> CLASS_SIO_STRUCT_CHANNEL::rcv_struct_new_msg_in_is_next_expected(<a class="code hl_typedef" href="classipc_1_1transport_1_1struc_1_1sync__io_1_1Channel.html#a84287334d14f54c97f7dbb0d5b04cca5">Msg_in_ptr_uniq</a>&amp;&amp; msg_in_moved)</div>
<div class="line"><a id="l03904" name="l03904"></a><span class="lineno"> 3904</span>{</div>
<div class="line"><a id="l03905" name="l03905"></a><span class="lineno"> 3905</span>  <span class="keyword">using </span>boost::promise;</div>
<div class="line"><a id="l03906" name="l03906"></a><span class="lineno"> 3906</span>  <span class="keyword">using </span>std::holds_alternative;</div>
<div class="line"><a id="l03907" name="l03907"></a><span class="lineno"> 3907</span>  <span class="keyword">using </span>std::monostate;</div>
<div class="line"><a id="l03908" name="l03908"></a><span class="lineno"> 3908</span> </div>
<div class="line"><a id="l03909" name="l03909"></a><span class="lineno"> 3909</span>  <a class="code hl_typedef" href="classipc_1_1transport_1_1struc_1_1sync__io_1_1Channel.html#a84287334d14f54c97f7dbb0d5b04cca5">Msg_in_ptr_uniq</a> msg_in(std::move(msg_in_moved));</div>
<div class="line"><a id="l03910" name="l03910"></a><span class="lineno"> 3910</span>  <span class="comment">// msg_in_moved is now nullified as promised.  We own the Msg_in.</span></div>
<div class="line"><a id="l03911" name="l03911"></a><span class="lineno"> 3911</span>  <span class="keyword">auto</span>&amp; msg_in_privileged = *msg_in;</div>
<div class="line"><a id="l03912" name="l03912"></a><span class="lineno"> 3912</span> </div>
<div class="line"><a id="l03913" name="l03913"></a><span class="lineno"> 3913</span>  <span class="keyword">const</span> <span class="keyword">auto</span> <span class="keywordtype">id</span> = msg_in_privileged.id_or_none();</div>
<div class="line"><a id="l03914" name="l03914"></a><span class="lineno"> 3914</span>  assert(<span class="keywordtype">id</span> != 0);</div>
<div class="line"><a id="l03915" name="l03915"></a><span class="lineno"> 3915</span> </div>
<div class="line"><a id="l03916" name="l03916"></a><span class="lineno"> 3916</span>  <span class="comment">/* Refer to the summary comment (regarding layers of handling structured in-messages) in our caller.</span></div>
<div class="line"><a id="l03917" name="l03917"></a><span class="lineno"> 3917</span><span class="comment">   * We are handling the last 2 layers mentioned there in this method.</span></div>
<div class="line"><a id="l03918" name="l03918"></a><span class="lineno"> 3918</span><span class="comment">   *</span></div>
<div class="line"><a id="l03919" name="l03919"></a><span class="lineno"> 3919</span><span class="comment">   * So either it&#39;s a response or unsolicited. */</span></div>
<div class="line"><a id="l03920" name="l03920"></a><span class="lineno"> 3920</span>  <span class="keyword">const</span> <span class="keyword">auto</span> originating_msg_id = msg_in_privileged.originating_msg_id_or_none();</div>
<div class="line"><a id="l03921" name="l03921"></a><span class="lineno"> 3921</span>  <span class="keywordflow">if</span> (originating_msg_id != 0)</div>
<div class="line"><a id="l03922" name="l03922"></a><span class="lineno"> 3922</span>  {</div>
<div class="line"><a id="l03923" name="l03923"></a><span class="lineno"> 3923</span>    <span class="comment">// It&#39;s a response.</span></div>
<div class="line"><a id="l03924" name="l03924"></a><span class="lineno"> 3924</span>    <span class="keyword">const</span> <span class="keyword">auto</span> exp_rsp_it = m_rcv_expecting_response_map.find(originating_msg_id);</div>
<div class="line"><a id="l03925" name="l03925"></a><span class="lineno"> 3925</span>    <span class="keywordflow">if</span> (exp_rsp_it == m_rcv_expecting_response_map.end())</div>
<div class="line"><a id="l03926" name="l03926"></a><span class="lineno"> 3926</span>    {</div>
<div class="line"><a id="l03927" name="l03927"></a><span class="lineno"> 3927</span>      <span class="comment">/* It&#39;s a response to something that doesn&#39;t exist or didn&#39;t express it desired a response.</span></div>
<div class="line"><a id="l03928" name="l03928"></a><span class="lineno"> 3928</span><span class="comment">       * See rationale for how we handle it in m_rcv_pending_msgs doc header.  So do that: namely,</span></div>
<div class="line"><a id="l03929" name="l03929"></a><span class="lineno"> 3929</span><span class="comment">       *   - send an internal-message (out-of-band, meaning seq #s are irrelevant -- message ID 0)</span></div>
<div class="line"><a id="l03930" name="l03930"></a><span class="lineno"> 3930</span><span class="comment">       *     informing remote peer;</span></div>
<div class="line"><a id="l03931" name="l03931"></a><span class="lineno"> 3931</span><span class="comment">       *   - emit offending msg_in to special handler (if registered) and forget it. */</span></div>
<div class="line"><a id="l03932" name="l03932"></a><span class="lineno"> 3932</span>      FLOW_LOG_WARNING(<span class="stringliteral">&quot;struc::Channel [&quot;</span> &lt;&lt; *<span class="keyword">this</span> &lt;&lt; <span class="stringliteral">&quot;]: Structured in-message ID &quot;</span></div>
<div class="line"><a id="l03933" name="l03933"></a><span class="lineno"> 3933</span>                       <span class="stringliteral">&quot;[&quot;</span> &lt;&lt; <span class="keywordtype">id</span> &lt;&lt; <span class="stringliteral">&quot;] is itself in-order but is a response to &quot;</span></div>
<div class="line"><a id="l03934" name="l03934"></a><span class="lineno"> 3934</span>                       <span class="stringliteral">&quot;alleged out-message ID [&quot;</span> &lt;&lt; originating_msg_id &lt;&lt; <span class="stringliteral">&quot;] which either never existed or &quot;</span></div>
<div class="line"><a id="l03935" name="l03935"></a><span class="lineno"> 3935</span>                       <span class="stringliteral">&quot;is not registered as awaiting a response.  This is an error on the user&#39;s part and thus &quot;</span></div>
<div class="line"><a id="l03936" name="l03936"></a><span class="lineno"> 3936</span>                       <span class="stringliteral">&quot;not fatal.  Will send this as an internal-message to remote peer; and will fire &quot;</span></div>
<div class="line"><a id="l03937" name="l03937"></a><span class="lineno"> 3937</span>                       <span class="stringliteral">&quot;registered on-unexpected-rsp handler (if any) locally.&quot;</span>);</div>
<div class="line"><a id="l03938" name="l03938"></a><span class="lineno"> 3938</span> </div>
<div class="line"><a id="l03939" name="l03939"></a><span class="lineno"> 3939</span>      rcv_struct_inform_of_unexpected_response(std::move(msg_in));</div>
<div class="line"><a id="l03940" name="l03940"></a><span class="lineno"> 3940</span>      <span class="keywordflow">return</span> <span class="keyword">true</span>;</div>
<div class="line"><a id="l03941" name="l03941"></a><span class="lineno"> 3941</span>    } <span class="comment">// if (exp_rsp_it not found)</span></div>
<div class="line"><a id="l03942" name="l03942"></a><span class="lineno"> 3942</span>    <span class="comment">// else if (exp_rsp_it found)</span></div>
<div class="line"><a id="l03943" name="l03943"></a><span class="lineno"> 3943</span> </div>
<div class="line"><a id="l03944" name="l03944"></a><span class="lineno"> 3944</span>    <span class="keyword">const</span> <a class="code hl_struct" href="structipc_1_1transport_1_1struc_1_1sync__io_1_1Channel_1_1Expecting__response.html">Expecting_response</a>&amp; exp_rsp = *exp_rsp_it-&gt;second;</div>
<div class="line"><a id="l03945" name="l03945"></a><span class="lineno"> 3945</span>    <span class="keyword">const</span> <span class="keywordtype">bool</span> one_off = exp_rsp.<a class="code hl_variable" href="structipc_1_1transport_1_1struc_1_1sync__io_1_1Channel_1_1Expecting__response.html#a615b5613ac4e2bc93be88b8835e6a22c">m_one_expected</a>; <span class="comment">// Delete exp_rsp_it below if true (single response expected).</span></div>
<div class="line"><a id="l03946" name="l03946"></a><span class="lineno"> 3946</span>    <span class="keyword">auto</span> on_msg_func = exp_rsp.<a class="code hl_variable" href="structipc_1_1transport_1_1struc_1_1sync__io_1_1Channel_1_1Expecting__response.html#a410ae0ef77010cfb5f90de9a90b25e92">m_on_msg_func</a>;</div>
<div class="line"><a id="l03947" name="l03947"></a><span class="lineno"> 3947</span>    assert(!on_msg_func-&gt;empty());</div>
<div class="line"><a id="l03948" name="l03948"></a><span class="lineno"> 3948</span> </div>
<div class="line"><a id="l03949" name="l03949"></a><span class="lineno"> 3949</span>    FLOW_LOG_TRACE(<span class="stringliteral">&quot;struc::Channel [&quot;</span> &lt;&lt; *<span class="keyword">this</span> &lt;&lt; <span class="stringliteral">&quot;]: Structured in-message ID &quot;</span></div>
<div class="line"><a id="l03950" name="l03950"></a><span class="lineno"> 3950</span>                   <span class="stringliteral">&quot;[&quot;</span> &lt;&lt; <span class="keywordtype">id</span> &lt;&lt; <span class="stringliteral">&quot;] is itself in-order and is a response to &quot;</span></div>
<div class="line"><a id="l03951" name="l03951"></a><span class="lineno"> 3951</span>                   <span class="stringliteral">&quot;out-message ID [&quot;</span> &lt;&lt; originating_msg_id &lt;&lt; <span class="stringliteral">&quot;] which is expecting the response &quot;</span></div>
<div class="line"><a id="l03952" name="l03952"></a><span class="lineno"> 3952</span>                   <span class="stringliteral">&quot;(one-off? = [&quot;</span> &lt;&lt; one_off &lt;&lt; <span class="stringliteral">&quot;]).  &quot;</span></div>
<div class="line"><a id="l03953" name="l03953"></a><span class="lineno"> 3953</span>                   <span class="stringliteral">&quot;Will delete expectation if one-off; post handler.&quot;</span>);</div>
<div class="line"><a id="l03954" name="l03954"></a><span class="lineno"> 3954</span> </div>
<div class="line"><a id="l03955" name="l03955"></a><span class="lineno"> 3955</span>    handlers_post(<span class="stringliteral">&quot;rcv_struct_new_msg_in_is_next_expected(1)&quot;</span>,</div>
<div class="line"><a id="l03956" name="l03956"></a><span class="lineno"> 3956</span>                  [<span class="keyword">this</span>, msg_in = <a class="code hl_typedef" href="classipc_1_1transport_1_1struc_1_1sync__io_1_1Channel.html#acde2b3866547a30958035203d9d89928">Msg_in_ptr</a>(msg_in.release()), <span class="comment">// Upgrade to shared_ptr&lt;&gt; by the way.</span></div>
<div class="line"><a id="l03957" name="l03957"></a><span class="lineno"> 3957</span>                   on_msg_func = std::move(on_msg_func)]() <span class="keyword">mutable</span></div>
<div class="line"><a id="l03958" name="l03958"></a><span class="lineno"> 3958</span>    {</div>
<div class="line"><a id="l03959" name="l03959"></a><span class="lineno"> 3959</span>      FLOW_LOG_TRACE(<span class="stringliteral">&quot;struc::Channel [&quot;</span> &lt;&lt; *this &lt;&lt; <span class="stringliteral">&quot;]: Invoking on-rsp user handler.&quot;</span>);</div>
<div class="line"><a id="l03960" name="l03960"></a><span class="lineno"> 3960</span>      (*on_msg_func)(std::move(msg_in));</div>
<div class="line"><a id="l03961" name="l03961"></a><span class="lineno"> 3961</span>    });</div>
<div class="line"><a id="l03962" name="l03962"></a><span class="lineno"> 3962</span> </div>
<div class="line"><a id="l03963" name="l03963"></a><span class="lineno"> 3963</span>    <span class="keywordflow">if</span> (one_off)</div>
<div class="line"><a id="l03964" name="l03964"></a><span class="lineno"> 3964</span>    {</div>
<div class="line"><a id="l03965" name="l03965"></a><span class="lineno"> 3965</span>      m_rcv_expecting_response_map.erase(exp_rsp_it);</div>
<div class="line"><a id="l03966" name="l03966"></a><span class="lineno"> 3966</span>    }</div>
<div class="line"><a id="l03967" name="l03967"></a><span class="lineno"> 3967</span>    <span class="keywordflow">return</span> <span class="keyword">true</span>;</div>
<div class="line"><a id="l03968" name="l03968"></a><span class="lineno"> 3968</span>  } <span class="comment">// if (originating_msg_id != 0) (is response)</span></div>
<div class="line"><a id="l03969" name="l03969"></a><span class="lineno"> 3969</span>  <span class="comment">// else if (originating_msg_id == 0) (is unsolicited)</span></div>
<div class="line"><a id="l03970" name="l03970"></a><span class="lineno"> 3970</span> </div>
<div class="line"><a id="l03971" name="l03971"></a><span class="lineno"> 3971</span>  <span class="comment">/* Refer once again to the summary comment in calling method.  Unsolicited message may need to be cached -- or not.</span></div>
<div class="line"><a id="l03972" name="l03972"></a><span class="lineno"> 3972</span><span class="comment">   * (That&#39;s unlike responses: Either something was expecting it; or not and it&#39;s an error.) */</span></div>
<div class="line"><a id="l03973" name="l03973"></a><span class="lineno"> 3973</span> </div>
<div class="line"><a id="l03974" name="l03974"></a><span class="lineno"> 3974</span>  <span class="keyword">const</span> <a class="code hl_typedef" href="classipc_1_1transport_1_1struc_1_1sync__io_1_1Channel.html#aa40c3ec3f45cdfea9360f7f35b9ade3c">Msg_which_in</a> which = msg_in-&gt;body_root().which();</div>
<div class="line"><a id="l03975" name="l03975"></a><span class="lineno"> 3975</span>  <span class="keyword">const</span> <span class="keyword">auto</span> exp_msg_it = m_rcv_expecting_msg_map.find(which);</div>
<div class="line"><a id="l03976" name="l03976"></a><span class="lineno"> 3976</span>  <span class="keywordflow">if</span> (exp_msg_it == m_rcv_expecting_msg_map.end())</div>
<div class="line"><a id="l03977" name="l03977"></a><span class="lineno"> 3977</span>  {</div>
<div class="line"><a id="l03978" name="l03978"></a><span class="lineno"> 3978</span>    <span class="keyword">auto</span>&amp; q = m_rcv_pending_msgs[which]; <span class="comment">// Create queue if needed.</span></div>
<div class="line"><a id="l03979" name="l03979"></a><span class="lineno"> 3979</span>    q.emplace(std::move(msg_in)); <span class="comment">// Move the unique_ptr into cached queue.</span></div>
<div class="line"><a id="l03980" name="l03980"></a><span class="lineno"> 3980</span>    FLOW_LOG_TRACE(<span class="stringliteral">&quot;struc::Channel [&quot;</span> &lt;&lt; *<span class="keyword">this</span> &lt;&lt; <span class="stringliteral">&quot;]: Structured in-message ID &quot;</span></div>
<div class="line"><a id="l03981" name="l03981"></a><span class="lineno"> 3981</span>                   <span class="stringliteral">&quot;[&quot;</span> &lt;&lt; <span class="keywordtype">id</span> &lt;&lt; <span class="stringliteral">&quot;] is itself in-order and unsolicited; currently no handler is registered &quot;</span></div>
<div class="line"><a id="l03982" name="l03982"></a><span class="lineno"> 3982</span>                   <span class="stringliteral">&quot;for its union-which = [&quot;</span> &lt;&lt; <span class="keywordtype">int</span>(which) &lt;&lt; <span class="stringliteral">&quot;]; cached into per-union-which queue now sized &quot;</span></div>
<div class="line"><a id="l03983" name="l03983"></a><span class="lineno"> 3983</span>                   <span class="stringliteral">&quot;[&quot;</span> &lt;&lt; q.size() &lt;&lt; <span class="stringliteral">&quot;].&quot;</span>);</div>
<div class="line"><a id="l03984" name="l03984"></a><span class="lineno"> 3984</span>    <span class="keywordflow">return</span> <span class="keyword">true</span>;</div>
<div class="line"><a id="l03985" name="l03985"></a><span class="lineno"> 3985</span>  }</div>
<div class="line"><a id="l03986" name="l03986"></a><span class="lineno"> 3986</span>  <span class="comment">// else if (exp_msg_it exists)</span></div>
<div class="line"><a id="l03987" name="l03987"></a><span class="lineno"> 3987</span> </div>
<div class="line"><a id="l03988" name="l03988"></a><span class="lineno"> 3988</span>  <span class="comment">// This is much like the response handling above.</span></div>
<div class="line"><a id="l03989" name="l03989"></a><span class="lineno"> 3989</span> </div>
<div class="line"><a id="l03990" name="l03990"></a><span class="lineno"> 3990</span>  <span class="keyword">const</span> <a class="code hl_struct" href="structipc_1_1transport_1_1struc_1_1sync__io_1_1Channel_1_1Expecting__response.html">Expecting_msg</a>&amp; exp_msg = *exp_msg_it-&gt;second;</div>
<div class="line"><a id="l03991" name="l03991"></a><span class="lineno"> 3991</span>  <span class="keyword">const</span> <span class="keywordtype">bool</span> one_off = exp_msg.<a class="code hl_variable" href="structipc_1_1transport_1_1struc_1_1sync__io_1_1Channel_1_1Expecting__response.html#a615b5613ac4e2bc93be88b8835e6a22c">m_one_expected</a>; <span class="comment">// Delete exp_msg_it below if true (single response expected).</span></div>
<div class="line"><a id="l03992" name="l03992"></a><span class="lineno"> 3992</span>  <span class="keyword">auto</span> on_msg_func = exp_msg.<a class="code hl_variable" href="structipc_1_1transport_1_1struc_1_1sync__io_1_1Channel_1_1Expecting__response.html#a410ae0ef77010cfb5f90de9a90b25e92">m_on_msg_func</a>;</div>
<div class="line"><a id="l03993" name="l03993"></a><span class="lineno"> 3993</span>  assert(!on_msg_func-&gt;empty());</div>
<div class="line"><a id="l03994" name="l03994"></a><span class="lineno"> 3994</span> </div>
<div class="line"><a id="l03995" name="l03995"></a><span class="lineno"> 3995</span>  FLOW_LOG_TRACE(<span class="stringliteral">&quot;struc::Channel [&quot;</span> &lt;&lt; *<span class="keyword">this</span> &lt;&lt; <span class="stringliteral">&quot;]: Structured in-message ID &quot;</span></div>
<div class="line"><a id="l03996" name="l03996"></a><span class="lineno"> 3996</span>                 <span class="stringliteral">&quot;[&quot;</span> &lt;&lt; <span class="keywordtype">id</span> &lt;&lt; <span class="stringliteral">&quot;] is itself in-order and unsolicited; currently expecting its &quot;</span></div>
<div class="line"><a id="l03997" name="l03997"></a><span class="lineno"> 3997</span>                 <span class="stringliteral">&quot;union-which = [&quot;</span> &lt;&lt; <span class="keywordtype">int</span>(which) &lt;&lt; <span class="stringliteral">&quot;] (one-off? = [&quot;</span> &lt;&lt; one_off &lt;&lt; <span class="stringliteral">&quot;]).  &quot;</span></div>
<div class="line"><a id="l03998" name="l03998"></a><span class="lineno"> 3998</span>                 <span class="stringliteral">&quot;Will fire handler and delete expectation if one-off.&quot;</span>);</div>
<div class="line"><a id="l03999" name="l03999"></a><span class="lineno"> 3999</span> </div>
<div class="line"><a id="l04000" name="l04000"></a><span class="lineno"> 4000</span>  handlers_post(<span class="stringliteral">&quot;rcv_struct_new_msg_in_is_next_expected(2)&quot;</span>,</div>
<div class="line"><a id="l04001" name="l04001"></a><span class="lineno"> 4001</span>                [<span class="keyword">this</span>, msg_in = <a class="code hl_typedef" href="classipc_1_1transport_1_1struc_1_1sync__io_1_1Channel.html#acde2b3866547a30958035203d9d89928">Msg_in_ptr</a>(msg_in.release()), <span class="comment">// Upgrade to shared_ptr&lt;&gt; by the way.</span></div>
<div class="line"><a id="l04002" name="l04002"></a><span class="lineno"> 4002</span>                 on_msg_func = std::move(on_msg_func)]() <span class="keyword">mutable</span></div>
<div class="line"><a id="l04003" name="l04003"></a><span class="lineno"> 4003</span>  {</div>
<div class="line"><a id="l04004" name="l04004"></a><span class="lineno"> 4004</span>    FLOW_LOG_TRACE(<span class="stringliteral">&quot;struc::Channel [&quot;</span> &lt;&lt; *this &lt;&lt; <span class="stringliteral">&quot;]: Invoking on-msg user handler (uncached).&quot;</span>);</div>
<div class="line"><a id="l04005" name="l04005"></a><span class="lineno"> 4005</span>    (*on_msg_func)(std::move(msg_in));</div>
<div class="line"><a id="l04006" name="l04006"></a><span class="lineno"> 4006</span>  });</div>
<div class="line"><a id="l04007" name="l04007"></a><span class="lineno"> 4007</span> </div>
<div class="line"><a id="l04008" name="l04008"></a><span class="lineno"> 4008</span>  <span class="keywordflow">if</span> (one_off)</div>
<div class="line"><a id="l04009" name="l04009"></a><span class="lineno"> 4009</span>  {</div>
<div class="line"><a id="l04010" name="l04010"></a><span class="lineno"> 4010</span>    m_rcv_expecting_msg_map.erase(exp_msg_it);</div>
<div class="line"><a id="l04011" name="l04011"></a><span class="lineno"> 4011</span>  }</div>
<div class="line"><a id="l04012" name="l04012"></a><span class="lineno"> 4012</span> </div>
<div class="line"><a id="l04013" name="l04013"></a><span class="lineno"> 4013</span>  <span class="keywordflow">return</span> <span class="keyword">true</span>;</div>
<div class="line"><a id="l04014" name="l04014"></a><span class="lineno"> 4014</span>} <span class="comment">// Channel::rcv_struct_new_msg_in_is_next_expected()</span></div>
<div class="line"><a id="l04015" name="l04015"></a><span class="lineno"> 4015</span> </div>
<div class="line"><a id="l04016" name="l04016"></a><span class="lineno"> 4016</span><a class="code hl_define" href="ipc__transport__structured_2src_2ipc_2transport_2struc_2sync__io_2channel_8hpp.html#a50e1bb663274c68c760263342ddfdcbc">TEMPLATE_SIO_STRUCT_CHANNEL</a></div>
<div class="line"><a id="l04017" name="l04017"></a><span class="lineno"><a class="line" href="classipc_1_1transport_1_1struc_1_1sync__io_1_1Channel.html#a795baef6fefbc4749daf5ceda52943c1"> 4017</a></span><span class="keywordtype">void</span> CLASS_SIO_STRUCT_CHANNEL::rcv_struct_inform_of_unexpected_response(<a class="code hl_typedef" href="classipc_1_1transport_1_1struc_1_1sync__io_1_1Channel.html#a84287334d14f54c97f7dbb0d5b04cca5">Msg_in_ptr_uniq</a>&amp;&amp; msg_in)</div>
<div class="line"><a id="l04018" name="l04018"></a><span class="lineno"> 4018</span>{</div>
<div class="line"><a id="l04019" name="l04019"></a><span class="lineno"> 4019</span>  <span class="keyword">using </span>flow::util::ostream_op_string;</div>
<div class="line"><a id="l04020" name="l04020"></a><span class="lineno"> 4020</span> </div>
<div class="line"><a id="l04021" name="l04021"></a><span class="lineno"> 4021</span>  <span class="comment">/* There are 2 actions below: send_core() an internal message about the unexpected response, for the other</span></div>
<div class="line"><a id="l04022" name="l04022"></a><span class="lineno"> 4022</span><span class="comment">   * side&#39;s benefit (it can fire its on-*remote*-unexpected-response handler if applicable); and -- separately --</span></div>
<div class="line"><a id="l04023" name="l04023"></a><span class="lineno"> 4023</span><span class="comment">   * fire our on-*local*-unexpected-response handler.  The latter definitely should be handlers_post()ed to</span></div>
<div class="line"><a id="l04024" name="l04024"></a><span class="lineno"> 4024</span><span class="comment">   * avoid recursive mayhem as usual.  Should the send_core() action also be handlers_post()ed, or could we just</span></div>
<div class="line"><a id="l04025" name="l04025"></a><span class="lineno"> 4025</span><span class="comment">   * do it synchronously?  Back when Channel was async-I/O all the way (before sync_io pattern existed)</span></div>
<div class="line"><a id="l04026" name="l04026"></a><span class="lineno"> 4026</span><span class="comment">   * I had post()ed it onto thread W, which at the time was used exclusively for firing user handlers; the idea</span></div>
<div class="line"><a id="l04027" name="l04027"></a><span class="lineno"> 4027</span><span class="comment">   * was to emulate the user themselves send()ing a thing.  Now, though, that appears unnecessary: it&#39;s an internal</span></div>
<div class="line"><a id="l04028" name="l04028"></a><span class="lineno"> 4028</span><span class="comment">   * best-effort message; we don&#39;t even care about any error, and it cannot be replied-to. */</span></div>
<div class="line"><a id="l04029" name="l04029"></a><span class="lineno"> 4029</span> </div>
<div class="line"><a id="l04030" name="l04030"></a><span class="lineno"> 4030</span>  <span class="keyword">auto</span>&amp; msg_in_privileged = *<span class="keyword">static_cast&lt;</span><a class="code hl_class" href="classipc_1_1transport_1_1struc_1_1Msg__in__impl.html">Msg_in_impl</a>*<span class="keyword">&gt;</span>(msg_in.get());</div>
<div class="line"><a id="l04031" name="l04031"></a><span class="lineno"> 4031</span>  <a class="code hl_class" href="classipc_1_1transport_1_1struc_1_1Msg__mdt__out.html">Msg_mdt_out</a> mdt(m_struct_builder_config, m_session_token, msg_in_privileged.id_or_none(),</div>
<div class="line"><a id="l04032" name="l04032"></a><span class="lineno"> 4032</span>                  0, 0);</div>
<div class="line"><a id="l04033" name="l04033"></a><span class="lineno"> 4033</span>  <span class="comment">// Indicate we&#39;re referencing offending msg *msg_in. -----^</span></div>
<div class="line"><a id="l04034" name="l04034"></a><span class="lineno"> 4034</span> </div>
<div class="line"><a id="l04035" name="l04035"></a><span class="lineno"> 4035</span>  <span class="comment">/* For the metadata-text, shove in a pretty-printing of the metadata header with lots of goodies in there --</span></div>
<div class="line"><a id="l04036" name="l04036"></a><span class="lineno"> 4036</span><span class="comment">   * but reasonably capped in length (and in compute used, though certainly not super-quick either) and</span></div>
<div class="line"><a id="l04037" name="l04037"></a><span class="lineno"> 4037</span><span class="comment">   * *not* including the user message body itself.  However do add the top-level union-which as well. */</span></div>
<div class="line"><a id="l04038" name="l04038"></a><span class="lineno"> 4038</span>  <span class="keyword">auto</span> rsp_root = mdt.<a class="code hl_function" href="classipc_1_1transport_1_1struc_1_1Msg__mdt__out.html#a1541fa2c6343cbcddf3feac9fcf67c46">internal_msg_body_root</a>().initUnexpectedResponse();</div>
<div class="line"><a id="l04039" name="l04039"></a><span class="lineno"> 4039</span>  rsp_root.setOriginatingMessageMetadataText</div>
<div class="line"><a id="l04040" name="l04040"></a><span class="lineno"> 4040</span>             (ostream_op_string(<span class="stringliteral">&quot;user-msg-union-which = &quot;</span>, <span class="keywordtype">int</span>(msg_in_privileged.body_root().which()),</div>
<div class="line"><a id="l04041" name="l04041"></a><span class="lineno"> 4041</span>                                <span class="stringliteral">&quot;, metadata-header =\n&quot;</span>,</div>
<div class="line"><a id="l04042" name="l04042"></a><span class="lineno"> 4042</span>                                ::capnp::prettyPrint(msg_in_privileged.mdt_root()).flatten().cStr()));</div>
<div class="line"><a id="l04043" name="l04043"></a><span class="lineno"> 4043</span> </div>
<div class="line"><a id="l04044" name="l04044"></a><span class="lineno"> 4044</span>  <span class="comment">// Send the internal message.  Forego some of the vanilla-send() steps and ignore errors (spirit = do our best).</span></div>
<div class="line"><a id="l04045" name="l04045"></a><span class="lineno"> 4045</span>  <span class="keywordflow">if</span> (!m_channel_err_code_or_ok)</div>
<div class="line"><a id="l04046" name="l04046"></a><span class="lineno"> 4046</span>  {</div>
<div class="line"><a id="l04047" name="l04047"></a><span class="lineno"> 4047</span>    send_core(mdt, <span class="keyword">nullptr</span>, <span class="keyword">nullptr</span>); <span class="comment">// Last nullptr =&gt; ignore error.</span></div>
<div class="line"><a id="l04048" name="l04048"></a><span class="lineno"> 4048</span>  }</div>
<div class="line"><a id="l04049" name="l04049"></a><span class="lineno"> 4049</span> </div>
<div class="line"><a id="l04050" name="l04050"></a><span class="lineno"> 4050</span>  handlers_post(<span class="stringliteral">&quot;rcv_struct_inform_of_unexpected_response()&quot;</span>,</div>
<div class="line"><a id="l04051" name="l04051"></a><span class="lineno"> 4051</span>                [<span class="keyword">this</span>, msg_in = <a class="code hl_typedef" href="classipc_1_1transport_1_1struc_1_1sync__io_1_1Channel.html#acde2b3866547a30958035203d9d89928">Msg_in_ptr</a>(msg_in.release())] <span class="comment">// Upgrade to shared_ptr&lt;&gt; by the way.</span></div>
<div class="line"><a id="l04052" name="l04052"></a><span class="lineno"> 4052</span>                 () <span class="keyword">mutable</span></div>
<div class="line"><a id="l04053" name="l04053"></a><span class="lineno"> 4053</span>  {</div>
<div class="line"><a id="l04054" name="l04054"></a><span class="lineno"> 4054</span>    auto&amp; msg_in_privileged = *static_cast&lt;Msg_in_impl*&gt;(msg_in.get());</div>
<div class="line"><a id="l04055" name="l04055"></a><span class="lineno"> 4055</span> </div>
<div class="line"><a id="l04056" name="l04056"></a><span class="lineno"> 4056</span>    if (m_on_unexpected_response_func_or_empty.empty())</div>
<div class="line"><a id="l04057" name="l04057"></a><span class="lineno"> 4057</span>    {</div>
<div class="line"><a id="l04058" name="l04058"></a><span class="lineno"> 4058</span>      FLOW_LOG_TRACE(<span class="stringliteral">&quot;struc::Channel [&quot;</span> &lt;&lt; *this &lt;&lt; <span class="stringliteral">&quot;]: Would invoke on-unexpected-rsp user handler; &quot;</span></div>
<div class="line"><a id="l04059" name="l04059"></a><span class="lineno"> 4059</span>                     <span class="stringliteral">&quot;but none is configured.  Restating some details: &quot;</span></div>
<div class="line"><a id="l04060" name="l04060"></a><span class="lineno"> 4060</span>                     <span class="stringliteral">&quot;Structured in-message ID [&quot;</span> &lt;&lt; msg_in_privileged.id_or_none() &lt;&lt; <span class="stringliteral">&quot;] is a response to &quot;</span></div>
<div class="line"><a id="l04061" name="l04061"></a><span class="lineno"> 4061</span>                     <span class="stringliteral">&quot;alleged out-message ID [&quot;</span> &lt;&lt; msg_in_privileged.originating_msg_id_or_none() &lt;&lt; <span class="stringliteral">&quot;] which either &quot;</span></div>
<div class="line"><a id="l04062" name="l04062"></a><span class="lineno"> 4062</span>                     <span class="stringliteral">&quot;never existed or is not registered as awaiting a response.&quot;</span>);</div>
<div class="line"><a id="l04063" name="l04063"></a><span class="lineno"> 4063</span>    }</div>
<div class="line"><a id="l04064" name="l04064"></a><span class="lineno"> 4064</span>    <span class="keywordflow">else</span></div>
<div class="line"><a id="l04065" name="l04065"></a><span class="lineno"> 4065</span>    {</div>
<div class="line"><a id="l04066" name="l04066"></a><span class="lineno"> 4066</span>      FLOW_LOG_TRACE(<span class="stringliteral">&quot;struc::Channel [&quot;</span> &lt;&lt; *this &lt;&lt; <span class="stringliteral">&quot;]: Invoking on-unexpected-rsp user handler.&quot;</span>);</div>
<div class="line"><a id="l04067" name="l04067"></a><span class="lineno"> 4067</span>      m_on_unexpected_response_func_or_empty(std::move(msg_in));</div>
<div class="line"><a id="l04068" name="l04068"></a><span class="lineno"> 4068</span>    }</div>
<div class="line"><a id="l04069" name="l04069"></a><span class="lineno"> 4069</span>  }); <span class="comment">// handlers_post()</span></div>
<div class="line"><a id="l04070" name="l04070"></a><span class="lineno"> 4070</span>} <span class="comment">// Channel::rcv_struct_inform_of_unexpected_response()</span></div>
<div class="line"><a id="l04071" name="l04071"></a><span class="lineno"> 4071</span> </div>
<div class="line"><a id="l04072" name="l04072"></a><span class="lineno"> 4072</span><a class="code hl_define" href="ipc__transport__structured_2src_2ipc_2transport_2struc_2sync__io_2channel_8hpp.html#a50e1bb663274c68c760263342ddfdcbc">TEMPLATE_SIO_STRUCT_CHANNEL</a></div>
<div class="line"><a id="l04073" name="l04073"></a><span class="lineno"><a class="line" href="classipc_1_1transport_1_1struc_1_1sync__io_1_1Channel.html#ab17b00ae995cf634c721420cd85fdef2"> 4073</a></span><span class="keywordtype">bool</span> CLASS_SIO_STRUCT_CHANNEL::handle_async_err_code(<span class="keyword">const</span> <a class="code hl_typedef" href="namespaceipc.html#aa3192e586cc45d3e7c22463bf2760f89">Error_code</a>&amp; err_code, <a class="code hl_typedef" href="namespaceipc_1_1util.html#ae6ac47812a90d1287c61e0b7de7bc4f5">util::String_view</a> context)</div>
<div class="line"><a id="l04074" name="l04074"></a><span class="lineno"> 4074</span>{</div>
<div class="line"><a id="l04075" name="l04075"></a><span class="lineno"> 4075</span>  <span class="keyword">const</span> <span class="keyword">auto</span> this_is_hosed = bool(err_code);</div>
<div class="line"><a id="l04076" name="l04076"></a><span class="lineno"> 4076</span>  <span class="keyword">const</span> <span class="keyword">auto</span> overall_hosed = bool(m_channel_err_code_or_ok);</div>
<div class="line"><a id="l04077" name="l04077"></a><span class="lineno"> 4077</span> </div>
<div class="line"><a id="l04078" name="l04078"></a><span class="lineno"> 4078</span>  <span class="keywordflow">if</span> (!this_is_hosed)</div>
<div class="line"><a id="l04079" name="l04079"></a><span class="lineno"> 4079</span>  {</div>
<div class="line"><a id="l04080" name="l04080"></a><span class="lineno"> 4080</span>    <span class="keywordflow">if</span> (overall_hosed)</div>
<div class="line"><a id="l04081" name="l04081"></a><span class="lineno"> 4081</span>    {</div>
<div class="line"><a id="l04082" name="l04082"></a><span class="lineno"> 4082</span>      FLOW_LOG_WARNING(<span class="stringliteral">&quot;struc::Channel [&quot;</span> &lt;&lt; *<span class="keyword">this</span> &lt;&lt; <span class="stringliteral">&quot;]: An operation [&quot;</span> &lt;&lt; context &lt;&lt; <span class="stringliteral">&quot;] yielded success, &quot;</span></div>
<div class="line"><a id="l04083" name="l04083"></a><span class="lineno"> 4083</span>                       <span class="stringliteral">&quot;but the channel was previously hosed; so ignoring the operation&#39;s result and potentially &quot;</span></div>
<div class="line"><a id="l04084" name="l04084"></a><span class="lineno"> 4084</span>                       <span class="stringliteral">&quot;ending the calling async chain.&quot;</span>);</div>
<div class="line"><a id="l04085" name="l04085"></a><span class="lineno"> 4085</span>      <span class="keywordflow">return</span> <span class="keyword">true</span>;</div>
<div class="line"><a id="l04086" name="l04086"></a><span class="lineno"> 4086</span>    }</div>
<div class="line"><a id="l04087" name="l04087"></a><span class="lineno"> 4087</span>    <span class="comment">// else if (!overall_hosed)</span></div>
<div class="line"><a id="l04088" name="l04088"></a><span class="lineno"> 4088</span>    <span class="keywordflow">return</span> <span class="keyword">false</span>;</div>
<div class="line"><a id="l04089" name="l04089"></a><span class="lineno"> 4089</span>  } <span class="comment">// else if (this_is_hosed):</span></div>
<div class="line"><a id="l04090" name="l04090"></a><span class="lineno"> 4090</span> </div>
<div class="line"><a id="l04091" name="l04091"></a><span class="lineno"> 4091</span>  <span class="keywordflow">if</span> (overall_hosed) <span class="comment">// &amp;&amp; this_is_hosed</span></div>
<div class="line"><a id="l04092" name="l04092"></a><span class="lineno"> 4092</span>  {</div>
<div class="line"><a id="l04093" name="l04093"></a><span class="lineno"> 4093</span>    FLOW_LOG_WARNING(<span class="stringliteral">&quot;struc::Channel [&quot;</span> &lt;&lt; *<span class="keyword">this</span> &lt;&lt; <span class="stringliteral">&quot;]: An operation [&quot;</span> &lt;&lt; context &lt;&lt; <span class="stringliteral">&quot;] yielded failure &quot;</span></div>
<div class="line"><a id="l04094" name="l04094"></a><span class="lineno"> 4094</span>                     <span class="stringliteral">&quot;[&quot;</span> &lt;&lt; err_code &lt;&lt; <span class="stringliteral">&quot;] [&quot;</span> &lt;&lt; err_code.message() &lt;&lt; <span class="stringliteral">&quot;]; but the channel was previously already &quot;</span></div>
<div class="line"><a id="l04095" name="l04095"></a><span class="lineno"> 4095</span>                     <span class="stringliteral">&quot;hosed for reason &quot;</span></div>
<div class="line"><a id="l04096" name="l04096"></a><span class="lineno"> 4096</span>                     <span class="stringliteral">&quot;[&quot;</span> &lt;&lt; m_channel_err_code_or_ok &lt;&lt; <span class="stringliteral">&quot;] [&quot;</span> &lt;&lt; m_channel_err_code_or_ok.message() &lt;&lt; <span class="stringliteral">&quot;]; &quot;</span></div>
<div class="line"><a id="l04097" name="l04097"></a><span class="lineno"> 4097</span>                     <span class="stringliteral">&quot;so ignoring the operation&#39;s result and potentially ending the calling async chain.&quot;</span>);</div>
<div class="line"><a id="l04098" name="l04098"></a><span class="lineno"> 4098</span>  }</div>
<div class="line"><a id="l04099" name="l04099"></a><span class="lineno"> 4099</span>  <span class="keywordflow">else</span> <span class="comment">// if (!overall_hosed) // &amp;&amp; this_is_hosed</span></div>
<div class="line"><a id="l04100" name="l04100"></a><span class="lineno"> 4100</span>  {</div>
<div class="line"><a id="l04101" name="l04101"></a><span class="lineno"> 4101</span>    handle_new_error(err_code, context);</div>
<div class="line"><a id="l04102" name="l04102"></a><span class="lineno"> 4102</span>  }</div>
<div class="line"><a id="l04103" name="l04103"></a><span class="lineno"> 4103</span> </div>
<div class="line"><a id="l04104" name="l04104"></a><span class="lineno"> 4104</span>  <span class="keywordflow">return</span> <span class="keyword">true</span>;</div>
<div class="line"><a id="l04105" name="l04105"></a><span class="lineno"> 4105</span>} <span class="comment">// Channel::handle_async_err_code()</span></div>
<div class="line"><a id="l04106" name="l04106"></a><span class="lineno"> 4106</span> </div>
<div class="line"><a id="l04107" name="l04107"></a><span class="lineno"> 4107</span><a class="code hl_define" href="ipc__transport__structured_2src_2ipc_2transport_2struc_2sync__io_2channel_8hpp.html#a50e1bb663274c68c760263342ddfdcbc">TEMPLATE_SIO_STRUCT_CHANNEL</a></div>
<div class="line"><a id="l04108" name="l04108"></a><span class="lineno"><a class="line" href="classipc_1_1transport_1_1struc_1_1sync__io_1_1Channel.html#ad3f5d174c65db9d5ec3b14769fb9574a"> 4108</a></span><span class="keywordtype">void</span> CLASS_SIO_STRUCT_CHANNEL::handle_new_error(<span class="keyword">const</span> <a class="code hl_typedef" href="namespaceipc.html#aa3192e586cc45d3e7c22463bf2760f89">Error_code</a>&amp; err_code_not_ok, <a class="code hl_typedef" href="namespaceipc_1_1util.html#ae6ac47812a90d1287c61e0b7de7bc4f5">util::String_view</a> context)</div>
<div class="line"><a id="l04109" name="l04109"></a><span class="lineno"> 4109</span>{</div>
<div class="line"><a id="l04110" name="l04110"></a><span class="lineno"> 4110</span>  assert(err_code_not_ok &amp;&amp; <span class="stringliteral">&quot;Bug?  Call this only when error detected.&quot;</span>);</div>
<div class="line"><a id="l04111" name="l04111"></a><span class="lineno"> 4111</span>  assert((!m_channel_err_code_or_ok) &amp;&amp; <span class="stringliteral">&quot;Bug?  Call this only ascertaining the channel isn&#39;t already hosed.&quot;</span>);</div>
<div class="line"><a id="l04112" name="l04112"></a><span class="lineno"> 4112</span>  <span class="keyword">const</span> <span class="keyword">auto</span>&amp; err_code = err_code_not_ok; <span class="comment">// For brevity.</span></div>
<div class="line"><a id="l04113" name="l04113"></a><span class="lineno"> 4113</span> </div>
<div class="line"><a id="l04114" name="l04114"></a><span class="lineno"> 4114</span>  FLOW_LOG_WARNING(<span class="stringliteral">&quot;struc::Channel [&quot;</span> &lt;&lt; *<span class="keyword">this</span> &lt;&lt; <span class="stringliteral">&quot;]: An operation [&quot;</span> &lt;&lt; context &lt;&lt; <span class="stringliteral">&quot;] yielded failure &quot;</span></div>
<div class="line"><a id="l04115" name="l04115"></a><span class="lineno"> 4115</span>                   <span class="stringliteral">&quot;[&quot;</span> &lt;&lt; err_code &lt;&lt; <span class="stringliteral">&quot;] [&quot;</span> &lt;&lt; err_code.message() &lt;&lt; <span class="stringliteral">&quot;] thus hosing the channel; &quot;</span></div>
<div class="line"><a id="l04116" name="l04116"></a><span class="lineno"> 4116</span>                   <span class="stringliteral">&quot;saving that fail-reason and potentially ending the calling async chain.&quot;</span>);</div>
<div class="line"><a id="l04117" name="l04117"></a><span class="lineno"> 4117</span>  m_channel_err_code_or_ok = err_code; <span class="comment">// It will now never change.</span></div>
<div class="line"><a id="l04118" name="l04118"></a><span class="lineno"> 4118</span> </div>
<div class="line"><a id="l04119" name="l04119"></a><span class="lineno"> 4119</span>  handlers_post(<span class="stringliteral">&quot;handle_new_error()&quot;</span>, [<span class="keyword">this</span>]() <span class="keyword">mutable</span></div>
<div class="line"><a id="l04120" name="l04120"></a><span class="lineno"> 4120</span>  {</div>
<div class="line"><a id="l04121" name="l04121"></a><span class="lineno"> 4121</span>    FLOW_LOG_TRACE(<span class="stringliteral">&quot;struc::Channel [&quot;</span> &lt;&lt; *<span class="keyword">this</span> &lt;&lt; <span class="stringliteral">&quot;]: Invoking on-error user handler.&quot;</span>);</div>
<div class="line"><a id="l04122" name="l04122"></a><span class="lineno"> 4122</span>    assert((!m_on_err_func.empty()) &amp;&amp; <span class="stringliteral">&quot;Bug?  Error shall be reported at most once.&quot;</span>);</div>
<div class="line"><a id="l04123" name="l04123"></a><span class="lineno"> 4123</span>    m_on_err_func(m_channel_err_code_or_ok);</div>
<div class="line"><a id="l04124" name="l04124"></a><span class="lineno"> 4124</span> </div>
<div class="line"><a id="l04125" name="l04125"></a><span class="lineno"> 4125</span>    m_on_err_func.clear(); <span class="comment">// Save RAM.  Also help detect any breaking of promise that we&#39;d invoke it at most once.</span></div>
<div class="line"><a id="l04126" name="l04126"></a><span class="lineno"> 4126</span>  }); <span class="comment">// handlers_post()</span></div>
<div class="line"><a id="l04127" name="l04127"></a><span class="lineno"> 4127</span>} <span class="comment">// Channel::handle_new_error()</span></div>
<div class="line"><a id="l04128" name="l04128"></a><span class="lineno"> 4128</span> </div>
<div class="line"><a id="l04129" name="l04129"></a><span class="lineno"> 4129</span><a class="code hl_define" href="ipc__transport__structured_2src_2ipc_2transport_2struc_2sync__io_2channel_8hpp.html#a50e1bb663274c68c760263342ddfdcbc">TEMPLATE_SIO_STRUCT_CHANNEL</a></div>
<div class="line"><a id="l04130" name="l04130"></a><span class="lineno"> 4130</span><span class="keyword">const</span> <span class="keyword">typename</span> CLASS_SIO_STRUCT_CHANNEL::Builder_config&amp;</div>
<div class="line"><a id="l04131" name="l04131"></a><span class="lineno"><a class="line" href="classipc_1_1transport_1_1struc_1_1sync__io_1_1Channel.html#a48a8fd167c1fe6ae95d8fc80b6a6e67f"> 4131</a></span>  CLASS_SIO_STRUCT_CHANNEL::struct_builder_config()<span class="keyword"> const</span></div>
<div class="line"><a id="l04132" name="l04132"></a><span class="lineno"> 4132</span><span class="keyword"></span>{</div>
<div class="line"><a id="l04133" name="l04133"></a><span class="lineno"> 4133</span>  <span class="keywordflow">return</span> m_struct_builder_config;</div>
<div class="line"><a id="l04134" name="l04134"></a><span class="lineno"> 4134</span>}</div>
<div class="line"><a id="l04135" name="l04135"></a><span class="lineno"> 4135</span> </div>
<div class="line"><a id="l04136" name="l04136"></a><span class="lineno"> 4136</span><a class="code hl_define" href="ipc__transport__structured_2src_2ipc_2transport_2struc_2sync__io_2channel_8hpp.html#a50e1bb663274c68c760263342ddfdcbc">TEMPLATE_SIO_STRUCT_CHANNEL</a></div>
<div class="line"><a id="l04137" name="l04137"></a><span class="lineno"> 4137</span><span class="keyword">const</span> <span class="keyword">typename</span> CLASS_SIO_STRUCT_CHANNEL::Builder_config::Builder::Session&amp;</div>
<div class="line"><a id="l04138" name="l04138"></a><span class="lineno"><a class="line" href="classipc_1_1transport_1_1struc_1_1sync__io_1_1Channel.html#a43fa0b77781376edd13b742b832572e1"> 4138</a></span>  CLASS_SIO_STRUCT_CHANNEL::struct_lender_session()<span class="keyword"> const</span></div>
<div class="line"><a id="l04139" name="l04139"></a><span class="lineno"> 4139</span><span class="keyword"></span>{</div>
<div class="line"><a id="l04140" name="l04140"></a><span class="lineno"> 4140</span>  <span class="keywordflow">return</span> m_struct_lender_session;</div>
<div class="line"><a id="l04141" name="l04141"></a><span class="lineno"> 4141</span>}</div>
<div class="line"><a id="l04142" name="l04142"></a><span class="lineno"> 4142</span> </div>
<div class="line"><a id="l04143" name="l04143"></a><span class="lineno"> 4143</span><a class="code hl_define" href="ipc__transport__structured_2src_2ipc_2transport_2struc_2sync__io_2channel_8hpp.html#a50e1bb663274c68c760263342ddfdcbc">TEMPLATE_SIO_STRUCT_CHANNEL</a></div>
<div class="line"><a id="l04144" name="l04144"></a><span class="lineno"> 4144</span><span class="keyword">const</span> <span class="keyword">typename</span> CLASS_SIO_STRUCT_CHANNEL::Reader_config&amp;</div>
<div class="line"><a id="l04145" name="l04145"></a><span class="lineno"><a class="line" href="classipc_1_1transport_1_1struc_1_1sync__io_1_1Channel.html#a7efbfbcce0d4d426b7df9b6d6fd1e373"> 4145</a></span>  CLASS_SIO_STRUCT_CHANNEL::struct_reader_config()<span class="keyword"> const</span></div>
<div class="line"><a id="l04146" name="l04146"></a><span class="lineno"> 4146</span><span class="keyword"></span>{</div>
<div class="line"><a id="l04147" name="l04147"></a><span class="lineno"> 4147</span>  <span class="keywordflow">return</span> m_struct_reader_config;</div>
<div class="line"><a id="l04148" name="l04148"></a><span class="lineno"> 4148</span>}</div>
<div class="line"><a id="l04149" name="l04149"></a><span class="lineno"> 4149</span> </div>
<div class="line"><a id="l04150" name="l04150"></a><span class="lineno"> 4150</span><a class="code hl_define" href="ipc__transport__structured_2src_2ipc_2transport_2struc_2sync__io_2channel_8hpp.html#a50e1bb663274c68c760263342ddfdcbc">TEMPLATE_SIO_STRUCT_CHANNEL</a></div>
<div class="line"><a id="l04151" name="l04151"></a><span class="lineno"><a class="line" href="classipc_1_1transport_1_1struc_1_1sync__io_1_1Channel.html#ae43681c46951acd7e3c06d3cd73854f6"> 4151</a></span><span class="keywordtype">bool</span> CLASS_SIO_STRUCT_CHANNEL::check_unsendable(<span class="keyword">const</span> <a class="code hl_class" href="classipc_1_1transport_1_1struc_1_1Msg__out.html">Msg_out</a>&amp; msg)<span class="keyword"> const</span></div>
<div class="line"><a id="l04152" name="l04152"></a><span class="lineno"> 4152</span><span class="keyword"></span>{</div>
<div class="line"><a id="l04153" name="l04153"></a><span class="lineno"> 4153</span>  <span class="keywordflow">if</span> <span class="keyword">constexpr</span>(Owned_channel::S_HAS_BLOB_PIPE_ONLY) <span class="comment">// C++17: This is #if-like.</span></div>
<div class="line"><a id="l04154" name="l04154"></a><span class="lineno"> 4154</span>  {</div>
<div class="line"><a id="l04155" name="l04155"></a><span class="lineno"> 4155</span>    <span class="keyword">const</span> <span class="keyword">auto</span> hndl = msg.<a class="code hl_function" href="classipc_1_1transport_1_1struc_1_1Msg__out.html#ae033461f1404be60262033bafcfaccba">native_handle_or_null</a>();</div>
<div class="line"><a id="l04156" name="l04156"></a><span class="lineno"> 4156</span>    <span class="keywordflow">if</span> (!hndl.null())</div>
<div class="line"><a id="l04157" name="l04157"></a><span class="lineno"> 4157</span>    {</div>
<div class="line"><a id="l04158" name="l04158"></a><span class="lineno"> 4158</span>      FLOW_LOG_WARNING(<span class="stringliteral">&quot;struc::Channel [&quot;</span> &lt;&lt; *<span class="keyword">this</span> &lt;&lt; <span class="stringliteral">&quot;]: Send request wants to send native handle &quot;</span></div>
<div class="line"><a id="l04159" name="l04159"></a><span class="lineno"> 4159</span>                       <span class="stringliteral">&quot;[&quot;</span> &lt;&lt; hndl &lt;&lt; <span class="stringliteral">&quot;], but the owned channel is incapable of such &quot;</span></div>
<div class="line"><a id="l04160" name="l04160"></a><span class="lineno"> 4160</span>                       <span class="stringliteral">&quot;transport.  Ignoring.  Bug by user?&quot;</span>);</div>
<div class="line"><a id="l04161" name="l04161"></a><span class="lineno"> 4161</span>      <span class="keywordflow">return</span> <span class="keyword">true</span>;</div>
<div class="line"><a id="l04162" name="l04162"></a><span class="lineno"> 4162</span>    }</div>
<div class="line"><a id="l04163" name="l04163"></a><span class="lineno"> 4163</span>    <span class="comment">// else</span></div>
<div class="line"><a id="l04164" name="l04164"></a><span class="lineno"> 4164</span>  }</div>
<div class="line"><a id="l04165" name="l04165"></a><span class="lineno"> 4165</span>  <span class="keywordflow">return</span> <span class="keyword">false</span>;</div>
<div class="line"><a id="l04166" name="l04166"></a><span class="lineno"> 4166</span>} <span class="comment">// Channel::check_unsendable()</span></div>
<div class="line"><a id="l04167" name="l04167"></a><span class="lineno"> 4167</span> </div>
<div class="line"><a id="l04168" name="l04168"></a><span class="lineno"> 4168</span><a class="code hl_define" href="ipc__transport__structured_2src_2ipc_2transport_2struc_2sync__io_2channel_8hpp.html#a50e1bb663274c68c760263342ddfdcbc">TEMPLATE_SIO_STRUCT_CHANNEL</a></div>
<div class="line"><a id="l04169" name="l04169"></a><span class="lineno"><a class="line" href="classipc_1_1transport_1_1struc_1_1sync__io_1_1Channel.html#a0dc388e18b0fc0fa2d8ad0a6953fb039"> 4169</a></span><span class="keywordtype">bool</span> CLASS_SIO_STRUCT_CHANNEL::send(<span class="keyword">const</span> <a class="code hl_class" href="classipc_1_1transport_1_1struc_1_1Msg__out.html">Msg_out</a>&amp; msg, <span class="keyword">const</span> <a class="code hl_class" href="classipc_1_1transport_1_1struc_1_1Msg__in.html">Msg_in</a>* originating_msg_or_null, <a class="code hl_typedef" href="namespaceipc.html#aa3192e586cc45d3e7c22463bf2760f89">Error_code</a>* err_code)</div>
<div class="line"><a id="l04170" name="l04170"></a><span class="lineno"> 4170</span>{</div>
<div class="line"><a id="l04171" name="l04171"></a><span class="lineno"> 4171</span>  <span class="keywordflow">if</span> (check_not_started_ops(<span class="stringliteral">&quot;send()&quot;</span>))</div>
<div class="line"><a id="l04172" name="l04172"></a><span class="lineno"> 4172</span>  {</div>
<div class="line"><a id="l04173" name="l04173"></a><span class="lineno"> 4173</span>    <span class="keywordflow">return</span> <span class="keyword">false</span>;</div>
<div class="line"><a id="l04174" name="l04174"></a><span class="lineno"> 4174</span>  }</div>
<div class="line"><a id="l04175" name="l04175"></a><span class="lineno"> 4175</span>  <span class="comment">// else</span></div>
<div class="line"><a id="l04176" name="l04176"></a><span class="lineno"> 4176</span> </div>
<div class="line"><a id="l04177" name="l04177"></a><span class="lineno"> 4177</span>  <span class="keywordflow">if</span> (check_unsendable(msg))</div>
<div class="line"><a id="l04178" name="l04178"></a><span class="lineno"> 4178</span>  {</div>
<div class="line"><a id="l04179" name="l04179"></a><span class="lineno"> 4179</span>    <span class="keywordflow">return</span> <span class="keyword">false</span>;</div>
<div class="line"><a id="l04180" name="l04180"></a><span class="lineno"> 4180</span>  }</div>
<div class="line"><a id="l04181" name="l04181"></a><span class="lineno"> 4181</span>  <span class="comment">// else</span></div>
<div class="line"><a id="l04182" name="l04182"></a><span class="lineno"> 4182</span> </div>
<div class="line"><a id="l04183" name="l04183"></a><span class="lineno"> 4183</span>  <span class="keywordflow">if</span> (check_prior_error(<span class="stringliteral">&quot;send()&quot;</span>))</div>
<div class="line"><a id="l04184" name="l04184"></a><span class="lineno"> 4184</span>  {</div>
<div class="line"><a id="l04185" name="l04185"></a><span class="lineno"> 4185</span>    <span class="keywordflow">return</span> <span class="keyword">false</span>;</div>
<div class="line"><a id="l04186" name="l04186"></a><span class="lineno"> 4186</span>  }</div>
<div class="line"><a id="l04187" name="l04187"></a><span class="lineno"> 4187</span>  <span class="comment">// else</span></div>
<div class="line"><a id="l04188" name="l04188"></a><span class="lineno"> 4188</span> </div>
<div class="line"><a id="l04189" name="l04189"></a><span class="lineno"> 4189</span>  <span class="keywordflow">return</span> send_impl(msg, originating_msg_or_null, err_code, <a class="code hl_typedef" href="classipc_1_1transport_1_1struc_1_1sync__io_1_1Channel.html#a583ccd4bb6b1aefb09d77e5709aef5b4">On_msg_func_ptr</a>(), <span class="keyword">nullptr</span>);</div>
<div class="line"><a id="l04190" name="l04190"></a><span class="lineno"> 4190</span>} <span class="comment">// Channel::send()</span></div>
<div class="line"><a id="l04191" name="l04191"></a><span class="lineno"> 4191</span> </div>
<div class="line"><a id="l04192" name="l04192"></a><span class="lineno"> 4192</span><a class="code hl_define" href="ipc__transport__structured_2src_2ipc_2transport_2struc_2sync__io_2channel_8hpp.html#a50e1bb663274c68c760263342ddfdcbc">TEMPLATE_SIO_STRUCT_CHANNEL</a></div>
<div class="line"><a id="l04193" name="l04193"></a><span class="lineno"> 4193</span><span class="keyword">template</span>&lt;<span class="keyword">typename</span> On_msg_handler&gt;</div>
<div class="line"><a id="l04194" name="l04194"></a><span class="lineno"><a class="line" href="classipc_1_1transport_1_1struc_1_1sync__io_1_1Channel.html#a26dc83067e005be38567199cbedd7f19"> 4194</a></span><span class="keywordtype">bool</span> CLASS_SIO_STRUCT_CHANNEL::async_request(<span class="keyword">const</span> <a class="code hl_class" href="classipc_1_1transport_1_1struc_1_1Msg__out.html">Msg_out</a>&amp; msg, <span class="keyword">const</span> <a class="code hl_class" href="classipc_1_1transport_1_1struc_1_1Msg__in.html">Msg_in</a>* originating_msg_or_null,</div>
<div class="line"><a id="l04195" name="l04195"></a><span class="lineno"> 4195</span>                                             <a class="code hl_typedef" href="classipc_1_1transport_1_1struc_1_1Channel__base.html#adcf24fa51747ed83c4b6427fbf44fecf">msg_id_out_t</a>* id_unless_one_off, On_msg_handler&amp;&amp; on_rsp_func,</div>
<div class="line"><a id="l04196" name="l04196"></a><span class="lineno"> 4196</span>                                             <a class="code hl_typedef" href="namespaceipc.html#aa3192e586cc45d3e7c22463bf2760f89">Error_code</a>* err_code)</div>
<div class="line"><a id="l04197" name="l04197"></a><span class="lineno"> 4197</span>{</div>
<div class="line"><a id="l04198" name="l04198"></a><span class="lineno"> 4198</span>  <span class="keyword">using </span>boost::make_shared;</div>
<div class="line"><a id="l04199" name="l04199"></a><span class="lineno"> 4199</span> </div>
<div class="line"><a id="l04200" name="l04200"></a><span class="lineno"> 4200</span>  <span class="keywordflow">if</span> (check_not_started_ops(<span class="stringliteral">&quot;async_request()&quot;</span>))</div>
<div class="line"><a id="l04201" name="l04201"></a><span class="lineno"> 4201</span>  {</div>
<div class="line"><a id="l04202" name="l04202"></a><span class="lineno"> 4202</span>    <span class="keywordflow">return</span> <span class="keyword">false</span>;</div>
<div class="line"><a id="l04203" name="l04203"></a><span class="lineno"> 4203</span>  }</div>
<div class="line"><a id="l04204" name="l04204"></a><span class="lineno"> 4204</span>  <span class="comment">// else</span></div>
<div class="line"><a id="l04205" name="l04205"></a><span class="lineno"> 4205</span> </div>
<div class="line"><a id="l04206" name="l04206"></a><span class="lineno"> 4206</span>  <span class="keywordflow">if</span> (check_unsendable(msg))</div>
<div class="line"><a id="l04207" name="l04207"></a><span class="lineno"> 4207</span>  {</div>
<div class="line"><a id="l04208" name="l04208"></a><span class="lineno"> 4208</span>    <span class="keywordflow">return</span> <span class="keyword">false</span>;</div>
<div class="line"><a id="l04209" name="l04209"></a><span class="lineno"> 4209</span>  }</div>
<div class="line"><a id="l04210" name="l04210"></a><span class="lineno"> 4210</span>  <span class="comment">// else</span></div>
<div class="line"><a id="l04211" name="l04211"></a><span class="lineno"> 4211</span> </div>
<div class="line"><a id="l04212" name="l04212"></a><span class="lineno"> 4212</span>  <span class="keywordflow">if</span> (check_prior_error(<span class="stringliteral">&quot;async_request()&quot;</span>))</div>
<div class="line"><a id="l04213" name="l04213"></a><span class="lineno"> 4213</span>  {</div>
<div class="line"><a id="l04214" name="l04214"></a><span class="lineno"> 4214</span>    <span class="keywordflow">return</span> <span class="keyword">false</span>;</div>
<div class="line"><a id="l04215" name="l04215"></a><span class="lineno"> 4215</span>  }</div>
<div class="line"><a id="l04216" name="l04216"></a><span class="lineno"> 4216</span>  <span class="comment">// else</span></div>
<div class="line"><a id="l04217" name="l04217"></a><span class="lineno"> 4217</span> </div>
<div class="line"><a id="l04218" name="l04218"></a><span class="lineno"> 4218</span>  <span class="keywordflow">return</span> send_impl(msg, originating_msg_or_null, err_code,</div>
<div class="line"><a id="l04219" name="l04219"></a><span class="lineno"> 4219</span>                   make_shared&lt;On_msg_func&gt;(std::move(on_rsp_func)), id_unless_one_off);</div>
<div class="line"><a id="l04220" name="l04220"></a><span class="lineno"> 4220</span>} <span class="comment">// Channel::async_request()</span></div>
<div class="line"><a id="l04221" name="l04221"></a><span class="lineno"> 4221</span> </div>
<div class="line"><a id="l04222" name="l04222"></a><span class="lineno"> 4222</span><a class="code hl_define" href="ipc__transport__structured_2src_2ipc_2transport_2struc_2sync__io_2channel_8hpp.html#a50e1bb663274c68c760263342ddfdcbc">TEMPLATE_SIO_STRUCT_CHANNEL</a></div>
<div class="line"><a id="l04223" name="l04223"></a><span class="lineno"><a class="line" href="classipc_1_1transport_1_1struc_1_1sync__io_1_1Channel.html#aafaf244b9483c724eaba1d6bee561035"> 4223</a></span><span class="keywordtype">bool</span> CLASS_SIO_STRUCT_CHANNEL::send_impl(<span class="keyword">const</span> <a class="code hl_class" href="classipc_1_1transport_1_1struc_1_1Msg__out.html">Msg_out</a>&amp; msg_public, <span class="keyword">const</span> <a class="code hl_class" href="classipc_1_1transport_1_1struc_1_1Msg__in.html">Msg_in</a>* originating_msg_or_null,</div>
<div class="line"><a id="l04224" name="l04224"></a><span class="lineno"> 4224</span>                                         <a class="code hl_typedef" href="namespaceipc.html#aa3192e586cc45d3e7c22463bf2760f89">Error_code</a>* err_code,</div>
<div class="line"><a id="l04225" name="l04225"></a><span class="lineno"> 4225</span>                                         <span class="comment">/* @todo Make it &amp;&amp; for a little perf boost.  T&amp;&amp; doesn&#39;t play well</span></div>
<div class="line"><a id="l04226" name="l04226"></a><span class="lineno"> 4226</span><span class="comment">                                          * with FLOW_ERROR_EXEC_AND_THROW_ON_ERROR(), as I recall, so it&#39;ll take</span></div>
<div class="line"><a id="l04227" name="l04227"></a><span class="lineno"> 4227</span><span class="comment">                                          * a bit of maneuvering. */</span></div>
<div class="line"><a id="l04228" name="l04228"></a><span class="lineno"> 4228</span>                                         <span class="keyword">const</span> <a class="code hl_typedef" href="classipc_1_1transport_1_1struc_1_1sync__io_1_1Channel.html#a583ccd4bb6b1aefb09d77e5709aef5b4">On_msg_func_ptr</a>&amp; on_rsp_func_or_null, <a class="code hl_typedef" href="classipc_1_1transport_1_1struc_1_1Channel__base.html#adcf24fa51747ed83c4b6427fbf44fecf">msg_id_out_t</a>* id_unless_one_off)</div>
<div class="line"><a id="l04229" name="l04229"></a><span class="lineno"> 4229</span>{</div>
<div class="line"><a id="l04230" name="l04230"></a><span class="lineno"> 4230</span>  FLOW_ERROR_EXEC_AND_THROW_ON_ERROR(<span class="keywordtype">bool</span>, Channel::send_impl, flow::util::bind_ns::cref(msg_public),</div>
<div class="line"><a id="l04231" name="l04231"></a><span class="lineno"> 4231</span>                                     originating_msg_or_null, _1, flow::util::bind_ns::cref(on_rsp_func_or_null),</div>
<div class="line"><a id="l04232" name="l04232"></a><span class="lineno"> 4232</span>                                     id_unless_one_off);</div>
<div class="line"><a id="l04233" name="l04233"></a><span class="lineno"> 4233</span>  <span class="comment">// ^-- Call ourselves and return if err_code is null.  If got to present line, err_code is not null.</span></div>
<div class="line"><a id="l04234" name="l04234"></a><span class="lineno"> 4234</span> </div>
<div class="line"><a id="l04235" name="l04235"></a><span class="lineno"> 4235</span>  <span class="keyword">const</span> <span class="keyword">auto</span>&amp; msg = <span class="keyword">static_cast&lt;</span><span class="keyword">const </span><a class="code hl_class" href="classipc_1_1transport_1_1struc_1_1Msg__out__impl.html">Msg_out_impl</a>&amp;<span class="keyword">&gt;</span>(msg_public);</div>
<div class="line"><a id="l04236" name="l04236"></a><span class="lineno"> 4236</span>  <span class="keyword">const</span> <span class="keywordtype">bool</span> one_off = !bool(id_unless_one_off);</div>
<div class="line"><a id="l04237" name="l04237"></a><span class="lineno"> 4237</span> </div>
<div class="line"><a id="l04238" name="l04238"></a><span class="lineno"> 4238</span>  <span class="comment">// See send() doc header which summarizes our course of action.  See also m_channel doc header for context.</span></div>
<div class="line"><a id="l04239" name="l04239"></a><span class="lineno"> 4239</span> </div>
<div class="line"><a id="l04240" name="l04240"></a><span class="lineno"> 4240</span>  <span class="comment">// Send time: generate ID (and seq #; it is important we only generate it now, at sync send() time).</span></div>
<div class="line"><a id="l04241" name="l04241"></a><span class="lineno"> 4241</span>  <span class="keyword">const</span> <span class="keyword">auto</span> <span class="keywordtype">id</span> = m_snd_msg_next_id++;</div>
<div class="line"><a id="l04242" name="l04242"></a><span class="lineno"> 4242</span>  FLOW_LOG_TRACE(<span class="stringliteral">&quot;struc::Channel [&quot;</span> &lt;&lt; *<span class="keyword">this</span> &lt;&lt; <span class="stringliteral">&quot;]: Send request: Generated out-message ID [&quot;</span> &lt;&lt; <span class="keywordtype">id</span> &lt;&lt; <span class="stringliteral">&quot;].&quot;</span>);</div>
<div class="line"><a id="l04243" name="l04243"></a><span class="lineno"> 4243</span> </div>
<div class="line"><a id="l04244" name="l04244"></a><span class="lineno"> 4244</span>  <span class="keywordflow">if</span> ((<span class="keywordtype">id</span> != 1) &amp;&amp; (m_phase != Phase::S_LOGGED_IN))</div>
<div class="line"><a id="l04245" name="l04245"></a><span class="lineno"> 4245</span>  {</div>
<div class="line"><a id="l04246" name="l04246"></a><span class="lineno"> 4246</span>    assert((<span class="keywordtype">id</span> == 2) &amp;&amp; <span class="stringliteral">&quot;How in the hell did we get past this error last time?&quot;</span>);</div>
<div class="line"><a id="l04247" name="l04247"></a><span class="lineno"> 4247</span>    FLOW_LOG_WARNING(<span class="stringliteral">&quot;struc::Channel [&quot;</span> &lt;&lt; *<span class="keyword">this</span> &lt;&lt; <span class="stringliteral">&quot;]: Log-in: Send request wants to send out-message, &quot;</span></div>
<div class="line"><a id="l04248" name="l04248"></a><span class="lineno"> 4248</span>                     <span class="stringliteral">&quot;but in this phase one can send at most one (log-in request on client, response on &quot;</span></div>
<div class="line"><a id="l04249" name="l04249"></a><span class="lineno"> 4249</span>                     <span class="stringliteral">&quot;server), and this is message 2.  Ignoring.&quot;</span>);</div>
<div class="line"><a id="l04250" name="l04250"></a><span class="lineno"> 4250</span>    <span class="comment">// Undo any ID generation we did above....</span></div>
<div class="line"><a id="l04251" name="l04251"></a><span class="lineno"> 4251</span>    --m_snd_msg_next_id;</div>
<div class="line"><a id="l04252" name="l04252"></a><span class="lineno"> 4252</span>    <span class="keywordflow">return</span> <span class="keyword">false</span>;</div>
<div class="line"><a id="l04253" name="l04253"></a><span class="lineno"> 4253</span>  }</div>
<div class="line"><a id="l04254" name="l04254"></a><span class="lineno"> 4254</span>  <span class="comment">// else</span></div>
<div class="line"><a id="l04255" name="l04255"></a><span class="lineno"> 4255</span> </div>
<div class="line"><a id="l04256" name="l04256"></a><span class="lineno"> 4256</span>  <span class="comment">/* Before sending there&#39;s this to take care of: now that the send-time has come, we know the ID (a/k/a seq #,</span></div>
<div class="line"><a id="l04257" name="l04257"></a><span class="lineno"> 4257</span><span class="comment">   * though that doesn&#39;t matter here), and can therefore register the response expectation, if any,</span></div>
<div class="line"><a id="l04258" name="l04258"></a><span class="lineno"> 4258</span><span class="comment">   * in m_rcv_expecting_msg_map.</span></div>
<div class="line"><a id="l04259" name="l04259"></a><span class="lineno"> 4259</span><span class="comment">   *</span></div>
<div class="line"><a id="l04260" name="l04260"></a><span class="lineno"> 4260</span><span class="comment">   * on_rsp_func_or_null non-null =&gt; They&#39;ve supplied async handler for response.</span></div>
<div class="line"><a id="l04261" name="l04261"></a><span class="lineno"> 4261</span><span class="comment">   * m_rcv_expecting_response_map marks down that a response is being awaited. */</span></div>
<div class="line"><a id="l04262" name="l04262"></a><span class="lineno"> 4262</span> </div>
<div class="line"><a id="l04263" name="l04263"></a><span class="lineno"> 4263</span>  <span class="keywordflow">if</span> (on_rsp_func_or_null)</div>
<div class="line"><a id="l04264" name="l04264"></a><span class="lineno"> 4264</span>  {</div>
<div class="line"><a id="l04265" name="l04265"></a><span class="lineno"> 4265</span>    <span class="keywordflow">if</span> (!one_off)</div>
<div class="line"><a id="l04266" name="l04266"></a><span class="lineno"> 4266</span>    {</div>
<div class="line"><a id="l04267" name="l04267"></a><span class="lineno"> 4267</span>      *id_unless_one_off = id; <span class="comment">// Let them know the out-message ID: they can use it in undo_expect_responses().</span></div>
<div class="line"><a id="l04268" name="l04268"></a><span class="lineno"> 4268</span> </div>
<div class="line"><a id="l04269" name="l04269"></a><span class="lineno"> 4269</span>      <span class="comment">// @todo Maybe require one_off=true in CLI_LOG_IN?  I guess it could be fine; just odd.</span></div>
<div class="line"><a id="l04270" name="l04270"></a><span class="lineno"> 4270</span>    }</div>
<div class="line"><a id="l04271" name="l04271"></a><span class="lineno"> 4271</span> </div>
<div class="line"><a id="l04272" name="l04272"></a><span class="lineno"> 4272</span>    <span class="comment">/* A response expectation.  Mental sanity-check for various phases:</span></div>
<div class="line"><a id="l04273" name="l04273"></a><span class="lineno"> 4273</span><span class="comment">     *   - LOGGED_IN: Allowed, of course.</span></div>
<div class="line"><a id="l04274" name="l04274"></a><span class="lineno"> 4274</span><span class="comment">     *   - CLI_LOG_IN: Required (log-in request =&gt; await response to it).</span></div>
<div class="line"><a id="l04275" name="l04275"></a><span class="lineno"> 4275</span><span class="comment">     *   - SRV_LOG_IN: Allowed, though perhaps a bit unorthodox (typically log-in request =&gt; log-in response; and</span></div>
<div class="line"><a id="l04276" name="l04276"></a><span class="lineno"> 4276</span><span class="comment">     *     that ends any exchange).  However, we don&#39;t care.  We enter LOGGED_IN phase below upon successful send;</span></div>
<div class="line"><a id="l04277" name="l04277"></a><span class="lineno"> 4277</span><span class="comment">     *     and if they want to get a reponse to that, that&#39;s their business. */</span></div>
<div class="line"><a id="l04278" name="l04278"></a><span class="lineno"> 4278</span> </div>
<div class="line"><a id="l04279" name="l04279"></a><span class="lineno"> 4279</span><span class="preprocessor">#ifndef NDEBUG</span></div>
<div class="line"><a id="l04280" name="l04280"></a><span class="lineno"> 4280</span>    <span class="keyword">const</span> <span class="keyword">auto</span> result =</div>
<div class="line"><a id="l04281" name="l04281"></a><span class="lineno"> 4281</span><span class="preprocessor">#endif</span></div>
<div class="line"><a id="l04282" name="l04282"></a><span class="lineno"> 4282</span>    m_rcv_expecting_response_map.emplace(<span class="keywordtype">id</span>,</div>
<div class="line"><a id="l04283" name="l04283"></a><span class="lineno"> 4283</span>                                         <span class="keyword">new</span> <a class="code hl_struct" href="structipc_1_1transport_1_1struc_1_1sync__io_1_1Channel_1_1Expecting__response.html">Expecting_response</a>{ one_off, on_rsp_func_or_null });</div>
<div class="line"><a id="l04284" name="l04284"></a><span class="lineno"> 4284</span>    assert(result.second &amp;&amp; <span class="stringliteral">&quot;IDs do not repeat, so dupe-insertion should not be possible.&quot;</span>);</div>
<div class="line"><a id="l04285" name="l04285"></a><span class="lineno"> 4285</span> </div>
<div class="line"><a id="l04286" name="l04286"></a><span class="lineno"> 4286</span>    FLOW_LOG_TRACE(<span class="stringliteral">&quot;struc::Channel [&quot;</span> &lt;&lt; *<span class="keyword">this</span> &lt;&lt; <span class="stringliteral">&quot;]: Registered a (one-off? = [&quot;</span> &lt;&lt; one_off &lt;&lt; <span class="stringliteral">&quot;], &quot;</span></div>
<div class="line"><a id="l04287" name="l04287"></a><span class="lineno"> 4287</span>                   <span class="stringliteral">&quot;response expectation (request about to be sync-nb-sent); that raises their total count to &quot;</span></div>
<div class="line"><a id="l04288" name="l04288"></a><span class="lineno"> 4288</span>                   <span class="stringliteral">&quot;[&quot;</span> &lt;&lt; m_rcv_expecting_response_map.size() &lt;&lt; <span class="stringliteral">&quot;].&quot;</span>);</div>
<div class="line"><a id="l04289" name="l04289"></a><span class="lineno"> 4289</span>    <span class="comment">/* Note: Any failure to send() below is fatal to *this, meaning no further send()s (or receives for that matter)</span></div>
<div class="line"><a id="l04290" name="l04290"></a><span class="lineno"> 4290</span><span class="comment">     * are going to happen.  Hence it does not matter how we&#39;ve changed m_snd_msg_next_id and other things;</span></div>
<div class="line"><a id="l04291" name="l04291"></a><span class="lineno"> 4291</span><span class="comment">     * it&#39;s not like they can be &quot;put back&quot; and &quot;reused.&quot; */</span></div>
<div class="line"><a id="l04292" name="l04292"></a><span class="lineno"> 4292</span>  } <span class="comment">// if (on_rsp_func_or_null)</span></div>
<div class="line"><a id="l04293" name="l04293"></a><span class="lineno"> 4293</span>  <span class="keywordflow">else</span> <span class="keywordflow">if</span> (m_phase == Phase::S_CLI_LOG_IN) <span class="comment">// &amp;&amp; (!on_rsp_func_or_null)</span></div>
<div class="line"><a id="l04294" name="l04294"></a><span class="lineno"> 4294</span>  {</div>
<div class="line"><a id="l04295" name="l04295"></a><span class="lineno"> 4295</span>    <span class="comment">/* No response expectation.  That is certainly fine, usually, except in CLI_LOG_IN, this *must* be the</span></div>
<div class="line"><a id="l04296" name="l04296"></a><span class="lineno"> 4296</span><span class="comment">     * log-in request and hence *must* expect response. */</span></div>
<div class="line"><a id="l04297" name="l04297"></a><span class="lineno"> 4297</span>    FLOW_LOG_WARNING(<span class="stringliteral">&quot;struc::Channel [&quot;</span> &lt;&lt; *<span class="keyword">this</span> &lt;&lt; <span class="stringliteral">&quot;]: Log-in (as client): Send attempt of what must be &quot;</span></div>
<div class="line"><a id="l04298" name="l04298"></a><span class="lineno"> 4298</span>                     <span class="stringliteral">&quot;the log-in request, but they failed to specify it expects a (log-in) response (used send() &quot;</span></div>
<div class="line"><a id="l04299" name="l04299"></a><span class="lineno"> 4299</span>                     <span class="stringliteral">&quot;instead of async_request()).  Ignoring.  &quot;</span></div>
<div class="line"><a id="l04300" name="l04300"></a><span class="lineno"> 4300</span>                     <span class="stringliteral">&quot;In theory they can try sending this log-in request again with the proper API which is &quot;</span></div>
<div class="line"><a id="l04301" name="l04301"></a><span class="lineno"> 4301</span>                     <span class="stringliteral">&quot;async_request().&quot;</span>);</div>
<div class="line"><a id="l04302" name="l04302"></a><span class="lineno"> 4302</span>    <span class="comment">// Undo any ID generation we did above....</span></div>
<div class="line"><a id="l04303" name="l04303"></a><span class="lineno"> 4303</span>    --m_snd_msg_next_id;</div>
<div class="line"><a id="l04304" name="l04304"></a><span class="lineno"> 4304</span>    <span class="keywordflow">return</span> <span class="keyword">false</span>;</div>
<div class="line"><a id="l04305" name="l04305"></a><span class="lineno"> 4305</span>  } <span class="comment">// else if (!on_rsp_func_or_null)</span></div>
<div class="line"><a id="l04306" name="l04306"></a><span class="lineno"> 4306</span>  <span class="comment">/* else if (SRV_LOG_IN or LOGGED_IN) &amp;&amp; (!on_rsp_func_or_null)</span></div>
<div class="line"><a id="l04307" name="l04307"></a><span class="lineno"> 4307</span><span class="comment">   * { In LOGGED_IN and SRV_LOG_IN, this is allowed.  Nothing more to do about it though. } */</span></div>
<div class="line"><a id="l04308" name="l04308"></a><span class="lineno"> 4308</span> </div>
<div class="line"><a id="l04309" name="l04309"></a><span class="lineno"> 4309</span>  <span class="comment">// Check for invalid situations w/r/t whether this is a response to something or unsolicited.</span></div>
<div class="line"><a id="l04310" name="l04310"></a><span class="lineno"> 4310</span>  <span class="keywordflow">if</span> ((!originating_msg_or_null) &amp;&amp; (m_phase == Phase::S_SRV_LOG_IN))</div>
<div class="line"><a id="l04311" name="l04311"></a><span class="lineno"> 4311</span>  {</div>
<div class="line"><a id="l04312" name="l04312"></a><span class="lineno"> 4312</span>    <span class="comment">/* Unsolicited.  That is certainly fine, usually, except in SRV_LOG_IN, this *must* be the</span></div>
<div class="line"><a id="l04313" name="l04313"></a><span class="lineno"> 4313</span><span class="comment">     * log-in reponse and hence *must* be a... response. */</span></div>
<div class="line"><a id="l04314" name="l04314"></a><span class="lineno"> 4314</span>    FLOW_LOG_WARNING(<span class="stringliteral">&quot;struc::Channel [&quot;</span> &lt;&lt; *<span class="keyword">this</span> &lt;&lt; <span class="stringliteral">&quot;]: Log-in (as server): Send attempt of what must be &quot;</span></div>
<div class="line"><a id="l04315" name="l04315"></a><span class="lineno"> 4315</span>                     <span class="stringliteral">&quot;the log-in response, but they failed to specify that it *is* a response.  Ignoring.  &quot;</span></div>
<div class="line"><a id="l04316" name="l04316"></a><span class="lineno"> 4316</span>                     <span class="stringliteral">&quot;In theory they can try sending this log-in response again with the proper form of send().&quot;</span>);</div>
<div class="line"><a id="l04317" name="l04317"></a><span class="lineno"> 4317</span>    <span class="comment">// Undo any ID generation we did above....</span></div>
<div class="line"><a id="l04318" name="l04318"></a><span class="lineno"> 4318</span>    --m_snd_msg_next_id;</div>
<div class="line"><a id="l04319" name="l04319"></a><span class="lineno"> 4319</span>    <span class="keywordflow">return</span> <span class="keyword">false</span>;</div>
<div class="line"><a id="l04320" name="l04320"></a><span class="lineno"> 4320</span>  } <span class="comment">// if ((!originating_msg_or_null) || (m_phase == Phase::S_SRV_LOG_IN))</span></div>
<div class="line"><a id="l04321" name="l04321"></a><span class="lineno"> 4321</span>  <span class="comment">// else</span></div>
<div class="line"><a id="l04322" name="l04322"></a><span class="lineno"> 4322</span>  <span class="keywordflow">if</span> (originating_msg_or_null &amp;&amp; (m_phase == Phase::S_CLI_LOG_IN))</div>
<div class="line"><a id="l04323" name="l04323"></a><span class="lineno"> 4323</span>  {</div>
<div class="line"><a id="l04324" name="l04324"></a><span class="lineno"> 4324</span>    <span class="comment">/* Response.  That is certainly fine, usually, except in CLI_LOG_IN, this *must* be the</span></div>
<div class="line"><a id="l04325" name="l04325"></a><span class="lineno"> 4325</span><span class="comment">     * log-in request which cannot be replying to anything else.  A little hard to imagine how the rest of the</span></div>
<div class="line"><a id="l04326" name="l04326"></a><span class="lineno"> 4326</span><span class="comment">     * logic would let things get this far, but anyway better safe than sorry. */</span></div>
<div class="line"><a id="l04327" name="l04327"></a><span class="lineno"> 4327</span>    FLOW_LOG_WARNING(<span class="stringliteral">&quot;struc::Channel [&quot;</span> &lt;&lt; *<span class="keyword">this</span> &lt;&lt; <span class="stringliteral">&quot;]: Log-in (as server): Send attempt of what must be &quot;</span></div>
<div class="line"><a id="l04328" name="l04328"></a><span class="lineno"> 4328</span>                     <span class="stringliteral">&quot;the log-in request, but somehow they specified it&#39;s a response itself.  Ignoring.  &quot;</span></div>
<div class="line"><a id="l04329" name="l04329"></a><span class="lineno"> 4329</span>                     <span class="stringliteral">&quot;In theory they can try sending this log-in request again with the proper form of send().&quot;</span>);</div>
<div class="line"><a id="l04330" name="l04330"></a><span class="lineno"> 4330</span>    <span class="comment">// Undo any ID generation we did above....</span></div>
<div class="line"><a id="l04331" name="l04331"></a><span class="lineno"> 4331</span>    --m_snd_msg_next_id;</div>
<div class="line"><a id="l04332" name="l04332"></a><span class="lineno"> 4332</span>    <span class="keywordflow">return</span> <span class="keyword">false</span>;</div>
<div class="line"><a id="l04333" name="l04333"></a><span class="lineno"> 4333</span>  } <span class="comment">// else if (originating_msg_or_null &amp;&amp; (m_phase == Phase::S_CLI_LOG_IN))</span></div>
<div class="line"><a id="l04334" name="l04334"></a><span class="lineno"> 4334</span> </div>
<div class="line"><a id="l04335" name="l04335"></a><span class="lineno"> 4335</span>  <span class="comment">// else (any other message can be a response or not; all allowed)</span></div>
<div class="line"><a id="l04336" name="l04336"></a><span class="lineno"> 4336</span> </div>
<div class="line"><a id="l04337" name="l04337"></a><span class="lineno"> 4337</span>  <span class="comment">/* From this point on, if anything fails, then *this is hosed (at least in the send direction).</span></div>
<div class="line"><a id="l04338" name="l04338"></a><span class="lineno"> 4338</span><span class="comment">   * So, like, in particular m_snd_msg_next_id does not matter anymore and need not be re-decremented or what-not. */</span></div>
<div class="line"><a id="l04339" name="l04339"></a><span class="lineno"> 4339</span> </div>
<div class="line"><a id="l04340" name="l04340"></a><span class="lineno"> 4340</span>  <span class="comment">// Prepare the metadata (internal message describing the user message right after it).</span></div>
<div class="line"><a id="l04341" name="l04341"></a><span class="lineno"> 4341</span>  <a class="code hl_class" href="classipc_1_1transport_1_1struc_1_1Msg__mdt__out.html">Msg_mdt_out</a> mdt(m_struct_builder_config, m_session_token,</div>
<div class="line"><a id="l04342" name="l04342"></a><span class="lineno"> 4342</span>                  originating_msg_or_null</div>
<div class="line"><a id="l04343" name="l04343"></a><span class="lineno"> 4343</span>                    ? <span class="keyword">static_cast&lt;</span><span class="keyword">const </span><a class="code hl_class" href="classipc_1_1transport_1_1struc_1_1Msg__in__impl.html">Msg_in_impl</a>*<span class="keyword">&gt;</span>(originating_msg_or_null)-&gt;id_or_none()</div>
<div class="line"><a id="l04344" name="l04344"></a><span class="lineno"> 4344</span>                    : 0,</div>
<div class="line"><a id="l04345" name="l04345"></a><span class="lineno"> 4345</span>                  <span class="keywordtype">id</span>, msg.n_serialization_segments());</div>
<div class="line"><a id="l04346" name="l04346"></a><span class="lineno"> 4346</span> </div>
<div class="line"><a id="l04347" name="l04347"></a><span class="lineno"> 4347</span>  <span class="comment">// Lastly actually send both things.</span></div>
<div class="line"><a id="l04348" name="l04348"></a><span class="lineno"> 4348</span>  <span class="keywordflow">return</span> send_core(mdt, &amp;msg, err_code);</div>
<div class="line"><a id="l04349" name="l04349"></a><span class="lineno"> 4349</span>} <span class="comment">// Channel::send_impl()</span></div>
<div class="line"><a id="l04350" name="l04350"></a><span class="lineno"> 4350</span> </div>
<div class="line"><a id="l04351" name="l04351"></a><span class="lineno"> 4351</span><a class="code hl_define" href="ipc__transport__structured_2src_2ipc_2transport_2struc_2sync__io_2channel_8hpp.html#a50e1bb663274c68c760263342ddfdcbc">TEMPLATE_SIO_STRUCT_CHANNEL</a></div>
<div class="line"><a id="l04352" name="l04352"></a><span class="lineno"><a class="line" href="classipc_1_1transport_1_1struc_1_1sync__io_1_1Channel.html#a0550bcab7578fcd9aa90a4add39eb3c7"> 4352</a></span><span class="keywordtype">bool</span> CLASS_SIO_STRUCT_CHANNEL::send_core(<span class="keyword">const</span> <a class="code hl_class" href="classipc_1_1transport_1_1struc_1_1Msg__mdt__out.html">Msg_mdt_out</a>&amp; mdt, <span class="keyword">const</span> <a class="code hl_class" href="classipc_1_1transport_1_1struc_1_1Msg__out__impl.html">Msg_out_impl</a>* msg,</div>
<div class="line"><a id="l04353" name="l04353"></a><span class="lineno"> 4353</span>                                         <a class="code hl_typedef" href="namespaceipc.html#aa3192e586cc45d3e7c22463bf2760f89">Error_code</a>* err_code_or_ignore)</div>
<div class="line"><a id="l04354" name="l04354"></a><span class="lineno"> 4354</span>{</div>
<div class="line"><a id="l04355" name="l04355"></a><span class="lineno"> 4355</span>  <span class="comment">/* `sink` used only if err_code_or_ignore is null -- we are to ignore any error and let the next send*() catch it.</span></div>
<div class="line"><a id="l04356" name="l04356"></a><span class="lineno"> 4356</span><span class="comment">   * As of this writing used only for internal messages which are best-effort. */</span></div>
<div class="line"><a id="l04357" name="l04357"></a><span class="lineno"> 4357</span>  <a class="code hl_typedef" href="namespaceipc.html#aa3192e586cc45d3e7c22463bf2760f89">Error_code</a> sink;</div>
<div class="line"><a id="l04358" name="l04358"></a><span class="lineno"> 4358</span>  <a class="code hl_typedef" href="namespaceipc.html#aa3192e586cc45d3e7c22463bf2760f89">Error_code</a>* <span class="keyword">const</span> err_code = err_code_or_ignore ? err_code_or_ignore : &amp;sink;</div>
<div class="line"><a id="l04359" name="l04359"></a><span class="lineno"> 4359</span> </div>
<div class="line"><a id="l04360" name="l04360"></a><span class="lineno"> 4360</span>  <span class="comment">// See send() doc header which summarizes our course of action.  See also m_channel doc header for context.</span></div>
<div class="line"><a id="l04361" name="l04361"></a><span class="lineno"> 4361</span> </div>
<div class="line"><a id="l04362" name="l04362"></a><span class="lineno"> 4362</span>  <span class="comment">/* One more thing before we really do stuff -- as discussed in send_proto_neg() -- if protocol-negotiation</span></div>
<div class="line"><a id="l04363" name="l04363"></a><span class="lineno"> 4363</span><span class="comment">   * message send failed, and we got here (meaning !check_prior_error(), meaning !m_channel_err_code_or_ok, meaning</span></div>
<div class="line"><a id="l04364" name="l04364"></a><span class="lineno"> 4364</span><span class="comment">   * no prior send_core() or start_and_poll() got to it first), then promote that saved protocol-negotiation-send</span></div>
<div class="line"><a id="l04365" name="l04365"></a><span class="lineno"> 4365</span><span class="comment">   * error to m_channel_err_code_or_ok and emit it (the latter done one time for *this, as usual). */</span></div>
<div class="line"><a id="l04366" name="l04366"></a><span class="lineno"> 4366</span>  <span class="keywordflow">if</span> (m_proto_neg_err_code_or_ok)</div>
<div class="line"><a id="l04367" name="l04367"></a><span class="lineno"> 4367</span>  {</div>
<div class="line"><a id="l04368" name="l04368"></a><span class="lineno"> 4368</span>    FLOW_LOG_WARNING(<span class="stringliteral">&quot;struc::Channel [&quot;</span> &lt;&lt; *<span class="keyword">this</span> &lt;&lt; <span class="stringliteral">&quot;]: Send request wants to send out-message, &quot;</span></div>
<div class="line"><a id="l04369" name="l04369"></a><span class="lineno"> 4369</span>                     <span class="stringliteral">&quot;but earlier protocol-negotiation message send along a pipe failed (error [&quot;</span> &lt;&lt; *err_code &lt;&lt; <span class="stringliteral">&quot;] &quot;</span></div>
<div class="line"><a id="l04370" name="l04370"></a><span class="lineno"> 4370</span>                     <span class="stringliteral">&quot;[&quot;</span> &lt;&lt; err_code-&gt;message() &lt;&lt; <span class="stringliteral">&quot;]).  We now promote this &quot;</span></div>
<div class="line"><a id="l04371" name="l04371"></a><span class="lineno"> 4371</span>                     <span class="stringliteral">&quot;to a channel-hosing error; emitting it.&quot;</span>);</div>
<div class="line"><a id="l04372" name="l04372"></a><span class="lineno"> 4372</span> </div>
<div class="line"><a id="l04373" name="l04373"></a><span class="lineno"> 4373</span>    assert(err_code_or_ignore</div>
<div class="line"><a id="l04374" name="l04374"></a><span class="lineno"> 4374</span>           &amp;&amp; <span class="stringliteral">&quot;No internal messages shall be sent before start_and_poll() begins read chain.  Did this change?  &quot;</span></div>
<div class="line"><a id="l04375" name="l04375"></a><span class="lineno"> 4375</span>                <span class="stringliteral">&quot;Just did not want to deal with the subtleties of that + m_proto_neg_err_code_or_ok &quot;</span></div>
<div class="line"><a id="l04376" name="l04376"></a><span class="lineno"> 4376</span>                <span class="stringliteral">&quot;until really necessary, if ever.&quot;</span>);</div>
<div class="line"><a id="l04377" name="l04377"></a><span class="lineno"> 4377</span>    m_channel_err_code_or_ok = *err_code = m_proto_neg_err_code_or_ok;</div>
<div class="line"><a id="l04378" name="l04378"></a><span class="lineno"> 4378</span>    <span class="keywordflow">return</span> <span class="keyword">true</span>; <span class="comment">// This is similar to send_*() failing below, as far as the user is concerned.</span></div>
<div class="line"><a id="l04379" name="l04379"></a><span class="lineno"> 4379</span>  } <span class="comment">// if (m_proto_neg_err_code_or_ok)</span></div>
<div class="line"><a id="l04380" name="l04380"></a><span class="lineno"> 4380</span> </div>
<div class="line"><a id="l04381" name="l04381"></a><span class="lineno"> 4381</span>  <span class="comment">/* Let&#39;s send!  This is the other side of the logic on the receive side.  See start_and_poll()</span></div>
<div class="line"><a id="l04382" name="l04382"></a><span class="lineno"> 4382</span><span class="comment">   * where that&#39;s kicked off.  It will refer you to Msg_in_pipe doc header and so on.  The below should follow</span></div>
<div class="line"><a id="l04383" name="l04383"></a><span class="lineno"> 4383</span><span class="comment">   * from that understanding.  So we&#39;ll keep inline comments fairly svelte, unless there&#39;s new info.</span></div>
<div class="line"><a id="l04384" name="l04384"></a><span class="lineno"> 4384</span><span class="comment">   *</span></div>
<div class="line"><a id="l04385" name="l04385"></a><span class="lineno"> 4385</span><span class="comment">   * One thing that wouldn&#39;t be clear from the above is: A *sent* out-message really consists of two</span></div>
<div class="line"><a id="l04386" name="l04386"></a><span class="lineno"> 4386</span><span class="comment">   * sub-messages: mdt (the description and/or internal message), and msg (the user message -- or none).</span></div>
<div class="line"><a id="l04387" name="l04387"></a><span class="lineno"> 4387</span><span class="comment">   * A *received* in-message consists of *both* together in one Msg_in (user being able to access only</span></div>
<div class="line"><a id="l04388" name="l04388"></a><span class="lineno"> 4388</span><span class="comment">   * the user message, if message is even emitted to them -- internal messages aren&#39;t directly so emitted).</span></div>
<div class="line"><a id="l04389" name="l04389"></a><span class="lineno"> 4389</span><span class="comment">   * On the Msg_in this works transparently: we just call add_serialization_segment() 1+ times, and it</span></div>
<div class="line"><a id="l04390" name="l04390"></a><span class="lineno"> 4390</span><span class="comment">   * figures out which of those encodes `mdt` and which `msg`.  So... how?  Answer: It expects (by</span></div>
<div class="line"><a id="l04391" name="l04391"></a><span class="lineno"> 4391</span><span class="comment">   * its contract) the first segment to be the 1-segment serialization of `mdt`; while all the following</span></div>
<div class="line"><a id="l04392" name="l04392"></a><span class="lineno"> 4392</span><span class="comment">   * (0 of them, if there&#39;s no user message = internal message) encode `msg`.  So that&#39;s what we do:</span></div>
<div class="line"><a id="l04393" name="l04393"></a><span class="lineno"> 4393</span><span class="comment">   * mdt.emit_serialization(); send that; msg-&gt;emit_serialization() (if not null); send all those.</span></div>
<div class="line"><a id="l04394" name="l04394"></a><span class="lineno"> 4394</span><span class="comment">   * That is what Msg_in expects by contract.  On the other side it&#39;s transparent: all 1+</span></div>
<div class="line"><a id="l04395" name="l04395"></a><span class="lineno"> 4395</span><span class="comment">   * segments are fed into Msg_in, and it figures out what&#39;s what. */</span></div>
<div class="line"><a id="l04396" name="l04396"></a><span class="lineno"> 4396</span> </div>
<div class="line"><a id="l04397" name="l04397"></a><span class="lineno"> 4397</span>  <a class="code hl_typedef" href="namespaceipc_1_1transport_1_1struc.html#a82a69eaa39cbe8a002de1266f1cbb5cb">Segment_ptrs</a> blobs_out;</div>
<div class="line"><a id="l04398" name="l04398"></a><span class="lineno"> 4398</span>  blobs_out.reserve(1 + (msg ? msg-&gt;<a class="code hl_function" href="classipc_1_1transport_1_1struc_1_1Msg__out__impl.html#a98fdfc10c77d95b8d9817403168a6282">n_serialization_segments</a>() : 0)); <span class="comment">// Tiny optimization.</span></div>
<div class="line"><a id="l04399" name="l04399"></a><span class="lineno"> 4399</span> </div>
<div class="line"><a id="l04400" name="l04400"></a><span class="lineno"> 4400</span>  blobs_out.push_back(mdt.<a class="code hl_function" href="classipc_1_1transport_1_1struc_1_1Msg__mdt__out.html#a267d8cad7e43fa969c09ae44cf7bafec">emit_serialization</a>(m_struct_lender_session, err_code));</div>
<div class="line"><a id="l04401" name="l04401"></a><span class="lineno"> 4401</span>  <span class="keywordflow">if</span> (*err_code)</div>
<div class="line"><a id="l04402" name="l04402"></a><span class="lineno"> 4402</span>  {</div>
<div class="line"><a id="l04403" name="l04403"></a><span class="lineno"> 4403</span>    FLOW_LOG_WARNING(<span class="stringliteral">&quot;struc::Channel [&quot;</span> &lt;&lt; *<span class="keyword">this</span> &lt;&lt; <span class="stringliteral">&quot;]: Send request wants to send out-message, &quot;</span></div>
<div class="line"><a id="l04404" name="l04404"></a><span class="lineno"> 4404</span>                     <span class="stringliteral">&quot;but the metadata (description/internal) serialization is illegal (error [&quot;</span> &lt;&lt; *err_code &lt;&lt; <span class="stringliteral">&quot;] &quot;</span></div>
<div class="line"><a id="l04405" name="l04405"></a><span class="lineno"> 4405</span>                     <span class="stringliteral">&quot;[&quot;</span> &lt;&lt; err_code-&gt;message() &lt;&lt; <span class="stringliteral">&quot;]).  This is a channel-hosing error; emitting it &quot;</span></div>
<div class="line"><a id="l04406" name="l04406"></a><span class="lineno"> 4406</span>                     <span class="stringliteral">&quot;unless internally-ignoring (are we? = [&quot;</span> &lt;&lt; (!err_code_or_ignore) &lt;&lt; <span class="stringliteral">&quot;]).&quot;</span>);</div>
<div class="line"><a id="l04407" name="l04407"></a><span class="lineno"> 4407</span>    err_code_or_ignore &amp;&amp; (m_channel_err_code_or_ok = *err_code);</div>
<div class="line"><a id="l04408" name="l04408"></a><span class="lineno"> 4408</span>    <span class="keywordflow">return</span> <span class="keyword">true</span>; <span class="comment">// This is similar to send_*() failing below, as far as the user is concerned.</span></div>
<div class="line"><a id="l04409" name="l04409"></a><span class="lineno"> 4409</span>  }</div>
<div class="line"><a id="l04410" name="l04410"></a><span class="lineno"> 4410</span>  <span class="comment">// else</span></div>
<div class="line"><a id="l04411" name="l04411"></a><span class="lineno"> 4411</span> </div>
<div class="line"><a id="l04412" name="l04412"></a><span class="lineno"> 4412</span>  <span class="comment">/* Note this does not rise to the level of a user-data dump; so TRACE level (versus DATA) is defensible.</span></div>
<div class="line"><a id="l04413" name="l04413"></a><span class="lineno"> 4413</span><span class="comment">   * It ain&#39;t quick, but its size is capped pretty well.  Possible exception: an internal message containing</span></div>
<div class="line"><a id="l04414" name="l04414"></a><span class="lineno"> 4414</span><span class="comment">   * a dump of an unexpected response (see where m_on_unexpected_response_func_or_empty is invoked)</span></div>
<div class="line"><a id="l04415" name="l04415"></a><span class="lineno"> 4415</span><span class="comment">   * could be huge; but actually we cap that pretty well too (before it gets here). */</span></div>
<div class="line"><a id="l04416" name="l04416"></a><span class="lineno"> 4416</span>  FLOW_LOG_TRACE(<span class="stringliteral">&quot;struc::Channel [&quot;</span> &lt;&lt; *<span class="keyword">this</span> &lt;&lt; <span class="stringliteral">&quot;]: Send request wants to send out-message; here is &quot;</span></div>
<div class="line"><a id="l04417" name="l04417"></a><span class="lineno"> 4417</span>                 <span class="stringliteral">&quot;the metadata header (there may also be a DATA message below with the complete user &quot;</span></div>
<div class="line"><a id="l04418" name="l04418"></a><span class="lineno"> 4418</span>                 <span class="stringliteral">&quot;message payload if any; and/or TRACE message with similar):&quot;</span></div>
<div class="line"><a id="l04419" name="l04419"></a><span class="lineno"> 4419</span>                 <span class="comment">/* @todo The -&gt;asReader() thing should not be necessary according to pretty-print.h doc header,</span></div>
<div class="line"><a id="l04420" name="l04420"></a><span class="lineno"> 4420</span><span class="comment">                  * but, perhaps, gcc-8.3 gets confused with all the implicit conversions; so we &quot;help out.&quot;</span></div>
<div class="line"><a id="l04421" name="l04421"></a><span class="lineno"> 4421</span><span class="comment">                  * Revisit; also for the prettyPrint() higher up in this method. */</span></div>
<div class="line"><a id="l04422" name="l04422"></a><span class="lineno"> 4422</span>                 <span class="stringliteral">&quot;\n&quot;</span> &lt;&lt; ::capnp::prettyPrint(mdt.<a class="code hl_function" href="classipc_1_1transport_1_1struc_1_1Msg__mdt__out.html#a4dae089f324bbdf98d838ddc70abdc9e">body_root</a>()-&gt;asReader()).flatten().cStr());</div>
<div class="line"><a id="l04423" name="l04423"></a><span class="lineno"> 4423</span> </div>
<div class="line"><a id="l04424" name="l04424"></a><span class="lineno"> 4424</span>  <span class="keywordflow">if</span> (msg)</div>
<div class="line"><a id="l04425" name="l04425"></a><span class="lineno"> 4425</span>  {</div>
<div class="line"><a id="l04426" name="l04426"></a><span class="lineno"> 4426</span>    msg-&gt;<a class="code hl_function" href="classipc_1_1transport_1_1struc_1_1Msg__out__impl.html#a80de3b0b3783c53d06f0fac44248405c">emit_serialization</a>(&amp;blobs_out, m_struct_lender_session, err_code); <span class="comment">// Appends to blobs_out.</span></div>
<div class="line"><a id="l04427" name="l04427"></a><span class="lineno"> 4427</span>    <span class="keywordflow">if</span> (*err_code)</div>
<div class="line"><a id="l04428" name="l04428"></a><span class="lineno"> 4428</span>    {</div>
<div class="line"><a id="l04429" name="l04429"></a><span class="lineno"> 4429</span>      FLOW_LOG_WARNING(<span class="stringliteral">&quot;struc::Channel [&quot;</span> &lt;&lt; *<span class="keyword">this</span> &lt;&lt; <span class="stringliteral">&quot;]: Send request wants to send out-message, &quot;</span></div>
<div class="line"><a id="l04430" name="l04430"></a><span class="lineno"> 4430</span>                       <span class="stringliteral">&quot;but the user-message serialization is illegal (error [&quot;</span> &lt;&lt; *err_code &lt;&lt; <span class="stringliteral">&quot;] &quot;</span></div>
<div class="line"><a id="l04431" name="l04431"></a><span class="lineno"> 4431</span>                       <span class="stringliteral">&quot;[&quot;</span> &lt;&lt; err_code-&gt;message() &lt;&lt; <span class="stringliteral">&quot;]).  This is a channel-hosing error; emitting it &quot;</span></div>
<div class="line"><a id="l04432" name="l04432"></a><span class="lineno"> 4432</span>                       <span class="stringliteral">&quot;unless internally-ignoring (are we? = [&quot;</span> &lt;&lt; (!err_code_or_ignore) &lt;&lt; <span class="stringliteral">&quot;]).&quot;</span>);</div>
<div class="line"><a id="l04433" name="l04433"></a><span class="lineno"> 4433</span>      err_code_or_ignore &amp;&amp; (m_channel_err_code_or_ok = *err_code);</div>
<div class="line"><a id="l04434" name="l04434"></a><span class="lineno"> 4434</span>      <span class="keywordflow">return</span> <span class="keyword">true</span>; <span class="comment">// This is similar to send_*() failing below, as far as the user is concerned.</span></div>
<div class="line"><a id="l04435" name="l04435"></a><span class="lineno"> 4435</span>    }</div>
<div class="line"><a id="l04436" name="l04436"></a><span class="lineno"> 4436</span>    <span class="comment">// else:</span></div>
<div class="line"><a id="l04437" name="l04437"></a><span class="lineno"> 4437</span> </div>
<div class="line"><a id="l04438" name="l04438"></a><span class="lineno"> 4438</span>    <span class="comment">// This has some other interesting info plus a (possibly truncated) one-line representation of body_root() contents.</span></div>
<div class="line"><a id="l04439" name="l04439"></a><span class="lineno"> 4439</span>    FLOW_LOG_TRACE(<span class="stringliteral">&quot;struc::Channel [&quot;</span> &lt;&lt; *<span class="keyword">this</span> &lt;&lt; <span class="stringliteral">&quot;]: Send request wants to send (user) out-message &quot;</span></div>
<div class="line"><a id="l04440" name="l04440"></a><span class="lineno"> 4440</span>                   <span class="stringliteral">&quot;[&quot;</span> &lt;&lt; *msg &lt;&lt; <span class="stringliteral">&quot;].&quot;</span>);</div>
<div class="line"><a id="l04441" name="l04441"></a><span class="lineno"> 4441</span> </div>
<div class="line"><a id="l04442" name="l04442"></a><span class="lineno"> 4442</span>    <span class="comment">/* Print the entire contents with indentation/newlines.</span></div>
<div class="line"><a id="l04443" name="l04443"></a><span class="lineno"> 4443</span><span class="comment">     * The user message could be giant.  By definition that is for DATA verbosity only.</span></div>
<div class="line"><a id="l04444" name="l04444"></a><span class="lineno"> 4444</span><span class="comment">     * In addition even the mere computation of what to print (e.g., if we wanted to truncate it before printing</span></div>
<div class="line"><a id="l04445" name="l04445"></a><span class="lineno"> 4445</span><span class="comment">     * at TRACE level) is potentially cripplingly slow; so absolutely do not do it outside the log macro. */</span></div>
<div class="line"><a id="l04446" name="l04446"></a><span class="lineno"> 4446</span>    FLOW_LOG_DATA(<span class="stringliteral">&quot;struc::Channel [&quot;</span> &lt;&lt; *<span class="keyword">this</span> &lt;&lt; <span class="stringliteral">&quot;]: Here is the complete user &quot;</span></div>
<div class="line"><a id="l04447" name="l04447"></a><span class="lineno"> 4447</span>                  <span class="comment">// @todo See above to-do regarding asReader().</span></div>
<div class="line"><a id="l04448" name="l04448"></a><span class="lineno"> 4448</span>                  <span class="stringliteral">&quot;message:\n&quot;</span> &lt;&lt; ::capnp::prettyPrint(msg-&gt;<a class="code hl_function" href="classipc_1_1transport_1_1struc_1_1Msg__out.html#a9894ad7ec2a46641c4b9b86664d0d465">body_root</a>()-&gt;asReader()).flatten().cStr());</div>
<div class="line"><a id="l04449" name="l04449"></a><span class="lineno"> 4449</span> </div>
<div class="line"><a id="l04450" name="l04450"></a><span class="lineno"> 4450</span>    <span class="comment">// Fall through.</span></div>
<div class="line"><a id="l04451" name="l04451"></a><span class="lineno"> 4451</span>  } <span class="comment">// if (msg)</span></div>
<div class="line"><a id="l04452" name="l04452"></a><span class="lineno"> 4452</span>  <span class="keywordflow">else</span></div>
<div class="line"><a id="l04453" name="l04453"></a><span class="lineno"> 4453</span>  {</div>
<div class="line"><a id="l04454" name="l04454"></a><span class="lineno"> 4454</span>    assert((m_phase == Phase::S_LOGGED_IN)</div>
<div class="line"><a id="l04455" name="l04455"></a><span class="lineno"> 4455</span>           &amp;&amp; <span class="stringliteral">&quot;We do not mess with internal messages until log-in has finished.  Bug?&quot;</span>);</div>
<div class="line"><a id="l04456" name="l04456"></a><span class="lineno"> 4456</span>  }</div>
<div class="line"><a id="l04457" name="l04457"></a><span class="lineno"> 4457</span> </div>
<div class="line"><a id="l04458" name="l04458"></a><span class="lineno"> 4458</span>  <span class="comment">// That&#39;s it.  Now it&#39;s just blobs to send out, regardless of what they represent.</span></div>
<div class="line"><a id="l04459" name="l04459"></a><span class="lineno"> 4459</span> </div>
<div class="line"><a id="l04460" name="l04460"></a><span class="lineno"> 4460</span>  <span class="keyword">const</span> <span class="keyword">auto</span> hndl = msg ? msg-&gt;<a class="code hl_function" href="classipc_1_1transport_1_1struc_1_1Msg__out.html#ae033461f1404be60262033bafcfaccba">native_handle_or_null</a>() : <a class="code hl_typedef" href="namespaceipc_1_1transport.html#a7ee4551983d9df16ec16a3139bac50e8">Native_handle</a>();</div>
<div class="line"><a id="l04461" name="l04461"></a><span class="lineno"> 4461</span>  [[maybe_unused]] <span class="keyword">const</span> <span class="keywordtype">bool</span> has_hndl = !hndl.null();</div>
<div class="line"><a id="l04462" name="l04462"></a><span class="lineno"> 4462</span> </div>
<div class="line"><a id="l04463" name="l04463"></a><span class="lineno"> 4463</span>  <span class="comment">// Synchronous helpers.</span></div>
<div class="line"><a id="l04464" name="l04464"></a><span class="lineno"> 4464</span>  [[maybe_unused]] <span class="keyword">const</span> <span class="keyword">auto</span> send_blobs = [&amp;]()</div>
<div class="line"><a id="l04465" name="l04465"></a><span class="lineno"> 4465</span>  {</div>
<div class="line"><a id="l04466" name="l04466"></a><span class="lineno"> 4466</span>    <span class="keywordflow">if</span> <span class="keyword">constexpr</span>(Owned_channel::S_HAS_BLOB_PIPE)</div>
<div class="line"><a id="l04467" name="l04467"></a><span class="lineno"> 4467</span>    {</div>
<div class="line"><a id="l04468" name="l04468"></a><span class="lineno"> 4468</span>      <span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span>&amp; blob : blobs_out)</div>
<div class="line"><a id="l04469" name="l04469"></a><span class="lineno"> 4469</span>      {</div>
<div class="line"><a id="l04470" name="l04470"></a><span class="lineno"> 4470</span><span class="preprocessor">#ifndef NDEBUG</span></div>
<div class="line"><a id="l04471" name="l04471"></a><span class="lineno"> 4471</span>        <span class="keyword">const</span> <span class="keywordtype">bool</span> ok =</div>
<div class="line"><a id="l04472" name="l04472"></a><span class="lineno"> 4472</span><span class="preprocessor">#endif</span></div>
<div class="line"><a id="l04473" name="l04473"></a><span class="lineno"> 4473</span>        m_channel.send_blob(blob-&gt;const_buffer(), err_code);</div>
<div class="line"><a id="l04474" name="l04474"></a><span class="lineno"> 4474</span>        assert(ok); <span class="comment">// Only false if not PEER state; we promised undefined behavior in that case.</span></div>
<div class="line"><a id="l04475" name="l04475"></a><span class="lineno"> 4475</span> </div>
<div class="line"><a id="l04476" name="l04476"></a><span class="lineno"> 4476</span>        <span class="keywordflow">if</span> (*err_code)</div>
<div class="line"><a id="l04477" name="l04477"></a><span class="lineno"> 4477</span>        {</div>
<div class="line"><a id="l04478" name="l04478"></a><span class="lineno"> 4478</span>          <span class="keywordflow">return</span>;</div>
<div class="line"><a id="l04479" name="l04479"></a><span class="lineno"> 4479</span>        }</div>
<div class="line"><a id="l04480" name="l04480"></a><span class="lineno"> 4480</span>      }</div>
<div class="line"><a id="l04481" name="l04481"></a><span class="lineno"> 4481</span>    }</div>
<div class="line"><a id="l04482" name="l04482"></a><span class="lineno"> 4482</span>    <span class="comment">// else if constexpr(true) { No-op: We won&#39;t be called; see below. }</span></div>
<div class="line"><a id="l04483" name="l04483"></a><span class="lineno"> 4483</span>  }; <span class="comment">// const auto send_blobs =</span></div>
<div class="line"><a id="l04484" name="l04484"></a><span class="lineno"> 4484</span>  [[maybe_unused]] <span class="keyword">const</span> <span class="keyword">auto</span> send_meta_blobs = [&amp;]()</div>
<div class="line"><a id="l04485" name="l04485"></a><span class="lineno"> 4485</span>  {</div>
<div class="line"><a id="l04486" name="l04486"></a><span class="lineno"> 4486</span>    <span class="keywordflow">if</span> <span class="keyword">constexpr</span>(Owned_channel::S_HAS_NATIVE_HANDLE_PIPE)</div>
<div class="line"><a id="l04487" name="l04487"></a><span class="lineno"> 4487</span>    {</div>
<div class="line"><a id="l04488" name="l04488"></a><span class="lineno"> 4488</span>      <span class="keywordtype">bool</span> first = <span class="keyword">true</span>;</div>
<div class="line"><a id="l04489" name="l04489"></a><span class="lineno"> 4489</span>      <span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span>&amp; blob : blobs_out)</div>
<div class="line"><a id="l04490" name="l04490"></a><span class="lineno"> 4490</span>      {</div>
<div class="line"><a id="l04491" name="l04491"></a><span class="lineno"> 4491</span><span class="preprocessor">#ifndef NDEBUG</span></div>
<div class="line"><a id="l04492" name="l04492"></a><span class="lineno"> 4492</span>        <span class="keyword">const</span> <span class="keywordtype">bool</span> ok =</div>
<div class="line"><a id="l04493" name="l04493"></a><span class="lineno"> 4493</span><span class="preprocessor">#endif</span></div>
<div class="line"><a id="l04494" name="l04494"></a><span class="lineno"> 4494</span>        m_channel.send_native_handle(first ? (first = <span class="keyword">false</span>, hndl)</div>
<div class="line"><a id="l04495" name="l04495"></a><span class="lineno"> 4495</span>                                           : <a class="code hl_typedef" href="namespaceipc_1_1transport.html#a7ee4551983d9df16ec16a3139bac50e8">Native_handle</a>(),</div>
<div class="line"><a id="l04496" name="l04496"></a><span class="lineno"> 4496</span>                                     blob-&gt;const_buffer(), err_code);</div>
<div class="line"><a id="l04497" name="l04497"></a><span class="lineno"> 4497</span>        assert(ok); <span class="comment">// Same as above.</span></div>
<div class="line"><a id="l04498" name="l04498"></a><span class="lineno"> 4498</span> </div>
<div class="line"><a id="l04499" name="l04499"></a><span class="lineno"> 4499</span>        <span class="keywordflow">if</span> (*err_code)</div>
<div class="line"><a id="l04500" name="l04500"></a><span class="lineno"> 4500</span>        {</div>
<div class="line"><a id="l04501" name="l04501"></a><span class="lineno"> 4501</span>          <span class="keywordflow">return</span>;</div>
<div class="line"><a id="l04502" name="l04502"></a><span class="lineno"> 4502</span>        }</div>
<div class="line"><a id="l04503" name="l04503"></a><span class="lineno"> 4503</span>      }</div>
<div class="line"><a id="l04504" name="l04504"></a><span class="lineno"> 4504</span>    }</div>
<div class="line"><a id="l04505" name="l04505"></a><span class="lineno"> 4505</span>    <span class="comment">// else if constexpr(true) { No-op: We won&#39;t be called; see below. }</span></div>
<div class="line"><a id="l04506" name="l04506"></a><span class="lineno"> 4506</span>  }; <span class="comment">// const auto send_meta_blobs =</span></div>
<div class="line"><a id="l04507" name="l04507"></a><span class="lineno"> 4507</span> </div>
<div class="line"><a id="l04508" name="l04508"></a><span class="lineno"> 4508</span>  FLOW_LOG_TRACE(<span class="stringliteral">&quot;struc::Channel [&quot;</span> &lt;&lt; *<span class="keyword">this</span> &lt;&lt; <span class="stringliteral">&quot;]: Send request wants to send out-message, &quot;</span></div>
<div class="line"><a id="l04509" name="l04509"></a><span class="lineno"> 4509</span>                 <span class="stringliteral">&quot;and the serialization shall now be sent: total of [&quot;</span> &lt;&lt; blobs_out.size() &lt;&lt; <span class="stringliteral">&quot;] segments, 1 per blob; &quot;</span></div>
<div class="line"><a id="l04510" name="l04510"></a><span class="lineno"> 4510</span>                 <span class="stringliteral">&quot;1st blob contains metadata including ID and the further-segments count, plus native handle (unless &quot;</span></div>
<div class="line"><a id="l04511" name="l04511"></a><span class="lineno"> 4511</span>                 <span class="stringliteral">&quot;null) = [&quot;</span> &lt;&lt; (msg ? msg-&gt;<a class="code hl_function" href="classipc_1_1transport_1_1struc_1_1Msg__out.html#ae033461f1404be60262033bafcfaccba">native_handle_or_null</a>() : <a class="code hl_struct" href="structipc_1_1util_1_1Native__handle.html">Native_handle</a>()) &lt;&lt; <span class="stringliteral">&quot;].&quot;</span>);</div>
<div class="line"><a id="l04512" name="l04512"></a><span class="lineno"> 4512</span> </div>
<div class="line"><a id="l04513" name="l04513"></a><span class="lineno"> 4513</span>  <span class="keywordflow">if</span> <span class="keyword">constexpr</span>(Owned_channel::S_HAS_BLOB_PIPE_ONLY)</div>
<div class="line"><a id="l04514" name="l04514"></a><span class="lineno"> 4514</span>  {</div>
<div class="line"><a id="l04515" name="l04515"></a><span class="lineno"> 4515</span>    assert((!has_hndl) &amp;&amp; <span class="stringliteral">&quot;Attempting to send a native-handle over an Owned_channel without a native handles pipe.&quot;</span>);</div>
<div class="line"><a id="l04516" name="l04516"></a><span class="lineno"> 4516</span>    send_blobs();</div>
<div class="line"><a id="l04517" name="l04517"></a><span class="lineno"> 4517</span>  }</div>
<div class="line"><a id="l04518" name="l04518"></a><span class="lineno"> 4518</span>  <span class="keywordflow">else</span> <span class="keywordflow">if</span> <span class="keyword">constexpr</span>(Owned_channel::S_HAS_NATIVE_HANDLE_PIPE_ONLY)</div>
<div class="line"><a id="l04519" name="l04519"></a><span class="lineno"> 4519</span>  {</div>
<div class="line"><a id="l04520" name="l04520"></a><span class="lineno"> 4520</span>    send_meta_blobs();</div>
<div class="line"><a id="l04521" name="l04521"></a><span class="lineno"> 4521</span>  }</div>
<div class="line"><a id="l04522" name="l04522"></a><span class="lineno"> 4522</span>  <span class="keywordflow">else</span></div>
<div class="line"><a id="l04523" name="l04523"></a><span class="lineno"> 4523</span>  {</div>
<div class="line"><a id="l04524" name="l04524"></a><span class="lineno"> 4524</span>    <span class="keyword">static_assert</span>(Owned_channel::S_HAS_2_PIPES, <span class="stringliteral">&quot;This code assumes 1 blobs pipe, 1 handles pipe, or both exactly.&quot;</span>);</div>
<div class="line"><a id="l04525" name="l04525"></a><span class="lineno"> 4525</span>    has_hndl ? send_meta_blobs() : send_blobs();</div>
<div class="line"><a id="l04526" name="l04526"></a><span class="lineno"> 4526</span>  }</div>
<div class="line"><a id="l04527" name="l04527"></a><span class="lineno"> 4527</span> </div>
<div class="line"><a id="l04528" name="l04528"></a><span class="lineno"> 4528</span>  <span class="comment">// `msg` may now be safely destroyed.</span></div>
<div class="line"><a id="l04529" name="l04529"></a><span class="lineno"> 4529</span> </div>
<div class="line"><a id="l04530" name="l04530"></a><span class="lineno"> 4530</span>  <span class="keywordflow">if</span> (*err_code)</div>
<div class="line"><a id="l04531" name="l04531"></a><span class="lineno"> 4531</span>  {</div>
<div class="line"><a id="l04532" name="l04532"></a><span class="lineno"> 4532</span>    <span class="comment">// A send_*() failed.  There is one special case however which we promised to emit in a special way.</span></div>
<div class="line"><a id="l04533" name="l04533"></a><span class="lineno"> 4533</span>    <span class="keywordflow">if</span> (*err_code == <a class="code hl_enumvalue" href="namespaceipc_1_1transport_1_1error.html#adfef15ef4e76cc55d652fbd9c2797297a42d41c622e92e9053177ba73e75633fe">transport::error::Code::S_SENDS_FINISHED_CANNOT_SEND</a>)</div>
<div class="line"><a id="l04534" name="l04534"></a><span class="lineno"> 4534</span>    {</div>
<div class="line"><a id="l04535" name="l04535"></a><span class="lineno"> 4535</span>      FLOW_LOG_WARNING(<span class="stringliteral">&quot;struc::Channel [&quot;</span> &lt;&lt; *<span class="keyword">this</span> &lt;&lt; <span class="stringliteral">&quot;]: Send request wants to send out-message, &quot;</span></div>
<div class="line"><a id="l04536" name="l04536"></a><span class="lineno"> 4536</span>                       <span class="stringliteral">&quot;and we tried to send the serialization: total of [&quot;</span> &lt;&lt; blobs_out.size() &lt;&lt; <span class="stringliteral">&quot;] segs, 1/blob; &quot;</span></div>
<div class="line"><a id="l04537" name="l04537"></a><span class="lineno"> 4537</span>                       <span class="stringliteral">&quot;1st blob contains 1st segment including further segment count (0 if internal msg), &quot;</span></div>
<div class="line"><a id="l04538" name="l04538"></a><span class="lineno"> 4538</span>                       <span class="stringliteral">&quot;plus native handle (unless null) = [&quot;</span> &lt;&lt; hndl &lt;&lt; <span class="stringliteral">&quot;].  However Channel reports &quot;</span></div>
<div class="line"><a id="l04539" name="l04539"></a><span class="lineno"> 4539</span>                       <span class="stringliteral">&quot;we had already sent graceful-close.  Therefore ignoring send attempt after all.&quot;</span>);</div>
<div class="line"><a id="l04540" name="l04540"></a><span class="lineno"> 4540</span>      <span class="comment">/* Subtlety regarding bool(err_code_or_ignore):</span></div>
<div class="line"><a id="l04541" name="l04541"></a><span class="lineno"> 4541</span><span class="comment">       *   - Regardless of that, we are not to record this &quot;error&quot; into m_channel_err_code_or_ok by our contract.</span></div>
<div class="line"><a id="l04542" name="l04542"></a><span class="lineno"> 4542</span><span class="comment">       *   - What remains, then, is whether to return true or false.</span></div>
<div class="line"><a id="l04543" name="l04543"></a><span class="lineno"> 4543</span><span class="comment">       *     - If bool(err_code_or_ignore) is true (not ignoring errors) then return false by contract.</span></div>
<div class="line"><a id="l04544" name="l04544"></a><span class="lineno"> 4544</span><span class="comment">       *     - Otherwise, 1, still return false as promised; but 2, the caller won&#39;t care anyway.</span></div>
<div class="line"><a id="l04545" name="l04545"></a><span class="lineno"> 4545</span><span class="comment">       * So return false. */</span></div>
<div class="line"><a id="l04546" name="l04546"></a><span class="lineno"> 4546</span>      <span class="keywordflow">return</span> <span class="keyword">false</span>;</div>
<div class="line"><a id="l04547" name="l04547"></a><span class="lineno"> 4547</span>    }</div>
<div class="line"><a id="l04548" name="l04548"></a><span class="lineno"> 4548</span>    <span class="comment">// else</span></div>
<div class="line"><a id="l04549" name="l04549"></a><span class="lineno"> 4549</span>    FLOW_LOG_WARNING(<span class="stringliteral">&quot;struc::Channel [&quot;</span> &lt;&lt; *<span class="keyword">this</span> &lt;&lt; <span class="stringliteral">&quot;]: Send request wants to send out-message, &quot;</span></div>
<div class="line"><a id="l04550" name="l04550"></a><span class="lineno"> 4550</span>                     <span class="stringliteral">&quot;and we tried to send the serialization: total of [&quot;</span> &lt;&lt; blobs_out.size() &lt;&lt; <span class="stringliteral">&quot;] segs, 1/blob; &quot;</span></div>
<div class="line"><a id="l04551" name="l04551"></a><span class="lineno"> 4551</span>                     <span class="stringliteral">&quot;1st blob contains 1st segment including futher segment count (0 if internal msg), &quot;</span></div>
<div class="line"><a id="l04552" name="l04552"></a><span class="lineno"> 4552</span>                     <span class="stringliteral">&quot;plus native handle (unless null) = [&quot;</span> &lt;&lt; hndl &lt;&lt; <span class="stringliteral">&quot;].  However Channel reports &quot;</span></div>
<div class="line"><a id="l04553" name="l04553"></a><span class="lineno"> 4553</span>                     <span class="stringliteral">&quot;a send failed (error [&quot;</span> &lt;&lt; *err_code &lt;&lt; <span class="stringliteral">&quot;] [&quot;</span> &lt;&lt; err_code-&gt;message() &lt;&lt; <span class="stringliteral">&quot;]).  &quot;</span></div>
<div class="line"><a id="l04554" name="l04554"></a><span class="lineno"> 4554</span>                     <span class="stringliteral">&quot;This is a channel-hosing error; emitting it &quot;</span></div>
<div class="line"><a id="l04555" name="l04555"></a><span class="lineno"> 4555</span>                     <span class="stringliteral">&quot;unless internally-ignoring (are we? = [&quot;</span> &lt;&lt; (!err_code_or_ignore) &lt;&lt; <span class="stringliteral">&quot;]).&quot;</span>);</div>
<div class="line"><a id="l04556" name="l04556"></a><span class="lineno"> 4556</span>    err_code_or_ignore &amp;&amp; (m_channel_err_code_or_ok = *err_code);</div>
<div class="line"><a id="l04557" name="l04557"></a><span class="lineno"> 4557</span>    <span class="keywordflow">return</span> <span class="keyword">true</span>;</div>
<div class="line"><a id="l04558" name="l04558"></a><span class="lineno"> 4558</span>  }</div>
<div class="line"><a id="l04559" name="l04559"></a><span class="lineno"> 4559</span>  <span class="comment">// else cool!  But one last thing possibly:</span></div>
<div class="line"><a id="l04560" name="l04560"></a><span class="lineno"> 4560</span> </div>
<div class="line"><a id="l04561" name="l04561"></a><span class="lineno"> 4561</span>  <span class="keywordflow">if</span> (m_phase == Phase::S_SRV_LOG_IN)</div>
<div class="line"><a id="l04562" name="l04562"></a><span class="lineno"> 4562</span>  {</div>
<div class="line"><a id="l04563" name="l04563"></a><span class="lineno"> 4563</span>    FLOW_LOG_INFO(<span class="stringliteral">&quot;struc::Channel [&quot;</span> &lt;&lt; *<span class="keyword">this</span> &lt;&lt; <span class="stringliteral">&quot;]: Log-in (as server): Successfully sent what must be the &quot;</span></div>
<div class="line"><a id="l04564" name="l04564"></a><span class="lineno"> 4564</span>                  <span class="stringliteral">&quot;log-in response message.  Changing phase to logged-in.&quot;</span>);</div>
<div class="line"><a id="l04565" name="l04565"></a><span class="lineno"> 4565</span>    m_phase = Phase::S_LOGGED_IN;</div>
<div class="line"><a id="l04566" name="l04566"></a><span class="lineno"> 4566</span>  }</div>
<div class="line"><a id="l04567" name="l04567"></a><span class="lineno"> 4567</span> </div>
<div class="line"><a id="l04568" name="l04568"></a><span class="lineno"> 4568</span>  assert(!*err_code);</div>
<div class="line"><a id="l04569" name="l04569"></a><span class="lineno"> 4569</span>  <span class="keywordflow">return</span> <span class="keyword">true</span>;</div>
<div class="line"><a id="l04570" name="l04570"></a><span class="lineno"> 4570</span>} <span class="comment">// Channel::send_core()</span></div>
<div class="line"><a id="l04571" name="l04571"></a><span class="lineno"> 4571</span> </div>
<div class="line"><a id="l04572" name="l04572"></a><span class="lineno"> 4572</span><a class="code hl_define" href="ipc__transport__structured_2src_2ipc_2transport_2struc_2sync__io_2channel_8hpp.html#a50e1bb663274c68c760263342ddfdcbc">TEMPLATE_SIO_STRUCT_CHANNEL</a></div>
<div class="line"><a id="l04573" name="l04573"></a><span class="lineno"><a class="line" href="classipc_1_1transport_1_1struc_1_1sync__io_1_1Channel.html#a8fc989561ed62604dd50f942655daea0"> 4573</a></span><span class="keywordtype">void</span> CLASS_SIO_STRUCT_CHANNEL::send_proto_neg()</div>
<div class="line"><a id="l04574" name="l04574"></a><span class="lineno"> 4574</span>{</div>
<div class="line"><a id="l04575" name="l04575"></a><span class="lineno"> 4575</span>  <span class="keyword">constexpr</span> <span class="keywordtype">size_t</span> PROTO_NEGOTIATION_SEG_SZ = 256; <span class="comment">// Enough to serialize a ProtocolNegotiation capnp-struct in 1 seg.</span></div>
<div class="line"><a id="l04576" name="l04576"></a><span class="lineno"> 4576</span> </div>
<div class="line"><a id="l04577" name="l04577"></a><span class="lineno"> 4577</span>  <span class="comment">/* See &quot;Protocol negotiation&quot; in class doc header for background.</span></div>
<div class="line"><a id="l04578" name="l04578"></a><span class="lineno"> 4578</span><span class="comment">   * Our job here is straighforward enough (like a much-simpler send_core(), albeit along both pipes if relevant, with</span></div>
<div class="line"><a id="l04579" name="l04579"></a><span class="lineno"> 4579</span><span class="comment">   * a really simple payload contained in 1 blob-message), and the code below is easy enough to follow.</span></div>
<div class="line"><a id="l04580" name="l04580"></a><span class="lineno"> 4580</span><span class="comment">   *</span></div>
<div class="line"><a id="l04581" name="l04581"></a><span class="lineno"> 4581</span><span class="comment">   * The only subtlety has to do with error handling.  Recall we are called at the end of successful start_ops(), hence</span></div>
<div class="line"><a id="l04582" name="l04582"></a><span class="lineno"> 4582</span><span class="comment">   * before any user send()/async_request() and before start_and_poll() (which is when we begin the read chain, and</span></div>
<div class="line"><a id="l04583" name="l04583"></a><span class="lineno"> 4583</span><span class="comment">   * error handler is registered and can be subsequently invoked).  What we do below is synchronous.</span></div>
<div class="line"><a id="l04584" name="l04584"></a><span class="lineno"> 4584</span><span class="comment">   * Vast majority of the time all will work below, so nothing to worry about; now suppose an m_channel.send_*()</span></div>
<div class="line"><a id="l04585" name="l04585"></a><span class="lineno"> 4585</span><span class="comment">   * below fails (into err_code).  Now what?</span></div>
<div class="line"><a id="l04586" name="l04586"></a><span class="lineno"> 4586</span><span class="comment">   *</span></div>
<div class="line"><a id="l04587" name="l04587"></a><span class="lineno"> 4587</span><span class="comment">   * Short-circuiting discussion of various other possibilities, basically, we treat this as the whole channel being</span></div>
<div class="line"><a id="l04588" name="l04588"></a><span class="lineno"> 4588</span><span class="comment">   * hosed; so we save error into m_proto_neg_err_code_or_ok (ref = err_code).  Only question is when to emit it.</span></div>
<div class="line"><a id="l04589" name="l04589"></a><span class="lineno"> 4589</span><span class="comment">   * We execute before start_and_poll() (through which incoming-direction work becomes possible) and before</span></div>
<div class="line"><a id="l04590" name="l04590"></a><span class="lineno"> 4590</span><span class="comment">   * and send()/async_request() (through which outgoing-direction work happens).  (The two interact fine in either</span></div>
<div class="line"><a id="l04591" name="l04591"></a><span class="lineno"> 4591</span><span class="comment">   * order; a given new error is emitted to the first such API call.)  So what we do is check m_proto_neg_err_code_or_ok</span></div>
<div class="line"><a id="l04592" name="l04592"></a><span class="lineno"> 4592</span><span class="comment">   * here and check it in start_and_poll(); if truthy then immediately promote it to m_channel_err_code_or_ok</span></div>
<div class="line"><a id="l04593" name="l04593"></a><span class="lineno"> 4593</span><span class="comment">   * and emit via handle_new_error() as usual.  What if send()/async_request() happens first though?  Similarly there.</span></div>
<div class="line"><a id="l04594" name="l04594"></a><span class="lineno"> 4594</span><span class="comment">   */</span></div>
<div class="line"><a id="l04595" name="l04595"></a><span class="lineno"> 4595</span> </div>
<div class="line"><a id="l04596" name="l04596"></a><span class="lineno"> 4596</span>  <span class="keyword">auto</span>&amp; err_code = m_proto_neg_err_code_or_ok;</div>
<div class="line"><a id="l04597" name="l04597"></a><span class="lineno"> 4597</span>  assert(!err_code);</div>
<div class="line"><a id="l04598" name="l04598"></a><span class="lineno"> 4598</span> </div>
<div class="line"><a id="l04599" name="l04599"></a><span class="lineno"> 4599</span>  <span class="keyword">const</span> <span class="keyword">auto</span> protocol_ver_to_send = m_protocol_negotiator.local_max_proto_ver_for_sending();</div>
<div class="line"><a id="l04600" name="l04600"></a><span class="lineno"> 4600</span>  <span class="keyword">const</span> <span class="keyword">auto</span> protocol_ver_to_send_aux = m_protocol_negotiator_aux.local_max_proto_ver_for_sending();</div>
<div class="line"><a id="l04601" name="l04601"></a><span class="lineno"> 4601</span>  assert((protocol_ver_to_send != <a class="code hl_variable" href="classipc_1_1transport_1_1Protocol__negotiator.html#aa7e47f4f6a700aeaa9600a5426a17292">Protocol_negotiator::S_VER_UNKNOWN</a>)</div>
<div class="line"><a id="l04602" name="l04602"></a><span class="lineno"> 4602</span>         &amp;&amp; (protocol_ver_to_send_aux != <a class="code hl_variable" href="classipc_1_1transport_1_1Protocol__negotiator.html#aa7e47f4f6a700aeaa9600a5426a17292">Protocol_negotiator::S_VER_UNKNOWN</a>)</div>
<div class="line"><a id="l04603" name="l04603"></a><span class="lineno"> 4603</span>         &amp;&amp; <span class="stringliteral">&quot;How&#39;d we get to this line twice?  Or Protocol_negotiator bug?&quot;</span>);</div>
<div class="line"><a id="l04604" name="l04604"></a><span class="lineno"> 4604</span>  assert((m_protocol_negotiator.local_max_proto_ver_for_sending() == <a class="code hl_variable" href="classipc_1_1transport_1_1Protocol__negotiator.html#aa7e47f4f6a700aeaa9600a5426a17292">Protocol_negotiator::S_VER_UNKNOWN</a>)</div>
<div class="line"><a id="l04605" name="l04605"></a><span class="lineno"> 4605</span>         &amp;&amp; (m_protocol_negotiator_aux.local_max_proto_ver_for_sending() == <a class="code hl_variable" href="classipc_1_1transport_1_1Protocol__negotiator.html#aa7e47f4f6a700aeaa9600a5426a17292">Protocol_negotiator::S_VER_UNKNOWN</a>)</div>
<div class="line"><a id="l04606" name="l04606"></a><span class="lineno"> 4606</span>         &amp;&amp; <span class="stringliteral">&quot;Protocol_negotiator not properly marking the once-only sending-out of protocol version?&quot;</span>);</div>
<div class="line"><a id="l04607" name="l04607"></a><span class="lineno"> 4607</span> </div>
<div class="line"><a id="l04608" name="l04608"></a><span class="lineno"> 4608</span>  <a class="code hl_typedef" href="namespaceipc_1_1transport_1_1struc.html#a82a69eaa39cbe8a002de1266f1cbb5cb">Segment_ptrs</a> blobs_out;</div>
<div class="line"><a id="l04609" name="l04609"></a><span class="lineno"> 4609</span>  blobs_out.reserve(1); <span class="comment">// Little optimization.</span></div>
<div class="line"><a id="l04610" name="l04610"></a><span class="lineno"> 4610</span> </div>
<div class="line"><a id="l04611" name="l04611"></a><span class="lineno"> 4611</span>  <a class="code hl_class" href="classipc_1_1transport_1_1struc_1_1Heap__fixed__builder.html">Heap_fixed_builder</a> proto_neg_builder(<a class="code hl_struct" href="structipc_1_1transport_1_1struc_1_1Heap__fixed__builder_1_1Config.html">Heap_fixed_builder::Config</a>{ get_logger(), PROTO_NEGOTIATION_SEG_SZ, 0, 0 });</div>
<div class="line"><a id="l04612" name="l04612"></a><span class="lineno"> 4612</span> </div>
<div class="line"><a id="l04613" name="l04613"></a><span class="lineno"> 4613</span>  <span class="keyword">auto</span> root = proto_neg_builder.<a class="code hl_function" href="classipc_1_1transport_1_1struc_1_1Heap__fixed__builder.html#a0c054e351753ce326620aa1dec12d923">payload_msg_builder</a>()-&gt;initRoot&lt;schema::detail::ProtocolNegotiation&gt;();</div>
<div class="line"><a id="l04614" name="l04614"></a><span class="lineno"> 4614</span>  root.setMaxProtoVer(protocol_ver_to_send);</div>
<div class="line"><a id="l04615" name="l04615"></a><span class="lineno"> 4615</span>  root.setMaxProtoVerAux(protocol_ver_to_send_aux);</div>
<div class="line"><a id="l04616" name="l04616"></a><span class="lineno"> 4616</span> </div>
<div class="line"><a id="l04617" name="l04617"></a><span class="lineno"> 4617</span>  FLOW_LOG_TRACE(<span class="stringliteral">&quot;struc::Channel [&quot;</span> &lt;&lt; *<span class="keyword">this</span> &lt;&lt; <span class="stringliteral">&quot;]: Here is the prepended protocol-negotiation header we shall send:&quot;</span></div>
<div class="line"><a id="l04618" name="l04618"></a><span class="lineno"> 4618</span>                 <span class="stringliteral">&quot;\n&quot;</span> &lt;&lt; ::capnp::prettyPrint(root.asReader()).flatten().cStr());</div>
<div class="line"><a id="l04619" name="l04619"></a><span class="lineno"> 4619</span> </div>
<div class="line"><a id="l04620" name="l04620"></a><span class="lineno"> 4620</span>  proto_neg_builder.emit_serialization(&amp;blobs_out, <a class="code hl_variable" href="namespaceipc_1_1transport_1_1struc.html#ac70446757444f864afa21a5062bc5b0d">NULL_SESSION</a>, &amp;err_code);</div>
<div class="line"><a id="l04621" name="l04621"></a><span class="lineno"> 4621</span>  assert((!err_code) &amp;&amp; <span class="stringliteral">&quot;Very simple structure; no way should it overflow segment.&quot;</span>);</div>
<div class="line"><a id="l04622" name="l04622"></a><span class="lineno"> 4622</span>  assert((blobs_out.size() == 1) &amp;&amp; <span class="stringliteral">&quot;Very simple structure; no way it should need more than 1 segment.&quot;</span>);</div>
<div class="line"><a id="l04623" name="l04623"></a><span class="lineno"> 4623</span> </div>
<div class="line"><a id="l04624" name="l04624"></a><span class="lineno"> 4624</span>  <span class="keyword">const</span> <span class="keyword">auto</span>&amp; blob = blobs_out.front();</div>
<div class="line"><a id="l04625" name="l04625"></a><span class="lineno"> 4625</span> </div>
<div class="line"><a id="l04626" name="l04626"></a><span class="lineno"> 4626</span>  <span class="comment">// That&#39;s it.  Now it&#39;s just a blob to send out.</span></div>
<div class="line"><a id="l04627" name="l04627"></a><span class="lineno"> 4627</span> </div>
<div class="line"><a id="l04628" name="l04628"></a><span class="lineno"> 4628</span>  <span class="comment">// Synchronous helpers.</span></div>
<div class="line"><a id="l04629" name="l04629"></a><span class="lineno"> 4629</span>  [[maybe_unused]] <span class="keyword">const</span> <span class="keyword">auto</span> send_blob = [&amp;]()</div>
<div class="line"><a id="l04630" name="l04630"></a><span class="lineno"> 4630</span>  {</div>
<div class="line"><a id="l04631" name="l04631"></a><span class="lineno"> 4631</span>    <span class="keywordflow">if</span> <span class="keyword">constexpr</span>(Owned_channel::S_HAS_BLOB_PIPE)</div>
<div class="line"><a id="l04632" name="l04632"></a><span class="lineno"> 4632</span>    {</div>
<div class="line"><a id="l04633" name="l04633"></a><span class="lineno"> 4633</span><span class="preprocessor">#ifndef NDEBUG</span></div>
<div class="line"><a id="l04634" name="l04634"></a><span class="lineno"> 4634</span>      <span class="keyword">const</span> <span class="keywordtype">bool</span> ok =</div>
<div class="line"><a id="l04635" name="l04635"></a><span class="lineno"> 4635</span><span class="preprocessor">#endif</span></div>
<div class="line"><a id="l04636" name="l04636"></a><span class="lineno"> 4636</span>      m_channel.send_blob(blob-&gt;const_buffer(), &amp;err_code);</div>
<div class="line"><a id="l04637" name="l04637"></a><span class="lineno"> 4637</span>      assert(ok); <span class="comment">// Only false if not PEER state; we promised undefined behavior in that case.</span></div>
<div class="line"><a id="l04638" name="l04638"></a><span class="lineno"> 4638</span>    }</div>
<div class="line"><a id="l04639" name="l04639"></a><span class="lineno"> 4639</span>    <span class="comment">// else if constexpr(true) { No-op: We won&#39;t be called; see below. }</span></div>
<div class="line"><a id="l04640" name="l04640"></a><span class="lineno"> 4640</span>  }; <span class="comment">// const auto send_blob =</span></div>
<div class="line"><a id="l04641" name="l04641"></a><span class="lineno"> 4641</span>  [[maybe_unused]] <span class="keyword">const</span> <span class="keyword">auto</span> send_meta_blob = [&amp;]()</div>
<div class="line"><a id="l04642" name="l04642"></a><span class="lineno"> 4642</span>  {</div>
<div class="line"><a id="l04643" name="l04643"></a><span class="lineno"> 4643</span>    <span class="keywordflow">if</span> <span class="keyword">constexpr</span>(Owned_channel::S_HAS_NATIVE_HANDLE_PIPE)</div>
<div class="line"><a id="l04644" name="l04644"></a><span class="lineno"> 4644</span>    {</div>
<div class="line"><a id="l04645" name="l04645"></a><span class="lineno"> 4645</span><span class="preprocessor">#ifndef NDEBUG</span></div>
<div class="line"><a id="l04646" name="l04646"></a><span class="lineno"> 4646</span>      <span class="keyword">const</span> <span class="keywordtype">bool</span> ok =</div>
<div class="line"><a id="l04647" name="l04647"></a><span class="lineno"> 4647</span><span class="preprocessor">#endif</span></div>
<div class="line"><a id="l04648" name="l04648"></a><span class="lineno"> 4648</span>      m_channel.send_native_handle(<a class="code hl_typedef" href="namespaceipc_1_1transport.html#a7ee4551983d9df16ec16a3139bac50e8">Native_handle</a>(), blob-&gt;const_buffer(), &amp;err_code);</div>
<div class="line"><a id="l04649" name="l04649"></a><span class="lineno"> 4649</span>      assert(ok); <span class="comment">// Same as above.</span></div>
<div class="line"><a id="l04650" name="l04650"></a><span class="lineno"> 4650</span>    }</div>
<div class="line"><a id="l04651" name="l04651"></a><span class="lineno"> 4651</span>    <span class="comment">// else if constexpr(true) { No-op: We won&#39;t be called; see below. }</span></div>
<div class="line"><a id="l04652" name="l04652"></a><span class="lineno"> 4652</span>  }; <span class="comment">// const auto send_meta_blob =</span></div>
<div class="line"><a id="l04653" name="l04653"></a><span class="lineno"> 4653</span> </div>
<div class="line"><a id="l04654" name="l04654"></a><span class="lineno"> 4654</span>  <span class="keywordflow">if</span> <span class="keyword">constexpr</span>(Owned_channel::S_HAS_BLOB_PIPE_ONLY)</div>
<div class="line"><a id="l04655" name="l04655"></a><span class="lineno"> 4655</span>  {</div>
<div class="line"><a id="l04656" name="l04656"></a><span class="lineno"> 4656</span>    send_blob();</div>
<div class="line"><a id="l04657" name="l04657"></a><span class="lineno"> 4657</span>  }</div>
<div class="line"><a id="l04658" name="l04658"></a><span class="lineno"> 4658</span>  <span class="keywordflow">else</span> <span class="keywordflow">if</span> <span class="keyword">constexpr</span>(Owned_channel::S_HAS_NATIVE_HANDLE_PIPE_ONLY)</div>
<div class="line"><a id="l04659" name="l04659"></a><span class="lineno"> 4659</span>  {</div>
<div class="line"><a id="l04660" name="l04660"></a><span class="lineno"> 4660</span>    send_meta_blob();</div>
<div class="line"><a id="l04661" name="l04661"></a><span class="lineno"> 4661</span>  }</div>
<div class="line"><a id="l04662" name="l04662"></a><span class="lineno"> 4662</span>  <span class="keywordflow">else</span></div>
<div class="line"><a id="l04663" name="l04663"></a><span class="lineno"> 4663</span>  {</div>
<div class="line"><a id="l04664" name="l04664"></a><span class="lineno"> 4664</span>    <span class="keyword">static_assert</span>(Owned_channel::S_HAS_2_PIPES, <span class="stringliteral">&quot;This code assumes 1 blobs pipe, 1 handles pipe, or both exactly.&quot;</span>);</div>
<div class="line"><a id="l04665" name="l04665"></a><span class="lineno"> 4665</span>    send_meta_blob();</div>
<div class="line"><a id="l04666" name="l04666"></a><span class="lineno"> 4666</span>    <span class="keywordflow">if</span> (!err_code)</div>
<div class="line"><a id="l04667" name="l04667"></a><span class="lineno"> 4667</span>    {</div>
<div class="line"><a id="l04668" name="l04668"></a><span class="lineno"> 4668</span>      send_blob();</div>
<div class="line"><a id="l04669" name="l04669"></a><span class="lineno"> 4669</span>    }</div>
<div class="line"><a id="l04670" name="l04670"></a><span class="lineno"> 4670</span>  }</div>
<div class="line"><a id="l04671" name="l04671"></a><span class="lineno"> 4671</span>} <span class="comment">// Channel::send_proto_neg()</span></div>
<div class="line"><a id="l04672" name="l04672"></a><span class="lineno"> 4672</span> </div>
<div class="line"><a id="l04673" name="l04673"></a><span class="lineno"> 4673</span><a class="code hl_define" href="ipc__transport__structured_2src_2ipc_2transport_2struc_2sync__io_2channel_8hpp.html#a50e1bb663274c68c760263342ddfdcbc">TEMPLATE_SIO_STRUCT_CHANNEL</a></div>
<div class="line"><a id="l04674" name="l04674"></a><span class="lineno"> 4674</span><span class="keyword">template</span>&lt;<span class="keyword">typename</span> Task_err&gt;</div>
<div class="line"><a id="l04675" name="l04675"></a><span class="lineno"><a class="line" href="classipc_1_1transport_1_1struc_1_1sync__io_1_1Channel.html#ae4a2a63dc88722d96ee9f3ed68cf7b86"> 4675</a></span><span class="keywordtype">bool</span> CLASS_SIO_STRUCT_CHANNEL::async_end_sending(<a class="code hl_typedef" href="namespaceipc.html#aa3192e586cc45d3e7c22463bf2760f89">Error_code</a>* sync_err_code, Task_err&amp;&amp; on_done_func)</div>
<div class="line"><a id="l04676" name="l04676"></a><span class="lineno"> 4676</span>{</div>
<div class="line"><a id="l04677" name="l04677"></a><span class="lineno"> 4677</span>  <span class="keywordflow">if</span> (check_not_started_ops(<span class="stringliteral">&quot;async_end_sending()&quot;</span>))</div>
<div class="line"><a id="l04678" name="l04678"></a><span class="lineno"> 4678</span>  {</div>
<div class="line"><a id="l04679" name="l04679"></a><span class="lineno"> 4679</span>    <span class="keywordflow">return</span> <span class="keyword">false</span>;</div>
<div class="line"><a id="l04680" name="l04680"></a><span class="lineno"> 4680</span>  }</div>
<div class="line"><a id="l04681" name="l04681"></a><span class="lineno"> 4681</span>  <span class="comment">// else</span></div>
<div class="line"><a id="l04682" name="l04682"></a><span class="lineno"> 4682</span> </div>
<div class="line"><a id="l04683" name="l04683"></a><span class="lineno"> 4683</span>  <span class="keywordflow">return</span> m_channel.async_end_sending(sync_err_code, on_done_func);</div>
<div class="line"><a id="l04684" name="l04684"></a><span class="lineno"> 4684</span>}</div>
<div class="line"><a id="l04685" name="l04685"></a><span class="lineno"> 4685</span> </div>
<div class="line"><a id="l04686" name="l04686"></a><span class="lineno"> 4686</span><a class="code hl_define" href="ipc__transport__structured_2src_2ipc_2transport_2struc_2sync__io_2channel_8hpp.html#a50e1bb663274c68c760263342ddfdcbc">TEMPLATE_SIO_STRUCT_CHANNEL</a></div>
<div class="line"><a id="l04687" name="l04687"></a><span class="lineno"><a class="line" href="classipc_1_1transport_1_1struc_1_1sync__io_1_1Channel.html#abeb37ac07422166123553920393d5ab4"> 4687</a></span><span class="keywordtype">bool</span> CLASS_SIO_STRUCT_CHANNEL::check_prior_error(<a class="code hl_typedef" href="namespaceipc_1_1util.html#ae6ac47812a90d1287c61e0b7de7bc4f5">util::String_view</a> context)<span class="keyword"> const</span></div>
<div class="line"><a id="l04688" name="l04688"></a><span class="lineno"> 4688</span><span class="keyword"></span>{</div>
<div class="line"><a id="l04689" name="l04689"></a><span class="lineno"> 4689</span>  <span class="keywordflow">if</span> (m_channel_err_code_or_ok)</div>
<div class="line"><a id="l04690" name="l04690"></a><span class="lineno"> 4690</span>  {</div>
<div class="line"><a id="l04691" name="l04691"></a><span class="lineno"> 4691</span>    FLOW_LOG_WARNING(<span class="stringliteral">&quot;struc::Channel [&quot;</span> &lt;&lt; *<span class="keyword">this</span> &lt;&lt; <span class="stringliteral">&quot;]: In context [&quot;</span> &lt;&lt; context &lt;&lt; <span class="stringliteral">&quot;]: A prior error &quot;</span></div>
<div class="line"><a id="l04692" name="l04692"></a><span class="lineno"> 4692</span>                     <span class="stringliteral">&quot;[&quot;</span> &lt;&lt; m_channel_err_code_or_ok &lt;&lt; <span class="stringliteral">&quot;] [&quot;</span> &lt;&lt; m_channel_err_code_or_ok.message() &lt;&lt; <span class="stringliteral">&quot;] shall &quot;</span></div>
<div class="line"><a id="l04693" name="l04693"></a><span class="lineno"> 4693</span>                     <span class="stringliteral">&quot;prevent further action in this context: bailing out of this operation.&quot;</span>);</div>
<div class="line"><a id="l04694" name="l04694"></a><span class="lineno"> 4694</span>    <span class="keywordflow">return</span> <span class="keyword">true</span>;</div>
<div class="line"><a id="l04695" name="l04695"></a><span class="lineno"> 4695</span>  }</div>
<div class="line"><a id="l04696" name="l04696"></a><span class="lineno"> 4696</span>  <span class="comment">// else</span></div>
<div class="line"><a id="l04697" name="l04697"></a><span class="lineno"> 4697</span>  <span class="keywordflow">return</span> <span class="keyword">false</span>;</div>
<div class="line"><a id="l04698" name="l04698"></a><span class="lineno"> 4698</span>}</div>
<div class="line"><a id="l04699" name="l04699"></a><span class="lineno"> 4699</span> </div>
<div class="line"><a id="l04700" name="l04700"></a><span class="lineno"> 4700</span><a class="code hl_define" href="ipc__transport__structured_2src_2ipc_2transport_2struc_2sync__io_2channel_8hpp.html#a50e1bb663274c68c760263342ddfdcbc">TEMPLATE_SIO_STRUCT_CHANNEL</a></div>
<div class="line"><a id="l04701" name="l04701"></a><span class="lineno"><a class="line" href="classipc_1_1transport_1_1struc_1_1sync__io_1_1Channel.html#ae6b2691d6471330d8b7cc7e8e9320054"> 4701</a></span><span class="keywordtype">bool</span> CLASS_SIO_STRUCT_CHANNEL::check_phase_and_prior_error(<a class="code hl_enumeration" href="classipc_1_1transport_1_1struc_1_1sync__io_1_1Channel.html#a5a3833cd141802041551db21198ac319">Phase</a> required_phase, <a class="code hl_typedef" href="namespaceipc_1_1util.html#ae6ac47812a90d1287c61e0b7de7bc4f5">util::String_view</a> context)<span class="keyword"> const</span></div>
<div class="line"><a id="l04702" name="l04702"></a><span class="lineno"> 4702</span><span class="keyword"></span>{</div>
<div class="line"><a id="l04703" name="l04703"></a><span class="lineno"> 4703</span>  <span class="keywordflow">if</span> (check_prior_error(context))</div>
<div class="line"><a id="l04704" name="l04704"></a><span class="lineno"> 4704</span>  {</div>
<div class="line"><a id="l04705" name="l04705"></a><span class="lineno"> 4705</span>    <span class="keywordflow">return</span> <span class="keyword">true</span>;</div>
<div class="line"><a id="l04706" name="l04706"></a><span class="lineno"> 4706</span>  }</div>
<div class="line"><a id="l04707" name="l04707"></a><span class="lineno"> 4707</span>  <span class="comment">// else</span></div>
<div class="line"><a id="l04708" name="l04708"></a><span class="lineno"> 4708</span> </div>
<div class="line"><a id="l04709" name="l04709"></a><span class="lineno"> 4709</span>  <span class="keywordflow">if</span> (m_phase != required_phase)</div>
<div class="line"><a id="l04710" name="l04710"></a><span class="lineno"> 4710</span>  {</div>
<div class="line"><a id="l04711" name="l04711"></a><span class="lineno"> 4711</span>    FLOW_LOG_WARNING(<span class="stringliteral">&quot;struc::Channel [&quot;</span> &lt;&lt; *<span class="keyword">this</span> &lt;&lt; <span class="stringliteral">&quot;]: In context [&quot;</span> &lt;&lt; context &lt;&lt; <span class="stringliteral">&quot;]: The required log-in &quot;</span></div>
<div class="line"><a id="l04712" name="l04712"></a><span class="lineno"> 4712</span>                     <span class="stringliteral">&quot;phase for this context is not in effect: bailing out of this operation.&quot;</span>);</div>
<div class="line"><a id="l04713" name="l04713"></a><span class="lineno"> 4713</span>    <span class="keywordflow">return</span> <span class="keyword">true</span>;</div>
<div class="line"><a id="l04714" name="l04714"></a><span class="lineno"> 4714</span>  }</div>
<div class="line"><a id="l04715" name="l04715"></a><span class="lineno"> 4715</span>  <span class="comment">// else</span></div>
<div class="line"><a id="l04716" name="l04716"></a><span class="lineno"> 4716</span> </div>
<div class="line"><a id="l04717" name="l04717"></a><span class="lineno"> 4717</span>  <span class="keywordflow">return</span> <span class="keyword">false</span>;</div>
<div class="line"><a id="l04718" name="l04718"></a><span class="lineno"> 4718</span>} <span class="comment">// Channel::check_phase_and_prior_error()</span></div>
<div class="line"><a id="l04719" name="l04719"></a><span class="lineno"> 4719</span> </div>
<div class="line"><a id="l04720" name="l04720"></a><span class="lineno"> 4720</span><a class="code hl_define" href="ipc__transport__structured_2src_2ipc_2transport_2struc_2sync__io_2channel_8hpp.html#a50e1bb663274c68c760263342ddfdcbc">TEMPLATE_SIO_STRUCT_CHANNEL</a></div>
<div class="line"><a id="l04721" name="l04721"></a><span class="lineno"><a class="line" href="classipc_1_1transport_1_1struc_1_1sync__io_1_1Channel.html#a426ecae27b4ea5cf7e666e56bad6afe5"> 4721</a></span><span class="keyword">typename</span> CLASS_SIO_STRUCT_CHANNEL::Msg_out CLASS_SIO_STRUCT_CHANNEL::create_msg(<a class="code hl_struct" href="structipc_1_1util_1_1Native__handle.html">Native_handle</a>&amp;&amp; hndl_or_null)<span class="keyword"> const</span></div>
<div class="line"><a id="l04722" name="l04722"></a><span class="lineno"> 4722</span><span class="keyword"></span>{</div>
<div class="line"><a id="l04723" name="l04723"></a><span class="lineno"> 4723</span>  <span class="comment">// We are just a convenience helper really; all we do is pass-in m_struct_builder_config memorized for convenience.</span></div>
<div class="line"><a id="l04724" name="l04724"></a><span class="lineno"> 4724</span> </div>
<div class="line"><a id="l04725" name="l04725"></a><span class="lineno"> 4725</span>  <a class="code hl_class" href="classipc_1_1transport_1_1struc_1_1Msg__out.html">Msg_out</a> msg(m_struct_builder_config);</div>
<div class="line"><a id="l04726" name="l04726"></a><span class="lineno"> 4726</span>  <span class="keywordflow">if</span> (!hndl_or_null.null()) <span class="comment">// Tiny optimization to skip past some boring checks inside store_...().</span></div>
<div class="line"><a id="l04727" name="l04727"></a><span class="lineno"> 4727</span>  {</div>
<div class="line"><a id="l04728" name="l04728"></a><span class="lineno"> 4728</span>    msg.<a class="code hl_function" href="classipc_1_1transport_1_1struc_1_1Msg__out.html#aced8ef8237617c74aaf06832d1385fed">store_native_handle_or_null</a>(std::move(hndl_or_null));</div>
<div class="line"><a id="l04729" name="l04729"></a><span class="lineno"> 4729</span>  }</div>
<div class="line"><a id="l04730" name="l04730"></a><span class="lineno"> 4730</span>  <span class="keywordflow">return</span> msg;</div>
<div class="line"><a id="l04731" name="l04731"></a><span class="lineno"> 4731</span>}</div>
<div class="line"><a id="l04732" name="l04732"></a><span class="lineno"> 4732</span> </div>
<div class="line"><a id="l04733" name="l04733"></a><span class="lineno"> 4733</span><a class="code hl_define" href="ipc__transport__structured_2src_2ipc_2transport_2struc_2sync__io_2channel_8hpp.html#a50e1bb663274c68c760263342ddfdcbc">TEMPLATE_SIO_STRUCT_CHANNEL</a></div>
<div class="line"><a id="l04734" name="l04734"></a><span class="lineno"> 4734</span><span class="keyword">template</span>&lt;<span class="keyword">typename</span> On_msg_handler&gt;</div>
<div class="line"><a id="l04735" name="l04735"></a><span class="lineno"><a class="line" href="classipc_1_1transport_1_1struc_1_1sync__io_1_1Channel.html#a5fc489b9abefe5ab676f6991d6d03f0d"> 4735</a></span><span class="keywordtype">bool</span> CLASS_SIO_STRUCT_CHANNEL::expect_msg(<a class="code hl_typedef" href="classipc_1_1transport_1_1struc_1_1sync__io_1_1Channel.html#aa40c3ec3f45cdfea9360f7f35b9ade3c">Msg_which_in</a> which, <a class="code hl_typedef" href="classipc_1_1transport_1_1struc_1_1sync__io_1_1Channel.html#acde2b3866547a30958035203d9d89928">Msg_in_ptr</a>* qd_msg, On_msg_handler&amp;&amp; on_msg_func)</div>
<div class="line"><a id="l04736" name="l04736"></a><span class="lineno"> 4736</span>{</div>
<div class="line"><a id="l04737" name="l04737"></a><span class="lineno"> 4737</span>  <span class="keyword">using </span>boost::make_shared;</div>
<div class="line"><a id="l04738" name="l04738"></a><span class="lineno"> 4738</span> </div>
<div class="line"><a id="l04739" name="l04739"></a><span class="lineno"> 4739</span>  assert(qd_msg);</div>
<div class="line"><a id="l04740" name="l04740"></a><span class="lineno"> 4740</span>  <span class="keywordflow">if</span> (check_phase_and_prior_error(Phase::S_LOGGED_IN, <span class="stringliteral">&quot;expect_msg()&quot;</span>))</div>
<div class="line"><a id="l04741" name="l04741"></a><span class="lineno"> 4741</span>  {</div>
<div class="line"><a id="l04742" name="l04742"></a><span class="lineno"> 4742</span>    <span class="keywordflow">return</span> <span class="keyword">false</span>;</div>
<div class="line"><a id="l04743" name="l04743"></a><span class="lineno"> 4743</span>  }</div>
<div class="line"><a id="l04744" name="l04744"></a><span class="lineno"> 4744</span>  <span class="comment">// else</span></div>
<div class="line"><a id="l04745" name="l04745"></a><span class="lineno"> 4745</span> </div>
<div class="line"><a id="l04746" name="l04746"></a><span class="lineno"> 4746</span>  <a class="code hl_typedef" href="classipc_1_1transport_1_1struc_1_1sync__io_1_1Channel.html#a4ab778bce8d7e6e84788879fedc62745">Msgs_in</a> qd_msgs;</div>
<div class="line"><a id="l04747" name="l04747"></a><span class="lineno"> 4747</span>  <span class="keyword">const</span> <span class="keywordtype">bool</span> ok = expect_msgs_impl(&amp;qd_msgs,</div>
<div class="line"><a id="l04748" name="l04748"></a><span class="lineno"> 4748</span>                                   <span class="keyword">true</span>, <span class="comment">// One-off expectation (one message expected).</span></div>
<div class="line"><a id="l04749" name="l04749"></a><span class="lineno"> 4749</span>                                   which,</div>
<div class="line"><a id="l04750" name="l04750"></a><span class="lineno"> 4750</span>                                   make_shared&lt;On_msg_func&gt;(std::move(on_msg_func)));</div>
<div class="line"><a id="l04751" name="l04751"></a><span class="lineno"> 4751</span> </div>
<div class="line"><a id="l04752" name="l04752"></a><span class="lineno"> 4752</span>  <span class="keywordflow">if</span> (ok &amp;&amp; (!qd_msgs.empty()))</div>
<div class="line"><a id="l04753" name="l04753"></a><span class="lineno"> 4753</span>  {</div>
<div class="line"><a id="l04754" name="l04754"></a><span class="lineno"> 4754</span>    assert((qd_msgs.size() == 1) || <span class="stringliteral">&quot;Desiring 1 message -- should have emitted at most 1 already-ready message.&quot;</span>);</div>
<div class="line"><a id="l04755" name="l04755"></a><span class="lineno"> 4755</span>    *qd_msg = std::move(qd_msgs.front());</div>
<div class="line"><a id="l04756" name="l04756"></a><span class="lineno"> 4756</span>  }</div>
<div class="line"><a id="l04757" name="l04757"></a><span class="lineno"> 4757</span>  <span class="keywordflow">else</span></div>
<div class="line"><a id="l04758" name="l04758"></a><span class="lineno"> 4758</span>  {</div>
<div class="line"><a id="l04759" name="l04759"></a><span class="lineno"> 4759</span>    qd_msg-&gt;reset();</div>
<div class="line"><a id="l04760" name="l04760"></a><span class="lineno"> 4760</span>  }</div>
<div class="line"><a id="l04761" name="l04761"></a><span class="lineno"> 4761</span> </div>
<div class="line"><a id="l04762" name="l04762"></a><span class="lineno"> 4762</span>  <span class="keywordflow">return</span> ok;</div>
<div class="line"><a id="l04763" name="l04763"></a><span class="lineno"> 4763</span>} <span class="comment">// Channel::expect_msg()</span></div>
<div class="line"><a id="l04764" name="l04764"></a><span class="lineno"> 4764</span> </div>
<div class="line"><a id="l04765" name="l04765"></a><span class="lineno"> 4765</span><a class="code hl_define" href="ipc__transport__structured_2src_2ipc_2transport_2struc_2sync__io_2channel_8hpp.html#a50e1bb663274c68c760263342ddfdcbc">TEMPLATE_SIO_STRUCT_CHANNEL</a></div>
<div class="line"><a id="l04766" name="l04766"></a><span class="lineno"> 4766</span><span class="keyword">template</span>&lt;<span class="keyword">typename</span> On_msg_handler&gt;</div>
<div class="line"><a id="l04767" name="l04767"></a><span class="lineno"><a class="line" href="classipc_1_1transport_1_1struc_1_1sync__io_1_1Channel.html#a62f52488ba20dd6c69dfc1abadb2d69f"> 4767</a></span><span class="keywordtype">bool</span> CLASS_SIO_STRUCT_CHANNEL::expect_msgs(<a class="code hl_typedef" href="classipc_1_1transport_1_1struc_1_1sync__io_1_1Channel.html#aa40c3ec3f45cdfea9360f7f35b9ade3c">Msg_which_in</a> which, <a class="code hl_typedef" href="classipc_1_1transport_1_1struc_1_1sync__io_1_1Channel.html#a4ab778bce8d7e6e84788879fedc62745">Msgs_in</a>* qd_msgs, On_msg_handler&amp;&amp; on_msg_func)</div>
<div class="line"><a id="l04768" name="l04768"></a><span class="lineno"> 4768</span>{</div>
<div class="line"><a id="l04769" name="l04769"></a><span class="lineno"> 4769</span>  <span class="keyword">using </span>boost::make_shared;</div>
<div class="line"><a id="l04770" name="l04770"></a><span class="lineno"> 4770</span> </div>
<div class="line"><a id="l04771" name="l04771"></a><span class="lineno"> 4771</span>  assert(qd_msgs);</div>
<div class="line"><a id="l04772" name="l04772"></a><span class="lineno"> 4772</span>  <span class="keywordflow">if</span> (check_phase_and_prior_error(Phase::S_LOGGED_IN, <span class="stringliteral">&quot;expect_msgs()&quot;</span>))</div>
<div class="line"><a id="l04773" name="l04773"></a><span class="lineno"> 4773</span>  {</div>
<div class="line"><a id="l04774" name="l04774"></a><span class="lineno"> 4774</span>    <span class="keywordflow">return</span> <span class="keyword">false</span>;</div>
<div class="line"><a id="l04775" name="l04775"></a><span class="lineno"> 4775</span>  }</div>
<div class="line"><a id="l04776" name="l04776"></a><span class="lineno"> 4776</span>  <span class="comment">// else</span></div>
<div class="line"><a id="l04777" name="l04777"></a><span class="lineno"> 4777</span> </div>
<div class="line"><a id="l04778" name="l04778"></a><span class="lineno"> 4778</span>  <span class="keywordflow">return</span> expect_msgs_impl(qd_msgs,</div>
<div class="line"><a id="l04779" name="l04779"></a><span class="lineno"> 4779</span>                          <span class="keyword">false</span>, <span class="comment">// Open-ended expectation (0+ messages expected).</span></div>
<div class="line"><a id="l04780" name="l04780"></a><span class="lineno"> 4780</span>                          which,</div>
<div class="line"><a id="l04781" name="l04781"></a><span class="lineno"> 4781</span>                          make_shared&lt;On_msg_func&gt;(std::move(on_msg_func)));</div>
<div class="line"><a id="l04782" name="l04782"></a><span class="lineno"> 4782</span>}</div>
<div class="line"><a id="l04783" name="l04783"></a><span class="lineno"> 4783</span> </div>
<div class="line"><a id="l04784" name="l04784"></a><span class="lineno"> 4784</span><a class="code hl_define" href="ipc__transport__structured_2src_2ipc_2transport_2struc_2sync__io_2channel_8hpp.html#a50e1bb663274c68c760263342ddfdcbc">TEMPLATE_SIO_STRUCT_CHANNEL</a></div>
<div class="line"><a id="l04785" name="l04785"></a><span class="lineno"> 4785</span><span class="keyword">template</span>&lt;<span class="keyword">typename</span> On_msg_handler&gt;</div>
<div class="line"><a id="l04786" name="l04786"></a><span class="lineno"><a class="line" href="classipc_1_1transport_1_1struc_1_1sync__io_1_1Channel.html#a996e06f75024e10987eb9cf62e096eec"> 4786</a></span><span class="keywordtype">bool</span> CLASS_SIO_STRUCT_CHANNEL::expect_log_in_request(<a class="code hl_typedef" href="classipc_1_1transport_1_1struc_1_1sync__io_1_1Channel.html#aa40c3ec3f45cdfea9360f7f35b9ade3c">Msg_which_in</a> which, <a class="code hl_typedef" href="classipc_1_1transport_1_1struc_1_1sync__io_1_1Channel.html#acde2b3866547a30958035203d9d89928">Msg_in_ptr</a>* qd_msg,</div>
<div class="line"><a id="l04787" name="l04787"></a><span class="lineno"> 4787</span>                                                     On_msg_handler&amp;&amp; on_log_in_req_func)</div>
<div class="line"><a id="l04788" name="l04788"></a><span class="lineno"> 4788</span>{</div>
<div class="line"><a id="l04789" name="l04789"></a><span class="lineno"> 4789</span>  <span class="keyword">using </span>boost::make_shared;</div>
<div class="line"><a id="l04790" name="l04790"></a><span class="lineno"> 4790</span> </div>
<div class="line"><a id="l04791" name="l04791"></a><span class="lineno"> 4791</span>  assert(qd_msg);</div>
<div class="line"><a id="l04792" name="l04792"></a><span class="lineno"> 4792</span>  <span class="keywordflow">if</span> (check_phase_and_prior_error(Phase::S_SRV_LOG_IN, <span class="stringliteral">&quot;expect_log_in_request()&quot;</span>))</div>
<div class="line"><a id="l04793" name="l04793"></a><span class="lineno"> 4793</span>  {</div>
<div class="line"><a id="l04794" name="l04794"></a><span class="lineno"> 4794</span>    <span class="keywordflow">return</span> <span class="keyword">false</span>;</div>
<div class="line"><a id="l04795" name="l04795"></a><span class="lineno"> 4795</span>  }</div>
<div class="line"><a id="l04796" name="l04796"></a><span class="lineno"> 4796</span>  <span class="comment">// else</span></div>
<div class="line"><a id="l04797" name="l04797"></a><span class="lineno"> 4797</span> </div>
<div class="line"><a id="l04798" name="l04798"></a><span class="lineno"> 4798</span>  <span class="keywordflow">if</span> (m_phase_log_in_started)</div>
<div class="line"><a id="l04799" name="l04799"></a><span class="lineno"> 4799</span>  {</div>
<div class="line"><a id="l04800" name="l04800"></a><span class="lineno"> 4800</span>    FLOW_LOG_WARNING(<span class="stringliteral">&quot;struc::Channel [&quot;</span> &lt;&lt; *<span class="keyword">this</span> &lt;&lt; <span class="stringliteral">&quot;]: Log-in: expect_log_in_request() called again.  &quot;</span></div>
<div class="line"><a id="l04801" name="l04801"></a><span class="lineno"> 4801</span>                     <span class="stringliteral">&quot;Ignoring.&quot;</span>);</div>
<div class="line"><a id="l04802" name="l04802"></a><span class="lineno"> 4802</span>    <span class="keywordflow">return</span> <span class="keyword">false</span>;</div>
<div class="line"><a id="l04803" name="l04803"></a><span class="lineno"> 4803</span>  }</div>
<div class="line"><a id="l04804" name="l04804"></a><span class="lineno"> 4804</span>  <span class="comment">// else</span></div>
<div class="line"><a id="l04805" name="l04805"></a><span class="lineno"> 4805</span>  m_phase_log_in_started = <span class="keyword">true</span>;</div>
<div class="line"><a id="l04806" name="l04806"></a><span class="lineno"> 4806</span> </div>
<div class="line"><a id="l04807" name="l04807"></a><span class="lineno"> 4807</span>  <a class="code hl_typedef" href="classipc_1_1transport_1_1struc_1_1sync__io_1_1Channel.html#a4ab778bce8d7e6e84788879fedc62745">Msgs_in</a> qd_msgs;</div>
<div class="line"><a id="l04808" name="l04808"></a><span class="lineno"> 4808</span>  <span class="keyword">const</span> <span class="keywordtype">bool</span> ok = expect_msgs_impl(&amp;qd_msgs,</div>
<div class="line"><a id="l04809" name="l04809"></a><span class="lineno"> 4809</span>                                   <span class="keyword">true</span>, <span class="comment">// One-off expectation (one message -- the log-in response -- expected).</span></div>
<div class="line"><a id="l04810" name="l04810"></a><span class="lineno"> 4810</span>                                   which,</div>
<div class="line"><a id="l04811" name="l04811"></a><span class="lineno"> 4811</span>                                   make_shared&lt;On_msg_func&gt;(std::move(on_log_in_req_func)));</div>
<div class="line"><a id="l04812" name="l04812"></a><span class="lineno"> 4812</span>  <span class="keywordflow">if</span> (ok &amp;&amp; (!qd_msgs.empty()))</div>
<div class="line"><a id="l04813" name="l04813"></a><span class="lineno"> 4813</span>  {</div>
<div class="line"><a id="l04814" name="l04814"></a><span class="lineno"> 4814</span>    assert((qd_msgs.size() == 1) &amp;&amp; <span class="stringliteral">&quot;Only one log-in request would have been accepted without error.&quot;</span>);</div>
<div class="line"><a id="l04815" name="l04815"></a><span class="lineno"> 4815</span>    *qd_msg = std::move(qd_msgs.front());</div>
<div class="line"><a id="l04816" name="l04816"></a><span class="lineno"> 4816</span>  }</div>
<div class="line"><a id="l04817" name="l04817"></a><span class="lineno"> 4817</span>  <span class="keywordflow">else</span></div>
<div class="line"><a id="l04818" name="l04818"></a><span class="lineno"> 4818</span>  {</div>
<div class="line"><a id="l04819" name="l04819"></a><span class="lineno"> 4819</span>    qd_msg-&gt;reset();</div>
<div class="line"><a id="l04820" name="l04820"></a><span class="lineno"> 4820</span>  }</div>
<div class="line"><a id="l04821" name="l04821"></a><span class="lineno"> 4821</span> </div>
<div class="line"><a id="l04822" name="l04822"></a><span class="lineno"> 4822</span>  <span class="keywordflow">return</span> ok;</div>
<div class="line"><a id="l04823" name="l04823"></a><span class="lineno"> 4823</span>} <span class="comment">// Channel::expect_log_in_request()</span></div>
<div class="line"><a id="l04824" name="l04824"></a><span class="lineno"> 4824</span> </div>
<div class="line"><a id="l04825" name="l04825"></a><span class="lineno"> 4825</span><a class="code hl_define" href="ipc__transport__structured_2src_2ipc_2transport_2struc_2sync__io_2channel_8hpp.html#a50e1bb663274c68c760263342ddfdcbc">TEMPLATE_SIO_STRUCT_CHANNEL</a></div>
<div class="line"><a id="l04826" name="l04826"></a><span class="lineno"><a class="line" href="classipc_1_1transport_1_1struc_1_1sync__io_1_1Channel.html#a2552eada8012c4a8c4d2fc5f02e9f69b"> 4826</a></span><span class="keywordtype">bool</span> CLASS_SIO_STRUCT_CHANNEL::expect_msgs_impl(<a class="code hl_typedef" href="classipc_1_1transport_1_1struc_1_1sync__io_1_1Channel.html#a4ab778bce8d7e6e84788879fedc62745">Msgs_in</a>* qd_msgs,</div>
<div class="line"><a id="l04827" name="l04827"></a><span class="lineno"> 4827</span>                                                <span class="keywordtype">bool</span> one_off, <a class="code hl_typedef" href="classipc_1_1transport_1_1struc_1_1sync__io_1_1Channel.html#aa40c3ec3f45cdfea9360f7f35b9ade3c">Msg_which_in</a> which, <a class="code hl_typedef" href="classipc_1_1transport_1_1struc_1_1sync__io_1_1Channel.html#a583ccd4bb6b1aefb09d77e5709aef5b4">On_msg_func_ptr</a>&amp;&amp; on_msg_func_moved)</div>
<div class="line"><a id="l04828" name="l04828"></a><span class="lineno"> 4828</span>{</div>
<div class="line"><a id="l04829" name="l04829"></a><span class="lineno"> 4829</span>  <span class="keyword">using </span>std::vector;</div>
<div class="line"><a id="l04830" name="l04830"></a><span class="lineno"> 4830</span> </div>
<div class="line"><a id="l04831" name="l04831"></a><span class="lineno"> 4831</span>  <span class="keyword">const</span> <span class="keyword">auto</span> insert_result</div>
<div class="line"><a id="l04832" name="l04832"></a><span class="lineno"> 4832</span>    = m_rcv_expecting_msg_map.emplace(which, <span class="keyword">new</span> <a class="code hl_struct" href="structipc_1_1transport_1_1struc_1_1sync__io_1_1Channel_1_1Expecting__response.html">Expecting_msg</a>{ one_off, on_msg_func_moved });</div>
<div class="line"><a id="l04833" name="l04833"></a><span class="lineno"> 4833</span>  <span class="keyword">auto</span>&amp; exp_msg_it = insert_result.first;</div>
<div class="line"><a id="l04834" name="l04834"></a><span class="lineno"> 4834</span>  <span class="keyword">auto</span> on_msg_func = std::move(on_msg_func_moved); <span class="comment">// We may need to immediately fire/pop this below.</span></div>
<div class="line"><a id="l04835" name="l04835"></a><span class="lineno"> 4835</span>  <span class="keyword">const</span> <span class="keywordtype">bool</span> inserted = insert_result.second;</div>
<div class="line"><a id="l04836" name="l04836"></a><span class="lineno"> 4836</span> </div>
<div class="line"><a id="l04837" name="l04837"></a><span class="lineno"> 4837</span>  <span class="keywordflow">if</span> (!inserted)</div>
<div class="line"><a id="l04838" name="l04838"></a><span class="lineno"> 4838</span>  {</div>
<div class="line"><a id="l04839" name="l04839"></a><span class="lineno"> 4839</span>    FLOW_LOG_WARNING(<span class="stringliteral">&quot;struc::Channel [&quot;</span> &lt;&lt; *<span class="keyword">this</span> &lt;&lt; <span class="stringliteral">&quot;]: Wanted to register a (one-off? = [&quot;</span> &lt;&lt; one_off &lt;&lt; <span class="stringliteral">&quot;]) &quot;</span></div>
<div class="line"><a id="l04840" name="l04840"></a><span class="lineno"> 4840</span>                     <span class="stringliteral">&quot;message expectation (union-which = [&quot;</span> &lt;&lt; <span class="keywordtype">int</span>(which) &lt;&lt; <span class="stringliteral">&quot;]); but there is already one registered &quot;</span></div>
<div class="line"><a id="l04841" name="l04841"></a><span class="lineno"> 4841</span>                     <span class="stringliteral">&quot;for that union-which.  Ignoring.&quot;</span>);</div>
<div class="line"><a id="l04842" name="l04842"></a><span class="lineno"> 4842</span>    <span class="keywordflow">return</span> <span class="keyword">false</span>;</div>
<div class="line"><a id="l04843" name="l04843"></a><span class="lineno"> 4843</span>  }</div>
<div class="line"><a id="l04844" name="l04844"></a><span class="lineno"> 4844</span>  <span class="comment">// else if (inserted):</span></div>
<div class="line"><a id="l04845" name="l04845"></a><span class="lineno"> 4845</span> </div>
<div class="line"><a id="l04846" name="l04846"></a><span class="lineno"> 4846</span>  <span class="keyword">const</span> <span class="keywordtype">bool</span> logging_in = m_phase != Phase::S_LOGGED_IN;</div>
<div class="line"><a id="l04847" name="l04847"></a><span class="lineno"> 4847</span>  <span class="keyword">const</span> <span class="keyword">auto</span> msgs_in_q_it = m_rcv_pending_msgs.find(which);</div>
<div class="line"><a id="l04848" name="l04848"></a><span class="lineno"> 4848</span>  <span class="keyword">const</span> <span class="keywordtype">bool</span> found = msgs_in_q_it != m_rcv_pending_msgs.end();</div>
<div class="line"><a id="l04849" name="l04849"></a><span class="lineno"> 4849</span> </div>
<div class="line"><a id="l04850" name="l04850"></a><span class="lineno"> 4850</span>  FLOW_LOG_TRACE(<span class="stringliteral">&quot;struc::Channel [&quot;</span> &lt;&lt; *<span class="keyword">this</span> &lt;&lt; <span class="stringliteral">&quot;]: Registered a (one-off? = [&quot;</span> &lt;&lt; one_off &lt;&lt; <span class="stringliteral">&quot;]) &quot;</span></div>
<div class="line"><a id="l04851" name="l04851"></a><span class="lineno"> 4851</span>                 <span class="stringliteral">&quot;message expectation (union-which = [&quot;</span> &lt;&lt; <span class="keywordtype">int</span>(which) &lt;&lt; <span class="stringliteral">&quot;]); that raises their total count to &quot;</span></div>
<div class="line"><a id="l04852" name="l04852"></a><span class="lineno"> 4852</span>                 <span class="stringliteral">&quot;[&quot;</span> &lt;&lt; m_rcv_expecting_msg_map.size() &lt;&lt; <span class="stringliteral">&quot;].  Will immediately return qd-msgs if &quot;</span></div>
<div class="line"><a id="l04853" name="l04853"></a><span class="lineno"> 4853</span>                 <span class="stringliteral">&quot;we had collected 1+ messages matching that union-which; had we? = [&quot;</span> &lt;&lt; found &lt;&lt; <span class="stringliteral">&quot;].&quot;</span>);</div>
<div class="line"><a id="l04854" name="l04854"></a><span class="lineno"> 4854</span>  <span class="keywordflow">if</span> (!found)</div>
<div class="line"><a id="l04855" name="l04855"></a><span class="lineno"> 4855</span>  {</div>
<div class="line"><a id="l04856" name="l04856"></a><span class="lineno"> 4856</span>    <span class="keywordflow">if</span> (logging_in &amp;&amp; (!m_rcv_pending_msgs.empty()))</div>
<div class="line"><a id="l04857" name="l04857"></a><span class="lineno"> 4857</span>    {</div>
<div class="line"><a id="l04858" name="l04858"></a><span class="lineno"> 4858</span>      assert((m_phase == Phase::S_SRV_LOG_IN) &amp;&amp; <span class="stringliteral">&quot;Unless LOGGED_IN we should only be called by expect_log_in_request() &quot;</span></div>
<div class="line"><a id="l04859" name="l04859"></a><span class="lineno"> 4859</span>                                                   <span class="stringliteral">&quot;which implies SRV_LOG_IN.&quot;</span>);</div>
<div class="line"><a id="l04860" name="l04860"></a><span class="lineno"> 4860</span>      assert((m_rcv_pending_msgs.size() == 1)</div>
<div class="line"><a id="l04861" name="l04861"></a><span class="lineno"> 4861</span>             &amp;&amp; <span class="stringliteral">&quot;Other code is supposed to ensure we cache at most the log-in request and no more in-messages while &quot;</span></div>
<div class="line"><a id="l04862" name="l04862"></a><span class="lineno"> 4862</span>                  <span class="stringliteral">&quot;in SRV_LOG_IN phase.&quot;</span>);</div>
<div class="line"><a id="l04863" name="l04863"></a><span class="lineno"> 4863</span>      assert((m_rcv_expecting_msg_map.size() == 1)</div>
<div class="line"><a id="l04864" name="l04864"></a><span class="lineno"> 4864</span>             &amp;&amp; <span class="stringliteral">&quot;Other code is supposed to prevent logged-in APIs like expect_msg() in this phase; and more than one &quot;</span></div>
<div class="line"><a id="l04865" name="l04865"></a><span class="lineno"> 4865</span>                  <span class="stringliteral">&quot;successful call to expect_log_in_request(); yet somehow we&#39;d saved more expectations than exactly &quot;</span></div>
<div class="line"><a id="l04866" name="l04866"></a><span class="lineno"> 4866</span>                  <span class="stringliteral">&quot;1 in m_rcv_expecting_msg_map.&quot;</span>);</div>
<div class="line"><a id="l04867" name="l04867"></a><span class="lineno"> 4867</span> </div>
<div class="line"><a id="l04868" name="l04868"></a><span class="lineno"> 4868</span>      FLOW_LOG_WARNING(<span class="stringliteral">&quot;struc::Channel [&quot;</span> &lt;&lt; *<span class="keyword">this</span> &lt;&lt; <span class="stringliteral">&quot;]: Registered a (one-off? = [&quot;</span> &lt;&lt; one_off &lt;&lt; <span class="stringliteral">&quot;]) &quot;</span></div>
<div class="line"><a id="l04869" name="l04869"></a><span class="lineno"> 4869</span>                       <span class="stringliteral">&quot;*log-in request* expectation (union-which = [&quot;</span> &lt;&lt; <span class="keywordtype">int</span>(which) &lt;&lt; <span class="stringliteral">&quot;]); that raises their &quot;</span></div>
<div class="line"><a id="l04870" name="l04870"></a><span class="lineno"> 4870</span>                       <span class="stringliteral">&quot;total count to 1.  Would immediately queue handler(s) to fire if &quot;</span></div>
<div class="line"><a id="l04871" name="l04871"></a><span class="lineno"> 4871</span>                       <span class="stringliteral">&quot;we had collected 1 messages matching that union-which; but we had not; however we had &quot;</span></div>
<div class="line"><a id="l04872" name="l04872"></a><span class="lineno"> 4872</span>                       <span class="stringliteral">&quot;cached 1 message with different union-which = &quot;</span></div>
<div class="line"><a id="l04873" name="l04873"></a><span class="lineno"> 4873</span>                       <span class="stringliteral">&quot;[&quot;</span> &lt;&lt; <span class="keywordtype">int</span>(m_rcv_pending_msgs.begin()-&gt;first) &lt;&lt; <span class="stringliteral">&quot;].  &quot;</span></div>
<div class="line"><a id="l04874" name="l04874"></a><span class="lineno"> 4874</span>                       <span class="stringliteral">&quot;So: peer expects log-in request X, while other side sent log-in request Y.  &quot;</span></div>
<div class="line"><a id="l04875" name="l04875"></a><span class="lineno"> 4875</span>                       <span class="stringliteral">&quot;This might be a protocol error on the user&#39;s part on this or other side or both.&quot;</span>);</div>
<div class="line"><a id="l04876" name="l04876"></a><span class="lineno"> 4876</span>      <span class="comment">// Subtlety: See similar comment in the on-receive handler where it also emits this error.</span></div>
<div class="line"><a id="l04877" name="l04877"></a><span class="lineno"> 4877</span>      handle_new_error(<a class="code hl_enumvalue" href="namespaceipc_1_1transport_1_1struc_1_1error.html#a990b9ff850cf9aaf354efdd07d86a71dad88bc7df9bd2dcdf4370585c912a9a61">error::Code::S_STRUCT_CHANNEL_GOT_UNEXPECTED_LOG_IN_REQUEST</a>, <span class="stringliteral">&quot;expect_msgs_impl()&quot;</span>);</div>
<div class="line"><a id="l04878" name="l04878"></a><span class="lineno"> 4878</span>      <span class="keywordflow">return</span> <span class="keyword">false</span>;</div>
<div class="line"><a id="l04879" name="l04879"></a><span class="lineno"> 4879</span>    }</div>
<div class="line"><a id="l04880" name="l04880"></a><span class="lineno"> 4880</span>    <span class="comment">// else</span></div>
<div class="line"><a id="l04881" name="l04881"></a><span class="lineno"> 4881</span> </div>
<div class="line"><a id="l04882" name="l04882"></a><span class="lineno"> 4882</span>    <span class="keywordflow">return</span> <span class="keyword">true</span>; <span class="comment">// Cool -- just await future in-message(s) with `which`.</span></div>
<div class="line"><a id="l04883" name="l04883"></a><span class="lineno"> 4883</span>  } <span class="comment">// if (!found)</span></div>
<div class="line"><a id="l04884" name="l04884"></a><span class="lineno"> 4884</span>  <span class="comment">// else if (found):</span></div>
<div class="line"><a id="l04885" name="l04885"></a><span class="lineno"> 4885</span> </div>
<div class="line"><a id="l04886" name="l04886"></a><span class="lineno"> 4886</span>  qd_msgs-&gt;clear();</div>
<div class="line"><a id="l04887" name="l04887"></a><span class="lineno"> 4887</span> </div>
<div class="line"><a id="l04888" name="l04888"></a><span class="lineno"> 4888</span>  <span class="keyword">auto</span>&amp; msgs_in_q = msgs_in_q_it-&gt;second;</div>
<div class="line"><a id="l04889" name="l04889"></a><span class="lineno"> 4889</span>  assert((!msgs_in_q.empty()) &amp;&amp; <span class="stringliteral">&quot;We always erase m_rcv_pending_msgs[] queue once it&#39;s empty... yet a queue is empty.&quot;</span>);</div>
<div class="line"><a id="l04890" name="l04890"></a><span class="lineno"> 4890</span> </div>
<div class="line"><a id="l04891" name="l04891"></a><span class="lineno"> 4891</span>  <span class="keywordflow">if</span> (one_off)</div>
<div class="line"><a id="l04892" name="l04892"></a><span class="lineno"> 4892</span>  {</div>
<div class="line"><a id="l04893" name="l04893"></a><span class="lineno"> 4893</span>    qd_msgs-&gt;reserve(1); <span class="comment">// Little optimization.  Maybe it&#39;ll make it reserve 1 exactly; maybe it&#39;s a no-op.</span></div>
<div class="line"><a id="l04894" name="l04894"></a><span class="lineno"> 4894</span> </div>
<div class="line"><a id="l04895" name="l04895"></a><span class="lineno"> 4895</span>    <a class="code hl_typedef" href="classipc_1_1transport_1_1struc_1_1sync__io_1_1Channel.html#a84287334d14f54c97f7dbb0d5b04cca5">Msg_in_ptr_uniq</a> msg_in(std::move(msgs_in_q.front()));</div>
<div class="line"><a id="l04896" name="l04896"></a><span class="lineno"> 4896</span>    msgs_in_q.pop();</div>
<div class="line"><a id="l04897" name="l04897"></a><span class="lineno"> 4897</span>    <span class="keywordflow">if</span> (msgs_in_q.empty()) <span class="comment">// Empty -&gt; immediately erase.</span></div>
<div class="line"><a id="l04898" name="l04898"></a><span class="lineno"> 4898</span>    {</div>
<div class="line"><a id="l04899" name="l04899"></a><span class="lineno"> 4899</span>      m_rcv_pending_msgs.erase(msgs_in_q_it); <span class="comment">// msg_in_q now points to garbage (do not touch it).</span></div>
<div class="line"><a id="l04900" name="l04900"></a><span class="lineno"> 4900</span>      FLOW_LOG_TRACE(<span class="stringliteral">&quot;Popped 1 (because one-off expectation); queue is now empty.&quot;</span>);</div>
<div class="line"><a id="l04901" name="l04901"></a><span class="lineno"> 4901</span>    }</div>
<div class="line"><a id="l04902" name="l04902"></a><span class="lineno"> 4902</span>    <span class="keywordflow">else</span></div>
<div class="line"><a id="l04903" name="l04903"></a><span class="lineno"> 4903</span>    {</div>
<div class="line"><a id="l04904" name="l04904"></a><span class="lineno"> 4904</span>      FLOW_LOG_TRACE(<span class="stringliteral">&quot;Popped 1 (because one-off expectation); queue is now sized [&quot;</span> &lt;&lt; msgs_in_q.size() &lt;&lt; <span class="stringliteral">&quot;].&quot;</span>);</div>
<div class="line"><a id="l04905" name="l04905"></a><span class="lineno"> 4905</span>    }</div>
<div class="line"><a id="l04906" name="l04906"></a><span class="lineno"> 4906</span> </div>
<div class="line"><a id="l04907" name="l04907"></a><span class="lineno"> 4907</span>    qd_msgs-&gt;emplace_back(<a class="code hl_typedef" href="classipc_1_1transport_1_1struc_1_1sync__io_1_1Channel.html#acde2b3866547a30958035203d9d89928">Msg_in_ptr</a>(msg_in.release())); <span class="comment">// Upgrade to shared_ptr&lt;&gt; by the way.</span></div>
<div class="line"><a id="l04908" name="l04908"></a><span class="lineno"> 4908</span> </div>
<div class="line"><a id="l04909" name="l04909"></a><span class="lineno"> 4909</span>    <span class="comment">// ...and un-insert the registered expectation, since it was immediately met.  @todo Can perf this up probably.</span></div>
<div class="line"><a id="l04910" name="l04910"></a><span class="lineno"> 4910</span>    m_rcv_expecting_msg_map.erase(exp_msg_it);</div>
<div class="line"><a id="l04911" name="l04911"></a><span class="lineno"> 4911</span>    <span class="keywordflow">return</span> <span class="keyword">true</span>;</div>
<div class="line"><a id="l04912" name="l04912"></a><span class="lineno"> 4912</span>  }</div>
<div class="line"><a id="l04913" name="l04913"></a><span class="lineno"> 4913</span>  <span class="comment">// else if (!one_off):</span></div>
<div class="line"><a id="l04914" name="l04914"></a><span class="lineno"> 4914</span> </div>
<div class="line"><a id="l04915" name="l04915"></a><span class="lineno"> 4915</span>  <span class="comment">// Emit the entire queue of waiting messages.</span></div>
<div class="line"><a id="l04916" name="l04916"></a><span class="lineno"> 4916</span>  qd_msgs-&gt;reserve(msgs_in_q.size()); <span class="comment">// Little optimization.</span></div>
<div class="line"><a id="l04917" name="l04917"></a><span class="lineno"> 4917</span> </div>
<div class="line"><a id="l04918" name="l04918"></a><span class="lineno"> 4918</span>  <span class="keywordflow">do</span> <span class="comment">// while (!msgs_in_q.empty())</span></div>
<div class="line"><a id="l04919" name="l04919"></a><span class="lineno"> 4919</span>  {</div>
<div class="line"><a id="l04920" name="l04920"></a><span class="lineno"> 4920</span>    qd_msgs-&gt;emplace_back(msgs_in_q.front().release()); <span class="comment">// Upgrade to shared_ptr&lt;&gt; by the way.</span></div>
<div class="line"><a id="l04921" name="l04921"></a><span class="lineno"> 4921</span>    msgs_in_q.pop();</div>
<div class="line"><a id="l04922" name="l04922"></a><span class="lineno"> 4922</span>  }</div>
<div class="line"><a id="l04923" name="l04923"></a><span class="lineno"> 4923</span>  <span class="keywordflow">while</span> (!msgs_in_q.empty());</div>
<div class="line"><a id="l04924" name="l04924"></a><span class="lineno"> 4924</span>  m_rcv_pending_msgs.erase(msgs_in_q_it); <span class="comment">// Empty -&gt; immediately erase.</span></div>
<div class="line"><a id="l04925" name="l04925"></a><span class="lineno"> 4925</span> </div>
<div class="line"><a id="l04926" name="l04926"></a><span class="lineno"> 4926</span>  FLOW_LOG_TRACE(<span class="stringliteral">&quot;Popped all [&quot;</span> &lt;&lt; qd_msgs-&gt;size() &lt;&lt; <span class="stringliteral">&quot;] cached in-message from queue.&quot;</span>);</div>
<div class="line"><a id="l04927" name="l04927"></a><span class="lineno"> 4927</span> </div>
<div class="line"><a id="l04928" name="l04928"></a><span class="lineno"> 4928</span>  <span class="comment">// And leave m_rcv_expecting_msg_map alone: new element will stay there until undo_expect_msgs().</span></div>
<div class="line"><a id="l04929" name="l04929"></a><span class="lineno"> 4929</span> </div>
<div class="line"><a id="l04930" name="l04930"></a><span class="lineno"> 4930</span>  <span class="keywordflow">return</span> <span class="keyword">true</span>;</div>
<div class="line"><a id="l04931" name="l04931"></a><span class="lineno"> 4931</span>} <span class="comment">// Channel::expect_msgs_impl()</span></div>
<div class="line"><a id="l04932" name="l04932"></a><span class="lineno"> 4932</span> </div>
<div class="line"><a id="l04933" name="l04933"></a><span class="lineno"> 4933</span><a class="code hl_define" href="ipc__transport__structured_2src_2ipc_2transport_2struc_2sync__io_2channel_8hpp.html#a50e1bb663274c68c760263342ddfdcbc">TEMPLATE_SIO_STRUCT_CHANNEL</a></div>
<div class="line"><a id="l04934" name="l04934"></a><span class="lineno"><a class="line" href="classipc_1_1transport_1_1struc_1_1sync__io_1_1Channel.html#ac8ba5f1a26a9f3e881b4871b0f6aa990"> 4934</a></span><span class="keywordtype">bool</span> CLASS_SIO_STRUCT_CHANNEL::undo_expect_msgs(<a class="code hl_typedef" href="classipc_1_1transport_1_1struc_1_1sync__io_1_1Channel.html#aa40c3ec3f45cdfea9360f7f35b9ade3c">Msg_which_in</a> which)</div>
<div class="line"><a id="l04935" name="l04935"></a><span class="lineno"> 4935</span>{</div>
<div class="line"><a id="l04936" name="l04936"></a><span class="lineno"> 4936</span>  <span class="keywordflow">if</span> (check_phase_and_prior_error(Phase::S_LOGGED_IN, <span class="stringliteral">&quot;undo_expect_msgs()&quot;</span>))</div>
<div class="line"><a id="l04937" name="l04937"></a><span class="lineno"> 4937</span>  {</div>
<div class="line"><a id="l04938" name="l04938"></a><span class="lineno"> 4938</span>    <span class="keywordflow">return</span> <span class="keyword">false</span>;</div>
<div class="line"><a id="l04939" name="l04939"></a><span class="lineno"> 4939</span>  }</div>
<div class="line"><a id="l04940" name="l04940"></a><span class="lineno"> 4940</span>  <span class="comment">// else</span></div>
<div class="line"><a id="l04941" name="l04941"></a><span class="lineno"> 4941</span> </div>
<div class="line"><a id="l04942" name="l04942"></a><span class="lineno"> 4942</span>  <span class="keyword">const</span> <span class="keywordtype">bool</span> erased = m_rcv_expecting_msg_map.erase(which) == 1;</div>
<div class="line"><a id="l04943" name="l04943"></a><span class="lineno"> 4943</span>  <span class="keywordflow">if</span> (!erased)</div>
<div class="line"><a id="l04944" name="l04944"></a><span class="lineno"> 4944</span>  {</div>
<div class="line"><a id="l04945" name="l04945"></a><span class="lineno"> 4945</span>    FLOW_LOG_WARNING(<span class="stringliteral">&quot;struc::Channel [&quot;</span> &lt;&lt; *<span class="keyword">this</span> &lt;&lt; <span class="stringliteral">&quot;]: Attempt to erase in-message expectation &quot;</span></div>
<div class="line"><a id="l04946" name="l04946"></a><span class="lineno"> 4946</span>                     <span class="stringliteral">&quot;[&quot;</span> &lt;&lt; <span class="keywordtype">int</span>(which) &lt;&lt; <span class="stringliteral">&quot;]: Failed, as there was no such expectation registered.  &quot;</span></div>
<div class="line"><a id="l04947" name="l04947"></a><span class="lineno"> 4947</span>                     <span class="stringliteral">&quot;Their total number remains [&quot;</span> &lt;&lt; m_rcv_expecting_msg_map.size() &lt;&lt; <span class="stringliteral">&quot;].&quot;</span>);</div>
<div class="line"><a id="l04948" name="l04948"></a><span class="lineno"> 4948</span>    <span class="keywordflow">return</span> <span class="keyword">false</span>;</div>
<div class="line"><a id="l04949" name="l04949"></a><span class="lineno"> 4949</span>  }</div>
<div class="line"><a id="l04950" name="l04950"></a><span class="lineno"> 4950</span>  <span class="comment">// else</span></div>
<div class="line"><a id="l04951" name="l04951"></a><span class="lineno"> 4951</span> </div>
<div class="line"><a id="l04952" name="l04952"></a><span class="lineno"> 4952</span>  FLOW_LOG_TRACE(<span class="stringliteral">&quot;struc::Channel [&quot;</span> &lt;&lt; *<span class="keyword">this</span> &lt;&lt; <span class="stringliteral">&quot;]: Attempt to erase in-message expectation &quot;</span></div>
<div class="line"><a id="l04953" name="l04953"></a><span class="lineno"> 4953</span>                 <span class="stringliteral">&quot;[&quot;</span> &lt;&lt; <span class="keywordtype">int</span>(which) &lt;&lt; <span class="stringliteral">&quot;]: Success.  Their total number is now &quot;</span></div>
<div class="line"><a id="l04954" name="l04954"></a><span class="lineno"> 4954</span>                 <span class="stringliteral">&quot;[&quot;</span> &lt;&lt; m_rcv_expecting_msg_map.size() &lt;&lt; <span class="stringliteral">&quot;].&quot;</span>);</div>
<div class="line"><a id="l04955" name="l04955"></a><span class="lineno"> 4955</span>  <span class="keywordflow">return</span> <span class="keyword">true</span>;</div>
<div class="line"><a id="l04956" name="l04956"></a><span class="lineno"> 4956</span>} <span class="comment">// Channel::undo_expect_msgs()</span></div>
<div class="line"><a id="l04957" name="l04957"></a><span class="lineno"> 4957</span> </div>
<div class="line"><a id="l04958" name="l04958"></a><span class="lineno"> 4958</span><a class="code hl_define" href="ipc__transport__structured_2src_2ipc_2transport_2struc_2sync__io_2channel_8hpp.html#a50e1bb663274c68c760263342ddfdcbc">TEMPLATE_SIO_STRUCT_CHANNEL</a></div>
<div class="line"><a id="l04959" name="l04959"></a><span class="lineno"><a class="line" href="classipc_1_1transport_1_1struc_1_1sync__io_1_1Channel.html#a5aae7a7f907f56fa07a230eadec2fedf"> 4959</a></span><span class="keywordtype">bool</span> CLASS_SIO_STRUCT_CHANNEL::undo_expect_responses(<a class="code hl_typedef" href="classipc_1_1transport_1_1struc_1_1Channel__base.html#adcf24fa51747ed83c4b6427fbf44fecf">msg_id_out_t</a> originating_msg_id)</div>
<div class="line"><a id="l04960" name="l04960"></a><span class="lineno"> 4960</span>{</div>
<div class="line"><a id="l04961" name="l04961"></a><span class="lineno"> 4961</span>  assert((originating_msg_id != 0) &amp;&amp; <span class="stringliteral">&quot;send() would never set *id_unless_one_off = 0.&quot;</span>);</div>
<div class="line"><a id="l04962" name="l04962"></a><span class="lineno"> 4962</span> </div>
<div class="line"><a id="l04963" name="l04963"></a><span class="lineno"> 4963</span>  <span class="keywordflow">if</span> (check_phase_and_prior_error(Phase::S_LOGGED_IN, <span class="stringliteral">&quot;undo_expect_responses()&quot;</span>))</div>
<div class="line"><a id="l04964" name="l04964"></a><span class="lineno"> 4964</span>  {</div>
<div class="line"><a id="l04965" name="l04965"></a><span class="lineno"> 4965</span>    <span class="keywordflow">return</span> <span class="keyword">false</span>;</div>
<div class="line"><a id="l04966" name="l04966"></a><span class="lineno"> 4966</span>  }</div>
<div class="line"><a id="l04967" name="l04967"></a><span class="lineno"> 4967</span>  <span class="comment">// else</span></div>
<div class="line"><a id="l04968" name="l04968"></a><span class="lineno"> 4968</span> </div>
<div class="line"><a id="l04969" name="l04969"></a><span class="lineno"> 4969</span>  <span class="keyword">const</span> <span class="keywordtype">bool</span> erased = m_rcv_expecting_response_map.erase(originating_msg_id) == 1;</div>
<div class="line"><a id="l04970" name="l04970"></a><span class="lineno"> 4970</span>  <span class="keywordflow">if</span> (!erased)</div>
<div class="line"><a id="l04971" name="l04971"></a><span class="lineno"> 4971</span>  {</div>
<div class="line"><a id="l04972" name="l04972"></a><span class="lineno"> 4972</span>    FLOW_LOG_WARNING(<span class="stringliteral">&quot;struc::Channel [&quot;</span> &lt;&lt; *<span class="keyword">this</span> &lt;&lt; <span class="stringliteral">&quot;]: Attempt to erase response expectation for sent &quot;</span></div>
<div class="line"><a id="l04973" name="l04973"></a><span class="lineno"> 4973</span>                     <span class="stringliteral">&quot;message with ID [&quot;</span> &lt;&lt; originating_msg_id &lt;&lt; <span class="stringliteral">&quot;]: Failed, as there was no such &quot;</span></div>
<div class="line"><a id="l04974" name="l04974"></a><span class="lineno"> 4974</span>                     <span class="stringliteral">&quot;expectation registered.  Their total number remains &quot;</span></div>
<div class="line"><a id="l04975" name="l04975"></a><span class="lineno"> 4975</span>                     <span class="stringliteral">&quot;[&quot;</span> &lt;&lt; m_rcv_expecting_response_map.size() &lt;&lt; <span class="stringliteral">&quot;].&quot;</span>);</div>
<div class="line"><a id="l04976" name="l04976"></a><span class="lineno"> 4976</span>    <span class="keywordflow">return</span> <span class="keyword">false</span>;</div>
<div class="line"><a id="l04977" name="l04977"></a><span class="lineno"> 4977</span>  }</div>
<div class="line"><a id="l04978" name="l04978"></a><span class="lineno"> 4978</span>  <span class="comment">// else</span></div>
<div class="line"><a id="l04979" name="l04979"></a><span class="lineno"> 4979</span> </div>
<div class="line"><a id="l04980" name="l04980"></a><span class="lineno"> 4980</span>  FLOW_LOG_TRACE(<span class="stringliteral">&quot;struc::Channel [&quot;</span> &lt;&lt; *<span class="keyword">this</span> &lt;&lt; <span class="stringliteral">&quot;]: Attempt to erase response expectation for sent &quot;</span></div>
<div class="line"><a id="l04981" name="l04981"></a><span class="lineno"> 4981</span>                 <span class="stringliteral">&quot;message with ID [&quot;</span> &lt;&lt; originating_msg_id &lt;&lt; <span class="stringliteral">&quot;]: Success.  Their total number is now &quot;</span></div>
<div class="line"><a id="l04982" name="l04982"></a><span class="lineno"> 4982</span>                 <span class="stringliteral">&quot;[&quot;</span> &lt;&lt; m_rcv_expecting_response_map.size() &lt;&lt; <span class="stringliteral">&quot;].&quot;</span>);</div>
<div class="line"><a id="l04983" name="l04983"></a><span class="lineno"> 4983</span>  <span class="keywordflow">return</span> <span class="keyword">true</span>;</div>
<div class="line"><a id="l04984" name="l04984"></a><span class="lineno"> 4984</span>} <span class="comment">// Channel::undo_expect_responses()</span></div>
<div class="line"><a id="l04985" name="l04985"></a><span class="lineno"> 4985</span> </div>
<div class="line"><a id="l04986" name="l04986"></a><span class="lineno"> 4986</span><a class="code hl_define" href="ipc__transport__structured_2src_2ipc_2transport_2struc_2sync__io_2channel_8hpp.html#a50e1bb663274c68c760263342ddfdcbc">TEMPLATE_SIO_STRUCT_CHANNEL</a></div>
<div class="line"><a id="l04987" name="l04987"></a><span class="lineno"> 4987</span><span class="keyword">template</span>&lt;<span class="keyword">typename</span> On_unexpected_response_handler&gt;</div>
<div class="line"><a id="l04988" name="l04988"></a><span class="lineno"><a class="line" href="classipc_1_1transport_1_1struc_1_1sync__io_1_1Channel.html#a5c62d2a374a3a98e7fa0aef01bf8a774"> 4988</a></span><span class="keywordtype">bool</span> CLASS_SIO_STRUCT_CHANNEL::set_unexpected_response_handler(On_unexpected_response_handler&amp;&amp; on_func)</div>
<div class="line"><a id="l04989" name="l04989"></a><span class="lineno"> 4989</span>{</div>
<div class="line"><a id="l04990" name="l04990"></a><span class="lineno"> 4990</span>  <span class="keywordflow">if</span> (!m_on_unexpected_response_func_or_empty.empty())</div>
<div class="line"><a id="l04991" name="l04991"></a><span class="lineno"> 4991</span>  {</div>
<div class="line"><a id="l04992" name="l04992"></a><span class="lineno"> 4992</span>    FLOW_LOG_WARNING(<span class="stringliteral">&quot;struc::Channel [&quot;</span> &lt;&lt; *<span class="keyword">this</span> &lt;&lt; <span class="stringliteral">&quot;]: Attempt to register unexpected-response handler, &quot;</span></div>
<div class="line"><a id="l04993" name="l04993"></a><span class="lineno"> 4993</span>                     <span class="stringliteral">&quot;when one is already set.&quot;</span>);</div>
<div class="line"><a id="l04994" name="l04994"></a><span class="lineno"> 4994</span>    <span class="keywordflow">return</span> <span class="keyword">false</span>;</div>
<div class="line"><a id="l04995" name="l04995"></a><span class="lineno"> 4995</span>  }</div>
<div class="line"><a id="l04996" name="l04996"></a><span class="lineno"> 4996</span>  <span class="comment">// else</span></div>
<div class="line"><a id="l04997" name="l04997"></a><span class="lineno"> 4997</span> </div>
<div class="line"><a id="l04998" name="l04998"></a><span class="lineno"> 4998</span>  m_on_unexpected_response_func_or_empty = <a class="code hl_typedef" href="classipc_1_1transport_1_1struc_1_1sync__io_1_1Channel.html#abb3be9330a898ce542afd778d8e42a49">On_unexpected_response_func</a>(std::move(on_func));</div>
<div class="line"><a id="l04999" name="l04999"></a><span class="lineno"> 4999</span>  <span class="keywordflow">return</span> <span class="keyword">true</span>;</div>
<div class="line"><a id="l05000" name="l05000"></a><span class="lineno"> 5000</span>} <span class="comment">// Channel::set_unexpected_response_handler()</span></div>
<div class="line"><a id="l05001" name="l05001"></a><span class="lineno"> 5001</span> </div>
<div class="line"><a id="l05002" name="l05002"></a><span class="lineno"> 5002</span><a class="code hl_define" href="ipc__transport__structured_2src_2ipc_2transport_2struc_2sync__io_2channel_8hpp.html#a50e1bb663274c68c760263342ddfdcbc">TEMPLATE_SIO_STRUCT_CHANNEL</a></div>
<div class="line"><a id="l05003" name="l05003"></a><span class="lineno"><a class="line" href="classipc_1_1transport_1_1struc_1_1sync__io_1_1Channel.html#a1f226e506cc5c04584e11480426b19da"> 5003</a></span><span class="keywordtype">bool</span> CLASS_SIO_STRUCT_CHANNEL::unset_unexpected_response_handler()</div>
<div class="line"><a id="l05004" name="l05004"></a><span class="lineno"> 5004</span>{</div>
<div class="line"><a id="l05005" name="l05005"></a><span class="lineno"> 5005</span>  <span class="keywordflow">if</span> (m_on_unexpected_response_func_or_empty.empty())</div>
<div class="line"><a id="l05006" name="l05006"></a><span class="lineno"> 5006</span>  {</div>
<div class="line"><a id="l05007" name="l05007"></a><span class="lineno"> 5007</span>    FLOW_LOG_WARNING(<span class="stringliteral">&quot;struc::Channel [&quot;</span> &lt;&lt; *<span class="keyword">this</span> &lt;&lt; <span class="stringliteral">&quot;]: Attempt to unregister unexpected-response handler, &quot;</span></div>
<div class="line"><a id="l05008" name="l05008"></a><span class="lineno"> 5008</span>                     <span class="stringliteral">&quot;when one is not set.&quot;</span>);</div>
<div class="line"><a id="l05009" name="l05009"></a><span class="lineno"> 5009</span>    <span class="keywordflow">return</span> <span class="keyword">false</span>;</div>
<div class="line"><a id="l05010" name="l05010"></a><span class="lineno"> 5010</span>  }</div>
<div class="line"><a id="l05011" name="l05011"></a><span class="lineno"> 5011</span>  <span class="comment">// else</span></div>
<div class="line"><a id="l05012" name="l05012"></a><span class="lineno"> 5012</span> </div>
<div class="line"><a id="l05013" name="l05013"></a><span class="lineno"> 5013</span>  m_on_unexpected_response_func_or_empty.clear();</div>
<div class="line"><a id="l05014" name="l05014"></a><span class="lineno"> 5014</span>  <span class="keywordflow">return</span> <span class="keyword">true</span>;</div>
<div class="line"><a id="l05015" name="l05015"></a><span class="lineno"> 5015</span>} <span class="comment">// Channel::set_unexpected_response_handler()</span></div>
<div class="line"><a id="l05016" name="l05016"></a><span class="lineno"> 5016</span> </div>
<div class="line"><a id="l05017" name="l05017"></a><span class="lineno"> 5017</span><a class="code hl_define" href="ipc__transport__structured_2src_2ipc_2transport_2struc_2sync__io_2channel_8hpp.html#a50e1bb663274c68c760263342ddfdcbc">TEMPLATE_SIO_STRUCT_CHANNEL</a></div>
<div class="line"><a id="l05018" name="l05018"></a><span class="lineno"> 5018</span><span class="keyword">template</span>&lt;<span class="keyword">typename</span> On_remote_unexpected_response_handler&gt;</div>
<div class="line"><a id="l05019" name="l05019"></a><span class="lineno"><a class="line" href="classipc_1_1transport_1_1struc_1_1sync__io_1_1Channel.html#a3fda370cc97c89a62f77a6fcf639cfd7"> 5019</a></span><span class="keywordtype">bool</span> CLASS_SIO_STRUCT_CHANNEL::set_remote_unexpected_response_handler(On_remote_unexpected_response_handler&amp;&amp; on_func)</div>
<div class="line"><a id="l05020" name="l05020"></a><span class="lineno"> 5020</span>{</div>
<div class="line"><a id="l05021" name="l05021"></a><span class="lineno"> 5021</span>  <span class="keywordflow">if</span> (!m_on_remote_unexpected_response_func_or_empty.empty())</div>
<div class="line"><a id="l05022" name="l05022"></a><span class="lineno"> 5022</span>  {</div>
<div class="line"><a id="l05023" name="l05023"></a><span class="lineno"> 5023</span>    FLOW_LOG_WARNING(<span class="stringliteral">&quot;struc::Channel [&quot;</span> &lt;&lt; *<span class="keyword">this</span> &lt;&lt; <span class="stringliteral">&quot;]: Attempt to register remote-unexpected-response handler, &quot;</span></div>
<div class="line"><a id="l05024" name="l05024"></a><span class="lineno"> 5024</span>                     <span class="stringliteral">&quot;when one is already set.&quot;</span>);</div>
<div class="line"><a id="l05025" name="l05025"></a><span class="lineno"> 5025</span>    <span class="keywordflow">return</span> <span class="keyword">false</span>;</div>
<div class="line"><a id="l05026" name="l05026"></a><span class="lineno"> 5026</span>  }</div>
<div class="line"><a id="l05027" name="l05027"></a><span class="lineno"> 5027</span>  <span class="comment">// else</span></div>
<div class="line"><a id="l05028" name="l05028"></a><span class="lineno"> 5028</span> </div>
<div class="line"><a id="l05029" name="l05029"></a><span class="lineno"> 5029</span>  m_on_remote_unexpected_response_func_or_empty = <a class="code hl_typedef" href="classipc_1_1transport_1_1struc_1_1sync__io_1_1Channel.html#a86342fa9838aea7d49bbf3dd344445e2">On_remote_unexpected_response_func</a>(std::move(on_func));</div>
<div class="line"><a id="l05030" name="l05030"></a><span class="lineno"> 5030</span>  <span class="keywordflow">return</span> <span class="keyword">true</span>;</div>
<div class="line"><a id="l05031" name="l05031"></a><span class="lineno"> 5031</span>} <span class="comment">// Channel::set_remote_unexpected_response_handler()</span></div>
<div class="line"><a id="l05032" name="l05032"></a><span class="lineno"> 5032</span> </div>
<div class="line"><a id="l05033" name="l05033"></a><span class="lineno"> 5033</span><a class="code hl_define" href="ipc__transport__structured_2src_2ipc_2transport_2struc_2sync__io_2channel_8hpp.html#a50e1bb663274c68c760263342ddfdcbc">TEMPLATE_SIO_STRUCT_CHANNEL</a></div>
<div class="line"><a id="l05034" name="l05034"></a><span class="lineno"><a class="line" href="classipc_1_1transport_1_1struc_1_1sync__io_1_1Channel.html#a24382a751a2c03e00c5140c89aba2c62"> 5034</a></span><span class="keywordtype">bool</span> CLASS_SIO_STRUCT_CHANNEL::unset_remote_unexpected_response_handler()</div>
<div class="line"><a id="l05035" name="l05035"></a><span class="lineno"> 5035</span>{</div>
<div class="line"><a id="l05036" name="l05036"></a><span class="lineno"> 5036</span>  <span class="keywordflow">if</span> (m_on_remote_unexpected_response_func_or_empty.empty())</div>
<div class="line"><a id="l05037" name="l05037"></a><span class="lineno"> 5037</span>  {</div>
<div class="line"><a id="l05038" name="l05038"></a><span class="lineno"> 5038</span>    FLOW_LOG_WARNING(<span class="stringliteral">&quot;struc::Channel [&quot;</span> &lt;&lt; *<span class="keyword">this</span> &lt;&lt; <span class="stringliteral">&quot;]: Attempt to unregister remote-unexpected-response handler, &quot;</span></div>
<div class="line"><a id="l05039" name="l05039"></a><span class="lineno"> 5039</span>                     <span class="stringliteral">&quot;when one is not set.&quot;</span>);</div>
<div class="line"><a id="l05040" name="l05040"></a><span class="lineno"> 5040</span>    <span class="keywordflow">return</span> <span class="keyword">false</span>;</div>
<div class="line"><a id="l05041" name="l05041"></a><span class="lineno"> 5041</span>  }</div>
<div class="line"><a id="l05042" name="l05042"></a><span class="lineno"> 5042</span>  <span class="comment">// else</span></div>
<div class="line"><a id="l05043" name="l05043"></a><span class="lineno"> 5043</span> </div>
<div class="line"><a id="l05044" name="l05044"></a><span class="lineno"> 5044</span>  m_on_remote_unexpected_response_func_or_empty.clear();</div>
<div class="line"><a id="l05045" name="l05045"></a><span class="lineno"> 5045</span>  <span class="keywordflow">return</span> <span class="keyword">true</span>;</div>
<div class="line"><a id="l05046" name="l05046"></a><span class="lineno"> 5046</span>} <span class="comment">// Channel::set_remote_unexpected_response_handler()</span></div>
<div class="line"><a id="l05047" name="l05047"></a><span class="lineno"> 5047</span> </div>
<div class="line"><a id="l05048" name="l05048"></a><span class="lineno"> 5048</span><a class="code hl_define" href="ipc__transport__structured_2src_2ipc_2transport_2struc_2sync__io_2channel_8hpp.html#a50e1bb663274c68c760263342ddfdcbc">TEMPLATE_SIO_STRUCT_CHANNEL</a></div>
<div class="line"><a id="l05049" name="l05049"></a><span class="lineno"><a class="line" href="classipc_1_1transport_1_1struc_1_1sync__io_1_1Channel.html#a759e1993bc61abb41380219b254ca410"> 5049</a></span><span class="keyword">const</span> <span class="keyword">typename</span> CLASS_SIO_STRUCT_CHANNEL::Owned_channel&amp; CLASS_SIO_STRUCT_CHANNEL::owned_channel()<span class="keyword"> const</span></div>
<div class="line"><a id="l05050" name="l05050"></a><span class="lineno"> 5050</span><span class="keyword"></span>{</div>
<div class="line"><a id="l05051" name="l05051"></a><span class="lineno"> 5051</span>  <span class="keywordflow">return</span> m_channel;</div>
<div class="line"><a id="l05052" name="l05052"></a><span class="lineno"> 5052</span>}</div>
<div class="line"><a id="l05053" name="l05053"></a><span class="lineno"> 5053</span> </div>
<div class="line"><a id="l05054" name="l05054"></a><span class="lineno"> 5054</span><a class="code hl_define" href="ipc__transport__structured_2src_2ipc_2transport_2struc_2sync__io_2channel_8hpp.html#a50e1bb663274c68c760263342ddfdcbc">TEMPLATE_SIO_STRUCT_CHANNEL</a></div>
<div class="line"><a id="l05055" name="l05055"></a><span class="lineno"><a class="line" href="classipc_1_1transport_1_1struc_1_1sync__io_1_1Channel.html#a9d97a5900bd517596b763db2d6b27b45"> 5055</a></span><span class="keyword">typename</span> CLASS_SIO_STRUCT_CHANNEL::Owned_channel* CLASS_SIO_STRUCT_CHANNEL::owned_channel_mutable()</div>
<div class="line"><a id="l05056" name="l05056"></a><span class="lineno"> 5056</span>{</div>
<div class="line"><a id="l05057" name="l05057"></a><span class="lineno"> 5057</span>  <span class="keywordflow">return</span> &amp;m_channel;</div>
<div class="line"><a id="l05058" name="l05058"></a><span class="lineno"> 5058</span>}</div>
<div class="line"><a id="l05059" name="l05059"></a><span class="lineno"> 5059</span> </div>
<div class="line"><a id="l05060" name="l05060"></a><span class="lineno"> 5060</span><a class="code hl_define" href="ipc__transport__structured_2src_2ipc_2transport_2struc_2sync__io_2channel_8hpp.html#a50e1bb663274c68c760263342ddfdcbc">TEMPLATE_SIO_STRUCT_CHANNEL</a></div>
<div class="line"><a id="l05061" name="l05061"></a><span class="lineno"><a class="line" href="classipc_1_1transport_1_1struc_1_1sync__io_1_1Channel.html#a021bb07a76c54837619c7a91dbd5de03"> 5061</a></span><span class="keyword">const</span> <a class="code hl_typedef" href="namespaceipc_1_1transport_1_1struc.html#a6751c05fb6582a34c7c47ac470c4a48b">Session_token</a>&amp; CLASS_SIO_STRUCT_CHANNEL::session_token()<span class="keyword"> const</span></div>
<div class="line"><a id="l05062" name="l05062"></a><span class="lineno"> 5062</span><span class="keyword"></span>{</div>
<div class="line"><a id="l05063" name="l05063"></a><span class="lineno"> 5063</span>  <span class="keywordflow">if</span> (check_phase_and_prior_error(Phase::S_LOGGED_IN, <span class="stringliteral">&quot;session_token()&quot;</span>))</div>
<div class="line"><a id="l05064" name="l05064"></a><span class="lineno"> 5064</span>  {</div>
<div class="line"><a id="l05065" name="l05065"></a><span class="lineno"> 5065</span>    <span class="keywordflow">return</span> <a class="code hl_variable" href="namespaceipc_1_1transport_1_1struc.html#ad556d20a2aa2d52b83c7afb73951d47d">NULL_SESSION_TOKEN</a>;</div>
<div class="line"><a id="l05066" name="l05066"></a><span class="lineno"> 5066</span>  }</div>
<div class="line"><a id="l05067" name="l05067"></a><span class="lineno"> 5067</span>  <span class="comment">// else</span></div>
<div class="line"><a id="l05068" name="l05068"></a><span class="lineno"> 5068</span> </div>
<div class="line"><a id="l05069" name="l05069"></a><span class="lineno"> 5069</span>  <span class="keywordflow">return</span> m_session_token;</div>
<div class="line"><a id="l05070" name="l05070"></a><span class="lineno"> 5070</span>} <span class="comment">// Channel::session_token()</span></div>
<div class="line"><a id="l05071" name="l05071"></a><span class="lineno"> 5071</span><span class="comment"></span> </div>
<div class="line"><a id="l05072" name="l05072"></a><span class="lineno"> 5072</span><span class="comment">/// @cond</span></div>
<div class="line"><a id="l05073" name="l05073"></a><span class="lineno"> 5073</span><span class="comment"></span><span class="comment">// -^- Doxygen, please ignore the following.  It gets confused by something here and gives warnings.</span></div>
<div class="line"><a id="l05074" name="l05074"></a><span class="lineno"> 5074</span> </div>
<div class="line"><a id="l05075" name="l05075"></a><span class="lineno"> 5075</span><a class="code hl_define" href="ipc__transport__structured_2src_2ipc_2transport_2struc_2sync__io_2channel_8hpp.html#a50e1bb663274c68c760263342ddfdcbc">TEMPLATE_SIO_STRUCT_CHANNEL</a></div>
<div class="line"><a id="l05076" name="l05076"></a><span class="lineno"> 5076</span>std::ostream&amp; <a class="code hl_function" href="namespaceipc_1_1transport_1_1struc.html#ae272f248d74db0486c4d9411715db15d">operator&lt;&lt;</a>(std::ostream&amp; os, <span class="keyword">const</span> <a class="code hl_define" href="ipc__transport__structured_2src_2ipc_2transport_2struc_2sync__io_2channel_8hpp.html#aefc68934c89912e7b5d0706bdb2be6e5">CLASS_SIO_STRUCT_CHANNEL</a>&amp; val)</div>
<div class="line"><a id="l05077" name="l05077"></a><span class="lineno"> 5077</span>{</div>
<div class="line"><a id="l05078" name="l05078"></a><span class="lineno"> 5078</span>  <span class="keywordflow">return</span> os &lt;&lt; <span class="stringliteral">&quot;SIO[owned_channel [&quot;</span> &lt;&lt; val.owned_channel() &lt;&lt; <span class="stringliteral">&quot;]]@&quot;</span> &lt;&lt; <span class="keyword">static_cast&lt;</span><span class="keyword">const </span><span class="keywordtype">void</span>*<span class="keyword">&gt;</span>(&amp;val);</div>
<div class="line"><a id="l05079" name="l05079"></a><span class="lineno"> 5079</span>}</div>
<div class="line"><a id="l05080" name="l05080"></a><span class="lineno"> 5080</span> </div>
<div class="line"><a id="l05081" name="l05081"></a><span class="lineno"> 5081</span><span class="comment">// -v- Doxygen, please stop ignoring.</span><span class="comment"></span></div>
<div class="line"><a id="l05082" name="l05082"></a><span class="lineno"> 5082</span><span class="comment">/// @endcond</span></div>
<div class="line"><a id="l05083" name="l05083"></a><span class="lineno"> 5083</span><span class="comment"></span> </div>
<div class="line"><a id="l05084" name="l05084"></a><span class="lineno"> 5084</span><span class="preprocessor">#undef CLASS_SIO_STRUCT_CHANNEL</span></div>
<div class="line"><a id="l05085" name="l05085"></a><span class="lineno"> 5085</span><span class="preprocessor">#undef TEMPLATE_SIO_STRUCT_CHANNEL</span></div>
<div class="line"><a id="l05086" name="l05086"></a><span class="lineno"> 5086</span> </div>
<div class="line"><a id="l05087" name="l05087"></a><span class="lineno"> 5087</span>} <span class="comment">// namespace ipc::transport::struc::sync_io</span></div>
<div class="ttc" id="achannel__base_8hpp_html"><div class="ttname"><a href="channel__base_8hpp.html">channel_base.hpp</a></div></div>
<div class="ttc" id="aclassipc_1_1transport_1_1Null__peer_html"><div class="ttname"><a href="classipc_1_1transport_1_1Null__peer.html">ipc::transport::Null_peer</a></div><div class="ttdoc">Dummy type for use as a template param to Channel when either the blobs pipe or handles pipe is disab...</div><div class="ttdef"><b>Definition:</b> <a href="ipc__core_2src_2ipc_2transport_2channel_8hpp_source.html#l00999">channel.hpp:1000</a></div></div>
<div class="ttc" id="aclassipc_1_1transport_1_1Protocol__negotiator_html"><div class="ttname"><a href="classipc_1_1transport_1_1Protocol__negotiator.html">ipc::transport::Protocol_negotiator</a></div><div class="ttdoc">A simple state machine that, assuming the opposide side of a comm pathway uses an equivalent state ma...</div><div class="ttdef"><b>Definition:</b> <a href="protocol__negotiator_8hpp_source.html#l00189">protocol_negotiator.hpp:191</a></div></div>
<div class="ttc" id="aclassipc_1_1transport_1_1Protocol__negotiator_html_a35fb3885d39f11d0c1f7860e64194592"><div class="ttname"><a href="classipc_1_1transport_1_1Protocol__negotiator.html#a35fb3885d39f11d0c1f7860e64194592">ipc::transport::Protocol_negotiator::proto_ver_t</a></div><div class="ttdeci">int16_t proto_ver_t</div><div class="ttdoc">Type sufficient to store a protocol version; positive values identify newer versions of a protocol; w...</div><div class="ttdef"><b>Definition:</b> <a href="protocol__negotiator_8hpp_source.html#l00199">protocol_negotiator.hpp:199</a></div></div>
<div class="ttc" id="aclassipc_1_1transport_1_1Protocol__negotiator_html_aa7e47f4f6a700aeaa9600a5426a17292"><div class="ttname"><a href="classipc_1_1transport_1_1Protocol__negotiator.html#aa7e47f4f6a700aeaa9600a5426a17292">ipc::transport::Protocol_negotiator::S_VER_UNKNOWN</a></div><div class="ttdeci">static constexpr proto_ver_t S_VER_UNKNOWN</div><div class="ttdoc">A proto_ver_t value, namely a negative one, which is a reserved value indicating &quot;unknown version&quot;; i...</div><div class="ttdef"><b>Definition:</b> <a href="protocol__negotiator_8hpp_source.html#l00215">protocol_negotiator.hpp:215</a></div></div>
<div class="ttc" id="aclassipc_1_1transport_1_1struc_1_1Channel__base_html"><div class="ttname"><a href="classipc_1_1transport_1_1struc_1_1Channel__base.html">ipc::transport::struc::Channel_base</a></div><div class="ttdoc">Channel base that contains non-parameterized public items such as tag types and constants.</div><div class="ttdef"><b>Definition:</b> <a href="channel__base_8hpp_source.html#l00036">channel_base.hpp:37</a></div></div>
<div class="ttc" id="aclassipc_1_1transport_1_1struc_1_1Channel__base_html_adcf24fa51747ed83c4b6427fbf44fecf"><div class="ttname"><a href="classipc_1_1transport_1_1struc_1_1Channel__base.html#adcf24fa51747ed83c4b6427fbf44fecf">ipc::transport::struc::Channel_base::msg_id_out_t</a></div><div class="ttdeci">msg_id_t msg_id_out_t</div><div class="ttdoc">Clarifying short-hand for outgoing-message IDs.</div><div class="ttdef"><b>Definition:</b> <a href="channel__base_8hpp_source.html#l00045">channel_base.hpp:45</a></div></div>
<div class="ttc" id="aclassipc_1_1transport_1_1struc_1_1Channel_html"><div class="ttname"><a href="classipc_1_1transport_1_1struc_1_1Channel.html">ipc::transport::struc::Channel</a></div><div class="ttdoc">Owning and wrapping a pre-connected transport::Channel peer (an endpoint of an established channel ov...</div><div class="ttdef"><b>Definition:</b> <a href="ipc__transport__structured_2src_2ipc_2transport_2struc_2channel_8hpp_source.html#l00586">channel.hpp:589</a></div></div>
<div class="ttc" id="aclassipc_1_1transport_1_1struc_1_1Heap__fixed__builder_html"><div class="ttname"><a href="classipc_1_1transport_1_1struc_1_1Heap__fixed__builder.html">ipc::transport::struc::Heap_fixed_builder</a></div><div class="ttdoc">Implements Struct_builder concept by straightforwardly allocating fixed-size segments on-demand in th...</div><div class="ttdef"><b>Definition:</b> <a href="heap__serializer_8hpp_source.html#l00130">heap_serializer.hpp:132</a></div></div>
<div class="ttc" id="aclassipc_1_1transport_1_1struc_1_1Heap__fixed__builder_html_a0c054e351753ce326620aa1dec12d923"><div class="ttname"><a href="classipc_1_1transport_1_1struc_1_1Heap__fixed__builder.html#a0c054e351753ce326620aa1dec12d923">ipc::transport::struc::Heap_fixed_builder::payload_msg_builder</a></div><div class="ttdeci">Capnp_msg_builder_interface * payload_msg_builder()</div><div class="ttdoc">Implements concept API.</div><div class="ttdef"><b>Definition:</b> <a href="heap__serializer_8cpp_source.html#l00065">heap_serializer.cpp:65</a></div></div>
<div class="ttc" id="aclassipc_1_1transport_1_1struc_1_1Msg__in__impl_html"><div class="ttname"><a href="classipc_1_1transport_1_1struc_1_1Msg__in__impl.html">ipc::transport::struc::Msg_in_impl</a></div><div class="ttdoc">Internally used (data-free) addendum on-top of Msg_in which makes the protected API public instead.</div><div class="ttdef"><b>Definition:</b> <a href="msg__impl_8hpp_source.html#l00078">msg_impl.hpp:79</a></div></div>
<div class="ttc" id="aclassipc_1_1transport_1_1struc_1_1Msg__in__impl_html_a0cca042534b3ebee0a90e2c6d7c1c7ca"><div class="ttname"><a href="classipc_1_1transport_1_1struc_1_1Msg__in__impl.html#a0cca042534b3ebee0a90e2c6d7c1c7ca">ipc::transport::struc::Msg_in_impl::originating_msg_id_or_none</a></div><div class="ttdeci">msg_id_t originating_msg_id_or_none() const</div><div class="ttdoc">See super-class.</div><div class="ttdef"><b>Definition:</b> <a href="msg__impl_8hpp_source.html#l00228">msg_impl.hpp:228</a></div></div>
<div class="ttc" id="aclassipc_1_1transport_1_1struc_1_1Msg__in__impl_html_a1a57abfeb8dc53f43d20cd0a8bb7def7"><div class="ttname"><a href="classipc_1_1transport_1_1struc_1_1Msg__in__impl.html#a1a57abfeb8dc53f43d20cd0a8bb7def7">ipc::transport::struc::Msg_in_impl::internal_msg_body_root</a></div><div class="ttdeci">Internal_msg_body_reader internal_msg_body_root() const</div><div class="ttdoc">See super-class.</div><div class="ttdef"><b>Definition:</b> <a href="msg__impl_8hpp_source.html#l00235">msg_impl.hpp:235</a></div></div>
<div class="ttc" id="aclassipc_1_1transport_1_1struc_1_1Msg__in_html"><div class="ttname"><a href="classipc_1_1transport_1_1struc_1_1Msg__in.html">ipc::transport::struc::Msg_in</a></div><div class="ttdoc">A structured in-message instance suitable as received and emittable (to user) by struc::Channel.</div><div class="ttdef"><b>Definition:</b> <a href="msg_8hpp_source.html#l00545">msg.hpp:547</a></div></div>
<div class="ttc" id="aclassipc_1_1transport_1_1struc_1_1Msg__mdt__out_html"><div class="ttname"><a href="classipc_1_1transport_1_1struc_1_1Msg__mdt__out.html">ipc::transport::struc::Msg_mdt_out</a></div><div class="ttdoc">Internally used (data-free) addendum on-top of Msg_out; really an alias to Msg_out&lt;schema::detail::St...</div><div class="ttdef"><b>Definition:</b> <a href="msg__mdt__out_8hpp_source.html#l00050">msg_mdt_out.hpp:52</a></div></div>
<div class="ttc" id="aclassipc_1_1transport_1_1struc_1_1Msg__mdt__out_html_a1541fa2c6343cbcddf3feac9fcf67c46"><div class="ttname"><a href="classipc_1_1transport_1_1struc_1_1Msg__mdt__out.html#a1541fa2c6343cbcddf3feac9fcf67c46">ipc::transport::struc::Msg_mdt_out::internal_msg_body_root</a></div><div class="ttdeci">Internal_msg_body_builder internal_msg_body_root()</div><div class="ttdoc">Returns a builder for the internal-message root; to be called only if id_or_none == 0 in ctor.</div><div class="ttdef"><b>Definition:</b> <a href="msg__mdt__out_8hpp_source.html#l00193">msg_mdt_out.hpp:193</a></div></div>
<div class="ttc" id="aclassipc_1_1transport_1_1struc_1_1Msg__mdt__out_html_a267d8cad7e43fa969c09ae44cf7bafec"><div class="ttname"><a href="classipc_1_1transport_1_1struc_1_1Msg__mdt__out.html#a267d8cad7e43fa969c09ae44cf7bafec">ipc::transport::struc::Msg_mdt_out::emit_serialization</a></div><div class="ttdeci">flow::util::Blob * emit_serialization(const typename Base::Builder::Session &amp;session, Error_code *err_code) const</div><div class="ttdoc">Returns the serialization in the form of a sequence of 1 Blob.</div><div class="ttdef"><b>Definition:</b> <a href="msg__mdt__out_8hpp_source.html#l00206">msg_mdt_out.hpp:206</a></div></div>
<div class="ttc" id="aclassipc_1_1transport_1_1struc_1_1Msg__mdt__out_html_a4dae089f324bbdf98d838ddc70abdc9e"><div class="ttname"><a href="classipc_1_1transport_1_1struc_1_1Msg__mdt__out.html#a4dae089f324bbdf98d838ddc70abdc9e">ipc::transport::struc::Msg_mdt_out::body_root</a></div><div class="ttdeci">const Body_builder * body_root() const</div><div class="ttdoc">Forwards to Msg_out::body_root() (const overload).</div><div class="ttdef"><b>Definition:</b> <a href="msg__mdt__out_8hpp_source.html#l00200">msg_mdt_out.hpp:200</a></div></div>
<div class="ttc" id="aclassipc_1_1transport_1_1struc_1_1Msg__out__impl_html"><div class="ttname"><a href="classipc_1_1transport_1_1struc_1_1Msg__out__impl.html">ipc::transport::struc::Msg_out_impl</a></div><div class="ttdoc">Internally used (data-free) addendum on-top of Msg_out which makes the protected API public instead.</div><div class="ttdef"><b>Definition:</b> <a href="msg__impl_8hpp_source.html#l00040">msg_impl.hpp:41</a></div></div>
<div class="ttc" id="aclassipc_1_1transport_1_1struc_1_1Msg__out__impl_html_a80de3b0b3783c53d06f0fac44248405c"><div class="ttname"><a href="classipc_1_1transport_1_1struc_1_1Msg__out__impl.html#a80de3b0b3783c53d06f0fac44248405c">ipc::transport::struc::Msg_out_impl::emit_serialization</a></div><div class="ttdeci">void emit_serialization(Segment_ptrs *target_blobs, const typename Base::Builder::Session &amp;session, Error_code *err_code) const</div><div class="ttdoc">See super-class.</div><div class="ttdef"><b>Definition:</b> <a href="msg__impl_8hpp_source.html#l00172">msg_impl.hpp:172</a></div></div>
<div class="ttc" id="aclassipc_1_1transport_1_1struc_1_1Msg__out__impl_html_a98fdfc10c77d95b8d9817403168a6282"><div class="ttname"><a href="classipc_1_1transport_1_1struc_1_1Msg__out__impl.html#a98fdfc10c77d95b8d9817403168a6282">ipc::transport::struc::Msg_out_impl::n_serialization_segments</a></div><div class="ttdeci">size_t n_serialization_segments() const</div><div class="ttdoc">See super-class.</div><div class="ttdef"><b>Definition:</b> <a href="msg__impl_8hpp_source.html#l00180">msg_impl.hpp:180</a></div></div>
<div class="ttc" id="aclassipc_1_1transport_1_1struc_1_1Msg__out_html"><div class="ttname"><a href="classipc_1_1transport_1_1struc_1_1Msg__out.html">ipc::transport::struc::Msg_out</a></div><div class="ttdoc">A structured out-message suitable to be sent via struc::Channel::send() (et al).</div><div class="ttdef"><b>Definition:</b> <a href="msg_8hpp_source.html#l00153">msg.hpp:154</a></div></div>
<div class="ttc" id="aclassipc_1_1transport_1_1struc_1_1Msg__out_html_a9894ad7ec2a46641c4b9b86664d0d465"><div class="ttname"><a href="classipc_1_1transport_1_1struc_1_1Msg__out.html#a9894ad7ec2a46641c4b9b86664d0d465">ipc::transport::struc::Msg_out::body_root</a></div><div class="ttdeci">Body_builder * body_root()</div><div class="ttdoc">The Body root capnp-generated mutator object.</div><div class="ttdef"><b>Definition:</b> <a href="msg_8hpp_source.html#l01018">msg.hpp:1018</a></div></div>
<div class="ttc" id="aclassipc_1_1transport_1_1struc_1_1Msg__out_html_aced8ef8237617c74aaf06832d1385fed"><div class="ttname"><a href="classipc_1_1transport_1_1struc_1_1Msg__out.html#aced8ef8237617c74aaf06832d1385fed">ipc::transport::struc::Msg_out::store_native_handle_or_null</a></div><div class="ttdeci">void store_native_handle_or_null(Native_handle &amp;&amp;native_handle_or_null)</div><div class="ttdoc">Store the Native_handle (potentially .null(), meaning none) in this out-message; no-ops if the same ....</div><div class="ttdef"><b>Definition:</b> <a href="msg_8hpp_source.html#l01038">msg.hpp:1038</a></div></div>
<div class="ttc" id="aclassipc_1_1transport_1_1struc_1_1Msg__out_html_ae033461f1404be60262033bafcfaccba"><div class="ttname"><a href="classipc_1_1transport_1_1struc_1_1Msg__out.html#ae033461f1404be60262033bafcfaccba">ipc::transport::struc::Msg_out::native_handle_or_null</a></div><div class="ttdeci">Native_handle native_handle_or_null() const</div><div class="ttdoc">Returns whatever was the last word according to store_native_handle_or_null().</div><div class="ttdef"><b>Definition:</b> <a href="msg_8hpp_source.html#l01053">msg.hpp:1053</a></div></div>
<div class="ttc" id="aclassipc_1_1transport_1_1struc_1_1sync__io_1_1Channel_html"><div class="ttname"><a href="classipc_1_1transport_1_1struc_1_1sync__io_1_1Channel.html">ipc::transport::struc::sync_io::Channel</a></div><div class="ttdoc">sync_io-pattern counterpart to async-I/O-pattern transport::struc::Channel.</div><div class="ttdef"><b>Definition:</b> <a href="ipc__transport__structured_2src_2ipc_2transport_2struc_2sync__io_2channel_8hpp_source.html#l00322">channel.hpp:326</a></div></div>
<div class="ttc" id="aclassipc_1_1transport_1_1struc_1_1sync__io_1_1Channel_html_a021bb07a76c54837619c7a91dbd5de03"><div class="ttname"><a href="classipc_1_1transport_1_1struc_1_1sync__io_1_1Channel.html#a021bb07a76c54837619c7a91dbd5de03">ipc::transport::struc::sync_io::Channel::session_token</a></div><div class="ttdeci">const Session_token &amp; session_token() const</div><div class="ttdoc">See Async_io_obj counterpart.</div><div class="ttdef"><b>Definition:</b> <a href="ipc__transport__structured_2src_2ipc_2transport_2struc_2sync__io_2channel_8hpp_source.html#l05061">channel.hpp:5061</a></div></div>
<div class="ttc" id="aclassipc_1_1transport_1_1struc_1_1sync__io_1_1Channel_html_a05207484f4183cafebfe2c0681bd3332"><div class="ttname"><a href="classipc_1_1transport_1_1struc_1_1sync__io_1_1Channel.html#a05207484f4183cafebfe2c0681bd3332">ipc::transport::struc::sync_io::Channel::rcv_on_async_read_proto_neg_msg</a></div><div class="ttdeci">void rcv_on_async_read_proto_neg_msg(Msg_in_pipe *pipe, Error_code err_code, size_t sz)</div><div class="ttdoc">To execute upon completing an m_channel.async_receive_*() of the expected protocol-negotiation messag...</div><div class="ttdef"><b>Definition:</b> <a href="ipc__transport__structured_2src_2ipc_2transport_2struc_2sync__io_2channel_8hpp_source.html#l03236">channel.hpp:3236</a></div></div>
<div class="ttc" id="aclassipc_1_1transport_1_1struc_1_1sync__io_1_1Channel_html_a0550bcab7578fcd9aa90a4add39eb3c7"><div class="ttname"><a href="classipc_1_1transport_1_1struc_1_1sync__io_1_1Channel.html#a0550bcab7578fcd9aa90a4add39eb3c7">ipc::transport::struc::sync_io::Channel::send_core</a></div><div class="ttdeci">bool send_core(const Msg_mdt_out &amp;mdt, const Msg_out_impl *msg, Error_code *err_code_or_ignore)</div><div class="ttdoc">Core of send() or internal-message-send: Serializes the given structured out-messages (metadata out-m...</div><div class="ttdef"><b>Definition:</b> <a href="ipc__transport__structured_2src_2ipc_2transport_2struc_2sync__io_2channel_8hpp_source.html#l04352">channel.hpp:4352</a></div></div>
<div class="ttc" id="aclassipc_1_1transport_1_1struc_1_1sync__io_1_1Channel_html_a072fb8667ba55ff69230fd48d400ee88"><div class="ttname"><a href="classipc_1_1transport_1_1struc_1_1sync__io_1_1Channel.html#a072fb8667ba55ff69230fd48d400ee88">ipc::transport::struc::sync_io::Channel::m_rcv_expecting_msg_map</a></div><div class="ttdeci">Expecting_msg_map m_rcv_expecting_msg_map</div><div class="ttdoc">Map storing current policy for expecting non-response messages.</div><div class="ttdef"><b>Definition:</b> <a href="ipc__transport__structured_2src_2ipc_2transport_2struc_2sync__io_2channel_8hpp_source.html#l02007">channel.hpp:2007</a></div></div>
<div class="ttc" id="aclassipc_1_1transport_1_1struc_1_1sync__io_1_1Channel_html_a0986d9820ae3a1203014d94c193b4ca4"><div class="ttname"><a href="classipc_1_1transport_1_1struc_1_1sync__io_1_1Channel.html#a0986d9820ae3a1203014d94c193b4ca4">ipc::transport::struc::sync_io::Channel::m_on_unexpected_response_func_or_empty</a></div><div class="ttdeci">On_unexpected_response_func m_on_unexpected_response_func_or_empty</div><div class="ttdoc">See set_unexpected_response_handler().</div><div class="ttdef"><b>Definition:</b> <a href="ipc__transport__structured_2src_2ipc_2transport_2struc_2sync__io_2channel_8hpp_source.html#l01925">channel.hpp:1925</a></div></div>
<div class="ttc" id="aclassipc_1_1transport_1_1struc_1_1sync__io_1_1Channel_html_a0c00bab2dad604dde176c4190553915c"><div class="ttname"><a href="classipc_1_1transport_1_1struc_1_1sync__io_1_1Channel.html#a0c00bab2dad604dde176c4190553915c">ipc::transport::struc::sync_io::Channel::start_and_poll</a></div><div class="ttdeci">bool start_and_poll(Task_err &amp;&amp;on_err_func)</div><div class="ttdoc">Permanently memorizes the incoming-direction on-error handler, thus authorizing the emission of any i...</div><div class="ttdef"><b>Definition:</b> <a href="ipc__transport__structured_2src_2ipc_2transport_2struc_2sync__io_2channel_8hpp_source.html#l02521">channel.hpp:2521</a></div></div>
<div class="ttc" id="aclassipc_1_1transport_1_1struc_1_1sync__io_1_1Channel_html_a0dc388e18b0fc0fa2d8ad0a6953fb039"><div class="ttname"><a href="classipc_1_1transport_1_1struc_1_1sync__io_1_1Channel.html#a0dc388e18b0fc0fa2d8ad0a6953fb039">ipc::transport::struc::sync_io::Channel::send</a></div><div class="ttdeci">bool send(const Msg_out &amp;msg, const Msg_in *originating_msg_or_null=0, Error_code *err_code=0)</div><div class="ttdoc">See Async_io_obj counterpart.</div><div class="ttdef"><b>Definition:</b> <a href="ipc__transport__structured_2src_2ipc_2transport_2struc_2sync__io_2channel_8hpp_source.html#l04169">channel.hpp:4169</a></div></div>
<div class="ttc" id="aclassipc_1_1transport_1_1struc_1_1sync__io_1_1Channel_html_a1218e59c91d08758cd997d77913abd5a"><div class="ttname"><a href="classipc_1_1transport_1_1struc_1_1sync__io_1_1Channel.html#a1218e59c91d08758cd997d77913abd5a">ipc::transport::struc::sync_io::Channel::m_rcv_reassembly_q</a></div><div class="ttdeci">std::optional&lt; Reassembly_q &gt; m_rcv_reassembly_q</div><div class="ttdoc">When Owned_channel::S_HAS_2_PIPES, stores the reassembly queue of in-messages to feed into m_rcv_pend...</div><div class="ttdef"><b>Definition:</b> <a href="ipc__transport__structured_2src_2ipc_2transport_2struc_2sync__io_2channel_8hpp_source.html#l02047">channel.hpp:2047</a></div></div>
<div class="ttc" id="aclassipc_1_1transport_1_1struc_1_1sync__io_1_1Channel_html_a126c0d7ee5fcab20dc8c87884fdd7597"><div class="ttname"><a href="classipc_1_1transport_1_1struc_1_1sync__io_1_1Channel.html#a126c0d7ee5fcab20dc8c87884fdd7597">ipc::transport::struc::sync_io::Channel::handlers_post</a></div><div class="ttdeci">void handlers_post(util::String_view context, Task &amp;&amp;handler)</div><div class="ttdoc">Record handler to invoke in handlers_poll() soon.</div><div class="ttdef"><b>Definition:</b> <a href="ipc__transport__structured_2src_2ipc_2transport_2struc_2sync__io_2channel_8hpp_source.html#l03603">channel.hpp:3603</a></div></div>
<div class="ttc" id="aclassipc_1_1transport_1_1struc_1_1sync__io_1_1Channel_html_a134966e02297d141b9e6d5e0d2ca3a7b"><div class="ttname"><a href="classipc_1_1transport_1_1struc_1_1sync__io_1_1Channel.html#a134966e02297d141b9e6d5e0d2ca3a7b">ipc::transport::struc::sync_io::Channel::rcv_struct_new_msg_in_is_next_expected</a></div><div class="ttdeci">bool rcv_struct_new_msg_in_is_next_expected(Msg_in_ptr_uniq &amp;&amp;msg_in)</div><div class="ttdoc">Helper from rcv_struct_new_msg_in() (possibly indirectly): the case where the in-message's session-to...</div><div class="ttdef"><b>Definition:</b> <a href="ipc__transport__structured_2src_2ipc_2transport_2struc_2sync__io_2channel_8hpp_source.html#l03903">channel.hpp:3903</a></div></div>
<div class="ttc" id="aclassipc_1_1transport_1_1struc_1_1sync__io_1_1Channel_html_a14a7166b2f8c117ce6ddafe943d036fa"><div class="ttname"><a href="classipc_1_1transport_1_1struc_1_1sync__io_1_1Channel.html#a14a7166b2f8c117ce6ddafe943d036fa">ipc::transport::struc::sync_io::Channel::Reader_config</a></div><div class="ttdeci">Struct_reader_config Reader_config</div><div class="ttdoc">See Async_io_obj counterpart.</div><div class="ttdef"><b>Definition:</b> <a href="ipc__transport__structured_2src_2ipc_2transport_2struc_2sync__io_2channel_8hpp_source.html#l00346">channel.hpp:346</a></div></div>
<div class="ttc" id="aclassipc_1_1transport_1_1struc_1_1sync__io_1_1Channel_html_a1572a1b1cb4a72ea57f7841a5e78759b"><div class="ttname"><a href="classipc_1_1transport_1_1struc_1_1sync__io_1_1Channel.html#a1572a1b1cb4a72ea57f7841a5e78759b">ipc::transport::struc::sync_io::Channel::Msg_which</a></div><div class="ttdeci">typename Message_body::Which Msg_which</div><div class="ttdoc">See Async_io_obj counterpart.</div><div class="ttdef"><b>Definition:</b> <a href="ipc__transport__structured_2src_2ipc_2transport_2struc_2sync__io_2channel_8hpp_source.html#l00352">channel.hpp:352</a></div></div>
<div class="ttc" id="aclassipc_1_1transport_1_1struc_1_1sync__io_1_1Channel_html_a1f226e506cc5c04584e11480426b19da"><div class="ttname"><a href="classipc_1_1transport_1_1struc_1_1sync__io_1_1Channel.html#a1f226e506cc5c04584e11480426b19da">ipc::transport::struc::sync_io::Channel::unset_unexpected_response_handler</a></div><div class="ttdeci">bool unset_unexpected_response_handler()</div><div class="ttdoc">See Async_io_obj counterpart.</div><div class="ttdef"><b>Definition:</b> <a href="ipc__transport__structured_2src_2ipc_2transport_2struc_2sync__io_2channel_8hpp_source.html#l05003">channel.hpp:5003</a></div></div>
<div class="ttc" id="aclassipc_1_1transport_1_1struc_1_1sync__io_1_1Channel_html_a24382a751a2c03e00c5140c89aba2c62"><div class="ttname"><a href="classipc_1_1transport_1_1struc_1_1sync__io_1_1Channel.html#a24382a751a2c03e00c5140c89aba2c62">ipc::transport::struc::sync_io::Channel::unset_remote_unexpected_response_handler</a></div><div class="ttdeci">bool unset_remote_unexpected_response_handler()</div><div class="ttdoc">See Async_io_obj counterpart.</div><div class="ttdef"><b>Definition:</b> <a href="ipc__transport__structured_2src_2ipc_2transport_2struc_2sync__io_2channel_8hpp_source.html#l05034">channel.hpp:5034</a></div></div>
<div class="ttc" id="aclassipc_1_1transport_1_1struc_1_1sync__io_1_1Channel_html_a252e43676b8a41a706df0655f887be63"><div class="ttname"><a href="classipc_1_1transport_1_1struc_1_1sync__io_1_1Channel.html#a252e43676b8a41a706df0655f887be63">ipc::transport::struc::sync_io::Channel::rcv_async_read_lead_or_continuation_msg</a></div><div class="ttdeci">void rcv_async_read_lead_or_continuation_msg(Msg_in_pipe *pipe, bool lead_else_cont)</div><div class="ttdoc">This key method acts on the pre-condition that the given in-pipe is not known to be in would-block st...</div><div class="ttdef"><b>Definition:</b> <a href="ipc__transport__structured_2src_2ipc_2transport_2struc_2sync__io_2channel_8hpp_source.html#l02732">channel.hpp:2732</a></div></div>
<div class="ttc" id="aclassipc_1_1transport_1_1struc_1_1sync__io_1_1Channel_html_a2552eada8012c4a8c4d2fc5f02e9f69b"><div class="ttname"><a href="classipc_1_1transport_1_1struc_1_1sync__io_1_1Channel.html#a2552eada8012c4a8c4d2fc5f02e9f69b">ipc::transport::struc::sync_io::Channel::expect_msgs_impl</a></div><div class="ttdeci">bool expect_msgs_impl(Msgs_in *qd_msgs, bool one_off, Msg_which_in which, On_msg_func_ptr &amp;&amp;on_msg_func)</div><div class="ttdoc">Core of expect_msg(), expect_msgs(), and expect_log_in_request().</div><div class="ttdef"><b>Definition:</b> <a href="ipc__transport__structured_2src_2ipc_2transport_2struc_2sync__io_2channel_8hpp_source.html#l04826">channel.hpp:4826</a></div></div>
<div class="ttc" id="aclassipc_1_1transport_1_1struc_1_1sync__io_1_1Channel_html_a26121a19c67c5bf5c338441502d9d6f7"><div class="ttname"><a href="classipc_1_1transport_1_1struc_1_1sync__io_1_1Channel.html#a26121a19c67c5bf5c338441502d9d6f7">ipc::transport::struc::sync_io::Channel::On_msg_func</a></div><div class="ttdeci">Function&lt; void(Msg_in_ptr &amp;&amp;msg)&gt; On_msg_func</div><div class="ttdoc">Concrete type corresponding to On_msg_handler template param: in-message handler.</div><div class="ttdef"><b>Definition:</b> <a href="ipc__transport__structured_2src_2ipc_2transport_2struc_2sync__io_2channel_8hpp_source.html#l01044">channel.hpp:1044</a></div></div>
<div class="ttc" id="aclassipc_1_1transport_1_1struc_1_1sync__io_1_1Channel_html_a26594894094e4fa03b3c1dacd2e0f351"><div class="ttname"><a href="classipc_1_1transport_1_1struc_1_1sync__io_1_1Channel.html#a26594894094e4fa03b3c1dacd2e0f351">ipc::transport::struc::sync_io::Channel::Reassembly_q</a></div><div class="ttdeci">std::map&lt; msg_id_in_t, Msg_in_ptr_uniq &gt; Reassembly_q</div><div class="ttdoc">Reassembly queue type: &quot;queue&quot; of all in-messages with msg_id_in_t exceeding m_rcv_msg_next_id,...</div><div class="ttdef"><b>Definition:</b> <a href="ipc__transport__structured_2src_2ipc_2transport_2struc_2sync__io_2channel_8hpp_source.html#l01150">channel.hpp:1150</a></div></div>
<div class="ttc" id="aclassipc_1_1transport_1_1struc_1_1sync__io_1_1Channel_html_a26d39d4e1e2c304ef803b3721bde86f0"><div class="ttname"><a href="classipc_1_1transport_1_1struc_1_1sync__io_1_1Channel.html#a26d39d4e1e2c304ef803b3721bde86f0">ipc::transport::struc::sync_io::Channel::m_rcv_msg_next_id</a></div><div class="ttdeci">msg_id_in_t m_rcv_msg_next_id</div><div class="ttdoc">Next expected in-message ID (sequence #), incremented from initial value 1 to 2, 3,...</div><div class="ttdef"><b>Definition:</b> <a href="ipc__transport__structured_2src_2ipc_2transport_2struc_2sync__io_2channel_8hpp_source.html#l02036">channel.hpp:2036</a></div></div>
<div class="ttc" id="aclassipc_1_1transport_1_1struc_1_1sync__io_1_1Channel_html_a26dc83067e005be38567199cbedd7f19"><div class="ttname"><a href="classipc_1_1transport_1_1struc_1_1sync__io_1_1Channel.html#a26dc83067e005be38567199cbedd7f19">ipc::transport::struc::sync_io::Channel::async_request</a></div><div class="ttdeci">bool async_request(const Msg_out &amp;msg, const Msg_in *originating_msg_or_null, msg_id_out_t *id_unless_one_off, On_msg_handler &amp;&amp;on_rsp_func, Error_code *err_code=0)</div><div class="ttdoc">See Async_io_obj counterpart; though naturally on_rsp_func() is invoked in the sync_io-pattern fashio...</div><div class="ttdef"><b>Definition:</b> <a href="ipc__transport__structured_2src_2ipc_2transport_2struc_2sync__io_2channel_8hpp_source.html#l04194">channel.hpp:4194</a></div></div>
<div class="ttc" id="aclassipc_1_1transport_1_1struc_1_1sync__io_1_1Channel_html_a2c0013237f845e5589cf0063886c7431"><div class="ttname"><a href="classipc_1_1transport_1_1struc_1_1sync__io_1_1Channel.html#a2c0013237f845e5589cf0063886c7431">ipc::transport::struc::sync_io::Channel::m_sync_io_handlers</a></div><div class="ttdeci">std::vector&lt; boost::movelib::unique_ptr&lt; util::Task &gt; &gt; m_sync_io_handlers</div><div class="ttdoc">The handlers as pushed by handlers_post() to be flushed via handlers_poll() (internally by *this).</div><div class="ttdef"><b>Definition:</b> <a href="ipc__transport__structured_2src_2ipc_2transport_2struc_2sync__io_2channel_8hpp_source.html#l02186">channel.hpp:2186</a></div></div>
<div class="ttc" id="aclassipc_1_1transport_1_1struc_1_1sync__io_1_1Channel_html_a2eed5db328a8c45ab16a875617a172c7"><div class="ttname"><a href="classipc_1_1transport_1_1struc_1_1sync__io_1_1Channel.html#a2eed5db328a8c45ab16a875617a172c7">ipc::transport::struc::sync_io::Channel::Msg_in_q</a></div><div class="ttdeci">std::queue&lt; Msg_in_ptr_uniq &gt; Msg_in_q</div><div class="ttdoc">Short-hand for queue (FIFO) of in-messages.</div><div class="ttdef"><b>Definition:</b> <a href="ipc__transport__structured_2src_2ipc_2transport_2struc_2sync__io_2channel_8hpp_source.html#l01144">channel.hpp:1144</a></div></div>
<div class="ttc" id="aclassipc_1_1transport_1_1struc_1_1sync__io_1_1Channel_html_a34e183c252390f369f121074772c14c4"><div class="ttname"><a href="classipc_1_1transport_1_1struc_1_1sync__io_1_1Channel.html#a34e183c252390f369f121074772c14c4">ipc::transport::struc::sync_io::Channel::Msg_body</a></div><div class="ttdeci">Message_body Msg_body</div><div class="ttdoc">See Async_io_obj counterpart.</div><div class="ttdef"><b>Definition:</b> <a href="ipc__transport__structured_2src_2ipc_2transport_2struc_2sync__io_2channel_8hpp_source.html#l00349">channel.hpp:349</a></div></div>
<div class="ttc" id="aclassipc_1_1transport_1_1struc_1_1sync__io_1_1Channel_html_a3a0adf8ce8fc29ec55b4c8c30886c1fc"><div class="ttname"><a href="classipc_1_1transport_1_1struc_1_1sync__io_1_1Channel.html#a3a0adf8ce8fc29ec55b4c8c30886c1fc">ipc::transport::struc::sync_io::Channel::handlers_poll</a></div><div class="ttdeci">void handlers_poll(util::String_view context)</div><div class="ttdoc">Executes what was recorded recently in handlers_post().</div><div class="ttdef"><b>Definition:</b> <a href="ipc__transport__structured_2src_2ipc_2transport_2struc_2sync__io_2channel_8hpp_source.html#l03626">channel.hpp:3626</a></div></div>
<div class="ttc" id="aclassipc_1_1transport_1_1struc_1_1sync__io_1_1Channel_html_a3d4c8da3dd620d113479f5c6a3f96c3a"><div class="ttname"><a href="classipc_1_1transport_1_1struc_1_1sync__io_1_1Channel.html#a3d4c8da3dd620d113479f5c6a3f96c3a">ipc::transport::struc::sync_io::Channel::Expecting_response_map</a></div><div class="ttdeci">boost::unordered_map&lt; msg_id_out_t, typename Expecting_response::Ptr &gt; Expecting_response_map</div><div class="ttdoc">Table mapping originating out-message to the policy for handling an in-message that indicates that ou...</div><div class="ttdef"><b>Definition:</b> <a href="ipc__transport__structured_2src_2ipc_2transport_2struc_2sync__io_2channel_8hpp_source.html#l01132">channel.hpp:1132</a></div></div>
<div class="ttc" id="aclassipc_1_1transport_1_1struc_1_1sync__io_1_1Channel_html_a3fda370cc97c89a62f77a6fcf639cfd7"><div class="ttname"><a href="classipc_1_1transport_1_1struc_1_1sync__io_1_1Channel.html#a3fda370cc97c89a62f77a6fcf639cfd7">ipc::transport::struc::sync_io::Channel::set_remote_unexpected_response_handler</a></div><div class="ttdeci">bool set_remote_unexpected_response_handler(On_remote_unexpected_response_handler &amp;&amp;on_func)</div><div class="ttdoc">See Async_io_obj counterpart; though naturally on_func() is invoked in the sync_io-pattern fashion.</div><div class="ttdef"><b>Definition:</b> <a href="ipc__transport__structured_2src_2ipc_2transport_2struc_2sync__io_2channel_8hpp_source.html#l05019">channel.hpp:5019</a></div></div>
<div class="ttc" id="aclassipc_1_1transport_1_1struc_1_1sync__io_1_1Channel_html_a426ecae27b4ea5cf7e666e56bad6afe5"><div class="ttname"><a href="classipc_1_1transport_1_1struc_1_1sync__io_1_1Channel.html#a426ecae27b4ea5cf7e666e56bad6afe5">ipc::transport::struc::sync_io::Channel::create_msg</a></div><div class="ttdeci">Msg_out create_msg(Native_handle &amp;&amp;hndl_or_null=Native_handle()) const</div><div class="ttdoc">See Async_io_obj counterpart.</div><div class="ttdef"><b>Definition:</b> <a href="ipc__transport__structured_2src_2ipc_2transport_2struc_2sync__io_2channel_8hpp_source.html#l04721">channel.hpp:4721</a></div></div>
<div class="ttc" id="aclassipc_1_1transport_1_1struc_1_1sync__io_1_1Channel_html_a43fa0b77781376edd13b742b832572e1"><div class="ttname"><a href="classipc_1_1transport_1_1struc_1_1sync__io_1_1Channel.html#a43fa0b77781376edd13b742b832572e1">ipc::transport::struc::sync_io::Channel::struct_lender_session</a></div><div class="ttdeci">const Builder_config::Builder::Session &amp; struct_lender_session() const</div><div class="ttdoc">See Async_io_obj counterpart.</div><div class="ttdef"><b>Definition:</b> <a href="ipc__transport__structured_2src_2ipc_2transport_2struc_2sync__io_2channel_8hpp_source.html#l04138">channel.hpp:4138</a></div></div>
<div class="ttc" id="aclassipc_1_1transport_1_1struc_1_1sync__io_1_1Channel_html_a47816a05b0af2d8b5c26ecaf01b89b1f"><div class="ttname"><a href="classipc_1_1transport_1_1struc_1_1sync__io_1_1Channel.html#a47816a05b0af2d8b5c26ecaf01b89b1f">ipc::transport::struc::sync_io::Channel::m_struct_builder_config</a></div><div class="ttdeci">const Builder_config m_struct_builder_config</div><div class="ttdoc">The builder engine config for out-messages: Small data store, such that the Struct_builder Builder_co...</div><div class="ttdef"><b>Definition:</b> <a href="ipc__transport__structured_2src_2ipc_2transport_2struc_2sync__io_2channel_8hpp_source.html#l01863">channel.hpp:1863</a></div></div>
<div class="ttc" id="aclassipc_1_1transport_1_1struc_1_1sync__io_1_1Channel_html_a48a8fd167c1fe6ae95d8fc80b6a6e67f"><div class="ttname"><a href="classipc_1_1transport_1_1struc_1_1sync__io_1_1Channel.html#a48a8fd167c1fe6ae95d8fc80b6a6e67f">ipc::transport::struc::sync_io::Channel::struct_builder_config</a></div><div class="ttdeci">const Builder_config &amp; struct_builder_config() const</div><div class="ttdoc">See Async_io_obj counterpart.</div><div class="ttdef"><b>Definition:</b> <a href="ipc__transport__structured_2src_2ipc_2transport_2struc_2sync__io_2channel_8hpp_source.html#l04131">channel.hpp:4131</a></div></div>
<div class="ttc" id="aclassipc_1_1transport_1_1struc_1_1sync__io_1_1Channel_html_a491a1a9eff4e277f3e5cd32c0178adbf"><div class="ttname"><a href="classipc_1_1transport_1_1struc_1_1sync__io_1_1Channel.html#a491a1a9eff4e277f3e5cd32c0178adbf">ipc::transport::struc::sync_io::Channel::m_on_remote_unexpected_response_func_or_empty</a></div><div class="ttdeci">On_remote_unexpected_response_func m_on_remote_unexpected_response_func_or_empty</div><div class="ttdoc">See set_remote_unexpected_response_handler().</div><div class="ttdef"><b>Definition:</b> <a href="ipc__transport__structured_2src_2ipc_2transport_2struc_2sync__io_2channel_8hpp_source.html#l01928">channel.hpp:1928</a></div></div>
<div class="ttc" id="aclassipc_1_1transport_1_1struc_1_1sync__io_1_1Channel_html_a49e257338f9b20fd70c42142eb2db4f0"><div class="ttname"><a href="classipc_1_1transport_1_1struc_1_1sync__io_1_1Channel.html#a49e257338f9b20fd70c42142eb2db4f0">ipc::transport::struc::sync_io::Channel::m_session_token</a></div><div class="ttdeci">Session_token m_session_token</div><div class="ttdoc">Session token: in Phase::S_LOGGED_IN to send in every out-message and check-against every in-message;...</div><div class="ttdef"><b>Definition:</b> <a href="ipc__transport__structured_2src_2ipc_2transport_2struc_2sync__io_2channel_8hpp_source.html#l01945">channel.hpp:1945</a></div></div>
<div class="ttc" id="aclassipc_1_1transport_1_1struc_1_1sync__io_1_1Channel_html_a4ab778bce8d7e6e84788879fedc62745"><div class="ttname"><a href="classipc_1_1transport_1_1struc_1_1sync__io_1_1Channel.html#a4ab778bce8d7e6e84788879fedc62745">ipc::transport::struc::sync_io::Channel::Msgs_in</a></div><div class="ttdeci">std::vector&lt; Msg_in_ptr &gt; Msgs_in</div><div class="ttdoc">List of in-messages used in certain APIs like expect_msgs() to synchronously emit cached in-messages.</div><div class="ttdef"><b>Definition:</b> <a href="ipc__transport__structured_2src_2ipc_2transport_2struc_2sync__io_2channel_8hpp_source.html#l00370">channel.hpp:370</a></div></div>
<div class="ttc" id="aclassipc_1_1transport_1_1struc_1_1sync__io_1_1Channel_html_a4abac89dbd4d26c79b7915990f751a76"><div class="ttname"><a href="classipc_1_1transport_1_1struc_1_1sync__io_1_1Channel.html#a4abac89dbd4d26c79b7915990f751a76">ipc::transport::struc::sync_io::Channel::Owned_channel</a></div><div class="ttdeci">Channel_obj Owned_channel</div><div class="ttdoc">See Async_io_obj counterpart.</div><div class="ttdef"><b>Definition:</b> <a href="ipc__transport__structured_2src_2ipc_2transport_2struc_2sync__io_2channel_8hpp_source.html#l00337">channel.hpp:337</a></div></div>
<div class="ttc" id="aclassipc_1_1transport_1_1struc_1_1sync__io_1_1Channel_html_a50fb95469fcf9d5aadfb37c7117b8abb"><div class="ttname"><a href="classipc_1_1transport_1_1struc_1_1sync__io_1_1Channel.html#a50fb95469fcf9d5aadfb37c7117b8abb">ipc::transport::struc::sync_io::Channel::rcv_async_read_proto_neg_msg</a></div><div class="ttdeci">void rcv_async_read_proto_neg_msg(Msg_in_pipe *pipe)</div><div class="ttdoc">Acts on the pre-condition that the given in-pipe has just started (thus not known to be in would-bloc...</div><div class="ttdef"><b>Definition:</b> <a href="ipc__transport__structured_2src_2ipc_2transport_2struc_2sync__io_2channel_8hpp_source.html#l03163">channel.hpp:3163</a></div></div>
<div class="ttc" id="aclassipc_1_1transport_1_1struc_1_1sync__io_1_1Channel_html_a5132d96a55a628a7830c19c630390582"><div class="ttname"><a href="classipc_1_1transport_1_1struc_1_1sync__io_1_1Channel.html#a5132d96a55a628a7830c19c630390582">ipc::transport::struc::sync_io::Channel::m_snd_msg_next_id</a></div><div class="ttdeci">msg_id_out_t m_snd_msg_next_id</div><div class="ttdoc">Next out-message ID (for the next send() or async_request()).</div><div class="ttdef"><b>Definition:</b> <a href="ipc__transport__structured_2src_2ipc_2transport_2struc_2sync__io_2channel_8hpp_source.html#l01948">channel.hpp:1948</a></div></div>
<div class="ttc" id="aclassipc_1_1transport_1_1struc_1_1sync__io_1_1Channel_html_a515bbf752a9021ba8e0cec34d30f24b9"><div class="ttname"><a href="classipc_1_1transport_1_1struc_1_1sync__io_1_1Channel.html#a515bbf752a9021ba8e0cec34d30f24b9">ipc::transport::struc::sync_io::Channel::m_proto_neg_err_code_or_ok</a></div><div class="ttdeci">Error_code m_proto_neg_err_code_or_ok</div><div class="ttdoc">Error, or lack thereof, recorded by start_ops() (having returned true) when synchronously sending out...</div><div class="ttdef"><b>Definition:</b> <a href="ipc__transport__structured_2src_2ipc_2transport_2struc_2sync__io_2channel_8hpp_source.html#l01901">channel.hpp:1901</a></div></div>
<div class="ttc" id="aclassipc_1_1transport_1_1struc_1_1sync__io_1_1Channel_html_a543aa806ec21b8550f9f440e59767d52"><div class="ttname"><a href="classipc_1_1transport_1_1struc_1_1sync__io_1_1Channel.html#a543aa806ec21b8550f9f440e59767d52">ipc::transport::struc::sync_io::Channel::replace_event_wait_handles</a></div><div class="ttdeci">bool replace_event_wait_handles(const Create_ev_wait_hndl_func &amp;create_ev_wait_hndl_func)</div><div class="ttdoc">Analogous to transport::sync_io::Native_handle_sender::replace_event_wait_handles().</div><div class="ttdef"><b>Definition:</b> <a href="ipc__transport__structured_2src_2ipc_2transport_2struc_2sync__io_2channel_8hpp_source.html#l02383">channel.hpp:2383</a></div></div>
<div class="ttc" id="aclassipc_1_1transport_1_1struc_1_1sync__io_1_1Channel_html_a583ccd4bb6b1aefb09d77e5709aef5b4"><div class="ttname"><a href="classipc_1_1transport_1_1struc_1_1sync__io_1_1Channel.html#a583ccd4bb6b1aefb09d77e5709aef5b4">ipc::transport::struc::sync_io::Channel::On_msg_func_ptr</a></div><div class="ttdeci">boost::shared_ptr&lt; On_msg_func &gt; On_msg_func_ptr</div><div class="ttdoc">Ref-counted wrapper of On_msg_func.</div><div class="ttdef"><b>Definition:</b> <a href="ipc__transport__structured_2src_2ipc_2transport_2struc_2sync__io_2channel_8hpp_source.html#l01047">channel.hpp:1047</a></div></div>
<div class="ttc" id="aclassipc_1_1transport_1_1struc_1_1sync__io_1_1Channel_html_a5a3833cd141802041551db21198ac319"><div class="ttname"><a href="classipc_1_1transport_1_1struc_1_1sync__io_1_1Channel.html#a5a3833cd141802041551db21198ac319">ipc::transport::struc::sync_io::Channel::Phase</a></div><div class="ttdeci">Phase</div><div class="ttdoc">The state of *this (given start_ops() success); see m_phase.</div><div class="ttdef"><b>Definition:</b> <a href="ipc__transport__structured_2src_2ipc_2transport_2struc_2sync__io_2channel_8hpp_source.html#l01063">channel.hpp:1064</a></div></div>
<div class="ttc" id="aclassipc_1_1transport_1_1struc_1_1sync__io_1_1Channel_html_a5aae7a7f907f56fa07a230eadec2fedf"><div class="ttname"><a href="classipc_1_1transport_1_1struc_1_1sync__io_1_1Channel.html#a5aae7a7f907f56fa07a230eadec2fedf">ipc::transport::struc::sync_io::Channel::undo_expect_responses</a></div><div class="ttdeci">bool undo_expect_responses(msg_id_out_t originating_msg_id)</div><div class="ttdoc">See Async_io_obj counterpart.</div><div class="ttdef"><b>Definition:</b> <a href="ipc__transport__structured_2src_2ipc_2transport_2struc_2sync__io_2channel_8hpp_source.html#l04959">channel.hpp:4959</a></div></div>
<div class="ttc" id="aclassipc_1_1transport_1_1struc_1_1sync__io_1_1Channel_html_a5c62d2a374a3a98e7fa0aef01bf8a774"><div class="ttname"><a href="classipc_1_1transport_1_1struc_1_1sync__io_1_1Channel.html#a5c62d2a374a3a98e7fa0aef01bf8a774">ipc::transport::struc::sync_io::Channel::set_unexpected_response_handler</a></div><div class="ttdeci">bool set_unexpected_response_handler(On_unexpected_response_handler &amp;&amp;on_func)</div><div class="ttdoc">See Async_io_obj counterpart; though naturally on_func() is invoked in the sync_io-pattern fashion.</div><div class="ttdef"><b>Definition:</b> <a href="ipc__transport__structured_2src_2ipc_2transport_2struc_2sync__io_2channel_8hpp_source.html#l04988">channel.hpp:4988</a></div></div>
<div class="ttc" id="aclassipc_1_1transport_1_1struc_1_1sync__io_1_1Channel_html_a5fc489b9abefe5ab676f6991d6d03f0d"><div class="ttname"><a href="classipc_1_1transport_1_1struc_1_1sync__io_1_1Channel.html#a5fc489b9abefe5ab676f6991d6d03f0d">ipc::transport::struc::sync_io::Channel::expect_msg</a></div><div class="ttdeci">bool expect_msg(Msg_which_in which, Msg_in_ptr *qd_msg, On_msg_handler &amp;&amp;on_msg_func)</div><div class="ttdoc">Registers the expectation (which may be immediately met) of up to 1 notification in-message whose Msg...</div><div class="ttdef"><b>Definition:</b> <a href="ipc__transport__structured_2src_2ipc_2transport_2struc_2sync__io_2channel_8hpp_source.html#l04735">channel.hpp:4735</a></div></div>
<div class="ttc" id="aclassipc_1_1transport_1_1struc_1_1sync__io_1_1Channel_html_a62f52488ba20dd6c69dfc1abadb2d69f"><div class="ttname"><a href="classipc_1_1transport_1_1struc_1_1sync__io_1_1Channel.html#a62f52488ba20dd6c69dfc1abadb2d69f">ipc::transport::struc::sync_io::Channel::expect_msgs</a></div><div class="ttdeci">bool expect_msgs(Msg_which_in which, Msgs_in *qd_msgs, On_msg_handler &amp;&amp;on_msg_func)</div><div class="ttdoc">Registers the expectation (some of which may be immediately met) of 0+ notification in-messages whose...</div><div class="ttdef"><b>Definition:</b> <a href="ipc__transport__structured_2src_2ipc_2transport_2struc_2sync__io_2channel_8hpp_source.html#l04767">channel.hpp:4767</a></div></div>
<div class="ttc" id="aclassipc_1_1transport_1_1struc_1_1sync__io_1_1Channel_html_a6e4f8c4207fcf678b4cfc785707d3dce"><div class="ttname"><a href="classipc_1_1transport_1_1struc_1_1sync__io_1_1Channel.html#a6e4f8c4207fcf678b4cfc785707d3dce">ipc::transport::struc::sync_io::Channel::start_ops</a></div><div class="ttdeci">bool start_ops(Event_wait_func_t &amp;&amp;ev_wait_func)</div><div class="ttdoc">Sets up the sync_io-pattern interaction between *this and the user's event loop; required before asyn...</div><div class="ttdef"><b>Definition:</b> <a href="ipc__transport__structured_2src_2ipc_2transport_2struc_2sync__io_2channel_8hpp_source.html#l02390">channel.hpp:2390</a></div></div>
<div class="ttc" id="aclassipc_1_1transport_1_1struc_1_1sync__io_1_1Channel_html_a759e1993bc61abb41380219b254ca410"><div class="ttname"><a href="classipc_1_1transport_1_1struc_1_1sync__io_1_1Channel.html#a759e1993bc61abb41380219b254ca410">ipc::transport::struc::sync_io::Channel::owned_channel</a></div><div class="ttdeci">const Owned_channel &amp; owned_channel() const</div><div class="ttdoc">See Async_io_obj counterpart.</div><div class="ttdef"><b>Definition:</b> <a href="ipc__transport__structured_2src_2ipc_2transport_2struc_2sync__io_2channel_8hpp_source.html#l05049">channel.hpp:5049</a></div></div>
<div class="ttc" id="aclassipc_1_1transport_1_1struc_1_1sync__io_1_1Channel_html_a795baef6fefbc4749daf5ceda52943c1"><div class="ttname"><a href="classipc_1_1transport_1_1struc_1_1sync__io_1_1Channel.html#a795baef6fefbc4749daf5ceda52943c1">ipc::transport::struc::sync_io::Channel::rcv_struct_inform_of_unexpected_response</a></div><div class="ttdeci">void rcv_struct_inform_of_unexpected_response(Msg_in_ptr_uniq &amp;&amp;msg_in)</div><div class="ttdoc">Helper from rcv_struct_new_msg_in_is_next_expected() that reacts to receiving an otherwise valid repo...</div><div class="ttdef"><b>Definition:</b> <a href="ipc__transport__structured_2src_2ipc_2transport_2struc_2sync__io_2channel_8hpp_source.html#l04017">channel.hpp:4017</a></div></div>
<div class="ttc" id="aclassipc_1_1transport_1_1struc_1_1sync__io_1_1Channel_html_a7a731cdae5217ed9e867fb80c1fb0fd9"><div class="ttname"><a href="classipc_1_1transport_1_1struc_1_1sync__io_1_1Channel.html#a7a731cdae5217ed9e867fb80c1fb0fd9">ipc::transport::struc::sync_io::Channel::Msg_which_out</a></div><div class="ttdeci">Msg_which Msg_which_out</div><div class="ttdoc">See Async_io_obj counterpart.</div><div class="ttdef"><b>Definition:</b> <a href="ipc__transport__structured_2src_2ipc_2transport_2struc_2sync__io_2channel_8hpp_source.html#l00358">channel.hpp:358</a></div></div>
<div class="ttc" id="aclassipc_1_1transport_1_1struc_1_1sync__io_1_1Channel_html_a7efbfbcce0d4d426b7df9b6d6fd1e373"><div class="ttname"><a href="classipc_1_1transport_1_1struc_1_1sync__io_1_1Channel.html#a7efbfbcce0d4d426b7df9b6d6fd1e373">ipc::transport::struc::sync_io::Channel::struct_reader_config</a></div><div class="ttdeci">const Reader_config &amp; struct_reader_config() const</div><div class="ttdoc">See Async_io_obj counterpart.</div><div class="ttdef"><b>Definition:</b> <a href="ipc__transport__structured_2src_2ipc_2transport_2struc_2sync__io_2channel_8hpp_source.html#l04145">channel.hpp:4145</a></div></div>
<div class="ttc" id="aclassipc_1_1transport_1_1struc_1_1sync__io_1_1Channel_html_a84287334d14f54c97f7dbb0d5b04cca5"><div class="ttname"><a href="classipc_1_1transport_1_1struc_1_1sync__io_1_1Channel.html#a84287334d14f54c97f7dbb0d5b04cca5">ipc::transport::struc::sync_io::Channel::Msg_in_ptr_uniq</a></div><div class="ttdeci">boost::movelib::unique_ptr&lt; Msg_in_impl &gt; Msg_in_ptr_uniq</div><div class="ttdoc">Like Msg_in_ptr but unique_ptr instead of shared_ptr. Note the latter can upgrade-from a move()d form...</div><div class="ttdef"><b>Definition:</b> <a href="ipc__transport__structured_2src_2ipc_2transport_2struc_2sync__io_2channel_8hpp_source.html#l01141">channel.hpp:1141</a></div></div>
<div class="ttc" id="aclassipc_1_1transport_1_1struc_1_1sync__io_1_1Channel_html_a86342fa9838aea7d49bbf3dd344445e2"><div class="ttname"><a href="classipc_1_1transport_1_1struc_1_1sync__io_1_1Channel.html#a86342fa9838aea7d49bbf3dd344445e2">ipc::transport::struc::sync_io::Channel::On_remote_unexpected_response_func</a></div><div class="ttdeci">Function&lt; void(msg_id_out_t msg_id_out, std::string &amp;&amp;msg_metadata_text)&gt; On_remote_unexpected_response_func</div><div class="ttdoc">Concrete type corresponding to On_remote_unexpected_response_handler template param (see set_remote_u...</div><div class="ttdef"><b>Definition:</b> <a href="ipc__transport__structured_2src_2ipc_2transport_2struc_2sync__io_2channel_8hpp_source.html#l01059">channel.hpp:1060</a></div></div>
<div class="ttc" id="aclassipc_1_1transport_1_1struc_1_1sync__io_1_1Channel_html_a8a59bbc3c6a7191b316b23661d8ba6e3"><div class="ttname"><a href="classipc_1_1transport_1_1struc_1_1sync__io_1_1Channel.html#a8a59bbc3c6a7191b316b23661d8ba6e3">ipc::transport::struc::sync_io::Channel::Builder_config</a></div><div class="ttdeci">Struct_builder_config Builder_config</div><div class="ttdoc">See Async_io_obj counterpart.</div><div class="ttdef"><b>Definition:</b> <a href="ipc__transport__structured_2src_2ipc_2transport_2struc_2sync__io_2channel_8hpp_source.html#l00344">channel.hpp:344</a></div></div>
<div class="ttc" id="aclassipc_1_1transport_1_1struc_1_1sync__io_1_1Channel_html_a8d1ffe78546eb31fd41df6784a26868c"><div class="ttname"><a href="classipc_1_1transport_1_1struc_1_1sync__io_1_1Channel.html#a8d1ffe78546eb31fd41df6784a26868c">ipc::transport::struc::sync_io::Channel::Expecting_msg_map</a></div><div class="ttdeci">boost::unordered_map&lt; Msg_which_in, typename Expecting_msg::Ptr &gt; Expecting_msg_map</div><div class="ttdoc">Table mapping in-message Msg_which_in enum value to the policy for handling an in-message with that w...</div><div class="ttdef"><b>Definition:</b> <a href="ipc__transport__structured_2src_2ipc_2transport_2struc_2sync__io_2channel_8hpp_source.html#l01138">channel.hpp:1138</a></div></div>
<div class="ttc" id="aclassipc_1_1transport_1_1struc_1_1sync__io_1_1Channel_html_a8fc989561ed62604dd50f942655daea0"><div class="ttname"><a href="classipc_1_1transport_1_1struc_1_1sync__io_1_1Channel.html#a8fc989561ed62604dd50f942655daea0">ipc::transport::struc::sync_io::Channel::send_proto_neg</a></div><div class="ttdeci">void send_proto_neg()</div><div class="ttdoc">Essentially a much-cut-down version of send_core() that specifically sends, along all Owned_channel p...</div><div class="ttdef"><b>Definition:</b> <a href="ipc__transport__structured_2src_2ipc_2transport_2struc_2sync__io_2channel_8hpp_source.html#l04573">channel.hpp:4573</a></div></div>
<div class="ttc" id="aclassipc_1_1transport_1_1struc_1_1sync__io_1_1Channel_html_a9174c694ee8437605c089965ecea2ebf"><div class="ttname"><a href="classipc_1_1transport_1_1struc_1_1sync__io_1_1Channel.html#a9174c694ee8437605c089965ecea2ebf">ipc::transport::struc::sync_io::Channel::rcv_struct_new_msg_in_during_log_in_as_srv</a></div><div class="ttdeci">bool rcv_struct_new_msg_in_during_log_in_as_srv(Msg_in_ptr_uniq &amp;&amp;msg_in)</div><div class="ttdoc">Like rcv_struct_new_msg_in_during_log_in_as_cli() but for Phase::S_SRV_LOG_IN instead of CLI_LOG_IN.</div><div class="ttdef"><b>Definition:</b> <a href="ipc__transport__structured_2src_2ipc_2transport_2struc_2sync__io_2channel_8hpp_source.html#l03798">channel.hpp:3798</a></div></div>
<div class="ttc" id="aclassipc_1_1transport_1_1struc_1_1sync__io_1_1Channel_html_a9385752ed00263dec5c5080b67ce0960"><div class="ttname"><a href="classipc_1_1transport_1_1struc_1_1sync__io_1_1Channel.html#a9385752ed00263dec5c5080b67ce0960">ipc::transport::struc::sync_io::Channel::Channel</a></div><div class="ttdeci">Channel(flow::log::Logger *logger_ptr, Owned_channel &amp;&amp;channel, const Builder_config &amp;struct_builder_config, const typename Builder_config::Builder::Session &amp;struct_lender_session, const Reader_config &amp;struct_reader_config, const Session_token &amp;session_token_non_nil)</div><div class="ttdoc">Non-tag, no-log-in ctor form: Creates structured channel peer with no log-in phase (log-in phase must...</div><div class="ttdef"><b>Definition:</b> <a href="ipc__transport__structured_2src_2ipc_2transport_2struc_2sync__io_2channel_8hpp_source.html#l02202">channel.hpp:2202</a></div></div>
<div class="ttc" id="aclassipc_1_1transport_1_1struc_1_1sync__io_1_1Channel_html_a95cfe30e685e828d62318c9b2bc4b137"><div class="ttname"><a href="classipc_1_1transport_1_1struc_1_1sync__io_1_1Channel.html#a95cfe30e685e828d62318c9b2bc4b137">ipc::transport::struc::sync_io::Channel::m_channel_err_code_or_ok</a></div><div class="ttdeci">Error_code m_channel_err_code_or_ok</div><div class="ttdoc">Starts falsy; becomes forever truthy (with a specific Error_code that will not change thereafter) whe...</div><div class="ttdef"><b>Definition:</b> <a href="ipc__transport__structured_2src_2ipc_2transport_2struc_2sync__io_2channel_8hpp_source.html#l01998">channel.hpp:1998</a></div></div>
<div class="ttc" id="aclassipc_1_1transport_1_1struc_1_1sync__io_1_1Channel_html_a996e06f75024e10987eb9cf62e096eec"><div class="ttname"><a href="classipc_1_1transport_1_1struc_1_1sync__io_1_1Channel.html#a996e06f75024e10987eb9cf62e096eec">ipc::transport::struc::sync_io::Channel::expect_log_in_request</a></div><div class="ttdeci">bool expect_log_in_request(Msg_which_in which, Msg_in_ptr *qd_msg, On_msg_handler &amp;&amp;on_log_in_req_func)</div><div class="ttdoc">In log-in phase as server only: Registers the expectation (which may be immediately met) of up to 1 l...</div><div class="ttdef"><b>Definition:</b> <a href="ipc__transport__structured_2src_2ipc_2transport_2struc_2sync__io_2channel_8hpp_source.html#l04786">channel.hpp:4786</a></div></div>
<div class="ttc" id="aclassipc_1_1transport_1_1struc_1_1sync__io_1_1Channel_html_a9a63c3620852f2354fe145364a73c688"><div class="ttname"><a href="classipc_1_1transport_1_1struc_1_1sync__io_1_1Channel.html#a9a63c3620852f2354fe145364a73c688">ipc::transport::struc::sync_io::Channel::m_started_ops</a></div><div class="ttdeci">bool m_started_ops</div><div class="ttdoc">Whether start_ops() has been called yet or not.</div><div class="ttdef"><b>Definition:</b> <a href="ipc__transport__structured_2src_2ipc_2transport_2struc_2sync__io_2channel_8hpp_source.html#l01908">channel.hpp:1908</a></div></div>
<div class="ttc" id="aclassipc_1_1transport_1_1struc_1_1sync__io_1_1Channel_html_a9b5d17887c9ad1e37081bf4ae4a70e65"><div class="ttname"><a href="classipc_1_1transport_1_1struc_1_1sync__io_1_1Channel.html#a9b5d17887c9ad1e37081bf4ae4a70e65">ipc::transport::struc::sync_io::Channel::msg_id_out_t</a></div><div class="ttdeci">Channel_base::msg_id_out_t msg_id_out_t</div><div class="ttdoc">See Async_io_obj counterpart.</div><div class="ttdef"><b>Definition:</b> <a href="ipc__transport__structured_2src_2ipc_2transport_2struc_2sync__io_2channel_8hpp_source.html#l00373">channel.hpp:373</a></div></div>
<div class="ttc" id="aclassipc_1_1transport_1_1struc_1_1sync__io_1_1Channel_html_a9b6cda20adb82073a1d7cf1b5cbfa865"><div class="ttname"><a href="classipc_1_1transport_1_1struc_1_1sync__io_1_1Channel.html#a9b6cda20adb82073a1d7cf1b5cbfa865">ipc::transport::struc::sync_io::Channel::rcv_blob_max_size</a></div><div class="ttdeci">size_t rcv_blob_max_size(decltype(Msg_in_pipe::m_lead_msg_mode) mode) const</div><div class="ttdoc">Helper that returns the max receive-buffer size for any async-read into a given Msg_in_pipe.</div><div class="ttdef"><b>Definition:</b> <a href="ipc__transport__structured_2src_2ipc_2transport_2struc_2sync__io_2channel_8hpp_source.html#l02702">channel.hpp:2702</a></div></div>
<div class="ttc" id="aclassipc_1_1transport_1_1struc_1_1sync__io_1_1Channel_html_a9c04f15d4d17cd43aca70136119e1d28"><div class="ttname"><a href="classipc_1_1transport_1_1struc_1_1sync__io_1_1Channel.html#a9c04f15d4d17cd43aca70136119e1d28">ipc::transport::struc::sync_io::Channel::m_rcv_pipes</a></div><div class="ttdeci">boost::array&lt; std::optional&lt; Msg_in_pipe &gt;, 2 &gt; m_rcv_pipes</div><div class="ttdoc">1 or 2 active (via optional) structs containing policy and state w/r/t receipt of low-level (unstruct...</div><div class="ttdef"><b>Definition:</b> <a href="ipc__transport__structured_2src_2ipc_2transport_2struc_2sync__io_2channel_8hpp_source.html#l01922">channel.hpp:1922</a></div></div>
<div class="ttc" id="aclassipc_1_1transport_1_1struc_1_1sync__io_1_1Channel_html_a9d3344a97644dad136bb47e852dda6fd"><div class="ttname"><a href="classipc_1_1transport_1_1struc_1_1sync__io_1_1Channel.html#a9d3344a97644dad136bb47e852dda6fd">ipc::transport::struc::sync_io::Channel::Rcv_next_step</a></div><div class="ttdeci">Rcv_next_step</div><div class="ttdoc">Upon receiving an unstructured message along 1 given pipe of Owned_channel this indicates the next su...</div><div class="ttdef"><b>Definition:</b> <a href="ipc__transport__structured_2src_2ipc_2transport_2struc_2sync__io_2channel_8hpp_source.html#l01409">channel.hpp:1410</a></div></div>
<div class="ttc" id="aclassipc_1_1transport_1_1struc_1_1sync__io_1_1Channel_html_a9d7fc428bc293e993fe96428c44bfb4c"><div class="ttname"><a href="classipc_1_1transport_1_1struc_1_1sync__io_1_1Channel.html#a9d7fc428bc293e993fe96428c44bfb4c">ipc::transport::struc::sync_io::Channel::m_protocol_negotiator_aux</a></div><div class="ttdeci">Protocol_negotiator m_protocol_negotiator_aux</div><div class="ttdoc">Handles the protocol negotiation at the start of the pipe, as pertains to algorithms perpetuated outs...</div><div class="ttdef"><b>Definition:</b> <a href="ipc__transport__structured_2src_2ipc_2transport_2struc_2sync__io_2channel_8hpp_source.html#l01893">channel.hpp:1893</a></div></div>
<div class="ttc" id="aclassipc_1_1transport_1_1struc_1_1sync__io_1_1Channel_html_a9d97a5900bd517596b763db2d6b27b45"><div class="ttname"><a href="classipc_1_1transport_1_1struc_1_1sync__io_1_1Channel.html#a9d97a5900bd517596b763db2d6b27b45">ipc::transport::struc::sync_io::Channel::owned_channel_mutable</a></div><div class="ttdeci">Owned_channel * owned_channel_mutable()</div><div class="ttdoc">See Async_io_obj counterpart.</div><div class="ttdef"><b>Definition:</b> <a href="ipc__transport__structured_2src_2ipc_2transport_2struc_2sync__io_2channel_8hpp_source.html#l05055">channel.hpp:5055</a></div></div>
<div class="ttc" id="aclassipc_1_1transport_1_1struc_1_1sync__io_1_1Channel_html_aa14373afb4601567d1640f7b0b3faa45"><div class="ttname"><a href="classipc_1_1transport_1_1struc_1_1sync__io_1_1Channel.html#aa14373afb4601567d1640f7b0b3faa45">ipc::transport::struc::sync_io::Channel::m_phase_log_in_started</a></div><div class="ttdeci">bool m_phase_log_in_started</div><div class="ttdoc">Used when m_phase is Phase::S_SRV_LOG_IN, this starts false and is changed to true at thread-U call o...</div><div class="ttdef"><b>Definition:</b> <a href="ipc__transport__structured_2src_2ipc_2transport_2struc_2sync__io_2channel_8hpp_source.html#l01980">channel.hpp:1980</a></div></div>
<div class="ttc" id="aclassipc_1_1transport_1_1struc_1_1sync__io_1_1Channel_html_aa210976b523c04042dd083f054182441"><div class="ttname"><a href="classipc_1_1transport_1_1struc_1_1sync__io_1_1Channel.html#aa210976b523c04042dd083f054182441">ipc::transport::struc::sync_io::Channel::rcv_struct_new_msg_in</a></div><div class="ttdeci">bool rcv_struct_new_msg_in(Msg_in_ptr_uniq &amp;&amp;msg_in)</div><div class="ttdoc">Helper from rcv_on_async_read_*(), processes a newly completed structured in-message,...</div><div class="ttdef"><b>Definition:</b> <a href="ipc__transport__structured_2src_2ipc_2transport_2struc_2sync__io_2channel_8hpp_source.html#l03323">channel.hpp:3323</a></div></div>
<div class="ttc" id="aclassipc_1_1transport_1_1struc_1_1sync__io_1_1Channel_html_aa40c3ec3f45cdfea9360f7f35b9ade3c"><div class="ttname"><a href="classipc_1_1transport_1_1struc_1_1sync__io_1_1Channel.html#aa40c3ec3f45cdfea9360f7f35b9ade3c">ipc::transport::struc::sync_io::Channel::Msg_which_in</a></div><div class="ttdeci">Msg_which Msg_which_in</div><div class="ttdoc">See Async_io_obj counterpart.</div><div class="ttdef"><b>Definition:</b> <a href="ipc__transport__structured_2src_2ipc_2transport_2struc_2sync__io_2channel_8hpp_source.html#l00355">channel.hpp:355</a></div></div>
<div class="ttc" id="aclassipc_1_1transport_1_1struc_1_1sync__io_1_1Channel_html_aa4cd0e7c721ee3af4d1faa2ada5ad646"><div class="ttname"><a href="classipc_1_1transport_1_1struc_1_1sync__io_1_1Channel.html#aa4cd0e7c721ee3af4d1faa2ada5ad646">ipc::transport::struc::sync_io::Channel::m_struct_lender_session</a></div><div class="ttdeci">const Builder_config::Builder::Session m_struct_lender_session</div><div class="ttdoc">Value (possibly of size 0 depending on this type) to pass to Msg_out::emit_serialization() to indicat...</div><div class="ttdef"><b>Definition:</b> <a href="ipc__transport__structured_2src_2ipc_2transport_2struc_2sync__io_2channel_8hpp_source.html#l01870">channel.hpp:1870</a></div></div>
<div class="ttc" id="aclassipc_1_1transport_1_1struc_1_1sync__io_1_1Channel_html_aa83fd6e35057876e2f5173df53e73371"><div class="ttname"><a href="classipc_1_1transport_1_1struc_1_1sync__io_1_1Channel.html#aa83fd6e35057876e2f5173df53e73371">ipc::transport::struc::sync_io::Channel::rcv_on_async_read_continuation_msg</a></div><div class="ttdeci">Rcv_next_step rcv_on_async_read_continuation_msg(Msg_in_pipe *pipe, const Error_code &amp;err_code, size_t sz)</div><div class="ttdoc">Same as rcv_on_async_read_lead_msg() but for an expected continuation message instead of lead.</div><div class="ttdef"><b>Definition:</b> <a href="ipc__transport__structured_2src_2ipc_2transport_2struc_2sync__io_2channel_8hpp_source.html#l03056">channel.hpp:3056</a></div></div>
<div class="ttc" id="aclassipc_1_1transport_1_1struc_1_1sync__io_1_1Channel_html_aac7386bca503f1457d93c65e1bfdf71f"><div class="ttname"><a href="classipc_1_1transport_1_1struc_1_1sync__io_1_1Channel.html#aac7386bca503f1457d93c65e1bfdf71f">ipc::transport::struc::sync_io::Channel::~Channel</a></div><div class="ttdeci">~Channel()</div><div class="ttdoc">Invokes the destructor on the Owned_channel.</div><div class="ttdef"><b>Definition:</b> <a href="ipc__transport__structured_2src_2ipc_2transport_2struc_2sync__io_2channel_8hpp_source.html#l02375">channel.hpp:2375</a></div></div>
<div class="ttc" id="aclassipc_1_1transport_1_1struc_1_1sync__io_1_1Channel_html_aad25fed4c22117bf07c45240f790d306"><div class="ttname"><a href="classipc_1_1transport_1_1struc_1_1sync__io_1_1Channel.html#aad25fed4c22117bf07c45240f790d306">ipc::transport::struc::sync_io::Channel::m_protocol_negotiator</a></div><div class="ttdeci">Protocol_negotiator m_protocol_negotiator</div><div class="ttdoc">Handles the protocol negotiation at the start of the pipe, as pertains to algorithms perpetuated by *...</div><div class="ttdef"><b>Definition:</b> <a href="ipc__transport__structured_2src_2ipc_2transport_2struc_2sync__io_2channel_8hpp_source.html#l01884">channel.hpp:1884</a></div></div>
<div class="ttc" id="aclassipc_1_1transport_1_1struc_1_1sync__io_1_1Channel_html_aafaf244b9483c724eaba1d6bee561035"><div class="ttname"><a href="classipc_1_1transport_1_1struc_1_1sync__io_1_1Channel.html#aafaf244b9483c724eaba1d6bee561035">ipc::transport::struc::sync_io::Channel::send_impl</a></div><div class="ttdeci">bool send_impl(const Msg_out &amp;msg, const Msg_in *originating_msg_or_null, Error_code *err_code, const On_msg_func_ptr &amp;on_rsp_func_or_null, msg_id_out_t *id_unless_one_off)</div><div class="ttdoc">send() and async_request() implementation.</div><div class="ttdef"><b>Definition:</b> <a href="ipc__transport__structured_2src_2ipc_2transport_2struc_2sync__io_2channel_8hpp_source.html#l04223">channel.hpp:4223</a></div></div>
<div class="ttc" id="aclassipc_1_1transport_1_1struc_1_1sync__io_1_1Channel_html_ab17b00ae995cf634c721420cd85fdef2"><div class="ttname"><a href="classipc_1_1transport_1_1struc_1_1sync__io_1_1Channel.html#ab17b00ae995cf634c721420cd85fdef2">ipc::transport::struc::sync_io::Channel::handle_async_err_code</a></div><div class="ttdeci">bool handle_async_err_code(const Error_code &amp;err_code, util::String_view context)</div><div class="ttdoc">Helper for async handlers: returns true if and only if err_code indicates a new error or m_channel_er...</div><div class="ttdef"><b>Definition:</b> <a href="ipc__transport__structured_2src_2ipc_2transport_2struc_2sync__io_2channel_8hpp_source.html#l04073">channel.hpp:4073</a></div></div>
<div class="ttc" id="aclassipc_1_1transport_1_1struc_1_1sync__io_1_1Channel_html_ab8bfe06a0aecb261dd11624c4ddec518"><div class="ttname"><a href="classipc_1_1transport_1_1struc_1_1sync__io_1_1Channel.html#ab8bfe06a0aecb261dd11624c4ddec518">ipc::transport::struc::sync_io::Channel::rcv_struct_new_internal_msg_in</a></div><div class="ttdeci">bool rcv_struct_new_internal_msg_in(const Msg_in_impl &amp;msg_in)</div><div class="ttdoc">Helper from rcv_struct_new_msg_in(): the case where the in-message has a sentinel message ID value,...</div><div class="ttdef"><b>Definition:</b> <a href="ipc__transport__structured_2src_2ipc_2transport_2struc_2sync__io_2channel_8hpp_source.html#l03658">channel.hpp:3658</a></div></div>
<div class="ttc" id="aclassipc_1_1transport_1_1struc_1_1sync__io_1_1Channel_html_abb3be9330a898ce542afd778d8e42a49"><div class="ttname"><a href="classipc_1_1transport_1_1struc_1_1sync__io_1_1Channel.html#abb3be9330a898ce542afd778d8e42a49">ipc::transport::struc::sync_io::Channel::On_unexpected_response_func</a></div><div class="ttdeci">Function&lt; void(Msg_in_ptr &amp;&amp;msg)&gt; On_unexpected_response_func</div><div class="ttdoc">Concrete type corresponding to On_unexpected_response_handler template param (see set_unexpected_resp...</div><div class="ttdef"><b>Definition:</b> <a href="ipc__transport__structured_2src_2ipc_2transport_2struc_2sync__io_2channel_8hpp_source.html#l01053">channel.hpp:1053</a></div></div>
<div class="ttc" id="aclassipc_1_1transport_1_1struc_1_1sync__io_1_1Channel_html_abe17c6f98af890eaf522c97eb21e2e35"><div class="ttname"><a href="classipc_1_1transport_1_1struc_1_1sync__io_1_1Channel.html#abe17c6f98af890eaf522c97eb21e2e35">ipc::transport::struc::sync_io::Channel::m_channel</a></div><div class="ttdeci">Owned_channel m_channel</div><div class="ttdoc">The Channel taken-over in ctor, lifetime until dtor.</div><div class="ttdef"><b>Definition:</b> <a href="ipc__transport__structured_2src_2ipc_2transport_2struc_2sync__io_2channel_8hpp_source.html#l02098">channel.hpp:2098</a></div></div>
<div class="ttc" id="aclassipc_1_1transport_1_1struc_1_1sync__io_1_1Channel_html_abeb37ac07422166123553920393d5ab4"><div class="ttname"><a href="classipc_1_1transport_1_1struc_1_1sync__io_1_1Channel.html#abeb37ac07422166123553920393d5ab4">ipc::transport::struc::sync_io::Channel::check_prior_error</a></div><div class="ttdeci">bool check_prior_error(util::String_view context) const</div><div class="ttdoc">Helper for some public APIs to use at the top: ensures that no prior error has been detected (by inco...</div><div class="ttdef"><b>Definition:</b> <a href="ipc__transport__structured_2src_2ipc_2transport_2struc_2sync__io_2channel_8hpp_source.html#l04687">channel.hpp:4687</a></div></div>
<div class="ttc" id="aclassipc_1_1transport_1_1struc_1_1sync__io_1_1Channel_html_abf9a2118d887439717e17d0515be3e43"><div class="ttname"><a href="classipc_1_1transport_1_1struc_1_1sync__io_1_1Channel.html#abf9a2118d887439717e17d0515be3e43">ipc::transport::struc::sync_io::Channel::m_rcv_expecting_response_map</a></div><div class="ttdeci">Expecting_response_map m_rcv_expecting_response_map</div><div class="ttdoc">Map storing current policy for expecting responses. See Expecting_response_map doc header for details...</div><div class="ttdef"><b>Definition:</b> <a href="ipc__transport__structured_2src_2ipc_2transport_2struc_2sync__io_2channel_8hpp_source.html#l02001">channel.hpp:2001</a></div></div>
<div class="ttc" id="aclassipc_1_1transport_1_1struc_1_1sync__io_1_1Channel_html_ac8ba5f1a26a9f3e881b4871b0f6aa990"><div class="ttname"><a href="classipc_1_1transport_1_1struc_1_1sync__io_1_1Channel.html#ac8ba5f1a26a9f3e881b4871b0f6aa990">ipc::transport::struc::sync_io::Channel::undo_expect_msgs</a></div><div class="ttdeci">bool undo_expect_msgs(Msg_which_in which)</div><div class="ttdoc">See Async_io_obj counterpart.</div><div class="ttdef"><b>Definition:</b> <a href="ipc__transport__structured_2src_2ipc_2transport_2struc_2sync__io_2channel_8hpp_source.html#l04934">channel.hpp:4934</a></div></div>
<div class="ttc" id="aclassipc_1_1transport_1_1struc_1_1sync__io_1_1Channel_html_acde2b3866547a30958035203d9d89928"><div class="ttname"><a href="classipc_1_1transport_1_1struc_1_1sync__io_1_1Channel.html#acde2b3866547a30958035203d9d89928">ipc::transport::struc::sync_io::Channel::Msg_in_ptr</a></div><div class="ttdeci">boost::shared_ptr&lt; Msg_in &gt; Msg_in_ptr</div><div class="ttdoc">See Async_io_obj counterpart.</div><div class="ttdef"><b>Definition:</b> <a href="ipc__transport__structured_2src_2ipc_2transport_2struc_2sync__io_2channel_8hpp_source.html#l00367">channel.hpp:367</a></div></div>
<div class="ttc" id="aclassipc_1_1transport_1_1struc_1_1sync__io_1_1Channel_html_ad1fcc872d76e6a59321f5d67b2e0a70b"><div class="ttname"><a href="classipc_1_1transport_1_1struc_1_1sync__io_1_1Channel.html#ad1fcc872d76e6a59321f5d67b2e0a70b">ipc::transport::struc::sync_io::Channel::m_on_err_func</a></div><div class="ttdeci">flow::async::Task_asio_err m_on_err_func</div><div class="ttdoc">The channel-hosed error reporting handler.</div><div class="ttdef"><b>Definition:</b> <a href="ipc__transport__structured_2src_2ipc_2transport_2struc_2sync__io_2channel_8hpp_source.html#l01914">channel.hpp:1914</a></div></div>
<div class="ttc" id="aclassipc_1_1transport_1_1struc_1_1sync__io_1_1Channel_html_ad3f5d174c65db9d5ec3b14769fb9574a"><div class="ttname"><a href="classipc_1_1transport_1_1struc_1_1sync__io_1_1Channel.html#ad3f5d174c65db9d5ec3b14769fb9574a">ipc::transport::struc::sync_io::Channel::handle_new_error</a></div><div class="ttdeci">void handle_new_error(const Error_code &amp;err_code_not_ok, util::String_view context)</div><div class="ttdoc">Helper that handles the situation where m_channel_err_code_or_ok is falsy, and processing has found a...</div><div class="ttdef"><b>Definition:</b> <a href="ipc__transport__structured_2src_2ipc_2transport_2struc_2sync__io_2channel_8hpp_source.html#l04108">channel.hpp:4108</a></div></div>
<div class="ttc" id="aclassipc_1_1transport_1_1struc_1_1sync__io_1_1Channel_html_ad77261f31055f4151c70225c3fa1da2e"><div class="ttname"><a href="classipc_1_1transport_1_1struc_1_1sync__io_1_1Channel.html#ad77261f31055f4151c70225c3fa1da2e">ipc::transport::struc::sync_io::Channel::msg_id_in_t</a></div><div class="ttdeci">msg_id_t msg_id_in_t</div><div class="ttdoc">Clarifying short-hand for incoming-message IDs.</div><div class="ttdef"><b>Definition:</b> <a href="ipc__transport__structured_2src_2ipc_2transport_2struc_2sync__io_2channel_8hpp_source.html#l01041">channel.hpp:1041</a></div></div>
<div class="ttc" id="aclassipc_1_1transport_1_1struc_1_1sync__io_1_1Channel_html_ae2a7cdf855b3cdcab1a2e1cd74834cc4"><div class="ttname"><a href="classipc_1_1transport_1_1struc_1_1sync__io_1_1Channel.html#ae2a7cdf855b3cdcab1a2e1cd74834cc4">ipc::transport::struc::sync_io::Channel::check_not_started_ops</a></div><div class="ttdeci">bool check_not_started_ops(util::String_view context) const</div><div class="ttdoc">Helper that returns true if and only if start_ops() has not yet been called.</div><div class="ttdef"><b>Definition:</b> <a href="ipc__transport__structured_2src_2ipc_2transport_2struc_2sync__io_2channel_8hpp_source.html#l02508">channel.hpp:2508</a></div></div>
<div class="ttc" id="aclassipc_1_1transport_1_1struc_1_1sync__io_1_1Channel_html_ae43681c46951acd7e3c06d3cd73854f6"><div class="ttname"><a href="classipc_1_1transport_1_1struc_1_1sync__io_1_1Channel.html#ae43681c46951acd7e3c06d3cd73854f6">ipc::transport::struc::sync_io::Channel::check_unsendable</a></div><div class="ttdeci">bool check_unsendable(const Msg_out &amp;msg) const</div><div class="ttdoc">send() and async_request() helper that returns true if and only if msg contains a native handle,...</div><div class="ttdef"><b>Definition:</b> <a href="ipc__transport__structured_2src_2ipc_2transport_2struc_2sync__io_2channel_8hpp_source.html#l04151">channel.hpp:4151</a></div></div>
<div class="ttc" id="aclassipc_1_1transport_1_1struc_1_1sync__io_1_1Channel_html_ae4a2a63dc88722d96ee9f3ed68cf7b86"><div class="ttname"><a href="classipc_1_1transport_1_1struc_1_1sync__io_1_1Channel.html#ae4a2a63dc88722d96ee9f3ed68cf7b86">ipc::transport::struc::sync_io::Channel::async_end_sending</a></div><div class="ttdeci">bool async_end_sending(Error_code *sync_err_code, Task_err &amp;&amp;on_done_func)</div><div class="ttdoc">See Async_io_obj counterpart; except (1) naturally on_done_func() is invoked in the sync_io-pattern f...</div><div class="ttdef"><b>Definition:</b> <a href="ipc__transport__structured_2src_2ipc_2transport_2struc_2sync__io_2channel_8hpp_source.html#l04675">channel.hpp:4675</a></div></div>
<div class="ttc" id="aclassipc_1_1transport_1_1struc_1_1sync__io_1_1Channel_html_ae6b2691d6471330d8b7cc7e8e9320054"><div class="ttname"><a href="classipc_1_1transport_1_1struc_1_1sync__io_1_1Channel.html#ae6b2691d6471330d8b7cc7e8e9320054">ipc::transport::struc::sync_io::Channel::check_phase_and_prior_error</a></div><div class="ttdeci">bool check_phase_and_prior_error(Phase required_phase, util::String_view context) const</div><div class="ttdoc">Helper for most public APIs to use at the top: ensures check_prior_error() passes,...</div><div class="ttdef"><b>Definition:</b> <a href="ipc__transport__structured_2src_2ipc_2transport_2struc_2sync__io_2channel_8hpp_source.html#l04701">channel.hpp:4701</a></div></div>
<div class="ttc" id="aclassipc_1_1transport_1_1struc_1_1sync__io_1_1Channel_html_ae9f5a798718d98523342acf55400d628"><div class="ttname"><a href="classipc_1_1transport_1_1struc_1_1sync__io_1_1Channel.html#ae9f5a798718d98523342acf55400d628">ipc::transport::struc::sync_io::Channel::m_rcv_pending_msgs</a></div><div class="ttdeci">boost::unordered_map&lt; Msg_which_in, Msg_in_q &gt; m_rcv_pending_msgs</div><div class="ttdoc">Queues of in-messages, keyed by Msg_which_in, each in msg_id_in_t (sequence #) order,...</div><div class="ttdef"><b>Definition:</b> <a href="ipc__transport__structured_2src_2ipc_2transport_2struc_2sync__io_2channel_8hpp_source.html#l02089">channel.hpp:2089</a></div></div>
<div class="ttc" id="aclassipc_1_1transport_1_1struc_1_1sync__io_1_1Channel_html_af546fc0ab4d0ddca0a857c57decd0620"><div class="ttname"><a href="classipc_1_1transport_1_1struc_1_1sync__io_1_1Channel.html#af546fc0ab4d0ddca0a857c57decd0620">ipc::transport::struc::sync_io::Channel::rcv_on_async_read_lead_msg</a></div><div class="ttdeci">Rcv_next_step rcv_on_async_read_lead_msg(Msg_in_pipe *pipe, const Error_code &amp;err_code, size_t sz)</div><div class="ttdoc">To execute upon completing an m_channel.async_receive_*() of an expected lead message along the given...</div><div class="ttdef"><b>Definition:</b> <a href="ipc__transport__structured_2src_2ipc_2transport_2struc_2sync__io_2channel_8hpp_source.html#l02912">channel.hpp:2912</a></div></div>
<div class="ttc" id="aclassipc_1_1transport_1_1struc_1_1sync__io_1_1Channel_html_af7ac60b2b7a7baf26a96cf4635d4c320"><div class="ttname"><a href="classipc_1_1transport_1_1struc_1_1sync__io_1_1Channel.html#af7ac60b2b7a7baf26a96cf4635d4c320">ipc::transport::struc::sync_io::Channel::m_struct_reader_config</a></div><div class="ttdeci">const Reader_config m_struct_reader_config</div><div class="ttdoc">Analogous to m_struct_builder_config but for deserialization.</div><div class="ttdef"><b>Definition:</b> <a href="ipc__transport__structured_2src_2ipc_2transport_2struc_2sync__io_2channel_8hpp_source.html#l01876">channel.hpp:1876</a></div></div>
<div class="ttc" id="aclassipc_1_1transport_1_1struc_1_1sync__io_1_1Channel_html_afca9a3012b2f41d635381a5a13ddd7c1"><div class="ttname"><a href="classipc_1_1transport_1_1struc_1_1sync__io_1_1Channel.html#afca9a3012b2f41d635381a5a13ddd7c1">ipc::transport::struc::sync_io::Channel::m_phase</a></div><div class="ttdeci">Phase m_phase</div><div class="ttdoc">Phase (w/r/t log-in or lack thereof) of *this peer.</div><div class="ttdef"><b>Definition:</b> <a href="ipc__transport__structured_2src_2ipc_2transport_2struc_2sync__io_2channel_8hpp_source.html#l01973">channel.hpp:1973</a></div></div>
<div class="ttc" id="aclassipc_1_1transport_1_1struc_1_1sync__io_1_1Channel_html_aff04d908fa53c7df582f3b2b6e51cfce"><div class="ttname"><a href="classipc_1_1transport_1_1struc_1_1sync__io_1_1Channel.html#aff04d908fa53c7df582f3b2b6e51cfce">ipc::transport::struc::sync_io::Channel::rcv_struct_new_msg_in_during_log_in_as_cli</a></div><div class="ttdeci">bool rcv_struct_new_msg_in_during_log_in_as_cli(Msg_in_ptr_uniq &amp;&amp;msg_in)</div><div class="ttdoc">Helper from rcv_struct_new_msg_in(): the case where m_phase is Phase::S_CLI_LOG_IN,...</div><div class="ttdef"><b>Definition:</b> <a href="ipc__transport__structured_2src_2ipc_2transport_2struc_2sync__io_2channel_8hpp_source.html#l03718">channel.hpp:3718</a></div></div>
<div class="ttc" id="aclassipc_1_1util_1_1sync__io_1_1Asio__waitable__native__handle_html"><div class="ttname"><a href="classipc_1_1util_1_1sync__io_1_1Asio__waitable__native__handle.html">ipc::util::sync_io::Asio_waitable_native_handle</a></div><div class="ttdoc">Useful if using the sync_io pattern within a user event loop built on boost.asio (optionally with flo...</div><div class="ttdef"><b>Definition:</b> <a href="asio__waitable__native__hndl_8hpp_source.html#l00080">asio_waitable_native_hndl.hpp:81</a></div></div>
<div class="ttc" id="aheap__serializer_8hpp_html"><div class="ttname"><a href="heap__serializer_8hpp.html">heap_serializer.hpp</a></div></div>
<div class="ttc" id="aipc__core_2src_2ipc_2transport_2channel_8hpp_html"><div class="ttname"><a href="ipc__core_2src_2ipc_2transport_2channel_8hpp.html">channel.hpp</a></div></div>
<div class="ttc" id="aipc__core_2src_2ipc_2transport_2error_8hpp_html"><div class="ttname"><a href="ipc__core_2src_2ipc_2transport_2error_8hpp.html">error.hpp</a></div></div>
<div class="ttc" id="aipc__transport__structured_2src_2ipc_2transport_2struc_2sync__io_2channel_8hpp_html_a50e1bb663274c68c760263342ddfdcbc"><div class="ttname"><a href="ipc__transport__structured_2src_2ipc_2transport_2struc_2sync__io_2channel_8hpp.html#a50e1bb663274c68c760263342ddfdcbc">TEMPLATE_SIO_STRUCT_CHANNEL</a></div><div class="ttdeci">#define TEMPLATE_SIO_STRUCT_CHANNEL</div><div class="ttdoc">Internally used macro; public API users should disregard (same deal as in ../structured_channel....</div><div class="ttdef"><b>Definition:</b> <a href="ipc__transport__structured_2src_2ipc_2transport_2struc_2sync__io_2channel_8hpp_source.html#l02194">channel.hpp:2194</a></div></div>
<div class="ttc" id="aipc__transport__structured_2src_2ipc_2transport_2struc_2sync__io_2channel_8hpp_html_aefc68934c89912e7b5d0706bdb2be6e5"><div class="ttname"><a href="ipc__transport__structured_2src_2ipc_2transport_2struc_2sync__io_2channel_8hpp.html#aefc68934c89912e7b5d0706bdb2be6e5">CLASS_SIO_STRUCT_CHANNEL</a></div><div class="ttdeci">#define CLASS_SIO_STRUCT_CHANNEL</div><div class="ttdoc">Internally used macro; public API users should disregard (same deal as in ../structured_channel....</div><div class="ttdef"><b>Definition:</b> <a href="ipc__transport__structured_2src_2ipc_2transport_2struc_2sync__io_2channel_8hpp_source.html#l02198">channel.hpp:2198</a></div></div>
<div class="ttc" id="amsg__impl_8hpp_html"><div class="ttname"><a href="msg__impl_8hpp.html">msg_impl.hpp</a></div></div>
<div class="ttc" id="amsg__mdt__out_8hpp_html"><div class="ttname"><a href="msg__mdt__out_8hpp.html">msg_mdt_out.hpp</a></div></div>
<div class="ttc" id="anamespaceipc_1_1transport_1_1error_html_adfef15ef4e76cc55d652fbd9c2797297a42d41c622e92e9053177ba73e75633fe"><div class="ttname"><a href="namespaceipc_1_1transport_1_1error.html#adfef15ef4e76cc55d652fbd9c2797297a42d41c622e92e9053177ba73e75633fe">ipc::transport::error::Code::S_SENDS_FINISHED_CANNOT_SEND</a></div><div class="ttdeci">@ S_SENDS_FINISHED_CANNOT_SEND</div><div class="ttdoc">Will not send message: local user already ended sending via API marking this.</div></div>
<div class="ttc" id="anamespaceipc_1_1transport_1_1error_html_adfef15ef4e76cc55d652fbd9c2797297aa667487757f9d6300f6888bac40bcc24"><div class="ttname"><a href="namespaceipc_1_1transport_1_1error.html#adfef15ef4e76cc55d652fbd9c2797297aa667487757f9d6300f6888bac40bcc24">ipc::transport::error::Code::S_SYNC_IO_WOULD_BLOCK</a></div><div class="ttdeci">@ S_SYNC_IO_WOULD_BLOCK</div><div class="ttdoc">A sync_io operation could not immediately complete; it will complete contingent on active async-wait ...</div></div>
<div class="ttc" id="anamespaceipc_1_1transport_1_1error_html_adfef15ef4e76cc55d652fbd9c2797297afe29343445a7bf167cc186a44bd2c6ed"><div class="ttname"><a href="namespaceipc_1_1transport_1_1error.html#adfef15ef4e76cc55d652fbd9c2797297afe29343445a7bf167cc186a44bd2c6ed">ipc::transport::error::Code::S_OBJECT_SHUTDOWN_ABORTED_COMPLETION_HANDLER</a></div><div class="ttdeci">@ S_OBJECT_SHUTDOWN_ABORTED_COMPLETION_HANDLER</div><div class="ttdoc">Async completion handler is being called prematurely, because underlying object is shutting down,...</div></div>
<div class="ttc" id="anamespaceipc_1_1transport_1_1struc_1_1error_html_a990b9ff850cf9aaf354efdd07d86a71da26ab25e100104aeb567d90f794313e3b"><div class="ttname"><a href="namespaceipc_1_1transport_1_1struc_1_1error.html#a990b9ff850cf9aaf354efdd07d86a71da26ab25e100104aeb567d90f794313e3b">ipc::transport::struc::error::Code::S_STRUCT_CHANNEL_INTERNAL_PROTOCOL_MISUSED_SCHEMA</a></div><div class="ttdeci">@ S_STRUCT_CHANNEL_INTERNAL_PROTOCOL_MISUSED_SCHEMA</div><div class="ttdoc">Structured channel: received structured message with invalid internally-set/used fields.</div></div>
<div class="ttc" id="anamespaceipc_1_1transport_1_1struc_1_1error_html_a990b9ff850cf9aaf354efdd07d86a71da2fba90660c799be216d283a3129f1f63"><div class="ttname"><a href="namespaceipc_1_1transport_1_1struc_1_1error.html#a990b9ff850cf9aaf354efdd07d86a71da2fba90660c799be216d283a3129f1f63">ipc::transport::struc::error::Code::S_STRUCT_CHANNEL_INTERNAL_PROTOCOL_BAD_AUTH</a></div><div class="ttdeci">@ S_STRUCT_CHANNEL_INTERNAL_PROTOCOL_BAD_AUTH</div><div class="ttdoc">Structured channel: auth session token in in-message does not match expected value established during...</div></div>
<div class="ttc" id="anamespaceipc_1_1transport_1_1struc_1_1error_html_a990b9ff850cf9aaf354efdd07d86a71da64f092d17e34549f74d37f8f03c98954"><div class="ttname"><a href="namespaceipc_1_1transport_1_1struc_1_1error.html#a990b9ff850cf9aaf354efdd07d86a71da64f092d17e34549f74d37f8f03c98954">ipc::transport::struc::error::Code::S_STRUCT_CHANNEL_INTERNAL_PROTOCOL_MISMATCH_GOT_HNDL</a></div><div class="ttdeci">@ S_STRUCT_CHANNEL_INTERNAL_PROTOCOL_MISMATCH_GOT_HNDL</div><div class="ttdoc">Structured channel: received unexpected payload: continuation message contains native handle.</div></div>
<div class="ttc" id="anamespaceipc_1_1transport_1_1struc_1_1error_html_a990b9ff850cf9aaf354efdd07d86a71da86f9bea5b4ceda65e11b2a3ec7e389f7"><div class="ttname"><a href="namespaceipc_1_1transport_1_1struc_1_1error.html#a990b9ff850cf9aaf354efdd07d86a71da86f9bea5b4ceda65e11b2a3ec7e389f7">ipc::transport::struc::error::Code::S_STRUCT_CHANNEL_INTERNAL_PROTOCOL_INTERNAL_MSG_TYPE_UNKNOWN</a></div><div class="ttdeci">@ S_STRUCT_CHANNEL_INTERNAL_PROTOCOL_INTERNAL_MSG_TYPE_UNKNOWN</div><div class="ttdoc">Structured channel: in internally-generated message the internal message type is unknown.</div></div>
<div class="ttc" id="anamespaceipc_1_1transport_1_1struc_1_1error_html_a990b9ff850cf9aaf354efdd07d86a71daab47c241a659164b808ddba23736d02b"><div class="ttname"><a href="namespaceipc_1_1transport_1_1struc_1_1error.html#a990b9ff850cf9aaf354efdd07d86a71daab47c241a659164b808ddba23736d02b">ipc::transport::struc::error::Code::S_STRUCT_CHANNEL_INTERNAL_PROTOCOL_LOG_IN_MISUSED_SCHEMA</a></div><div class="ttdeci">@ S_STRUCT_CHANNEL_INTERNAL_PROTOCOL_LOG_IN_MISUSED_SCHEMA</div><div class="ttdoc">Structured channel: log-in phase: received structured message with invalid internally-set/used fields...</div></div>
<div class="ttc" id="anamespaceipc_1_1transport_1_1struc_1_1error_html_a990b9ff850cf9aaf354efdd07d86a71dad88bc7df9bd2dcdf4370585c912a9a61"><div class="ttname"><a href="namespaceipc_1_1transport_1_1struc_1_1error.html#a990b9ff850cf9aaf354efdd07d86a71dad88bc7df9bd2dcdf4370585c912a9a61">ipc::transport::struc::error::Code::S_STRUCT_CHANNEL_GOT_UNEXPECTED_LOG_IN_REQUEST</a></div><div class="ttdeci">@ S_STRUCT_CHANNEL_GOT_UNEXPECTED_LOG_IN_REQUEST</div><div class="ttdoc">Structured channel: log-in phase as server: actual log-in request contents differ from local user exp...</div></div>
<div class="ttc" id="anamespaceipc_1_1transport_1_1struc_1_1error_html_a990b9ff850cf9aaf354efdd07d86a71dadaf85866b948217cbf039a7b4f89dbd3"><div class="ttname"><a href="namespaceipc_1_1transport_1_1struc_1_1error.html#a990b9ff850cf9aaf354efdd07d86a71dadaf85866b948217cbf039a7b4f89dbd3">ipc::transport::struc::error::Code::S_STRUCT_CHANNEL_INTERNAL_PROTOCOL_MISMATCH_GOT_NO_HNDL</a></div><div class="ttdeci">@ S_STRUCT_CHANNEL_INTERNAL_PROTOCOL_MISMATCH_GOT_NO_HNDL</div><div class="ttdoc">Structured channel: received unexpected payload: message sans native handle along handles-only pipe.</div></div>
<div class="ttc" id="anamespaceipc_1_1transport_1_1struc_1_1error_html_a990b9ff850cf9aaf354efdd07d86a71dade89b3f5038a04f02d8f4ae68698a069"><div class="ttname"><a href="namespaceipc_1_1transport_1_1struc_1_1error.html#a990b9ff850cf9aaf354efdd07d86a71dade89b3f5038a04f02d8f4ae68698a069">ipc::transport::struc::error::Code::S_INTERNAL_ERROR_DESERIALIZE_TARGET_ALLOC_FAILED</a></div><div class="ttdeci">@ S_INTERNAL_ERROR_DESERIALIZE_TARGET_ALLOC_FAILED</div><div class="ttdoc">Structured message deserialization (e.g., when receiving from channel): Reader engine,...</div></div>
<div class="ttc" id="anamespaceipc_1_1transport_1_1struc_1_1error_html_a990b9ff850cf9aaf354efdd07d86a71dae77f8d36304752faf1a967c474457569"><div class="ttname"><a href="namespaceipc_1_1transport_1_1struc_1_1error.html#a990b9ff850cf9aaf354efdd07d86a71dae77f8d36304752faf1a967c474457569">ipc::transport::struc::error::Code::S_STRUCT_CHANNEL_INTERNAL_PROTOCOL_MISMATCH_GOT_NO_BLOB</a></div><div class="ttdeci">@ S_STRUCT_CHANNEL_INTERNAL_PROTOCOL_MISMATCH_GOT_NO_BLOB</div><div class="ttdoc">Structured channel: received unexpected payload: message with empty blob (not even an encoded length)...</div></div>
<div class="ttc" id="anamespaceipc_1_1transport_1_1struc_1_1shm_1_1classic_html_ac543b500a85f556564e592cbbefb6185"><div class="ttname"><a href="namespaceipc_1_1transport_1_1struc_1_1shm_1_1classic.html#ac543b500a85f556564e592cbbefb6185">ipc::transport::struc::shm::classic::Channel</a></div><div class="ttdeci">struc::Channel&lt; Channel_obj, Message_body, Builder::Config, Reader::Config &gt; Channel</div><div class="ttdoc">Convenience alias: Use this when constructing a struc::Channel with tag Channel_base::S_SERIALIZE_VIA...</div><div class="ttdef"><b>Definition:</b> <a href="transport_2struc_2shm_2classic_2classic_8hpp_source.html#l00041">classic.hpp:42</a></div></div>
<div class="ttc" id="anamespaceipc_1_1transport_1_1struc_1_1sync__io_html"><div class="ttname"><a href="namespaceipc_1_1transport_1_1struc_1_1sync__io.html">ipc::transport::struc::sync_io</a></div><div class="ttdoc">sync_io-pattern counterparts to async-I/O-pattern object types in parent namespace ipc::transport::st...</div><div class="ttdef"><b>Definition:</b> <a href="struc__fwd_8hpp_source.html#l00237">struc_fwd.hpp:238</a></div></div>
<div class="ttc" id="anamespaceipc_1_1transport_1_1struc_html_a6751c05fb6582a34c7c47ac470c4a48b"><div class="ttname"><a href="namespaceipc_1_1transport_1_1struc.html#a6751c05fb6582a34c7c47ac470c4a48b">ipc::transport::struc::Session_token</a></div><div class="ttdeci">boost::uuids::uuid Session_token</div><div class="ttdoc">A type used by struc::Channel for internal safety/security/auth needs.</div><div class="ttdef"><b>Definition:</b> <a href="struc__fwd_8hpp_source.html#l00113">struc_fwd.hpp:113</a></div></div>
<div class="ttc" id="anamespaceipc_1_1transport_1_1struc_html_a82a69eaa39cbe8a002de1266f1cbb5cb"><div class="ttname"><a href="namespaceipc_1_1transport_1_1struc.html#a82a69eaa39cbe8a002de1266f1cbb5cb">ipc::transport::struc::Segment_ptrs</a></div><div class="ttdeci">std::vector&lt; flow::util::Blob * &gt; Segment_ptrs</div><div class="ttdoc">Sequence of 1+ Blob pointers to blobs which must stay alive while these pointers may be dereferenced,...</div><div class="ttdef"><b>Definition:</b> <a href="struc__fwd_8hpp_source.html#l00122">struc_fwd.hpp:122</a></div></div>
<div class="ttc" id="anamespaceipc_1_1transport_1_1struc_html_ac70446757444f864afa21a5062bc5b0d"><div class="ttname"><a href="namespaceipc_1_1transport_1_1struc.html#ac70446757444f864afa21a5062bc5b0d">ipc::transport::struc::NULL_SESSION</a></div><div class="ttdeci">const Null_session NULL_SESSION</div><div class="ttdoc">The only necessary value of empty-type Null_session.</div><div class="ttdef"><b>Definition:</b> <a href="heap__serializer_8cpp_source.html#l00035">heap_serializer.cpp:35</a></div></div>
<div class="ttc" id="anamespaceipc_1_1transport_1_1struc_html_ad556d20a2aa2d52b83c7afb73951d47d"><div class="ttname"><a href="namespaceipc_1_1transport_1_1struc.html#ad556d20a2aa2d52b83c7afb73951d47d">ipc::transport::struc::NULL_SESSION_TOKEN</a></div><div class="ttdeci">const Session_token NULL_SESSION_TOKEN</div><div class="ttdoc">A value for which .is_nil() is true.</div><div class="ttdef"><b>Definition:</b> <a href="ipc__transport__structured_2src_2ipc_2transport_2struc_2channel_8cpp_source.html#l00035">channel.cpp:35</a></div></div>
<div class="ttc" id="anamespaceipc_1_1transport_1_1struc_html_ae272f248d74db0486c4d9411715db15d"><div class="ttname"><a href="namespaceipc_1_1transport_1_1struc.html#ae272f248d74db0486c4d9411715db15d">ipc::transport::struc::operator&lt;&lt;</a></div><div class="ttdeci">std::ostream &amp; operator&lt;&lt;(std::ostream &amp;os, const Heap_fixed_builder &amp;val)</div><div class="ttdoc">Prints string representation of the given Heap_fixed_builder to the given ostream.</div><div class="ttdef"><b>Definition:</b> <a href="heap__serializer_8cpp_source.html#l00132">heap_serializer.cpp:132</a></div></div>
<div class="ttc" id="anamespaceipc_1_1transport_1_1struc_html_af7f35fc7588d97a838274fa25700ead9"><div class="ttname"><a href="namespaceipc_1_1transport_1_1struc.html#af7f35fc7588d97a838274fa25700ead9">ipc::transport::struc::msg_id_t</a></div><div class="ttdeci">uint64_t msg_id_t</div><div class="ttdoc">Message ID uniquely identifying outgoing message (Msg_out, among all other Msg_outs),...</div><div class="ttdef"><b>Definition:</b> <a href="struc__fwd_8hpp_source.html#l00145">struc_fwd.hpp:145</a></div></div>
<div class="ttc" id="anamespaceipc_1_1transport_html_a7ee4551983d9df16ec16a3139bac50e8"><div class="ttname"><a href="namespaceipc_1_1transport.html#a7ee4551983d9df16ec16a3139bac50e8">ipc::transport::Native_handle</a></div><div class="ttdeci">util::Native_handle Native_handle</div><div class="ttdoc">Convenience alias for the commonly used type util::Native_handle.</div><div class="ttdef"><b>Definition:</b> <a href="transport__fwd_8hpp_source.html#l00081">transport_fwd.hpp:81</a></div></div>
<div class="ttc" id="anamespaceipc_1_1util_1_1sync__io_html_ac6973c71fc70c6d867b0f2255c642532"><div class="ttname"><a href="namespaceipc_1_1util_1_1sync__io.html#ac6973c71fc70c6d867b0f2255c642532">ipc::util::sync_io::Task_ptr</a></div><div class="ttdeci">boost::shared_ptr&lt; Task &gt; Task_ptr</div><div class="ttdoc">Short-hand for ref-counted pointer to a Function&lt;&gt; that takes no arguments and returns nothing; in pa...</div><div class="ttdef"><b>Definition:</b> <a href="sync__io__fwd_8hpp_source.html#l00585">sync_io_fwd.hpp:585</a></div></div>
<div class="ttc" id="anamespaceipc_1_1util_html_a31e67d3a017477a04b313927e2f2c733"><div class="ttname"><a href="namespaceipc_1_1util.html#a31e67d3a017477a04b313927e2f2c733">ipc::util::Task</a></div><div class="ttdeci">flow::async::Task Task</div><div class="ttdoc">Short-hand for polymorphic function (a-la std::function&lt;&gt;) that takes no arguments and returns nothin...</div><div class="ttdef"><b>Definition:</b> <a href="util__fwd_8hpp_source.html#l00116">util_fwd.hpp:116</a></div></div>
<div class="ttc" id="anamespaceipc_1_1util_html_ae6ac47812a90d1287c61e0b7de7bc4f5"><div class="ttname"><a href="namespaceipc_1_1util.html#ae6ac47812a90d1287c61e0b7de7bc4f5">ipc::util::String_view</a></div><div class="ttdeci">flow::util::String_view String_view</div><div class="ttdoc">Short-hand for Flow's String_view.</div><div class="ttdef"><b>Definition:</b> <a href="util__fwd_8hpp_source.html#l00109">util_fwd.hpp:109</a></div></div>
<div class="ttc" id="anamespaceipc_html_a4ccdeed058222c635745a4dc830e99f7"><div class="ttname"><a href="namespaceipc.html#a4ccdeed058222c635745a4dc830e99f7">ipc::Log_component</a></div><div class="ttdeci">Log_component</div><div class="ttdoc">The flow::log::Component payload enumeration containing various log components used by Flow-IPC inter...</div><div class="ttdef"><b>Definition:</b> <a href="common_8hpp_source.html#l00321">common.hpp:322</a></div></div>
<div class="ttc" id="anamespaceipc_html_aa3192e586cc45d3e7c22463bf2760f89"><div class="ttname"><a href="namespaceipc.html#aa3192e586cc45d3e7c22463bf2760f89">ipc::Error_code</a></div><div class="ttdeci">flow::Error_code Error_code</div><div class="ttdoc">Short-hand for flow::Error_code which is very common.</div><div class="ttdef"><b>Definition:</b> <a href="common_8hpp_source.html#l00297">common.hpp:297</a></div></div>
<div class="ttc" id="anamespaceipc_html_aa455c7f045059736578ca275fc1a851f"><div class="ttname"><a href="namespaceipc.html#aa455c7f045059736578ca275fc1a851f">ipc::Function</a></div><div class="ttdeci">flow::Function&lt; Signature &gt; Function</div><div class="ttdoc">Short-hand for polymorphic functor holder which is very common. This is essentially std::function.</div><div class="ttdef"><b>Definition:</b> <a href="common_8hpp_source.html#l00301">common.hpp:301</a></div></div>
<div class="ttc" id="astructipc_1_1transport_1_1struc_1_1Channel__base_1_1Serialize__via__app__shm_html"><div class="ttname"><a href="structipc_1_1transport_1_1struc_1_1Channel__base_1_1Serialize__via__app__shm.html">ipc::transport::struc::Channel_base::Serialize_via_app_shm</a></div><div class="ttdoc">Similar to Serialize_via_session_shm but assumes per-app-scope SHM-arena (as opposed to per-session-s...</div><div class="ttdef"><b>Definition:</b> <a href="channel__base_8hpp_source.html#l00152">channel_base.hpp:152</a></div></div>
<div class="ttc" id="astructipc_1_1transport_1_1struc_1_1Channel__base_1_1Serialize__via__heap_html"><div class="ttname"><a href="structipc_1_1transport_1_1struc_1_1Channel__base_1_1Serialize__via__heap.html">ipc::transport::struc::Channel_base::Serialize_via_heap</a></div><div class="ttdoc">Tag type for ctor selection: Backing memory for serialization comes from fixed-size segment allocatio...</div><div class="ttdef"><b>Definition:</b> <a href="channel__base_8hpp_source.html#l00077">channel_base.hpp:77</a></div></div>
<div class="ttc" id="astructipc_1_1transport_1_1struc_1_1Channel__base_1_1Serialize__via__session__shm_html"><div class="ttname"><a href="structipc_1_1transport_1_1struc_1_1Channel__base_1_1Serialize__via__session__shm.html">ipc::transport::struc::Channel_base::Serialize_via_session_shm</a></div><div class="ttdoc">Tag type for ctor selection: Backing RAM for serialization comes from a given session::Session's SHM ...</div><div class="ttdef"><b>Definition:</b> <a href="channel__base_8hpp_source.html#l00114">channel_base.hpp:114</a></div></div>
<div class="ttc" id="astructipc_1_1transport_1_1struc_1_1Heap__fixed__builder_1_1Config_html"><div class="ttname"><a href="structipc_1_1transport_1_1struc_1_1Heap__fixed__builder_1_1Config.html">ipc::transport::struc::Heap_fixed_builder::Config</a></div><div class="ttdoc">Implements Struct_builder::Config sub-concept.</div><div class="ttdef"><b>Definition:</b> <a href="heap__serializer_8hpp_source.html#l00154">heap_serializer.hpp:155</a></div></div>
<div class="ttc" id="astructipc_1_1transport_1_1struc_1_1Heap__reader_1_1Config_html"><div class="ttname"><a href="structipc_1_1transport_1_1struc_1_1Heap__reader_1_1Config.html">ipc::transport::struc::Heap_reader::Config</a></div><div class="ttdoc">Implements Struct_reader::Config sub-concept.</div><div class="ttdef"><b>Definition:</b> <a href="heap__serializer_8hpp_source.html#l00332">heap_serializer.hpp:333</a></div></div>
<div class="ttc" id="astructipc_1_1transport_1_1struc_1_1sync__io_1_1Channel_1_1Expecting__response_html"><div class="ttname"><a href="structipc_1_1transport_1_1struc_1_1sync__io_1_1Channel_1_1Expecting__response.html">ipc::transport::struc::sync_io::Channel::Expecting_response</a></div><div class="ttdoc">Policy for how to act upon receiving a response in-message that indicates its originating out-message...</div><div class="ttdef"><b>Definition:</b> <a href="ipc__transport__structured_2src_2ipc_2transport_2struc_2sync__io_2channel_8hpp_source.html#l01092">channel.hpp:1093</a></div></div>
<div class="ttc" id="astructipc_1_1transport_1_1struc_1_1sync__io_1_1Channel_1_1Expecting__response_html_a410ae0ef77010cfb5f90de9a90b25e92"><div class="ttname"><a href="structipc_1_1transport_1_1struc_1_1sync__io_1_1Channel_1_1Expecting__response.html#a410ae0ef77010cfb5f90de9a90b25e92">ipc::transport::struc::sync_io::Channel::Expecting_response::m_on_msg_func</a></div><div class="ttdeci">On_msg_func_ptr m_on_msg_func</div><div class="ttdoc">The handler to invoke on receiving a response to the requesting Msg_out (see send() response-expectin...</div><div class="ttdef"><b>Definition:</b> <a href="ipc__transport__structured_2src_2ipc_2transport_2struc_2sync__io_2channel_8hpp_source.html#l01114">channel.hpp:1114</a></div></div>
<div class="ttc" id="astructipc_1_1transport_1_1struc_1_1sync__io_1_1Channel_1_1Expecting__response_html_a5f68a8c574bf52f8fce42ea01c564923"><div class="ttname"><a href="structipc_1_1transport_1_1struc_1_1sync__io_1_1Channel_1_1Expecting__response.html#a5f68a8c574bf52f8fce42ea01c564923">ipc::transport::struc::sync_io::Channel::Expecting_response::Ptr</a></div><div class="ttdeci">boost::movelib::unique_ptr&lt; Expecting_response &gt; Ptr</div><div class="ttdoc">Short-hand to cheap handle type.</div><div class="ttdef"><b>Definition:</b> <a href="ipc__transport__structured_2src_2ipc_2transport_2struc_2sync__io_2channel_8hpp_source.html#l01097">channel.hpp:1097</a></div></div>
<div class="ttc" id="astructipc_1_1transport_1_1struc_1_1sync__io_1_1Channel_1_1Expecting__response_html_a615b5613ac4e2bc93be88b8835e6a22c"><div class="ttname"><a href="structipc_1_1transport_1_1struc_1_1sync__io_1_1Channel_1_1Expecting__response.html#a615b5613ac4e2bc93be88b8835e6a22c">ipc::transport::struc::sync_io::Channel::Expecting_response::m_one_expected</a></div><div class="ttdeci">bool m_one_expected</div><div class="ttdoc">true if receiving a response means request is satisfied; false if undo_expect_responses() must be inv...</div><div class="ttdef"><b>Definition:</b> <a href="ipc__transport__structured_2src_2ipc_2transport_2struc_2sync__io_2channel_8hpp_source.html#l01106">channel.hpp:1106</a></div></div>
<div class="ttc" id="astructipc_1_1transport_1_1struc_1_1sync__io_1_1Channel_1_1Msg__in__pipe_html"><div class="ttname"><a href="structipc_1_1transport_1_1struc_1_1sync__io_1_1Channel_1_1Msg__in__pipe.html">ipc::transport::struc::sync_io::Channel::Msg_in_pipe</a></div><div class="ttdoc">Data and policy with respect to receipt of the next/currently-incomplete in-message.</div><div class="ttdef"><b>Definition:</b> <a href="ipc__transport__structured_2src_2ipc_2transport_2struc_2sync__io_2channel_8hpp_source.html#l01275">channel.hpp:1276</a></div></div>
<div class="ttc" id="astructipc_1_1transport_1_1struc_1_1sync__io_1_1Channel_1_1Msg__in__pipe_html_a1b6834c271148af382c46ef948d1faab"><div class="ttname"><a href="structipc_1_1transport_1_1struc_1_1sync__io_1_1Channel_1_1Msg__in__pipe.html#a1b6834c271148af382c46ef948d1faab">ipc::transport::struc::sync_io::Channel::Msg_in_pipe::m_n_segs_left_after_this_read</a></div><div class="ttdeci">size_t m_n_segs_left_after_this_read</div><div class="ttdoc">During an async-read (note: given start_and_poll() and until channel is hosed, there is always an asy...</div><div class="ttdef"><b>Definition:</b> <a href="ipc__transport__structured_2src_2ipc_2transport_2struc_2sync__io_2channel_8hpp_source.html#l01327">channel.hpp:1327</a></div></div>
<div class="ttc" id="astructipc_1_1transport_1_1struc_1_1sync__io_1_1Channel_1_1Msg__in__pipe_html_a3d239c5a1e29bd6db1ee7c4764616549"><div class="ttname"><a href="structipc_1_1transport_1_1struc_1_1sync__io_1_1Channel_1_1Msg__in__pipe.html#a3d239c5a1e29bd6db1ee7c4764616549">ipc::transport::struc::sync_io::Channel::Msg_in_pipe::m_lead_msg_mode</a></div><div class="ttdeci">enum ipc::transport::struc::sync_io::Channel::Msg_in_pipe::@0 m_lead_msg_mode</div><div class="ttdoc">The immutable mode of behavior along this pipe, which must be enabled: Whether to use Native_handle_r...</div></div>
<div class="ttc" id="astructipc_1_1transport_1_1struc_1_1sync__io_1_1Channel_1_1Msg__in__pipe_html_a56c1f9cdcfd2a145114ab080199eb704"><div class="ttname"><a href="structipc_1_1transport_1_1struc_1_1sync__io_1_1Channel_1_1Msg__in__pipe.html#a56c1f9cdcfd2a145114ab080199eb704">ipc::transport::struc::sync_io::Channel::Msg_in_pipe::m_proto_neg_blob</a></div><div class="ttdeci">flow::util::Blob * m_proto_neg_blob</div><div class="ttdoc">Used only for the first in-message in the pipe, before any m_incomplete_msg, when doing protocol nego...</div><div class="ttdef"><b>Definition:</b> <a href="ipc__transport__structured_2src_2ipc_2transport_2struc_2sync__io_2channel_8hpp_source.html#l01387">channel.hpp:1387</a></div></div>
<div class="ttc" id="astructipc_1_1transport_1_1struc_1_1sync__io_1_1Channel_1_1Msg__in__pipe_html_a58b72930ddbf7e45936f8c8f34105324"><div class="ttname"><a href="structipc_1_1transport_1_1struc_1_1sync__io_1_1Channel_1_1Msg__in__pipe.html#a58b72930ddbf7e45936f8c8f34105324">ipc::transport::struc::sync_io::Channel::Msg_in_pipe::m_proto_neg_reader_in</a></div><div class="ttdeci">boost::movelib::unique_ptr&lt; Heap_reader &gt; m_proto_neg_reader_in</div><div class="ttdoc">Used only for the first in-message in the pipe, before any m_incomplete_msg, when doing protocol nego...</div><div class="ttdef"><b>Definition:</b> <a href="ipc__transport__structured_2src_2ipc_2transport_2struc_2sync__io_2channel_8hpp_source.html#l01402">channel.hpp:1402</a></div></div>
<div class="ttc" id="astructipc_1_1transport_1_1struc_1_1sync__io_1_1Channel_1_1Msg__in__pipe_html_a83b9a3a7ddee7b6bfe14724bfccfc6ba"><div class="ttname"><a href="structipc_1_1transport_1_1struc_1_1sync__io_1_1Channel_1_1Msg__in__pipe.html#a83b9a3a7ddee7b6bfe14724bfccfc6ba">ipc::transport::struc::sync_io::Channel::Msg_in_pipe::m_proto_neg_hndl</a></div><div class="ttdeci">Native_handle m_proto_neg_hndl</div><div class="ttdoc">Used only for the first in-message in the pipe, before any m_incomplete_msg, when doing protocol nego...</div><div class="ttdef"><b>Definition:</b> <a href="ipc__transport__structured_2src_2ipc_2transport_2struc_2sync__io_2channel_8hpp_source.html#l01394">channel.hpp:1394</a></div></div>
<div class="ttc" id="astructipc_1_1transport_1_1struc_1_1sync__io_1_1Channel_1_1Msg__in__pipe_html_aa02a4835e4bd31cd5f6ea9bbd37eeff4"><div class="ttname"><a href="structipc_1_1transport_1_1struc_1_1sync__io_1_1Channel_1_1Msg__in__pipe.html#aa02a4835e4bd31cd5f6ea9bbd37eeff4">ipc::transport::struc::sync_io::Channel::Msg_in_pipe::m_incomplete_msg</a></div><div class="ttdeci">Msg_in_ptr_uniq m_incomplete_msg</div><div class="ttdoc">Target (incomplete) in-message for the async_receive_*() operation in-progress; one is always in-prog...</div><div class="ttdef"><b>Definition:</b> <a href="ipc__transport__structured_2src_2ipc_2transport_2struc_2sync__io_2channel_8hpp_source.html#l01381">channel.hpp:1381</a></div></div>
<div class="ttc" id="astructipc_1_1transport_1_1struc_1_1sync__io_1_1Channel_1_1Msg__in__pipe_html_ad27cbaa9b01823f31fb2ae47835974df"><div class="ttname"><a href="structipc_1_1transport_1_1struc_1_1sync__io_1_1Channel_1_1Msg__in__pipe.html#ad27cbaa9b01823f31fb2ae47835974df">ipc::transport::struc::sync_io::Channel::Msg_in_pipe::m_target_hndl</a></div><div class="ttdeci">Native_handle m_target_hndl</div><div class="ttdoc">Target Native_handle for the async_receive_native_handle() operation in-progress or last-completed; n...</div><div class="ttdef"><b>Definition:</b> <a href="ipc__transport__structured_2src_2ipc_2transport_2struc_2sync__io_2channel_8hpp_source.html#l01359">channel.hpp:1359</a></div></div>
<div class="ttc" id="astructipc_1_1transport_1_1struc_1_1sync__io_1_1Channel_1_1Msg__in__pipe_html_af253db32507ef0191eef0fc926a65f54a2909901e853fa702041678e01f37f7de"><div class="ttname"><a href="structipc_1_1transport_1_1struc_1_1sync__io_1_1Channel_1_1Msg__in__pipe.html#af253db32507ef0191eef0fc926a65f54a2909901e853fa702041678e01f37f7de">ipc::transport::struc::sync_io::Channel::Msg_in_pipe::S_RCV_WITH_OR_SANS_HNDL_DEMUX</a></div><div class="ttdeci">@ S_RCV_WITH_OR_SANS_HNDL_DEMUX</div><div class="ttdoc">Use Native_handle_receiver::async_receive_native_handle(); accept with-handle and sans-handle lead in...</div><div class="ttdef"><b>Definition:</b> <a href="ipc__transport__structured_2src_2ipc_2transport_2struc_2sync__io_2channel_8hpp_source.html#l01293">channel.hpp:1293</a></div></div>
<div class="ttc" id="astructipc_1_1transport_1_1struc_1_1sync__io_1_1Channel_1_1Msg__in__pipe_html_af253db32507ef0191eef0fc926a65f54ae237f1213d4bbf83cf354afb87238ecf"><div class="ttname"><a href="structipc_1_1transport_1_1struc_1_1sync__io_1_1Channel_1_1Msg__in__pipe.html#af253db32507ef0191eef0fc926a65f54ae237f1213d4bbf83cf354afb87238ecf">ipc::transport::struc::sync_io::Channel::Msg_in_pipe::S_RCV_WITH_HNDL_ELSE_ERROR</a></div><div class="ttdeci">@ S_RCV_WITH_HNDL_ELSE_ERROR</div><div class="ttdoc">Use Native_handle_receiver::async_receive_native_handle(); accept with-handle message only; sans-hand...</div><div class="ttdef"><b>Definition:</b> <a href="ipc__transport__structured_2src_2ipc_2transport_2struc_2sync__io_2channel_8hpp_source.html#l01303">channel.hpp:1303</a></div></div>
<div class="ttc" id="astructipc_1_1transport_1_1struc_1_1sync__io_1_1Channel_1_1Msg__in__pipe_html_af253db32507ef0191eef0fc926a65f54af9cda4dc28baebac6ea0b91401fefeaa"><div class="ttname"><a href="structipc_1_1transport_1_1struc_1_1sync__io_1_1Channel_1_1Msg__in__pipe.html#af253db32507ef0191eef0fc926a65f54af9cda4dc28baebac6ea0b91401fefeaa">ipc::transport::struc::sync_io::Channel::Msg_in_pipe::S_RCV_SANS_HNDL_ONLY</a></div><div class="ttdeci">@ S_RCV_SANS_HNDL_ONLY</div><div class="ttdoc">Use Blob_receiver::async_receive_blob(); accept sans-handle message only; with-handle message means f...</div><div class="ttdef"><b>Definition:</b> <a href="ipc__transport__structured_2src_2ipc_2transport_2struc_2sync__io_2channel_8hpp_source.html#l01315">channel.hpp:1314</a></div></div>
<div class="ttc" id="astructipc_1_1transport_1_1struc_1_1sync__io_1_1Channel_1_1Msg__in__pipe_html_af73c6fcead6a866df1524e01b5654222"><div class="ttname"><a href="structipc_1_1transport_1_1struc_1_1sync__io_1_1Channel_1_1Msg__in__pipe.html#af73c6fcead6a866df1524e01b5654222">ipc::transport::struc::sync_io::Channel::Msg_in_pipe::m_target_blob</a></div><div class="ttdeci">flow::util::Blob * m_target_blob</div><div class="ttdoc">Target buffer for the async_receive_*() operation in-progress.</div><div class="ttdef"><b>Definition:</b> <a href="ipc__transport__structured_2src_2ipc_2transport_2struc_2sync__io_2channel_8hpp_source.html#l01346">channel.hpp:1346</a></div></div>
<div class="ttc" id="astructipc_1_1util_1_1Native__handle_html"><div class="ttname"><a href="structipc_1_1util_1_1Native__handle.html">ipc::util::Native_handle</a></div><div class="ttdoc">A monolayer-thin wrapper around a native handle, a/k/a descriptor a/k/a FD.</div><div class="ttdef"><b>Definition:</b> <a href="native__handle_8hpp_source.html#l00061">native_handle.hpp:62</a></div></div>
<div class="ttc" id="astructipc_1_1util_1_1Native__handle_html_a11bd62ce0a7bef4bdfe666201c26d4dc"><div class="ttname"><a href="structipc_1_1util_1_1Native__handle.html#a11bd62ce0a7bef4bdfe666201c26d4dc">ipc::util::Native_handle::null</a></div><div class="ttdeci">bool null() const</div><div class="ttdoc">Returns true if and only if m_native_handle equals S_NULL_HANDLE.</div><div class="ttdef"><b>Definition:</b> <a href="native__handle_8cpp_source.html#l00060">native_handle.cpp:60</a></div></div>
</div><!-- fragment --></div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Wed Mar 27 2024 03:21:15 for Flow-IPC by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.4
</small></address>
</body>
</html>
