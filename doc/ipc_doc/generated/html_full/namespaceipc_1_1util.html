<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.9.4"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Flow-IPC: ipc::util Namespace Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">Flow-IPC<span id="projectnumber">&#160;1.0.0</span>
   </div>
   <div id="projectbrief">Flow-IPC project: Full implementation reference.</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.4 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search",'Search','.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespaceipc.html">ipc</a></li><li class="navelem"><a class="el" href="namespaceipc_1_1util.html">util</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#namespaces">Namespaces</a> &#124;
<a href="#nested-classes">Classes</a> &#124;
<a href="#typedef-members">Typedefs</a> &#124;
<a href="#enum-members">Enumerations</a> &#124;
<a href="#func-members">Functions</a> &#124;
<a href="#var-members">Variables</a>  </div>
  <div class="headertitle"><div class="title">ipc::util Namespace Reference</div></div>
</div><!--header-->
<div class="contents">

<p>Flow-IPC module containing miscellaneous general-use facilities that ubiquitously used by ~all Flow-IPC modules and/or do not fit into any other Flow-IPC module.  
<a href="namespaceipc_1_1util.html#details">More...</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="namespaces" name="namespaces"></a>
Namespaces</h2></td></tr>
<tr class="memitem:namespaceipc_1_1util_1_1sync__io"><td class="memItemLeft" align="right" valign="top">namespace &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceipc_1_1util_1_1sync__io.html">sync_io</a></td></tr>
<tr class="memdesc:namespaceipc_1_1util_1_1sync__io"><td class="mdescLeft">&#160;</td><td class="mdescRight">Contains common code, as well as important explanatory documentation in the following text, for the <code><a class="el" href="namespaceipc_1_1util_1_1sync__io.html" title="Contains common code, as well as important explanatory documentation in the following text,...">sync_io</a></code> pattern used in <a class="el" href="namespaceipc_1_1transport.html" title="Flow-IPC module providing transmission of structured messages and/or low-level blobs (and more) betwe...">ipc::transport</a> and <a class="el" href="namespaceipc_1_1session.html" title="Flow-IPC module providing the broad lifecycle and shared-resource organization – via the session conc...">ipc::session</a> to provide fine-tuned control over integrating asynchronous Flow-IPC activities into the user's event loop. <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="nested-classes" name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classipc_1_1util_1_1Default__init__allocator.html">Default_init_allocator</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classAllocator.html">Allocator</a> adaptor (useful for, e.g., <code>vector</code> that skips zero-filling) that turns a value-initialization <code>T()</code> into a default-initialization for those types, namely PoDs, for which default-initialization is a no-op.  <a href="classipc_1_1util_1_1Default__init__allocator.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structipc_1_1util_1_1Native__handle.html">Native_handle</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A monolayer-thin wrapper around a native handle, a/k/a descriptor a/k/a FD.  <a href="structipc_1_1util_1_1Native__handle.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classipc_1_1util_1_1Process__credentials.html">Process_credentials</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A process's credentials (PID, UID, GID as of this writing).  <a href="classipc_1_1util_1_1Process__credentials.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classipc_1_1util_1_1Shared__name.html">Shared_name</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">String-wrapping abstraction representing a name uniquely distinguishing a kernel-persistent entity from all others in the system, or a fragment of such a name.  <a href="classipc_1_1util_1_1Shared__name.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classipc_1_1util_1_1Use__counted__object.html">Use_counted_object</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Simple counter that manually tracks utilization. It is not thread-safe.  <a href="classipc_1_1util_1_1Use__counted__object.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="typedef-members" name="typedef-members"></a>
Typedefs</h2></td></tr>
<tr class="memitem:a844d5ca9c17b672644fc8d9dbe758db0"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceipc_1_1util.html#a844d5ca9c17b672644fc8d9dbe758db0">Pipe_writer</a> = boost::asio::writable_pipe</td></tr>
<tr class="memdesc:a844d5ca9c17b672644fc8d9dbe758db0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Short-hand for anonymous pipe write end.  <a href="namespaceipc_1_1util.html#a844d5ca9c17b672644fc8d9dbe758db0">More...</a><br /></td></tr>
<tr class="separator:a844d5ca9c17b672644fc8d9dbe758db0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaf368acf8243bb25de3eef4e836c15de"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceipc_1_1util.html#aaf368acf8243bb25de3eef4e836c15de">Pipe_reader</a> = boost::asio::readable_pipe</td></tr>
<tr class="memdesc:aaf368acf8243bb25de3eef4e836c15de"><td class="mdescLeft">&#160;</td><td class="mdescRight">Short-hand for anonymous pipe read end.  <a href="namespaceipc_1_1util.html#aaf368acf8243bb25de3eef4e836c15de">More...</a><br /></td></tr>
<tr class="separator:aaf368acf8243bb25de3eef4e836c15de"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae6ac47812a90d1287c61e0b7de7bc4f5"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceipc_1_1util.html#ae6ac47812a90d1287c61e0b7de7bc4f5">String_view</a> = flow::util::String_view</td></tr>
<tr class="memdesc:ae6ac47812a90d1287c61e0b7de7bc4f5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Short-hand for Flow's <code>String_view</code>.  <a href="namespaceipc_1_1util.html#ae6ac47812a90d1287c61e0b7de7bc4f5">More...</a><br /></td></tr>
<tr class="separator:ae6ac47812a90d1287c61e0b7de7bc4f5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac66141280c3b7295a86b65209f31cc58"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceipc_1_1util.html#ac66141280c3b7295a86b65209f31cc58">Fine_duration</a> = flow::Fine_duration</td></tr>
<tr class="memdesc:ac66141280c3b7295a86b65209f31cc58"><td class="mdescLeft">&#160;</td><td class="mdescRight">Short-hand for Flow's <code>Fine_duration</code>.  <a href="namespaceipc_1_1util.html#ac66141280c3b7295a86b65209f31cc58">More...</a><br /></td></tr>
<tr class="separator:ac66141280c3b7295a86b65209f31cc58"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa3808edfc4d59bce4b9800d6a60026d3"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceipc_1_1util.html#aa3808edfc4d59bce4b9800d6a60026d3">Fine_time_pt</a> = flow::Fine_time_pt</td></tr>
<tr class="memdesc:aa3808edfc4d59bce4b9800d6a60026d3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Short-hand for Flow's <code>Fine_time_pt</code>.  <a href="namespaceipc_1_1util.html#aa3808edfc4d59bce4b9800d6a60026d3">More...</a><br /></td></tr>
<tr class="separator:aa3808edfc4d59bce4b9800d6a60026d3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a31e67d3a017477a04b313927e2f2c733"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceipc_1_1util.html#a31e67d3a017477a04b313927e2f2c733">Task</a> = flow::async::Task</td></tr>
<tr class="memdesc:a31e67d3a017477a04b313927e2f2c733"><td class="mdescLeft">&#160;</td><td class="mdescRight">Short-hand for polymorphic function (a-la <code>std::function&lt;&gt;</code>) that takes no arguments and returns nothing.  <a href="namespaceipc_1_1util.html#a31e67d3a017477a04b313927e2f2c733">More...</a><br /></td></tr>
<tr class="separator:a31e67d3a017477a04b313927e2f2c733"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae0be7edba7e30ffa3f8b742af621f2ab"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceipc_1_1util.html#ae0be7edba7e30ffa3f8b742af621f2ab">Blob_const</a> = boost::asio::const_buffer</td></tr>
<tr class="memdesc:ae0be7edba7e30ffa3f8b742af621f2ab"><td class="mdescLeft">&#160;</td><td class="mdescRight">Short-hand for an immutable blob somewhere in memory, stored as exactly a <code>void const *</code> and a <code>size_t</code>.  <a href="namespaceipc_1_1util.html#ae0be7edba7e30ffa3f8b742af621f2ab">More...</a><br /></td></tr>
<tr class="separator:ae0be7edba7e30ffa3f8b742af621f2ab"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6cb62ae434900f3a8915b33ec5d61a96"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceipc_1_1util.html#a6cb62ae434900f3a8915b33ec5d61a96">Blob_mutable</a> = boost::asio::mutable_buffer</td></tr>
<tr class="memdesc:a6cb62ae434900f3a8915b33ec5d61a96"><td class="mdescLeft">&#160;</td><td class="mdescRight">Short-hand for an mutable blob somewhere in memory, stored as exactly a <code>void*</code> and a <code>size_t</code>.  <a href="namespaceipc_1_1util.html#a6cb62ae434900f3a8915b33ec5d61a96">More...</a><br /></td></tr>
<tr class="separator:a6cb62ae434900f3a8915b33ec5d61a96"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0c44028a45451ebf21f6af8e806b2682"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceipc_1_1util.html#a0c44028a45451ebf21f6af8e806b2682">process_id_t</a> = ::pid_t</td></tr>
<tr class="memdesc:a0c44028a45451ebf21f6af8e806b2682"><td class="mdescLeft">&#160;</td><td class="mdescRight">Syntactic-sugary type for POSIX process ID (integer).  <a href="namespaceipc_1_1util.html#a0c44028a45451ebf21f6af8e806b2682">More...</a><br /></td></tr>
<tr class="separator:a0c44028a45451ebf21f6af8e806b2682"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6435c1b48ec8684c24ca406d1d17208e"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceipc_1_1util.html#a6435c1b48ec8684c24ca406d1d17208e">user_id_t</a> = ::uid_t</td></tr>
<tr class="memdesc:a6435c1b48ec8684c24ca406d1d17208e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Syntactic-sugary type for POSIX user ID (integer).  <a href="namespaceipc_1_1util.html#a6435c1b48ec8684c24ca406d1d17208e">More...</a><br /></td></tr>
<tr class="separator:a6435c1b48ec8684c24ca406d1d17208e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3f7d069ce0d23f73153da2e2559dc3d3"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceipc_1_1util.html#a3f7d069ce0d23f73153da2e2559dc3d3">group_id_t</a> = ::gid_t</td></tr>
<tr class="memdesc:a3f7d069ce0d23f73153da2e2559dc3d3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Syntactic-sugary type for POSIX group ID (integer).  <a href="namespaceipc_1_1util.html#a3f7d069ce0d23f73153da2e2559dc3d3">More...</a><br /></td></tr>
<tr class="separator:a3f7d069ce0d23f73153da2e2559dc3d3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9571de958538d7a4a8649bbfecfac0b9"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceipc_1_1util.html#a9571de958538d7a4a8649bbfecfac0b9">Open_or_create</a> = bipc::open_or_create_t</td></tr>
<tr class="memdesc:a9571de958538d7a4a8649bbfecfac0b9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Tag type indicating an atomic open-if-exists-else-create operation.  <a href="namespaceipc_1_1util.html#a9571de958538d7a4a8649bbfecfac0b9">More...</a><br /></td></tr>
<tr class="separator:a9571de958538d7a4a8649bbfecfac0b9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3e03491b5b2b5fac26551a220946d6e5"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceipc_1_1util.html#a3e03491b5b2b5fac26551a220946d6e5">Open_only</a> = bipc::open_only_t</td></tr>
<tr class="memdesc:a3e03491b5b2b5fac26551a220946d6e5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Tag type indicating an ideally-atomic open-if-exists-else-fail operation.  <a href="namespaceipc_1_1util.html#a3e03491b5b2b5fac26551a220946d6e5">More...</a><br /></td></tr>
<tr class="separator:a3e03491b5b2b5fac26551a220946d6e5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9d84c2bab504e6de32b20c77ca9723a2"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceipc_1_1util.html#a9d84c2bab504e6de32b20c77ca9723a2">Create_only</a> = bipc::create_only_t</td></tr>
<tr class="memdesc:a9d84c2bab504e6de32b20c77ca9723a2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Tag type indicating a create-unless-exists-else-fail operation.  <a href="namespaceipc_1_1util.html#a9d84c2bab504e6de32b20c77ca9723a2">More...</a><br /></td></tr>
<tr class="separator:a9d84c2bab504e6de32b20c77ca9723a2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1b398ae730d1e6040687cb2397115152"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceipc_1_1util.html#a1b398ae730d1e6040687cb2397115152">Permissions</a> = bipc::permissions</td></tr>
<tr class="memdesc:a1b398ae730d1e6040687cb2397115152"><td class="mdescLeft">&#160;</td><td class="mdescRight">Short-hand for Unix (POSIX) permissions class.  <a href="namespaceipc_1_1util.html#a1b398ae730d1e6040687cb2397115152">More...</a><br /></td></tr>
<tr class="separator:a1b398ae730d1e6040687cb2397115152"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="enum-members" name="enum-members"></a>
Enumerations</h2></td></tr>
<tr class="memitem:a2ec0bfdddb41a1ef0403e4bb8967705d"><td class="memItemLeft" align="right" valign="top">enum class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceipc_1_1util.html#a2ec0bfdddb41a1ef0403e4bb8967705d">Permissions_level</a> : size_t { <br />
&#160;&#160;<a class="el" href="namespaceipc_1_1util.html#a2ec0bfdddb41a1ef0403e4bb8967705dac43e9194d6c0e9803ecabbf3cb4c97fa">S_NO_ACCESS</a>
, <a class="el" href="namespaceipc_1_1util.html#a2ec0bfdddb41a1ef0403e4bb8967705daa3e1d310128f18fe2f903bf3cba8849a">S_USER_ACCESS</a>
, <a class="el" href="namespaceipc_1_1util.html#a2ec0bfdddb41a1ef0403e4bb8967705daa5508fa6037b9c0926cf7eb20af97a6d">S_GROUP_ACCESS</a>
, <a class="el" href="namespaceipc_1_1util.html#a2ec0bfdddb41a1ef0403e4bb8967705da25bf1cdee66ff5f73914fd5b0ee996e9">S_UNRESTRICTED</a>
, <br />
&#160;&#160;<a class="el" href="namespaceipc_1_1util.html#a2ec0bfdddb41a1ef0403e4bb8967705da6fba12db09e5bebfaa04f6372c41c2cf">S_END_SENTINEL</a>
<br />
 }</td></tr>
<tr class="memdesc:a2ec0bfdddb41a1ef0403e4bb8967705d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Simple specifier of desired access permissions, usually but not necessarily translated into a <code>Permissions</code> value (though even then different value in different contexts).  <a href="namespaceipc_1_1util.html#a2ec0bfdddb41a1ef0403e4bb8967705d">More...</a><br /></td></tr>
<tr class="separator:a2ec0bfdddb41a1ef0403e4bb8967705d"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="func-members" name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:a5429c6225cc9a271ad8c0041d99c236b"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceipc_1_1util.html#a5429c6225cc9a271ad8c0041d99c236b">pipe_produce</a> (flow::log::Logger *logger_ptr, <a class="el" href="namespaceipc_1_1util.html#a844d5ca9c17b672644fc8d9dbe758db0">Pipe_writer</a> *pipe)</td></tr>
<tr class="memdesc:a5429c6225cc9a271ad8c0041d99c236b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Writes a byte to the given pipe writer.  <a href="namespaceipc_1_1util.html#a5429c6225cc9a271ad8c0041d99c236b">More...</a><br /></td></tr>
<tr class="separator:a5429c6225cc9a271ad8c0041d99c236b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a814272e555c0592b0caf92b7bc3d64b3"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceipc_1_1util.html#a814272e555c0592b0caf92b7bc3d64b3">pipe_consume</a> (flow::log::Logger *logger_ptr, <a class="el" href="namespaceipc_1_1util.html#aaf368acf8243bb25de3eef4e836c15de">Pipe_reader</a> *pipe)</td></tr>
<tr class="memdesc:a814272e555c0592b0caf92b7bc3d64b3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reads a byte via the given pipe reader.  <a href="namespaceipc_1_1util.html#a814272e555c0592b0caf92b7bc3d64b3">More...</a><br /></td></tr>
<tr class="separator:a814272e555c0592b0caf92b7bc3d64b3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1cdc0a8d761170faa844c49d37c522ff"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceipc_1_1util.html#a1cdc0a8d761170faa844c49d37c522ff">remove_persistent_shm_pool</a> (flow::log::Logger *logger_ptr, const <a class="el" href="classipc_1_1util_1_1Shared__name.html">Shared_name</a> &amp;name, <a class="el" href="namespaceipc.html#aa3192e586cc45d3e7c22463bf2760f89">Error_code</a> *err_code)</td></tr>
<tr class="memdesc:a1cdc0a8d761170faa844c49d37c522ff"><td class="mdescLeft">&#160;</td><td class="mdescRight">Equivalent to <a class="el" href="classipc_1_1shm_1_1classic_1_1Pool__arena.html#aff2327ce7339c1c732ddd4fcd4861ee4" title="Removes the named SHM pool object.">shm::classic::Pool_arena::remove_persistent()</a>.  <a href="namespaceipc_1_1util.html#a1cdc0a8d761170faa844c49d37c522ff">More...</a><br /></td></tr>
<tr class="separator:a1cdc0a8d761170faa844c49d37c522ff"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abd43da87aa17031604c7906757c07d46"><td class="memTemplParams" colspan="2">template&lt;typename Func &gt; </td></tr>
<tr class="memitem:abd43da87aa17031604c7906757c07d46"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceipc_1_1util.html#abd43da87aa17031604c7906757c07d46">op_with_possible_bipc_exception</a> (flow::log::Logger *logger_ptr, <a class="el" href="namespaceipc.html#aa3192e586cc45d3e7c22463bf2760f89">Error_code</a> *err_code, const <a class="el" href="namespaceipc.html#aa3192e586cc45d3e7c22463bf2760f89">Error_code</a> &amp;misc_bipc_lib_error, <a class="el" href="namespaceipc_1_1util.html#ae6ac47812a90d1287c61e0b7de7bc4f5">String_view</a> context, const Func &amp;func)</td></tr>
<tr class="memdesc:abd43da87aa17031604c7906757c07d46"><td class="mdescLeft">&#160;</td><td class="mdescRight">Internal (to <a class="el" href="namespaceipc.html" title="Catch-all namespace for the Flow-IPC project: A library/API in modern C++17 providing high-performanc...">ipc</a>) utility that invokes the given function that invokes a boost.interprocess operation that is documented to throw <code>bipc::interprocess_exception</code> on failure; if indeed it throws the utility emits an error in the Flow error-reporting style.  <a href="namespaceipc_1_1util.html#abd43da87aa17031604c7906757c07d46">More...</a><br /></td></tr>
<tr class="separator:abd43da87aa17031604c7906757c07d46"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a49b39ceb74614b5f2d26dd86fd71bcb3"><td class="memTemplParams" colspan="2">template&lt;typename Handle_name_func &gt; </td></tr>
<tr class="memitem:a49b39ceb74614b5f2d26dd86fd71bcb3"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceipc_1_1util.html#a49b39ceb74614b5f2d26dd86fd71bcb3">for_each_persistent_impl</a> (const fs::path &amp;persistent_obj_dev_dir_path, const Handle_name_func &amp;handle_name_func)</td></tr>
<tr class="memdesc:a49b39ceb74614b5f2d26dd86fd71bcb3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Implementation of <code>Persistent_object::for_each_persistent()</code>; for example see <a class="el" href="classipc_1_1shm_1_1classic_1_1Pool__arena.html#a9e720283945eefe3d941b185e95d2ce1" title="Lists all named SHM pool objects currently persisting, invoking the given handler synchronously on ea...">shm::classic::Pool_arena::for_each_persistent()</a>.  <a href="namespaceipc_1_1util.html#a49b39ceb74614b5f2d26dd86fd71bcb3">More...</a><br /></td></tr>
<tr class="separator:a49b39ceb74614b5f2d26dd86fd71bcb3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a74135195ff6c2f840092c21e522f964a"><td class="memTemplParams" colspan="2">template&lt;typename Handle_name_func &gt; </td></tr>
<tr class="memitem:a74135195ff6c2f840092c21e522f964a"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceipc_1_1util.html#a74135195ff6c2f840092c21e522f964a">for_each_persistent_shm_pool</a> (const Handle_name_func &amp;handle_name_func)</td></tr>
<tr class="memdesc:a74135195ff6c2f840092c21e522f964a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Equivalent to <a class="el" href="classipc_1_1shm_1_1classic_1_1Pool__arena.html#a9e720283945eefe3d941b185e95d2ce1" title="Lists all named SHM pool objects currently persisting, invoking the given handler synchronously on ea...">shm::classic::Pool_arena::for_each_persistent()</a>.  <a href="namespaceipc_1_1util.html#a74135195ff6c2f840092c21e522f964a">More...</a><br /></td></tr>
<tr class="separator:a74135195ff6c2f840092c21e522f964a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a71fa0c2bd2c45109a9fbab4b048c666d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classipc_1_1util_1_1Shared__name.html">Shared_name</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceipc_1_1util.html#a71fa0c2bd2c45109a9fbab4b048c666d">build_conventional_non_session_based_shared_name</a> (const <a class="el" href="classipc_1_1util_1_1Shared__name.html">Shared_name</a> &amp;resource_type)</td></tr>
<tr class="memdesc:a71fa0c2bd2c45109a9fbab4b048c666d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Builds an absolute name according to the path convention explained in <a class="el" href="classipc_1_1util_1_1Shared__name.html" title="String-wrapping abstraction representing a name uniquely distinguishing a kernel-persistent entity fr...">Shared_name</a> class doc header; this overload applies to resources <em>outside</em> the <a class="el" href="namespaceipc_1_1session.html" title="Flow-IPC module providing the broad lifecycle and shared-resource organization – via the session conc...">ipc::session</a> paradigm.  <a href="namespaceipc_1_1util.html#a71fa0c2bd2c45109a9fbab4b048c666d">More...</a><br /></td></tr>
<tr class="separator:a71fa0c2bd2c45109a9fbab4b048c666d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a28030c32e9c66f5c2862cbc6998885c7"><td class="memItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceipc_1_1util.html#a28030c32e9c66f5c2862cbc6998885c7">operator&lt;&lt;</a> (std::ostream &amp;os, const <a class="el" href="structipc_1_1util_1_1Native__handle.html">Native_handle</a> &amp;val)</td></tr>
<tr class="memdesc:a28030c32e9c66f5c2862cbc6998885c7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Prints string representation of the given <a class="el" href="structipc_1_1util_1_1Native__handle.html" title="A monolayer-thin wrapper around a native handle, a/k/a descriptor a/k/a FD.">Native_handle</a> to the given <code>ostream</code>.  <a href="namespaceipc_1_1util.html#a28030c32e9c66f5c2862cbc6998885c7">More...</a><br /></td></tr>
<tr class="separator:a28030c32e9c66f5c2862cbc6998885c7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae4b4126f841ef060cdae15998e48691c"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceipc_1_1util.html#ae4b4126f841ef060cdae15998e48691c">operator==</a> (<a class="el" href="structipc_1_1util_1_1Native__handle.html">Native_handle</a> val1, <a class="el" href="structipc_1_1util_1_1Native__handle.html">Native_handle</a> val2)</td></tr>
<tr class="memdesc:ae4b4126f841ef060cdae15998e48691c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns <code>true</code> if and only if the two <a class="el" href="structipc_1_1util_1_1Native__handle.html" title="A monolayer-thin wrapper around a native handle, a/k/a descriptor a/k/a FD.">Native_handle</a> objects are the same underlying handle.  <a href="namespaceipc_1_1util.html#ae4b4126f841ef060cdae15998e48691c">More...</a><br /></td></tr>
<tr class="separator:ae4b4126f841ef060cdae15998e48691c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aacbd7ee43d4912a8790a228dc7cf682d"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceipc_1_1util.html#aacbd7ee43d4912a8790a228dc7cf682d">operator!=</a> (<a class="el" href="structipc_1_1util_1_1Native__handle.html">Native_handle</a> val1, <a class="el" href="structipc_1_1util_1_1Native__handle.html">Native_handle</a> val2)</td></tr>
<tr class="memdesc:aacbd7ee43d4912a8790a228dc7cf682d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Negation of similar <code>==</code>.  <a href="namespaceipc_1_1util.html#aacbd7ee43d4912a8790a228dc7cf682d">More...</a><br /></td></tr>
<tr class="separator:aacbd7ee43d4912a8790a228dc7cf682d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad3883df3081441d71a9a989073264b04"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceipc_1_1util.html#ad3883df3081441d71a9a989073264b04">hash_value</a> (<a class="el" href="structipc_1_1util_1_1Native__handle.html">Native_handle</a> val)</td></tr>
<tr class="memdesc:ad3883df3081441d71a9a989073264b04"><td class="mdescLeft">&#160;</td><td class="mdescRight">Hasher of <a class="el" href="structipc_1_1util_1_1Native__handle.html" title="A monolayer-thin wrapper around a native handle, a/k/a descriptor a/k/a FD.">Native_handle</a> for boost.unordered et al.  <a href="namespaceipc_1_1util.html#ad3883df3081441d71a9a989073264b04">More...</a><br /></td></tr>
<tr class="separator:ad3883df3081441d71a9a989073264b04"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6ff4b35d8fbbe2eb6266f3a7b0f07c49"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceipc_1_1util.html#a6ff4b35d8fbbe2eb6266f3a7b0f07c49">operator&lt;</a> (<a class="el" href="structipc_1_1util_1_1Native__handle.html">Native_handle</a> val1, <a class="el" href="structipc_1_1util_1_1Native__handle.html">Native_handle</a> val2)</td></tr>
<tr class="memdesc:a6ff4b35d8fbbe2eb6266f3a7b0f07c49"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a less-than comparison of two <a class="el" href="structipc_1_1util_1_1Native__handle.html" title="A monolayer-thin wrapper around a native handle, a/k/a descriptor a/k/a FD.">Native_handle</a> objects, with the usual total ordering guarantees.  <a href="namespaceipc_1_1util.html#a6ff4b35d8fbbe2eb6266f3a7b0f07c49">More...</a><br /></td></tr>
<tr class="separator:a6ff4b35d8fbbe2eb6266f3a7b0f07c49"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4ccdab04a79159f82d7ade8136a2eeb2"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceipc_1_1util.html#a4ccdab04a79159f82d7ade8136a2eeb2">operator==</a> (const <a class="el" href="classipc_1_1util_1_1Process__credentials.html">Process_credentials</a> &amp;val1, const <a class="el" href="classipc_1_1util_1_1Process__credentials.html">Process_credentials</a> &amp;val2)</td></tr>
<tr class="memdesc:a4ccdab04a79159f82d7ade8136a2eeb2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks for by-value equality between two <a class="el" href="classipc_1_1util_1_1Process__credentials.html" title="A process&#39;s credentials (PID, UID, GID as of this writing).">Process_credentials</a> objects.  <a href="namespaceipc_1_1util.html#a4ccdab04a79159f82d7ade8136a2eeb2">More...</a><br /></td></tr>
<tr class="separator:a4ccdab04a79159f82d7ade8136a2eeb2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaf94b5903f4e0aa2f2699867dd8971ef"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceipc_1_1util.html#aaf94b5903f4e0aa2f2699867dd8971ef">operator!=</a> (const <a class="el" href="classipc_1_1util_1_1Process__credentials.html">Process_credentials</a> &amp;val1, const <a class="el" href="classipc_1_1util_1_1Process__credentials.html">Process_credentials</a> &amp;val2)</td></tr>
<tr class="memdesc:aaf94b5903f4e0aa2f2699867dd8971ef"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks for by-value inequality between two <a class="el" href="classipc_1_1util_1_1Process__credentials.html" title="A process&#39;s credentials (PID, UID, GID as of this writing).">Process_credentials</a> objects.  <a href="namespaceipc_1_1util.html#aaf94b5903f4e0aa2f2699867dd8971ef">More...</a><br /></td></tr>
<tr class="separator:aaf94b5903f4e0aa2f2699867dd8971ef"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9da92514406dc1fc61f5a561c9b5aee9"><td class="memItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceipc_1_1util.html#a9da92514406dc1fc61f5a561c9b5aee9">operator&lt;&lt;</a> (std::ostream &amp;os, const <a class="el" href="classipc_1_1util_1_1Process__credentials.html">Process_credentials</a> &amp;val)</td></tr>
<tr class="memdesc:a9da92514406dc1fc61f5a561c9b5aee9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Prints string representation of the given <a class="el" href="classipc_1_1util_1_1Process__credentials.html" title="A process&#39;s credentials (PID, UID, GID as of this writing).">util::Process_credentials</a> to the given <code>ostream</code>.  <a href="namespaceipc_1_1util.html#a9da92514406dc1fc61f5a561c9b5aee9">More...</a><br /></td></tr>
<tr class="separator:a9da92514406dc1fc61f5a561c9b5aee9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af61b02fd66b67aeed5a803ca47e52973"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classipc_1_1util_1_1Shared__name.html">Shared_name</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceipc_1_1util.html#af61b02fd66b67aeed5a803ca47e52973">operator+</a> (const <a class="el" href="classipc_1_1util_1_1Shared__name.html">Shared_name</a> &amp;src1, const char *raw_src2)</td></tr>
<tr class="memdesc:af61b02fd66b67aeed5a803ca47e52973"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns new object equal to <code>Shared_name(src1) += raw_src2</code>.  <a href="namespaceipc_1_1util.html#af61b02fd66b67aeed5a803ca47e52973">More...</a><br /></td></tr>
<tr class="separator:af61b02fd66b67aeed5a803ca47e52973"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a096c71dede7bd5528215ac01a380a189"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classipc_1_1util_1_1Shared__name.html">Shared_name</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceipc_1_1util.html#a096c71dede7bd5528215ac01a380a189">operator+</a> (const char *raw_src1, const <a class="el" href="classipc_1_1util_1_1Shared__name.html">Shared_name</a> &amp;src2)</td></tr>
<tr class="memdesc:a096c71dede7bd5528215ac01a380a189"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns new object equal to <code>Shared_name(src2)</code> with <code>raw_src1</code> pre-pended to it.  <a href="namespaceipc_1_1util.html#a096c71dede7bd5528215ac01a380a189">More...</a><br /></td></tr>
<tr class="separator:a096c71dede7bd5528215ac01a380a189"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a54dc5077333284fda9e8d2df8b0e9b91"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classipc_1_1util_1_1Shared__name.html">Shared_name</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceipc_1_1util.html#a54dc5077333284fda9e8d2df8b0e9b91">operator+</a> (const <a class="el" href="classipc_1_1util_1_1Shared__name.html">Shared_name</a> &amp;src1, const <a class="el" href="classipc_1_1util_1_1Shared__name.html">Shared_name</a> &amp;src2)</td></tr>
<tr class="memdesc:a54dc5077333284fda9e8d2df8b0e9b91"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns new object equal to <code>Shared_name(src1) += src2</code>.  <a href="namespaceipc_1_1util.html#a54dc5077333284fda9e8d2df8b0e9b91">More...</a><br /></td></tr>
<tr class="separator:a54dc5077333284fda9e8d2df8b0e9b91"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa61c6b31c5c4e241c97f06a4d38c76c4"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classipc_1_1util_1_1Shared__name.html">Shared_name</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceipc_1_1util.html#aa61c6b31c5c4e241c97f06a4d38c76c4">operator/</a> (const <a class="el" href="classipc_1_1util_1_1Shared__name.html">Shared_name</a> &amp;src1, const char *raw_src2)</td></tr>
<tr class="memdesc:aa61c6b31c5c4e241c97f06a4d38c76c4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns new object equal to <code>Shared_name(src1) /= raw_src2</code>.  <a href="namespaceipc_1_1util.html#aa61c6b31c5c4e241c97f06a4d38c76c4">More...</a><br /></td></tr>
<tr class="separator:aa61c6b31c5c4e241c97f06a4d38c76c4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7f2bead5935309c2f760645fe46ddd71"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classipc_1_1util_1_1Shared__name.html">Shared_name</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceipc_1_1util.html#a7f2bead5935309c2f760645fe46ddd71">operator/</a> (const char *raw_src1, const <a class="el" href="classipc_1_1util_1_1Shared__name.html">Shared_name</a> &amp;src2)</td></tr>
<tr class="memdesc:a7f2bead5935309c2f760645fe46ddd71"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns new object equal to <code>Shared_name(raw_src1) /= src2</code>.  <a href="namespaceipc_1_1util.html#a7f2bead5935309c2f760645fe46ddd71">More...</a><br /></td></tr>
<tr class="separator:a7f2bead5935309c2f760645fe46ddd71"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a15ea67c1855a678f7e948b24ccf2c1cd"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classipc_1_1util_1_1Shared__name.html">Shared_name</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceipc_1_1util.html#a15ea67c1855a678f7e948b24ccf2c1cd">operator/</a> (const <a class="el" href="classipc_1_1util_1_1Shared__name.html">Shared_name</a> &amp;src1, const <a class="el" href="classipc_1_1util_1_1Shared__name.html">Shared_name</a> &amp;src2)</td></tr>
<tr class="memdesc:a15ea67c1855a678f7e948b24ccf2c1cd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns new object equal to <code>Shared_name(src1) /= src2</code>.  <a href="namespaceipc_1_1util.html#a15ea67c1855a678f7e948b24ccf2c1cd">More...</a><br /></td></tr>
<tr class="separator:a15ea67c1855a678f7e948b24ccf2c1cd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af7728c93fdf29479bbb2482e02f05cbf"><td class="memItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceipc_1_1util.html#af7728c93fdf29479bbb2482e02f05cbf">operator&lt;&lt;</a> (std::ostream &amp;os, const <a class="el" href="classipc_1_1util_1_1Shared__name.html">Shared_name</a> &amp;val)</td></tr>
<tr class="memdesc:af7728c93fdf29479bbb2482e02f05cbf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Prints embellished string representation of the given <a class="el" href="classipc_1_1util_1_1Shared__name.html" title="String-wrapping abstraction representing a name uniquely distinguishing a kernel-persistent entity fr...">Shared_name</a> to the given <code>ostream</code>.  <a href="namespaceipc_1_1util.html#af7728c93fdf29479bbb2482e02f05cbf">More...</a><br /></td></tr>
<tr class="separator:af7728c93fdf29479bbb2482e02f05cbf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adfd8805e0d37556102cad7b191fee9a3"><td class="memItemLeft" align="right" valign="top">std::istream &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceipc_1_1util.html#adfd8805e0d37556102cad7b191fee9a3">operator&gt;&gt;</a> (std::istream &amp;is, <a class="el" href="classipc_1_1util_1_1Shared__name.html">Shared_name</a> &amp;val)</td></tr>
<tr class="memdesc:adfd8805e0d37556102cad7b191fee9a3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reads <a class="el" href="classipc_1_1util_1_1Shared__name.html" title="String-wrapping abstraction representing a name uniquely distinguishing a kernel-persistent entity fr...">Shared_name</a> from the given <code>istream</code>; equivalent to reading <code>string</code> into <a class="el" href="classipc_1_1util_1_1Shared__name.html#ae89e1e061f87ffe0288514e254837595" title="Returns (sans copying) ref to immutable entire wrapped name string, suitable to pass into sys calls w...">Shared_name::str()</a>.  <a href="namespaceipc_1_1util.html#adfd8805e0d37556102cad7b191fee9a3">More...</a><br /></td></tr>
<tr class="separator:adfd8805e0d37556102cad7b191fee9a3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adad98b6935e58bdc92dfcf57bf60345e"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceipc_1_1util.html#adad98b6935e58bdc92dfcf57bf60345e">operator==</a> (const <a class="el" href="classipc_1_1util_1_1Shared__name.html">Shared_name</a> &amp;val1, const <a class="el" href="classipc_1_1util_1_1Shared__name.html">Shared_name</a> &amp;val2)</td></tr>
<tr class="memdesc:adad98b6935e58bdc92dfcf57bf60345e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns <code>true</code> if and only if <code>val1.str() == val2.str()</code>.  <a href="namespaceipc_1_1util.html#adad98b6935e58bdc92dfcf57bf60345e">More...</a><br /></td></tr>
<tr class="separator:adad98b6935e58bdc92dfcf57bf60345e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aec185fc5e2e88206d1366de8ce42f732"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceipc_1_1util.html#aec185fc5e2e88206d1366de8ce42f732">operator!=</a> (const <a class="el" href="classipc_1_1util_1_1Shared__name.html">Shared_name</a> &amp;val1, const <a class="el" href="classipc_1_1util_1_1Shared__name.html">Shared_name</a> &amp;val2)</td></tr>
<tr class="memdesc:aec185fc5e2e88206d1366de8ce42f732"><td class="mdescLeft">&#160;</td><td class="mdescRight">Negation of similar <code>==</code>.  <a href="namespaceipc_1_1util.html#aec185fc5e2e88206d1366de8ce42f732">More...</a><br /></td></tr>
<tr class="separator:aec185fc5e2e88206d1366de8ce42f732"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5023285f7dd8a117686f0ee986e685cb"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceipc_1_1util.html#a5023285f7dd8a117686f0ee986e685cb">operator==</a> (const <a class="el" href="classipc_1_1util_1_1Shared__name.html">Shared_name</a> &amp;val1, <a class="el" href="namespaceipc_1_1util.html#ae6ac47812a90d1287c61e0b7de7bc4f5">util::String_view</a> val2)</td></tr>
<tr class="memdesc:a5023285f7dd8a117686f0ee986e685cb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns <code>true</code> if and only if <code>val1.str() == string(val2)</code>.  <a href="namespaceipc_1_1util.html#a5023285f7dd8a117686f0ee986e685cb">More...</a><br /></td></tr>
<tr class="separator:a5023285f7dd8a117686f0ee986e685cb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0d9b586ec40d9dc3bc14915ef6d24cb7"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceipc_1_1util.html#a0d9b586ec40d9dc3bc14915ef6d24cb7">operator!=</a> (const <a class="el" href="classipc_1_1util_1_1Shared__name.html">Shared_name</a> &amp;val1, <a class="el" href="namespaceipc_1_1util.html#ae6ac47812a90d1287c61e0b7de7bc4f5">util::String_view</a> val2)</td></tr>
<tr class="memdesc:a0d9b586ec40d9dc3bc14915ef6d24cb7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Negation of similar <code>==</code>.  <a href="namespaceipc_1_1util.html#a0d9b586ec40d9dc3bc14915ef6d24cb7">More...</a><br /></td></tr>
<tr class="separator:a0d9b586ec40d9dc3bc14915ef6d24cb7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a97a7c8e6330909a1371134a7bdcea788"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceipc_1_1util.html#a97a7c8e6330909a1371134a7bdcea788">operator==</a> (<a class="el" href="namespaceipc_1_1util.html#ae6ac47812a90d1287c61e0b7de7bc4f5">util::String_view</a> val1, const <a class="el" href="classipc_1_1util_1_1Shared__name.html">Shared_name</a> &amp;val2)</td></tr>
<tr class="memdesc:a97a7c8e6330909a1371134a7bdcea788"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns <code>true</code> if and only if <code>string(val1) == val2.str()</code>.  <a href="namespaceipc_1_1util.html#a97a7c8e6330909a1371134a7bdcea788">More...</a><br /></td></tr>
<tr class="separator:a97a7c8e6330909a1371134a7bdcea788"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a988ac1702279bd2b958464cd8ee7e81f"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceipc_1_1util.html#a988ac1702279bd2b958464cd8ee7e81f">operator!=</a> (<a class="el" href="namespaceipc_1_1util.html#ae6ac47812a90d1287c61e0b7de7bc4f5">util::String_view</a> val1, const <a class="el" href="classipc_1_1util_1_1Shared__name.html">Shared_name</a> &amp;val2)</td></tr>
<tr class="memdesc:a988ac1702279bd2b958464cd8ee7e81f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Negation of similar <code>==</code>.  <a href="namespaceipc_1_1util.html#a988ac1702279bd2b958464cd8ee7e81f">More...</a><br /></td></tr>
<tr class="separator:a988ac1702279bd2b958464cd8ee7e81f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aea456ff91117633e731804a894aa94da"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceipc_1_1util.html#aea456ff91117633e731804a894aa94da">operator&lt;</a> (const <a class="el" href="classipc_1_1util_1_1Shared__name.html">Shared_name</a> &amp;val1, const <a class="el" href="classipc_1_1util_1_1Shared__name.html">Shared_name</a> &amp;val2)</td></tr>
<tr class="memdesc:aea456ff91117633e731804a894aa94da"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns <code>true</code> if and only if <code>val1.str() &lt; val2.str()</code>.  <a href="namespaceipc_1_1util.html#aea456ff91117633e731804a894aa94da">More...</a><br /></td></tr>
<tr class="separator:aea456ff91117633e731804a894aa94da"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aba4ae811264cbb7e664ce126b591cbc7"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceipc_1_1util.html#aba4ae811264cbb7e664ce126b591cbc7">hash_value</a> (const <a class="el" href="classipc_1_1util_1_1Shared__name.html">Shared_name</a> &amp;val)</td></tr>
<tr class="memdesc:aba4ae811264cbb7e664ce126b591cbc7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Hasher of <a class="el" href="classipc_1_1util_1_1Shared__name.html" title="String-wrapping abstraction representing a name uniquely distinguishing a kernel-persistent entity fr...">Shared_name</a> for boost.unordered et al.  <a href="namespaceipc_1_1util.html#aba4ae811264cbb7e664ce126b591cbc7">More...</a><br /></td></tr>
<tr class="separator:aba4ae811264cbb7e664ce126b591cbc7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9ea22a64cfbc6de66181c278ff5f6975"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceipc_1_1util.html#a9ea22a64cfbc6de66181c278ff5f6975">swap</a> (<a class="el" href="classipc_1_1util_1_1Shared__name.html">Shared_name</a> &amp;val1, <a class="el" href="classipc_1_1util_1_1Shared__name.html">Shared_name</a> &amp;val2)</td></tr>
<tr class="memdesc:a9ea22a64cfbc6de66181c278ff5f6975"><td class="mdescLeft">&#160;</td><td class="mdescRight">Swaps two objects.  <a href="namespaceipc_1_1util.html#a9ea22a64cfbc6de66181c278ff5f6975">More...</a><br /></td></tr>
<tr class="separator:a9ea22a64cfbc6de66181c278ff5f6975"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a52b2ba03d5ace7389991bb5d31b9fa59"><td class="memTemplParams" colspan="2">template&lt;typename Source &gt; </td></tr>
<tr class="memitem:a52b2ba03d5ace7389991bb5d31b9fa59"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classipc_1_1util_1_1Shared__name.html">Shared_name</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceipc_1_1util.html#a52b2ba03d5ace7389991bb5d31b9fa59">operator+</a> (const <a class="el" href="classipc_1_1util_1_1Shared__name.html">Shared_name</a> &amp;src1, const Source &amp;raw_src2)</td></tr>
<tr class="memdesc:a52b2ba03d5ace7389991bb5d31b9fa59"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns new object equal to <code>Shared_name(src1) += raw_src2</code>.  <a href="namespaceipc_1_1util.html#a52b2ba03d5ace7389991bb5d31b9fa59">More...</a><br /></td></tr>
<tr class="separator:a52b2ba03d5ace7389991bb5d31b9fa59"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1f1a40877cc08b287f8f3c7e7f663782"><td class="memTemplParams" colspan="2">template&lt;typename Source &gt; </td></tr>
<tr class="memitem:a1f1a40877cc08b287f8f3c7e7f663782"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classipc_1_1util_1_1Shared__name.html">Shared_name</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceipc_1_1util.html#a1f1a40877cc08b287f8f3c7e7f663782">operator+</a> (const Source &amp;raw_src1, const <a class="el" href="classipc_1_1util_1_1Shared__name.html">Shared_name</a> &amp;src2)</td></tr>
<tr class="memdesc:a1f1a40877cc08b287f8f3c7e7f663782"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns new object equal to <code>Shared_name(src2)</code> with <code>raw_src1</code> pre-pended to it.  <a href="namespaceipc_1_1util.html#a1f1a40877cc08b287f8f3c7e7f663782">More...</a><br /></td></tr>
<tr class="separator:a1f1a40877cc08b287f8f3c7e7f663782"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a910207a2da57b61cee4a22899e239dc2"><td class="memTemplParams" colspan="2">template&lt;typename Source &gt; </td></tr>
<tr class="memitem:a910207a2da57b61cee4a22899e239dc2"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classipc_1_1util_1_1Shared__name.html">Shared_name</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceipc_1_1util.html#a910207a2da57b61cee4a22899e239dc2">operator/</a> (const <a class="el" href="classipc_1_1util_1_1Shared__name.html">Shared_name</a> &amp;src1, const Source &amp;raw_src2)</td></tr>
<tr class="memdesc:a910207a2da57b61cee4a22899e239dc2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns new object equal to <code>Shared_name(src1) /= raw_src2</code>.  <a href="namespaceipc_1_1util.html#a910207a2da57b61cee4a22899e239dc2">More...</a><br /></td></tr>
<tr class="separator:a910207a2da57b61cee4a22899e239dc2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a462b81d34ba23c968f63d9805fa74538"><td class="memTemplParams" colspan="2">template&lt;typename Source &gt; </td></tr>
<tr class="memitem:a462b81d34ba23c968f63d9805fa74538"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classipc_1_1util_1_1Shared__name.html">Shared_name</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceipc_1_1util.html#a462b81d34ba23c968f63d9805fa74538">operator/</a> (const Source &amp;raw_src1, const <a class="el" href="classipc_1_1util_1_1Shared__name.html">Shared_name</a> &amp;src2)</td></tr>
<tr class="memdesc:a462b81d34ba23c968f63d9805fa74538"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns new object equal to <code>Shared_name(raw_src1) /= src2</code>.  <a href="namespaceipc_1_1util.html#a462b81d34ba23c968f63d9805fa74538">More...</a><br /></td></tr>
<tr class="separator:a462b81d34ba23c968f63d9805fa74538"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a150051ee7e308ba7c9269b2d1e2c6c37"><td class="memTemplParams" colspan="2">template&lt;typename Persistent_object , typename Filter_func &gt; </td></tr>
<tr class="memitem:a150051ee7e308ba7c9269b2d1e2c6c37"><td class="memTemplItemLeft" align="right" valign="top">unsigned int&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceipc_1_1util.html#a150051ee7e308ba7c9269b2d1e2c6c37">remove_each_persistent_if</a> (flow::log::Logger *logger_ptr, const Filter_func &amp;filter_func)</td></tr>
<tr class="memdesc:a150051ee7e308ba7c9269b2d1e2c6c37"><td class="mdescLeft">&#160;</td><td class="mdescRight">Utility that invokes <code>Persistent_object::for_each_persistent(name_prefix_or_empty)</code> and synchronously invokes <code>Persistent_object::remove_persistent()</code> on each resulting item that passes the given filter, where <code>Persistent_object</code> is a type that handles objects &ndash; such as SHM pools or POSIX MQs &ndash; with kernel-persistent semantics.  <a href="namespaceipc_1_1util.html#a150051ee7e308ba7c9269b2d1e2c6c37">More...</a><br /></td></tr>
<tr class="separator:a150051ee7e308ba7c9269b2d1e2c6c37"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad6be904bf1b0fe6659a11dec0fabbf6b"><td class="memTemplParams" colspan="2">template&lt;typename Persistent_object &gt; </td></tr>
<tr class="memitem:ad6be904bf1b0fe6659a11dec0fabbf6b"><td class="memTemplItemLeft" align="right" valign="top">unsigned int&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceipc_1_1util.html#ad6be904bf1b0fe6659a11dec0fabbf6b">remove_each_persistent_with_name_prefix</a> (flow::log::Logger *logger_ptr, const <a class="el" href="classipc_1_1util_1_1Shared__name.html">Shared_name</a> &amp;name_prefix_or_empty)</td></tr>
<tr class="memdesc:ad6be904bf1b0fe6659a11dec0fabbf6b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Utility that invokes <a class="el" href="namespaceipc_1_1util.html#a150051ee7e308ba7c9269b2d1e2c6c37" title="Utility that invokes Persistent_object::for_each_persistent(name_prefix_or_empty) and synchronously i...">remove_each_persistent_if()</a> with the filter that returns <code>true</code> (yes, remove) if and only if the item's name optionally matches a given <a class="el" href="classipc_1_1util_1_1Shared__name.html" title="String-wrapping abstraction representing a name uniquely distinguishing a kernel-persistent entity fr...">Shared_name</a> prefix.  <a href="namespaceipc_1_1util.html#ad6be904bf1b0fe6659a11dec0fabbf6b">More...</a><br /></td></tr>
<tr class="separator:ad6be904bf1b0fe6659a11dec0fabbf6b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abda2ce5bcdbc26ca63d667b87818439c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespaceipc_1_1util.html#a1b398ae730d1e6040687cb2397115152">Permissions</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceipc_1_1util.html#abda2ce5bcdbc26ca63d667b87818439c">shared_resource_permissions</a> (<a class="el" href="namespaceipc_1_1util.html#a2ec0bfdddb41a1ef0403e4bb8967705d">Permissions_level</a> permissions_lvl)</td></tr>
<tr class="memdesc:abda2ce5bcdbc26ca63d667b87818439c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Maps general Permissions_level specifier to low-level <a class="el" href="namespaceipc_1_1util.html#a1b398ae730d1e6040687cb2397115152" title="Short-hand for Unix (POSIX) permissions class.">Permissions</a> value, when the underlying resource is in the file-system and is either accessible (read-write in terms of file system) or inaccessible.  <a href="namespaceipc_1_1util.html#abda2ce5bcdbc26ca63d667b87818439c">More...</a><br /></td></tr>
<tr class="separator:abda2ce5bcdbc26ca63d667b87818439c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abbba79fcaee378f433e7ce3093e5c435"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceipc_1_1util.html#abbba79fcaee378f433e7ce3093e5c435">set_resource_permissions</a> (flow::log::Logger *logger_ptr, const fs::path &amp;path, const <a class="el" href="namespaceipc_1_1util.html#a1b398ae730d1e6040687cb2397115152">Permissions</a> &amp;perms, <a class="el" href="namespaceipc.html#aa3192e586cc45d3e7c22463bf2760f89">Error_code</a> *err_code=0)</td></tr>
<tr class="memdesc:abbba79fcaee378f433e7ce3093e5c435"><td class="mdescLeft">&#160;</td><td class="mdescRight">Utility that sets the permissions of the given resource (at the supplied file system path) to specified POSIX value.  <a href="namespaceipc_1_1util.html#abbba79fcaee378f433e7ce3093e5c435">More...</a><br /></td></tr>
<tr class="separator:abbba79fcaee378f433e7ce3093e5c435"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af8b2f5a0cd9fe9db4511c9a3e685b6ae"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceipc_1_1util.html#af8b2f5a0cd9fe9db4511c9a3e685b6ae">set_resource_permissions</a> (flow::log::Logger *logger_ptr, <a class="el" href="structipc_1_1util_1_1Native__handle.html">Native_handle</a> handle, const <a class="el" href="namespaceipc_1_1util.html#a1b398ae730d1e6040687cb2397115152">Permissions</a> &amp;perms, <a class="el" href="namespaceipc.html#aa3192e586cc45d3e7c22463bf2760f89">Error_code</a> *err_code=0)</td></tr>
<tr class="memdesc:af8b2f5a0cd9fe9db4511c9a3e685b6ae"><td class="mdescLeft">&#160;</td><td class="mdescRight">Identical to the other <a class="el" href="namespaceipc_1_1util.html#abbba79fcaee378f433e7ce3093e5c435" title="Utility that sets the permissions of the given resource (at the supplied file system path) to specifi...">set_resource_permissions()</a> overload but operates on a pre-opened <a class="el" href="structipc_1_1util_1_1Native__handle.html" title="A monolayer-thin wrapper around a native handle, a/k/a descriptor a/k/a FD.">Native_handle</a> (a/k/a handle, socket, file descriptor) to the resource in question.  <a href="namespaceipc_1_1util.html#af8b2f5a0cd9fe9db4511c9a3e685b6ae">More...</a><br /></td></tr>
<tr class="separator:af8b2f5a0cd9fe9db4511c9a3e685b6ae"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a924cd56daf7eeaa0b07edb352367f9ec"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceipc_1_1util.html#a924cd56daf7eeaa0b07edb352367f9ec">process_running</a> (<a class="el" href="namespaceipc_1_1util.html#a0c44028a45451ebf21f6af8e806b2682">process_id_t</a> process_id)</td></tr>
<tr class="memdesc:a924cd56daf7eeaa0b07edb352367f9ec"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns <code>true</code> if and only if the given process (by PID) is reported as running by the OS.  <a href="namespaceipc_1_1util.html#a924cd56daf7eeaa0b07edb352367f9ec">More...</a><br /></td></tr>
<tr class="separator:a924cd56daf7eeaa0b07edb352367f9ec"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2bb38cee29dacbe56de5182221b45941"><td class="memItemLeft" align="right" valign="top">const uint8_t *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceipc_1_1util.html#a2bb38cee29dacbe56de5182221b45941">blob_data</a> (const <a class="el" href="namespaceipc_1_1util.html#ae0be7edba7e30ffa3f8b742af621f2ab">Blob_const</a> &amp;blob)</td></tr>
<tr class="memdesc:a2bb38cee29dacbe56de5182221b45941"><td class="mdescLeft">&#160;</td><td class="mdescRight">Syntactic-sugary helper that returns pointer to first byte in an immutable buffer, as <code>const uint8_t*</code>.  <a href="namespaceipc_1_1util.html#a2bb38cee29dacbe56de5182221b45941">More...</a><br /></td></tr>
<tr class="separator:a2bb38cee29dacbe56de5182221b45941"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af38a66554a822a470667967c56083e3b"><td class="memItemLeft" align="right" valign="top">uint8_t *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceipc_1_1util.html#af38a66554a822a470667967c56083e3b">blob_data</a> (const <a class="el" href="namespaceipc_1_1util.html#a6cb62ae434900f3a8915b33ec5d61a96">Blob_mutable</a> &amp;blob)</td></tr>
<tr class="memdesc:af38a66554a822a470667967c56083e3b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Syntactic-sugary helper that returns pointer to first byte in a mutable buffer, as <code>uint8_t*</code>.  <a href="namespaceipc_1_1util.html#af38a66554a822a470667967c56083e3b">More...</a><br /></td></tr>
<tr class="separator:af38a66554a822a470667967c56083e3b"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="var-members" name="var-members"></a>
Variables</h2></td></tr>
<tr class="memitem:a5716a13eb4de32e516ca257e025d8c20"><td class="memItemLeft" align="right" valign="top">const boost::array&lt; <a class="el" href="namespaceipc_1_1util.html#a1b398ae730d1e6040687cb2397115152">Permissions</a>, size_t(<a class="el" href="namespaceipc_1_1util.html#a2ec0bfdddb41a1ef0403e4bb8967705da6fba12db09e5bebfaa04f6372c41c2cf">Permissions_level::S_END_SENTINEL</a>)&gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceipc_1_1util.html#a5716a13eb4de32e516ca257e025d8c20">SHARED_RESOURCE_PERMISSIONS_LVL_MAP</a></td></tr>
<tr class="memdesc:a5716a13eb4de32e516ca257e025d8c20"><td class="mdescLeft">&#160;</td><td class="mdescRight">Maps general Permissions_level specifier to low-level <a class="el" href="namespaceipc_1_1util.html#a1b398ae730d1e6040687cb2397115152" title="Short-hand for Unix (POSIX) permissions class.">Permissions</a> value, when the underlying resource is in the file-system and is either accessible (read-write in terms of file system) or inaccessible.  <a href="namespaceipc_1_1util.html#a5716a13eb4de32e516ca257e025d8c20">More...</a><br /></td></tr>
<tr class="separator:a5716a13eb4de32e516ca257e025d8c20"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa74a8b46a5b38021c662a0b3bdfb46bf"><td class="memItemLeft" align="right" valign="top">const boost::array&lt; <a class="el" href="namespaceipc_1_1util.html#a1b398ae730d1e6040687cb2397115152">Permissions</a>, size_t(<a class="el" href="namespaceipc_1_1util.html#a2ec0bfdddb41a1ef0403e4bb8967705da6fba12db09e5bebfaa04f6372c41c2cf">Permissions_level::S_END_SENTINEL</a>)&gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceipc_1_1util.html#aa74a8b46a5b38021c662a0b3bdfb46bf">PRODUCER_CONSUMER_RESOURCE_PERMISSIONS_LVL_MAP</a></td></tr>
<tr class="memdesc:aa74a8b46a5b38021c662a0b3bdfb46bf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Maps general Permissions_level specifier to low-level <a class="el" href="namespaceipc_1_1util.html#a1b398ae730d1e6040687cb2397115152" title="Short-hand for Unix (POSIX) permissions class.">Permissions</a> value, when the underlying resource is in the file-system (e.g., a file) and is <em>produced</em> (and therefore always writable) by the owning (creating, updating) user; but <em>consumed</em> (and therefore at most readable, never writable) by potentially other processes, and therefore possibly other users (e.g., group access or unrestricted access &ndash; but only for reading either way).  <a href="namespaceipc_1_1util.html#aa74a8b46a5b38021c662a0b3bdfb46bf">More...</a><br /></td></tr>
<tr class="separator:aa74a8b46a5b38021c662a0b3bdfb46bf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaaa1fe31f8d77f78345dec8fc95e9882"><td class="memItemLeft" align="right" valign="top">const fs::path&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceipc_1_1util.html#aaaa1fe31f8d77f78345dec8fc95e9882">IPC_KERNEL_PERSISTENT_RUN_DIR</a> = &quot;/var/run&quot;</td></tr>
<tr class="memdesc:aaaa1fe31f8d77f78345dec8fc95e9882"><td class="mdescLeft">&#160;</td><td class="mdescRight">Absolute path to the directory (without trailing separator) in the file system where kernel-persistent runtime, but not temporary, information shall be placed.  <a href="namespaceipc_1_1util.html#aaaa1fe31f8d77f78345dec8fc95e9882">More...</a><br /></td></tr>
<tr class="separator:aaaa1fe31f8d77f78345dec8fc95e9882"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5664539b3d75d6d10cdfebf6eac5382d"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="namespaceipc_1_1util.html#a9571de958538d7a4a8649bbfecfac0b9">Open_or_create</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceipc_1_1util.html#a5664539b3d75d6d10cdfebf6eac5382d">OPEN_OR_CREATE</a></td></tr>
<tr class="memdesc:a5664539b3d75d6d10cdfebf6eac5382d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Tag value indicating an open-if-exists-else-create operation.  <a href="namespaceipc_1_1util.html#a5664539b3d75d6d10cdfebf6eac5382d">More...</a><br /></td></tr>
<tr class="separator:a5664539b3d75d6d10cdfebf6eac5382d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6a3a6ec85242d073df96978c63464078"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="namespaceipc_1_1util.html#a3e03491b5b2b5fac26551a220946d6e5">Open_only</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceipc_1_1util.html#a6a3a6ec85242d073df96978c63464078">OPEN_ONLY</a></td></tr>
<tr class="memdesc:a6a3a6ec85242d073df96978c63464078"><td class="mdescLeft">&#160;</td><td class="mdescRight">Tag value indicating an atomic open-if-exists-else-fail operation.  <a href="namespaceipc_1_1util.html#a6a3a6ec85242d073df96978c63464078">More...</a><br /></td></tr>
<tr class="separator:a6a3a6ec85242d073df96978c63464078"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad1ca1cab79a35e1eb1c47037a0973cd8"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="namespaceipc_1_1util.html#a9d84c2bab504e6de32b20c77ca9723a2">Create_only</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceipc_1_1util.html#ad1ca1cab79a35e1eb1c47037a0973cd8">CREATE_ONLY</a></td></tr>
<tr class="memdesc:ad1ca1cab79a35e1eb1c47037a0973cd8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Tag value indicating an atomic create-unless-exists-else-fail operation.  <a href="namespaceipc_1_1util.html#ad1ca1cab79a35e1eb1c47037a0973cd8">More...</a><br /></td></tr>
<tr class="separator:ad1ca1cab79a35e1eb1c47037a0973cd8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aca6ca223759ca3e11d5834a323454afa"><td class="memItemLeft" align="right" valign="top">const std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceipc_1_1util.html#aca6ca223759ca3e11d5834a323454afa">EMPTY_STRING</a></td></tr>
<tr class="memdesc:aca6ca223759ca3e11d5834a323454afa"><td class="mdescLeft">&#160;</td><td class="mdescRight">A (default-cted) string. May be useful for functions returning <code>const std::string&amp;</code>.  <a href="namespaceipc_1_1util.html#aca6ca223759ca3e11d5834a323454afa">More...</a><br /></td></tr>
<tr class="separator:aca6ca223759ca3e11d5834a323454afa"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p >Flow-IPC module containing miscellaneous general-use facilities that ubiquitously used by ~all Flow-IPC modules and/or do not fit into any other Flow-IPC module. </p>
<p >Each symbol therein is typically used by at least 1 other Flow-IPC module; but all public symbols (except ones under a detail/ subdirectory) are intended for use by Flow-IPC user as well. Some particulars to note:</p>
<p ><a class="el" href="classipc_1_1util_1_1Shared__name.html" title="String-wrapping abstraction representing a name uniquely distinguishing a kernel-persistent entity fr...">ipc::util::Shared_name</a> is a universally used shared-resource name class, conceptually similar to <code>boost::filesystem::path</code>. It is used in <a class="el" href="namespaceipc_1_1transport.html" title="Flow-IPC module providing transmission of structured messages and/or low-level blobs (and more) betwe...">ipc::transport</a> APIs &ndash; namely to name endpoints when establishing channels, and more &ndash; but also in other Flow-IPC modules. For example <code><a class="el" href="classipc_1_1util_1_1Shared__name.html" title="String-wrapping abstraction representing a name uniquely distinguishing a kernel-persistent entity fr...">Shared_name</a></code> is used to name certain SHM entities in <a class="el" href="namespaceipc_1_1shm.html" title="Modules for SHared Memory (SHM) support.">ipc::shm</a> and in <a class="el" href="namespaceipc_1_1session.html" title="Flow-IPC module providing the broad lifecycle and shared-resource organization – via the session conc...">ipc::session</a> when connecting to conversation partner process(es).</p>
<p ><a class="el" href="structipc_1_1util_1_1Native__handle.html" title="A monolayer-thin wrapper around a native handle, a/k/a descriptor a/k/a FD.">ipc::util::Native_handle</a> is a commonly used native-handle (FD in POSIX parlance) wrapper (so thin it doesn't add a single bit on top of the actul FD). These are ~always passed around by value (copied), as they are very small in practice.</p>
<p >There are of course various other things; just check them out as they are referenced, or just look around. Note there are free functions providing various niceties; and more types including classes and scoped <code>enum</code>s. </p>
</div><h2 class="groupheader">Typedef Documentation</h2>
<a id="ae0be7edba7e30ffa3f8b742af621f2ab" name="ae0be7edba7e30ffa3f8b742af621f2ab"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae0be7edba7e30ffa3f8b742af621f2ab">&#9670;&nbsp;</a></span>Blob_const</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespaceipc_1_1util.html#ae0be7edba7e30ffa3f8b742af621f2ab">ipc::util::Blob_const</a> = typedef boost::asio::const_buffer</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Short-hand for an immutable blob somewhere in memory, stored as exactly a <code>void const *</code> and a <code>size_t</code>. </p>
<h3>How to use</h3>
<p >We provide this alias as a stylistic short-hand, as it better suits various interfaces especially in <a class="el" href="namespaceipc_1_1transport.html" title="Flow-IPC module providing transmission of structured messages and/or low-level blobs (and more) betwe...">ipc::transport</a>. Nevertheless it's not meant to more than that; it's an attempt to abstract it away.</p>
<p >That is to say, to work with these (create them, access them, etc.), do use the highly convenient boost.asio buffer APIs which are well documented in boost.asio's docs. </p>

<p class="definition">Definition at line <a class="el" href="util__fwd_8hpp_source.html#l00128">128</a> of file <a class="el" href="util__fwd_8hpp_source.html">util_fwd.hpp</a>.</p>

</div>
</div>
<a id="a6cb62ae434900f3a8915b33ec5d61a96" name="a6cb62ae434900f3a8915b33ec5d61a96"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6cb62ae434900f3a8915b33ec5d61a96">&#9670;&nbsp;</a></span>Blob_mutable</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespaceipc_1_1util.html#a6cb62ae434900f3a8915b33ec5d61a96">ipc::util::Blob_mutable</a> = typedef boost::asio::mutable_buffer</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Short-hand for an mutable blob somewhere in memory, stored as exactly a <code>void*</code> and a <code>size_t</code>. </p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="namespaceipc_1_1util.html#ae0be7edba7e30ffa3f8b742af621f2ab" title="Short-hand for an immutable blob somewhere in memory, stored as exactly a void const * and a size_t.">ipc::util::Blob_const</a>; usability notes in that doc header apply similarly here. </dd></dl>

<p class="definition">Definition at line <a class="el" href="util__fwd_8hpp_source.html#l00134">134</a> of file <a class="el" href="util__fwd_8hpp_source.html">util_fwd.hpp</a>.</p>

</div>
</div>
<a id="a9d84c2bab504e6de32b20c77ca9723a2" name="a9d84c2bab504e6de32b20c77ca9723a2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9d84c2bab504e6de32b20c77ca9723a2">&#9670;&nbsp;</a></span>Create_only</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespaceipc_1_1util.html#a9d84c2bab504e6de32b20c77ca9723a2">ipc::util::Create_only</a> = typedef bipc::create_only_t</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Tag type indicating a create-unless-exists-else-fail operation. </p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="namespaceipc_1_1util.html#ad1ca1cab79a35e1eb1c47037a0973cd8" title="Tag value indicating an atomic create-unless-exists-else-fail operation.">CREATE_ONLY</a>. </dd></dl>

<p class="definition">Definition at line <a class="el" href="util__fwd_8hpp_source.html#l00152">152</a> of file <a class="el" href="util__fwd_8hpp_source.html">util_fwd.hpp</a>.</p>

</div>
</div>
<a id="ac66141280c3b7295a86b65209f31cc58" name="ac66141280c3b7295a86b65209f31cc58"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac66141280c3b7295a86b65209f31cc58">&#9670;&nbsp;</a></span>Fine_duration</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespaceipc_1_1util.html#ac66141280c3b7295a86b65209f31cc58">ipc::util::Fine_duration</a> = typedef flow::Fine_duration</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Short-hand for Flow's <code>Fine_duration</code>. </p>

<p class="definition">Definition at line <a class="el" href="util__fwd_8hpp_source.html#l00111">111</a> of file <a class="el" href="util__fwd_8hpp_source.html">util_fwd.hpp</a>.</p>

</div>
</div>
<a id="aa3808edfc4d59bce4b9800d6a60026d3" name="aa3808edfc4d59bce4b9800d6a60026d3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa3808edfc4d59bce4b9800d6a60026d3">&#9670;&nbsp;</a></span>Fine_time_pt</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespaceipc_1_1util.html#aa3808edfc4d59bce4b9800d6a60026d3">ipc::util::Fine_time_pt</a> = typedef flow::Fine_time_pt</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Short-hand for Flow's <code>Fine_time_pt</code>. </p>

<p class="definition">Definition at line <a class="el" href="util__fwd_8hpp_source.html#l00113">113</a> of file <a class="el" href="util__fwd_8hpp_source.html">util_fwd.hpp</a>.</p>

</div>
</div>
<a id="a3f7d069ce0d23f73153da2e2559dc3d3" name="a3f7d069ce0d23f73153da2e2559dc3d3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3f7d069ce0d23f73153da2e2559dc3d3">&#9670;&nbsp;</a></span>group_id_t</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespaceipc_1_1util.html#a3f7d069ce0d23f73153da2e2559dc3d3">ipc::util::group_id_t</a> = typedef ::gid_t</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Syntactic-sugary type for POSIX group ID (integer). </p>

<p class="definition">Definition at line <a class="el" href="util__fwd_8hpp_source.html#l00143">143</a> of file <a class="el" href="util__fwd_8hpp_source.html">util_fwd.hpp</a>.</p>

</div>
</div>
<a id="a3e03491b5b2b5fac26551a220946d6e5" name="a3e03491b5b2b5fac26551a220946d6e5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3e03491b5b2b5fac26551a220946d6e5">&#9670;&nbsp;</a></span>Open_only</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespaceipc_1_1util.html#a3e03491b5b2b5fac26551a220946d6e5">ipc::util::Open_only</a> = typedef bipc::open_only_t</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Tag type indicating an ideally-atomic open-if-exists-else-fail operation. </p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="namespaceipc_1_1util.html#a6a3a6ec85242d073df96978c63464078" title="Tag value indicating an atomic open-if-exists-else-fail operation.">OPEN_ONLY</a>. </dd></dl>

<p class="definition">Definition at line <a class="el" href="util__fwd_8hpp_source.html#l00149">149</a> of file <a class="el" href="util__fwd_8hpp_source.html">util_fwd.hpp</a>.</p>

</div>
</div>
<a id="a9571de958538d7a4a8649bbfecfac0b9" name="a9571de958538d7a4a8649bbfecfac0b9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9571de958538d7a4a8649bbfecfac0b9">&#9670;&nbsp;</a></span>Open_or_create</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespaceipc_1_1util.html#a9571de958538d7a4a8649bbfecfac0b9">ipc::util::Open_or_create</a> = typedef bipc::open_or_create_t</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Tag type indicating an atomic open-if-exists-else-create operation. </p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="namespaceipc_1_1util.html#a5664539b3d75d6d10cdfebf6eac5382d" title="Tag value indicating an open-if-exists-else-create operation.">OPEN_OR_CREATE</a>. </dd></dl>

<p class="definition">Definition at line <a class="el" href="util__fwd_8hpp_source.html#l00146">146</a> of file <a class="el" href="util__fwd_8hpp_source.html">util_fwd.hpp</a>.</p>

</div>
</div>
<a id="a1b398ae730d1e6040687cb2397115152" name="a1b398ae730d1e6040687cb2397115152"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1b398ae730d1e6040687cb2397115152">&#9670;&nbsp;</a></span>Permissions</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespaceipc_1_1util.html#a1b398ae730d1e6040687cb2397115152">ipc::util::Permissions</a> = typedef bipc::permissions</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Short-hand for Unix (POSIX) permissions class. </p>

<p class="definition">Definition at line <a class="el" href="util__fwd_8hpp_source.html#l00155">155</a> of file <a class="el" href="util__fwd_8hpp_source.html">util_fwd.hpp</a>.</p>

</div>
</div>
<a id="aaf368acf8243bb25de3eef4e836c15de" name="aaf368acf8243bb25de3eef4e836c15de"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaf368acf8243bb25de3eef4e836c15de">&#9670;&nbsp;</a></span>Pipe_reader</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespaceipc_1_1util.html#aaf368acf8243bb25de3eef4e836c15de">ipc::util::Pipe_reader</a> = typedef boost::asio::readable_pipe</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Short-hand for anonymous pipe read end. </p>

<p class="definition">Definition at line <a class="el" href="detail_2util__fwd_8hpp_source.html#l00035">35</a> of file <a class="el" href="detail_2util__fwd_8hpp_source.html">util_fwd.hpp</a>.</p>

</div>
</div>
<a id="a844d5ca9c17b672644fc8d9dbe758db0" name="a844d5ca9c17b672644fc8d9dbe758db0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a844d5ca9c17b672644fc8d9dbe758db0">&#9670;&nbsp;</a></span>Pipe_writer</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespaceipc_1_1util.html#a844d5ca9c17b672644fc8d9dbe758db0">ipc::util::Pipe_writer</a> = typedef boost::asio::writable_pipe</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Short-hand for anonymous pipe write end. </p>

<p class="definition">Definition at line <a class="el" href="detail_2util__fwd_8hpp_source.html#l00032">32</a> of file <a class="el" href="detail_2util__fwd_8hpp_source.html">util_fwd.hpp</a>.</p>

</div>
</div>
<a id="a0c44028a45451ebf21f6af8e806b2682" name="a0c44028a45451ebf21f6af8e806b2682"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0c44028a45451ebf21f6af8e806b2682">&#9670;&nbsp;</a></span>process_id_t</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespaceipc_1_1util.html#a0c44028a45451ebf21f6af8e806b2682">ipc::util::process_id_t</a> = typedef ::pid_t</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Syntactic-sugary type for POSIX process ID (integer). </p>

<p class="definition">Definition at line <a class="el" href="util__fwd_8hpp_source.html#l00137">137</a> of file <a class="el" href="util__fwd_8hpp_source.html">util_fwd.hpp</a>.</p>

</div>
</div>
<a id="ae6ac47812a90d1287c61e0b7de7bc4f5" name="ae6ac47812a90d1287c61e0b7de7bc4f5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae6ac47812a90d1287c61e0b7de7bc4f5">&#9670;&nbsp;</a></span>String_view</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespaceipc_1_1util.html#ae6ac47812a90d1287c61e0b7de7bc4f5">ipc::util::String_view</a> = typedef flow::util::String_view</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Short-hand for Flow's <code>String_view</code>. </p>

<p class="definition">Definition at line <a class="el" href="util__fwd_8hpp_source.html#l00109">109</a> of file <a class="el" href="util__fwd_8hpp_source.html">util_fwd.hpp</a>.</p>

</div>
</div>
<a id="a31e67d3a017477a04b313927e2f2c733" name="a31e67d3a017477a04b313927e2f2c733"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a31e67d3a017477a04b313927e2f2c733">&#9670;&nbsp;</a></span>Task</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespaceipc_1_1util.html#a31e67d3a017477a04b313927e2f2c733">ipc::util::Task</a> = typedef flow::async::Task</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Short-hand for polymorphic function (a-la <code>std::function&lt;&gt;</code>) that takes no arguments and returns nothing. </p>

<p class="definition">Definition at line <a class="el" href="util__fwd_8hpp_source.html#l00116">116</a> of file <a class="el" href="util__fwd_8hpp_source.html">util_fwd.hpp</a>.</p>

</div>
</div>
<a id="a6435c1b48ec8684c24ca406d1d17208e" name="a6435c1b48ec8684c24ca406d1d17208e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6435c1b48ec8684c24ca406d1d17208e">&#9670;&nbsp;</a></span>user_id_t</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespaceipc_1_1util.html#a6435c1b48ec8684c24ca406d1d17208e">ipc::util::user_id_t</a> = typedef ::uid_t</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Syntactic-sugary type for POSIX user ID (integer). </p>

<p class="definition">Definition at line <a class="el" href="util__fwd_8hpp_source.html#l00140">140</a> of file <a class="el" href="util__fwd_8hpp_source.html">util_fwd.hpp</a>.</p>

</div>
</div>
<h2 class="groupheader">Enumeration Type Documentation</h2>
<a id="a2ec0bfdddb41a1ef0403e4bb8967705d" name="a2ec0bfdddb41a1ef0403e4bb8967705d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2ec0bfdddb41a1ef0403e4bb8967705d">&#9670;&nbsp;</a></span>Permissions_level</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">enum class <a class="el" href="namespaceipc_1_1util.html#a2ec0bfdddb41a1ef0403e4bb8967705d">ipc::util::Permissions_level</a> : size_t</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">strong</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Simple specifier of desired access permissions, usually but not necessarily translated into a <code>Permissions</code> value (though even then different value in different contexts). </p>
<p >May be used to map, say, from a Permissions_level to a <a class="el" href="namespaceipc_1_1util.html#a1b398ae730d1e6040687cb2397115152" title="Short-hand for Unix (POSIX) permissions class.">Permissions</a> value in an <code>array&lt;Permissions, size_t(Permissions_level::S_END_SENTINEL)&gt;</code>.</p>
<p >While, unlike <a class="el" href="namespaceipc_1_1util.html#a1b398ae730d1e6040687cb2397115152" title="Short-hand for Unix (POSIX) permissions class.">Permissions</a>, this <code>enum</code> intends not be overtly based on a POSIX RWXRWXRWC model, it does still assume the 3 user groupings are "user themselves," "user's group," and "everyone." The 1st and 3rd are likely universal, but the 2nd may not apply to all OS &ndash; through probably all POSIX/Unix ones &ndash; and even for something like Linux there could be different groupings such as ones based on OS ACL. As of this writing it's fine, as this is a POSIX-targeted library at least (in fact, Linux, as of this writing, but that could change to include, say, MacOS/BSD).</p>
<h3>Maintenance</h3>
<p >Do <em>not</em> change the order of these constants unless absolutely necessary. In general any change here means updating any <code>array&lt;&gt;</code>s (etc.) that map implicitly from a <code>size_t</code> representing Permissions_level. By convention they are named <code>*_PERMISSIONS_LVL_MAP</code> as of this writing.</p>
<p >The <code>array&lt;&gt;</code> mapping scheme is for max performance; if one uses an <code>unordered_map</code> or similar, then there is no similar issue. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="a2ec0bfdddb41a1ef0403e4bb8967705dac43e9194d6c0e9803ecabbf3cb4c97fa" name="a2ec0bfdddb41a1ef0403e4bb8967705dac43e9194d6c0e9803ecabbf3cb4c97fa"></a>S_NO_ACCESS&#160;</td><td class="fielddoc"><p >Forbids all access, even by the creator's user. Most likely this would be useful for testing or debugging. </p>
</td></tr>
<tr><td class="fieldname"><a id="a2ec0bfdddb41a1ef0403e4bb8967705daa3e1d310128f18fe2f903bf3cba8849a" name="a2ec0bfdddb41a1ef0403e4bb8967705daa3e1d310128f18fe2f903bf3cba8849a"></a>S_USER_ACCESS&#160;</td><td class="fielddoc"><p >Allows access by resource-owning user (in POSIX/Unix identified by UID) and no one else. </p>
</td></tr>
<tr><td class="fieldname"><a id="a2ec0bfdddb41a1ef0403e4bb8967705daa5508fa6037b9c0926cf7eb20af97a6d" name="a2ec0bfdddb41a1ef0403e4bb8967705daa5508fa6037b9c0926cf7eb20af97a6d"></a>S_GROUP_ACCESS&#160;</td><td class="fielddoc"><p >Allows access by resource-owning user's containing group(s) (in POSIX/Unix identified by GID) and no one else. </p>
<p >This implies, as well, at least as much access as <code>S_USER_ACCESS</code>. </p>
</td></tr>
<tr><td class="fieldname"><a id="a2ec0bfdddb41a1ef0403e4bb8967705da25bf1cdee66ff5f73914fd5b0ee996e9" name="a2ec0bfdddb41a1ef0403e4bb8967705da25bf1cdee66ff5f73914fd5b0ee996e9"></a>S_UNRESTRICTED&#160;</td><td class="fielddoc"><p >Allows access by all. Implies, as well, at least as much access as <code>S_GROUP_ACCESS</code> and thus <code>S_USER_ACCESS</code>. </p>
</td></tr>
<tr><td class="fieldname"><a id="a2ec0bfdddb41a1ef0403e4bb8967705da6fba12db09e5bebfaa04f6372c41c2cf" name="a2ec0bfdddb41a1ef0403e4bb8967705da6fba12db09e5bebfaa04f6372c41c2cf"></a>S_END_SENTINEL&#160;</td><td class="fielddoc"><p >Sentinel: not a valid value. May be used to, e.g., size an <code>array&lt;&gt;</code> mapping from Permissions_level. </p>
</td></tr>
</table>

<p class="definition">Definition at line <a class="el" href="util__fwd_8hpp_source.html#l00087">87</a> of file <a class="el" href="util__fwd_8hpp_source.html">util_fwd.hpp</a>.</p>

</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a id="a2bb38cee29dacbe56de5182221b45941" name="a2bb38cee29dacbe56de5182221b45941"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2bb38cee29dacbe56de5182221b45941">&#9670;&nbsp;</a></span>blob_data() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const uint8_t * ipc::util::blob_data </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespaceipc_1_1util.html#ae0be7edba7e30ffa3f8b742af621f2ab">Blob_const</a> &amp;&#160;</td>
          <td class="paramname"><em>blob</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Syntactic-sugary helper that returns pointer to first byte in an immutable buffer, as <code>const uint8_t*</code>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">blob</td><td>The buffer. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>See above. </dd></dl>

<p class="definition">Definition at line <a class="el" href="ipc__core_2src_2ipc_2util_2util_8cpp_source.html#l00156">156</a> of file <a class="el" href="ipc__core_2src_2ipc_2util_2util_8cpp_source.html">util.cpp</a>.</p>

<p class="reference">Referenced by <a class="el" href="asio__local__stream__socket_8hpp_source.html#l00170">ipc::transport::asio_local_stream_socket::async_write_with_native_handle()</a>, <a class="el" href="detail_2asio__local__stream__socket_8hpp_source.html#l00031">ipc::transport::asio_local_stream_socket::on_wait_writable_or_error()</a>, <a class="el" href="bipc__mq__handle_8cpp_source.html#l00200">ipc::transport::Bipc_mq_handle::send()</a>, <a class="el" href="posix__mq__handle_8cpp_source.html#l00728">ipc::transport::Posix_mq_handle::send()</a>, <a class="el" href="bipc__mq__handle_8cpp_source.html#l00262">ipc::transport::Bipc_mq_handle::timed_send()</a>, <a class="el" href="posix__mq__handle_8cpp_source.html#l00796">ipc::transport::Posix_mq_handle::timed_send()</a>, <a class="el" href="bipc__mq__handle_8cpp_source.html#l00154">ipc::transport::Bipc_mq_handle::try_send()</a>, and <a class="el" href="posix__mq__handle_8cpp_source.html#l00678">ipc::transport::Posix_mq_handle::try_send()</a>.</p>
<div class="dynheader">
Here is the caller graph for this function:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="namespaceipc_1_1util_a2bb38cee29dacbe56de5182221b45941_icgraph.svg" width="774" height="628"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe>
</div>
</div>

</div>
</div>
<a id="af38a66554a822a470667967c56083e3b" name="af38a66554a822a470667967c56083e3b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af38a66554a822a470667967c56083e3b">&#9670;&nbsp;</a></span>blob_data() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint8_t * ipc::util::blob_data </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespaceipc_1_1util.html#a6cb62ae434900f3a8915b33ec5d61a96">Blob_mutable</a> &amp;&#160;</td>
          <td class="paramname"><em>blob</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Syntactic-sugary helper that returns pointer to first byte in a mutable buffer, as <code>uint8_t*</code>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">blob</td><td>The buffer. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>See above. </dd></dl>

<p class="definition">Definition at line <a class="el" href="ipc__core_2src_2ipc_2util_2util_8cpp_source.html#l00168">168</a> of file <a class="el" href="ipc__core_2src_2ipc_2util_2util_8cpp_source.html">util.cpp</a>.</p>

</div>
</div>
<a id="a71fa0c2bd2c45109a9fbab4b048c666d" name="a71fa0c2bd2c45109a9fbab4b048c666d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a71fa0c2bd2c45109a9fbab4b048c666d">&#9670;&nbsp;</a></span>build_conventional_non_session_based_shared_name()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classipc_1_1util_1_1Shared__name.html">Shared_name</a> ipc::util::build_conventional_non_session_based_shared_name </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classipc_1_1util_1_1Shared__name.html">Shared_name</a> &amp;&#160;</td>
          <td class="paramname"><em>resource_type</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Builds an absolute name according to the path convention explained in <a class="el" href="classipc_1_1util_1_1Shared__name.html" title="String-wrapping abstraction representing a name uniquely distinguishing a kernel-persistent entity fr...">Shared_name</a> class doc header; this overload applies to resources <em>outside</em> the <a class="el" href="namespaceipc_1_1session.html" title="Flow-IPC module providing the broad lifecycle and shared-resource organization – via the session conc...">ipc::session</a> paradigm. </p>
<p >Typically one would then add a <a class="el" href="classipc_1_1util_1_1Shared__name.html#a5c0910497c5ec484d3e42dfb0ccad48d" title="Character we use, by convention, to separate conceptual folders within str().">Shared_name::S_SEPARATOR</a> and then purpose-specific path component(s) (via <code>/=</code> or similar).</p>
<p >Behavior is undefined if a path fragment argument is empty (assertion may trip).</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">resource_type</td><td>Resource type constant. Typically it is available as a <code>S_RESOURCE_TYPE_ID</code> constant in some class; otherwise as a <code>Shared_name::S_RESOURCE_TYPE_ID_*</code> constant. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Absolute path not ending in <code>S_SEPARATOR</code>, typically to be appended with a <code>S_SEPARATOR</code> and more component(s) by the caller. </dd></dl>

<p class="definition">Definition at line <a class="el" href="shared__name_8cpp_source.html#l00337">337</a> of file <a class="el" href="shared__name_8cpp_source.html">shared_name.cpp</a>.</p>

<p class="reference">References <a class="el" href="shared__name_8cpp_source.html#l00155">ipc::util::Shared_name::empty()</a>, <a class="el" href="shared__name_8hpp_source.html#l00272">ipc::util::Shared_name::S_ROOT_MAGIC</a>, and <a class="el" href="shared__name_8hpp_source.html#l00280">ipc::util::Shared_name::S_SENTINEL</a>.</p>

<p class="reference">Referenced by <a class="el" href="blob__stream__mq__impl_8hpp_source.html#l00344">ipc::transport::Blob_stream_mq_base_impl&lt; Persistent_mq_handle &gt;::mq_sentinel_name()</a>.</p>
<div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="namespaceipc_1_1util_a71fa0c2bd2c45109a9fbab4b048c666d_cgraph.svg" width="419" height="47"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe>
</div>
</div>
<div class="dynheader">
Here is the caller graph for this function:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="namespaceipc_1_1util_a71fa0c2bd2c45109a9fbab4b048c666d_icgraph.svg" width="419" height="59"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe>
</div>
</div>

</div>
</div>
<a id="a49b39ceb74614b5f2d26dd86fd71bcb3" name="a49b39ceb74614b5f2d26dd86fd71bcb3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a49b39ceb74614b5f2d26dd86fd71bcb3">&#9670;&nbsp;</a></span>for_each_persistent_impl()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Handle_name_func &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void ipc::util::for_each_persistent_impl </td>
          <td>(</td>
          <td class="paramtype">const fs::path &amp;&#160;</td>
          <td class="paramname"><em>persistent_obj_dev_dir_path</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Handle_name_func &amp;&#160;</td>
          <td class="paramname"><em>handle_name_func</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Implementation of <code>Persistent_object::for_each_persistent()</code>; for example see <a class="el" href="classipc_1_1shm_1_1classic_1_1Pool__arena.html#a9e720283945eefe3d941b185e95d2ce1" title="Lists all named SHM pool objects currently persisting, invoking the given handler synchronously on ea...">shm::classic::Pool_arena::for_each_persistent()</a>. </p>
<p >It relies on the OS feature wherein each particular <code>Persistent_object</code> (kernel-persistent object) type is listed in flat fashion in a particular directory; <code>persistent_obj_dev_dir_path</code> must specify this directory.</p>
<p >Conceptually, we shall perform <code>ls D/</code>, where <code>D</code> is <code>persistent_obj_dev_dir_path</code>. Then for each resulting <code>D/N</code>, we shall call <code>handle_name_func(N)</code>.</p>
<h3>Errors (or lack thereof)</h3>
<p >There is no error condition. If <code>persistent_obj_dev_dir_path</code> does not exist, or we lack permissions to look therein, it merely means it cannot contain any relevant items; hence <code>handle_name_func()</code> is not invoked.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Handle_name_func</td><td>See, e.g., <a class="el" href="classipc_1_1shm_1_1classic_1_1Pool__arena.html#a9e720283945eefe3d941b185e95d2ce1" title="Lists all named SHM pool objects currently persisting, invoking the given handler synchronously on ea...">shm::classic::Pool_arena::for_each_persistent()</a>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">persistent_obj_dev_dir_path</td><td>This must be an absolute path, or behavior is undefined (assertion may trip). See above. </td></tr>
    <tr><td class="paramname">handle_name_func</td><td>See <code>Handle_name_func</code>. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="util_8hpp_source.html#l00090">90</a> of file <a class="el" href="util_8hpp_source.html">util.hpp</a>.</p>

<p class="reference">References <a class="el" href="shared__name_8hpp_source.html#l00674">ipc::util::Shared_name::ct()</a>.</p>

<p class="reference">Referenced by <a class="el" href="posix__mq__handle_8hpp_source.html#l00683">ipc::transport::Posix_mq_handle::for_each_persistent()</a>, and <a class="el" href="util_8hpp_source.html#l00130">for_each_persistent_shm_pool()</a>.</p>
<div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="namespaceipc_1_1util_a49b39ceb74614b5f2d26dd86fd71bcb3_cgraph.svg" width="342" height="47"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe>
</div>
</div>
<div class="dynheader">
Here is the caller graph for this function:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="namespaceipc_1_1util_a49b39ceb74614b5f2d26dd86fd71bcb3_icgraph.svg" width="511" height="162"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe>
</div>
</div>

</div>
</div>
<a id="a74135195ff6c2f840092c21e522f964a" name="a74135195ff6c2f840092c21e522f964a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a74135195ff6c2f840092c21e522f964a">&#9670;&nbsp;</a></span>for_each_persistent_shm_pool()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Handle_name_func &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void ipc::util::for_each_persistent_shm_pool </td>
          <td>(</td>
          <td class="paramtype">const Handle_name_func &amp;&#160;</td>
          <td class="paramname"><em>handle_name_func</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Equivalent to <a class="el" href="classipc_1_1shm_1_1classic_1_1Pool__arena.html#a9e720283945eefe3d941b185e95d2ce1" title="Lists all named SHM pool objects currently persisting, invoking the given handler synchronously on ea...">shm::classic::Pool_arena::for_each_persistent()</a>. </p>
<p >Provided here (for internal purposes as of this writing) to avoid a little circular-inter-component-dependent problem: Posix_mq_handle::for_each_persistent() needs us; but accessing <code>Pool_arena</code> would mean <code>ipc_core</code> Flow-IPC sub-component needing <code>ipc_shm</code> sub-component as a dependency... but the reverse is already naturally the case. See <a class="el" href="namespaceipc.html" title="Catch-all namespace for the Flow-IPC project: A library/API in modern C++17 providing high-performanc...">ipc</a> namespace doc header for discussion of the component hierarchy and how we prefer to avoid circular dependencies therein.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Handle_name_func</td><td>See above. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">handle_name_func</td><td>See above. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="util_8hpp_source.html#l00130">130</a> of file <a class="el" href="util_8hpp_source.html">util.hpp</a>.</p>

<p class="reference">References <a class="el" href="util_8hpp_source.html#l00090">for_each_persistent_impl()</a>.</p>

<p class="reference">Referenced by <a class="el" href="bipc__mq__handle_8hpp_source.html#l00620">ipc::transport::Bipc_mq_handle::for_each_persistent()</a>, and <a class="el" href="pool__arena_8hpp_source.html#l00769">ipc::shm::classic::Pool_arena::for_each_persistent()</a>.</p>
<div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="namespaceipc_1_1util_a74135195ff6c2f840092c21e522f964a_cgraph.svg" width="528" height="47"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe>
</div>
</div>
<div class="dynheader">
Here is the caller graph for this function:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="namespaceipc_1_1util_a74135195ff6c2f840092c21e522f964a_icgraph.svg" width="340" height="131"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe>
</div>
</div>

</div>
</div>
<a id="aba4ae811264cbb7e664ce126b591cbc7" name="aba4ae811264cbb7e664ce126b591cbc7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aba4ae811264cbb7e664ce126b591cbc7">&#9670;&nbsp;</a></span>hash_value() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t hash_value </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classipc_1_1util_1_1Shared__name.html">Shared_name</a> &amp;&#160;</td>
          <td class="paramname"><em>val</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Hasher of <a class="el" href="classipc_1_1util_1_1Shared__name.html" title="String-wrapping abstraction representing a name uniquely distinguishing a kernel-persistent entity fr...">Shared_name</a> for boost.unordered et al. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">val</td><td>Object to hash. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>See above. </dd></dl>

<p class="definition">Definition at line <a class="el" href="shared__name_8cpp_source.html#l00412">412</a> of file <a class="el" href="shared__name_8cpp_source.html">shared_name.cpp</a>.</p>

</div>
</div>
<a id="ad3883df3081441d71a9a989073264b04" name="ad3883df3081441d71a9a989073264b04"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad3883df3081441d71a9a989073264b04">&#9670;&nbsp;</a></span>hash_value() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t hash_value </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structipc_1_1util_1_1Native__handle.html">Native_handle</a>&#160;</td>
          <td class="paramname"><em>val</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Hasher of <a class="el" href="structipc_1_1util_1_1Native__handle.html" title="A monolayer-thin wrapper around a native handle, a/k/a descriptor a/k/a FD.">Native_handle</a> for boost.unordered et al. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">val</td><td>Object to hash. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>See above. </dd></dl>

<p class="definition">Definition at line <a class="el" href="native__handle_8cpp_source.html#l00089">89</a> of file <a class="el" href="native__handle_8cpp_source.html">native_handle.cpp</a>.</p>

</div>
</div>
<a id="abd43da87aa17031604c7906757c07d46" name="abd43da87aa17031604c7906757c07d46"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abd43da87aa17031604c7906757c07d46">&#9670;&nbsp;</a></span>op_with_possible_bipc_exception()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Func &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void ipc::util::op_with_possible_bipc_exception </td>
          <td>(</td>
          <td class="paramtype">flow::log::Logger *&#160;</td>
          <td class="paramname"><em>logger_ptr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceipc.html#aa3192e586cc45d3e7c22463bf2760f89">Error_code</a> *&#160;</td>
          <td class="paramname"><em>err_code</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespaceipc.html#aa3192e586cc45d3e7c22463bf2760f89">Error_code</a> &amp;&#160;</td>
          <td class="paramname"><em>misc_bipc_lib_error</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceipc_1_1util.html#ae6ac47812a90d1287c61e0b7de7bc4f5">String_view</a>&#160;</td>
          <td class="paramname"><em>context</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Func &amp;&#160;</td>
          <td class="paramname"><em>func</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Internal (to <a class="el" href="namespaceipc.html" title="Catch-all namespace for the Flow-IPC project: A library/API in modern C++17 providing high-performanc...">ipc</a>) utility that invokes the given function that invokes a boost.interprocess operation that is documented to throw <code>bipc::interprocess_exception</code> on failure; if indeed it throws the utility emits an error in the Flow error-reporting style. </p>
<p >On error it logs WARNING with all available details.</p>
<h3>Background</h3>
<p >boost.interprocess has a number of operations that are documented to throw the aforementioned exception on error &ndash; without any alternate way of reporting an error such as through an out-arg. Moreover the exception itself is not any standard runtime-exception type but rather a custom thing. This is somewhat annoying; and various parts of <a class="el" href="namespaceipc.html" title="Catch-all namespace for the Flow-IPC project: A library/API in modern C++17 providing high-performanc...">ipc</a> want to emit errors in a consistent way. That does <em>not</em> mean we must only emit some <code><a class="el" href="namespaceipc_1_1transport_1_1error.html#adfef15ef4e76cc55d652fbd9c2797297" title="All possible errors returned (via Error_code arguments) by ipc::transport functions/methods outside o...">transport::error::Code</a>::*</code> or whatever, but we should emit a native-based <a class="el" href="namespaceipc.html#aa3192e586cc45d3e7c22463bf2760f89" title="Short-hand for flow::Error_code which is very common.">Error_code</a> if applicable, either as an out-arg or as a <code>flow::error::Runtime_error</code> wrapping it, or indeed one of our own codes otherwise (or if it is more applicable).</p>
<p >So this helper standardizes that stuff.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Func</td><td>Functor that takes no args and returns nothing. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">logger_ptr</td><td>Logger to use for logging subsequently. </td></tr>
    <tr><td class="paramname">err_code</td><td><code>err_code</code> as-if passed to our API. <code>*err_code</code> shall be set if not null depending on success/failure; if null and no problem, won't throw; if null and problem will throw <code>Runtime_error</code> containing a truthy <a class="el" href="namespaceipc.html#aa3192e586cc45d3e7c22463bf2760f89" title="Short-hand for flow::Error_code which is very common.">Error_code</a>. That's the usual Flow-style error emission semantics. </td></tr>
    <tr><td class="paramname">misc_bipc_lib_error</td><td>If <code>func</code> throws, and we are unable to suss out the system error that caused it, then emit this value. E.g.: transport::Code::S_MQ_BIPC_MISC_LIBRARY_ERROR makes sense if creating a <code>bipc::message_queue</code>; or a similar one for SHM-related parts of <code>bipc</code>; etc. </td></tr>
    <tr><td class="paramname">context</td><td>Description for logging of the op being attempted, in case there is an error. Compile-time-known strings are best, as this is not protected by a filtering macro and hence will be evaluated no matter what. </td></tr>
    <tr><td class="paramname">func</td><td><code>func()</code> shall be executed synchronously. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="util_8hpp_source.html#l00034">34</a> of file <a class="el" href="util_8hpp_source.html">util.hpp</a>.</p>

<p class="reference">References <a class="el" href="util_8hpp_source.html#l00034">op_with_possible_bipc_exception()</a>.</p>

<p class="reference">Referenced by <a class="el" href="ipc__session_2src_2ipc_2session_2detail_2client__session__impl_8hpp_source.html#l01127">ipc::session::Client_session_impl&lt; S_MQ_TYPE_OR_NONE, S_TRANSMIT_NATIVE_HANDLES, Mdt_payload, S_SHM_TYPE_OR_NONE, S_GRACEFUL_FINISH_REQUIRED_V &gt;::async_connect()</a>, <a class="el" href="util_8hpp_source.html#l00034">op_with_possible_bipc_exception()</a>, <a class="el" href="pool__arena_8cpp_source.html#l00030">ipc::shm::classic::Pool_arena::Pool_arena()</a>, and <a class="el" href="session__server__impl_8hpp_source.html#l00438">ipc::session::Session_server_impl&lt; Session_server_t, Server_session_t &gt;::Session_server_impl()</a>.</p>
<div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="namespaceipc_1_1util_abd43da87aa17031604c7906757c07d46_cgraph.svg" width="170" height="71"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe>
</div>
</div>
<div class="dynheader">
Here is the caller graph for this function:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="namespaceipc_1_1util_abd43da87aa17031604c7906757c07d46_icgraph.svg" width="368" height="192"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe>
</div>
</div>

</div>
</div>
<a id="aaf94b5903f4e0aa2f2699867dd8971ef" name="aaf94b5903f4e0aa2f2699867dd8971ef"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaf94b5903f4e0aa2f2699867dd8971ef">&#9670;&nbsp;</a></span>operator!=() <span class="overload">[1/5]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool operator!= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classipc_1_1util_1_1Process__credentials.html">Process_credentials</a> &amp;&#160;</td>
          <td class="paramname"><em>val1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classipc_1_1util_1_1Process__credentials.html">Process_credentials</a> &amp;&#160;</td>
          <td class="paramname"><em>val2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Checks for by-value inequality between two <a class="el" href="classipc_1_1util_1_1Process__credentials.html" title="A process&#39;s credentials (PID, UID, GID as of this writing).">Process_credentials</a> objects. </p>
<p >process_invoked_as() does not participate in this and is not invoked.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">val1</td><td>Value to compare. </td></tr>
    <tr><td class="paramname">val2</td><td>Value to compare. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Whether at least one accessor compares unequal. </dd></dl>

<p class="definition">Definition at line <a class="el" href="process__credentials_8cpp_source.html#l00152">152</a> of file <a class="el" href="process__credentials_8cpp_source.html">process_credentials.cpp</a>.</p>

</div>
</div>
<a id="aec185fc5e2e88206d1366de8ce42f732" name="aec185fc5e2e88206d1366de8ce42f732"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aec185fc5e2e88206d1366de8ce42f732">&#9670;&nbsp;</a></span>operator!=() <span class="overload">[2/5]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool ipc::util::operator!= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classipc_1_1util_1_1Shared__name.html">Shared_name</a> &amp;&#160;</td>
          <td class="paramname"><em>val1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classipc_1_1util_1_1Shared__name.html">Shared_name</a> &amp;&#160;</td>
          <td class="paramname"><em>val2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Negation of similar <code>==</code>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">val1</td><td>See <code>==</code>. </td></tr>
    <tr><td class="paramname">val2</td><td>See <code>==</code>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>See above. </dd></dl>

<p class="definition">Definition at line <a class="el" href="shared__name_8cpp_source.html#l00378">378</a> of file <a class="el" href="shared__name_8cpp_source.html">shared_name.cpp</a>.</p>

<p class="reference">References <a class="el" href="native__handle_8cpp_source.html#l00079">operator==()</a>.</p>
<div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="namespaceipc_1_1util_aec185fc5e2e88206d1366de8ce42f732_cgraph.svg" width="326" height="35"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe>
</div>
</div>

</div>
</div>
<a id="a0d9b586ec40d9dc3bc14915ef6d24cb7" name="a0d9b586ec40d9dc3bc14915ef6d24cb7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0d9b586ec40d9dc3bc14915ef6d24cb7">&#9670;&nbsp;</a></span>operator!=() <span class="overload">[3/5]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool ipc::util::operator!= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classipc_1_1util_1_1Shared__name.html">Shared_name</a> &amp;&#160;</td>
          <td class="paramname"><em>val1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceipc_1_1util.html#ae6ac47812a90d1287c61e0b7de7bc4f5">util::String_view</a>&#160;</td>
          <td class="paramname"><em>val2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Negation of similar <code>==</code>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">val1</td><td>See <code>==</code>. </td></tr>
    <tr><td class="paramname">val2</td><td>See <code>==</code>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>See above. </dd></dl>

<p class="definition">Definition at line <a class="el" href="shared__name_8cpp_source.html#l00392">392</a> of file <a class="el" href="shared__name_8cpp_source.html">shared_name.cpp</a>.</p>

<p class="reference">References <a class="el" href="native__handle_8cpp_source.html#l00079">operator==()</a>.</p>
<div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="namespaceipc_1_1util_a0d9b586ec40d9dc3bc14915ef6d24cb7_cgraph.svg" width="326" height="35"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe>
</div>
</div>

</div>
</div>
<a id="aacbd7ee43d4912a8790a228dc7cf682d" name="aacbd7ee43d4912a8790a228dc7cf682d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aacbd7ee43d4912a8790a228dc7cf682d">&#9670;&nbsp;</a></span>operator!=() <span class="overload">[4/5]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool operator!= </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structipc_1_1util_1_1Native__handle.html">Native_handle</a>&#160;</td>
          <td class="paramname"><em>val1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structipc_1_1util_1_1Native__handle.html">Native_handle</a>&#160;</td>
          <td class="paramname"><em>val2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Negation of similar <code>==</code>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">val1</td><td>Object. </td></tr>
    <tr><td class="paramname">val2</td><td>Object. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>See above. </dd></dl>

<p class="definition">Definition at line <a class="el" href="native__handle_8cpp_source.html#l00084">84</a> of file <a class="el" href="native__handle_8cpp_source.html">native_handle.cpp</a>.</p>

</div>
</div>
<a id="a988ac1702279bd2b958464cd8ee7e81f" name="a988ac1702279bd2b958464cd8ee7e81f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a988ac1702279bd2b958464cd8ee7e81f">&#9670;&nbsp;</a></span>operator!=() <span class="overload">[5/5]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool ipc::util::operator!= </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespaceipc_1_1util.html#ae6ac47812a90d1287c61e0b7de7bc4f5">util::String_view</a>&#160;</td>
          <td class="paramname"><em>val1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classipc_1_1util_1_1Shared__name.html">Shared_name</a> &amp;&#160;</td>
          <td class="paramname"><em>val2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Negation of similar <code>==</code>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">val1</td><td>See <code>==</code>. </td></tr>
    <tr><td class="paramname">val2</td><td>See <code>==</code>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>See above. </dd></dl>

<p class="definition">Definition at line <a class="el" href="shared__name_8cpp_source.html#l00402">402</a> of file <a class="el" href="shared__name_8cpp_source.html">shared_name.cpp</a>.</p>

<p class="reference">References <a class="el" href="native__handle_8cpp_source.html#l00079">operator==()</a>.</p>
<div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="namespaceipc_1_1util_a988ac1702279bd2b958464cd8ee7e81f_cgraph.svg" width="326" height="35"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe>
</div>
</div>

</div>
</div>
<a id="a096c71dede7bd5528215ac01a380a189" name="a096c71dede7bd5528215ac01a380a189"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a096c71dede7bd5528215ac01a380a189">&#9670;&nbsp;</a></span>operator+() <span class="overload">[1/5]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classipc_1_1util_1_1Shared__name.html">Shared_name</a> operator+ </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>raw_src1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classipc_1_1util_1_1Shared__name.html">Shared_name</a> &amp;&#160;</td>
          <td class="paramname"><em>src2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns new object equal to <code>Shared_name(src2)</code> with <code>raw_src1</code> pre-pended to it. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">raw_src1</td><td>String to precede the appended <code>src2</code>. </td></tr>
    <tr><td class="paramname">src2</td><td>Object to append. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>See above. </dd></dl>

<p class="definition">Definition at line <a class="el" href="shared__name_8cpp_source.html#l00105">105</a> of file <a class="el" href="shared__name_8cpp_source.html">shared_name.cpp</a>.</p>

</div>
</div>
<a id="af61b02fd66b67aeed5a803ca47e52973" name="af61b02fd66b67aeed5a803ca47e52973"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af61b02fd66b67aeed5a803ca47e52973">&#9670;&nbsp;</a></span>operator+() <span class="overload">[2/5]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classipc_1_1util_1_1Shared__name.html">Shared_name</a> operator+ </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classipc_1_1util_1_1Shared__name.html">Shared_name</a> &amp;&#160;</td>
          <td class="paramname"><em>src1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>raw_src2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns new object equal to <code>Shared_name(src1) += raw_src2</code>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">src1</td><td>Object to precede the appended <code>raw_src2</code>. </td></tr>
    <tr><td class="paramname">raw_src2</td><td>String to append. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>See above. </dd></dl>

<p class="definition">Definition at line <a class="el" href="shared__name_8cpp_source.html#l00097">97</a> of file <a class="el" href="shared__name_8cpp_source.html">shared_name.cpp</a>.</p>

<p class="reference">Referenced by <a class="el" href="shared__name_8cpp_source.html#l00097">ipc::util::Shared_name::operator+()</a>.</p>
<div class="dynheader">
Here is the caller graph for this function:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="namespaceipc_1_1util_af61b02fd66b67aeed5a803ca47e52973_icgraph.svg" width="332" height="47"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe>
</div>
</div>

</div>
</div>
<a id="a54dc5077333284fda9e8d2df8b0e9b91" name="a54dc5077333284fda9e8d2df8b0e9b91"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a54dc5077333284fda9e8d2df8b0e9b91">&#9670;&nbsp;</a></span>operator+() <span class="overload">[3/5]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classipc_1_1util_1_1Shared__name.html">Shared_name</a> operator+ </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classipc_1_1util_1_1Shared__name.html">Shared_name</a> &amp;&#160;</td>
          <td class="paramname"><em>src1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classipc_1_1util_1_1Shared__name.html">Shared_name</a> &amp;&#160;</td>
          <td class="paramname"><em>src2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns new object equal to <code>Shared_name(src1) += src2</code>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">src1</td><td>Object to precede the appended <code>src2</code>. </td></tr>
    <tr><td class="paramname">src2</td><td>Object to append. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>See above. </dd></dl>

<p class="definition">Definition at line <a class="el" href="shared__name_8cpp_source.html#l00113">113</a> of file <a class="el" href="shared__name_8cpp_source.html">shared_name.cpp</a>.</p>

</div>
</div>
<a id="a52b2ba03d5ace7389991bb5d31b9fa59" name="a52b2ba03d5ace7389991bb5d31b9fa59"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a52b2ba03d5ace7389991bb5d31b9fa59">&#9670;&nbsp;</a></span>operator+() <span class="overload">[4/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Source &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classipc_1_1util_1_1Shared__name.html">Shared_name</a> operator+ </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classipc_1_1util_1_1Shared__name.html">Shared_name</a> &amp;&#160;</td>
          <td class="paramname"><em>src1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Source &amp;&#160;</td>
          <td class="paramname"><em>raw_src2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns new object equal to <code>Shared_name(src1) += raw_src2</code>. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Source</td><td>See <a class="el" href="classipc_1_1util_1_1Shared__name.html#a1bcac1c10e01ba11dcc437b3c32bbe6c" title="Appends the given other Shared_name.">Shared_name::operator+=()</a> similar overload. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">src1</td><td>Object to precede the appended <code>raw_src2</code>. </td></tr>
    <tr><td class="paramname">raw_src2</td><td>String to append. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>See above. </dd></dl>

<p class="definition">Definition at line <a class="el" href="shared__name_8hpp_source.html#l00708">708</a> of file <a class="el" href="shared__name_8hpp_source.html">shared_name.hpp</a>.</p>

</div>
</div>
<a id="a1f1a40877cc08b287f8f3c7e7f663782" name="a1f1a40877cc08b287f8f3c7e7f663782"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1f1a40877cc08b287f8f3c7e7f663782">&#9670;&nbsp;</a></span>operator+() <span class="overload">[5/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Source &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classipc_1_1util_1_1Shared__name.html">Shared_name</a> operator+ </td>
          <td>(</td>
          <td class="paramtype">const Source &amp;&#160;</td>
          <td class="paramname"><em>raw_src1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classipc_1_1util_1_1Shared__name.html">Shared_name</a> &amp;&#160;</td>
          <td class="paramname"><em>src2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns new object equal to <code>Shared_name(src2)</code> with <code>raw_src1</code> pre-pended to it. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Source</td><td>See <a class="el" href="classipc_1_1util_1_1Shared__name.html#a1bcac1c10e01ba11dcc437b3c32bbe6c" title="Appends the given other Shared_name.">Shared_name::operator+=()</a> similar overload. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">raw_src1</td><td>String to precede the appended <code>src2</code>. </td></tr>
    <tr><td class="paramname">src2</td><td>Object to append. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>See above. </dd></dl>

<p class="definition">Definition at line <a class="el" href="shared__name_8hpp_source.html#l00716">716</a> of file <a class="el" href="shared__name_8hpp_source.html">shared_name.hpp</a>.</p>

</div>
</div>
<a id="a7f2bead5935309c2f760645fe46ddd71" name="a7f2bead5935309c2f760645fe46ddd71"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7f2bead5935309c2f760645fe46ddd71">&#9670;&nbsp;</a></span>operator/() <span class="overload">[1/5]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classipc_1_1util_1_1Shared__name.html">Shared_name</a> operator/ </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>raw_src1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classipc_1_1util_1_1Shared__name.html">Shared_name</a> &amp;&#160;</td>
          <td class="paramname"><em>src2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns new object equal to <code>Shared_name(raw_src1) /= src2</code>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">raw_src1</td><td>String to precede the appended separator and <code>src2</code>. </td></tr>
    <tr><td class="paramname">src2</td><td>Object to append after separator. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>See above. </dd></dl>

<p class="definition">Definition at line <a class="el" href="shared__name_8cpp_source.html#l00127">127</a> of file <a class="el" href="shared__name_8cpp_source.html">shared_name.cpp</a>.</p>

</div>
</div>
<a id="aa61c6b31c5c4e241c97f06a4d38c76c4" name="aa61c6b31c5c4e241c97f06a4d38c76c4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa61c6b31c5c4e241c97f06a4d38c76c4">&#9670;&nbsp;</a></span>operator/() <span class="overload">[2/5]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classipc_1_1util_1_1Shared__name.html">Shared_name</a> operator/ </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classipc_1_1util_1_1Shared__name.html">Shared_name</a> &amp;&#160;</td>
          <td class="paramname"><em>src1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>raw_src2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns new object equal to <code>Shared_name(src1) /= raw_src2</code>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">src1</td><td>Object to precede the appended separator and <code>raw_src2</code>. </td></tr>
    <tr><td class="paramname">raw_src2</td><td>String to append after separator. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>See above. </dd></dl>

<p class="definition">Definition at line <a class="el" href="shared__name_8cpp_source.html#l00119">119</a> of file <a class="el" href="shared__name_8cpp_source.html">shared_name.cpp</a>.</p>

<p class="reference">Referenced by <a class="el" href="shared__name_8cpp_source.html#l00119">ipc::util::Shared_name::operator/()</a>.</p>
<div class="dynheader">
Here is the caller graph for this function:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="namespaceipc_1_1util_aa61c6b31c5c4e241c97f06a4d38c76c4_icgraph.svg" width="328" height="47"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe>
</div>
</div>

</div>
</div>
<a id="a15ea67c1855a678f7e948b24ccf2c1cd" name="a15ea67c1855a678f7e948b24ccf2c1cd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a15ea67c1855a678f7e948b24ccf2c1cd">&#9670;&nbsp;</a></span>operator/() <span class="overload">[3/5]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classipc_1_1util_1_1Shared__name.html">Shared_name</a> operator/ </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classipc_1_1util_1_1Shared__name.html">Shared_name</a> &amp;&#160;</td>
          <td class="paramname"><em>src1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classipc_1_1util_1_1Shared__name.html">Shared_name</a> &amp;&#160;</td>
          <td class="paramname"><em>src2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns new object equal to <code>Shared_name(src1) /= src2</code>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">src1</td><td>Object to precede the appended separator and <code>src2</code>. </td></tr>
    <tr><td class="paramname">src2</td><td>Object to append after separator. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>See above. </dd></dl>

<p class="definition">Definition at line <a class="el" href="shared__name_8cpp_source.html#l00135">135</a> of file <a class="el" href="shared__name_8cpp_source.html">shared_name.cpp</a>.</p>

</div>
</div>
<a id="a910207a2da57b61cee4a22899e239dc2" name="a910207a2da57b61cee4a22899e239dc2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a910207a2da57b61cee4a22899e239dc2">&#9670;&nbsp;</a></span>operator/() <span class="overload">[4/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Source &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classipc_1_1util_1_1Shared__name.html">Shared_name</a> operator/ </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classipc_1_1util_1_1Shared__name.html">Shared_name</a> &amp;&#160;</td>
          <td class="paramname"><em>src1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Source &amp;&#160;</td>
          <td class="paramname"><em>raw_src2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns new object equal to <code>Shared_name(src1) /= raw_src2</code>. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Source</td><td>See <a class="el" href="classipc_1_1util_1_1Shared__name.html#a956fdac1bb4cfab414b30091bec43f70" title="Appends a folder separator followed by the given other Shared_name.">Shared_name::operator/=()</a> similar overload. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">src1</td><td>Object to precede the appended separator and <code>raw_src2</code>. </td></tr>
    <tr><td class="paramname">raw_src2</td><td>String to append after separator. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>See above. </dd></dl>

<p class="definition">Definition at line <a class="el" href="shared__name_8hpp_source.html#l00724">724</a> of file <a class="el" href="shared__name_8hpp_source.html">shared_name.hpp</a>.</p>

</div>
</div>
<a id="a462b81d34ba23c968f63d9805fa74538" name="a462b81d34ba23c968f63d9805fa74538"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a462b81d34ba23c968f63d9805fa74538">&#9670;&nbsp;</a></span>operator/() <span class="overload">[5/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Source &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classipc_1_1util_1_1Shared__name.html">Shared_name</a> operator/ </td>
          <td>(</td>
          <td class="paramtype">const Source &amp;&#160;</td>
          <td class="paramname"><em>raw_src1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classipc_1_1util_1_1Shared__name.html">Shared_name</a> &amp;&#160;</td>
          <td class="paramname"><em>src2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns new object equal to <code>Shared_name(raw_src1) /= src2</code>. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Source</td><td>See <a class="el" href="classipc_1_1util_1_1Shared__name.html#a956fdac1bb4cfab414b30091bec43f70" title="Appends a folder separator followed by the given other Shared_name.">Shared_name::operator/=()</a> similar overload. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">raw_src1</td><td>String to precede the appended separator and <code>src2</code>. </td></tr>
    <tr><td class="paramname">src2</td><td>Object to append after separator. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>See above. </dd></dl>

<p class="definition">Definition at line <a class="el" href="shared__name_8hpp_source.html#l00732">732</a> of file <a class="el" href="shared__name_8hpp_source.html">shared_name.hpp</a>.</p>

</div>
</div>
<a id="aea456ff91117633e731804a894aa94da" name="aea456ff91117633e731804a894aa94da"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aea456ff91117633e731804a894aa94da">&#9670;&nbsp;</a></span>operator&lt;() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool ipc::util::operator&lt; </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classipc_1_1util_1_1Shared__name.html">Shared_name</a> &amp;&#160;</td>
          <td class="paramname"><em>val1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classipc_1_1util_1_1Shared__name.html">Shared_name</a> &amp;&#160;</td>
          <td class="paramname"><em>val2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns <code>true</code> if and only if <code>val1.str() &lt; val2.str()</code>. </p>
<p >Enables use of <a class="el" href="classipc_1_1util_1_1Shared__name.html" title="String-wrapping abstraction representing a name uniquely distinguishing a kernel-persistent entity fr...">Shared_name</a> in an <code>std::map</code> without jumping through any special hoops.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">val1</td><td>Object to compare. </td></tr>
    <tr><td class="paramname">val2</td><td>Object to compare. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>See above. </dd></dl>

<p class="definition">Definition at line <a class="el" href="shared__name_8cpp_source.html#l00407">407</a> of file <a class="el" href="shared__name_8cpp_source.html">shared_name.cpp</a>.</p>

<p class="reference">References <a class="el" href="shared__name_8cpp_source.html#l00140">ipc::util::Shared_name::str()</a>.</p>
<div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="namespaceipc_1_1util_aea456ff91117633e731804a894aa94da_cgraph.svg" width="354" height="35"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe>
</div>
</div>

</div>
</div>
<a id="a6ff4b35d8fbbe2eb6266f3a7b0f07c49" name="a6ff4b35d8fbbe2eb6266f3a7b0f07c49"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6ff4b35d8fbbe2eb6266f3a7b0f07c49">&#9670;&nbsp;</a></span>operator&lt;() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool operator&lt; </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structipc_1_1util_1_1Native__handle.html">Native_handle</a>&#160;</td>
          <td class="paramname"><em>val1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structipc_1_1util_1_1Native__handle.html">Native_handle</a>&#160;</td>
          <td class="paramname"><em>val2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns a less-than comparison of two <a class="el" href="structipc_1_1util_1_1Native__handle.html" title="A monolayer-thin wrapper around a native handle, a/k/a descriptor a/k/a FD.">Native_handle</a> objects, with the usual total ordering guarantees. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">val1</td><td>Left-hand side object. </td></tr>
    <tr><td class="paramname">val2</td><td>Right-hand side object. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Whether left side is considered strictly less-than right side. </dd></dl>

<p class="definition">Definition at line <a class="el" href="native__handle_8cpp_source.html#l00096">96</a> of file <a class="el" href="native__handle_8cpp_source.html">native_handle.cpp</a>.</p>

</div>
</div>
<a id="a28030c32e9c66f5c2862cbc6998885c7" name="a28030c32e9c66f5c2862cbc6998885c7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a28030c32e9c66f5c2862cbc6998885c7">&#9670;&nbsp;</a></span>operator&lt;&lt;() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::ostream &amp; operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>os</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structipc_1_1util_1_1Native__handle.html">Native_handle</a> &amp;&#160;</td>
          <td class="paramname"><em>val</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Prints string representation of the given <a class="el" href="structipc_1_1util_1_1Native__handle.html" title="A monolayer-thin wrapper around a native handle, a/k/a descriptor a/k/a FD.">Native_handle</a> to the given <code>ostream</code>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">os</td><td>Stream to which to write. </td></tr>
    <tr><td class="paramname">val</td><td>Object to serialize. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>os</code>. </dd></dl>

<p class="definition">Definition at line <a class="el" href="native__handle_8cpp_source.html#l00065">65</a> of file <a class="el" href="native__handle_8cpp_source.html">native_handle.cpp</a>.</p>

</div>
</div>
<a id="a9da92514406dc1fc61f5a561c9b5aee9" name="a9da92514406dc1fc61f5a561c9b5aee9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9da92514406dc1fc61f5a561c9b5aee9">&#9670;&nbsp;</a></span>operator&lt;&lt;() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::ostream &amp; operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>os</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classipc_1_1util_1_1Process__credentials.html">Process_credentials</a> &amp;&#160;</td>
          <td class="paramname"><em>val</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Prints string representation of the given <a class="el" href="classipc_1_1util_1_1Process__credentials.html" title="A process&#39;s credentials (PID, UID, GID as of this writing).">util::Process_credentials</a> to the given <code>ostream</code>. </p>
<p >process_invoked_as() does not participate in this and is not invoked; you may query that information if desired manually; just remember <code>val.process_id()</code> must be live at the time for it to work.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">os</td><td>Stream to which to write. </td></tr>
    <tr><td class="paramname">val</td><td>Object to serialize. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>os</code>. </dd></dl>

<p class="definition">Definition at line <a class="el" href="process__credentials_8cpp_source.html#l00157">157</a> of file <a class="el" href="process__credentials_8cpp_source.html">process_credentials.cpp</a>.</p>

</div>
</div>
<a id="af7728c93fdf29479bbb2482e02f05cbf" name="af7728c93fdf29479bbb2482e02f05cbf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af7728c93fdf29479bbb2482e02f05cbf">&#9670;&nbsp;</a></span>operator&lt;&lt;() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::ostream &amp; operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>os</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classipc_1_1util_1_1Shared__name.html">Shared_name</a> &amp;&#160;</td>
          <td class="paramname"><em>val</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Prints embellished string representation of the given <a class="el" href="classipc_1_1util_1_1Shared__name.html" title="String-wrapping abstraction representing a name uniquely distinguishing a kernel-persistent entity fr...">Shared_name</a> to the given <code>ostream</code>. </p>
<dl class="section warning"><dt>Warning</dt><dd>This is <em>not</em> equivalent to writing <a class="el" href="classipc_1_1util_1_1Shared__name.html#ae89e1e061f87ffe0288514e254837595" title="Returns (sans copying) ref to immutable entire wrapped name string, suitable to pass into sys calls w...">Shared_name::str()</a>; as of this writing it includes not just <code>str()</code> but also the number of characters in it as a decimal and a separator, for convenience in test/debug, to visually detect names approaching certain length limits. If you wish to output <code>val.str()</code>, then output... well... <code>val.str()</code>.</dd></dl>
<dl class="todo"><dt><b><a class="el" href="todo.html#_todo000021">Todo:</a></b></dt><dd>Does <a class="el" href="classipc_1_1util_1_1Shared__name.html" title="String-wrapping abstraction representing a name uniquely distinguishing a kernel-persistent entity fr...">Shared_name</a> <code>operator&gt;&gt;</code> and <code>operator&lt;&lt;</code> being asymmetrical get one into trouble when using <a class="el" href="classipc_1_1util_1_1Shared__name.html" title="String-wrapping abstraction representing a name uniquely distinguishing a kernel-persistent entity fr...">Shared_name</a> with boost.program_options (or <code>flow::cfg</code> which is built on top of it)? Look into it. It may be necessary to make <code>operator&lt;&lt;</code> equal to that of <code>ostream &lt;&lt; string</code> after all; though the added niceties of the current <code>&lt;&lt;</code> semantics may still at least be available via some explicit accessor.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">os</td><td>Stream to which to write. </td></tr>
    <tr><td class="paramname">val</td><td>Object to serialize. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>os</code>. </dd></dl>

<p class="definition">Definition at line <a class="el" href="shared__name_8cpp_source.html#l00353">353</a> of file <a class="el" href="shared__name_8cpp_source.html">shared_name.cpp</a>.</p>

</div>
</div>
<a id="a4ccdab04a79159f82d7ade8136a2eeb2" name="a4ccdab04a79159f82d7ade8136a2eeb2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4ccdab04a79159f82d7ade8136a2eeb2">&#9670;&nbsp;</a></span>operator==() <span class="overload">[1/5]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool operator== </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classipc_1_1util_1_1Process__credentials.html">Process_credentials</a> &amp;&#160;</td>
          <td class="paramname"><em>val1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classipc_1_1util_1_1Process__credentials.html">Process_credentials</a> &amp;&#160;</td>
          <td class="paramname"><em>val2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Checks for by-value equality between two <a class="el" href="classipc_1_1util_1_1Process__credentials.html" title="A process&#39;s credentials (PID, UID, GID as of this writing).">Process_credentials</a> objects. </p>
<p >process_invoked_as() does not participate in this and is not invoked.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">val1</td><td>Value to compare. </td></tr>
    <tr><td class="paramname">val2</td><td>Value to compare. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Whether the accessors all compare equal. </dd></dl>

<p class="definition">Definition at line <a class="el" href="process__credentials_8cpp_source.html#l00146">146</a> of file <a class="el" href="process__credentials_8cpp_source.html">process_credentials.cpp</a>.</p>

</div>
</div>
<a id="adad98b6935e58bdc92dfcf57bf60345e" name="adad98b6935e58bdc92dfcf57bf60345e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adad98b6935e58bdc92dfcf57bf60345e">&#9670;&nbsp;</a></span>operator==() <span class="overload">[2/5]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool ipc::util::operator== </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classipc_1_1util_1_1Shared__name.html">Shared_name</a> &amp;&#160;</td>
          <td class="paramname"><em>val1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classipc_1_1util_1_1Shared__name.html">Shared_name</a> &amp;&#160;</td>
          <td class="paramname"><em>val2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns <code>true</code> if and only if <code>val1.str() == val2.str()</code>. </p>
<p >Caution: this does not execute normalize() or anything like that.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">val1</td><td>Object to compare. </td></tr>
    <tr><td class="paramname">val2</td><td>Object to compare. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>See above. </dd></dl>

<p class="definition">Definition at line <a class="el" href="shared__name_8cpp_source.html#l00373">373</a> of file <a class="el" href="shared__name_8cpp_source.html">shared_name.cpp</a>.</p>

<p class="reference">References <a class="el" href="shared__name_8cpp_source.html#l00140">ipc::util::Shared_name::str()</a>.</p>
<div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="namespaceipc_1_1util_adad98b6935e58bdc92dfcf57bf60345e_cgraph.svg" width="363" height="35"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe>
</div>
</div>

</div>
</div>
<a id="a5023285f7dd8a117686f0ee986e685cb" name="a5023285f7dd8a117686f0ee986e685cb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5023285f7dd8a117686f0ee986e685cb">&#9670;&nbsp;</a></span>operator==() <span class="overload">[3/5]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool ipc::util::operator== </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classipc_1_1util_1_1Shared__name.html">Shared_name</a> &amp;&#160;</td>
          <td class="paramname"><em>val1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceipc_1_1util.html#ae6ac47812a90d1287c61e0b7de7bc4f5">util::String_view</a>&#160;</td>
          <td class="paramname"><em>val2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns <code>true</code> if and only if <code>val1.str() == string(val2)</code>. </p>
<p >Caution: this does not execute normalize() or anything like that.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">val1</td><td>Object to compare. </td></tr>
    <tr><td class="paramname">val2</td><td>String to compare. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>See above. </dd></dl>

<p class="definition">Definition at line <a class="el" href="shared__name_8cpp_source.html#l00383">383</a> of file <a class="el" href="shared__name_8cpp_source.html">shared_name.cpp</a>.</p>

<p class="reference">References <a class="el" href="shared__name_8cpp_source.html#l00397">operator==()</a>, and <a class="el" href="shared__name_8cpp_source.html#l00140">ipc::util::Shared_name::str()</a>.</p>
<div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="namespaceipc_1_1util_a5023285f7dd8a117686f0ee986e685cb_cgraph.svg" width="547" height="83"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe>
</div>
</div>

</div>
</div>
<a id="ae4b4126f841ef060cdae15998e48691c" name="ae4b4126f841ef060cdae15998e48691c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae4b4126f841ef060cdae15998e48691c">&#9670;&nbsp;</a></span>operator==() <span class="overload">[4/5]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool operator== </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structipc_1_1util_1_1Native__handle.html">Native_handle</a>&#160;</td>
          <td class="paramname"><em>val1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structipc_1_1util_1_1Native__handle.html">Native_handle</a>&#160;</td>
          <td class="paramname"><em>val2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns <code>true</code> if and only if the two <a class="el" href="structipc_1_1util_1_1Native__handle.html" title="A monolayer-thin wrapper around a native handle, a/k/a descriptor a/k/a FD.">Native_handle</a> objects are the same underlying handle. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">val1</td><td>Object. </td></tr>
    <tr><td class="paramname">val2</td><td>Object. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>See above. </dd></dl>

<p class="definition">Definition at line <a class="el" href="native__handle_8cpp_source.html#l00079">79</a> of file <a class="el" href="native__handle_8cpp_source.html">native_handle.cpp</a>.</p>

<p class="reference">Referenced by <a class="el" href="process__credentials_8cpp_source.html#l00152">ipc::util::Process_credentials::operator!=()</a>, <a class="el" href="shared__name_8cpp_source.html#l00378">operator!=()</a>, <a class="el" href="native__handle_8cpp_source.html#l00084">ipc::util::Native_handle::operator!=()</a>, and <a class="el" href="shared__name_8cpp_source.html#l00397">operator==()</a>.</p>
<div class="dynheader">
Here is the caller graph for this function:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="namespaceipc_1_1util_ae4b4126f841ef060cdae15998e48691c_icgraph.svg" width="535" height="206"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe>
</div>
</div>

</div>
</div>
<a id="a97a7c8e6330909a1371134a7bdcea788" name="a97a7c8e6330909a1371134a7bdcea788"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a97a7c8e6330909a1371134a7bdcea788">&#9670;&nbsp;</a></span>operator==() <span class="overload">[5/5]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool ipc::util::operator== </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespaceipc_1_1util.html#ae6ac47812a90d1287c61e0b7de7bc4f5">util::String_view</a>&#160;</td>
          <td class="paramname"><em>val1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classipc_1_1util_1_1Shared__name.html">Shared_name</a> &amp;&#160;</td>
          <td class="paramname"><em>val2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns <code>true</code> if and only if <code>string(val1) == val2.str()</code>. </p>
<p >Caution: this does not execute normalize() or anything like that.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">val1</td><td>String to compare. </td></tr>
    <tr><td class="paramname">val2</td><td>Object to compare. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>See above. </dd></dl>

<p class="definition">Definition at line <a class="el" href="shared__name_8cpp_source.html#l00397">397</a> of file <a class="el" href="shared__name_8cpp_source.html">shared_name.cpp</a>.</p>

<p class="reference">References <a class="el" href="native__handle_8cpp_source.html#l00079">operator==()</a>.</p>

<p class="reference">Referenced by <a class="el" href="shared__name_8cpp_source.html#l00383">operator==()</a>.</p>
<div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="namespaceipc_1_1util_a97a7c8e6330909a1371134a7bdcea788_cgraph.svg" width="331" height="35"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe>
</div>
</div>
<div class="dynheader">
Here is the caller graph for this function:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="namespaceipc_1_1util_a97a7c8e6330909a1371134a7bdcea788_icgraph.svg" width="331" height="35"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe>
</div>
</div>

</div>
</div>
<a id="adfd8805e0d37556102cad7b191fee9a3" name="adfd8805e0d37556102cad7b191fee9a3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adfd8805e0d37556102cad7b191fee9a3">&#9670;&nbsp;</a></span>operator&gt;&gt;()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::istream &amp; operator&gt;&gt; </td>
          <td>(</td>
          <td class="paramtype">std::istream &amp;&#160;</td>
          <td class="paramname"><em>is</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classipc_1_1util_1_1Shared__name.html">Shared_name</a> &amp;&#160;</td>
          <td class="paramname"><em>val</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Reads <a class="el" href="classipc_1_1util_1_1Shared__name.html" title="String-wrapping abstraction representing a name uniquely distinguishing a kernel-persistent entity fr...">Shared_name</a> from the given <code>istream</code>; equivalent to reading <code>string</code> into <a class="el" href="classipc_1_1util_1_1Shared__name.html#ae89e1e061f87ffe0288514e254837595" title="Returns (sans copying) ref to immutable entire wrapped name string, suitable to pass into sys calls w...">Shared_name::str()</a>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">is</td><td>Stream to read. </td></tr>
    <tr><td class="paramname">val</td><td>Object to which to deserialize. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>is</code>. </dd></dl>

<p class="definition">Definition at line <a class="el" href="shared__name_8cpp_source.html#l00364">364</a> of file <a class="el" href="shared__name_8cpp_source.html">shared_name.cpp</a>.</p>

</div>
</div>
<a id="a814272e555c0592b0caf92b7bc3d64b3" name="a814272e555c0592b0caf92b7bc3d64b3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a814272e555c0592b0caf92b7bc3d64b3">&#9670;&nbsp;</a></span>pipe_consume()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ipc::util::pipe_consume </td>
          <td>(</td>
          <td class="paramtype">flow::log::Logger *&#160;</td>
          <td class="paramname"><em>logger_ptr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceipc_1_1util.html#aaf368acf8243bb25de3eef4e836c15de">Pipe_reader</a> *&#160;</td>
          <td class="paramname"><em>pipe</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Reads a byte via the given pipe reader. </p>
<p >If any error occurs =&gt; undefined behavior (assert may trip). If it would-block... it will block. So: only use if your algorithm has made sure you have a byte in there.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">logger_ptr</td><td>Logger to use for logging subsequently. </td></tr>
    <tr><td class="paramname">pipe</td><td>The pipe. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="ipc__core_2src_2ipc_2util_2detail_2util_8cpp_source.html#l00096">96</a> of file <a class="el" href="ipc__core_2src_2ipc_2util_2detail_2util_8cpp_source.html">util.cpp</a>.</p>

<p class="reference">Referenced by <a class="el" href="session__server__adapter_8hpp_source.html#l00419">ipc::session::sync_io::Session_server_adapter&lt; Session_server &gt;::accept_read()</a>, <a class="el" href="posix__mq__handle_8cpp_source.html#l01120">ipc::transport::Posix_mq_handle::allow_impl()</a>, <a class="el" href="sync__io_2native__socket__stream__acceptor_8hpp_source.html#l00247">ipc::transport::sync_io::Native_socket_stream_acceptor::async_accept()</a>, <a class="el" href="sync__io_2detail_2blob__stream__mq__snd__impl_8hpp_source.html#l01507">ipc::transport::sync_io::Blob_stream_mq_sender_impl&lt; Persistent_mq_handle &gt;::async_write_q_head_payload()</a>, <a class="el" href="timer__ev__emitter_8cpp_source.html#l00123">ipc::util::sync_io::Timer_event_emitter::consume_timer_firing_signal()</a>, <a class="el" href="session__adapter_8hpp_source.html#l00588">ipc::session::sync_io::Session_adapter&lt; Session &gt;::on_ev_channel_open()</a>, <a class="el" href="sync__io_2detail_2blob__stream__mq__rcv__impl_8hpp_source.html#l00905">ipc::transport::sync_io::Blob_stream_mq_receiver_impl&lt; Persistent_mq_handle &gt;::read_msg()</a>, and <a class="el" href="session__adapter_8hpp_source.html#l00542">ipc::session::sync_io::Session_adapter&lt; Session &gt;::start_ops()</a>.</p>
<div class="dynheader">
Here is the caller graph for this function:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="namespaceipc_1_1util_a814272e555c0592b0caf92b7bc3d64b3_icgraph.svg" width="392" height="578"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe>
</div>
</div>

</div>
</div>
<a id="a5429c6225cc9a271ad8c0041d99c236b" name="a5429c6225cc9a271ad8c0041d99c236b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5429c6225cc9a271ad8c0041d99c236b">&#9670;&nbsp;</a></span>pipe_produce()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ipc::util::pipe_produce </td>
          <td>(</td>
          <td class="paramtype">flow::log::Logger *&#160;</td>
          <td class="paramname"><em>logger_ptr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceipc_1_1util.html#a844d5ca9c17b672644fc8d9dbe758db0">Pipe_writer</a> *&#160;</td>
          <td class="paramname"><em>pipe</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Writes a byte to the given pipe writer. </p>
<p >If any error occurs =&gt; undefined behavior (assert may trip). If it would-block... it will block. So: only use if your algorithm has made sure you will never reach the pipe's capacity.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">logger_ptr</td><td>Logger to use for logging subsequently. </td></tr>
    <tr><td class="paramname">pipe</td><td>The pipe. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="ipc__core_2src_2ipc_2util_2detail_2util_8cpp_source.html#l00067">67</a> of file <a class="el" href="ipc__core_2src_2ipc_2util_2detail_2util_8cpp_source.html">util.cpp</a>.</p>

<p class="reference">Referenced by <a class="el" href="session__server__adapter_8hpp_source.html#l00402">ipc::session::sync_io::Session_server_adapter&lt; Session_server &gt;::accept_write()</a>, <a class="el" href="sync__io_2native__socket__stream__acceptor_8hpp_source.html#l00247">ipc::transport::sync_io::Native_socket_stream_acceptor::async_accept()</a>, <a class="el" href="sync__io_2detail_2blob__stream__mq__snd__impl_8hpp_source.html#l01507">ipc::transport::sync_io::Blob_stream_mq_sender_impl&lt; Persistent_mq_handle &gt;::async_write_q_head_payload()</a>, <a class="el" href="posix__mq__handle_8cpp_source.html#l01081">ipc::transport::Posix_mq_handle::interrupt_impl()</a>, <a class="el" href="session__adapter_8hpp_source.html#l00676">ipc::session::sync_io::Session_adapter&lt; Session &gt;::on_channel_func_sio()</a>, <a class="el" href="session__adapter_8hpp_source.html#l00653">ipc::session::sync_io::Session_adapter&lt; Session &gt;::on_err_func_sio()</a>, <a class="el" href="sync__io_2detail_2blob__stream__mq__rcv__impl_8hpp_source.html#l00905">ipc::transport::sync_io::Blob_stream_mq_receiver_impl&lt; Persistent_mq_handle &gt;::read_msg()</a>, and <a class="el" href="timer__ev__emitter_8cpp_source.html#l00081">ipc::util::sync_io::Timer_event_emitter::timer_async_wait()</a>.</p>
<div class="dynheader">
Here is the caller graph for this function:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="namespaceipc_1_1util_a5429c6225cc9a271ad8c0041d99c236b_icgraph.svg" width="387" height="564"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe>
</div>
</div>

</div>
</div>
<a id="a924cd56daf7eeaa0b07edb352367f9ec" name="a924cd56daf7eeaa0b07edb352367f9ec"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a924cd56daf7eeaa0b07edb352367f9ec">&#9670;&nbsp;</a></span>process_running()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool ipc::util::process_running </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespaceipc_1_1util.html#a0c44028a45451ebf21f6af8e806b2682">process_id_t</a>&#160;</td>
          <td class="paramname"><em>process_id</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns <code>true</code> if and only if the given process (by PID) is reported as running by the OS. </p>
<p >Caution: It may be running, but it may be a zombie; and/or it may be running now but dead shortly after this function returns. Use defensively.</p>
<p >Implementation: It invokes POSIX <code>kill()</code> with the fake zero signal; this indicates the process <em>can</em> be signaled and therefore exists.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">process_id</td><td>The process ID of the process in question. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>See above. </dd></dl>

<p class="definition">Definition at line <a class="el" href="ipc__core_2src_2ipc_2util_2util_8cpp_source.html#l00134">134</a> of file <a class="el" href="ipc__core_2src_2ipc_2util_2util_8cpp_source.html">util.cpp</a>.</p>

<p class="reference">Referenced by <a class="el" href="ipc__shm__arena__lend_2src_2ipc_2session_2detail_2shm_2arena__lend_2jemalloc_2client__session__impl_8hpp_source.html#l00471">ipc::session::shm::arena_lend::jemalloc::Client_session_impl&lt; S_MQ_TYPE_OR_NONE, S_TRANSMIT_NATIVE_HANDLES, Mdt_payload &gt;::cleanup()</a>, and <a class="el" href="ipc__shm__arena__lend_2src_2ipc_2session_2shm_2arena__lend_2jemalloc_2session__server_8hpp_source.html#l00561">ipc::session::shm::arena_lend::jemalloc::Session_server&lt; S_MQ_TYPE_OR_NONE, S_TRANSMIT_NATIVE_HANDLES, Mdt_payload &gt;::cleanup()</a>.</p>
<div class="dynheader">
Here is the caller graph for this function:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="namespaceipc_1_1util_a924cd56daf7eeaa0b07edb352367f9ec_icgraph.svg" width="523" height="144"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe>
</div>
</div>

</div>
</div>
<a id="a150051ee7e308ba7c9269b2d1e2c6c37" name="a150051ee7e308ba7c9269b2d1e2c6c37"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a150051ee7e308ba7c9269b2d1e2c6c37">&#9670;&nbsp;</a></span>remove_each_persistent_if()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Persistent_object , typename Filter_func &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">unsigned int ipc::util::remove_each_persistent_if </td>
          <td>(</td>
          <td class="paramtype">flow::log::Logger *&#160;</td>
          <td class="paramname"><em>logger_ptr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Filter_func &amp;&#160;</td>
          <td class="paramname"><em>filter_func</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Utility that invokes <code>Persistent_object::for_each_persistent(name_prefix_or_empty)</code> and synchronously invokes <code>Persistent_object::remove_persistent()</code> on each resulting item that passes the given filter, where <code>Persistent_object</code> is a type that handles objects &ndash; such as SHM pools or POSIX MQs &ndash; with kernel-persistent semantics. </p>
<p >The number of items removed (without any error) is returned. The nature of any error(s) encountered by individual <code>remove_persistent()</code> calls is ignored (not returned in any way) except for logging.</p>
<p >This "forgiving" error emission behavior is sufficient in many cases. If you require finer control over this please use <code>Persistent_object::for_each_persistent()</code> and <code>Persistent_object::remove_persistent()</code> plus your own handling of the failure thereof in your custom <code>handle_name_func()</code>.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Persistent_object</td><td>See above. It must have <code>static</code> methods <code>for_each_persistent()</code> and <code>remove_persistent()</code> with semantics identical to, e.g., <a class="el" href="classipc_1_1shm_1_1classic_1_1Pool__arena.html" title="A SHM-classic interface around a single SHM pool with allocation-algorithm services by boost....">shm::classic::Pool_arena</a> versions of these methods. As of this writing this includes: <a class="el" href="classipc_1_1shm_1_1classic_1_1Pool__arena.html" title="A SHM-classic interface around a single SHM pool with allocation-algorithm services by boost....">shm::classic::Pool_arena</a>, <a class="el" href="classipc_1_1transport_1_1Persistent__mq__handle.html" title="A documentation-only concept defining the behavior of an object representing a light-weight handle to...">transport::Persistent_mq_handle</a> (concept), <a class="el" href="classipc_1_1transport_1_1Posix__mq__handle.html" title="Implements the Persistent_mq_handle concept by wrapping the POSIX message queue API (see man mq_overv...">transport::Posix_mq_handle</a>, <a class="el" href="classipc_1_1transport_1_1Bipc__mq__handle.html" title="Implements the Persistent_mq_handle concept by thinly wrapping bipc::message_queue,...">transport::Bipc_mq_handle</a> (its impls). </td></tr>
    <tr><td class="paramname">Filter_func</td><td>Function object with signature <code>bool F(const Shared_name&amp;)</code>, which should return <code>true</code> to delete, <code>false</code> to skip. For example it might simply check that <code>name</code> starts with a certain prefix (<a class="el" href="namespaceipc_1_1util.html#ad6be904bf1b0fe6659a11dec0fabbf6b" title="Utility that invokes remove_each_persistent_if() with the filter that returns true (yes,...">remove_each_persistent_with_name_prefix()</a> uses this), or it might check whether the creating process &ndash; whose PID might be encoded in <code>name</code> by some convention (e.g., see <a class="el" href="namespaceipc_1_1session.html" title="Flow-IPC module providing the broad lifecycle and shared-resource organization – via the session conc...">ipc::session</a>) &ndash; is alive (<a class="el" href="namespaceipc_1_1util.html#a924cd56daf7eeaa0b07edb352367f9ec" title="Returns true if and only if the given process (by PID) is reported as running by the OS.">util::process_running()</a>). </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">logger_ptr</td><td>Logger to use for subsequently logging. </td></tr>
    <tr><td class="paramname">filter_func</td><td>See <code>Filter_func</code> above. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The number of successful <code>Persistent_object::remove_persistent()</code> calls invoked (might be zero). </dd></dl>

<p class="definition">Definition at line <a class="el" href="shared__name_8hpp_source.html#l00740">740</a> of file <a class="el" href="shared__name_8hpp_source.html">shared_name.hpp</a>.</p>

</div>
</div>
<a id="ad6be904bf1b0fe6659a11dec0fabbf6b" name="ad6be904bf1b0fe6659a11dec0fabbf6b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad6be904bf1b0fe6659a11dec0fabbf6b">&#9670;&nbsp;</a></span>remove_each_persistent_with_name_prefix()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Persistent_object &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">unsigned int ipc::util::remove_each_persistent_with_name_prefix </td>
          <td>(</td>
          <td class="paramtype">flow::log::Logger *&#160;</td>
          <td class="paramname"><em>logger_ptr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classipc_1_1util_1_1Shared__name.html">Shared_name</a> &amp;&#160;</td>
          <td class="paramname"><em>name_prefix_or_empty</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Utility that invokes <a class="el" href="namespaceipc_1_1util.html#a150051ee7e308ba7c9269b2d1e2c6c37" title="Utility that invokes Persistent_object::for_each_persistent(name_prefix_or_empty) and synchronously i...">remove_each_persistent_if()</a> with the filter that returns <code>true</code> (yes, remove) if and only if the item's name optionally matches a given <a class="el" href="classipc_1_1util_1_1Shared__name.html" title="String-wrapping abstraction representing a name uniquely distinguishing a kernel-persistent entity fr...">Shared_name</a> prefix. </p>
<p >(Optional in that supplying an <code>.empty()</code> prefix deletes all items.)</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Persistent_object</td><td>See <a class="el" href="namespaceipc_1_1util.html#a150051ee7e308ba7c9269b2d1e2c6c37" title="Utility that invokes Persistent_object::for_each_persistent(name_prefix_or_empty) and synchronously i...">remove_each_persistent_if()</a>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">logger_ptr</td><td>See <a class="el" href="namespaceipc_1_1util.html#a150051ee7e308ba7c9269b2d1e2c6c37" title="Utility that invokes Persistent_object::for_each_persistent(name_prefix_or_empty) and synchronously i...">remove_each_persistent_if()</a>. </td></tr>
    <tr><td class="paramname">name_prefix_or_empty</td><td>An object is removed only if its name starts with this value. This filter is skipped if the value is <code>.empty()</code>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>See <a class="el" href="namespaceipc_1_1util.html#a150051ee7e308ba7c9269b2d1e2c6c37" title="Utility that invokes Persistent_object::for_each_persistent(name_prefix_or_empty) and synchronously i...">remove_each_persistent_if()</a>. </dd></dl>

<p class="definition">Definition at line <a class="el" href="shared__name_8hpp_source.html#l00764">764</a> of file <a class="el" href="shared__name_8hpp_source.html">shared_name.hpp</a>.</p>

<p class="reference">References <a class="el" href="shared__name_8cpp_source.html#l00140">ipc::util::Shared_name::str()</a>.</p>
<div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="namespaceipc_1_1util_ad6be904bf1b0fe6659a11dec0fabbf6b_cgraph.svg" width="374" height="59"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe>
</div>
</div>

</div>
</div>
<a id="a1cdc0a8d761170faa844c49d37c522ff" name="a1cdc0a8d761170faa844c49d37c522ff"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1cdc0a8d761170faa844c49d37c522ff">&#9670;&nbsp;</a></span>remove_persistent_shm_pool()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ipc::util::remove_persistent_shm_pool </td>
          <td>(</td>
          <td class="paramtype">flow::log::Logger *&#160;</td>
          <td class="paramname"><em>logger_ptr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classipc_1_1util_1_1Shared__name.html">Shared_name</a> &amp;&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceipc.html#aa3192e586cc45d3e7c22463bf2760f89">Error_code</a> *&#160;</td>
          <td class="paramname"><em>err_code</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Equivalent to <a class="el" href="classipc_1_1shm_1_1classic_1_1Pool__arena.html#aff2327ce7339c1c732ddd4fcd4861ee4" title="Removes the named SHM pool object.">shm::classic::Pool_arena::remove_persistent()</a>. </p>
<p >Provided for similar reason to that described in <a class="el" href="namespaceipc_1_1util.html#a74135195ff6c2f840092c21e522f964a" title="Equivalent to shm::classic::Pool_arena::for_each_persistent().">for_each_persistent_shm_pool()</a> doc header nearby.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">logger_ptr</td><td>See above. </td></tr>
    <tr><td class="paramname">name</td><td>See above. </td></tr>
    <tr><td class="paramname">err_code</td><td>See above. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="ipc__core_2src_2ipc_2util_2detail_2util_8cpp_source.html#l00119">119</a> of file <a class="el" href="ipc__core_2src_2ipc_2util_2detail_2util_8cpp_source.html">util.cpp</a>.</p>

<p class="reference">References <a class="el" href="shared__name_8cpp_source.html#l00145">ipc::util::Shared_name::native_str()</a>, and <a class="el" href="ipc__core_2src_2ipc_2util_2detail_2util_8cpp_source.html#l00119">remove_persistent_shm_pool()</a>.</p>

<p class="reference">Referenced by <a class="el" href="blob__stream__mq__impl_8hpp_source.html#l00219">ipc::transport::Blob_stream_mq_base_impl&lt; Persistent_mq_handle &gt;::ensure_unique_peer()</a>, <a class="el" href="blob__stream__mq__impl_8hpp_source.html#l00164">ipc::transport::Blob_stream_mq_base_impl&lt; Persistent_mq_handle &gt;::remove_persistent()</a>, <a class="el" href="pool__arena_8cpp_source.html#l00164">ipc::shm::classic::Pool_arena::remove_persistent()</a>, and <a class="el" href="ipc__core_2src_2ipc_2util_2detail_2util_8cpp_source.html#l00119">remove_persistent_shm_pool()</a>.</p>
<div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="namespaceipc_1_1util_a1cdc0a8d761170faa844c49d37c522ff_cgraph.svg" width="378" height="71"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe>
</div>
</div>
<div class="dynheader">
Here is the caller graph for this function:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="namespaceipc_1_1util_a1cdc0a8d761170faa844c49d37c522ff_icgraph.svg" width="694" height="264"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe>
</div>
</div>

</div>
</div>
<a id="abbba79fcaee378f433e7ce3093e5c435" name="abbba79fcaee378f433e7ce3093e5c435"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abbba79fcaee378f433e7ce3093e5c435">&#9670;&nbsp;</a></span>set_resource_permissions() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ipc::util::set_resource_permissions </td>
          <td>(</td>
          <td class="paramtype">flow::log::Logger *&#160;</td>
          <td class="paramname"><em>logger_ptr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const fs::path &amp;&#160;</td>
          <td class="paramname"><em>path</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespaceipc_1_1util.html#a1b398ae730d1e6040687cb2397115152">Permissions</a> &amp;&#160;</td>
          <td class="paramname"><em>perms</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceipc.html#aa3192e586cc45d3e7c22463bf2760f89">Error_code</a> *&#160;</td>
          <td class="paramname"><em>err_code</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Utility that sets the permissions of the given resource (at the supplied file system path) to specified POSIX value. </p>
<p >If the resource cannot be accessed (not found, permissions...) that system Error_code shall be emitted.</p>
<h3>Rationale</h3>
<p >It may seem unnecessary, particularly given that it sometimes (in our internal code, but I mention it publicly for exposition purposes) placed right after the creation of the resource (file, SHM pool, POSIX MQ, shared mutex, etc.) &ndash; where the same <code>perms</code> is supplied to the creation-API, whichever is applicable. The reason is that those APIs tend to make the corresponding OS call (e.g., <code>open()</code>) which is bound by the "process umask" in POSIX/Linux; so for example if it's set to the typical 022 (octal), then it's impossible to make the resource group- or all-writable, regardless of <code>perms</code>. <a class="el" href="namespaceipc_1_1util.html#abbba79fcaee378f433e7ce3093e5c435" title="Utility that sets the permissions of the given resource (at the supplied file system path) to specifi...">set_resource_permissions()</a> uses a technique that bypasses the umask thing. Note that it does not make any calls to change the umask to accomplish this.</p>
<p >Note 1: Sometimes there is not even the creation-API argument for <code>perms</code>; in which case the rationale is even more straightforward.</p>
<p >Note 2: Sometimes there <em>is</em> that API... and (namely in boost.ipc at least) they actually took care to do this (what we do here) themselves (via <code>fchmod()</code> and such)... so we don't need to; in fact I (ygoldfel) treated it as valuable confirmation of the correctness of this maneuver.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">logger_ptr</td><td>Logger to use for logging (WARNING, on error only). Caller can themselves log further info if desired. </td></tr>
    <tr><td class="paramname">path</td><td>Path to resource. Symlinks are followed, and the target is the resource in question (not the symlink). </td></tr>
    <tr><td class="paramname">perms</td><td>See other overload. </td></tr>
    <tr><td class="paramname">err_code</td><td>See <code>flow::Error_code</code> docs for error reporting semantics. <a class="el" href="namespaceipc.html#aa3192e586cc45d3e7c22463bf2760f89" title="Short-hand for flow::Error_code which is very common.">Error_code</a> generated: see other overload; note that in addition file-not-found and the like are possible errors (in fact arguably the likeliest). </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="ipc__core_2src_2ipc_2util_2util_8cpp_source.html#l00046">46</a> of file <a class="el" href="ipc__core_2src_2ipc_2util_2util_8cpp_source.html">util.cpp</a>.</p>

<p class="reference">References <a class="el" href="ipc__core_2src_2ipc_2util_2util_8cpp_source.html#l00046">set_resource_permissions()</a>.</p>

<p class="reference">Referenced by <a class="el" href="posix__mq__handle_8cpp_source.html#l00060">ipc::transport::Posix_mq_handle::Posix_mq_handle()</a>, <a class="el" href="session__server__impl_8hpp_source.html#l00438">ipc::session::Session_server_impl&lt; Session_server_t, Server_session_t &gt;::Session_server_impl()</a>, and <a class="el" href="ipc__core_2src_2ipc_2util_2util_8cpp_source.html#l00046">set_resource_permissions()</a>.</p>
<div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="namespaceipc_1_1util_abbba79fcaee378f433e7ce3093e5c435_cgraph.svg" width="152" height="71"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe>
</div>
</div>
<div class="dynheader">
Here is the caller graph for this function:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="namespaceipc_1_1util_abbba79fcaee378f433e7ce3093e5c435_icgraph.svg" width="346" height="131"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe>
</div>
</div>

</div>
</div>
<a id="af8b2f5a0cd9fe9db4511c9a3e685b6ae" name="af8b2f5a0cd9fe9db4511c9a3e685b6ae"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af8b2f5a0cd9fe9db4511c9a3e685b6ae">&#9670;&nbsp;</a></span>set_resource_permissions() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ipc::util::set_resource_permissions </td>
          <td>(</td>
          <td class="paramtype">flow::log::Logger *&#160;</td>
          <td class="paramname"><em>logger_ptr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structipc_1_1util_1_1Native__handle.html">Native_handle</a>&#160;</td>
          <td class="paramname"><em>handle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespaceipc_1_1util.html#a1b398ae730d1e6040687cb2397115152">Permissions</a> &amp;&#160;</td>
          <td class="paramname"><em>perms</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceipc.html#aa3192e586cc45d3e7c22463bf2760f89">Error_code</a> *&#160;</td>
          <td class="paramname"><em>err_code</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Identical to the other <a class="el" href="namespaceipc_1_1util.html#abbba79fcaee378f433e7ce3093e5c435" title="Utility that sets the permissions of the given resource (at the supplied file system path) to specifi...">set_resource_permissions()</a> overload but operates on a pre-opened <a class="el" href="structipc_1_1util_1_1Native__handle.html" title="A monolayer-thin wrapper around a native handle, a/k/a descriptor a/k/a FD.">Native_handle</a> (a/k/a handle, socket, file descriptor) to the resource in question. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">logger_ptr</td><td>See other overload. </td></tr>
    <tr><td class="paramname">handle</td><td>See above. <code>handle.null() == true</code> causes undefined behavior (assertion may trip). Closed/invalid/etc. handle will yield civilized Error_code emission. </td></tr>
    <tr><td class="paramname">perms</td><td>See other overload. </td></tr>
    <tr><td class="paramname">err_code</td><td>See <code>flow::Error_code</code> docs for error reporting semantics. <a class="el" href="namespaceipc.html#aa3192e586cc45d3e7c22463bf2760f89" title="Short-hand for flow::Error_code which is very common.">Error_code</a> generated: system error codes if permissions cannot be set (invalid descriptor, un-opened descriptor, etc.). </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="ipc__core_2src_2ipc_2util_2util_8cpp_source.html#l00098">98</a> of file <a class="el" href="ipc__core_2src_2ipc_2util_2util_8cpp_source.html">util.cpp</a>.</p>

<p class="reference">References <a class="el" href="native__handle_8hpp_source.html#l00084">ipc::util::Native_handle::m_native_handle</a>, <a class="el" href="native__handle_8cpp_source.html#l00060">ipc::util::Native_handle::null()</a>, and <a class="el" href="ipc__core_2src_2ipc_2util_2util_8cpp_source.html#l00046">set_resource_permissions()</a>.</p>
<div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="namespaceipc_1_1util_af8b2f5a0cd9fe9db4511c9a3e685b6ae_cgraph.svg" width="350" height="131"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe>
</div>
</div>

</div>
</div>
<a id="abda2ce5bcdbc26ca63d667b87818439c" name="abda2ce5bcdbc26ca63d667b87818439c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abda2ce5bcdbc26ca63d667b87818439c">&#9670;&nbsp;</a></span>shared_resource_permissions()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespaceipc_1_1util.html#a1b398ae730d1e6040687cb2397115152">Permissions</a> ipc::util::shared_resource_permissions </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespaceipc_1_1util.html#a2ec0bfdddb41a1ef0403e4bb8967705d">Permissions_level</a>&#160;</td>
          <td class="paramname"><em>permissions_lvl</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Maps general Permissions_level specifier to low-level <a class="el" href="namespaceipc_1_1util.html#a1b398ae730d1e6040687cb2397115152" title="Short-hand for Unix (POSIX) permissions class.">Permissions</a> value, when the underlying resource is in the file-system and is either accessible (read-write in terms of file system) or inaccessible. </p>
<p >Examples of such resources are SHM pools (e.g., <a class="el" href="classipc_1_1shm_1_1classic_1_1Pool__arena.html" title="A SHM-classic interface around a single SHM pool with allocation-algorithm services by boost....">shm::classic::Pool_arena</a>), bipc MQs (<a class="el" href="classipc_1_1transport_1_1Bipc__mq__handle.html" title="Implements the Persistent_mq_handle concept by thinly wrapping bipc::message_queue,...">transport::Bipc_mq_handle</a>), POSIX MQs (<a class="el" href="classipc_1_1transport_1_1Posix__mq__handle.html" title="Implements the Persistent_mq_handle concept by wrapping the POSIX message queue API (see man mq_overv...">transport::Posix_mq_handle</a>).</p>
<p >Please do not confuse this setting with the read-only/read-write dichotomy potentially specified each time such a resource is opened for access (as is the case for SHM pools): the present mapping applies to a persistent protection in the file system, not at runtime at the code writer's discretion. The present permissions check is performed at opening time; the runtime writability check each time a datum is written into the resource.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">permissions_lvl</td><td>The value to translate. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The result. </dd></dl>

<p class="definition">Definition at line <a class="el" href="ipc__core_2src_2ipc_2util_2util_8cpp_source.html#l00037">37</a> of file <a class="el" href="ipc__core_2src_2ipc_2util_2util_8cpp_source.html">util.cpp</a>.</p>

<p class="reference">References <a class="el" href="namespaceipc_1_1util.html#a2ec0bfdddb41a1ef0403e4bb8967705da6fba12db09e5bebfaa04f6372c41c2cf">S_END_SENTINEL</a>, and <a class="el" href="ipc__core_2src_2ipc_2util_2detail_2util_8cpp_source.html#l00034">SHARED_RESOURCE_PERMISSIONS_LVL_MAP</a>.</p>

<p class="reference">Referenced by <a class="el" href="ipc__shm_2src_2ipc_2session_2detail_2shm_2classic_2server__session__impl_8hpp_source.html#l00207">ipc::session::shm::classic::Server_session_impl&lt; S_MQ_TYPE_OR_NONE, S_TRANSMIT_NATIVE_HANDLES, Mdt_payload &gt;::async_accept_log_in()</a>, <a class="el" href="ipc__session_2src_2ipc_2session_2detail_2client__session__impl_8hpp_source.html#l01127">ipc::session::Client_session_impl&lt; S_MQ_TYPE_OR_NONE, S_TRANSMIT_NATIVE_HANDLES, Mdt_payload, S_SHM_TYPE_OR_NONE, S_GRACEFUL_FINISH_REQUIRED_V &gt;::async_connect()</a>, <a class="el" href="ipc__shm_2src_2ipc_2session_2shm_2classic_2session__server_8hpp_source.html#l00531">ipc::session::shm::classic::Session_server&lt; S_MQ_TYPE_OR_NONE, S_TRANSMIT_NATIVE_HANDLES, Mdt_payload &gt;::init_app_shm_as_needed()</a>, <a class="el" href="ipc__shm__arena__lend_2src_2ipc_2session_2shm_2arena__lend_2jemalloc_2session__server_8hpp_source.html#l00397">ipc::session::shm::arena_lend::jemalloc::Session_server&lt; S_MQ_TYPE_OR_NONE, S_TRANSMIT_NATIVE_HANDLES, Mdt_payload &gt;::init_app_shm_as_needed()</a>, <a class="el" href="arena__lend_2src_2ipc_2session_2detail_2shm_2arena__lend_2jemalloc_2session__impl_8hpp_source.html#l00270">ipc::session::shm::arena_lend::jemalloc::Session_impl&lt; Session_impl_t &gt;::init_shm()</a>, <a class="el" href="ipc__session_2src_2ipc_2session_2detail_2server__session__impl_8hpp_source.html#l01485">ipc::session::Server_session_impl&lt; S_MQ_TYPE_OR_NONE, S_TRANSMIT_NATIVE_HANDLES, Mdt_payload, S_SHM_TYPE_OR_NONE, S_SHM_MAX_HNDL_SZ, S_GRACEFUL_FINISH_REQUIRED_V &gt;::make_channel_mqs()</a>, and <a class="el" href="session__server__impl_8hpp_source.html#l00438">ipc::session::Session_server_impl&lt; Session_server_t, Server_session_t &gt;::Session_server_impl()</a>.</p>
<div class="dynheader">
Here is the caller graph for this function:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="namespaceipc_1_1util_abda2ce5bcdbc26ca63d667b87818439c_icgraph.svg" width="644" height="494"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe>
</div>
</div>

</div>
</div>
<a id="a9ea22a64cfbc6de66181c278ff5f6975" name="a9ea22a64cfbc6de66181c278ff5f6975"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9ea22a64cfbc6de66181c278ff5f6975">&#9670;&nbsp;</a></span>swap()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void swap </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classipc_1_1util_1_1Shared__name.html">Shared_name</a> &amp;&#160;</td>
          <td class="paramname"><em>val1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classipc_1_1util_1_1Shared__name.html">Shared_name</a> &amp;&#160;</td>
          <td class="paramname"><em>val2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Swaps two objects. </p>
<p >Constant-time. Suitable for standard ADL-swap pattern <code>using std::swap; swap(val1, val2);</code>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">val1</td><td>Object. </td></tr>
    <tr><td class="paramname">val2</td><td>Object. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="shared__name_8cpp_source.html#l00420">420</a> of file <a class="el" href="shared__name_8cpp_source.html">shared_name.cpp</a>.</p>

<p class="reference">Referenced by <a class="el" href="native__handle_8cpp_source.html#l00046">ipc::util::Native_handle::operator=()</a>.</p>
<div class="dynheader">
Here is the caller graph for this function:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="namespaceipc_1_1util_a9ea22a64cfbc6de66181c278ff5f6975_icgraph.svg" width="506" height="47"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe>
</div>
</div>

</div>
</div>
<h2 class="groupheader">Variable Documentation</h2>
<a id="ad1ca1cab79a35e1eb1c47037a0973cd8" name="ad1ca1cab79a35e1eb1c47037a0973cd8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad1ca1cab79a35e1eb1c47037a0973cd8">&#9670;&nbsp;</a></span>CREATE_ONLY</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="namespaceipc_1_1util.html#a9d84c2bab504e6de32b20c77ca9723a2">Create_only</a> ipc::util::CREATE_ONLY</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Tag value indicating an atomic create-unless-exists-else-fail operation. </p>

<p class="definition">Definition at line <a class="el" href="ipc__core_2src_2ipc_2util_2util_8cpp_source.html#l00032">32</a> of file <a class="el" href="ipc__core_2src_2ipc_2util_2util_8cpp_source.html">util.cpp</a>.</p>

<p class="reference">Referenced by <a class="el" href="ipc__shm_2src_2ipc_2session_2detail_2shm_2classic_2server__session__impl_8hpp_source.html#l00207">ipc::session::shm::classic::Server_session_impl&lt; S_MQ_TYPE_OR_NONE, S_TRANSMIT_NATIVE_HANDLES, Mdt_payload &gt;::async_accept_log_in()</a>, <a class="el" href="blob__stream__mq__impl_8hpp_source.html#l00219">ipc::transport::Blob_stream_mq_base_impl&lt; Persistent_mq_handle &gt;::ensure_unique_peer()</a>, <a class="el" href="ipc__shm_2src_2ipc_2session_2shm_2classic_2session__server_8hpp_source.html#l00531">ipc::session::shm::classic::Session_server&lt; S_MQ_TYPE_OR_NONE, S_TRANSMIT_NATIVE_HANDLES, Mdt_payload &gt;::init_app_shm_as_needed()</a>, and <a class="el" href="ipc__session_2src_2ipc_2session_2detail_2server__session__impl_8hpp_source.html#l01485">ipc::session::Server_session_impl&lt; S_MQ_TYPE_OR_NONE, S_TRANSMIT_NATIVE_HANDLES, Mdt_payload, S_SHM_TYPE_OR_NONE, S_SHM_MAX_HNDL_SZ, S_GRACEFUL_FINISH_REQUIRED_V &gt;::make_channel_mqs()</a>.</p>

</div>
</div>
<a id="aca6ca223759ca3e11d5834a323454afa" name="aca6ca223759ca3e11d5834a323454afa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aca6ca223759ca3e11d5834a323454afa">&#9670;&nbsp;</a></span>EMPTY_STRING</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const std::string ipc::util::EMPTY_STRING</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>A (default-cted) string. May be useful for functions returning <code>const std::string&amp;</code>. </p>

<p class="definition">Definition at line <a class="el" href="ipc__core_2src_2ipc_2util_2util_8cpp_source.html#l00033">33</a> of file <a class="el" href="ipc__core_2src_2ipc_2util_2util_8cpp_source.html">util.cpp</a>.</p>

<p class="reference">Referenced by <a class="el" href="blob__stream__mq__rcv_8hpp_source.html#l00377">ipc::transport::Blob_stream_mq_receiver&lt; Persistent_mq_handle &gt;::nickname()</a>, <a class="el" href="blob__stream__mq__snd_8hpp_source.html#l00523">ipc::transport::Blob_stream_mq_sender&lt; Persistent_mq_handle &gt;::nickname()</a>, <a class="el" href="sync__io_2blob__stream__mq__rcv_8hpp_source.html#l00371">ipc::transport::sync_io::Blob_stream_mq_receiver&lt; Persistent_mq_handle &gt;::nickname()</a>, and <a class="el" href="sync__io_2blob__stream__mq__snd_8hpp_source.html#l00403">ipc::transport::sync_io::Blob_stream_mq_sender&lt; Persistent_mq_handle &gt;::nickname()</a>.</p>

</div>
</div>
<a id="aaaa1fe31f8d77f78345dec8fc95e9882" name="aaaa1fe31f8d77f78345dec8fc95e9882"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaaa1fe31f8d77f78345dec8fc95e9882">&#9670;&nbsp;</a></span>IPC_KERNEL_PERSISTENT_RUN_DIR</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const fs::path ipc::util::IPC_KERNEL_PERSISTENT_RUN_DIR = &quot;/var/run&quot;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Absolute path to the directory (without trailing separator) in the file system where kernel-persistent runtime, but not temporary, information shall be placed. </p>
<p >Kernel-persistent means that it'll disappear at reboot; runtime, but not temporary, means it's... not the designated temporary-data directory (informally: not /tmp). Informally: just know that it is /var/run, and that it stores things such as process-ID (PID) files.</p>
<p >It is a Unix path, absolute (starts with forward-slash), and lexically normal (and lacks a root-name). </p>

<p class="definition">Definition at line <a class="el" href="ipc__core_2src_2ipc_2util_2detail_2util_8cpp_source.html#l00063">63</a> of file <a class="el" href="ipc__core_2src_2ipc_2util_2detail_2util_8cpp_source.html">util.cpp</a>.</p>

<p class="reference">Referenced by <a class="el" href="session__base_8hpp_source.html#l00986">ipc::session::Session_base&lt; S_MQ_TYPE_OR_NONE, S_TRANSMIT_NATIVE_HANDLES, Mdt_payload &gt;::cur_ns_store_absolute_path()</a>.</p>

</div>
</div>
<a id="a6a3a6ec85242d073df96978c63464078" name="a6a3a6ec85242d073df96978c63464078"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6a3a6ec85242d073df96978c63464078">&#9670;&nbsp;</a></span>OPEN_ONLY</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="namespaceipc_1_1util.html#a3e03491b5b2b5fac26551a220946d6e5">Open_only</a> ipc::util::OPEN_ONLY</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Tag value indicating an atomic open-if-exists-else-fail operation. </p>

<p class="definition">Definition at line <a class="el" href="ipc__core_2src_2ipc_2util_2util_8cpp_source.html#l00031">31</a> of file <a class="el" href="ipc__core_2src_2ipc_2util_2util_8cpp_source.html">util.cpp</a>.</p>

<p class="reference">Referenced by <a class="el" href="ipc__shm_2src_2ipc_2session_2detail_2shm_2classic_2client__session__impl_8hpp_source.html#l00175">ipc::session::shm::classic::Client_session_impl&lt; S_MQ_TYPE_OR_NONE, S_TRANSMIT_NATIVE_HANDLES, Mdt_payload &gt;::async_connect()</a>, <a class="el" href="bipc__mq__handle_8cpp_source.html#l00097">ipc::transport::Bipc_mq_handle::Bipc_mq_handle()</a>, <a class="el" href="ipc__session_2src_2ipc_2session_2detail_2client__session__impl_8hpp_source.html#l02397">ipc::session::Client_session_impl&lt; S_MQ_TYPE_OR_NONE, S_TRANSMIT_NATIVE_HANDLES, Mdt_payload, S_SHM_TYPE_OR_NONE, S_GRACEFUL_FINISH_REQUIRED_V &gt;::create_channel_obj()</a>, and <a class="el" href="pool__arena_8cpp_source.html#l00079">ipc::shm::classic::Pool_arena::Pool_arena()</a>.</p>

</div>
</div>
<a id="a5664539b3d75d6d10cdfebf6eac5382d" name="a5664539b3d75d6d10cdfebf6eac5382d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5664539b3d75d6d10cdfebf6eac5382d">&#9670;&nbsp;</a></span>OPEN_OR_CREATE</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="namespaceipc_1_1util.html#a9571de958538d7a4a8649bbfecfac0b9">Open_or_create</a> ipc::util::OPEN_OR_CREATE</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Tag value indicating an open-if-exists-else-create operation. </p>

<p class="definition">Definition at line <a class="el" href="ipc__core_2src_2ipc_2util_2util_8cpp_source.html#l00030">30</a> of file <a class="el" href="ipc__core_2src_2ipc_2util_2util_8cpp_source.html">util.cpp</a>.</p>

<p class="reference">Referenced by <a class="el" href="ipc__session_2src_2ipc_2session_2detail_2client__session__impl_8hpp_source.html#l01127">ipc::session::Client_session_impl&lt; S_MQ_TYPE_OR_NONE, S_TRANSMIT_NATIVE_HANDLES, Mdt_payload, S_SHM_TYPE_OR_NONE, S_GRACEFUL_FINISH_REQUIRED_V &gt;::async_connect()</a>, and <a class="el" href="session__server__impl_8hpp_source.html#l00438">ipc::session::Session_server_impl&lt; Session_server_t, Server_session_t &gt;::Session_server_impl()</a>.</p>

</div>
</div>
<a id="aa74a8b46a5b38021c662a0b3bdfb46bf" name="aa74a8b46a5b38021c662a0b3bdfb46bf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa74a8b46a5b38021c662a0b3bdfb46bf">&#9670;&nbsp;</a></span>PRODUCER_CONSUMER_RESOURCE_PERMISSIONS_LVL_MAP</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const boost::array&lt; <a class="el" href="namespaceipc_1_1util.html#a1b398ae730d1e6040687cb2397115152">Permissions</a>, size_t(<a class="el" href="namespaceipc_1_1util.html#a2ec0bfdddb41a1ef0403e4bb8967705da6fba12db09e5bebfaa04f6372c41c2cf">Permissions_level::S_END_SENTINEL</a>)&gt; ipc::util::PRODUCER_CONSUMER_RESOURCE_PERMISSIONS_LVL_MAP</td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Initial value:</b><div class="fragment"><div class="line">= {</div>
<div class="line">        <a class="code hl_typedef" href="namespaceipc_1_1util.html#a1b398ae730d1e6040687cb2397115152">Permissions</a>(0), </div>
<div class="line">        </div>
<div class="line">        <a class="code hl_typedef" href="namespaceipc_1_1util.html#a1b398ae730d1e6040687cb2397115152">Permissions</a>(0b110000000), </div>
<div class="line">        </div>
<div class="line">        <a class="code hl_typedef" href="namespaceipc_1_1util.html#a1b398ae730d1e6040687cb2397115152">Permissions</a>(0b110100000), </div>
<div class="line">        <a class="code hl_typedef" href="namespaceipc_1_1util.html#a1b398ae730d1e6040687cb2397115152">Permissions</a>(0b110100100) </div>
<div class="line">      }</div>
<div class="ttc" id="anamespaceipc_1_1util_html_a1b398ae730d1e6040687cb2397115152"><div class="ttname"><a href="namespaceipc_1_1util.html#a1b398ae730d1e6040687cb2397115152">ipc::util::Permissions</a></div><div class="ttdeci">bipc::permissions Permissions</div><div class="ttdoc">Short-hand for Unix (POSIX) permissions class.</div><div class="ttdef"><b>Definition:</b> <a href="util__fwd_8hpp_source.html#l00155">util_fwd.hpp:155</a></div></div>
</div><!-- fragment -->
<p>Maps general Permissions_level specifier to low-level <a class="el" href="namespaceipc_1_1util.html#a1b398ae730d1e6040687cb2397115152" title="Short-hand for Unix (POSIX) permissions class.">Permissions</a> value, when the underlying resource is in the file-system (e.g., a file) and is <em>produced</em> (and therefore always writable) by the owning (creating, updating) user; but <em>consumed</em> (and therefore at most readable, never writable) by potentially other processes, and therefore possibly other users (e.g., group access or unrestricted access &ndash; but only for reading either way). </p>
<p >For example a PID file is typically only writable by the daemon's user but may be readable or inaccessible by other users. </p>

<p class="definition">Definition at line <a class="el" href="ipc__core_2src_2ipc_2util_2detail_2util_8cpp_source.html#l00041">41</a> of file <a class="el" href="ipc__core_2src_2ipc_2util_2detail_2util_8cpp_source.html">util.cpp</a>.</p>

<p class="reference">Referenced by <a class="el" href="session__server__impl_8hpp_source.html#l00438">ipc::session::Session_server_impl&lt; Session_server_t, Server_session_t &gt;::Session_server_impl()</a>.</p>

</div>
</div>
<a id="a5716a13eb4de32e516ca257e025d8c20" name="a5716a13eb4de32e516ca257e025d8c20"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5716a13eb4de32e516ca257e025d8c20">&#9670;&nbsp;</a></span>SHARED_RESOURCE_PERMISSIONS_LVL_MAP</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const boost::array&lt; <a class="el" href="namespaceipc_1_1util.html#a1b398ae730d1e6040687cb2397115152">Permissions</a>, size_t(<a class="el" href="namespaceipc_1_1util.html#a2ec0bfdddb41a1ef0403e4bb8967705da6fba12db09e5bebfaa04f6372c41c2cf">Permissions_level::S_END_SENTINEL</a>)&gt; ipc::util::SHARED_RESOURCE_PERMISSIONS_LVL_MAP</td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Initial value:</b><div class="fragment"><div class="line">= {</div>
<div class="line">        <a class="code hl_typedef" href="namespaceipc_1_1util.html#a1b398ae730d1e6040687cb2397115152">Permissions</a>(0), </div>
<div class="line">        <a class="code hl_typedef" href="namespaceipc_1_1util.html#a1b398ae730d1e6040687cb2397115152">Permissions</a>(0b110000000), </div>
<div class="line">        <a class="code hl_typedef" href="namespaceipc_1_1util.html#a1b398ae730d1e6040687cb2397115152">Permissions</a>(0b110110000), </div>
<div class="line">        <a class="code hl_typedef" href="namespaceipc_1_1util.html#a1b398ae730d1e6040687cb2397115152">Permissions</a>(0b110110110) </div>
<div class="line">      }</div>
</div><!-- fragment -->
<p>Maps general Permissions_level specifier to low-level <a class="el" href="namespaceipc_1_1util.html#a1b398ae730d1e6040687cb2397115152" title="Short-hand for Unix (POSIX) permissions class.">Permissions</a> value, when the underlying resource is in the file-system and is either accessible (read-write in terms of file system) or inaccessible. </p>
<p >Examples of such resources are SHM pools (in Linux living in "/dev/shm") and POSIX MQs ("/dev/mqueue").</p>
<p >See any additional user-facing notes in <a class="el" href="namespaceipc_1_1util.html#abda2ce5bcdbc26ca63d667b87818439c" title="Maps general Permissions_level specifier to low-level Permissions value, when the underlying resource...">shared_resource_permissions()</a> doc header. </p>

<p class="definition">Definition at line <a class="el" href="ipc__core_2src_2ipc_2util_2detail_2util_8cpp_source.html#l00033">33</a> of file <a class="el" href="ipc__core_2src_2ipc_2util_2detail_2util_8cpp_source.html">util.cpp</a>.</p>

<p class="reference">Referenced by <a class="el" href="ipc__core_2src_2ipc_2util_2util_8cpp_source.html#l00037">shared_resource_permissions()</a>.</p>

</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Wed Mar 13 2024 09:08:24 for Flow-IPC by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.4
</small></address>
</body>
</html>
