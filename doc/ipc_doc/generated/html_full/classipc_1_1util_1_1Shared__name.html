<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.9.4"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Flow-IPC: ipc::util::Shared_name Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">Flow-IPC<span id="projectnumber">&#160;1.0.0</span>
   </div>
   <div id="projectbrief">Flow-IPC project: Full implementation reference.</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.4 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search",'Search','.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespaceipc.html">ipc</a></li><li class="navelem"><a class="el" href="namespaceipc_1_1util.html">util</a></li><li class="navelem"><a class="el" href="classipc_1_1util_1_1Shared__name.html">Shared_name</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pub-static-methods">Static Public Member Functions</a> &#124;
<a href="#pub-static-attribs">Static Public Attributes</a> &#124;
<a href="#pri-attribs">Private Attributes</a> &#124;
<a href="#friends">Friends</a> &#124;
<a href="#related">Related Functions</a> &#124;
<a href="classipc_1_1util_1_1Shared__name-members.html">List of all members</a>  </div>
  <div class="headertitle"><div class="title">ipc::util::Shared_name Class Reference</div></div>
</div><!--header-->
<div class="contents">

<p>String-wrapping abstraction representing a name uniquely distinguishing a kernel-persistent entity from all others in the system, or a fragment of such a name.  
 <a href="classipc_1_1util_1_1Shared__name.html#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="shared__name_8hpp_source.html">shared_name.hpp</a>&gt;</code></p>
<div class="dynheader">
Collaboration diagram for ipc::util::Shared_name:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="classipc_1_1util_1_1Shared__name__coll__graph.svg" width="356" height="276"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe>
</div>
<center><span class="legend">[<a href="graph_legend.html">legend</a>]</span></center></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-methods" name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a1f9b706d587b49ad84b555817c001fc8"><td class="memItemLeft" align="right" valign="top"><a id="a1f9b706d587b49ad84b555817c001fc8" name="a1f9b706d587b49ad84b555817c001fc8"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>Shared_name</b> ()</td></tr>
<tr class="memdesc:a1f9b706d587b49ad84b555817c001fc8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructs <a class="el" href="classipc_1_1util_1_1Shared__name.html#a861ea6c9ad6672e83bab5c7747b66f7b" title="Returns true if and only if str().empty() == true.">empty()</a> name. <br /></td></tr>
<tr class="separator:a1f9b706d587b49ad84b555817c001fc8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1e9cad5a94d78e1180a9e77877009873"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classipc_1_1util_1_1Shared__name.html#a1e9cad5a94d78e1180a9e77877009873">Shared_name</a> (const <a class="el" href="classipc_1_1util_1_1Shared__name.html">Shared_name</a> &amp;src)</td></tr>
<tr class="memdesc:a1e9cad5a94d78e1180a9e77877009873"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy-constructs from an existing <a class="el" href="classipc_1_1util_1_1Shared__name.html" title="String-wrapping abstraction representing a name uniquely distinguishing a kernel-persistent entity fr...">Shared_name</a>.  <a href="classipc_1_1util_1_1Shared__name.html#a1e9cad5a94d78e1180a9e77877009873">More...</a><br /></td></tr>
<tr class="separator:a1e9cad5a94d78e1180a9e77877009873"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a79995ab36be778bb2a56eeba80a7abed"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classipc_1_1util_1_1Shared__name.html#a79995ab36be778bb2a56eeba80a7abed">Shared_name</a> (<a class="el" href="classipc_1_1util_1_1Shared__name.html">Shared_name</a> &amp;&amp;src_moved)</td></tr>
<tr class="memdesc:a79995ab36be778bb2a56eeba80a7abed"><td class="mdescLeft">&#160;</td><td class="mdescRight">Move-constructs from an existing <a class="el" href="classipc_1_1util_1_1Shared__name.html" title="String-wrapping abstraction representing a name uniquely distinguishing a kernel-persistent entity fr...">Shared_name</a>, which is made <a class="el" href="classipc_1_1util_1_1Shared__name.html#a861ea6c9ad6672e83bab5c7747b66f7b" title="Returns true if and only if str().empty() == true.">empty()</a> if not already so.  <a href="classipc_1_1util_1_1Shared__name.html#a79995ab36be778bb2a56eeba80a7abed">More...</a><br /></td></tr>
<tr class="separator:a79995ab36be778bb2a56eeba80a7abed"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a766b98e1a87f4035b6869c78f331c69a"><td class="memTemplParams" colspan="2">template&lt;typename Input_it &gt; </td></tr>
<tr class="memitem:a766b98e1a87f4035b6869c78f331c69a"><td class="memTemplItemLeft" align="right" valign="top">&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classipc_1_1util_1_1Shared__name.html#a766b98e1a87f4035b6869c78f331c69a">Shared_name</a> (Input_it begin, Input_it end)</td></tr>
<tr class="memdesc:a766b98e1a87f4035b6869c78f331c69a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy-constructs from a <code>char</code> range given as a pair of random-iterators; in particular <code>const char*</code>s work.  <a href="classipc_1_1util_1_1Shared__name.html#a766b98e1a87f4035b6869c78f331c69a">More...</a><br /></td></tr>
<tr class="separator:a766b98e1a87f4035b6869c78f331c69a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abd312f9eaf6f07adaba115aaab05b539"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classipc_1_1util_1_1Shared__name.html">Shared_name</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classipc_1_1util_1_1Shared__name.html#abd312f9eaf6f07adaba115aaab05b539">operator=</a> (const <a class="el" href="classipc_1_1util_1_1Shared__name.html">Shared_name</a> &amp;src)</td></tr>
<tr class="memdesc:abd312f9eaf6f07adaba115aaab05b539"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy-assigns from an existing <a class="el" href="classipc_1_1util_1_1Shared__name.html" title="String-wrapping abstraction representing a name uniquely distinguishing a kernel-persistent entity fr...">Shared_name</a>.  <a href="classipc_1_1util_1_1Shared__name.html#abd312f9eaf6f07adaba115aaab05b539">More...</a><br /></td></tr>
<tr class="separator:abd312f9eaf6f07adaba115aaab05b539"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1511bd84d701dd866029d0f4c8869516"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classipc_1_1util_1_1Shared__name.html">Shared_name</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classipc_1_1util_1_1Shared__name.html#a1511bd84d701dd866029d0f4c8869516">operator=</a> (<a class="el" href="classipc_1_1util_1_1Shared__name.html">Shared_name</a> &amp;&amp;src_moved)</td></tr>
<tr class="memdesc:a1511bd84d701dd866029d0f4c8869516"><td class="mdescLeft">&#160;</td><td class="mdescRight">Move-assigns from an existing <a class="el" href="classipc_1_1util_1_1Shared__name.html" title="String-wrapping abstraction representing a name uniquely distinguishing a kernel-persistent entity fr...">Shared_name</a>.  <a href="classipc_1_1util_1_1Shared__name.html#a1511bd84d701dd866029d0f4c8869516">More...</a><br /></td></tr>
<tr class="separator:a1511bd84d701dd866029d0f4c8869516"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae89e1e061f87ffe0288514e254837595"><td class="memItemLeft" align="right" valign="top">const std::string &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classipc_1_1util_1_1Shared__name.html#ae89e1e061f87ffe0288514e254837595">str</a> () const</td></tr>
<tr class="memdesc:ae89e1e061f87ffe0288514e254837595"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns (sans copying) ref to immutable entire wrapped name string, suitable to pass into sys calls when naming supported shared resources assuming <code><a class="el" href="classipc_1_1util_1_1Shared__name.html#ab1934f80515fdbc3e2a59ccda32fff9a" title="Returns true if and only if the first character is S_SEPARATOR.">absolute()</a> == true</code>.  <a href="classipc_1_1util_1_1Shared__name.html#ae89e1e061f87ffe0288514e254837595">More...</a><br /></td></tr>
<tr class="separator:ae89e1e061f87ffe0288514e254837595"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0bccc73c9c5b4f3b784a1e57cdc5c910"><td class="memItemLeft" align="right" valign="top">const char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classipc_1_1util_1_1Shared__name.html#a0bccc73c9c5b4f3b784a1e57cdc5c910">native_str</a> () const</td></tr>
<tr class="memdesc:a0bccc73c9c5b4f3b784a1e57cdc5c910"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns (sans copying) pointer to NUL-terminated wrapped name string, suitable to pass into sys calls when naming supported shared resources assuming <code><a class="el" href="classipc_1_1util_1_1Shared__name.html#ab1934f80515fdbc3e2a59ccda32fff9a" title="Returns true if and only if the first character is S_SEPARATOR.">absolute()</a> == true</code>.  <a href="classipc_1_1util_1_1Shared__name.html#a0bccc73c9c5b4f3b784a1e57cdc5c910">More...</a><br /></td></tr>
<tr class="separator:a0bccc73c9c5b4f3b784a1e57cdc5c910"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af34db2934e116f8a4fdd403fd04695af"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classipc_1_1util_1_1Shared__name.html#af34db2934e116f8a4fdd403fd04695af">size</a> () const</td></tr>
<tr class="memdesc:af34db2934e116f8a4fdd403fd04695af"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns <code><a class="el" href="classipc_1_1util_1_1Shared__name.html#ae89e1e061f87ffe0288514e254837595" title="Returns (sans copying) ref to immutable entire wrapped name string, suitable to pass into sys calls w...">str()</a>.<a class="el" href="classipc_1_1util_1_1Shared__name.html#af34db2934e116f8a4fdd403fd04695af" title="Returns str().size().">size()</a></code>.  <a href="classipc_1_1util_1_1Shared__name.html#af34db2934e116f8a4fdd403fd04695af">More...</a><br /></td></tr>
<tr class="separator:af34db2934e116f8a4fdd403fd04695af"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a861ea6c9ad6672e83bab5c7747b66f7b"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classipc_1_1util_1_1Shared__name.html#a861ea6c9ad6672e83bab5c7747b66f7b">empty</a> () const</td></tr>
<tr class="memdesc:a861ea6c9ad6672e83bab5c7747b66f7b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns <code>true</code> if and only if <code><a class="el" href="classipc_1_1util_1_1Shared__name.html#ae89e1e061f87ffe0288514e254837595" title="Returns (sans copying) ref to immutable entire wrapped name string, suitable to pass into sys calls w...">str()</a>.<a class="el" href="classipc_1_1util_1_1Shared__name.html#a861ea6c9ad6672e83bab5c7747b66f7b" title="Returns true if and only if str().empty() == true.">empty()</a> == true</code>.  <a href="classipc_1_1util_1_1Shared__name.html#a861ea6c9ad6672e83bab5c7747b66f7b">More...</a><br /></td></tr>
<tr class="separator:a861ea6c9ad6672e83bab5c7747b66f7b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a774e872b51100b728e0780b39f563ed9"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classipc_1_1util_1_1Shared__name.html#a774e872b51100b728e0780b39f563ed9">has_trailing_separator</a> () const</td></tr>
<tr class="memdesc:a774e872b51100b728e0780b39f563ed9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns <code>true</code> if and only if <code>!this-&gt;<a class="el" href="classipc_1_1util_1_1Shared__name.html#a861ea6c9ad6672e83bab5c7747b66f7b" title="Returns true if and only if str().empty() == true.">empty()</a></code>, and <a class="el" href="classipc_1_1util_1_1Shared__name.html#ae89e1e061f87ffe0288514e254837595" title="Returns (sans copying) ref to immutable entire wrapped name string, suitable to pass into sys calls w...">str()</a> ends with the <a class="el" href="classipc_1_1util_1_1Shared__name.html#a5c0910497c5ec484d3e42dfb0ccad48d" title="Character we use, by convention, to separate conceptual folders within str().">S_SEPARATOR</a> character.  <a href="classipc_1_1util_1_1Shared__name.html#a774e872b51100b728e0780b39f563ed9">More...</a><br /></td></tr>
<tr class="separator:a774e872b51100b728e0780b39f563ed9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab1934f80515fdbc3e2a59ccda32fff9a"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classipc_1_1util_1_1Shared__name.html#ab1934f80515fdbc3e2a59ccda32fff9a">absolute</a> () const</td></tr>
<tr class="memdesc:ab1934f80515fdbc3e2a59ccda32fff9a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns <code>true</code> if and only if the first character is <a class="el" href="classipc_1_1util_1_1Shared__name.html#a5c0910497c5ec484d3e42dfb0ccad48d" title="Character we use, by convention, to separate conceptual folders within str().">S_SEPARATOR</a>.  <a href="classipc_1_1util_1_1Shared__name.html#ab1934f80515fdbc3e2a59ccda32fff9a">More...</a><br /></td></tr>
<tr class="separator:ab1934f80515fdbc3e2a59ccda32fff9a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8328c9a6bc2739145087515ee8e677d8"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classipc_1_1util_1_1Shared__name.html#a8328c9a6bc2739145087515ee8e677d8">clear</a> ()</td></tr>
<tr class="memdesc:a8328c9a6bc2739145087515ee8e677d8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Makes it so <code><a class="el" href="classipc_1_1util_1_1Shared__name.html#a861ea6c9ad6672e83bab5c7747b66f7b" title="Returns true if and only if str().empty() == true.">empty()</a> == true</code>.  <a href="classipc_1_1util_1_1Shared__name.html#a8328c9a6bc2739145087515ee8e677d8">More...</a><br /></td></tr>
<tr class="separator:a8328c9a6bc2739145087515ee8e677d8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a03d90faae35392c8bbdd22f056755ba9"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classipc_1_1util_1_1Shared__name.html#a03d90faae35392c8bbdd22f056755ba9">sanitized</a> () const</td></tr>
<tr class="memdesc:a03d90faae35392c8bbdd22f056755ba9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns <code>true</code> if and only if the contained name/fragment is <em>sanitized</em> according to length, legal characters, and similar.  <a href="classipc_1_1util_1_1Shared__name.html#a03d90faae35392c8bbdd22f056755ba9">More...</a><br /></td></tr>
<tr class="separator:a03d90faae35392c8bbdd22f056755ba9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:add4ed045e03f786427a236a5dfa5a1b0"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classipc_1_1util_1_1Shared__name.html#add4ed045e03f786427a236a5dfa5a1b0">sanitize</a> ()</td></tr>
<tr class="memdesc:add4ed045e03f786427a236a5dfa5a1b0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Best-effort attempt to turn <a class="el" href="classipc_1_1util_1_1Shared__name.html#a03d90faae35392c8bbdd22f056755ba9" title="Returns true if and only if the contained name/fragment is sanitized according to length,...">sanitized()</a> from <code>false</code> to <code>true</code>, unless it is already <code>true</code>; returns the final value of <a class="el" href="classipc_1_1util_1_1Shared__name.html#a03d90faae35392c8bbdd22f056755ba9" title="Returns true if and only if the contained name/fragment is sanitized according to length,...">sanitized()</a> indicating whether it was successful.  <a href="classipc_1_1util_1_1Shared__name.html#add4ed045e03f786427a236a5dfa5a1b0">More...</a><br /></td></tr>
<tr class="separator:add4ed045e03f786427a236a5dfa5a1b0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a956fdac1bb4cfab414b30091bec43f70"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classipc_1_1util_1_1Shared__name.html">Shared_name</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classipc_1_1util_1_1Shared__name.html#a956fdac1bb4cfab414b30091bec43f70">operator/=</a> (const <a class="el" href="classipc_1_1util_1_1Shared__name.html">Shared_name</a> &amp;src_to_append)</td></tr>
<tr class="memdesc:a956fdac1bb4cfab414b30091bec43f70"><td class="mdescLeft">&#160;</td><td class="mdescRight">Appends a folder separator followed by the given other <a class="el" href="classipc_1_1util_1_1Shared__name.html" title="String-wrapping abstraction representing a name uniquely distinguishing a kernel-persistent entity fr...">Shared_name</a>.  <a href="classipc_1_1util_1_1Shared__name.html#a956fdac1bb4cfab414b30091bec43f70">More...</a><br /></td></tr>
<tr class="separator:a956fdac1bb4cfab414b30091bec43f70"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a762bda2d73b31c9427c05c7c1a7abbcb"><td class="memTemplParams" colspan="2">template&lt;typename Source &gt; </td></tr>
<tr class="memitem:a762bda2d73b31c9427c05c7c1a7abbcb"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classipc_1_1util_1_1Shared__name.html">Shared_name</a> &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classipc_1_1util_1_1Shared__name.html#a762bda2d73b31c9427c05c7c1a7abbcb">operator/=</a> (const Source &amp;raw_name_to_append)</td></tr>
<tr class="memdesc:a762bda2d73b31c9427c05c7c1a7abbcb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Simply appends a folder separator followed by <code>raw_name_to_append</code> to the current value of <a class="el" href="classipc_1_1util_1_1Shared__name.html#ae89e1e061f87ffe0288514e254837595" title="Returns (sans copying) ref to immutable entire wrapped name string, suitable to pass into sys calls w...">str()</a>.  <a href="classipc_1_1util_1_1Shared__name.html#a762bda2d73b31c9427c05c7c1a7abbcb">More...</a><br /></td></tr>
<tr class="separator:a762bda2d73b31c9427c05c7c1a7abbcb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a99c77008fb2c507e32e05272812c4782"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classipc_1_1util_1_1Shared__name.html">Shared_name</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classipc_1_1util_1_1Shared__name.html#a99c77008fb2c507e32e05272812c4782">operator/=</a> (const char *raw_name_to_append)</td></tr>
<tr class="memdesc:a99c77008fb2c507e32e05272812c4782"><td class="mdescLeft">&#160;</td><td class="mdescRight">Similar to the overload that takes <code>const Source&amp;</code>, but takes NUL-terminated string instead.  <a href="classipc_1_1util_1_1Shared__name.html#a99c77008fb2c507e32e05272812c4782">More...</a><br /></td></tr>
<tr class="separator:a99c77008fb2c507e32e05272812c4782"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1bcac1c10e01ba11dcc437b3c32bbe6c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classipc_1_1util_1_1Shared__name.html">Shared_name</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classipc_1_1util_1_1Shared__name.html#a1bcac1c10e01ba11dcc437b3c32bbe6c">operator+=</a> (const <a class="el" href="classipc_1_1util_1_1Shared__name.html">Shared_name</a> &amp;src_to_append)</td></tr>
<tr class="memdesc:a1bcac1c10e01ba11dcc437b3c32bbe6c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Appends the given other <a class="el" href="classipc_1_1util_1_1Shared__name.html" title="String-wrapping abstraction representing a name uniquely distinguishing a kernel-persistent entity fr...">Shared_name</a>.  <a href="classipc_1_1util_1_1Shared__name.html#a1bcac1c10e01ba11dcc437b3c32bbe6c">More...</a><br /></td></tr>
<tr class="separator:a1bcac1c10e01ba11dcc437b3c32bbe6c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae168cc42213bf7972d17bbbc1e16f2a2"><td class="memTemplParams" colspan="2">template&lt;typename Source &gt; </td></tr>
<tr class="memitem:ae168cc42213bf7972d17bbbc1e16f2a2"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classipc_1_1util_1_1Shared__name.html">Shared_name</a> &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classipc_1_1util_1_1Shared__name.html#ae168cc42213bf7972d17bbbc1e16f2a2">operator+=</a> (const Source &amp;raw_name_to_append)</td></tr>
<tr class="memdesc:ae168cc42213bf7972d17bbbc1e16f2a2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Simply appends <code>raw_name_to_append</code> to the current value of <a class="el" href="classipc_1_1util_1_1Shared__name.html#ae89e1e061f87ffe0288514e254837595" title="Returns (sans copying) ref to immutable entire wrapped name string, suitable to pass into sys calls w...">str()</a>.  <a href="classipc_1_1util_1_1Shared__name.html#ae168cc42213bf7972d17bbbc1e16f2a2">More...</a><br /></td></tr>
<tr class="separator:ae168cc42213bf7972d17bbbc1e16f2a2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6f3d1055ef0e6d166a9f4532758d36de"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classipc_1_1util_1_1Shared__name.html">Shared_name</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classipc_1_1util_1_1Shared__name.html#a6f3d1055ef0e6d166a9f4532758d36de">operator+=</a> (const char *raw_name_to_append)</td></tr>
<tr class="memdesc:a6f3d1055ef0e6d166a9f4532758d36de"><td class="mdescLeft">&#160;</td><td class="mdescRight">Similar to the overload that takes <code>const Source&amp;</code>, but takes NUL-terminated string instead.  <a href="classipc_1_1util_1_1Shared__name.html#a6f3d1055ef0e6d166a9f4532758d36de">More...</a><br /></td></tr>
<tr class="separator:a6f3d1055ef0e6d166a9f4532758d36de"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-static-methods" name="pub-static-methods"></a>
Static Public Member Functions</h2></td></tr>
<tr class="memitem:a48f20b7b54490aa10dc64081d34c55b2"><td class="memTemplParams" colspan="2">template&lt;typename Source &gt; </td></tr>
<tr class="memitem:a48f20b7b54490aa10dc64081d34c55b2"><td class="memTemplItemLeft" align="right" valign="top">static <a class="el" href="classipc_1_1util_1_1Shared__name.html">Shared_name</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classipc_1_1util_1_1Shared__name.html#a48f20b7b54490aa10dc64081d34c55b2">ct</a> (const Source &amp;src)</td></tr>
<tr class="memdesc:a48f20b7b54490aa10dc64081d34c55b2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy-constructs from a <code>char</code>-sequence container (including <code>string</code>, <a class="el" href="namespaceipc_1_1util.html#ae6ac47812a90d1287c61e0b7de7bc4f5" title="Short-hand for Flow&#39;s String_view.">util::String_view</a>, <code>vector&lt;char&gt;</code>).  <a href="classipc_1_1util_1_1Shared__name.html#a48f20b7b54490aa10dc64081d34c55b2">More...</a><br /></td></tr>
<tr class="separator:a48f20b7b54490aa10dc64081d34c55b2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a66f531c6fa407739fa81b12034351874"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classipc_1_1util_1_1Shared__name.html">Shared_name</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classipc_1_1util_1_1Shared__name.html#a66f531c6fa407739fa81b12034351874">ct</a> (const char *src)</td></tr>
<tr class="memdesc:a66f531c6fa407739fa81b12034351874"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy-constructs from a NUL-terminated <code>const char*</code> string.  <a href="classipc_1_1util_1_1Shared__name.html#a66f531c6fa407739fa81b12034351874">More...</a><br /></td></tr>
<tr class="separator:a66f531c6fa407739fa81b12034351874"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a925d30aa9b3391651303de04f82d4949"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classipc_1_1util_1_1Shared__name.html">Shared_name</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classipc_1_1util_1_1Shared__name.html#a925d30aa9b3391651303de04f82d4949">ct</a> (std::string &amp;&amp;src_moved)</td></tr>
<tr class="memdesc:a925d30aa9b3391651303de04f82d4949"><td class="mdescLeft">&#160;</td><td class="mdescRight">Destructively move-constructs from an <code>std::string</code>, emptying that source object.  <a href="classipc_1_1util_1_1Shared__name.html#a925d30aa9b3391651303de04f82d4949">More...</a><br /></td></tr>
<tr class="separator:a925d30aa9b3391651303de04f82d4949"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-static-attribs" name="pub-static-attribs"></a>
Static Public Attributes</h2></td></tr>
<tr class="memitem:a5bbfb4d3b378cf7b9a1bcaf5d6c5a067"><td class="memItemLeft" align="right" valign="top">static const <a class="el" href="classipc_1_1util_1_1Shared__name.html">Shared_name</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classipc_1_1util_1_1Shared__name.html#a5bbfb4d3b378cf7b9a1bcaf5d6c5a067">S_EMPTY</a></td></tr>
<tr class="memdesc:a5bbfb4d3b378cf7b9a1bcaf5d6c5a067"><td class="mdescLeft">&#160;</td><td class="mdescRight">A (default-cted) <a class="el" href="classipc_1_1util_1_1Shared__name.html" title="String-wrapping abstraction representing a name uniquely distinguishing a kernel-persistent entity fr...">Shared_name</a>. May be useful for functions returning <code>const <a class="el" href="classipc_1_1util_1_1Shared__name.html" title="String-wrapping abstraction representing a name uniquely distinguishing a kernel-persistent entity fr...">Shared_name</a>&amp;</code>.  <a href="classipc_1_1util_1_1Shared__name.html#a5bbfb4d3b378cf7b9a1bcaf5d6c5a067">More...</a><br /></td></tr>
<tr class="separator:a5bbfb4d3b378cf7b9a1bcaf5d6c5a067"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afc9b87fc69d42df3107bf4a27ea66c7c"><td class="memItemLeft" align="right" valign="top">static const size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classipc_1_1util_1_1Shared__name.html#afc9b87fc69d42df3107bf4a27ea66c7c">S_MAX_LENGTH</a> = 75</td></tr>
<tr class="memdesc:afc9b87fc69d42df3107bf4a27ea66c7c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Max value of <a class="el" href="classipc_1_1util_1_1Shared__name.html#af34db2934e116f8a4fdd403fd04695af" title="Returns str().size().">size()</a> such that, if <a class="el" href="classipc_1_1util_1_1Shared__name.html#ae89e1e061f87ffe0288514e254837595" title="Returns (sans copying) ref to immutable entire wrapped name string, suitable to pass into sys calls w...">str()</a> used to name a supported shared resource, sys call safely won't barf.  <a href="classipc_1_1util_1_1Shared__name.html#afc9b87fc69d42df3107bf4a27ea66c7c">More...</a><br /></td></tr>
<tr class="separator:afc9b87fc69d42df3107bf4a27ea66c7c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5c0910497c5ec484d3e42dfb0ccad48d"><td class="memItemLeft" align="right" valign="top">static const char&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classipc_1_1util_1_1Shared__name.html#a5c0910497c5ec484d3e42dfb0ccad48d">S_SEPARATOR</a> = '_'</td></tr>
<tr class="memdesc:a5c0910497c5ec484d3e42dfb0ccad48d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Character we use, by convention, to separate conceptual folders within <a class="el" href="classipc_1_1util_1_1Shared__name.html#ae89e1e061f87ffe0288514e254837595" title="Returns (sans copying) ref to immutable entire wrapped name string, suitable to pass into sys calls w...">str()</a>.  <a href="classipc_1_1util_1_1Shared__name.html#a5c0910497c5ec484d3e42dfb0ccad48d">More...</a><br /></td></tr>
<tr class="separator:a5c0910497c5ec484d3e42dfb0ccad48d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af08b45aa719d4f5dced595cca39ab2c8"><td class="memItemLeft" align="right" valign="top">static const <a class="el" href="classipc_1_1util_1_1Shared__name.html">Shared_name</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classipc_1_1util_1_1Shared__name.html#af08b45aa719d4f5dced595cca39ab2c8">S_ROOT_MAGIC</a> = <a class="el" href="classipc_1_1util_1_1Shared__name.html#a48f20b7b54490aa10dc64081d34c55b2">Shared_name::ct</a>(&quot;libipc&quot;)</td></tr>
<tr class="memdesc:af08b45aa719d4f5dced595cca39ab2c8"><td class="mdescLeft">&#160;</td><td class="mdescRight">A <a class="el" href="classipc_1_1util_1_1Shared__name.html" title="String-wrapping abstraction representing a name uniquely distinguishing a kernel-persistent entity fr...">Shared_name</a> fragment, with no <a class="el" href="classipc_1_1util_1_1Shared__name.html#a5c0910497c5ec484d3e42dfb0ccad48d" title="Character we use, by convention, to separate conceptual folders within str().">S_SEPARATOR</a> characters inside, to be used in any <a class="el" href="classipc_1_1util_1_1Shared__name.html" title="String-wrapping abstraction representing a name uniquely distinguishing a kernel-persistent entity fr...">Shared_name</a> maintained by <a class="el" href="namespaceipc.html" title="Catch-all namespace for the Flow-IPC project: A library/API in modern C++17 providing high-performanc...">ipc</a> itself as the leading path component.  <a href="classipc_1_1util_1_1Shared__name.html#af08b45aa719d4f5dced595cca39ab2c8">More...</a><br /></td></tr>
<tr class="separator:af08b45aa719d4f5dced595cca39ab2c8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a43205a00865429c1bef6c7896816bf5c"><td class="memItemLeft" align="right" valign="top">static const <a class="el" href="classipc_1_1util_1_1Shared__name.html">Shared_name</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classipc_1_1util_1_1Shared__name.html#a43205a00865429c1bef6c7896816bf5c">S_SENTINEL</a> = <a class="el" href="classipc_1_1util_1_1Shared__name.html#a48f20b7b54490aa10dc64081d34c55b2">Shared_name::ct</a>(&quot;0&quot;)</td></tr>
<tr class="memdesc:a43205a00865429c1bef6c7896816bf5c"><td class="mdescLeft">&#160;</td><td class="mdescRight">A <a class="el" href="classipc_1_1util_1_1Shared__name.html" title="String-wrapping abstraction representing a name uniquely distinguishing a kernel-persistent entity fr...">Shared_name</a> fragment, with no <a class="el" href="classipc_1_1util_1_1Shared__name.html#a5c0910497c5ec484d3e42dfb0ccad48d" title="Character we use, by convention, to separate conceptual folders within str().">S_SEPARATOR</a> characters inside, that represents a path component that shall be different from any other generated string at the same path depth in the same context; and represents a sentinel.  <a href="classipc_1_1util_1_1Shared__name.html#a43205a00865429c1bef6c7896816bf5c">More...</a><br /></td></tr>
<tr class="separator:a43205a00865429c1bef6c7896816bf5c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaa78ddb3efa5abe4fa80058dedbef68c"><td class="memItemLeft" align="right" valign="top">static const <a class="el" href="classipc_1_1util_1_1Shared__name.html">Shared_name</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classipc_1_1util_1_1Shared__name.html#aaa78ddb3efa5abe4fa80058dedbef68c">S_1ST_OR_ONLY</a> = <a class="el" href="classipc_1_1util_1_1Shared__name.html#a48f20b7b54490aa10dc64081d34c55b2">Shared_name::ct</a>(&quot;1&quot;)</td></tr>
<tr class="memdesc:aaa78ddb3efa5abe4fa80058dedbef68c"><td class="mdescLeft">&#160;</td><td class="mdescRight">A <a class="el" href="classipc_1_1util_1_1Shared__name.html" title="String-wrapping abstraction representing a name uniquely distinguishing a kernel-persistent entity fr...">Shared_name</a> fragment, with no <a class="el" href="classipc_1_1util_1_1Shared__name.html#a5c0910497c5ec484d3e42dfb0ccad48d" title="Character we use, by convention, to separate conceptual folders within str().">S_SEPARATOR</a> characters inside, that represents a path component that (1) is not <a class="el" href="classipc_1_1util_1_1Shared__name.html#a43205a00865429c1bef6c7896816bf5c" title="A Shared_name fragment, with no S_SEPARATOR characters inside, that represents a path component that ...">S_SENTINEL</a> and (2) is suggested as the <em>first</em> or <em>only</em> unique ID of items at the same depth in the same context.  <a href="classipc_1_1util_1_1Shared__name.html#aaa78ddb3efa5abe4fa80058dedbef68c">More...</a><br /></td></tr>
<tr class="separator:aaa78ddb3efa5abe4fa80058dedbef68c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4c294e23753eb706b4c297d99d24cd48"><td class="memItemLeft" align="right" valign="top">static const <a class="el" href="classipc_1_1util_1_1Shared__name.html">Shared_name</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classipc_1_1util_1_1Shared__name.html#a4c294e23753eb706b4c297d99d24cd48">S_RESOURCE_TYPE_ID_SHM</a> = <a class="el" href="classipc_1_1util_1_1Shared__name.html#a48f20b7b54490aa10dc64081d34c55b2">Shared_name::ct</a>(&quot;shm&quot;)</td></tr>
<tr class="memdesc:a4c294e23753eb706b4c297d99d24cd48"><td class="mdescLeft">&#160;</td><td class="mdescRight">Relative-folder fragment (no separators) identifying the resource type for: SHM pools.  <a href="classipc_1_1util_1_1Shared__name.html#a4c294e23753eb706b4c297d99d24cd48">More...</a><br /></td></tr>
<tr class="separator:a4c294e23753eb706b4c297d99d24cd48"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a50cb5d2ad8f8b4391e1885e7b8f63890"><td class="memItemLeft" align="right" valign="top">static const <a class="el" href="classipc_1_1util_1_1Shared__name.html">Shared_name</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classipc_1_1util_1_1Shared__name.html#a50cb5d2ad8f8b4391e1885e7b8f63890">S_RESOURCE_TYPE_ID_MUTEX</a> = <a class="el" href="classipc_1_1util_1_1Shared__name.html#a48f20b7b54490aa10dc64081d34c55b2">Shared_name::ct</a>(&quot;mtx&quot;)</td></tr>
<tr class="memdesc:a50cb5d2ad8f8b4391e1885e7b8f63890"><td class="mdescLeft">&#160;</td><td class="mdescRight">Relative-folder fragment (no separators) identifying the resource type for: boost.interprocess named mutex.  <a href="classipc_1_1util_1_1Shared__name.html#a50cb5d2ad8f8b4391e1885e7b8f63890">More...</a><br /></td></tr>
<tr class="separator:a50cb5d2ad8f8b4391e1885e7b8f63890"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pri-attribs" name="pri-attribs"></a>
Private Attributes</h2></td></tr>
<tr class="memitem:a4ebeee7fd046ca6ad405af6183dfb790"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classipc_1_1util_1_1Shared__name.html#a4ebeee7fd046ca6ad405af6183dfb790">m_raw_name</a></td></tr>
<tr class="memdesc:a4ebeee7fd046ca6ad405af6183dfb790"><td class="mdescLeft">&#160;</td><td class="mdescRight">The name or name fragment; see <a class="el" href="classipc_1_1util_1_1Shared__name.html#ae89e1e061f87ffe0288514e254837595" title="Returns (sans copying) ref to immutable entire wrapped name string, suitable to pass into sys calls w...">str()</a>.  <a href="classipc_1_1util_1_1Shared__name.html#a4ebeee7fd046ca6ad405af6183dfb790">More...</a><br /></td></tr>
<tr class="separator:a4ebeee7fd046ca6ad405af6183dfb790"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="friends" name="friends"></a>
Friends</h2></td></tr>
<tr class="memitem:a9ea22a64cfbc6de66181c278ff5f6975"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classipc_1_1util_1_1Shared__name.html#a9ea22a64cfbc6de66181c278ff5f6975">swap</a> (<a class="el" href="classipc_1_1util_1_1Shared__name.html">Shared_name</a> &amp;val1, <a class="el" href="classipc_1_1util_1_1Shared__name.html">Shared_name</a> &amp;val2)</td></tr>
<tr class="memdesc:a9ea22a64cfbc6de66181c278ff5f6975"><td class="mdescLeft">&#160;</td><td class="mdescRight">Swaps two objects.  <a href="classipc_1_1util_1_1Shared__name.html#a9ea22a64cfbc6de66181c278ff5f6975">More...</a><br /></td></tr>
<tr class="separator:a9ea22a64cfbc6de66181c278ff5f6975"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="related" name="related"></a>
Related Functions</h2></td></tr>
<tr><td class="ititle" colspan="2"><p >(Note that these are not member functions.) </p>
</td></tr>
<tr class="memitem:a15ea67c1855a678f7e948b24ccf2c1cd"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classipc_1_1util_1_1Shared__name.html">Shared_name</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classipc_1_1util_1_1Shared__name.html#a15ea67c1855a678f7e948b24ccf2c1cd">operator/</a> (const <a class="el" href="classipc_1_1util_1_1Shared__name.html">Shared_name</a> &amp;src1, const <a class="el" href="classipc_1_1util_1_1Shared__name.html">Shared_name</a> &amp;src2)</td></tr>
<tr class="memdesc:a15ea67c1855a678f7e948b24ccf2c1cd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns new object equal to <code>Shared_name(src1) /= src2</code>.  <a href="classipc_1_1util_1_1Shared__name.html#a15ea67c1855a678f7e948b24ccf2c1cd">More...</a><br /></td></tr>
<tr class="separator:a15ea67c1855a678f7e948b24ccf2c1cd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a910207a2da57b61cee4a22899e239dc2"><td class="memTemplParams" colspan="2">template&lt;typename Source &gt; </td></tr>
<tr class="memitem:a910207a2da57b61cee4a22899e239dc2"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classipc_1_1util_1_1Shared__name.html">Shared_name</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classipc_1_1util_1_1Shared__name.html#a910207a2da57b61cee4a22899e239dc2">operator/</a> (const <a class="el" href="classipc_1_1util_1_1Shared__name.html">Shared_name</a> &amp;src1, const Source &amp;raw_src2)</td></tr>
<tr class="memdesc:a910207a2da57b61cee4a22899e239dc2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns new object equal to <code>Shared_name(src1) /= raw_src2</code>.  <a href="classipc_1_1util_1_1Shared__name.html#a910207a2da57b61cee4a22899e239dc2">More...</a><br /></td></tr>
<tr class="separator:a910207a2da57b61cee4a22899e239dc2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa61c6b31c5c4e241c97f06a4d38c76c4"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classipc_1_1util_1_1Shared__name.html">Shared_name</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classipc_1_1util_1_1Shared__name.html#aa61c6b31c5c4e241c97f06a4d38c76c4">operator/</a> (const <a class="el" href="classipc_1_1util_1_1Shared__name.html">Shared_name</a> &amp;src1, const char *raw_src2)</td></tr>
<tr class="memdesc:aa61c6b31c5c4e241c97f06a4d38c76c4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns new object equal to <code>Shared_name(src1) /= raw_src2</code>.  <a href="classipc_1_1util_1_1Shared__name.html#aa61c6b31c5c4e241c97f06a4d38c76c4">More...</a><br /></td></tr>
<tr class="separator:aa61c6b31c5c4e241c97f06a4d38c76c4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a462b81d34ba23c968f63d9805fa74538"><td class="memTemplParams" colspan="2">template&lt;typename Source &gt; </td></tr>
<tr class="memitem:a462b81d34ba23c968f63d9805fa74538"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classipc_1_1util_1_1Shared__name.html">Shared_name</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classipc_1_1util_1_1Shared__name.html#a462b81d34ba23c968f63d9805fa74538">operator/</a> (const Source &amp;raw_src1, const <a class="el" href="classipc_1_1util_1_1Shared__name.html">Shared_name</a> &amp;src2)</td></tr>
<tr class="memdesc:a462b81d34ba23c968f63d9805fa74538"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns new object equal to <code>Shared_name(raw_src1) /= src2</code>.  <a href="classipc_1_1util_1_1Shared__name.html#a462b81d34ba23c968f63d9805fa74538">More...</a><br /></td></tr>
<tr class="separator:a462b81d34ba23c968f63d9805fa74538"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7f2bead5935309c2f760645fe46ddd71"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classipc_1_1util_1_1Shared__name.html">Shared_name</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classipc_1_1util_1_1Shared__name.html#a7f2bead5935309c2f760645fe46ddd71">operator/</a> (const char *raw_src1, const <a class="el" href="classipc_1_1util_1_1Shared__name.html">Shared_name</a> &amp;src2)</td></tr>
<tr class="memdesc:a7f2bead5935309c2f760645fe46ddd71"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns new object equal to <code>Shared_name(raw_src1) /= src2</code>.  <a href="classipc_1_1util_1_1Shared__name.html#a7f2bead5935309c2f760645fe46ddd71">More...</a><br /></td></tr>
<tr class="separator:a7f2bead5935309c2f760645fe46ddd71"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a54dc5077333284fda9e8d2df8b0e9b91"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classipc_1_1util_1_1Shared__name.html">Shared_name</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classipc_1_1util_1_1Shared__name.html#a54dc5077333284fda9e8d2df8b0e9b91">operator+</a> (const <a class="el" href="classipc_1_1util_1_1Shared__name.html">Shared_name</a> &amp;src1, const <a class="el" href="classipc_1_1util_1_1Shared__name.html">Shared_name</a> &amp;src2)</td></tr>
<tr class="memdesc:a54dc5077333284fda9e8d2df8b0e9b91"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns new object equal to <code>Shared_name(src1) += src2</code>.  <a href="classipc_1_1util_1_1Shared__name.html#a54dc5077333284fda9e8d2df8b0e9b91">More...</a><br /></td></tr>
<tr class="separator:a54dc5077333284fda9e8d2df8b0e9b91"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a52b2ba03d5ace7389991bb5d31b9fa59"><td class="memTemplParams" colspan="2">template&lt;typename Source &gt; </td></tr>
<tr class="memitem:a52b2ba03d5ace7389991bb5d31b9fa59"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classipc_1_1util_1_1Shared__name.html">Shared_name</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classipc_1_1util_1_1Shared__name.html#a52b2ba03d5ace7389991bb5d31b9fa59">operator+</a> (const <a class="el" href="classipc_1_1util_1_1Shared__name.html">Shared_name</a> &amp;src1, const Source &amp;raw_src2)</td></tr>
<tr class="memdesc:a52b2ba03d5ace7389991bb5d31b9fa59"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns new object equal to <code>Shared_name(src1) += raw_src2</code>.  <a href="classipc_1_1util_1_1Shared__name.html#a52b2ba03d5ace7389991bb5d31b9fa59">More...</a><br /></td></tr>
<tr class="separator:a52b2ba03d5ace7389991bb5d31b9fa59"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af61b02fd66b67aeed5a803ca47e52973"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classipc_1_1util_1_1Shared__name.html">Shared_name</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classipc_1_1util_1_1Shared__name.html#af61b02fd66b67aeed5a803ca47e52973">operator+</a> (const <a class="el" href="classipc_1_1util_1_1Shared__name.html">Shared_name</a> &amp;src1, const char *raw_src2)</td></tr>
<tr class="memdesc:af61b02fd66b67aeed5a803ca47e52973"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns new object equal to <code>Shared_name(src1) += raw_src2</code>.  <a href="classipc_1_1util_1_1Shared__name.html#af61b02fd66b67aeed5a803ca47e52973">More...</a><br /></td></tr>
<tr class="separator:af61b02fd66b67aeed5a803ca47e52973"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1f1a40877cc08b287f8f3c7e7f663782"><td class="memTemplParams" colspan="2">template&lt;typename Source &gt; </td></tr>
<tr class="memitem:a1f1a40877cc08b287f8f3c7e7f663782"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classipc_1_1util_1_1Shared__name.html">Shared_name</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classipc_1_1util_1_1Shared__name.html#a1f1a40877cc08b287f8f3c7e7f663782">operator+</a> (const Source &amp;raw_src1, const <a class="el" href="classipc_1_1util_1_1Shared__name.html">Shared_name</a> &amp;src2)</td></tr>
<tr class="memdesc:a1f1a40877cc08b287f8f3c7e7f663782"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns new object equal to <code>Shared_name(src2)</code> with <code>raw_src1</code> pre-pended to it.  <a href="classipc_1_1util_1_1Shared__name.html#a1f1a40877cc08b287f8f3c7e7f663782">More...</a><br /></td></tr>
<tr class="separator:a1f1a40877cc08b287f8f3c7e7f663782"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a096c71dede7bd5528215ac01a380a189"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classipc_1_1util_1_1Shared__name.html">Shared_name</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classipc_1_1util_1_1Shared__name.html#a096c71dede7bd5528215ac01a380a189">operator+</a> (const char *raw_src1, const <a class="el" href="classipc_1_1util_1_1Shared__name.html">Shared_name</a> &amp;src2)</td></tr>
<tr class="memdesc:a096c71dede7bd5528215ac01a380a189"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns new object equal to <code>Shared_name(src2)</code> with <code>raw_src1</code> pre-pended to it.  <a href="classipc_1_1util_1_1Shared__name.html#a096c71dede7bd5528215ac01a380a189">More...</a><br /></td></tr>
<tr class="separator:a096c71dede7bd5528215ac01a380a189"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af7728c93fdf29479bbb2482e02f05cbf"><td class="memItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classipc_1_1util_1_1Shared__name.html#af7728c93fdf29479bbb2482e02f05cbf">operator&lt;&lt;</a> (std::ostream &amp;os, const <a class="el" href="classipc_1_1util_1_1Shared__name.html">Shared_name</a> &amp;val)</td></tr>
<tr class="memdesc:af7728c93fdf29479bbb2482e02f05cbf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Prints embellished string representation of the given <a class="el" href="classipc_1_1util_1_1Shared__name.html" title="String-wrapping abstraction representing a name uniquely distinguishing a kernel-persistent entity fr...">Shared_name</a> to the given <code>ostream</code>.  <a href="classipc_1_1util_1_1Shared__name.html#af7728c93fdf29479bbb2482e02f05cbf">More...</a><br /></td></tr>
<tr class="separator:af7728c93fdf29479bbb2482e02f05cbf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adfd8805e0d37556102cad7b191fee9a3"><td class="memItemLeft" align="right" valign="top">std::istream &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classipc_1_1util_1_1Shared__name.html#adfd8805e0d37556102cad7b191fee9a3">operator&gt;&gt;</a> (std::istream &amp;is, <a class="el" href="classipc_1_1util_1_1Shared__name.html">Shared_name</a> &amp;val)</td></tr>
<tr class="memdesc:adfd8805e0d37556102cad7b191fee9a3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reads <a class="el" href="classipc_1_1util_1_1Shared__name.html" title="String-wrapping abstraction representing a name uniquely distinguishing a kernel-persistent entity fr...">Shared_name</a> from the given <code>istream</code>; equivalent to reading <code>string</code> into <a class="el" href="classipc_1_1util_1_1Shared__name.html#ae89e1e061f87ffe0288514e254837595" title="Returns (sans copying) ref to immutable entire wrapped name string, suitable to pass into sys calls w...">Shared_name::str()</a>.  <a href="classipc_1_1util_1_1Shared__name.html#adfd8805e0d37556102cad7b191fee9a3">More...</a><br /></td></tr>
<tr class="separator:adfd8805e0d37556102cad7b191fee9a3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aba4ae811264cbb7e664ce126b591cbc7"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classipc_1_1util_1_1Shared__name.html#aba4ae811264cbb7e664ce126b591cbc7">hash_value</a> (const <a class="el" href="classipc_1_1util_1_1Shared__name.html">Shared_name</a> &amp;val)</td></tr>
<tr class="memdesc:aba4ae811264cbb7e664ce126b591cbc7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Hasher of <a class="el" href="classipc_1_1util_1_1Shared__name.html" title="String-wrapping abstraction representing a name uniquely distinguishing a kernel-persistent entity fr...">Shared_name</a> for boost.unordered et al.  <a href="classipc_1_1util_1_1Shared__name.html#aba4ae811264cbb7e664ce126b591cbc7">More...</a><br /></td></tr>
<tr class="separator:aba4ae811264cbb7e664ce126b591cbc7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9ea22a64cfbc6de66181c278ff5f6975"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classipc_1_1util_1_1Shared__name.html#a9ea22a64cfbc6de66181c278ff5f6975">swap</a> (<a class="el" href="classipc_1_1util_1_1Shared__name.html">Shared_name</a> &amp;val1, <a class="el" href="classipc_1_1util_1_1Shared__name.html">Shared_name</a> &amp;val2)</td></tr>
<tr class="memdesc:a9ea22a64cfbc6de66181c278ff5f6975"><td class="mdescLeft">&#160;</td><td class="mdescRight">Swaps two objects.  <a href="classipc_1_1util_1_1Shared__name.html#a9ea22a64cfbc6de66181c278ff5f6975">More...</a><br /></td></tr>
<tr class="separator:a9ea22a64cfbc6de66181c278ff5f6975"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p >String-wrapping abstraction representing a name uniquely distinguishing a kernel-persistent entity from all others in the system, or a fragment of such a name. </p>
<p >Conceptually it relates to <code>std::string</code> similarly to how <code>filesystem::path</code> does.</p>
<p >This is a very simple class in terms of what logic it actually adds: it encapsulates an <code>std::string</code> and allows for, basically, string operations like concatenation, with some syntactic sugar added for a simple <em>folder</em> convention. However, the design <em>context</em> (namely, how shared resources are named and why) is less trivial, and this doc header is a good place to get into those topics as well. Hence, we first cover practical aspects, with the architectural context referenced only as needed. Then, below that, there's an architecture discussion about naming in general.</p>
<h3>Construction/assignment from and conversion to strings/similar</h3>
<p >Interanally it stores an <code>std::string</code>.</p>
<p >Conversion: That <code>string</code> is accessible by <code>const&amp;</code> via <a class="el" href="classipc_1_1util_1_1Shared__name.html#ae89e1e061f87ffe0288514e254837595" title="Returns (sans copying) ref to immutable entire wrapped name string, suitable to pass into sys calls w...">str()</a> and similarly the NUL-terminated <a class="el" href="classipc_1_1util_1_1Shared__name.html#a0bccc73c9c5b4f3b784a1e57cdc5c910" title="Returns (sans copying) pointer to NUL-terminated wrapped name string, suitable to pass into sys calls...">native_str()</a>. Also there is an <code>ostream&lt;&lt;</code> printer; do note it does not simply print <a class="el" href="classipc_1_1util_1_1Shared__name.html#ae89e1e061f87ffe0288514e254837595" title="Returns (sans copying) ref to immutable entire wrapped name string, suitable to pass into sys calls w...">str()</a> but rather a beautified version. (<code>ostream&gt;&gt;</code> input is also provided but is identical to <code>ostream &gt;&gt; string</code>.)</p>
<p >Construction/assignment: It comes with standard default/copy/move ctors and assignment. There is also a constructor that takes two iterators-to-<code>char</code> (including 2 <code>const char*</code>). However, construction from <code>string</code> (including destuctive move-construction), <a class="el" href="namespaceipc_1_1util.html#ae6ac47812a90d1287c61e0b7de7bc4f5" title="Short-hand for Flow&#39;s String_view.">util::String_view</a>, NUL-terminated <code>const char*</code>, <code>vector&lt;char&gt;</code> (etc.) is available exclusively in the form of <code>static</code> quasi-ctors <a class="el" href="classipc_1_1util_1_1Shared__name.html#a48f20b7b54490aa10dc64081d34c55b2" title="Copy-constructs from a char-sequence container (including string, util::String_view,...">ct()</a>. Lastly: To assign please use move ctor: <code>existing_sh_name = Shared_name::ct(src)</code>.</p>
<p >Rationale: C++ ADL semantics cause a ton of super-annoying problems &ndash; especially inside <a class="el" href="namespaceipc_1_1transport.html" title="Flow-IPC module providing transmission of structured messages and/or low-level blobs (and more) betwe...">ipc::transport</a> namespace itself &ndash; where compilers will auto-convert, e.g., a <code>string</code> to <code><a class="el" href="classipc_1_1util_1_1Shared__name.html" title="String-wrapping abstraction representing a name uniquely distinguishing a kernel-persistent entity fr...">Shared_name</a></code> without being asked to do so at all. For example, one sees <code>operator &lt;&lt; string</code> output the <code>string</code> in "beautified" form, because a <code><a class="el" href="classipc_1_1util_1_1Shared__name.html" title="String-wrapping abstraction representing a name uniquely distinguishing a kernel-persistent entity fr...">Shared_name</a></code> is constructed implicitly and then printed via its <code>&lt;&lt;</code>. I (ygoldfel), then, took a cue from boost.asio's IP address classes which use <code>static</code> quasi-ctors to avoid any such issues. (The alternative was to fine-tune the ctor set a-la <code>filesystem::path</code>, with conversion traits and all kinds of craziness.)</p>
<h3>Practical <a class="el" href="classipc_1_1util_1_1Shared__name.html" title="String-wrapping abstraction representing a name uniquely distinguishing a kernel-persistent entity fr...">Shared_name</a> matters</h3>
<p >A <em>shared resource</em> in this context is some entity (such as a SHM-mapped addressable area; or a POSIX message queue) that can be <em>opened</em> for further access by potentially 2+ processes simultaneously. When opening (at least), the shared resource is referred to &ndash; in the associated opening sys call or similar &ndash; by a string name, and the name works equally from those 2+ processes. <a class="el" href="classipc_1_1util_1_1Shared__name.html" title="String-wrapping abstraction representing a name uniquely distinguishing a kernel-persistent entity fr...">Shared_name</a> stores such a string. It is also suitable for <em>fragments</em> of these names, including prefixes, suffixes, or middle parts. Therefore &ndash; much like <code>boost::filesystem::path</code> is basically a string wrapper &ndash; <a class="el" href="classipc_1_1util_1_1Shared__name.html" title="String-wrapping abstraction representing a name uniquely distinguishing a kernel-persistent entity fr...">Shared_name</a> is just a string wrapper. In fact the <code>std::string</code> it stores is accessible through <a class="el" href="classipc_1_1util_1_1Shared__name.html#ae89e1e061f87ffe0288514e254837595" title="Returns (sans copying) ref to immutable entire wrapped name string, suitable to pass into sys calls w...">str()</a> by reference.</p>
<p >All standard string-like operations (generally, the <code>+=</code>, <code>/=</code>, <code>+</code>, and <code>/</code> operations) are equally performant and not <em>any</em> smarter than the corresponding string concatenation ops (the <code>/</code> variants just add a separator character). The same holds for all operations, except see the next section. In particular, all characters are allowed in any position, and there is no max length enforced. Hence, the user may assume max possible performance and zero restrictions, with the exception of:</p>
<h3>Conventions understood/enforced by <a class="el" href="classipc_1_1util_1_1Shared__name.html" title="String-wrapping abstraction representing a name uniquely distinguishing a kernel-persistent entity fr...">Shared_name</a></h3>
<p >As noted, generally the class allows everything and does nothing smart that <code>std::string</code> wouldn't do. This is for flexibility and performance and is inspired by <code>boost::filesystem::path</code>. However, there is <em>optional</em> support for some simple conventions. First let's discuss those conventions:</p>
<p >In Flow-IPC, <a class="el" href="classipc_1_1util_1_1Shared__name.html" title="String-wrapping abstraction representing a name uniquely distinguishing a kernel-persistent entity fr...">Shared_name</a> is to be used for all shared resource <em>types</em> needed. (These are not enumerated here.) Different resource types might have different rules for (1) characters allowed; and (2) max length allowed; so that if this is violated, a creation/opening sys call (or similar) will fail with an error. Therefore, the following <em>conventions</em> are understood and represent the <em>union</em> of known system restrictions, so that <a class="el" href="classipc_1_1util_1_1Shared__name.html#a03d90faae35392c8bbdd22f056755ba9" title="Returns true if and only if the contained name/fragment is sanitized according to length,...">sanitized()</a> names will work for <em>all</em> known resource types. Also, some conventions are for human usability. In total, these conventions are understood:</p><ul>
<li>Only certain characters are allowed. Namely, only alphanumerics [A-Za-z0-9] are allowed as of this writing.</li>
<li>There is a <em>folder</em> convention: We anticipate a file tree-like organization of various items; hence a folder separator character, <a class="el" href="classipc_1_1util_1_1Shared__name.html#a5c0910497c5ec484d3e42dfb0ccad48d" title="Character we use, by convention, to separate conceptual folders within str().">S_SEPARATOR</a>, is allowed also.<ul>
<li>A complete, usable (in a sys call or similar) name is to start with one leading <a class="el" href="classipc_1_1util_1_1Shared__name.html#a5c0910497c5ec484d3e42dfb0ccad48d" title="Character we use, by convention, to separate conceptual folders within str().">S_SEPARATOR</a>.</li>
<li>We anticipate no empty "folder" names; and therefore no sequences of 2+ adjacent <a class="el" href="classipc_1_1util_1_1Shared__name.html#a5c0910497c5ec484d3e42dfb0ccad48d" title="Character we use, by convention, to separate conceptual folders within str().">S_SEPARATOR</a> chars.</li>
</ul>
</li>
<li>Names shall not exceed a certain max length. <a class="el" href="classipc_1_1util_1_1Shared__name.html#afc9b87fc69d42df3107bf4a27ea66c7c" title="Max value of size() such that, if str() used to name a supported shared resource, sys call safely won...">S_MAX_LENGTH</a> is chosen to be low enough to work for all supported resource types.</li>
</ul>
<p >How does <a class="el" href="classipc_1_1util_1_1Shared__name.html" title="String-wrapping abstraction representing a name uniquely distinguishing a kernel-persistent entity fr...">Shared_name</a> actually <em>use</em> the knowledge of these conventions? To reiterate: normally, it does not care. The only parts of its API that <em>do</em> care are as follows:</p><ul>
<li><a class="el" href="classipc_1_1util_1_1Shared__name.html#ab1934f80515fdbc3e2a59ccda32fff9a" title="Returns true if and only if the first character is S_SEPARATOR.">absolute()</a> will return <code>true</code> if and only if the first char is <a class="el" href="classipc_1_1util_1_1Shared__name.html#a5c0910497c5ec484d3e42dfb0ccad48d" title="Character we use, by convention, to separate conceptual folders within str().">S_SEPARATOR</a>. By convention, you should not pass <a class="el" href="classipc_1_1util_1_1Shared__name.html#ae89e1e061f87ffe0288514e254837595" title="Returns (sans copying) ref to immutable entire wrapped name string, suitable to pass into sys calls w...">str()</a> to a sys call/similar, unless <code><a class="el" href="classipc_1_1util_1_1Shared__name.html#ab1934f80515fdbc3e2a59ccda32fff9a" title="Returns true if and only if the first character is S_SEPARATOR.">absolute()</a> == true</code>.</li>
<li><a class="el" href="classipc_1_1util_1_1Shared__name.html#a03d90faae35392c8bbdd22f056755ba9" title="Returns true if and only if the contained name/fragment is sanitized according to length,...">sanitized()</a> will return <code>true</code> if and only if <a class="el" href="classipc_1_1util_1_1Shared__name.html#ae89e1e061f87ffe0288514e254837595" title="Returns (sans copying) ref to immutable entire wrapped name string, suitable to pass into sys calls w...">str()</a> is a valid name or name fragment (no illegal characters; does not exceed <a class="el" href="classipc_1_1util_1_1Shared__name.html#afc9b87fc69d42df3107bf4a27ea66c7c" title="Max value of size() such that, if str() used to name a supported shared resource, sys call safely won...">S_MAX_LENGTH</a>; no multi-separator sequences).</li>
<li><a class="el" href="classipc_1_1util_1_1Shared__name.html#add4ed045e03f786427a236a5dfa5a1b0" title="Best-effort attempt to turn sanitized() from false to true, unless it is already true; returns the fi...">sanitize()</a> will attempt to non-destructively modify (if needed) name in such a way as to make <a class="el" href="classipc_1_1util_1_1Shared__name.html#a03d90faae35392c8bbdd22f056755ba9" title="Returns true if and only if the contained name/fragment is sanitized according to length,...">sanitized()</a> return <code>true</code>. You should call them only when you specifically need some conventions checked or enforced. Otherwise <a class="el" href="classipc_1_1util_1_1Shared__name.html" title="String-wrapping abstraction representing a name uniquely distinguishing a kernel-persistent entity fr...">Shared_name</a> ops will be as dumb/fast as possible.</li>
</ul>
<dl class="section note"><dt>Note</dt><dd>The Flow-IPC library <em>user</em> is unlikely to directly pass a <a class="el" href="classipc_1_1util_1_1Shared__name.html" title="String-wrapping abstraction representing a name uniquely distinguishing a kernel-persistent entity fr...">Shared_name</a> into a sys call or similar. Probably Flow-IPC internals will do it for the user. Therefore, the likeliest pattern for the user to encounter in public Flow-IPC APIs is: When initially naming some <code>transport</code> object, a constructor or factory will take a <em>relative</em> (<code><a class="el" href="classipc_1_1util_1_1Shared__name.html#ab1934f80515fdbc3e2a59ccda32fff9a" title="Returns true if and only if the first character is S_SEPARATOR.">absolute()</a> == false</code>) <a class="el" href="classipc_1_1util_1_1Shared__name.html" title="String-wrapping abstraction representing a name uniquely distinguishing a kernel-persistent entity fr...">Shared_name</a> prepared by the user. Within that relative fragment, the user is to use the folder conventions above (via <code>/=</code> or <code>/</code> operators perhaps) if needed. Inside Flow-IPC, the impl can then construct an absolute name by internally pre-pending stuff to the user-constructed fragment. If you have ensured the name is <a class="el" href="classipc_1_1util_1_1Shared__name.html#a03d90faae35392c8bbdd22f056755ba9" title="Returns true if and only if the contained name/fragment is sanitized according to length,...">sanitized()</a>, then it will not fail on account of a bad name. If you have <em>not</em>, then it may still not fail: <a class="el" href="classipc_1_1util_1_1Shared__name.html#a03d90faae35392c8bbdd22f056755ba9" title="Returns true if and only if the contained name/fragment is sanitized according to length,...">sanitized()</a> is a conservative criterion and may be too stringent for some resource types and OS calls. It is up to <em>you</em> to either ensure <a class="el" href="classipc_1_1util_1_1Shared__name.html#a03d90faae35392c8bbdd22f056755ba9" title="Returns true if and only if the contained name/fragment is sanitized according to length,...">sanitized()</a> or otherwise worry about the possibility of a bad name (illegal characters, excessive length).</dd></dl>
<h3>Thread safety</h3>
<p ><a class="el" href="classipc_1_1util_1_1Shared__name.html" title="String-wrapping abstraction representing a name uniquely distinguishing a kernel-persistent entity fr...">Shared_name</a> has the same safety under concurrency as <code>std::string</code> (i.e., if you intend on writing while reading/writing same <code>*this</code> concurrently, synchronized access is necessary to avoid corruption and other standard thread safety violations).</p>
<h3>Architecture discussion / shared name convention synopsis</h3>
<p >As promised, we've covered the practical aspects of <a class="el" href="classipc_1_1util_1_1Shared__name.html" title="String-wrapping abstraction representing a name uniquely distinguishing a kernel-persistent entity fr...">Shared_name</a> first. Now let's discuss the larger design. Note that while this does inform some of <a class="el" href="classipc_1_1util_1_1Shared__name.html" title="String-wrapping abstraction representing a name uniquely distinguishing a kernel-persistent entity fr...">Shared_name</a> API (which is quite simple), really the discussion has wider implications, and this doc header merely seems like a good place for it. It would've been okay to split off much of the below info into <a class="el" href="namespaceipc_1_1session.html" title="Flow-IPC module providing the broad lifecycle and shared-resource organization  via the session conc...">ipc::session</a> somewhere, but... maybe that's better... but the human in me (ygoldfel) feels you'll want to know this now, here, even though for formal appropriateness maybe it should be moved. In any case here it is:</p>
<p >As noted before, there are N shared resource types, and <a class="el" href="classipc_1_1util_1_1Shared__name.html" title="String-wrapping abstraction representing a name uniquely distinguishing a kernel-persistent entity fr...">Shared_name</a> is to be used for all of them. At minimum, then:</p><ul>
<li>2 names are to be equal if and only if they refer to the same object of the same type, or they're 2 different objects but of <em>different</em> types.</li>
<li>This must be the case at each given point in time.</li>
</ul>
<p >When designing Flow-IPC, we decided that if would be helpful for humans if we immediately made this more stringent by enforcing the following stronger requirement as well:</p><ul>
<li>2 names are to be equal if and only if they are referring to objects of the same (resource) type. So then, e.g., if a SHM-area is named "X" then a POSIX queue cannot also be named "X" at the same point in time.</li>
</ul>
<p >Further, some things are made easier if the distinctness restriction (2 distinct names &lt;=&gt; 2 distinct objects at each given point in time) is made more stringent by extending it to <em>all time</em>; resulting in:</p><ul>
<li>2 names are to be equal if and only if they refer to the same object of the same type.</li>
<li>This must be the case over all time (not merely a each <em>given</em> point in time).<ul>
<li>In other words, if a name "X" is used for some object of some type, then it's only <em>ever</em> used for that object and never another (until reboot).</li>
</ul>
</li>
</ul>
<dl class="section note"><dt>Note</dt><dd>Shared resources are assumed to be <em>kernel-persistent</em>, which means the slate is wiped with each system boot. Hence "all time" really means "within the relevant uptime."</dd></dl>
<p>Practically speaking, then, how do we enable these distinctness guarantees, in absolute names (i.e., names to be passed, usually internally by Flow-IPC, into sys calls/similar)? Firstly, the resource type for the object referred to by each absolute name should be encoded in a standard prefix inside the name; a simple distinct constant for each resource type works. There should be a handful at most of these possible values. This will guarantee non-clashing between different types of resource.</p>
<p >That only leaves the distinct-across-all-time requirement. However, it's outside the scope of this header to explain how that's achieved, as it involves <a class="el" href="namespaceipc_1_1session.html" title="Flow-IPC module providing the broad lifecycle and shared-resource organization  via the session conc...">ipc::session</a> and other concepts and is just a large topic.</p>
<p >For convenience, we now summarize the resulting absolute shared name convention, as of this writing, without a full rationale and with references to other doc headers if appropriate. In order, the characters of a shared name in the Flow-IPC convention are as follows. Use <a class="el" href="namespaceipc_1_1session.html#a365d2d63f77b738e67e206af6b702634" title="Builds an absolute name according to the path convention explained in Shared_name class doc header; t...">session::build_conventional_shared_name()</a> to construct a path with these semantics.</p>
<ol type="1">
<li>Leading <a class="el" href="classipc_1_1util_1_1Shared__name.html#a5c0910497c5ec484d3e42dfb0ccad48d" title="Character we use, by convention, to separate conceptual folders within str().">S_SEPARATOR</a>. Indicates a full (absolute) name or prefix thereof.</li>
<li>A certain constant magic string, <a class="el" href="classipc_1_1util_1_1Shared__name.html#af08b45aa719d4f5dced595cca39ab2c8" title="A Shared_name fragment, with no S_SEPARATOR characters inside, to be used in any Shared_name maintain...">S_ROOT_MAGIC</a>, indicating <a class="el" href="namespaceipc.html" title="Catch-all namespace for the Flow-IPC project: A library/API in modern C++17 providing high-performanc...">ipc</a> is operating. (E.g., if... uh... emacs likes to put stuff in, say, SHM, at a certain SHM path, hopefully it won't clash with us accidentally.)</li>
<li>A <a class="el" href="classipc_1_1util_1_1Shared__name.html#a5c0910497c5ec484d3e42dfb0ccad48d" title="Character we use, by convention, to separate conceptual folders within str().">S_SEPARATOR</a>.</li>
<li>Hard-coded resource type constant. Indicates resource type. E.g., something like "posixq" might mean a POSIX message queue. The (quite few) possible values for this are stored internally in Flow-IPC.</li>
<li>A <a class="el" href="classipc_1_1util_1_1Shared__name.html#a5c0910497c5ec484d3e42dfb0ccad48d" title="Character we use, by convention, to separate conceptual folders within str().">S_SEPARATOR</a>.</li>
<li>Session-server application name. This brief name is 1-1 with all distinct executables supported by Flow-IPC. See <a class="el" href="namespaceipc_1_1session.html" title="Flow-IPC module providing the broad lifecycle and shared-resource organization  via the session conc...">ipc::session</a> for details.</li>
<li>A <a class="el" href="classipc_1_1util_1_1Shared__name.html#a5c0910497c5ec484d3e42dfb0ccad48d" title="Character we use, by convention, to separate conceptual folders within str().">S_SEPARATOR</a>.</li>
<li>Server-namespace. This uniquely identifies the server application <em>instance</em> across all time, for a given session-server application name. See <a class="el" href="namespaceipc_1_1session.html" title="Flow-IPC module providing the broad lifecycle and shared-resource organization  via the session conc...">ipc::session</a> for how this value is computed. In the rare case where the resource applies to <em>all</em> server-namespaces, use special value <a class="el" href="classipc_1_1util_1_1Shared__name.html#a43205a00865429c1bef6c7896816bf5c" title="A Shared_name fragment, with no S_SEPARATOR characters inside, that represents a path component that ...">S_SENTINEL</a>.</li>
<li>A <a class="el" href="classipc_1_1util_1_1Shared__name.html#a5c0910497c5ec484d3e42dfb0ccad48d" title="Character we use, by convention, to separate conceptual folders within str().">S_SEPARATOR</a>.</li>
<li>What comes next depends on the <em>scope</em> of this particular resource.<ul>
<li>Relevant to a given session A-B (where A and B are processes that can converse with each other), a/k/a <em>per-session scope</em>:<ol type="a">
<li>Session-client application name. Analogous to session-server application name but for the supported clients. See <a class="el" href="namespaceipc_1_1session.html" title="Flow-IPC module providing the broad lifecycle and shared-resource organization  via the session conc...">ipc::session</a> for details.</li>
<li>A <a class="el" href="classipc_1_1util_1_1Shared__name.html#a5c0910497c5ec484d3e42dfb0ccad48d" title="Character we use, by convention, to separate conceptual folders within str().">S_SEPARATOR</a>.</li>
<li>Client-namespace. Given everything up to this point, uniquely identifies client application <em>instance</em> across all time (like server-namespace above, basically). See <a class="el" href="namespaceipc_1_1session.html" title="Flow-IPC module providing the broad lifecycle and shared-resource organization  via the session conc...">ipc::session</a> for how it's computed.</li>
</ol>
</li>
<li>Relevant to no particular process pair A-B, but does apply only to a given session-client application, a/k/a <em>per-client-app scope</em>:<ol type="a">
<li>Session-client application name, as just above.</li>
<li>A <a class="el" href="classipc_1_1util_1_1Shared__name.html#a5c0910497c5ec484d3e42dfb0ccad48d" title="Character we use, by convention, to separate conceptual folders within str().">S_SEPARATOR</a>.</li>
<li>The reserved client-namespace, <a class="el" href="classipc_1_1util_1_1Shared__name.html#a43205a00865429c1bef6c7896816bf5c" title="A Shared_name fragment, with no S_SEPARATOR characters inside, that represents a path component that ...">S_SENTINEL</a>, indicating no particular session-client.</li>
</ol>
</li>
<li>Global (not limited to any smaller scope above), a/k/a <em>global scope</em>. This is intended largely for internal Flow-IPC needs, as of this writing.<ol type="a">
<li>The reserved session-client application name, <a class="el" href="classipc_1_1util_1_1Shared__name.html#a43205a00865429c1bef6c7896816bf5c" title="A Shared_name fragment, with no S_SEPARATOR characters inside, that represents a path component that ...">S_SENTINEL</a>, indicating no particular client application.</li>
</ol>
</li>
</ul>
</li>
<li>A <a class="el" href="classipc_1_1util_1_1Shared__name.html#a5c0910497c5ec484d3e42dfb0ccad48d" title="Character we use, by convention, to separate conceptual folders within str().">S_SEPARATOR</a>.</li>
<li>The rest of the name depends on the convention decided for that particular resource type and hence outside our scope here; see doc header for the relevant class corresponding to a shared resource type of interest.<ul>
<li>For each object, determine the <em>scope</em> (the 3 possibilities and resulting naming conventions are just above).</li>
<li>Keep using the basic folder convention, with non-empty folder names and <a class="el" href="classipc_1_1util_1_1Shared__name.html#a5c0910497c5ec484d3e42dfb0ccad48d" title="Character we use, by convention, to separate conceptual folders within str().">S_SEPARATOR</a> as separator.</li>
<li>When uniqueness is desired, the <code>1</code>-&gt;<code>2</code>-&gt;<code>3</code>... technique is typically used (always remembering that such an auto-ID must be safely generated across all participating processes in system).</li>
</ul>
</li>
</ol>
<p >In rare cases a <a class="el" href="classipc_1_1util_1_1Shared__name.html" title="String-wrapping abstraction representing a name uniquely distinguishing a kernel-persistent entity fr...">Shared_name</a> will be used outside the <a class="el" href="namespaceipc_1_1session.html" title="Flow-IPC module providing the broad lifecycle and shared-resource organization  via the session conc...">ipc::session</a> paradigm, such as for a lower-level purpose that nevertheless requires a shared-resource name (e.g., for a lower-level-use SHM pool). In that case the following shall be equal to <a class="el" href="classipc_1_1util_1_1Shared__name.html#a43205a00865429c1bef6c7896816bf5c" title="A Shared_name fragment, with no S_SEPARATOR characters inside, that represents a path component that ...">S_SENTINEL</a>: session-server application name; server-namespace. The components subsequent to that shall be as-if it's a global-scope resource; hence: <a class="el" href="classipc_1_1util_1_1Shared__name.html#a43205a00865429c1bef6c7896816bf5c" title="A Shared_name fragment, with no S_SEPARATOR characters inside, that represents a path component that ...">S_SENTINEL</a>. build_conventional_non_session_based_share_name() shall construct such a name.</p>
<dl class="section note"><dt>Note</dt><dd><em>camelCase</em>: As of this writing, <a class="el" href="classipc_1_1util_1_1Shared__name.html#a5c0910497c5ec484d3e42dfb0ccad48d" title="Character we use, by convention, to separate conceptual folders within str().">S_SEPARATOR</a> is <code>_</code> (because <code>/</code> is not available for native reasons). So, when it comes up, the convention is to use camelCase for tokens between nearby separators. Briefly: start with lower case; do not word-smoosh; each new word after word 1 is to begin with exactly 1 capital or number; an acronym is to be treated as a single word. Examples of compliant tokens: <code>httpUrlConnectionV44Beta</code>, <code>tableIdent</code>. These are bad: <code>httpURLConnection</code> (wrong acronym convention), <code>HTTPURLConnection</code> (ditto), <code>tableident</code> (word-smooshing).</dd></dl>
<h3>Rationale for max length handling</h3>
<p >As noted in the public section of this doc header: <a class="el" href="classipc_1_1util_1_1Shared__name.html#afc9b87fc69d42df3107bf4a27ea66c7c" title="Max value of size() such that, if str() used to name a supported shared resource, sys call safely won...">S_MAX_LENGTH</a> is a part of <a class="el" href="classipc_1_1util_1_1Shared__name.html#a03d90faae35392c8bbdd22f056755ba9" title="Returns true if and only if the contained name/fragment is sanitized according to length,...">sanitized()</a> criteria; it is not enforced by <a class="el" href="classipc_1_1util_1_1Shared__name.html" title="String-wrapping abstraction representing a name uniquely distinguishing a kernel-persistent entity fr...">Shared_name</a> itself outside of <a class="el" href="classipc_1_1util_1_1Shared__name.html#a03d90faae35392c8bbdd22f056755ba9" title="Returns true if and only if the contained name/fragment is sanitized according to length,...">sanitized()</a> and <a class="el" href="classipc_1_1util_1_1Shared__name.html#add4ed045e03f786427a236a5dfa5a1b0" title="Best-effort attempt to turn sanitized() from false to true, unless it is already true; returns the fi...">sanitize()</a>. It is up to the <a class="el" href="classipc_1_1util_1_1Shared__name.html" title="String-wrapping abstraction representing a name uniquely distinguishing a kernel-persistent entity fr...">Shared_name</a> user (which may, and usually is, internal Flow-IPC code) to actually ensure <a class="el" href="classipc_1_1util_1_1Shared__name.html#a03d90faae35392c8bbdd22f056755ba9" title="Returns true if and only if the contained name/fragment is sanitized according to length,...">sanitized()</a> is <code>true</code> &ndash; or otherwise avoid system API errors on account of bad names. All <em>we</em> choose to do, regarding the length aspect, is choose one conservatively low so that:</p><ul>
<li>At least it is no greater than the <em>lowest</em> inherent limit out of all the known resource types to which <a class="el" href="classipc_1_1util_1_1Shared__name.html" title="String-wrapping abstraction representing a name uniquely distinguishing a kernel-persistent entity fr...">Shared_name</a> apply.</li>
<li>Additionally, because in many cases a given <code>public</code> API takes a relative <a class="el" href="classipc_1_1util_1_1Shared__name.html" title="String-wrapping abstraction representing a name uniquely distinguishing a kernel-persistent entity fr...">Shared_name</a> and pre-pends an absolute "folder" path of known length, further leave slack to make it so that that prefix can still comfortably fit without hitting the limit from the previous bullet point.</li>
</ul>
<p >To wit, then, current tally of relevant resource types:</p><ul>
<li>POSIX message queue (<code>man mq_overview</code>): Linux: An internal forward-slash, included in <code>NAME_MAX = 255</code> characters including NUL; so apparently: 253. (The <code>man</code> text could be interpreted as meaning 253, 254, 255; it is ambiguous. Experiments show it's 253.)</li>
<li>SHM pool (ultimately: <code>man shm_open</code>): Linux: Same as preceding: 253.</li>
<li>bipc message queue (search: boost.interprocess <code>message_queue</code>): It just opens a SHM pool per MQ; so same as preceding: 253.</li>
<li>Unix domain sockets (ultimately: <code>man unix</code>): Linux, abstract namespace: It's a hairy topic. <code>sun_path[108]</code> is the case as of this writing; minus 1 leading and trailing NUL; and there's a note some (non-Linux?) Unix domain socket implementations go as low as <code>sun_path[92]</code>. But in Linux: 106.</li>
</ul>
<p >So that puts us at 107 without the "prefix slack." Applying a prefix slack of 32 characters gives us: 107 - 32 = 75. </p>

<p class="definition">Definition at line <a class="el" href="shared__name_8hpp_source.html#l00241">241</a> of file <a class="el" href="shared__name_8hpp_source.html">shared_name.hpp</a>.</p>
</div><h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="a1e9cad5a94d78e1180a9e77877009873" name="a1e9cad5a94d78e1180a9e77877009873"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1e9cad5a94d78e1180a9e77877009873">&#9670;&nbsp;</a></span>Shared_name() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">ipc::util::Shared_name::Shared_name </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classipc_1_1util_1_1Shared__name.html">Shared_name</a> &amp;&#160;</td>
          <td class="paramname"><em>src</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">default</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Copy-constructs from an existing <a class="el" href="classipc_1_1util_1_1Shared__name.html" title="String-wrapping abstraction representing a name uniquely distinguishing a kernel-persistent entity fr...">Shared_name</a>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">src</td><td>Source object. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a79995ab36be778bb2a56eeba80a7abed" name="a79995ab36be778bb2a56eeba80a7abed"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a79995ab36be778bb2a56eeba80a7abed">&#9670;&nbsp;</a></span>Shared_name() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">ipc::util::Shared_name::Shared_name </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classipc_1_1util_1_1Shared__name.html">Shared_name</a> &amp;&amp;&#160;</td>
          <td class="paramname"><em>src_moved</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">default</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Move-constructs from an existing <a class="el" href="classipc_1_1util_1_1Shared__name.html" title="String-wrapping abstraction representing a name uniquely distinguishing a kernel-persistent entity fr...">Shared_name</a>, which is made <a class="el" href="classipc_1_1util_1_1Shared__name.html#a861ea6c9ad6672e83bab5c7747b66f7b" title="Returns true if and only if str().empty() == true.">empty()</a> if not already so. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">src_moved</td><td>Source object, which is potentially modified. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a766b98e1a87f4035b6869c78f331c69a" name="a766b98e1a87f4035b6869c78f331c69a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a766b98e1a87f4035b6869c78f331c69a">&#9670;&nbsp;</a></span>Shared_name() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Input_it &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">ipc::util::Shared_name::Shared_name </td>
          <td>(</td>
          <td class="paramtype">Input_it&#160;</td>
          <td class="paramname"><em>begin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Input_it&#160;</td>
          <td class="paramname"><em>end</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">explicit</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Copy-constructs from a <code>char</code> range given as a pair of random-iterators; in particular <code>const char*</code>s work. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Input_it</td><td>An STL-compliant random iterator type. In particular <code>const char*</code> works. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">begin</td><td>Start of range to copy. </td></tr>
    <tr><td class="paramname">end</td><td>One past last element in range to copy (<code>begin</code> to copy nothing). </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="shared__name_8hpp_source.html#l00667">667</a> of file <a class="el" href="shared__name_8hpp_source.html">shared_name.hpp</a>.</p>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="ab1934f80515fdbc3e2a59ccda32fff9a" name="ab1934f80515fdbc3e2a59ccda32fff9a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab1934f80515fdbc3e2a59ccda32fff9a">&#9670;&nbsp;</a></span>absolute()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool ipc::util::Shared_name::absolute </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns <code>true</code> if and only if the first character is <a class="el" href="classipc_1_1util_1_1Shared__name.html#a5c0910497c5ec484d3e42dfb0ccad48d" title="Character we use, by convention, to separate conceptual folders within str().">S_SEPARATOR</a>. </p>
<p >By Flow-IPC convention, any name actually passed to a sys call in order to name a shared resource has <code><a class="el" href="classipc_1_1util_1_1Shared__name.html#ab1934f80515fdbc3e2a59ccda32fff9a" title="Returns true if and only if the first character is S_SEPARATOR.">absolute()</a> == true</code>. Note, however, that <a class="el" href="classipc_1_1util_1_1Shared__name.html#ab1934f80515fdbc3e2a59ccda32fff9a" title="Returns true if and only if the first character is S_SEPARATOR.">absolute()</a> being <code>true</code> does not necessarily mean <a class="el" href="classipc_1_1util_1_1Shared__name.html#ae89e1e061f87ffe0288514e254837595" title="Returns (sans copying) ref to immutable entire wrapped name string, suitable to pass into sys calls w...">str()</a> is the full name of a resource: it may well still be a fragment (a prefix) of some eventual name passed to a sys call. To obtain the full name one would append more stuff.</p>
<dl class="section return"><dt>Returns</dt><dd>See above. </dd></dl>

<p class="definition">Definition at line <a class="el" href="shared__name_8cpp_source.html#l00165">165</a> of file <a class="el" href="shared__name_8cpp_source.html">shared_name.cpp</a>.</p>

<p class="reference">References <a class="el" href="shared__name_8hpp_source.html#l00659">m_raw_name</a>, and <a class="el" href="shared__name_8hpp_source.html#l00266">S_SEPARATOR</a>.</p>

<p class="reference">Referenced by <a class="el" href="blob__stream__mq__impl_8hpp_source.html#l00344">ipc::transport::Blob_stream_mq_base_impl&lt; Persistent_mq_handle &gt;::mq_sentinel_name()</a>.</p>
<div class="dynheader">
Here is the caller graph for this function:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="classipc_1_1util_1_1Shared__name_ab1934f80515fdbc3e2a59ccda32fff9a_icgraph.svg" width="352" height="59"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe>
</div>
</div>

</div>
</div>
<a id="a8328c9a6bc2739145087515ee8e677d8" name="a8328c9a6bc2739145087515ee8e677d8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8328c9a6bc2739145087515ee8e677d8">&#9670;&nbsp;</a></span>clear()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ipc::util::Shared_name::clear </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Makes it so <code><a class="el" href="classipc_1_1util_1_1Shared__name.html#a861ea6c9ad6672e83bab5c7747b66f7b" title="Returns true if and only if str().empty() == true.">empty()</a> == true</code>. </p>

<p class="definition">Definition at line <a class="el" href="shared__name_8cpp_source.html#l00170">170</a> of file <a class="el" href="shared__name_8cpp_source.html">shared_name.cpp</a>.</p>

<p class="reference">References <a class="el" href="shared__name_8hpp_source.html#l00659">m_raw_name</a>.</p>

<p class="reference">Referenced by <a class="el" href="posix__mq__handle_8cpp_source.html#l00525">ipc::transport::Posix_mq_handle::operator=()</a>.</p>
<div class="dynheader">
Here is the caller graph for this function:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="classipc_1_1util_1_1Shared__name_a8328c9a6bc2739145087515ee8e677d8_icgraph.svg" width="550" height="59"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe>
</div>
</div>

</div>
</div>
<a id="a66f531c6fa407739fa81b12034351874" name="a66f531c6fa407739fa81b12034351874"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a66f531c6fa407739fa81b12034351874">&#9670;&nbsp;</a></span>ct() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classipc_1_1util_1_1Shared__name.html">Shared_name</a> ipc::util::Shared_name::ct </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>src</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Copy-constructs from a NUL-terminated <code>const char*</code> string. </p>
<h3>Rationale</h3>
<p >See class doc header for rationale as-to why this is a <code>static</code> ctor as opposed to a regular ctor.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Source</td><td>See above. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">src</td><td>String to copy. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The new object. </dd></dl>

<p class="definition">Definition at line <a class="el" href="shared__name_8cpp_source.html#l00052">52</a> of file <a class="el" href="shared__name_8cpp_source.html">shared_name.cpp</a>.</p>

<p class="reference">References <a class="el" href="shared__name_8hpp_source.html#l00659">m_raw_name</a>.</p>

</div>
</div>
<a id="a48f20b7b54490aa10dc64081d34c55b2" name="a48f20b7b54490aa10dc64081d34c55b2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a48f20b7b54490aa10dc64081d34c55b2">&#9670;&nbsp;</a></span>ct() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Source &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classipc_1_1util_1_1Shared__name.html">Shared_name</a> ipc::util::Shared_name::ct </td>
          <td>(</td>
          <td class="paramtype">const Source &amp;&#160;</td>
          <td class="paramname"><em>src</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Copy-constructs from a <code>char</code>-sequence container (including <code>string</code>, <a class="el" href="namespaceipc_1_1util.html#ae6ac47812a90d1287c61e0b7de7bc4f5" title="Short-hand for Flow&#39;s String_view.">util::String_view</a>, <code>vector&lt;char&gt;</code>). </p>
<p >This overload shall be used on a non-<code>&amp;&amp;</code> arg if <code><a class="el" href="classipc_1_1util_1_1Shared__name.html#a66f531c6fa407739fa81b12034351874" title="Copy-constructs from a NUL-terminated const char* string.">ct(const char*)</a></code> does not apply.</p>
<p >Specifically the returned object's internal <code>std::string</code> is constructed as: <code>std::string s(raw_name)</code>. As a result, whatever most-performant available single-arg ctor <code>basic_string</code> makes available is forwarded-to. (E.g., C++17 has a <code>String_view_like</code> ctor which is overload-resolved-to only when it most makes sense.)</p>
<h3>Rationale</h3>
<p >See class doc header for rationale as-to why this is a <code>static</code> ctor as opposed to a regular ctor.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Source</td><td>See above. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">src</td><td>String to copy. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The new object. </dd></dl>

<p class="definition">Definition at line <a class="el" href="shared__name_8hpp_source.html#l00674">674</a> of file <a class="el" href="shared__name_8hpp_source.html">shared_name.hpp</a>.</p>

<p class="reference">References <a class="el" href="shared__name_8hpp_source.html#l00659">m_raw_name</a>.</p>

<p class="reference">Referenced by <a class="el" href="session__server__impl_8hpp_source.html#l00746">ipc::session::Session_server_impl&lt; Session_server_t, Server_session_t &gt;::async_accept()</a>, <a class="el" href="ipc__shm_2src_2ipc_2session_2detail_2shm_2classic_2server__session__impl_8hpp_source.html#l00207">ipc::session::shm::classic::Server_session_impl&lt; S_MQ_TYPE_OR_NONE, S_TRANSMIT_NATIVE_HANDLES, Mdt_payload &gt;::async_accept_log_in()</a>, <a class="el" href="ipc__session_2src_2ipc_2session_2detail_2client__session__impl_8hpp_source.html#l01127">ipc::session::Client_session_impl&lt; S_MQ_TYPE_OR_NONE, S_TRANSMIT_NATIVE_HANDLES, Mdt_payload, S_SHM_TYPE_OR_NONE, S_GRACEFUL_FINISH_REQUIRED_V &gt;::async_connect()</a>, <a class="el" href="ipc__shm_2src_2ipc_2session_2detail_2shm_2classic_2client__session__impl_8hpp_source.html#l00175">ipc::session::shm::classic::Client_session_impl&lt; S_MQ_TYPE_OR_NONE, S_TRANSMIT_NATIVE_HANDLES, Mdt_payload &gt;::async_connect()</a>, <a class="el" href="session__base_8hpp_source.html#l00953">ipc::session::Session_base&lt; S_MQ_TYPE_OR_NONE, S_TRANSMIT_NATIVE_HANDLES, Mdt_payload &gt;::cur_ns_store_mutex_absolute_name()</a>, <a class="el" href="ipc__session_2src_2ipc_2session_2detail_2session__shared__name_8cpp_source.html#l00114">ipc::session::decompose_conventional_shared_name()</a>, <a class="el" href="util_8hpp_source.html#l00090">ipc::util::for_each_persistent_impl()</a>, <a class="el" href="ipc__shm_2src_2ipc_2session_2shm_2classic_2session__server_8hpp_source.html#l00531">ipc::session::shm::classic::Session_server&lt; S_MQ_TYPE_OR_NONE, S_TRANSMIT_NATIVE_HANDLES, Mdt_payload &gt;::init_app_shm_as_needed()</a>, <a class="el" href="ipc__shm__arena__lend_2src_2ipc_2session_2shm_2arena__lend_2jemalloc_2session__server_8hpp_source.html#l00397">ipc::session::shm::arena_lend::jemalloc::Session_server&lt; S_MQ_TYPE_OR_NONE, S_TRANSMIT_NATIVE_HANDLES, Mdt_payload &gt;::init_app_shm_as_needed()</a>, <a class="el" href="arena__lend_2src_2ipc_2session_2detail_2shm_2arena__lend_2jemalloc_2session__impl_8hpp_source.html#l00270">ipc::session::shm::arena_lend::jemalloc::Session_impl&lt; Session_impl_t &gt;::init_shm()</a>, <a class="el" href="ipc__session_2src_2ipc_2session_2detail_2server__session__impl_8hpp_source.html#l01485">ipc::session::Server_session_impl&lt; S_MQ_TYPE_OR_NONE, S_TRANSMIT_NATIVE_HANDLES, Mdt_payload, S_SHM_TYPE_OR_NONE, S_SHM_MAX_HNDL_SZ, S_GRACEFUL_FINISH_REQUIRED_V &gt;::make_channel_mqs()</a>, <a class="el" href="ipc__session_2src_2ipc_2session_2detail_2client__session__impl_8hpp_source.html#l01771">ipc::session::Client_session_impl&lt; S_MQ_TYPE_OR_NONE, S_TRANSMIT_NATIVE_HANDLES, Mdt_payload, S_SHM_TYPE_OR_NONE, S_GRACEFUL_FINISH_REQUIRED_V &gt;::on_master_channel_init_open_channel()</a>, <a class="el" href="ipc__session_2src_2ipc_2session_2detail_2client__session__impl_8hpp_source.html#l01528">ipc::session::Client_session_impl&lt; S_MQ_TYPE_OR_NONE, S_TRANSMIT_NATIVE_HANDLES, Mdt_payload, S_SHM_TYPE_OR_NONE, S_GRACEFUL_FINISH_REQUIRED_V &gt;::on_master_channel_log_in_rsp()</a>, <a class="el" href="ipc__session_2src_2ipc_2session_2detail_2client__session__impl_8hpp_source.html#l02279">ipc::session::Client_session_impl&lt; S_MQ_TYPE_OR_NONE, S_TRANSMIT_NATIVE_HANDLES, Mdt_payload, S_SHM_TYPE_OR_NONE, S_GRACEFUL_FINISH_REQUIRED_V &gt;::on_master_channel_open_channel_req()</a>, <a class="el" href="ipc__session_2src_2ipc_2session_2detail_2client__session__impl_8hpp_source.html#l02105">ipc::session::Client_session_impl&lt; S_MQ_TYPE_OR_NONE, S_TRANSMIT_NATIVE_HANDLES, Mdt_payload, S_SHM_TYPE_OR_NONE, S_GRACEFUL_FINISH_REQUIRED_V &gt;::open_channel()</a>, <a class="el" href="shared__name_8hpp_source.html#l00716">operator+()</a>, <a class="el" href="shared__name_8hpp_source.html#l00732">operator/()</a>, <a class="el" href="shared__name_8cpp_source.html#l00364">operator&gt;&gt;()</a>, <a class="el" href="session__base_8hpp_source.html#l00999">ipc::session::Session_base&lt; S_MQ_TYPE_OR_NONE, S_TRANSMIT_NATIVE_HANDLES, Mdt_payload &gt;::session_master_socket_stream_acceptor_absolute_name()</a>, and <a class="el" href="session__server__impl_8hpp_source.html#l00438">ipc::session::Session_server_impl&lt; Session_server_t, Server_session_t &gt;::Session_server_impl()</a>.</p>
<div class="dynheader">
Here is the caller graph for this function:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="classipc_1_1util_1_1Shared__name_a48f20b7b54490aa10dc64081d34c55b2_icgraph.svg" width="838" height="1386"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe>
</div>
</div>

</div>
</div>
<a id="a925d30aa9b3391651303de04f82d4949" name="a925d30aa9b3391651303de04f82d4949"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a925d30aa9b3391651303de04f82d4949">&#9670;&nbsp;</a></span>ct() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classipc_1_1util_1_1Shared__name.html">Shared_name</a> ipc::util::Shared_name::ct </td>
          <td>(</td>
          <td class="paramtype">std::string &amp;&amp;&#160;</td>
          <td class="paramname"><em>src_moved</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Destructively move-constructs from an <code>std::string</code>, emptying that source object. </p>
<h3>Rationale</h3>
<p >See class doc header for rationale as-to why this is a <code>static</code> ctor as opposed to a regular ctor.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">src_moved</td><td>String to move (make-<code>.<a class="el" href="classipc_1_1util_1_1Shared__name.html#a861ea6c9ad6672e83bab5c7747b66f7b" title="Returns true if and only if str().empty() == true.">empty()</a></code>). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The new object. </dd></dl>

<p class="definition">Definition at line <a class="el" href="shared__name_8cpp_source.html#l00059">59</a> of file <a class="el" href="shared__name_8cpp_source.html">shared_name.cpp</a>.</p>

<p class="reference">References <a class="el" href="shared__name_8hpp_source.html#l00659">m_raw_name</a>.</p>

</div>
</div>
<a id="a861ea6c9ad6672e83bab5c7747b66f7b" name="a861ea6c9ad6672e83bab5c7747b66f7b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a861ea6c9ad6672e83bab5c7747b66f7b">&#9670;&nbsp;</a></span>empty()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool ipc::util::Shared_name::empty </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns <code>true</code> if and only if <code><a class="el" href="classipc_1_1util_1_1Shared__name.html#ae89e1e061f87ffe0288514e254837595" title="Returns (sans copying) ref to immutable entire wrapped name string, suitable to pass into sys calls w...">str()</a>.<a class="el" href="classipc_1_1util_1_1Shared__name.html#a861ea6c9ad6672e83bab5c7747b66f7b" title="Returns true if and only if str().empty() == true.">empty()</a> == true</code>. </p>
<dl class="section return"><dt>Returns</dt><dd>See above. </dd></dl>

<p class="definition">Definition at line <a class="el" href="shared__name_8cpp_source.html#l00155">155</a> of file <a class="el" href="shared__name_8cpp_source.html">shared_name.cpp</a>.</p>

<p class="reference">References <a class="el" href="shared__name_8hpp_source.html#l00659">m_raw_name</a>.</p>

<p class="reference">Referenced by <a class="el" href="shared__name_8cpp_source.html#l00337">ipc::util::build_conventional_non_session_based_shared_name()</a>, <a class="el" href="ipc__session_2src_2ipc_2session_2detail_2session__shared__name_8cpp_source.html#l00044">ipc::session::build_conventional_shared_name()</a>, <a class="el" href="ipc__session_2src_2ipc_2session_2detail_2session__shared__name_8cpp_source.html#l00093">ipc::session::build_conventional_shared_name_prefix()</a>, <a class="el" href="ipc__session_2src_2ipc_2session_2detail_2client__session__impl_8hpp_source.html#l02397">ipc::session::Client_session_impl&lt; S_MQ_TYPE_OR_NONE, S_TRANSMIT_NATIVE_HANDLES, Mdt_payload, S_SHM_TYPE_OR_NONE, S_GRACEFUL_FINISH_REQUIRED_V &gt;::create_channel_obj()</a>, <a class="el" href="shared__name_8cpp_source.html#l00160">has_trailing_separator()</a>, <a class="el" href="arena__lend_2src_2ipc_2session_2detail_2shm_2arena__lend_2jemalloc_2session__impl_8hpp_source.html#l00270">ipc::session::shm::arena_lend::jemalloc::Session_impl&lt; Session_impl_t &gt;::init_shm()</a>, <a class="el" href="ipc__session_2src_2ipc_2session_2detail_2server__session__impl_8hpp_source.html#l01244">ipc::session::Server_session_impl&lt; S_MQ_TYPE_OR_NONE, S_TRANSMIT_NATIVE_HANDLES, Mdt_payload, S_SHM_TYPE_OR_NONE, S_SHM_MAX_HNDL_SZ, S_GRACEFUL_FINISH_REQUIRED_V &gt;::on_master_channel_open_channel_req()</a>, and <a class="el" href="shared__name_8cpp_source.html#l00221">sanitize()</a>.</p>
<div class="dynheader">
Here is the caller graph for this function:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="classipc_1_1util_1_1Shared__name_a861ea6c9ad6672e83bab5c7747b66f7b_icgraph.svg" width="1115" height="743"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe>
</div>
</div>

</div>
</div>
<a id="a774e872b51100b728e0780b39f563ed9" name="a774e872b51100b728e0780b39f563ed9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a774e872b51100b728e0780b39f563ed9">&#9670;&nbsp;</a></span>has_trailing_separator()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool ipc::util::Shared_name::has_trailing_separator </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns <code>true</code> if and only if <code>!this-&gt;<a class="el" href="classipc_1_1util_1_1Shared__name.html#a861ea6c9ad6672e83bab5c7747b66f7b" title="Returns true if and only if str().empty() == true.">empty()</a></code>, and <a class="el" href="classipc_1_1util_1_1Shared__name.html#ae89e1e061f87ffe0288514e254837595" title="Returns (sans copying) ref to immutable entire wrapped name string, suitable to pass into sys calls w...">str()</a> ends with the <a class="el" href="classipc_1_1util_1_1Shared__name.html#a5c0910497c5ec484d3e42dfb0ccad48d" title="Character we use, by convention, to separate conceptual folders within str().">S_SEPARATOR</a> character. </p>
<dl class="section return"><dt>Returns</dt><dd>See above. </dd></dl>

<p class="definition">Definition at line <a class="el" href="shared__name_8cpp_source.html#l00160">160</a> of file <a class="el" href="shared__name_8cpp_source.html">shared_name.cpp</a>.</p>

<p class="reference">References <a class="el" href="shared__name_8cpp_source.html#l00155">empty()</a>, <a class="el" href="shared__name_8hpp_source.html#l00659">m_raw_name</a>, and <a class="el" href="shared__name_8hpp_source.html#l00266">S_SEPARATOR</a>.</p>
<div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="classipc_1_1util_1_1Shared__name_a774e872b51100b728e0780b39f563ed9_cgraph.svg" width="356" height="47"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe>
</div>
</div>

</div>
</div>
<a id="a0bccc73c9c5b4f3b784a1e57cdc5c910" name="a0bccc73c9c5b4f3b784a1e57cdc5c910"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0bccc73c9c5b4f3b784a1e57cdc5c910">&#9670;&nbsp;</a></span>native_str()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const char * ipc::util::Shared_name::native_str </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns (sans copying) pointer to NUL-terminated wrapped name string, suitable to pass into sys calls when naming supported shared resources assuming <code><a class="el" href="classipc_1_1util_1_1Shared__name.html#ab1934f80515fdbc3e2a59ccda32fff9a" title="Returns true if and only if the first character is S_SEPARATOR.">absolute()</a> == true</code>. </p>
<p >If you require an <code>std::string</code> (such as for some fancy boost.interprocess call) See also <a class="el" href="classipc_1_1util_1_1Shared__name.html#ae89e1e061f87ffe0288514e254837595" title="Returns (sans copying) ref to immutable entire wrapped name string, suitable to pass into sys calls w...">str()</a>.</p>
<h3>Why isn't it named <code>c_str()</code>?</h3>
<p >It was, but <code>capnp::StringPtr</code> (and similar/derived classes such as <code>capnp::Text::Reader</code>) has a "clever" <code>operator T()</code> conversion operator that is enabled for all <code>T</code> that have <code>.c_str()</code>; and its implementation relies on being able to symmetrically construct <code>T(const char*)</code> &ndash; like <code>std::string</code>. We intentionally lack that. Hence renamed this away from <code>.c_str()</code>. This may appear like kow-towing to capnp's quirks, but actually conceivably that's a pattern people use, so let's not break it.</p>
<dl class="section return"><dt>Returns</dt><dd>See above. </dd></dl>

<p class="definition">Definition at line <a class="el" href="shared__name_8cpp_source.html#l00145">145</a> of file <a class="el" href="shared__name_8cpp_source.html">shared_name.cpp</a>.</p>

<p class="reference">References <a class="el" href="shared__name_8hpp_source.html#l00659">m_raw_name</a>.</p>

<p class="reference">Referenced by <a class="el" href="pool__arena_8cpp_source.html#l00030">ipc::shm::classic::Pool_arena::Pool_arena()</a>, <a class="el" href="bipc__mq__handle_8cpp_source.html#l00913">ipc::transport::Bipc_mq_handle::remove_persistent()</a>, and <a class="el" href="ipc__core_2src_2ipc_2util_2detail_2util_8cpp_source.html#l00119">ipc::util::remove_persistent_shm_pool()</a>.</p>
<div class="dynheader">
Here is the caller graph for this function:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="classipc_1_1util_1_1Shared__name_a0bccc73c9c5b4f3b784a1e57cdc5c910_icgraph.svg" width="912" height="282"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe>
</div>
</div>

</div>
</div>
<a id="a6f3d1055ef0e6d166a9f4532758d36de" name="a6f3d1055ef0e6d166a9f4532758d36de"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6f3d1055ef0e6d166a9f4532758d36de">&#9670;&nbsp;</a></span>operator+=() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classipc_1_1util_1_1Shared__name.html">Shared_name</a> &amp; ipc::util::Shared_name::operator+= </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>raw_name_to_append</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Similar to the overload that takes <code>const Source&amp;</code>, but takes NUL-terminated string instead. </p>
<p >See that doc header.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">raw_name_to_append</td><td>Thing to append. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>*this</code>. </dd></dl>

<p class="definition">Definition at line <a class="el" href="shared__name_8cpp_source.html#l00069">69</a> of file <a class="el" href="shared__name_8cpp_source.html">shared_name.cpp</a>.</p>

<p class="reference">References <a class="el" href="shared__name_8hpp_source.html#l00659">m_raw_name</a>.</p>

</div>
</div>
<a id="a1bcac1c10e01ba11dcc437b3c32bbe6c" name="a1bcac1c10e01ba11dcc437b3c32bbe6c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1bcac1c10e01ba11dcc437b3c32bbe6c">&#9670;&nbsp;</a></span>operator+=() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classipc_1_1util_1_1Shared__name.html">Shared_name</a> &amp; ipc::util::Shared_name::operator+= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classipc_1_1util_1_1Shared__name.html">Shared_name</a> &amp;&#160;</td>
          <td class="paramname"><em>src_to_append</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Appends the given other <a class="el" href="classipc_1_1util_1_1Shared__name.html" title="String-wrapping abstraction representing a name uniquely distinguishing a kernel-persistent entity fr...">Shared_name</a>. </p>
<p >Functionally equivalent to <code>return *this += src_to_append.str());</code>. If there's any reason to suspect the resulting name might be too long, execute <a class="el" href="classipc_1_1util_1_1Shared__name.html#add4ed045e03f786427a236a5dfa5a1b0" title="Best-effort attempt to turn sanitized() from false to true, unless it is already true; returns the fi...">sanitize()</a> afterwards and ensure that returns <code>true</code>.</p>
<p >It is stylistically (and possibly for performance) better to use <code>/=</code> rather than manually appending a separator and then <code>src_to_append</code> (with this <code>+=</code>).</p>
<p >See Rationale(s) for <a class="el" href="classipc_1_1util_1_1Shared__name.html#a956fdac1bb4cfab414b30091bec43f70" title="Appends a folder separator followed by the given other Shared_name.">operator/=()</a>, as they apply here.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">src_to_append</td><td>Thing to append. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>*this</code>. </dd></dl>

<p class="definition">Definition at line <a class="el" href="shared__name_8cpp_source.html#l00077">77</a> of file <a class="el" href="shared__name_8cpp_source.html">shared_name.cpp</a>.</p>

<p class="reference">References <a class="el" href="shared__name_8cpp_source.html#l00077">operator+=()</a>, and <a class="el" href="shared__name_8cpp_source.html#l00140">str()</a>.</p>

<p class="reference">Referenced by <a class="el" href="shared__name_8cpp_source.html#l00077">operator+=()</a>, and <a class="el" href="shared__name_8hpp_source.html#l00696">operator/=()</a>.</p>
<div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="classipc_1_1util_1_1Shared__name_a1bcac1c10e01ba11dcc437b3c32bbe6c_cgraph.svg" width="374" height="71"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe>
</div>
</div>
<div class="dynheader">
Here is the caller graph for this function:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="classipc_1_1util_1_1Shared__name_a1bcac1c10e01ba11dcc437b3c32bbe6c_icgraph.svg" width="352" height="71"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe>
</div>
</div>

</div>
</div>
<a id="ae168cc42213bf7972d17bbbc1e16f2a2" name="ae168cc42213bf7972d17bbbc1e16f2a2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae168cc42213bf7972d17bbbc1e16f2a2">&#9670;&nbsp;</a></span>operator+=() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Source &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classipc_1_1util_1_1Shared__name.html">Shared_name</a> &amp; ipc::util::Shared_name::operator+= </td>
          <td>(</td>
          <td class="paramtype">const Source &amp;&#160;</td>
          <td class="paramname"><em>raw_name_to_append</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Simply appends <code>raw_name_to_append</code> to the current value of <a class="el" href="classipc_1_1util_1_1Shared__name.html#ae89e1e061f87ffe0288514e254837595" title="Returns (sans copying) ref to immutable entire wrapped name string, suitable to pass into sys calls w...">str()</a>. </p>
<p >Specifically the internal <code>std::string</code> is modified as: <code>s += raw_name_to_append</code>. As a result, whatever most-performant available (single-arg by definition) <code>operator+=</code> that <code>basic_string</code> makes available is forwarded-to. (E.g., C++17 has a <code>String_view_like</code> appender which is overload-resolved-to only when it most makes sense.)</p>
<p >If there's any reason to suspect the resulting name might be too long, execute <a class="el" href="classipc_1_1util_1_1Shared__name.html#add4ed045e03f786427a236a5dfa5a1b0" title="Best-effort attempt to turn sanitized() from false to true, unless it is already true; returns the fi...">sanitize()</a> afterwards and ensure that returns <code>true</code>.</p>
<p >It is stylistically (and possibly for performance) better to use <code>/=</code> rather than manually appending a separator and then <code>src_to_append</code> (with this <code>+=</code>).</p>
<p >See Rationale(s) for <a class="el" href="classipc_1_1util_1_1Shared__name.html#a956fdac1bb4cfab414b30091bec43f70" title="Appends a folder separator followed by the given other Shared_name.">operator/=()</a>, as they apply here.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Source</td><td>See above. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">raw_name_to_append</td><td>Thing to append. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>*this</code>. </dd></dl>

<p class="definition">Definition at line <a class="el" href="shared__name_8hpp_source.html#l00687">687</a> of file <a class="el" href="shared__name_8hpp_source.html">shared_name.hpp</a>.</p>

<p class="reference">References <a class="el" href="shared__name_8hpp_source.html#l00659">m_raw_name</a>.</p>

</div>
</div>
<a id="a99c77008fb2c507e32e05272812c4782" name="a99c77008fb2c507e32e05272812c4782"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a99c77008fb2c507e32e05272812c4782">&#9670;&nbsp;</a></span>operator/=() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classipc_1_1util_1_1Shared__name.html">Shared_name</a> &amp; ipc::util::Shared_name::operator/= </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>raw_name_to_append</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Similar to the overload that takes <code>const Source&amp;</code>, but takes NUL-terminated string instead. </p>
<p >See that doc header.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">raw_name_to_append</td><td>Thing to append after appending separator. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>*this</code>. </dd></dl>

<p class="definition">Definition at line <a class="el" href="shared__name_8cpp_source.html#l00083">83</a> of file <a class="el" href="shared__name_8cpp_source.html">shared_name.cpp</a>.</p>

<p class="reference">References <a class="el" href="shared__name_8cpp_source.html#l00091">operator/=()</a>.</p>
<div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="classipc_1_1util_1_1Shared__name_a99c77008fb2c507e32e05272812c4782_cgraph.svg" width="568" height="71"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe>
</div>
</div>

</div>
</div>
<a id="a956fdac1bb4cfab414b30091bec43f70" name="a956fdac1bb4cfab414b30091bec43f70"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a956fdac1bb4cfab414b30091bec43f70">&#9670;&nbsp;</a></span>operator/=() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classipc_1_1util_1_1Shared__name.html">Shared_name</a> &amp; ipc::util::Shared_name::operator/= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classipc_1_1util_1_1Shared__name.html">Shared_name</a> &amp;&#160;</td>
          <td class="paramname"><em>src_to_append</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Appends a folder separator followed by the given other <a class="el" href="classipc_1_1util_1_1Shared__name.html" title="String-wrapping abstraction representing a name uniquely distinguishing a kernel-persistent entity fr...">Shared_name</a>. </p>
<p >Functionally equivalent to <code>return *this += (string(1, S_SEPARATOR) + src_to_append.str());</code>. If there's any reason to suspect <code>this-&gt;<a class="el" href="classipc_1_1util_1_1Shared__name.html#ae89e1e061f87ffe0288514e254837595" title="Returns (sans copying) ref to immutable entire wrapped name string, suitable to pass into sys calls w...">str()</a></code> already ends in <a class="el" href="classipc_1_1util_1_1Shared__name.html#a5c0910497c5ec484d3e42dfb0ccad48d" title="Character we use, by convention, to separate conceptual folders within str().">S_SEPARATOR</a>, and/or that the resulting name might be too long, execute <a class="el" href="classipc_1_1util_1_1Shared__name.html#add4ed045e03f786427a236a5dfa5a1b0" title="Best-effort attempt to turn sanitized() from false to true, unless it is already true; returns the fi...">sanitize()</a> afterwards and ensure that returns <code>true</code>.</p>
<p >It is stylistically (and possibly for performance) better to use this rather than manually appending a separator and then <code>src_to_append</code> (with <code>+=</code>).</p>
<h3>Rationale for not doing something smarter like avoiding a double-separator due to concatenation</h3>
<p >Basically we want things to be as fast as possible by default; and that is to make it as close to trivial string concatenation as possible. If more paranoia is required, we want the user to intentionally use <a class="el" href="classipc_1_1util_1_1Shared__name.html#add4ed045e03f786427a236a5dfa5a1b0" title="Best-effort attempt to turn sanitized() from false to true, unless it is already true; returns the fi...">sanitize()</a> or <a class="el" href="classipc_1_1util_1_1Shared__name.html#a03d90faae35392c8bbdd22f056755ba9" title="Returns true if and only if the contained name/fragment is sanitized according to length,...">sanitized()</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">src_to_append</td><td>Thing to append after appending separator. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>*this</code>.</dd></dl>
<h3>Rationale for having this <code>/=</code> as opposed to only the version taking <code>Source</code>, or vice versa</h3>
<p >If we had only the one taking <a class="el" href="classipc_1_1util_1_1Shared__name.html" title="String-wrapping abstraction representing a name uniquely distinguishing a kernel-persistent entity fr...">Shared_name</a>, then tried to use <code>+= X</code>, where <code>X</code> is <code>std::string</code> or <code>const char*</code> or <a class="el" href="namespaceipc_1_1util.html#ae6ac47812a90d1287c61e0b7de7bc4f5" title="Short-hand for Flow&#39;s String_view.">util::String_view</a>, it'd have to (implicitly) construct a <a class="el" href="classipc_1_1util_1_1Shared__name.html" title="String-wrapping abstraction representing a name uniquely distinguishing a kernel-persistent entity fr...">Shared_name</a> first, and that is a bit slower.</p>
<p >If we had only the one taking <code>Source</code> (e.g., <code>String_view</code>), and user wanted to append a <a class="el" href="classipc_1_1util_1_1Shared__name.html" title="String-wrapping abstraction representing a name uniquely distinguishing a kernel-persistent entity fr...">Shared_name</a>, they'd have to use <code>X.str()</code> explicitly, losing a bit of syntactic sugar.</p>
<p >Same deal with <code>+=</code> and the binary (<code>+</code>, <code>/</code>) derivations of these. </p>

<p class="definition">Definition at line <a class="el" href="shared__name_8cpp_source.html#l00091">91</a> of file <a class="el" href="shared__name_8cpp_source.html">shared_name.cpp</a>.</p>

<p class="reference">References <a class="el" href="shared__name_8cpp_source.html#l00091">operator/=()</a>, and <a class="el" href="shared__name_8cpp_source.html#l00140">str()</a>.</p>

<p class="reference">Referenced by <a class="el" href="shared__name_8cpp_source.html#l00083">operator/=()</a>.</p>
<div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="classipc_1_1util_1_1Shared__name_a956fdac1bb4cfab414b30091bec43f70_cgraph.svg" width="374" height="71"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe>
</div>
</div>
<div class="dynheader">
Here is the caller graph for this function:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="classipc_1_1util_1_1Shared__name_a956fdac1bb4cfab414b30091bec43f70_icgraph.svg" width="352" height="47"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe>
</div>
</div>

</div>
</div>
<a id="a762bda2d73b31c9427c05c7c1a7abbcb" name="a762bda2d73b31c9427c05c7c1a7abbcb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a762bda2d73b31c9427c05c7c1a7abbcb">&#9670;&nbsp;</a></span>operator/=() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Source &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classipc_1_1util_1_1Shared__name.html">Shared_name</a> &amp; ipc::util::Shared_name::operator/= </td>
          <td>(</td>
          <td class="paramtype">const Source &amp;&#160;</td>
          <td class="paramname"><em>raw_name_to_append</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Simply appends a folder separator followed by <code>raw_name_to_append</code> to the current value of <a class="el" href="classipc_1_1util_1_1Shared__name.html#ae89e1e061f87ffe0288514e254837595" title="Returns (sans copying) ref to immutable entire wrapped name string, suitable to pass into sys calls w...">str()</a>. </p>
<p >Specifically the internal <code>std::string</code> is modified as: <code>s += S_SEPARATOR; s += raw_name_to_append</code>. As a result, whatever most-performant available (single-arg by definition) <code>operator+=</code> that <code>basic_string</code> makes available is forwarded-to for the 2nd <code>+=</code>. (E.g., C++17 has a <code>String_view_like</code> appender which is overload-resolved-to only when it most makes sense.)</p>
<p >If there's any reason to suspect <code>this-&gt;<a class="el" href="classipc_1_1util_1_1Shared__name.html#ae89e1e061f87ffe0288514e254837595" title="Returns (sans copying) ref to immutable entire wrapped name string, suitable to pass into sys calls w...">str()</a></code> already ends in <a class="el" href="classipc_1_1util_1_1Shared__name.html#a5c0910497c5ec484d3e42dfb0ccad48d" title="Character we use, by convention, to separate conceptual folders within str().">S_SEPARATOR</a>, and/or that the resulting name might be too long, execute <a class="el" href="classipc_1_1util_1_1Shared__name.html#add4ed045e03f786427a236a5dfa5a1b0" title="Best-effort attempt to turn sanitized() from false to true, unless it is already true; returns the fi...">sanitize()</a> afterwards and ensure that returns <code>true</code>.</p>
<p >It is stylistically (and possibly for performance) better to use this rather than manually appending a separator and then <code>src_to_append</code> (with <code>+=</code>).</p>
<p >See Rationale(s) for the other <a class="el" href="classipc_1_1util_1_1Shared__name.html#a956fdac1bb4cfab414b30091bec43f70" title="Appends a folder separator followed by the given other Shared_name.">operator/=()</a>, as they apply here.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Source</td><td>See above. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">raw_name_to_append</td><td>Thing to append after appending separator. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>*this</code>. </dd></dl>

<p class="definition">Definition at line <a class="el" href="shared__name_8hpp_source.html#l00696">696</a> of file <a class="el" href="shared__name_8hpp_source.html">shared_name.hpp</a>.</p>

<p class="reference">References <a class="el" href="shared__name_8hpp_source.html#l00659">m_raw_name</a>, <a class="el" href="shared__name_8cpp_source.html#l00077">operator+=()</a>, and <a class="el" href="shared__name_8hpp_source.html#l00266">S_SEPARATOR</a>.</p>
<div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="classipc_1_1util_1_1Shared__name_a762bda2d73b31c9427c05c7c1a7abbcb_cgraph.svg" width="568" height="71"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe>
</div>
</div>

</div>
</div>
<a id="abd312f9eaf6f07adaba115aaab05b539" name="abd312f9eaf6f07adaba115aaab05b539"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abd312f9eaf6f07adaba115aaab05b539">&#9670;&nbsp;</a></span>operator=() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classipc_1_1util_1_1Shared__name.html">Shared_name</a> &amp; ipc::util::Shared_name::operator= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classipc_1_1util_1_1Shared__name.html">Shared_name</a> &amp;&#160;</td>
          <td class="paramname"><em>src</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">default</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Copy-assigns from an existing <a class="el" href="classipc_1_1util_1_1Shared__name.html" title="String-wrapping abstraction representing a name uniquely distinguishing a kernel-persistent entity fr...">Shared_name</a>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">src</td><td>Source object. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>*this</code>. </dd></dl>

</div>
</div>
<a id="a1511bd84d701dd866029d0f4c8869516" name="a1511bd84d701dd866029d0f4c8869516"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1511bd84d701dd866029d0f4c8869516">&#9670;&nbsp;</a></span>operator=() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classipc_1_1util_1_1Shared__name.html">Shared_name</a> &amp; ipc::util::Shared_name::operator= </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classipc_1_1util_1_1Shared__name.html">Shared_name</a> &amp;&amp;&#160;</td>
          <td class="paramname"><em>src_moved</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">default</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Move-assigns from an existing <a class="el" href="classipc_1_1util_1_1Shared__name.html" title="String-wrapping abstraction representing a name uniquely distinguishing a kernel-persistent entity fr...">Shared_name</a>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">src_moved</td><td>Source object, which is potentially modified. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>*this</code>. </dd></dl>

</div>
</div>
<a id="add4ed045e03f786427a236a5dfa5a1b0" name="add4ed045e03f786427a236a5dfa5a1b0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#add4ed045e03f786427a236a5dfa5a1b0">&#9670;&nbsp;</a></span>sanitize()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool ipc::util::Shared_name::sanitize </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Best-effort attempt to turn <a class="el" href="classipc_1_1util_1_1Shared__name.html#a03d90faae35392c8bbdd22f056755ba9" title="Returns true if and only if the contained name/fragment is sanitized according to length,...">sanitized()</a> from <code>false</code> to <code>true</code>, unless it is already <code>true</code>; returns the final value of <a class="el" href="classipc_1_1util_1_1Shared__name.html#a03d90faae35392c8bbdd22f056755ba9" title="Returns true if and only if the contained name/fragment is sanitized according to length,...">sanitized()</a> indicating whether it was successful. </p>
<p >If <code>false</code> returned, then the final value of <a class="el" href="classipc_1_1util_1_1Shared__name.html#ae89e1e061f87ffe0288514e254837595" title="Returns (sans copying) ref to immutable entire wrapped name string, suitable to pass into sys calls w...">str()</a> will equal the initial value.</p>
<p >This utility should be used very judiciously and with full knowledge of what it actually does. It should <em>not</em> be used "just in case" or "prophylactically" but only with full knowledge of where the current value of <a class="el" href="classipc_1_1util_1_1Shared__name.html#ae89e1e061f87ffe0288514e254837595" title="Returns (sans copying) ref to immutable entire wrapped name string, suitable to pass into sys calls w...">str()</a> might originate. For example, it might come from some user input. Another example involves, perhaps, concatenating two path fragments in such a way as to potentially yield a double-<a class="el" href="classipc_1_1util_1_1Shared__name.html#a5c0910497c5ec484d3e42dfb0ccad48d" title="Character we use, by convention, to separate conceptual folders within str().">S_SEPARATOR</a> situation: <a class="el" href="classipc_1_1util_1_1Shared__name.html#add4ed045e03f786427a236a5dfa5a1b0" title="Best-effort attempt to turn sanitized() from false to true, unless it is already true; returns the fi...">sanitize()</a> after this would get collapse the separators into just 1 separator. Yet another example is simply that if one combines two paths which don't exceed <a class="el" href="classipc_1_1util_1_1Shared__name.html#afc9b87fc69d42df3107bf4a27ea66c7c" title="Max value of size() such that, if str() used to name a supported shared resource, sys call safely won...">S_MAX_LENGTH</a>, but the result might exceed it: running <a class="el" href="classipc_1_1util_1_1Shared__name.html#add4ed045e03f786427a236a5dfa5a1b0" title="Best-effort attempt to turn sanitized() from false to true, unless it is already true; returns the fi...">sanitize()</a> and ensuring it returns <code>true</code> guaranteed one didn't accidentally exceed <a class="el" href="classipc_1_1util_1_1Shared__name.html#afc9b87fc69d42df3107bf4a27ea66c7c" title="Max value of size() such that, if str() used to name a supported shared resource, sys call safely won...">S_MAX_LENGTH</a>.</p>
<p >In other words, use it when you want it to do what it, in fact, does. And that is:</p><ul>
<li>Any '/' (forward-slash) character, as a special case, is transformed into <a class="el" href="classipc_1_1util_1_1Shared__name.html#a5c0910497c5ec484d3e42dfb0ccad48d" title="Character we use, by convention, to separate conceptual folders within str().">S_SEPARATOR</a>.</li>
<li>After any character replacements above: Any sequence of 2 or more <a class="el" href="classipc_1_1util_1_1Shared__name.html#a5c0910497c5ec484d3e42dfb0ccad48d" title="Character we use, by convention, to separate conceptual folders within str().">S_SEPARATOR</a> characters is collapsed into one <a class="el" href="classipc_1_1util_1_1Shared__name.html#a5c0910497c5ec484d3e42dfb0ccad48d" title="Character we use, by convention, to separate conceptual folders within str().">S_SEPARATOR</a>.</li>
</ul>
<p >Things it does <em>not</em> do, except the above:</p><ul>
<li>No legal or illegal character is changed (except '/' and separator collapsing).</li>
<li>It doesn't truncate to try to bring length to <a class="el" href="classipc_1_1util_1_1Shared__name.html#afc9b87fc69d42df3107bf4a27ea66c7c" title="Max value of size() such that, if str() used to name a supported shared resource, sys call safely won...">S_MAX_LENGTH</a> or less.</li>
</ul>
<p >However, the method's return value is still significant, in that if it is "still" <code>false</code>, then you know you have a real problem &ndash; yet if it's <code>true</code>, then it didn't do anything destructive to make it so.</p>
<p >Note, again, that the above replacements are "undone" if <code>false</code> is returned. In other words, the function won't sanitize "halfway."</p>
<h3>Performance</h3>
<p >There is at most one linear scan through <a class="el" href="classipc_1_1util_1_1Shared__name.html#ae89e1e061f87ffe0288514e254837595" title="Returns (sans copying) ref to immutable entire wrapped name string, suitable to pass into sys calls w...">str()</a>. In addition, though only if actual sanitizing (by changing <a class="el" href="classipc_1_1util_1_1Shared__name.html#ae89e1e061f87ffe0288514e254837595" title="Returns (sans copying) ref to immutable entire wrapped name string, suitable to pass into sys calls w...">str()</a>) might be necessary: an allocation, copy of <a class="el" href="classipc_1_1util_1_1Shared__name.html#ae89e1e061f87ffe0288514e254837595" title="Returns (sans copying) ref to immutable entire wrapped name string, suitable to pass into sys calls w...">str()</a>, and deallocation may be performed. Overall, it is linear-time regardless, plus those potential alloc/dealloc ops.</p>
<dl class="section return"><dt>Returns</dt><dd>What <a class="el" href="classipc_1_1util_1_1Shared__name.html#a03d90faae35392c8bbdd22f056755ba9" title="Returns true if and only if the contained name/fragment is sanitized according to length,...">sanitized()</a> would return just before returning from the present function. </dd></dl>

<p class="definition">Definition at line <a class="el" href="shared__name_8cpp_source.html#l00221">221</a> of file <a class="el" href="shared__name_8cpp_source.html">shared_name.cpp</a>.</p>

<p class="reference">References <a class="el" href="shared__name_8cpp_source.html#l00155">empty()</a>, <a class="el" href="shared__name_8hpp_source.html#l00659">m_raw_name</a>, <a class="el" href="shared__name_8hpp_source.html#l00263">S_MAX_LENGTH</a>, <a class="el" href="shared__name_8hpp_source.html#l00266">S_SEPARATOR</a>, and <a class="el" href="shared__name_8cpp_source.html#l00150">size()</a>.</p>
<div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="classipc_1_1util_1_1Shared__name_add4ed045e03f786427a236a5dfa5a1b0_cgraph.svg" width="352" height="107"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe>
</div>
</div>

</div>
</div>
<a id="a03d90faae35392c8bbdd22f056755ba9" name="a03d90faae35392c8bbdd22f056755ba9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a03d90faae35392c8bbdd22f056755ba9">&#9670;&nbsp;</a></span>sanitized()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool ipc::util::Shared_name::sanitized </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns <code>true</code> if and only if the contained name/fragment is <em>sanitized</em> according to length, legal characters, and similar. </p>
<p >More precisely, a sanitized <code>*this</code> satisfies all of the following:</p><ul>
<li>There are no illegal characters. (E.g., in particular, some characters would not be accepted when naming a SHM object in Linux.)<ul>
<li>In particular, only <a class="el" href="classipc_1_1util_1_1Shared__name.html#a5c0910497c5ec484d3e42dfb0ccad48d" title="Character we use, by convention, to separate conceptual folders within str().">S_SEPARATOR</a> is used as a folder separator.</li>
</ul>
</li>
<li>There is no more than 1 instance of <a class="el" href="classipc_1_1util_1_1Shared__name.html#a5c0910497c5ec484d3e42dfb0ccad48d" title="Character we use, by convention, to separate conceptual folders within str().">S_SEPARATOR</a> character in a row.</li>
<li><a class="el" href="classipc_1_1util_1_1Shared__name.html#af34db2934e116f8a4fdd403fd04695af" title="Returns str().size().">size()</a> does not exceed <a class="el" href="classipc_1_1util_1_1Shared__name.html#afc9b87fc69d42df3107bf4a27ea66c7c" title="Max value of size() such that, if str() used to name a supported shared resource, sys call safely won...">S_MAX_LENGTH</a>.</li>
</ul>
<h3>Performance</h3>
<p >It is linear-time, with at most one scan through <a class="el" href="classipc_1_1util_1_1Shared__name.html#ae89e1e061f87ffe0288514e254837595" title="Returns (sans copying) ref to immutable entire wrapped name string, suitable to pass into sys calls w...">str()</a>.</p>
<dl class="section return"><dt>Returns</dt><dd>See above. </dd></dl>

<p class="definition">Definition at line <a class="el" href="shared__name_8cpp_source.html#l00175">175</a> of file <a class="el" href="shared__name_8cpp_source.html">shared_name.cpp</a>.</p>

<p class="reference">References <a class="el" href="shared__name_8hpp_source.html#l00659">m_raw_name</a>, <a class="el" href="shared__name_8hpp_source.html#l00263">S_MAX_LENGTH</a>, <a class="el" href="shared__name_8hpp_source.html#l00266">S_SEPARATOR</a>, and <a class="el" href="shared__name_8cpp_source.html#l00150">size()</a>.</p>
<div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="classipc_1_1util_1_1Shared__name_a03d90faae35392c8bbdd22f056755ba9_cgraph.svg" width="352" height="47"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe>
</div>
</div>

</div>
</div>
<a id="af34db2934e116f8a4fdd403fd04695af" name="af34db2934e116f8a4fdd403fd04695af"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af34db2934e116f8a4fdd403fd04695af">&#9670;&nbsp;</a></span>size()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t ipc::util::Shared_name::size </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns <code><a class="el" href="classipc_1_1util_1_1Shared__name.html#ae89e1e061f87ffe0288514e254837595" title="Returns (sans copying) ref to immutable entire wrapped name string, suitable to pass into sys calls w...">str()</a>.<a class="el" href="classipc_1_1util_1_1Shared__name.html#af34db2934e116f8a4fdd403fd04695af" title="Returns str().size().">size()</a></code>. </p>
<dl class="section return"><dt>Returns</dt><dd>See above. </dd></dl>

<p class="definition">Definition at line <a class="el" href="shared__name_8cpp_source.html#l00150">150</a> of file <a class="el" href="shared__name_8cpp_source.html">shared_name.cpp</a>.</p>

<p class="reference">References <a class="el" href="shared__name_8hpp_source.html#l00659">m_raw_name</a>.</p>

<p class="reference">Referenced by <a class="el" href="ipc__shm__arena__lend_2src_2ipc_2session_2shm_2arena__lend_2jemalloc_2session__server_8hpp_source.html#l00561">ipc::session::shm::arena_lend::jemalloc::Session_server&lt; S_MQ_TYPE_OR_NONE, S_TRANSMIT_NATIVE_HANDLES, Mdt_payload &gt;::cleanup()</a>, <a class="el" href="detail_2asio__local__stream__socket_8cpp_source.html#l00028">ipc::transport::asio_local_stream_socket::endpoint_at_shared_name()</a>, <a class="el" href="shared__name_8cpp_source.html#l00221">sanitize()</a>, and <a class="el" href="shared__name_8cpp_source.html#l00175">sanitized()</a>.</p>
<div class="dynheader">
Here is the caller graph for this function:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="classipc_1_1util_1_1Shared__name_af34db2934e116f8a4fdd403fd04695af_icgraph.svg" width="631" height="276"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe>
</div>
</div>

</div>
</div>
<a id="ae89e1e061f87ffe0288514e254837595" name="ae89e1e061f87ffe0288514e254837595"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae89e1e061f87ffe0288514e254837595">&#9670;&nbsp;</a></span>str()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const std::string &amp; ipc::util::Shared_name::str </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns (sans copying) ref to immutable entire wrapped name string, suitable to pass into sys calls when naming supported shared resources assuming <code><a class="el" href="classipc_1_1util_1_1Shared__name.html#ab1934f80515fdbc3e2a59ccda32fff9a" title="Returns true if and only if the first character is S_SEPARATOR.">absolute()</a> == true</code>. </p>
<p >If you require a NUL-terminated string (such as for a native call), use <a class="el" href="classipc_1_1util_1_1Shared__name.html#a0bccc73c9c5b4f3b784a1e57cdc5c910" title="Returns (sans copying) pointer to NUL-terminated wrapped name string, suitable to pass into sys calls...">native_str()</a>.</p>
<dl class="section note"><dt>Note</dt><dd>Returning a <a class="el" href="namespaceipc_1_1util.html#ae6ac47812a90d1287c61e0b7de7bc4f5" title="Short-hand for Flow&#39;s String_view.">util::String_view</a> seemed pointless, as one can always be constructed easily by the caller, and in any case &ndash; for the time being at least &ndash; some/many APIs that take non-C-strings will take <code>std::string</code> as opposed to a <a class="el" href="namespaceipc_1_1util.html#ae6ac47812a90d1287c61e0b7de7bc4f5" title="Short-hand for Flow&#39;s String_view.">util::String_view</a>.</dd></dl>
<dl class="section return"><dt>Returns</dt><dd>See above. </dd></dl>

<p class="definition">Definition at line <a class="el" href="shared__name_8cpp_source.html#l00140">140</a> of file <a class="el" href="shared__name_8cpp_source.html">shared_name.cpp</a>.</p>

<p class="reference">References <a class="el" href="shared__name_8hpp_source.html#l00659">m_raw_name</a>.</p>

<p class="reference">Referenced by <a class="el" href="ipc__session_2src_2ipc_2session_2detail_2server__session__impl_8hpp_source.html#l01583">ipc::session::Server_session_impl&lt; S_MQ_TYPE_OR_NONE, S_TRANSMIT_NATIVE_HANDLES, Mdt_payload, S_SHM_TYPE_OR_NONE, S_SHM_MAX_HNDL_SZ, S_GRACEFUL_FINISH_REQUIRED_V &gt;::async_accept_log_in()</a>, <a class="el" href="ipc__shm__arena__lend_2src_2ipc_2session_2detail_2shm_2arena__lend_2jemalloc_2client__session__impl_8hpp_source.html#l00471">ipc::session::shm::arena_lend::jemalloc::Client_session_impl&lt; S_MQ_TYPE_OR_NONE, S_TRANSMIT_NATIVE_HANDLES, Mdt_payload &gt;::cleanup()</a>, <a class="el" href="ipc__shm__arena__lend_2src_2ipc_2session_2shm_2arena__lend_2jemalloc_2session__server_8hpp_source.html#l00561">ipc::session::shm::arena_lend::jemalloc::Session_server&lt; S_MQ_TYPE_OR_NONE, S_TRANSMIT_NATIVE_HANDLES, Mdt_payload &gt;::cleanup()</a>, <a class="el" href="ipc__session_2src_2ipc_2session_2detail_2session__shared__name_8cpp_source.html#l00114">ipc::session::decompose_conventional_shared_name()</a>, <a class="el" href="detail_2asio__local__stream__socket_8cpp_source.html#l00028">ipc::transport::asio_local_stream_socket::endpoint_at_shared_name()</a>, <a class="el" href="shared__name_8cpp_source.html#l00412">hash_value()</a>, <a class="el" href="arena__lend_2src_2ipc_2session_2detail_2shm_2arena__lend_2jemalloc_2session__impl_8hpp_source.html#l00270">ipc::session::shm::arena_lend::jemalloc::Session_impl&lt; Session_impl_t &gt;::init_shm()</a>, <a class="el" href="ipc__session_2src_2ipc_2session_2detail_2server__session__impl_8hpp_source.html#l00985">ipc::session::Server_session_impl&lt; S_MQ_TYPE_OR_NONE, S_TRANSMIT_NATIVE_HANDLES, Mdt_payload, S_SHM_TYPE_OR_NONE, S_SHM_MAX_HNDL_SZ, S_GRACEFUL_FINISH_REQUIRED_V &gt;::mdt_builder()</a>, <a class="el" href="ipc__session_2src_2ipc_2session_2detail_2server__session__impl_8hpp_source.html#l01244">ipc::session::Server_session_impl&lt; S_MQ_TYPE_OR_NONE, S_TRANSMIT_NATIVE_HANDLES, Mdt_payload, S_SHM_TYPE_OR_NONE, S_SHM_MAX_HNDL_SZ, S_GRACEFUL_FINISH_REQUIRED_V &gt;::on_master_channel_open_channel_req()</a>, <a class="el" href="native__socket__stream__acceptor_8cpp_source.html#l00181">ipc::transport::Native_socket_stream_acceptor::on_next_peer_socket_or_error()</a>, <a class="el" href="shared__name_8cpp_source.html#l00113">operator+()</a>, <a class="el" href="shared__name_8cpp_source.html#l00077">operator+=()</a>, <a class="el" href="shared__name_8cpp_source.html#l00091">operator/=()</a>, <a class="el" href="shared__name_8cpp_source.html#l00407">ipc::util::operator&lt;()</a>, <a class="el" href="shared__name_8cpp_source.html#l00353">operator&lt;&lt;()</a>, <a class="el" href="shared__name_8cpp_source.html#l00373">ipc::util::operator==()</a>, and <a class="el" href="shared__name_8hpp_source.html#l00764">ipc::util::remove_each_persistent_with_name_prefix()</a>.</p>
<div class="dynheader">
Here is the caller graph for this function:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="classipc_1_1util_1_1Shared__name_ae89e1e061f87ffe0288514e254837595_icgraph.svg" width="854" height="1115"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe>
</div>
</div>

</div>
</div>
<h2 class="groupheader">Friends And Related Function Documentation</h2>
<a id="aba4ae811264cbb7e664ce126b591cbc7" name="aba4ae811264cbb7e664ce126b591cbc7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aba4ae811264cbb7e664ce126b591cbc7">&#9670;&nbsp;</a></span>hash_value()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_t hash_value </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classipc_1_1util_1_1Shared__name.html">Shared_name</a> &amp;&#160;</td>
          <td class="paramname"><em>val</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Hasher of <a class="el" href="classipc_1_1util_1_1Shared__name.html" title="String-wrapping abstraction representing a name uniquely distinguishing a kernel-persistent entity fr...">Shared_name</a> for boost.unordered et al. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">val</td><td>Object to hash. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>See above. </dd></dl>

<p class="definition">Definition at line <a class="el" href="shared__name_8cpp_source.html#l00412">412</a> of file <a class="el" href="shared__name_8cpp_source.html">shared_name.cpp</a>.</p>

<p class="reference">References <a class="el" href="shared__name_8cpp_source.html#l00140">str()</a>.</p>
<div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="classipc_1_1util_1_1Shared__name_aba4ae811264cbb7e664ce126b591cbc7_cgraph.svg" width="374" height="47"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe>
</div>
</div>

</div>
</div>
<a id="a096c71dede7bd5528215ac01a380a189" name="a096c71dede7bd5528215ac01a380a189"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a096c71dede7bd5528215ac01a380a189">&#9670;&nbsp;</a></span>operator+() <span class="overload">[1/5]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classipc_1_1util_1_1Shared__name.html">Shared_name</a> operator+ </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>raw_src1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classipc_1_1util_1_1Shared__name.html">Shared_name</a> &amp;&#160;</td>
          <td class="paramname"><em>src2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns new object equal to <code>Shared_name(src2)</code> with <code>raw_src1</code> pre-pended to it. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">raw_src1</td><td>String to precede the appended <code>src2</code>. </td></tr>
    <tr><td class="paramname">src2</td><td>Object to append. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>See above. </dd></dl>

<p class="definition">Definition at line <a class="el" href="shared__name_8cpp_source.html#l00105">105</a> of file <a class="el" href="shared__name_8cpp_source.html">shared_name.cpp</a>.</p>

<p class="reference">References <a class="el" href="shared__name_8cpp_source.html#l00097">ipc::util::operator+()</a>.</p>
<div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="classipc_1_1util_1_1Shared__name_a096c71dede7bd5528215ac01a380a189_cgraph.svg" width="332" height="47"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe>
</div>
</div>

</div>
</div>
<a id="af61b02fd66b67aeed5a803ca47e52973" name="af61b02fd66b67aeed5a803ca47e52973"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af61b02fd66b67aeed5a803ca47e52973">&#9670;&nbsp;</a></span>operator+() <span class="overload">[2/5]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classipc_1_1util_1_1Shared__name.html">Shared_name</a> operator+ </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classipc_1_1util_1_1Shared__name.html">Shared_name</a> &amp;&#160;</td>
          <td class="paramname"><em>src1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>raw_src2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns new object equal to <code>Shared_name(src1) += raw_src2</code>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">src1</td><td>Object to precede the appended <code>raw_src2</code>. </td></tr>
    <tr><td class="paramname">raw_src2</td><td>String to append. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>See above. </dd></dl>

<p class="definition">Definition at line <a class="el" href="shared__name_8cpp_source.html#l00097">97</a> of file <a class="el" href="shared__name_8cpp_source.html">shared_name.cpp</a>.</p>

<p class="reference">References <a class="el" href="shared__name_8cpp_source.html#l00097">ipc::util::operator+()</a>.</p>
<div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="classipc_1_1util_1_1Shared__name_af61b02fd66b67aeed5a803ca47e52973_cgraph.svg" width="332" height="47"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe>
</div>
</div>

</div>
</div>
<a id="a54dc5077333284fda9e8d2df8b0e9b91" name="a54dc5077333284fda9e8d2df8b0e9b91"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a54dc5077333284fda9e8d2df8b0e9b91">&#9670;&nbsp;</a></span>operator+() <span class="overload">[3/5]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classipc_1_1util_1_1Shared__name.html">Shared_name</a> operator+ </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classipc_1_1util_1_1Shared__name.html">Shared_name</a> &amp;&#160;</td>
          <td class="paramname"><em>src1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classipc_1_1util_1_1Shared__name.html">Shared_name</a> &amp;&#160;</td>
          <td class="paramname"><em>src2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns new object equal to <code>Shared_name(src1) += src2</code>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">src1</td><td>Object to precede the appended <code>src2</code>. </td></tr>
    <tr><td class="paramname">src2</td><td>Object to append. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>See above. </dd></dl>

<p class="definition">Definition at line <a class="el" href="shared__name_8cpp_source.html#l00113">113</a> of file <a class="el" href="shared__name_8cpp_source.html">shared_name.cpp</a>.</p>

<p class="reference">References <a class="el" href="shared__name_8cpp_source.html#l00140">str()</a>.</p>
<div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="classipc_1_1util_1_1Shared__name_a54dc5077333284fda9e8d2df8b0e9b91_cgraph.svg" width="374" height="47"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe>
</div>
</div>

</div>
</div>
<a id="a52b2ba03d5ace7389991bb5d31b9fa59" name="a52b2ba03d5ace7389991bb5d31b9fa59"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a52b2ba03d5ace7389991bb5d31b9fa59">&#9670;&nbsp;</a></span>operator+() <span class="overload">[4/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Source &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classipc_1_1util_1_1Shared__name.html">Shared_name</a> operator+ </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classipc_1_1util_1_1Shared__name.html">Shared_name</a> &amp;&#160;</td>
          <td class="paramname"><em>src1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Source &amp;&#160;</td>
          <td class="paramname"><em>raw_src2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns new object equal to <code>Shared_name(src1) += raw_src2</code>. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Source</td><td>See <a class="el" href="classipc_1_1util_1_1Shared__name.html#a1bcac1c10e01ba11dcc437b3c32bbe6c" title="Appends the given other Shared_name.">Shared_name::operator+=()</a> similar overload. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">src1</td><td>Object to precede the appended <code>raw_src2</code>. </td></tr>
    <tr><td class="paramname">raw_src2</td><td>String to append. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>See above. </dd></dl>

<p class="definition">Definition at line <a class="el" href="shared__name_8hpp_source.html#l00708">708</a> of file <a class="el" href="shared__name_8hpp_source.html">shared_name.hpp</a>.</p>

</div>
</div>
<a id="a1f1a40877cc08b287f8f3c7e7f663782" name="a1f1a40877cc08b287f8f3c7e7f663782"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1f1a40877cc08b287f8f3c7e7f663782">&#9670;&nbsp;</a></span>operator+() <span class="overload">[5/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Source &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classipc_1_1util_1_1Shared__name.html">Shared_name</a> operator+ </td>
          <td>(</td>
          <td class="paramtype">const Source &amp;&#160;</td>
          <td class="paramname"><em>raw_src1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classipc_1_1util_1_1Shared__name.html">Shared_name</a> &amp;&#160;</td>
          <td class="paramname"><em>src2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns new object equal to <code>Shared_name(src2)</code> with <code>raw_src1</code> pre-pended to it. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Source</td><td>See <a class="el" href="classipc_1_1util_1_1Shared__name.html#a1bcac1c10e01ba11dcc437b3c32bbe6c" title="Appends the given other Shared_name.">Shared_name::operator+=()</a> similar overload. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">raw_src1</td><td>String to precede the appended <code>src2</code>. </td></tr>
    <tr><td class="paramname">src2</td><td>Object to append. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>See above. </dd></dl>

<p class="definition">Definition at line <a class="el" href="shared__name_8hpp_source.html#l00716">716</a> of file <a class="el" href="shared__name_8hpp_source.html">shared_name.hpp</a>.</p>

<p class="reference">References <a class="el" href="shared__name_8hpp_source.html#l00674">ct()</a>.</p>
<div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="classipc_1_1util_1_1Shared__name_a1f1a40877cc08b287f8f3c7e7f663782_cgraph.svg" width="370" height="47"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe>
</div>
</div>

</div>
</div>
<a id="a7f2bead5935309c2f760645fe46ddd71" name="a7f2bead5935309c2f760645fe46ddd71"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7f2bead5935309c2f760645fe46ddd71">&#9670;&nbsp;</a></span>operator/() <span class="overload">[1/5]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classipc_1_1util_1_1Shared__name.html">Shared_name</a> operator/ </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>raw_src1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classipc_1_1util_1_1Shared__name.html">Shared_name</a> &amp;&#160;</td>
          <td class="paramname"><em>src2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns new object equal to <code>Shared_name(raw_src1) /= src2</code>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">raw_src1</td><td>String to precede the appended separator and <code>src2</code>. </td></tr>
    <tr><td class="paramname">src2</td><td>Object to append after separator. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>See above. </dd></dl>

<p class="definition">Definition at line <a class="el" href="shared__name_8cpp_source.html#l00127">127</a> of file <a class="el" href="shared__name_8cpp_source.html">shared_name.cpp</a>.</p>

<p class="reference">References <a class="el" href="shared__name_8cpp_source.html#l00119">ipc::util::operator/()</a>.</p>
<div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="classipc_1_1util_1_1Shared__name_a7f2bead5935309c2f760645fe46ddd71_cgraph.svg" width="328" height="47"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe>
</div>
</div>

</div>
</div>
<a id="aa61c6b31c5c4e241c97f06a4d38c76c4" name="aa61c6b31c5c4e241c97f06a4d38c76c4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa61c6b31c5c4e241c97f06a4d38c76c4">&#9670;&nbsp;</a></span>operator/() <span class="overload">[2/5]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classipc_1_1util_1_1Shared__name.html">Shared_name</a> operator/ </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classipc_1_1util_1_1Shared__name.html">Shared_name</a> &amp;&#160;</td>
          <td class="paramname"><em>src1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>raw_src2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns new object equal to <code>Shared_name(src1) /= raw_src2</code>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">src1</td><td>Object to precede the appended separator and <code>raw_src2</code>. </td></tr>
    <tr><td class="paramname">raw_src2</td><td>String to append after separator. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>See above. </dd></dl>

<p class="definition">Definition at line <a class="el" href="shared__name_8cpp_source.html#l00119">119</a> of file <a class="el" href="shared__name_8cpp_source.html">shared_name.cpp</a>.</p>

<p class="reference">References <a class="el" href="shared__name_8cpp_source.html#l00119">ipc::util::operator/()</a>.</p>
<div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="classipc_1_1util_1_1Shared__name_aa61c6b31c5c4e241c97f06a4d38c76c4_cgraph.svg" width="328" height="47"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe>
</div>
</div>

</div>
</div>
<a id="a15ea67c1855a678f7e948b24ccf2c1cd" name="a15ea67c1855a678f7e948b24ccf2c1cd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a15ea67c1855a678f7e948b24ccf2c1cd">&#9670;&nbsp;</a></span>operator/() <span class="overload">[3/5]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classipc_1_1util_1_1Shared__name.html">Shared_name</a> operator/ </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classipc_1_1util_1_1Shared__name.html">Shared_name</a> &amp;&#160;</td>
          <td class="paramname"><em>src1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classipc_1_1util_1_1Shared__name.html">Shared_name</a> &amp;&#160;</td>
          <td class="paramname"><em>src2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns new object equal to <code>Shared_name(src1) /= src2</code>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">src1</td><td>Object to precede the appended separator and <code>src2</code>. </td></tr>
    <tr><td class="paramname">src2</td><td>Object to append after separator. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>See above. </dd></dl>

<p class="definition">Definition at line <a class="el" href="shared__name_8cpp_source.html#l00135">135</a> of file <a class="el" href="shared__name_8cpp_source.html">shared_name.cpp</a>.</p>

</div>
</div>
<a id="a910207a2da57b61cee4a22899e239dc2" name="a910207a2da57b61cee4a22899e239dc2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a910207a2da57b61cee4a22899e239dc2">&#9670;&nbsp;</a></span>operator/() <span class="overload">[4/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Source &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classipc_1_1util_1_1Shared__name.html">Shared_name</a> operator/ </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classipc_1_1util_1_1Shared__name.html">Shared_name</a> &amp;&#160;</td>
          <td class="paramname"><em>src1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Source &amp;&#160;</td>
          <td class="paramname"><em>raw_src2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns new object equal to <code>Shared_name(src1) /= raw_src2</code>. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Source</td><td>See <a class="el" href="classipc_1_1util_1_1Shared__name.html#a956fdac1bb4cfab414b30091bec43f70" title="Appends a folder separator followed by the given other Shared_name.">Shared_name::operator/=()</a> similar overload. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">src1</td><td>Object to precede the appended separator and <code>raw_src2</code>. </td></tr>
    <tr><td class="paramname">raw_src2</td><td>String to append after separator. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>See above. </dd></dl>

<p class="definition">Definition at line <a class="el" href="shared__name_8hpp_source.html#l00724">724</a> of file <a class="el" href="shared__name_8hpp_source.html">shared_name.hpp</a>.</p>

</div>
</div>
<a id="a462b81d34ba23c968f63d9805fa74538" name="a462b81d34ba23c968f63d9805fa74538"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a462b81d34ba23c968f63d9805fa74538">&#9670;&nbsp;</a></span>operator/() <span class="overload">[5/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Source &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classipc_1_1util_1_1Shared__name.html">Shared_name</a> operator/ </td>
          <td>(</td>
          <td class="paramtype">const Source &amp;&#160;</td>
          <td class="paramname"><em>raw_src1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classipc_1_1util_1_1Shared__name.html">Shared_name</a> &amp;&#160;</td>
          <td class="paramname"><em>src2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns new object equal to <code>Shared_name(raw_src1) /= src2</code>. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Source</td><td>See <a class="el" href="classipc_1_1util_1_1Shared__name.html#a956fdac1bb4cfab414b30091bec43f70" title="Appends a folder separator followed by the given other Shared_name.">Shared_name::operator/=()</a> similar overload. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">raw_src1</td><td>String to precede the appended separator and <code>src2</code>. </td></tr>
    <tr><td class="paramname">src2</td><td>Object to append after separator. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>See above. </dd></dl>

<p class="definition">Definition at line <a class="el" href="shared__name_8hpp_source.html#l00732">732</a> of file <a class="el" href="shared__name_8hpp_source.html">shared_name.hpp</a>.</p>

<p class="reference">References <a class="el" href="shared__name_8hpp_source.html#l00674">ct()</a>.</p>
<div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="classipc_1_1util_1_1Shared__name_a462b81d34ba23c968f63d9805fa74538_cgraph.svg" width="370" height="47"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe>
</div>
</div>

</div>
</div>
<a id="af7728c93fdf29479bbb2482e02f05cbf" name="af7728c93fdf29479bbb2482e02f05cbf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af7728c93fdf29479bbb2482e02f05cbf">&#9670;&nbsp;</a></span>operator&lt;&lt;()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::ostream &amp; operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>os</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classipc_1_1util_1_1Shared__name.html">Shared_name</a> &amp;&#160;</td>
          <td class="paramname"><em>val</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Prints embellished string representation of the given <a class="el" href="classipc_1_1util_1_1Shared__name.html" title="String-wrapping abstraction representing a name uniquely distinguishing a kernel-persistent entity fr...">Shared_name</a> to the given <code>ostream</code>. </p>
<dl class="section warning"><dt>Warning</dt><dd>This is <em>not</em> equivalent to writing <a class="el" href="classipc_1_1util_1_1Shared__name.html#ae89e1e061f87ffe0288514e254837595" title="Returns (sans copying) ref to immutable entire wrapped name string, suitable to pass into sys calls w...">Shared_name::str()</a>; as of this writing it includes not just <code><a class="el" href="classipc_1_1util_1_1Shared__name.html#ae89e1e061f87ffe0288514e254837595" title="Returns (sans copying) ref to immutable entire wrapped name string, suitable to pass into sys calls w...">str()</a></code> but also the number of characters in it as a decimal and a separator, for convenience in test/debug, to visually detect names approaching certain length limits. If you wish to output <code>val.str()</code>, then output... well... <code>val.str()</code>.</dd></dl>
<dl class="todo"><dt><b><a class="el" href="todo.html#_todo000021">Todo:</a></b></dt><dd>Does <a class="el" href="classipc_1_1util_1_1Shared__name.html" title="String-wrapping abstraction representing a name uniquely distinguishing a kernel-persistent entity fr...">Shared_name</a> <code>operator&gt;&gt;</code> and <code>operator&lt;&lt;</code> being asymmetrical get one into trouble when using <a class="el" href="classipc_1_1util_1_1Shared__name.html" title="String-wrapping abstraction representing a name uniquely distinguishing a kernel-persistent entity fr...">Shared_name</a> with boost.program_options (or <code>flow::cfg</code> which is built on top of it)? Look into it. It may be necessary to make <code>operator&lt;&lt;</code> equal to that of <code>ostream &lt;&lt; string</code> after all; though the added niceties of the current <code>&lt;&lt;</code> semantics may still at least be available via some explicit accessor.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">os</td><td>Stream to which to write. </td></tr>
    <tr><td class="paramname">val</td><td>Object to serialize. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>os</code>. </dd></dl>

<p class="definition">Definition at line <a class="el" href="shared__name_8cpp_source.html#l00353">353</a> of file <a class="el" href="shared__name_8cpp_source.html">shared_name.cpp</a>.</p>

<p class="reference">References <a class="el" href="shared__name_8cpp_source.html#l00140">str()</a>.</p>
<div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="classipc_1_1util_1_1Shared__name_af7728c93fdf29479bbb2482e02f05cbf_cgraph.svg" width="374" height="47"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe>
</div>
</div>

</div>
</div>
<a id="adfd8805e0d37556102cad7b191fee9a3" name="adfd8805e0d37556102cad7b191fee9a3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adfd8805e0d37556102cad7b191fee9a3">&#9670;&nbsp;</a></span>operator&gt;&gt;()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::istream &amp; operator&gt;&gt; </td>
          <td>(</td>
          <td class="paramtype">std::istream &amp;&#160;</td>
          <td class="paramname"><em>is</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classipc_1_1util_1_1Shared__name.html">Shared_name</a> &amp;&#160;</td>
          <td class="paramname"><em>val</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Reads <a class="el" href="classipc_1_1util_1_1Shared__name.html" title="String-wrapping abstraction representing a name uniquely distinguishing a kernel-persistent entity fr...">Shared_name</a> from the given <code>istream</code>; equivalent to reading <code>string</code> into <a class="el" href="classipc_1_1util_1_1Shared__name.html#ae89e1e061f87ffe0288514e254837595" title="Returns (sans copying) ref to immutable entire wrapped name string, suitable to pass into sys calls w...">Shared_name::str()</a>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">is</td><td>Stream to read. </td></tr>
    <tr><td class="paramname">val</td><td>Object to which to deserialize. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>is</code>. </dd></dl>

<p class="definition">Definition at line <a class="el" href="shared__name_8cpp_source.html#l00364">364</a> of file <a class="el" href="shared__name_8cpp_source.html">shared_name.cpp</a>.</p>

<p class="reference">References <a class="el" href="shared__name_8hpp_source.html#l00674">ct()</a>.</p>
<div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="classipc_1_1util_1_1Shared__name_adfd8805e0d37556102cad7b191fee9a3_cgraph.svg" width="370" height="47"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe>
</div>
</div>

</div>
</div>
<a id="a9ea22a64cfbc6de66181c278ff5f6975" name="a9ea22a64cfbc6de66181c278ff5f6975"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9ea22a64cfbc6de66181c278ff5f6975">&#9670;&nbsp;</a></span>swap <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void swap </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classipc_1_1util_1_1Shared__name.html">Shared_name</a> &amp;&#160;</td>
          <td class="paramname"><em>val1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classipc_1_1util_1_1Shared__name.html">Shared_name</a> &amp;&#160;</td>
          <td class="paramname"><em>val2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">friend</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Swaps two objects. </p>
<p >Constant-time. Suitable for standard ADL-swap pattern <code>using std::swap; swap(val1, val2);</code>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">val1</td><td>Object. </td></tr>
    <tr><td class="paramname">val2</td><td>Object. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="shared__name_8cpp_source.html#l00420">420</a> of file <a class="el" href="shared__name_8cpp_source.html">shared_name.cpp</a>.</p>

</div>
</div>
<a id="a9ea22a64cfbc6de66181c278ff5f6975" name="a9ea22a64cfbc6de66181c278ff5f6975"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9ea22a64cfbc6de66181c278ff5f6975">&#9670;&nbsp;</a></span>swap() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void swap </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classipc_1_1util_1_1Shared__name.html">Shared_name</a> &amp;&#160;</td>
          <td class="paramname"><em>val1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classipc_1_1util_1_1Shared__name.html">Shared_name</a> &amp;&#160;</td>
          <td class="paramname"><em>val2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Swaps two objects. </p>
<p >Constant-time. Suitable for standard ADL-swap pattern <code>using std::swap; swap(val1, val2);</code>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">val1</td><td>Object. </td></tr>
    <tr><td class="paramname">val2</td><td>Object. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="shared__name_8cpp_source.html#l00420">420</a> of file <a class="el" href="shared__name_8cpp_source.html">shared_name.cpp</a>.</p>

</div>
</div>
<h2 class="groupheader">Member Data Documentation</h2>
<a id="a4ebeee7fd046ca6ad405af6183dfb790" name="a4ebeee7fd046ca6ad405af6183dfb790"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4ebeee7fd046ca6ad405af6183dfb790">&#9670;&nbsp;</a></span>m_raw_name</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::string ipc::util::Shared_name::m_raw_name</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>The name or name fragment; see <a class="el" href="classipc_1_1util_1_1Shared__name.html#ae89e1e061f87ffe0288514e254837595" title="Returns (sans copying) ref to immutable entire wrapped name string, suitable to pass into sys calls w...">str()</a>. </p>
<dl class="todo"><dt><b><a class="el" href="todo.html#_todo000020">Todo:</a></b></dt><dd>Consider providing a ref-to-mutable accessor to <a class="el" href="classipc_1_1util_1_1Shared__name.html#a4ebeee7fd046ca6ad405af6183dfb790" title="The name or name fragment; see str().">Shared_name::m_raw_name</a> (or just make <code>public</code>). There are pros and cons; the basic pro being that <a class="el" href="classipc_1_1util_1_1Shared__name.html" title="String-wrapping abstraction representing a name uniquely distinguishing a kernel-persistent entity fr...">Shared_name</a> is meant to be a very thin wrapper around <code>std::string</code>, so it might make sense to allow for in-place modification without supplying some kind of reduced subset of <code>string</code> API. Suggest doing this to-do if a practical desire comes about. </dd></dl>

<p class="definition">Definition at line <a class="el" href="shared__name_8hpp_source.html#l00659">659</a> of file <a class="el" href="shared__name_8hpp_source.html">shared_name.hpp</a>.</p>

<p class="reference">Referenced by <a class="el" href="shared__name_8cpp_source.html#l00165">absolute()</a>, <a class="el" href="shared__name_8cpp_source.html#l00170">clear()</a>, <a class="el" href="shared__name_8cpp_source.html#l00052">ct()</a>, <a class="el" href="shared__name_8cpp_source.html#l00155">empty()</a>, <a class="el" href="shared__name_8cpp_source.html#l00160">has_trailing_separator()</a>, <a class="el" href="shared__name_8cpp_source.html#l00145">native_str()</a>, <a class="el" href="shared__name_8cpp_source.html#l00069">operator+=()</a>, <a class="el" href="shared__name_8hpp_source.html#l00696">operator/=()</a>, <a class="el" href="shared__name_8cpp_source.html#l00221">sanitize()</a>, <a class="el" href="shared__name_8cpp_source.html#l00175">sanitized()</a>, <a class="el" href="shared__name_8cpp_source.html#l00150">size()</a>, and <a class="el" href="shared__name_8cpp_source.html#l00140">str()</a>.</p>

</div>
</div>
<a id="aaa78ddb3efa5abe4fa80058dedbef68c" name="aaa78ddb3efa5abe4fa80058dedbef68c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaa78ddb3efa5abe4fa80058dedbef68c">&#9670;&nbsp;</a></span>S_1ST_OR_ONLY</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classipc_1_1util_1_1Shared__name.html">Shared_name</a> ipc::util::Shared_name::S_1ST_OR_ONLY = <a class="el" href="classipc_1_1util_1_1Shared__name.html#a48f20b7b54490aa10dc64081d34c55b2">Shared_name::ct</a>(&quot;1&quot;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>A <a class="el" href="classipc_1_1util_1_1Shared__name.html" title="String-wrapping abstraction representing a name uniquely distinguishing a kernel-persistent entity fr...">Shared_name</a> fragment, with no <a class="el" href="classipc_1_1util_1_1Shared__name.html#a5c0910497c5ec484d3e42dfb0ccad48d" title="Character we use, by convention, to separate conceptual folders within str().">S_SEPARATOR</a> characters inside, that represents a path component that (1) is not <a class="el" href="classipc_1_1util_1_1Shared__name.html#a43205a00865429c1bef6c7896816bf5c" title="A Shared_name fragment, with no S_SEPARATOR characters inside, that represents a path component that ...">S_SENTINEL</a> and (2) is suggested as the <em>first</em> or <em>only</em> unique ID of items at the same depth in the same context. </p>
<p >In actual fact it equals <code>1</code>; and typically (though not necessarily &ndash; other conventions may exist) generated strings shall be <code>1</code>, <code>2</code>, ..., of which the former is <a class="el" href="classipc_1_1util_1_1Shared__name.html#aaa78ddb3efa5abe4fa80058dedbef68c" title="A Shared_name fragment, with no S_SEPARATOR characters inside, that represents a path component that ...">S_1ST_OR_ONLY</a>.</p>
<p >So if <a class="el" href="classipc_1_1util_1_1Shared__name.html#a43205a00865429c1bef6c7896816bf5c" title="A Shared_name fragment, with no S_SEPARATOR characters inside, that represents a path component that ...">S_SENTINEL</a> means "not a thing" or "special thing to be treated not like a normal thing", then <a class="el" href="classipc_1_1util_1_1Shared__name.html#aaa78ddb3efa5abe4fa80058dedbef68c" title="A Shared_name fragment, with no S_SEPARATOR characters inside, that represents a path component that ...">S_1ST_OR_ONLY</a> means "a normal thing, of which there may be only one, and this is the first one
so created."</p>
<h3>Suggested use pattern</h3>
<p >This is most useful when, at this path level, you currently only have reason to have one object. Then you can name it <a class="el" href="classipc_1_1util_1_1Shared__name.html#aaa78ddb3efa5abe4fa80058dedbef68c" title="A Shared_name fragment, with no S_SEPARATOR characters inside, that represents a path component that ...">S_1ST_OR_ONLY</a> without relying on a magic string <code>1</code>. However, if in the future there is reason to add more objects at the same level, then remove the use of <code>S_1ST_OR_ONLY</code> and instead use a <code>uint</code> or <code>atomic&lt;uint&gt;</code> data member that starts at simply the numeric <code>1</code>, <code>++</code>ing it each time a new object is added (and converting it via <code>Shared_name::ct(std::to_string(x))</code> to string). The first object will have the same name as before, compatibly, while subsequent ones will be efficiently named uniquely.</p>
<p >Is this cheesy and reliant on the fact that this constant is, in fact, a string conversion of the number one? Yes, but the above pattern works and is reasonably efficient. I (ygoldfel) considered making this a super-general API that keeps generating unique IDs, but it just seemed like overkill given the simplicity of the task. Converting back from <a class="el" href="classipc_1_1util_1_1Shared__name.html" title="String-wrapping abstraction representing a name uniquely distinguishing a kernel-persistent entity fr...">Shared_name</a>, generating a new <code>++</code>ed one, then converting back &ndash; while providing a simple-enough API to ensure atomicity &ndash; seemed inferior to just letting people maintain a compatible <code>atomic&lt;uint&gt;</code>, when and if desired, and using <a class="el" href="classipc_1_1util_1_1Shared__name.html#aaa78ddb3efa5abe4fa80058dedbef68c" title="A Shared_name fragment, with no S_SEPARATOR characters inside, that represents a path component that ...">S_1ST_OR_ONLY</a> until then. </p>

<p class="definition">Definition at line <a class="el" href="shared__name_8hpp_source.html#l00309">309</a> of file <a class="el" href="shared__name_8hpp_source.html">shared_name.hpp</a>.</p>

<p class="reference">Referenced by <a class="el" href="ipc__shm_2src_2ipc_2session_2detail_2shm_2classic_2server__session__impl_8hpp_source.html#l00207">ipc::session::shm::classic::Server_session_impl&lt; S_MQ_TYPE_OR_NONE, S_TRANSMIT_NATIVE_HANDLES, Mdt_payload &gt;::async_accept_log_in()</a>, <a class="el" href="ipc__shm_2src_2ipc_2session_2detail_2shm_2classic_2client__session__impl_8hpp_source.html#l00175">ipc::session::shm::classic::Client_session_impl&lt; S_MQ_TYPE_OR_NONE, S_TRANSMIT_NATIVE_HANDLES, Mdt_payload &gt;::async_connect()</a>, and <a class="el" href="ipc__shm_2src_2ipc_2session_2shm_2classic_2session__server_8hpp_source.html#l00531">ipc::session::shm::classic::Session_server&lt; S_MQ_TYPE_OR_NONE, S_TRANSMIT_NATIVE_HANDLES, Mdt_payload &gt;::init_app_shm_as_needed()</a>.</p>

</div>
</div>
<a id="a5bbfb4d3b378cf7b9a1bcaf5d6c5a067" name="a5bbfb4d3b378cf7b9a1bcaf5d6c5a067"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5bbfb4d3b378cf7b9a1bcaf5d6c5a067">&#9670;&nbsp;</a></span>S_EMPTY</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classipc_1_1util_1_1Shared__name.html">Shared_name</a> ipc::util::Shared_name::S_EMPTY</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>A (default-cted) <a class="el" href="classipc_1_1util_1_1Shared__name.html" title="String-wrapping abstraction representing a name uniquely distinguishing a kernel-persistent entity fr...">Shared_name</a>. May be useful for functions returning <code>const <a class="el" href="classipc_1_1util_1_1Shared__name.html" title="String-wrapping abstraction representing a name uniquely distinguishing a kernel-persistent entity fr...">Shared_name</a>&amp;</code>. </p>

<p class="definition">Definition at line <a class="el" href="shared__name_8hpp_source.html#l00247">247</a> of file <a class="el" href="shared__name_8hpp_source.html">shared_name.hpp</a>.</p>

<p class="reference">Referenced by <a class="el" href="blob__stream__mq__rcv_8hpp_source.html#l00371">ipc::transport::Blob_stream_mq_receiver&lt; Persistent_mq_handle &gt;::absolute_name()</a>, <a class="el" href="blob__stream__mq__snd_8hpp_source.html#l00517">ipc::transport::Blob_stream_mq_sender&lt; Persistent_mq_handle &gt;::absolute_name()</a>, <a class="el" href="sync__io_2blob__stream__mq__rcv_8hpp_source.html#l00365">ipc::transport::sync_io::Blob_stream_mq_receiver&lt; Persistent_mq_handle &gt;::absolute_name()</a>, and <a class="el" href="sync__io_2blob__stream__mq__snd_8hpp_source.html#l00397">ipc::transport::sync_io::Blob_stream_mq_sender&lt; Persistent_mq_handle &gt;::absolute_name()</a>.</p>

</div>
</div>
<a id="afc9b87fc69d42df3107bf4a27ea66c7c" name="afc9b87fc69d42df3107bf4a27ea66c7c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afc9b87fc69d42df3107bf4a27ea66c7c">&#9670;&nbsp;</a></span>S_MAX_LENGTH</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const size_t ipc::util::Shared_name::S_MAX_LENGTH = 75</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Max value of <a class="el" href="classipc_1_1util_1_1Shared__name.html#af34db2934e116f8a4fdd403fd04695af" title="Returns str().size().">size()</a> such that, if <a class="el" href="classipc_1_1util_1_1Shared__name.html#ae89e1e061f87ffe0288514e254837595" title="Returns (sans copying) ref to immutable entire wrapped name string, suitable to pass into sys calls w...">str()</a> used to name a supported shared resource, sys call safely won't barf. </p>
<dl class="todo"><dt><b><a class="el" href="todo.html#_todo000018">Todo:</a></b></dt><dd><a class="el" href="classipc_1_1util_1_1Shared__name.html#afc9b87fc69d42df3107bf4a27ea66c7c" title="Max value of size() such that, if str() used to name a supported shared resource, sys call safely won...">Shared_name::S_MAX_LENGTH</a> currently applies to all shared resource types, but it'd be a useful feature to have different limits depending on OS/whatever limitations for particular resources types such as SHM object names versus queue names versus whatever.</dd></dl>
<dl class="todo"><dt><b><a class="el" href="todo.html#_todo000019">Todo:</a></b></dt><dd>Research real limits on <a class="el" href="classipc_1_1util_1_1Shared__name.html#afc9b87fc69d42df3107bf4a27ea66c7c" title="Max value of size() such that, if str() used to name a supported shared resource, sys call safely won...">Shared_name::S_MAX_LENGTH</a> for different real resource types; choose something for MAX_LENGTH that leaves enough slack to avoid running into trouble when making actual sys calls; as discussed in the at-internal section of <a class="el" href="classipc_1_1util_1_1Shared__name.html" title="String-wrapping abstraction representing a name uniquely distinguishing a kernel-persistent entity fr...">Shared_name</a> doc header about this topic. Explain here how we get to the limit ultimately chosen. The limit as of this writing is 64, but real research is needed. </dd></dl>

<p class="definition">Definition at line <a class="el" href="shared__name_8hpp_source.html#l00263">263</a> of file <a class="el" href="shared__name_8hpp_source.html">shared_name.hpp</a>.</p>

<p class="reference">Referenced by <a class="el" href="shared__name_8cpp_source.html#l00221">sanitize()</a>, and <a class="el" href="shared__name_8cpp_source.html#l00175">sanitized()</a>.</p>

</div>
</div>
<a id="a50cb5d2ad8f8b4391e1885e7b8f63890" name="a50cb5d2ad8f8b4391e1885e7b8f63890"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a50cb5d2ad8f8b4391e1885e7b8f63890">&#9670;&nbsp;</a></span>S_RESOURCE_TYPE_ID_MUTEX</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classipc_1_1util_1_1Shared__name.html">Shared_name</a> ipc::util::Shared_name::S_RESOURCE_TYPE_ID_MUTEX = <a class="el" href="classipc_1_1util_1_1Shared__name.html#a48f20b7b54490aa10dc64081d34c55b2">Shared_name::ct</a>(&quot;mtx&quot;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Relative-folder fragment (no separators) identifying the resource type for: boost.interprocess named mutex. </p>

<p class="definition">Definition at line <a class="el" href="shared__name_8hpp_source.html#l00315">315</a> of file <a class="el" href="shared__name_8hpp_source.html">shared_name.hpp</a>.</p>

<p class="reference">Referenced by <a class="el" href="session__base_8hpp_source.html#l00953">ipc::session::Session_base&lt; S_MQ_TYPE_OR_NONE, S_TRANSMIT_NATIVE_HANDLES, Mdt_payload &gt;::cur_ns_store_mutex_absolute_name()</a>.</p>

</div>
</div>
<a id="a4c294e23753eb706b4c297d99d24cd48" name="a4c294e23753eb706b4c297d99d24cd48"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4c294e23753eb706b4c297d99d24cd48">&#9670;&nbsp;</a></span>S_RESOURCE_TYPE_ID_SHM</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classipc_1_1util_1_1Shared__name.html">Shared_name</a> ipc::util::Shared_name::S_RESOURCE_TYPE_ID_SHM = <a class="el" href="classipc_1_1util_1_1Shared__name.html#a48f20b7b54490aa10dc64081d34c55b2">Shared_name::ct</a>(&quot;shm&quot;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Relative-folder fragment (no separators) identifying the resource type for: SHM pools. </p>

<p class="definition">Definition at line <a class="el" href="shared__name_8hpp_source.html#l00312">312</a> of file <a class="el" href="shared__name_8hpp_source.html">shared_name.hpp</a>.</p>

<p class="reference">Referenced by <a class="el" href="ipc__shm_2src_2ipc_2session_2detail_2shm_2classic_2server__session__impl_8hpp_source.html#l00207">ipc::session::shm::classic::Server_session_impl&lt; S_MQ_TYPE_OR_NONE, S_TRANSMIT_NATIVE_HANDLES, Mdt_payload &gt;::async_accept_log_in()</a>, <a class="el" href="ipc__shm_2src_2ipc_2session_2detail_2shm_2classic_2client__session__impl_8hpp_source.html#l00175">ipc::session::shm::classic::Client_session_impl&lt; S_MQ_TYPE_OR_NONE, S_TRANSMIT_NATIVE_HANDLES, Mdt_payload &gt;::async_connect()</a>, <a class="el" href="ipc__shm__arena__lend_2src_2ipc_2session_2detail_2shm_2arena__lend_2jemalloc_2client__session__impl_8hpp_source.html#l00471">ipc::session::shm::arena_lend::jemalloc::Client_session_impl&lt; S_MQ_TYPE_OR_NONE, S_TRANSMIT_NATIVE_HANDLES, Mdt_payload &gt;::cleanup()</a>, <a class="el" href="ipc__shm__arena__lend_2src_2ipc_2session_2shm_2arena__lend_2jemalloc_2session__server_8hpp_source.html#l00561">ipc::session::shm::arena_lend::jemalloc::Session_server&lt; S_MQ_TYPE_OR_NONE, S_TRANSMIT_NATIVE_HANDLES, Mdt_payload &gt;::cleanup()</a>, <a class="el" href="ipc__shm_2src_2ipc_2session_2shm_2classic_2session__server_8hpp_source.html#l00531">ipc::session::shm::classic::Session_server&lt; S_MQ_TYPE_OR_NONE, S_TRANSMIT_NATIVE_HANDLES, Mdt_payload &gt;::init_app_shm_as_needed()</a>, <a class="el" href="ipc__shm__arena__lend_2src_2ipc_2session_2shm_2arena__lend_2jemalloc_2session__server_8hpp_source.html#l00397">ipc::session::shm::arena_lend::jemalloc::Session_server&lt; S_MQ_TYPE_OR_NONE, S_TRANSMIT_NATIVE_HANDLES, Mdt_payload &gt;::init_app_shm_as_needed()</a>, <a class="el" href="arena__lend_2src_2ipc_2session_2detail_2shm_2arena__lend_2jemalloc_2session__impl_8hpp_source.html#l00270">ipc::session::shm::arena_lend::jemalloc::Session_impl&lt; Session_impl_t &gt;::init_shm()</a>, and <a class="el" href="blob__stream__mq__impl_8hpp_source.html#l00344">ipc::transport::Blob_stream_mq_base_impl&lt; Persistent_mq_handle &gt;::mq_sentinel_name()</a>.</p>

</div>
</div>
<a id="af08b45aa719d4f5dced595cca39ab2c8" name="af08b45aa719d4f5dced595cca39ab2c8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af08b45aa719d4f5dced595cca39ab2c8">&#9670;&nbsp;</a></span>S_ROOT_MAGIC</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classipc_1_1util_1_1Shared__name.html">Shared_name</a> ipc::util::Shared_name::S_ROOT_MAGIC = <a class="el" href="classipc_1_1util_1_1Shared__name.html#a48f20b7b54490aa10dc64081d34c55b2">Shared_name::ct</a>(&quot;libipc&quot;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>A <a class="el" href="classipc_1_1util_1_1Shared__name.html" title="String-wrapping abstraction representing a name uniquely distinguishing a kernel-persistent entity fr...">Shared_name</a> fragment, with no <a class="el" href="classipc_1_1util_1_1Shared__name.html#a5c0910497c5ec484d3e42dfb0ccad48d" title="Character we use, by convention, to separate conceptual folders within str().">S_SEPARATOR</a> characters inside, to be used in any <a class="el" href="classipc_1_1util_1_1Shared__name.html" title="String-wrapping abstraction representing a name uniquely distinguishing a kernel-persistent entity fr...">Shared_name</a> maintained by <a class="el" href="namespaceipc.html" title="Catch-all namespace for the Flow-IPC project: A library/API in modern C++17 providing high-performanc...">ipc</a> itself as the leading path component. </p>

<p class="definition">Definition at line <a class="el" href="shared__name_8hpp_source.html#l00272">272</a> of file <a class="el" href="shared__name_8hpp_source.html">shared_name.hpp</a>.</p>

<p class="reference">Referenced by <a class="el" href="shared__name_8cpp_source.html#l00337">ipc::util::build_conventional_non_session_based_shared_name()</a>, <a class="el" href="ipc__session_2src_2ipc_2session_2detail_2session__shared__name_8cpp_source.html#l00093">ipc::session::build_conventional_shared_name_prefix()</a>, and <a class="el" href="ipc__session_2src_2ipc_2session_2detail_2session__shared__name_8cpp_source.html#l00114">ipc::session::decompose_conventional_shared_name()</a>.</p>

</div>
</div>
<a id="a43205a00865429c1bef6c7896816bf5c" name="a43205a00865429c1bef6c7896816bf5c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a43205a00865429c1bef6c7896816bf5c">&#9670;&nbsp;</a></span>S_SENTINEL</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classipc_1_1util_1_1Shared__name.html">Shared_name</a> ipc::util::Shared_name::S_SENTINEL = <a class="el" href="classipc_1_1util_1_1Shared__name.html#a48f20b7b54490aa10dc64081d34c55b2">Shared_name::ct</a>(&quot;0&quot;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>A <a class="el" href="classipc_1_1util_1_1Shared__name.html" title="String-wrapping abstraction representing a name uniquely distinguishing a kernel-persistent entity fr...">Shared_name</a> fragment, with no <a class="el" href="classipc_1_1util_1_1Shared__name.html#a5c0910497c5ec484d3e42dfb0ccad48d" title="Character we use, by convention, to separate conceptual folders within str().">S_SEPARATOR</a> characters inside, that represents a path component that shall be different from any other generated string at the same path depth in the same context; and represents a sentinel. </p>
<p >In actual fact it equals <code>0</code>; and typically (though not necessarily &ndash; other conventions may exist) generated strings shall be <code>1</code>, <code>2</code>, ..., of which the former is <a class="el" href="classipc_1_1util_1_1Shared__name.html#aaa78ddb3efa5abe4fa80058dedbef68c" title="A Shared_name fragment, with no S_SEPARATOR characters inside, that represents a path component that ...">S_1ST_OR_ONLY</a>. </p>

<p class="definition">Definition at line <a class="el" href="shared__name_8hpp_source.html#l00280">280</a> of file <a class="el" href="shared__name_8hpp_source.html">shared_name.hpp</a>.</p>

<p class="reference">Referenced by <a class="el" href="shared__name_8cpp_source.html#l00337">ipc::util::build_conventional_non_session_based_shared_name()</a>, <a class="el" href="ipc__session_2src_2ipc_2session_2detail_2session__shared__name_8cpp_source.html#l00044">ipc::session::build_conventional_shared_name()</a>, <a class="el" href="ipc__session_2src_2ipc_2session_2detail_2session__shared__name_8cpp_source.html#l00093">ipc::session::build_conventional_shared_name_prefix()</a>, <a class="el" href="session__base_8hpp_source.html#l00953">ipc::session::Session_base&lt; S_MQ_TYPE_OR_NONE, S_TRANSMIT_NATIVE_HANDLES, Mdt_payload &gt;::cur_ns_store_mutex_absolute_name()</a>, <a class="el" href="ipc__session_2src_2ipc_2session_2detail_2session__shared__name_8cpp_source.html#l00114">ipc::session::decompose_conventional_shared_name()</a>, <a class="el" href="ipc__session_2src_2ipc_2session_2detail_2client__session__impl_8hpp_source.html#l01528">ipc::session::Client_session_impl&lt; S_MQ_TYPE_OR_NONE, S_TRANSMIT_NATIVE_HANDLES, Mdt_payload, S_SHM_TYPE_OR_NONE, S_GRACEFUL_FINISH_REQUIRED_V &gt;::on_master_channel_log_in_rsp()</a>, <a class="el" href="session__base_8hpp_source.html#l00999">ipc::session::Session_base&lt; S_MQ_TYPE_OR_NONE, S_TRANSMIT_NATIVE_HANDLES, Mdt_payload &gt;::session_master_socket_stream_acceptor_absolute_name()</a>, <a class="el" href="session__base_8hpp_source.html#l00880">ipc::session::Session_base&lt; S_MQ_TYPE_OR_NONE, S_TRANSMIT_NATIVE_HANDLES, Mdt_payload &gt;::set_cli_namespace()</a>, and <a class="el" href="session__base_8hpp_source.html#l00870">ipc::session::Session_base&lt; S_MQ_TYPE_OR_NONE, S_TRANSMIT_NATIVE_HANDLES, Mdt_payload &gt;::set_srv_namespace()</a>.</p>

</div>
</div>
<a id="a5c0910497c5ec484d3e42dfb0ccad48d" name="a5c0910497c5ec484d3e42dfb0ccad48d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5c0910497c5ec484d3e42dfb0ccad48d">&#9670;&nbsp;</a></span>S_SEPARATOR</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const char ipc::util::Shared_name::S_SEPARATOR = '_'</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Character we use, by convention, to separate conceptual folders within <a class="el" href="classipc_1_1util_1_1Shared__name.html#ae89e1e061f87ffe0288514e254837595" title="Returns (sans copying) ref to immutable entire wrapped name string, suitable to pass into sys calls w...">str()</a>. </p>

<p class="definition">Definition at line <a class="el" href="shared__name_8hpp_source.html#l00266">266</a> of file <a class="el" href="shared__name_8hpp_source.html">shared_name.hpp</a>.</p>

<p class="reference">Referenced by <a class="el" href="shared__name_8cpp_source.html#l00165">absolute()</a>, <a class="el" href="ipc__shm__arena__lend_2src_2ipc_2session_2detail_2shm_2arena__lend_2jemalloc_2client__session__impl_8hpp_source.html#l00471">ipc::session::shm::arena_lend::jemalloc::Client_session_impl&lt; S_MQ_TYPE_OR_NONE, S_TRANSMIT_NATIVE_HANDLES, Mdt_payload &gt;::cleanup()</a>, <a class="el" href="ipc__shm__arena__lend_2src_2ipc_2session_2shm_2arena__lend_2jemalloc_2session__server_8hpp_source.html#l00561">ipc::session::shm::arena_lend::jemalloc::Session_server&lt; S_MQ_TYPE_OR_NONE, S_TRANSMIT_NATIVE_HANDLES, Mdt_payload &gt;::cleanup()</a>, <a class="el" href="ipc__session_2src_2ipc_2session_2detail_2session__shared__name_8cpp_source.html#l00114">ipc::session::decompose_conventional_shared_name()</a>, <a class="el" href="shared__name_8cpp_source.html#l00160">has_trailing_separator()</a>, <a class="el" href="shared__name_8hpp_source.html#l00696">operator/=()</a>, <a class="el" href="shared__name_8cpp_source.html#l00221">sanitize()</a>, and <a class="el" href="shared__name_8cpp_source.html#l00175">sanitized()</a>.</p>

</div>
</div>
<hr/>The documentation for this class was generated from the following files:<ul>
<li>util/<a class="el" href="shared__name_8hpp_source.html">shared_name.hpp</a></li>
<li>util/<a class="el" href="shared__name_8cpp_source.html">shared_name.cpp</a></li>
<li>util/<a class="el" href="shared__name__fwd_8hpp_source.html">shared_name_fwd.hpp</a></li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Wed Mar 13 2024 09:08:24 for Flow-IPC by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.4
</small></address>
</body>
</html>
