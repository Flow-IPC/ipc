<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.9.4"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Flow-IPC: ipc::transport::Persistent_mq_handle Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">Flow-IPC<span id="projectnumber">&#160;1.0.2</span>
   </div>
   <div id="projectbrief">Flow-IPC project: Full implementation reference.</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.4 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search",'Search','.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespaceipc.html">ipc</a></li><li class="navelem"><a class="el" href="namespaceipc_1_1transport.html">transport</a></li><li class="navelem"><a class="el" href="classipc_1_1transport_1_1Persistent__mq__handle.html">Persistent_mq_handle</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pub-static-methods">Static Public Member Functions</a> &#124;
<a href="#pub-static-attribs">Static Public Attributes</a> &#124;
<a href="#related">Related Functions</a> &#124;
<a href="classipc_1_1transport_1_1Persistent__mq__handle-members.html">List of all members</a>  </div>
  <div class="headertitle"><div class="title">ipc::transport::Persistent_mq_handle Class Reference</div></div>
</div><!--header-->
<div class="contents">

<p>A documentation-only <em>concept</em> defining the behavior of an object representing a light-weight handle to a message queue, capable of receiving/sending discrete messages in non-blocking/blocking/timed-blocking fashion, as well as some support for polling/waiting and interruptions thereof.  
 <a href="classipc_1_1transport_1_1Persistent__mq__handle.html#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="persistent__mq__handle_8hpp_source.html">persistent_mq_handle.hpp</a>&gt;</code></p>
<div class="dynheader">
Collaboration diagram for ipc::transport::Persistent_mq_handle:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="classipc_1_1transport_1_1Persistent__mq__handle__coll__graph.svg" width="503" height="372"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe>
</div>
<center><span class="legend">[<a href="graph_legend.html">legend</a>]</span></center></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-methods" name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a22abfaa801a9e2f974a8cd179544d19a"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classipc_1_1transport_1_1Persistent__mq__handle.html#a22abfaa801a9e2f974a8cd179544d19a">Persistent_mq_handle</a> ()</td></tr>
<tr class="memdesc:a22abfaa801a9e2f974a8cd179544d19a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Construct null handle, suitable only for being subsequently moved-to or destroyed.  <a href="classipc_1_1transport_1_1Persistent__mq__handle.html#a22abfaa801a9e2f974a8cd179544d19a">More...</a><br /></td></tr>
<tr class="separator:a22abfaa801a9e2f974a8cd179544d19a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a341076bd3ac7e32e4d1fa12570a11fd2"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classipc_1_1transport_1_1Persistent__mq__handle.html#a341076bd3ac7e32e4d1fa12570a11fd2">Persistent_mq_handle</a> (flow::log::Logger *logger_ptr, const <a class="el" href="namespaceipc_1_1transport.html#a33de1c256addb3964b839dc2dd407d24">Shared_name</a> &amp;<a class="el" href="classipc_1_1transport_1_1Persistent__mq__handle.html#a5ef74ca74a9d985710af974fd6518940">absolute_name</a>, <a class="el" href="namespaceipc_1_1util.html#a9d84c2bab504e6de32b20c77ca9723a2">util::Create_only</a> mode_tag, size_t max_n_msg, size_t max_msg_sz, const <a class="el" href="namespaceipc_1_1util.html#a1b398ae730d1e6040687cb2397115152">util::Permissions</a> &amp;perms=<a class="el" href="namespaceipc_1_1util.html#a1b398ae730d1e6040687cb2397115152">util::Permissions</a>(), <a class="el" href="namespaceipc.html#aa3192e586cc45d3e7c22463bf2760f89">Error_code</a> *err_code=0)</td></tr>
<tr class="memdesc:a341076bd3ac7e32e4d1fa12570a11fd2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Construct handle to non-existing named MQ, creating it first.  <a href="classipc_1_1transport_1_1Persistent__mq__handle.html#a341076bd3ac7e32e4d1fa12570a11fd2">More...</a><br /></td></tr>
<tr class="separator:a341076bd3ac7e32e4d1fa12570a11fd2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af20035c875572ed018427322c845b9f9"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classipc_1_1transport_1_1Persistent__mq__handle.html#af20035c875572ed018427322c845b9f9">Persistent_mq_handle</a> (flow::log::Logger *logger_ptr, const <a class="el" href="namespaceipc_1_1transport.html#a33de1c256addb3964b839dc2dd407d24">Shared_name</a> &amp;<a class="el" href="classipc_1_1transport_1_1Persistent__mq__handle.html#a5ef74ca74a9d985710af974fd6518940">absolute_name</a>, <a class="el" href="namespaceipc_1_1util.html#a9571de958538d7a4a8649bbfecfac0b9">util::Open_or_create</a> mode_tag, size_t max_n_msg_on_create, size_t max_msg_sz_on_create, const <a class="el" href="namespaceipc_1_1util.html#a1b398ae730d1e6040687cb2397115152">util::Permissions</a> &amp;perms_on_create=<a class="el" href="namespaceipc_1_1util.html#a1b398ae730d1e6040687cb2397115152">util::Permissions</a>(), <a class="el" href="namespaceipc.html#aa3192e586cc45d3e7c22463bf2760f89">Error_code</a> *err_code=0)</td></tr>
<tr class="memdesc:af20035c875572ed018427322c845b9f9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Construct handle to existing named MQ, or else if it does not exist creates it first and opens it (atomically).  <a href="classipc_1_1transport_1_1Persistent__mq__handle.html#af20035c875572ed018427322c845b9f9">More...</a><br /></td></tr>
<tr class="separator:af20035c875572ed018427322c845b9f9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af74d564d34874d1b86c043dfb7406048"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classipc_1_1transport_1_1Persistent__mq__handle.html#af74d564d34874d1b86c043dfb7406048">Persistent_mq_handle</a> (flow::log::Logger *logger_ptr, const <a class="el" href="namespaceipc_1_1transport.html#a33de1c256addb3964b839dc2dd407d24">Shared_name</a> &amp;<a class="el" href="classipc_1_1transport_1_1Persistent__mq__handle.html#a5ef74ca74a9d985710af974fd6518940">absolute_name</a>, <a class="el" href="namespaceipc_1_1util.html#a3e03491b5b2b5fac26551a220946d6e5">util::Open_only</a> mode_tag, <a class="el" href="namespaceipc.html#aa3192e586cc45d3e7c22463bf2760f89">Error_code</a> *err_code=0)</td></tr>
<tr class="memdesc:af74d564d34874d1b86c043dfb7406048"><td class="mdescLeft">&#160;</td><td class="mdescRight">Construct handle to existing named MQ.  <a href="classipc_1_1transport_1_1Persistent__mq__handle.html#af74d564d34874d1b86c043dfb7406048">More...</a><br /></td></tr>
<tr class="separator:af74d564d34874d1b86c043dfb7406048"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a65d294e8972436e1193fe02baa34b20d"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classipc_1_1transport_1_1Persistent__mq__handle.html#a65d294e8972436e1193fe02baa34b20d">Persistent_mq_handle</a> (<a class="el" href="classipc_1_1transport_1_1Persistent__mq__handle.html">Persistent_mq_handle</a> &amp;&amp;src)</td></tr>
<tr class="memdesc:a65d294e8972436e1193fe02baa34b20d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructs handle from the source handle while making the latter invalid.  <a href="classipc_1_1transport_1_1Persistent__mq__handle.html#a65d294e8972436e1193fe02baa34b20d">More...</a><br /></td></tr>
<tr class="separator:a65d294e8972436e1193fe02baa34b20d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae58b5d8b275dc364a0abeaf36c6a4534"><td class="memItemLeft" align="right" valign="top"><a id="ae58b5d8b275dc364a0abeaf36c6a4534" name="ae58b5d8b275dc364a0abeaf36c6a4534"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>Persistent_mq_handle</b> (const <a class="el" href="classipc_1_1transport_1_1Persistent__mq__handle.html">Persistent_mq_handle</a> &amp;)=delete</td></tr>
<tr class="memdesc:ae58b5d8b275dc364a0abeaf36c6a4534"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copying of handles is prohibited. <br /></td></tr>
<tr class="separator:ae58b5d8b275dc364a0abeaf36c6a4534"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1fbb936f8f80fedcb1227794ef0a451b"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classipc_1_1transport_1_1Persistent__mq__handle.html#a1fbb936f8f80fedcb1227794ef0a451b">~Persistent_mq_handle</a> ()</td></tr>
<tr class="memdesc:a1fbb936f8f80fedcb1227794ef0a451b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Destroys this handle (or no-op if no handle was successfully constructed, or if it's a moved-from or default-cted handle).  <a href="classipc_1_1transport_1_1Persistent__mq__handle.html#a1fbb936f8f80fedcb1227794ef0a451b">More...</a><br /></td></tr>
<tr class="separator:a1fbb936f8f80fedcb1227794ef0a451b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a30b2d1fdc3cae55c9c1fe8a1014247ff"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classipc_1_1transport_1_1Persistent__mq__handle.html">Persistent_mq_handle</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classipc_1_1transport_1_1Persistent__mq__handle.html#a30b2d1fdc3cae55c9c1fe8a1014247ff">operator=</a> (<a class="el" href="classipc_1_1transport_1_1Persistent__mq__handle.html">Persistent_mq_handle</a> &amp;&amp;src)</td></tr>
<tr class="memdesc:a30b2d1fdc3cae55c9c1fe8a1014247ff"><td class="mdescLeft">&#160;</td><td class="mdescRight">Replaces handle with the source handle while making the latter invalid.  <a href="classipc_1_1transport_1_1Persistent__mq__handle.html#a30b2d1fdc3cae55c9c1fe8a1014247ff">More...</a><br /></td></tr>
<tr class="separator:a30b2d1fdc3cae55c9c1fe8a1014247ff"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af19038ecd7b1ab5b579d011345cef62b"><td class="memItemLeft" align="right" valign="top"><a id="af19038ecd7b1ab5b579d011345cef62b" name="af19038ecd7b1ab5b579d011345cef62b"></a>
<a class="el" href="classipc_1_1transport_1_1Persistent__mq__handle.html">Persistent_mq_handle</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>operator=</b> (const <a class="el" href="classipc_1_1transport_1_1Persistent__mq__handle.html">Persistent_mq_handle</a> &amp;)=delete</td></tr>
<tr class="memdesc:af19038ecd7b1ab5b579d011345cef62b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copying of handles is prohibited. <br /></td></tr>
<tr class="separator:af19038ecd7b1ab5b579d011345cef62b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad9d38e0e16931dd96738d53b787533a1"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classipc_1_1transport_1_1Persistent__mq__handle.html#ad9d38e0e16931dd96738d53b787533a1">try_send</a> (const <a class="el" href="namespaceipc_1_1util.html#ae0be7edba7e30ffa3f8b742af621f2ab">util::Blob_const</a> &amp;blob, <a class="el" href="namespaceipc.html#aa3192e586cc45d3e7c22463bf2760f89">Error_code</a> *err_code=0)</td></tr>
<tr class="memdesc:ad9d38e0e16931dd96738d53b787533a1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Non-blocking send: pushes copy of message to queue and returns <code>true</code>; if queue is full then no-op and returns <code>false</code>.  <a href="classipc_1_1transport_1_1Persistent__mq__handle.html#ad9d38e0e16931dd96738d53b787533a1">More...</a><br /></td></tr>
<tr class="separator:ad9d38e0e16931dd96738d53b787533a1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9d54e47b729eec9f72dee869326bfa8f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classipc_1_1transport_1_1Persistent__mq__handle.html#a9d54e47b729eec9f72dee869326bfa8f">send</a> (const <a class="el" href="namespaceipc_1_1util.html#ae0be7edba7e30ffa3f8b742af621f2ab">util::Blob_const</a> &amp;blob, <a class="el" href="namespaceipc.html#aa3192e586cc45d3e7c22463bf2760f89">Error_code</a> *err_code=0)</td></tr>
<tr class="memdesc:a9d54e47b729eec9f72dee869326bfa8f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Blocking send: pushes copy of message to queue; if queue is full blocks until it is not.  <a href="classipc_1_1transport_1_1Persistent__mq__handle.html#a9d54e47b729eec9f72dee869326bfa8f">More...</a><br /></td></tr>
<tr class="separator:a9d54e47b729eec9f72dee869326bfa8f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab4cba10b83df79acf76c64b0deb7f624"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classipc_1_1transport_1_1Persistent__mq__handle.html#ab4cba10b83df79acf76c64b0deb7f624">timed_send</a> (const <a class="el" href="namespaceipc_1_1util.html#ae0be7edba7e30ffa3f8b742af621f2ab">util::Blob_const</a> &amp;blob, <a class="el" href="namespaceipc_1_1util.html#ac66141280c3b7295a86b65209f31cc58">util::Fine_duration</a> timeout_from_now, <a class="el" href="namespaceipc.html#aa3192e586cc45d3e7c22463bf2760f89">Error_code</a> *err_code=0)</td></tr>
<tr class="memdesc:ab4cba10b83df79acf76c64b0deb7f624"><td class="mdescLeft">&#160;</td><td class="mdescRight">Blocking timed send: pushes copy of message to queue; if queue is full blocks until it is not, or the specified time passes, whichever happens first.  <a href="classipc_1_1transport_1_1Persistent__mq__handle.html#ab4cba10b83df79acf76c64b0deb7f624">More...</a><br /></td></tr>
<tr class="separator:ab4cba10b83df79acf76c64b0deb7f624"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab95e3d32a7ad3fa3630ba54442d8f2ee"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classipc_1_1transport_1_1Persistent__mq__handle.html#ab95e3d32a7ad3fa3630ba54442d8f2ee">is_sendable</a> (<a class="el" href="namespaceipc.html#aa3192e586cc45d3e7c22463bf2760f89">Error_code</a> *err_code=0)</td></tr>
<tr class="memdesc:ab95e3d32a7ad3fa3630ba54442d8f2ee"><td class="mdescLeft">&#160;</td><td class="mdescRight">Equivalent to <a class="el" href="classipc_1_1transport_1_1Persistent__mq__handle.html#ad9d38e0e16931dd96738d53b787533a1" title="Non-blocking send: pushes copy of message to queue and returns true; if queue is full then no-op and ...">try_send()</a> except stops short of writing anything, with <code>true</code> result indicating that <a class="el" href="classipc_1_1transport_1_1Persistent__mq__handle.html#ad9d38e0e16931dd96738d53b787533a1" title="Non-blocking send: pushes copy of message to queue and returns true; if queue is full then no-op and ...">try_send()</a> <em>would</em> work at that moment.  <a href="classipc_1_1transport_1_1Persistent__mq__handle.html#ab95e3d32a7ad3fa3630ba54442d8f2ee">More...</a><br /></td></tr>
<tr class="separator:ab95e3d32a7ad3fa3630ba54442d8f2ee"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a230060aa545bfe11eb263211c84514f1"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classipc_1_1transport_1_1Persistent__mq__handle.html#a230060aa545bfe11eb263211c84514f1">wait_sendable</a> (<a class="el" href="namespaceipc.html#aa3192e586cc45d3e7c22463bf2760f89">Error_code</a> *err_code=0)</td></tr>
<tr class="memdesc:a230060aa545bfe11eb263211c84514f1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Equivalent to <a class="el" href="classipc_1_1transport_1_1Persistent__mq__handle.html#a9d54e47b729eec9f72dee869326bfa8f" title="Blocking send: pushes copy of message to queue; if queue is full blocks until it is not.">send()</a> except stops short of writing anything, with non-error return indicating that <a class="el" href="classipc_1_1transport_1_1Persistent__mq__handle.html#ad9d38e0e16931dd96738d53b787533a1" title="Non-blocking send: pushes copy of message to queue and returns true; if queue is full then no-op and ...">try_send()</a> <em>would</em> work at that moment.  <a href="classipc_1_1transport_1_1Persistent__mq__handle.html#a230060aa545bfe11eb263211c84514f1">More...</a><br /></td></tr>
<tr class="separator:a230060aa545bfe11eb263211c84514f1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aadfffb71ff2fec6508174fdf4b08327e"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classipc_1_1transport_1_1Persistent__mq__handle.html#aadfffb71ff2fec6508174fdf4b08327e">timed_wait_sendable</a> (<a class="el" href="namespaceipc_1_1util.html#ac66141280c3b7295a86b65209f31cc58">util::Fine_duration</a> timeout_from_now, <a class="el" href="namespaceipc.html#aa3192e586cc45d3e7c22463bf2760f89">Error_code</a> *err_code=0)</td></tr>
<tr class="memdesc:aadfffb71ff2fec6508174fdf4b08327e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Equivalent to <a class="el" href="classipc_1_1transport_1_1Persistent__mq__handle.html#ab4cba10b83df79acf76c64b0deb7f624" title="Blocking timed send: pushes copy of message to queue; if queue is full blocks until it is not,...">timed_send()</a> except stops short of writing anything, with <code>true</code> result indicating that <a class="el" href="classipc_1_1transport_1_1Persistent__mq__handle.html#ad9d38e0e16931dd96738d53b787533a1" title="Non-blocking send: pushes copy of message to queue and returns true; if queue is full then no-op and ...">try_send()</a> <em>would</em> work at that moment.  <a href="classipc_1_1transport_1_1Persistent__mq__handle.html#aadfffb71ff2fec6508174fdf4b08327e">More...</a><br /></td></tr>
<tr class="separator:aadfffb71ff2fec6508174fdf4b08327e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a84f802c77b0ce93d59e7ac78839f14cc"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classipc_1_1transport_1_1Persistent__mq__handle.html#a84f802c77b0ce93d59e7ac78839f14cc">try_receive</a> (<a class="el" href="namespaceipc_1_1util.html#a6cb62ae434900f3a8915b33ec5d61a96">util::Blob_mutable</a> *blob, <a class="el" href="namespaceipc.html#aa3192e586cc45d3e7c22463bf2760f89">Error_code</a> *err_code=0)</td></tr>
<tr class="memdesc:a84f802c77b0ce93d59e7ac78839f14cc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Non-blocking receive: pops copy of message from queue into buffer and returns <code>true</code>; if queue is empty then no-op and returns <code>false</code>.  <a href="classipc_1_1transport_1_1Persistent__mq__handle.html#a84f802c77b0ce93d59e7ac78839f14cc">More...</a><br /></td></tr>
<tr class="separator:a84f802c77b0ce93d59e7ac78839f14cc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae1e6822d16d30dc57c95e3e051e5f8a8"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classipc_1_1transport_1_1Persistent__mq__handle.html#ae1e6822d16d30dc57c95e3e051e5f8a8">receive</a> (<a class="el" href="namespaceipc_1_1util.html#a6cb62ae434900f3a8915b33ec5d61a96">util::Blob_mutable</a> *blob, <a class="el" href="namespaceipc.html#aa3192e586cc45d3e7c22463bf2760f89">Error_code</a> *err_code=0)</td></tr>
<tr class="memdesc:ae1e6822d16d30dc57c95e3e051e5f8a8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Blocking receive: pops copy of message from queue into buffer; if queue is empty blocks until it is not.  <a href="classipc_1_1transport_1_1Persistent__mq__handle.html#ae1e6822d16d30dc57c95e3e051e5f8a8">More...</a><br /></td></tr>
<tr class="separator:ae1e6822d16d30dc57c95e3e051e5f8a8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af547b6f1b1e51a7d6f6fbafc14c95f9d"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classipc_1_1transport_1_1Persistent__mq__handle.html#af547b6f1b1e51a7d6f6fbafc14c95f9d">timed_receive</a> (<a class="el" href="namespaceipc_1_1util.html#a6cb62ae434900f3a8915b33ec5d61a96">util::Blob_mutable</a> *blob, <a class="el" href="namespaceipc_1_1util.html#ac66141280c3b7295a86b65209f31cc58">util::Fine_duration</a> timeout_from_now, <a class="el" href="namespaceipc.html#aa3192e586cc45d3e7c22463bf2760f89">Error_code</a> *err_code=0)</td></tr>
<tr class="memdesc:af547b6f1b1e51a7d6f6fbafc14c95f9d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Blocking timed receive: pops copy of message from queue into buffer; if queue is empty blocks until it is not, or the specified time passes, whichever happens first.  <a href="classipc_1_1transport_1_1Persistent__mq__handle.html#af547b6f1b1e51a7d6f6fbafc14c95f9d">More...</a><br /></td></tr>
<tr class="separator:af547b6f1b1e51a7d6f6fbafc14c95f9d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acdf4279219020020b1d8b3ff8a80cbe2"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classipc_1_1transport_1_1Persistent__mq__handle.html#acdf4279219020020b1d8b3ff8a80cbe2">is_receivable</a> (<a class="el" href="namespaceipc.html#aa3192e586cc45d3e7c22463bf2760f89">Error_code</a> *err_code=0)</td></tr>
<tr class="memdesc:acdf4279219020020b1d8b3ff8a80cbe2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Equivalent to <a class="el" href="classipc_1_1transport_1_1Persistent__mq__handle.html#a84f802c77b0ce93d59e7ac78839f14cc" title="Non-blocking receive: pops copy of message from queue into buffer and returns true; if queue is empty...">try_receive()</a> except stops short of reading anything, with <code>true</code> result indicating that <a class="el" href="classipc_1_1transport_1_1Persistent__mq__handle.html#a84f802c77b0ce93d59e7ac78839f14cc" title="Non-blocking receive: pops copy of message from queue into buffer and returns true; if queue is empty...">try_receive()</a> <em>would</em> work at that moment.  <a href="classipc_1_1transport_1_1Persistent__mq__handle.html#acdf4279219020020b1d8b3ff8a80cbe2">More...</a><br /></td></tr>
<tr class="separator:acdf4279219020020b1d8b3ff8a80cbe2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7029f9601aa268022bd8cf7970c512c8"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classipc_1_1transport_1_1Persistent__mq__handle.html#a7029f9601aa268022bd8cf7970c512c8">wait_receivable</a> (<a class="el" href="namespaceipc.html#aa3192e586cc45d3e7c22463bf2760f89">Error_code</a> *err_code=0)</td></tr>
<tr class="memdesc:a7029f9601aa268022bd8cf7970c512c8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Equivalent to <a class="el" href="classipc_1_1transport_1_1Persistent__mq__handle.html#ae1e6822d16d30dc57c95e3e051e5f8a8" title="Blocking receive: pops copy of message from queue into buffer; if queue is empty blocks until it is n...">receive()</a> except stops short of reading anything, with non-error return indicating that <a class="el" href="classipc_1_1transport_1_1Persistent__mq__handle.html#a84f802c77b0ce93d59e7ac78839f14cc" title="Non-blocking receive: pops copy of message from queue into buffer and returns true; if queue is empty...">try_receive()</a> <em>would</em> work at that moment.  <a href="classipc_1_1transport_1_1Persistent__mq__handle.html#a7029f9601aa268022bd8cf7970c512c8">More...</a><br /></td></tr>
<tr class="separator:a7029f9601aa268022bd8cf7970c512c8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac4f13853e38ade577faabbf9ef0af74f"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classipc_1_1transport_1_1Persistent__mq__handle.html#ac4f13853e38ade577faabbf9ef0af74f">timed_wait_receivable</a> (<a class="el" href="namespaceipc_1_1util.html#ac66141280c3b7295a86b65209f31cc58">util::Fine_duration</a> timeout_from_now, <a class="el" href="namespaceipc.html#aa3192e586cc45d3e7c22463bf2760f89">Error_code</a> *err_code=0)</td></tr>
<tr class="memdesc:ac4f13853e38ade577faabbf9ef0af74f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Equivalent to <a class="el" href="classipc_1_1transport_1_1Persistent__mq__handle.html#af547b6f1b1e51a7d6f6fbafc14c95f9d" title="Blocking timed receive: pops copy of message from queue into buffer; if queue is empty blocks until i...">timed_receive()</a> except stops short of reading anything, with <code>true</code> result indicating that <a class="el" href="classipc_1_1transport_1_1Persistent__mq__handle.html#a84f802c77b0ce93d59e7ac78839f14cc" title="Non-blocking receive: pops copy of message from queue into buffer and returns true; if queue is empty...">try_receive()</a> <em>would</em> work at that moment.  <a href="classipc_1_1transport_1_1Persistent__mq__handle.html#ac4f13853e38ade577faabbf9ef0af74f">More...</a><br /></td></tr>
<tr class="separator:ac4f13853e38ade577faabbf9ef0af74f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af7a883553df39b16047b49942bd734c0"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classipc_1_1transport_1_1Persistent__mq__handle.html#af7a883553df39b16047b49942bd734c0">interrupt_sends</a> ()</td></tr>
<tr class="memdesc:af7a883553df39b16047b49942bd734c0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Enables sends-interrupted mode: <a class="el" href="classipc_1_1transport_1_1Persistent__mq__handle.html#ab95e3d32a7ad3fa3630ba54442d8f2ee" title="Equivalent to try_send() except stops short of writing anything, with true result indicating that try...">is_sendable()</a> (future calls), <a class="el" href="classipc_1_1transport_1_1Persistent__mq__handle.html#a9d54e47b729eec9f72dee869326bfa8f" title="Blocking send: pushes copy of message to queue; if queue is full blocks until it is not.">send()</a> (future or concurrent calls), <a class="el" href="classipc_1_1transport_1_1Persistent__mq__handle.html#ab4cba10b83df79acf76c64b0deb7f624" title="Blocking timed send: pushes copy of message to queue; if queue is full blocks until it is not,...">timed_send()</a> (ditto), <a class="el" href="classipc_1_1transport_1_1Persistent__mq__handle.html#a230060aa545bfe11eb263211c84514f1" title="Equivalent to send() except stops short of writing anything, with non-error return indicating that tr...">wait_sendable()</a> (ditto), <a class="el" href="classipc_1_1transport_1_1Persistent__mq__handle.html#aadfffb71ff2fec6508174fdf4b08327e" title="Equivalent to timed_send() except stops short of writing anything, with true result indicating that t...">timed_wait_sendable()</a> (ditto) shall emit <a class="el" href="namespaceipc_1_1transport_1_1error.html#adfef15ef4e76cc55d652fbd9c2797297a291f8a813c292ccdb475c345181653ac" title="A blocking operation was intentionally interrupted or preemptively canceled.">error::Code::S_INTERRUPTED</a> as soon as possible.  <a href="classipc_1_1transport_1_1Persistent__mq__handle.html#af7a883553df39b16047b49942bd734c0">More...</a><br /></td></tr>
<tr class="separator:af7a883553df39b16047b49942bd734c0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af43b22d89c5a228c2a72c321c2e24545"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classipc_1_1transport_1_1Persistent__mq__handle.html#af43b22d89c5a228c2a72c321c2e24545">allow_sends</a> ()</td></tr>
<tr class="memdesc:af43b22d89c5a228c2a72c321c2e24545"><td class="mdescLeft">&#160;</td><td class="mdescRight">Disables mode enabled by <a class="el" href="classipc_1_1transport_1_1Persistent__mq__handle.html#af7a883553df39b16047b49942bd734c0" title="Enables sends-interrupted mode: is_sendable() (future calls), send() (future or concurrent calls),...">interrupt_sends()</a>.  <a href="classipc_1_1transport_1_1Persistent__mq__handle.html#af43b22d89c5a228c2a72c321c2e24545">More...</a><br /></td></tr>
<tr class="separator:af43b22d89c5a228c2a72c321c2e24545"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a206333d3eb619588d17812f8f49013a2"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classipc_1_1transport_1_1Persistent__mq__handle.html#a206333d3eb619588d17812f8f49013a2">interrupt_receives</a> ()</td></tr>
<tr class="memdesc:a206333d3eb619588d17812f8f49013a2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Enables receives-interrupted mode: <a class="el" href="classipc_1_1transport_1_1Persistent__mq__handle.html#acdf4279219020020b1d8b3ff8a80cbe2" title="Equivalent to try_receive() except stops short of reading anything, with true result indicating that ...">is_receivable()</a> (future calls), <a class="el" href="classipc_1_1transport_1_1Persistent__mq__handle.html#ae1e6822d16d30dc57c95e3e051e5f8a8" title="Blocking receive: pops copy of message from queue into buffer; if queue is empty blocks until it is n...">receive()</a> (future or concurrent calls), <a class="el" href="classipc_1_1transport_1_1Persistent__mq__handle.html#af547b6f1b1e51a7d6f6fbafc14c95f9d" title="Blocking timed receive: pops copy of message from queue into buffer; if queue is empty blocks until i...">timed_receive()</a> (ditto), <a class="el" href="classipc_1_1transport_1_1Persistent__mq__handle.html#a7029f9601aa268022bd8cf7970c512c8" title="Equivalent to receive() except stops short of reading anything, with non-error return indicating that...">wait_receivable()</a> (ditto), <a class="el" href="classipc_1_1transport_1_1Persistent__mq__handle.html#ac4f13853e38ade577faabbf9ef0af74f" title="Equivalent to timed_receive() except stops short of reading anything, with true result indicating tha...">timed_wait_receivable()</a> (ditto) shall emit <a class="el" href="namespaceipc_1_1transport_1_1error.html#adfef15ef4e76cc55d652fbd9c2797297a291f8a813c292ccdb475c345181653ac" title="A blocking operation was intentionally interrupted or preemptively canceled.">error::Code::S_INTERRUPTED</a> as soon as possible.  <a href="classipc_1_1transport_1_1Persistent__mq__handle.html#a206333d3eb619588d17812f8f49013a2">More...</a><br /></td></tr>
<tr class="separator:a206333d3eb619588d17812f8f49013a2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaedc972e2ce207875a3e7262f9064b65"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classipc_1_1transport_1_1Persistent__mq__handle.html#aaedc972e2ce207875a3e7262f9064b65">allow_receives</a> ()</td></tr>
<tr class="memdesc:aaedc972e2ce207875a3e7262f9064b65"><td class="mdescLeft">&#160;</td><td class="mdescRight">Disables mode enabled by <a class="el" href="classipc_1_1transport_1_1Persistent__mq__handle.html#a206333d3eb619588d17812f8f49013a2" title="Enables receives-interrupted mode: is_receivable() (future calls), receive() (future or concurrent ca...">interrupt_receives()</a>.  <a href="classipc_1_1transport_1_1Persistent__mq__handle.html#aaedc972e2ce207875a3e7262f9064b65">More...</a><br /></td></tr>
<tr class="separator:aaedc972e2ce207875a3e7262f9064b65"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5ef74ca74a9d985710af974fd6518940"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="namespaceipc_1_1transport.html#a33de1c256addb3964b839dc2dd407d24">Shared_name</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classipc_1_1transport_1_1Persistent__mq__handle.html#a5ef74ca74a9d985710af974fd6518940">absolute_name</a> () const</td></tr>
<tr class="memdesc:a5ef74ca74a9d985710af974fd6518940"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns name equal to <code>absolute_name</code> passed to ctor.  <a href="classipc_1_1transport_1_1Persistent__mq__handle.html#a5ef74ca74a9d985710af974fd6518940">More...</a><br /></td></tr>
<tr class="separator:a5ef74ca74a9d985710af974fd6518940"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae2efe92707c53c46bc70b84f96bda217"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classipc_1_1transport_1_1Persistent__mq__handle.html#ae2efe92707c53c46bc70b84f96bda217">max_msg_size</a> () const</td></tr>
<tr class="memdesc:ae2efe92707c53c46bc70b84f96bda217"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the max message size of the underlying queue.  <a href="classipc_1_1transport_1_1Persistent__mq__handle.html#ae2efe92707c53c46bc70b84f96bda217">More...</a><br /></td></tr>
<tr class="separator:ae2efe92707c53c46bc70b84f96bda217"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a22575a5750d322ccf87a923a3d662756"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classipc_1_1transport_1_1Persistent__mq__handle.html#a22575a5750d322ccf87a923a3d662756">max_n_msgs</a> () const</td></tr>
<tr class="memdesc:a22575a5750d322ccf87a923a3d662756"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the max message count of the underlying queue.  <a href="classipc_1_1transport_1_1Persistent__mq__handle.html#a22575a5750d322ccf87a923a3d662756">More...</a><br /></td></tr>
<tr class="separator:a22575a5750d322ccf87a923a3d662756"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a25e96c4f060cc3c4b611c4e2de60abaf"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespaceipc_1_1transport.html#a7ee4551983d9df16ec16a3139bac50e8">Native_handle</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classipc_1_1transport_1_1Persistent__mq__handle.html#a25e96c4f060cc3c4b611c4e2de60abaf">native_handle</a> () const</td></tr>
<tr class="memdesc:a25e96c4f060cc3c4b611c4e2de60abaf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Available if and only if <a class="el" href="classipc_1_1transport_1_1Persistent__mq__handle.html#ac2c0b560893c6a8b71aac0e748770076" title="true if and only if native_handle() method exists, and the returned value may be waited-on by poll()/...">S_HAS_NATIVE_HANDLE</a> is <code>true</code>: Returns the stored native MQ handle; null means a constructor failed, or <code>*this</code> has been moved-from, hence the handle is to not-a-queue.  <a href="classipc_1_1transport_1_1Persistent__mq__handle.html#a25e96c4f060cc3c4b611c4e2de60abaf">More...</a><br /></td></tr>
<tr class="separator:a25e96c4f060cc3c4b611c4e2de60abaf"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-static-methods" name="pub-static-methods"></a>
Static Public Member Functions</h2></td></tr>
<tr class="memitem:a2e8b8102fdbacc064d4759533a725f51"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classipc_1_1transport_1_1Persistent__mq__handle.html#a2e8b8102fdbacc064d4759533a725f51">remove_persistent</a> (flow::log::Logger *logger_ptr, const <a class="el" href="namespaceipc_1_1transport.html#a33de1c256addb3964b839dc2dd407d24">Shared_name</a> &amp;name, <a class="el" href="namespaceipc.html#aa3192e586cc45d3e7c22463bf2760f89">Error_code</a> *err_code=0)</td></tr>
<tr class="memdesc:a2e8b8102fdbacc064d4759533a725f51"><td class="mdescLeft">&#160;</td><td class="mdescRight">Removes the named persistent MQ.  <a href="classipc_1_1transport_1_1Persistent__mq__handle.html#a2e8b8102fdbacc064d4759533a725f51">More...</a><br /></td></tr>
<tr class="separator:a2e8b8102fdbacc064d4759533a725f51"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac14dd419cdbc97b6630900268f8b7dd2"><td class="memTemplParams" colspan="2">template&lt;typename Handle_name_func &gt; </td></tr>
<tr class="memitem:ac14dd419cdbc97b6630900268f8b7dd2"><td class="memTemplItemLeft" align="right" valign="top">static void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classipc_1_1transport_1_1Persistent__mq__handle.html#ac14dd419cdbc97b6630900268f8b7dd2">for_each_persistent</a> (const Handle_name_func &amp;handle_name_func)</td></tr>
<tr class="memdesc:ac14dd419cdbc97b6630900268f8b7dd2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Lists all named persistent MQs currently persisting, invoking the given handler synchronously on each one.  <a href="classipc_1_1transport_1_1Persistent__mq__handle.html#ac14dd419cdbc97b6630900268f8b7dd2">More...</a><br /></td></tr>
<tr class="separator:ac14dd419cdbc97b6630900268f8b7dd2"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-static-attribs" name="pub-static-attribs"></a>
Static Public Attributes</h2></td></tr>
<tr class="memitem:ad49e1049101a5ab6cfb2ed2b3eaedee0"><td class="memItemLeft" align="right" valign="top">static const <a class="el" href="namespaceipc_1_1transport.html#a33de1c256addb3964b839dc2dd407d24">Shared_name</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classipc_1_1transport_1_1Persistent__mq__handle.html#ad49e1049101a5ab6cfb2ed2b3eaedee0">S_RESOURCE_TYPE_ID</a></td></tr>
<tr class="memdesc:ad49e1049101a5ab6cfb2ed2b3eaedee0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Shared_name relative-folder fragment (no separators) identifying this resource type.  <a href="classipc_1_1transport_1_1Persistent__mq__handle.html#ad49e1049101a5ab6cfb2ed2b3eaedee0">More...</a><br /></td></tr>
<tr class="separator:ad49e1049101a5ab6cfb2ed2b3eaedee0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac2c0b560893c6a8b71aac0e748770076"><td class="memItemLeft" align="right" valign="top">static constexpr bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classipc_1_1transport_1_1Persistent__mq__handle.html#ac2c0b560893c6a8b71aac0e748770076">S_HAS_NATIVE_HANDLE</a> = unspecified</td></tr>
<tr class="memdesc:ac2c0b560893c6a8b71aac0e748770076"><td class="mdescLeft">&#160;</td><td class="mdescRight"><code>true</code> if and only if <a class="el" href="classipc_1_1transport_1_1Persistent__mq__handle.html#a25e96c4f060cc3c4b611c4e2de60abaf" title="Available if and only if S_HAS_NATIVE_HANDLE is true: Returns the stored native MQ handle; null means...">native_handle()</a> method exists, and the returned value may be waited-on by <code>poll()</code>/etc.  <a href="classipc_1_1transport_1_1Persistent__mq__handle.html#ac2c0b560893c6a8b71aac0e748770076">More...</a><br /></td></tr>
<tr class="separator:ac2c0b560893c6a8b71aac0e748770076"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="related" name="related"></a>
Related Functions</h2></td></tr>
<tr><td class="ititle" colspan="2"><p >(Note that these are not member functions.) </p>
</td></tr>
<tr class="memitem:a6f670a864f39c533a6a98dbca8fdb224"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classipc_1_1transport_1_1Persistent__mq__handle.html#a6f670a864f39c533a6a98dbca8fdb224">swap</a> (<a class="el" href="classipc_1_1transport_1_1Persistent__mq__handle.html">Persistent_mq_handle</a> &amp;val1, <a class="el" href="classipc_1_1transport_1_1Persistent__mq__handle.html">Persistent_mq_handle</a> &amp;val2)</td></tr>
<tr class="memdesc:a6f670a864f39c533a6a98dbca8fdb224"><td class="mdescLeft">&#160;</td><td class="mdescRight">Swaps two objects.  <a href="classipc_1_1transport_1_1Persistent__mq__handle.html#a6f670a864f39c533a6a98dbca8fdb224">More...</a><br /></td></tr>
<tr class="separator:a6f670a864f39c533a6a98dbca8fdb224"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p >A documentation-only <em>concept</em> defining the behavior of an object representing a light-weight handle to a message queue, capable of receiving/sending discrete messages in non-blocking/blocking/timed-blocking fashion, as well as some support for polling/waiting and interruptions thereof. </p>
<p >The message queue (MQ) is assumed to be of at least kernel persistence, meaning a handle to an MQ closing does not delete the MQ, and another handle may reattach to it; in order to delete the underlying MQ a separate remove op is needed (and is provided as well as a <code>static</code> method).</p>
<h3>How to use</h3>
<p >The following are relevant operations to do with MQs. (Read Rationale for background.)</p><ul>
<li>Create (named) MQ: <a class="el" href="classipc_1_1transport_1_1Persistent__mq__handle.html#a22abfaa801a9e2f974a8cd179544d19a" title="Construct null handle, suitable only for being subsequently moved-to or destroyed.">Persistent_mq_handle()</a> ctor, with either <a class="el" href="namespaceipc_1_1util.html#a9d84c2bab504e6de32b20c77ca9723a2" title="Tag type indicating a create-unless-exists-else-fail operation.">util::Create_only</a> or <a class="el" href="namespaceipc_1_1util.html#a9571de958538d7a4a8649bbfecfac0b9" title="Tag type indicating an atomic open-if-exists-else-create operation.">util::Open_or_create</a> tag arg. A Shared_name specifies the name. If one does not need a handle simply destroy the resulting object: the underlying created MQ continues existing.</li>
<li>Create handle to the (named) MQ: <a class="el" href="classipc_1_1transport_1_1Persistent__mq__handle.html#a22abfaa801a9e2f974a8cd179544d19a" title="Construct null handle, suitable only for being subsequently moved-to or destroyed.">Persistent_mq_handle()</a> ctor, with either <a class="el" href="namespaceipc_1_1util.html#a3e03491b5b2b5fac26551a220946d6e5" title="Tag type indicating an ideally-atomic open-if-exists-else-fail operation.">util::Open_only</a> or <a class="el" href="namespaceipc_1_1util.html#a9571de958538d7a4a8649bbfecfac0b9" title="Tag type indicating an atomic open-if-exists-else-create operation.">util::Open_or_create</a> tag arg. A Shared_name specifies the name.</li>
<li>Send message into the MQ, via handle: <a class="el" href="classipc_1_1transport_1_1Persistent__mq__handle.html#ad9d38e0e16931dd96738d53b787533a1" title="Non-blocking send: pushes copy of message to queue and returns true; if queue is full then no-op and ...">try_send()</a> (non-blocking), <a class="el" href="classipc_1_1transport_1_1Persistent__mq__handle.html#a9d54e47b729eec9f72dee869326bfa8f" title="Blocking send: pushes copy of message to queue; if queue is full blocks until it is not.">send()</a> (blocking), <a class="el" href="classipc_1_1transport_1_1Persistent__mq__handle.html#ab4cba10b83df79acf76c64b0deb7f624" title="Blocking timed send: pushes copy of message to queue; if queue is full blocks until it is not,...">timed_send()</a> (blocking with timeout).<ul>
<li>Await writability without writing: <a class="el" href="classipc_1_1transport_1_1Persistent__mq__handle.html#ab95e3d32a7ad3fa3630ba54442d8f2ee" title="Equivalent to try_send() except stops short of writing anything, with true result indicating that try...">is_sendable()</a> (instant poll), <a class="el" href="classipc_1_1transport_1_1Persistent__mq__handle.html#a230060aa545bfe11eb263211c84514f1" title="Equivalent to send() except stops short of writing anything, with non-error return indicating that tr...">wait_sendable()</a> (blocking), <a class="el" href="classipc_1_1transport_1_1Persistent__mq__handle.html#aadfffb71ff2fec6508174fdf4b08327e" title="Equivalent to timed_send() except stops short of writing anything, with true result indicating that t...">timed_wait_sendable()</a> (blocking with timeout).</li>
<li>Interrupt and/or preempt all above blocking operations including concurrently/preempt <a class="el" href="classipc_1_1transport_1_1Persistent__mq__handle.html#ab95e3d32a7ad3fa3630ba54442d8f2ee" title="Equivalent to try_send() except stops short of writing anything, with true result indicating that try...">is_sendable()</a>: <a class="el" href="classipc_1_1transport_1_1Persistent__mq__handle.html#af7a883553df39b16047b49942bd734c0" title="Enables sends-interrupted mode: is_sendable() (future calls), send() (future or concurrent calls),...">interrupt_sends()</a>. Undo: <a class="el" href="classipc_1_1transport_1_1Persistent__mq__handle.html#af43b22d89c5a228c2a72c321c2e24545" title="Disables mode enabled by interrupt_sends().">allow_sends()</a>.</li>
</ul>
</li>
<li>Receive message out of the MQ, via handle: <a class="el" href="classipc_1_1transport_1_1Persistent__mq__handle.html#a84f802c77b0ce93d59e7ac78839f14cc" title="Non-blocking receive: pops copy of message from queue into buffer and returns true; if queue is empty...">try_receive()</a> (non-blocking), <a class="el" href="classipc_1_1transport_1_1Persistent__mq__handle.html#ae1e6822d16d30dc57c95e3e051e5f8a8" title="Blocking receive: pops copy of message from queue into buffer; if queue is empty blocks until it is n...">receive()</a> (blocking), <a class="el" href="classipc_1_1transport_1_1Persistent__mq__handle.html#af547b6f1b1e51a7d6f6fbafc14c95f9d" title="Blocking timed receive: pops copy of message from queue into buffer; if queue is empty blocks until i...">timed_receive()</a> (blocking with timeout).<ul>
<li>Await readability without reading: <a class="el" href="classipc_1_1transport_1_1Persistent__mq__handle.html#acdf4279219020020b1d8b3ff8a80cbe2" title="Equivalent to try_receive() except stops short of reading anything, with true result indicating that ...">is_receivable()</a> (instant poll), <a class="el" href="classipc_1_1transport_1_1Persistent__mq__handle.html#a7029f9601aa268022bd8cf7970c512c8" title="Equivalent to receive() except stops short of reading anything, with non-error return indicating that...">wait_receivable()</a> (blocking), <a class="el" href="classipc_1_1transport_1_1Persistent__mq__handle.html#ac4f13853e38ade577faabbf9ef0af74f" title="Equivalent to timed_receive() except stops short of reading anything, with true result indicating tha...">timed_wait_receivable()</a> (blocking with timeout).</li>
<li>Interrupt and/or preempt all above blocking operations including concurrently/preempt <a class="el" href="classipc_1_1transport_1_1Persistent__mq__handle.html#acdf4279219020020b1d8b3ff8a80cbe2" title="Equivalent to try_receive() except stops short of reading anything, with true result indicating that ...">is_receivable()</a>: <a class="el" href="classipc_1_1transport_1_1Persistent__mq__handle.html#a206333d3eb619588d17812f8f49013a2" title="Enables receives-interrupted mode: is_receivable() (future calls), receive() (future or concurrent ca...">interrupt_receives()</a>. Undo: <a class="el" href="classipc_1_1transport_1_1Persistent__mq__handle.html#aaedc972e2ce207875a3e7262f9064b65" title="Disables mode enabled by interrupt_receives().">allow_receives()</a>.</li>
</ul>
</li>
<li>Destroy handle to the MQ: <a class="el" href="classipc_1_1transport_1_1Persistent__mq__handle.html#a1fbb936f8f80fedcb1227794ef0a451b" title="Destroys this handle (or no-op if no handle was successfully constructed, or if it&#39;s a moved-from or ...">~Persistent_mq_handle()</a> destructor. The underlying MQ continues existing.</li>
<li>Destroy (named) MQ: <a class="el" href="classipc_1_1transport_1_1Persistent__mq__handle.html#a2e8b8102fdbacc064d4759533a725f51" title="Removes the named persistent MQ.">remove_persistent()</a>. Underlying MQ name disappears, but MQ continues existing until all handles machine-wide are closed. A Shared_name specifies the name.</li>
</ul>
<h3>Thread safety</h3>
<p >Concurrent ops safe on different objects (including when the same-named queue is being accessed). Concurrent non-<code>const</code> ops (where at least 1 is non-<code>const</code>) not safe on the same <code>*this</code>.</p>
<p >The notable exception to the latter: each of <code>interrupt_*()</code> and <code>allow_*()</code> is safe to call on the same <code>*this</code> concurrently to any method except <code>interrupt_*()</code> and <code>allow_*()</code> themselves. In fact <code>interrupt_*()</code> ability to interrupt a concurrent timed-waiting of infinitely-waiting read or write is most of those methods' utility.</p>
<h3>Rationale</h3>
<p >Here's why this concept exists and how it was designed to be the way it is. It's actually quite simple; the only question is why it is this way and not some other way. Update: It's somewhat less simple now but not bad.</p>
<p ><a class="el" href="namespaceipc_1_1transport.html" title="Flow-IPC module providing transmission of structured messages and/or low-level blobs (and more) betwe...">ipc::transport</a> features the <a class="el" href="classipc_1_1transport_1_1Blob__sender.html" title="A documentation-only concept defining the behavior of an object capable of reliably/in-order sending ...">Blob_sender</a> and <a class="el" href="classipc_1_1transport_1_1Blob__receiver.html" title="A documentation-only concept defining the behavior of an object capable of reliably/in-order receivin...">Blob_receiver</a> concepts, each of which is a peer endpoint of a connected one-way pipe capable of transmitting discrete messages, each consisting of a binary blob. They are first-class citizens of <a class="el" href="namespaceipc_1_1transport.html" title="Flow-IPC module providing transmission of structured messages and/or low-level blobs (and more) betwe...">ipc::transport</a>, or at least of its core-layer portion, meaning they're likely to be used by the user directly or at least in highly visible fashion by another aspect of <a class="el" href="namespaceipc_1_1transport.html" title="Flow-IPC module providing transmission of structured messages and/or low-level blobs (and more) betwe...">ipc::transport</a> impl. They have a vaguely socket-like API, with an asynchronous receive method and a convenient non-blocking/synchronous sender method (that cannot yield would-block). Lastly the destructor of either ensures the underlying transport cannot be used again by somehow opening another handle to the same thing.</p>
<p >One implementation of <a class="el" href="classipc_1_1transport_1_1Blob__sender.html" title="A documentation-only concept defining the behavior of an object capable of reliably/in-order sending ...">Blob_sender</a> and <a class="el" href="classipc_1_1transport_1_1Blob__receiver.html" title="A documentation-only concept defining the behavior of an object capable of reliably/in-order receivin...">Blob_receiver</a> simultaneously might be <a class="el" href="classipc_1_1transport_1_1Native__socket__stream.html" title="Implements both Native_handle_sender and Native_handle_receiver concepts by using a stream-oriented U...">Native_socket_stream</a> which uses Unix domain stream connection as underlying transport. That one is a natural fit for the concept, including the fact that closing a Unix domain socket hoses the connection entirely (one cannot somehow "reattach" to it). It's good. However, benchmark tests (details omitted) show that, when need not also send native handles over such a connection, <em>message queue</em> low-level transports might be more performant or at least competitive.</p>
<p >In our ecosystem, two message queue (MQ) transports are candidates: the POSIX message queue (provided by Linux) (see <code>man mq_overview</code>) and the boost.interprocess (bipc) message queue (web-search for <code>boost::interprocess::message_queue</code>). We wanted to support both and then provide the choice of which one to use. So the goal is to write <a class="el" href="classipc_1_1transport_1_1Blob__sender.html" title="A documentation-only concept defining the behavior of an object capable of reliably/in-order sending ...">Blob_sender</a> and <a class="el" href="classipc_1_1transport_1_1Blob__receiver.html" title="A documentation-only concept defining the behavior of an object capable of reliably/in-order receivin...">Blob_receiver</a> concept impls for each type of MQ (and possibly others over time). So how to do that nicely?</p>
<p >The 2 low-level MQ APIs (POSIX MQ and bipc MQ) are extremely different, conceptually and in practice, from stream socket APIs of any kind. For one thing, the MQs have kernel persistence &ndash; they're like files in memory that disappear at reboot but otherwise stay around, so one can reattach a handle to one even after closing another one; and deleting it is a separate operation not involving any handle. For another, they don't use socket-descriptors and hence do not participate in <code>epoll/poll/select()</code> mechanisms and feature only blocking, non-blocking, and blocking-with-timeout send and receive APIs. (POSIX MQ does have <code>mq_notify()</code>, but this async-notify mechanism is quite limited, either creating a new thread for each notification, or using a signal. POSIX MQ in Linux <em>does</em> happen to have a non-portable property wherein the descriptor is really an FD, so it <em>can</em> participate in <code>epoll/poll/select()</code> mechanisms; and boost.asio <em>does</em> have a <code>posix::descriptor</code> that can wrap such a native descriptor. However: bipc MQ lacks anything like this at all.)</p>
<p >The 2 APIs are, however, extremely similar to each other. In fact, one gets the impression that the authors of bipc MQ considered wrapping POSIX MQs but reconsidered for whatever reason (maybe the obscure limit semantics, lack of availability in all Linux versions and other Unixes and Windows) &ndash; but fairly closely mirrored the API therein.</p>
<p >Knowing this, it looked pretty natural to write some Blob_sender/Blob_receiver impls holding some <code>bipc::message_queue</code> handles internally. However, while conceptually similar, the POSIX MQ API is a C API, not a Boost-style C++ thing. It would be entirely possible to still write Blob_sender/Blob_receiver impls around this API, but since conceptually it's so similar to bipc MQ, why waste the effort? Code reuse for the win.</p>
<p >That brings us to this concept. What it is is: A thing I (ygoldfel) came up with by simply taking <code>bipc::message_queue</code> and working backwards, making a concept for an MQ handle, <a class="el" href="classipc_1_1transport_1_1Persistent__mq__handle.html" title="A documentation-only concept defining the behavior of an object representing a light-weight handle to...">Persistent_mq_handle</a>, to which <code>bipc::message_queue</code> directly conforms already in most key ways (to wit: the send/receive methods). Then one could write a very thin non-polymorphic HAS-A wrapper class (with no added data stored) and a couple other utility functions with very thin adaptations to match <a class="el" href="namespaceipc_1_1transport.html" title="Flow-IPC module providing transmission of structured messages and/or low-level blobs (and more) betwe...">ipc::transport</a> style (like using Shared_name instead of strings when creating or removing kernel-persistent queue instances). This class is <a class="el" href="classipc_1_1transport_1_1Bipc__mq__handle.html" title="Implements the Persistent_mq_handle concept by thinly wrapping bipc::message_queue,...">Bipc_mq_handle</a>; it implements this <a class="el" href="classipc_1_1transport_1_1Persistent__mq__handle.html" title="A documentation-only concept defining the behavior of an object representing a light-weight handle to...">Persistent_mq_handle</a>.</p>
<p >Next, a class can be written to mirror this API but for POSIX MQs. This is a little harder, since it can't just expose some existing super-class's send/receive functions, but it would just wrap the Linux C API and store an MQ handle; done. This class is <a class="el" href="classipc_1_1transport_1_1Posix__mq__handle.html" title="Implements the Persistent_mq_handle concept by wrapping the POSIX message queue API (see man mq_overv...">Posix_mq_handle</a>; it also implements <a class="el" href="classipc_1_1transport_1_1Persistent__mq__handle.html" title="A documentation-only concept defining the behavior of an object representing a light-weight handle to...">Persistent_mq_handle</a>.</p>
<p >Now that <a class="el" href="classipc_1_1transport_1_1Persistent__mq__handle.html" title="A documentation-only concept defining the behavior of an object representing a light-weight handle to...">Persistent_mq_handle</a> provides a uniform API, a Blob_sender/Blob_receiver can be written around a <code>typename <a class="el" href="classipc_1_1transport_1_1Persistent__mq__handle.html" title="A documentation-only concept defining the behavior of an object representing a light-weight handle to...">Persistent_mq_handle</a></code> which can be either <a class="el" href="classipc_1_1transport_1_1Bipc__mq__handle.html" title="Implements the Persistent_mq_handle concept by thinly wrapping bipc::message_queue,...">Bipc_mq_handle</a> or <a class="el" href="classipc_1_1transport_1_1Posix__mq__handle.html" title="Implements the Persistent_mq_handle concept by wrapping the POSIX message queue API (see man mq_overv...">Posix_mq_handle</a> (or a future wrapper around something else).</p>
<h3>Poll/wait and interrupt facilities</h3>
<p >Somewhat later we added a major feature to the concept (and both known impls): For each type of transmission operation in a given direction (instant poll, blocking, blocking with timeout), there is a poll/wait counterpart which is almost the same except it does not actually transmit but merely returns the fact transmission is possible. E.g., <a class="el" href="classipc_1_1transport_1_1Persistent__mq__handle.html#a84f802c77b0ce93d59e7ac78839f14cc" title="Non-blocking receive: pops copy of message from queue into buffer and returns true; if queue is empty...">try_receive()</a> &lt;=&gt; <a class="el" href="classipc_1_1transport_1_1Persistent__mq__handle.html#acdf4279219020020b1d8b3ff8a80cbe2" title="Equivalent to try_receive() except stops short of reading anything, with true result indicating that ...">is_receivable()</a>, <a class="el" href="classipc_1_1transport_1_1Persistent__mq__handle.html#ae1e6822d16d30dc57c95e3e051e5f8a8" title="Blocking receive: pops copy of message from queue into buffer; if queue is empty blocks until it is n...">receive()</a> &lt;=&gt; <a class="el" href="classipc_1_1transport_1_1Persistent__mq__handle.html#a7029f9601aa268022bd8cf7970c512c8" title="Equivalent to receive() except stops short of reading anything, with non-error return indicating that...">wait_receivable()</a>, <a class="el" href="classipc_1_1transport_1_1Persistent__mq__handle.html#af547b6f1b1e51a7d6f6fbafc14c95f9d" title="Blocking timed receive: pops copy of message from queue into buffer; if queue is empty blocks until i...">timed_receive()</a> &lt;=&gt; <a class="el" href="classipc_1_1transport_1_1Persistent__mq__handle.html#ac4f13853e38ade577faabbf9ef0af74f" title="Equivalent to timed_receive() except stops short of reading anything, with true result indicating tha...">timed_wait_receivable()</a>. In fact &ndash; in the absence of a competing <code>*this</code> &ndash; <a class="el" href="classipc_1_1transport_1_1Persistent__mq__handle.html#ae1e6822d16d30dc57c95e3e051e5f8a8" title="Blocking receive: pops copy of message from queue into buffer; if queue is empty blocks until it is n...">receive()</a> = <a class="el" href="classipc_1_1transport_1_1Persistent__mq__handle.html#a7029f9601aa268022bd8cf7970c512c8" title="Equivalent to receive() except stops short of reading anything, with non-error return indicating that...">wait_receivable()</a> + <a class="el" href="classipc_1_1transport_1_1Persistent__mq__handle.html#a84f802c77b0ce93d59e7ac78839f14cc" title="Non-blocking receive: pops copy of message from queue into buffer and returns true; if queue is empty...">try_receive()</a> (succeeds), <a class="el" href="classipc_1_1transport_1_1Persistent__mq__handle.html#af547b6f1b1e51a7d6f6fbafc14c95f9d" title="Blocking timed receive: pops copy of message from queue into buffer; if queue is empty blocks until i...">timed_receive()</a> = <a class="el" href="classipc_1_1transport_1_1Persistent__mq__handle.html#ac4f13853e38ade577faabbf9ef0af74f" title="Equivalent to timed_receive() except stops short of reading anything, with true result indicating tha...">timed_wait_receivable()</a> + <a class="el" href="classipc_1_1transport_1_1Persistent__mq__handle.html#a84f802c77b0ce93d59e7ac78839f14cc" title="Non-blocking receive: pops copy of message from queue into buffer and returns true; if queue is empty...">try_receive()</a> (succeeds).</p>
<p >This is useful at least in that it allows one to defer deciding on a target buffer for receiving, until receiving would (probably) actually work. In the other direction it can still provide useful flexibility in a multi-threaded setup (one thread blockingly-waits, the other is signaled about readiness and tries to transmit but without blocking &ndash; useful in a thread U/thread W setup).</p>
<p >Lastly, any blocking (with or without timeout) can be interrupted via the <code>interrupt_*()</code> methods. For example a <a class="el" href="classipc_1_1transport_1_1Persistent__mq__handle.html#ae1e6822d16d30dc57c95e3e051e5f8a8" title="Blocking receive: pops copy of message from queue into buffer; if queue is empty blocks until it is n...">receive()</a> or <a class="el" href="classipc_1_1transport_1_1Persistent__mq__handle.html#a7029f9601aa268022bd8cf7970c512c8" title="Equivalent to receive() except stops short of reading anything, with non-error return indicating that...">wait_receivable()</a> may be ongoing in thread W, and thread U can <a class="el" href="classipc_1_1transport_1_1Persistent__mq__handle.html#a206333d3eb619588d17812f8f49013a2" title="Enables receives-interrupted mode: is_receivable() (future calls), receive() (future or concurrent ca...">interrupt_receives()</a> to immediately make the blocking op exit with <a class="el" href="namespaceipc_1_1transport_1_1error.html#adfef15ef4e76cc55d652fbd9c2797297a291f8a813c292ccdb475c345181653ac" title="A blocking operation was intentionally interrupted or preemptively canceled.">error::Code::S_INTERRUPTED</a>.</p>
<h3>Discussion: The road to boost.asio-like async I/O</h3>
<p >What would be cool, which isn't here, is if this concept described a boost.asio I/O object, capable of plugging into a boost.asio loop; or ~equivalently something a-la <a class="el" href="classipc_1_1transport_1_1Blob__sender.html" title="A documentation-only concept defining the behavior of an object capable of reliably/in-order sending ...">Blob_sender</a> and/or <a class="el" href="classipc_1_1transport_1_1Blob__receiver.html" title="A documentation-only concept defining the behavior of an object capable of reliably/in-order receivin...">Blob_receiver</a>. However that was not our aim &ndash; we only want a thin wrapper as noted in "Rationale" above &ndash; and <a class="el" href="classipc_1_1transport_1_1Blob__stream__mq__receiver.html" title="Implements Blob_receiver concept by using an adopted Persistent_mq_handle MQ handle to an MQ (message...">Blob_stream_mq_receiver</a> and <a class="el" href="classipc_1_1transport_1_1Blob__stream__mq__sender.html" title="Implements Blob_sender concept by using an adopted Persistent_mq_handle MQ handle to an MQ (message q...">Blob_stream_mq_sender</a> achieve it (and arguably more &ndash; albeit with the limit of a single writer and single reader). That said: it may be useful to contemplate what parts the concept does have that are conducive to that type of work.</p>
<p >Without the poll/wait facilities combined with interrupt facilities, it was possible but somewhat clunky, having to at least start a background thread in which to perform blocking transmit calls; they'd have to be broken up into subject-to-timeout shorter calls, so that the thread could be stopped and joined during deinit. Even then full deinit could only occur with a potential pause until the current short call in the background thread W could return. By having thread W do (indefinite) waits only, and allowing thread U to do non-blocking transmits only <em>and</em> <code>interrupt_*()</code>, we achieve pretty good flexibility and responsiveness. That is what <a class="el" href="classipc_1_1transport_1_1Blob__stream__mq__sender.html" title="Implements Blob_sender concept by using an adopted Persistent_mq_handle MQ handle to an MQ (message q...">Blob_stream_mq_sender</a> and <a class="el" href="classipc_1_1transport_1_1Blob__stream__mq__receiver.html" title="Implements Blob_receiver concept by using an adopted Persistent_mq_handle MQ handle to an MQ (message...">Blob_stream_mq_receiver</a> can do given the present concept.</p>
<p >However &ndash; it <em>can</em> be more advanced still. Consider the specific impl <a class="el" href="classipc_1_1transport_1_1Posix__mq__handle.html" title="Implements the Persistent_mq_handle concept by wrapping the POSIX message queue API (see man mq_overv...">Posix_mq_handle</a>, which has the additional-to-concept (edit: see below update) method <a class="el" href="classipc_1_1transport_1_1Posix__mq__handle.html#a62bc5410c9928099dff46ba021acb879" title="Implements Persistent_mq_handle API: Returns the stored native MQ handle; null if not open.">Posix_mq_handle::native_handle()</a>; in Linux a <a class="el" href="namespaceipc_1_1transport.html#a7ee4551983d9df16ec16a3139bac50e8" title="Convenience alias for the commonly used type util::Native_handle.">Native_handle</a>. This can be waited-on, natively with <code>[e]poll*()</code>; with boost.asio via <a class="el" href="classipc_1_1util_1_1sync__io_1_1Asio__waitable__native__handle.html" title="Useful if using the sync_io pattern within a user event loop built on boost.asio (optionally with flo...">util::sync_io::Asio_waitable_native_handle</a> (more or less a <code>boost::asio::posix::descriptor</code>). <em>Now</em> no background thread W is necessary: thread U can ask the <em>kernel</em> to report readability/writability &ndash; when active it can do non-blocking stuff.</p>
<p >The wrinkle: <a class="el" href="classipc_1_1transport_1_1Posix__mq__handle.html" title="Implements the Persistent_mq_handle concept by wrapping the POSIX message queue API (see man mq_overv...">Posix_mq_handle</a> has it; but <a class="el" href="classipc_1_1transport_1_1Bipc__mq__handle.html" title="Implements the Persistent_mq_handle concept by thinly wrapping bipc::message_queue,...">Bipc_mq_handle</a> does not (and there is no FD inside its impl either; it is fully SHM-based internally). Can it be generalized nevertheless? Yes and no. Yes: in that it can be simulated by "secretly" having a thread W and having it use a pipe (or something) to translate readable/writable events into a live FD that could be detected via <code>[e]poll*()</code> or boost.asio. No: in that it turns a hypothetical <a class="el" href="classipc_1_1transport_1_1Persistent__mq__handle.html" title="A documentation-only concept defining the behavior of an object representing a light-weight handle to...">Persistent_mq_handle</a> impl, namely <a class="el" href="classipc_1_1transport_1_1Bipc__mq__handle.html" title="Implements the Persistent_mq_handle concept by thinly wrapping bipc::message_queue,...">Bipc_mq_handle</a>, into something complex as opposed to any kind of thin wrapper around an MQ API. Therefore we did not do it.</p>
<p >However &ndash; we did ~such a thing with <a class="el" href="classipc_1_1transport_1_1sync__io_1_1Blob__stream__mq__sender.html" title="Implements sync_io::Blob_sender concept by using an adopted Persistent_mq_handle MQ handle to an MQ (...">sync_io::Blob_stream_mq_sender</a> and <a class="el" href="classipc_1_1transport_1_1sync__io_1_1Blob__stream__mq__receiver.html" title="Implements sync_io::Blob_receiver concept by using an adopted Persistent_mq_handle MQ handle to an MQ...">sync_io::Blob_stream_mq_receiver</a> which are templated on <a class="el" href="classipc_1_1transport_1_1Persistent__mq__handle.html" title="A documentation-only concept defining the behavior of an object representing a light-weight handle to...">Persistent_mq_handle</a> as a template-parameter; and, being <code><a class="el" href="namespaceipc_1_1transport_1_1sync__io.html" title="sync_io-pattern counterparts to async-I/O-pattern object types in parent namespace ipc::transport.">sync_io</a></code>-pattern-impls (see <a class="el" href="namespaceipc_1_1util_1_1sync__io.html" title="Contains common code, as well as important explanatory documentation in the following text,...">util::sync_io</a>), they each expose a waitable-on <a class="el" href="namespaceipc_1_1transport.html#a7ee4551983d9df16ec16a3139bac50e8" title="Convenience alias for the commonly used type util::Native_handle.">Native_handle</a>. Indeed as of this writing each of these templates keeps a "secret" thread W that performs blocking waits, while the user-accessible API makes it look like a nice, kernel-reported-via-FDs reactor/proactor-supporting I/O object. By operating on what is directly available via the present concept, this setup of <a class="el" href="classipc_1_1transport_1_1Blob__stream__mq__sender.html" title="Implements Blob_sender concept by using an adopted Persistent_mq_handle MQ handle to an MQ (message q...">Blob_stream_mq_sender</a> and <a class="el" href="classipc_1_1transport_1_1Blob__stream__mq__receiver.html" title="Implements Blob_receiver concept by using an adopted Persistent_mq_handle MQ handle to an MQ (message...">Blob_stream_mq_receiver</a> internals is agnostic to the type of MQ.</p>
<p >However, if one wanted to take advantage of the non-concept (edit: see below update) ability to be watched (via FD) with the kernel's help and without an added thread, they could specialize <code>Blob_stream_mq_*er</code> for <a class="el" href="classipc_1_1transport_1_1Posix__mq__handle.html" title="Implements the Persistent_mq_handle concept by wrapping the POSIX message queue API (see man mq_overv...">Posix_mq_handle</a> which does offer a kernel-FD accessor <code>.<a class="el" href="classipc_1_1transport_1_1Persistent__mq__handle.html#a25e96c4f060cc3c4b611c4e2de60abaf" title="Available if and only if S_HAS_NATIVE_HANDLE is true: Returns the stored native MQ handle; null means...">native_handle()</a></code>. Update: This is now done (in fact it is not specialized as of this writing but rather uses a few simple <code>if constexpr()</code>s). Accordingly the concept now allows for <code><a class="el" href="classipc_1_1transport_1_1Persistent__mq__handle.html#a25e96c4f060cc3c4b611c4e2de60abaf" title="Available if and only if S_HAS_NATIVE_HANDLE is true: Returns the stored native MQ handle; null means...">native_handle()</a></code> optionally: see <a class="el" href="classipc_1_1transport_1_1Persistent__mq__handle.html#ac2c0b560893c6a8b71aac0e748770076" title="true if and only if native_handle() method exists, and the returned value may be waited-on by poll()/...">Persistent_mq_handle::S_HAS_NATIVE_HANDLE</a>. </p>

<p class="definition">Definition at line <a class="el" href="persistent__mq__handle_8hpp_source.html#l00194">194</a> of file <a class="el" href="persistent__mq__handle_8hpp_source.html">persistent_mq_handle.hpp</a>.</p>
</div><h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="a22abfaa801a9e2f974a8cd179544d19a" name="a22abfaa801a9e2f974a8cd179544d19a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a22abfaa801a9e2f974a8cd179544d19a">&#9670;&nbsp;</a></span>Persistent_mq_handle() <span class="overload">[1/5]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ipc::transport::Persistent_mq_handle::Persistent_mq_handle </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Construct null handle, suitable only for being subsequently moved-to or destroyed. </p>
<p >If you do anything on <code>*this</code>, other than invoking dtor or move-assignment, behavior is undefined. </p>

</div>
</div>
<a id="a341076bd3ac7e32e4d1fa12570a11fd2" name="a341076bd3ac7e32e4d1fa12570a11fd2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a341076bd3ac7e32e4d1fa12570a11fd2">&#9670;&nbsp;</a></span>Persistent_mq_handle() <span class="overload">[2/5]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">ipc::transport::Persistent_mq_handle::Persistent_mq_handle </td>
          <td>(</td>
          <td class="paramtype">flow::log::Logger *&#160;</td>
          <td class="paramname"><em>logger_ptr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespaceipc_1_1transport.html#a33de1c256addb3964b839dc2dd407d24">Shared_name</a> &amp;&#160;</td>
          <td class="paramname"><em>absolute_name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceipc_1_1util.html#a9d84c2bab504e6de32b20c77ca9723a2">util::Create_only</a>&#160;</td>
          <td class="paramname"><em>mode_tag</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>max_n_msg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>max_msg_sz</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespaceipc_1_1util.html#a1b398ae730d1e6040687cb2397115152">util::Permissions</a> &amp;&#160;</td>
          <td class="paramname"><em>perms</em> = <code><a class="el" href="namespaceipc_1_1util.html#a1b398ae730d1e6040687cb2397115152">util::Permissions</a>()</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceipc.html#aa3192e586cc45d3e7c22463bf2760f89">Error_code</a> *&#160;</td>
          <td class="paramname"><em>err_code</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">explicit</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Construct handle to non-existing named MQ, creating it first. </p>
<p >If it already exists, it is an error. If an error is emitted via <code>*err_code</code>, and you do anything on <code>*this</code> other than invoking dtor or move-assignment, behavior is undefined.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">logger_ptr</td><td>Logger to use for subsequently logging. </td></tr>
    <tr><td class="paramname">absolute_name</td><td>Absolute name at which the persistent MQ lives. </td></tr>
    <tr><td class="paramname">mode_tag</td><td>API-choosing tag <a class="el" href="namespaceipc_1_1util.html#ad1ca1cab79a35e1eb1c47037a0973cd8" title="Tag value indicating an atomic create-unless-exists-else-fail operation.">util::CREATE_ONLY</a>. </td></tr>
    <tr><td class="paramname">perms</td><td>Permissions to use for creation. Suggest the use of <a class="el" href="namespaceipc_1_1util.html#abda2ce5bcdbc26ca63d667b87818439c" title="Maps general Permissions_level specifier to low-level Permissions value, when the underlying resource...">util::shared_resource_permissions()</a> to translate from one of a small handful of levels of access; these apply almost always in practice. The applied permissions shall <em>ignore</em> the process umask and shall thus exactly match <code>perms</code>, unless an error occurs. </td></tr>
    <tr><td class="paramname">max_n_msg</td><td>Max # of unpopped messages in created queue. </td></tr>
    <tr><td class="paramname">max_msg_sz</td><td>Max # of bytes in any one message in created queue. </td></tr>
    <tr><td class="paramname">err_code</td><td>See <code>flow::Error_code</code> docs for error reporting semantics. <a class="el" href="namespaceipc.html#aa3192e586cc45d3e7c22463bf2760f89" title="Short-hand for flow::Error_code which is very common.">Error_code</a> generated: various. Most likely creation failed due to permissions, or it already existed. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="af20035c875572ed018427322c845b9f9" name="af20035c875572ed018427322c845b9f9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af20035c875572ed018427322c845b9f9">&#9670;&nbsp;</a></span>Persistent_mq_handle() <span class="overload">[3/5]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">ipc::transport::Persistent_mq_handle::Persistent_mq_handle </td>
          <td>(</td>
          <td class="paramtype">flow::log::Logger *&#160;</td>
          <td class="paramname"><em>logger_ptr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespaceipc_1_1transport.html#a33de1c256addb3964b839dc2dd407d24">Shared_name</a> &amp;&#160;</td>
          <td class="paramname"><em>absolute_name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceipc_1_1util.html#a9571de958538d7a4a8649bbfecfac0b9">util::Open_or_create</a>&#160;</td>
          <td class="paramname"><em>mode_tag</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>max_n_msg_on_create</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>max_msg_sz_on_create</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespaceipc_1_1util.html#a1b398ae730d1e6040687cb2397115152">util::Permissions</a> &amp;&#160;</td>
          <td class="paramname"><em>perms_on_create</em> = <code><a class="el" href="namespaceipc_1_1util.html#a1b398ae730d1e6040687cb2397115152">util::Permissions</a>()</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceipc.html#aa3192e586cc45d3e7c22463bf2760f89">Error_code</a> *&#160;</td>
          <td class="paramname"><em>err_code</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">explicit</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Construct handle to existing named MQ, or else if it does not exist creates it first and opens it (atomically). </p>
<p >If an error is emitted via <code>*err_code</code>, and you do anything on <code>*this</code> other than invoking dtor or move-assignment, behavior is undefined.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">logger_ptr</td><td>Logger to use for subsequently logging. </td></tr>
    <tr><td class="paramname">absolute_name</td><td>Absolute name at which the persistent MQ lives. </td></tr>
    <tr><td class="paramname">mode_tag</td><td>API-choosing tag <a class="el" href="namespaceipc_1_1util.html#a5664539b3d75d6d10cdfebf6eac5382d" title="Tag value indicating an open-if-exists-else-create operation.">util::OPEN_OR_CREATE</a>. </td></tr>
    <tr><td class="paramname">perms_on_create</td><td>Permissions to use if creation is required. Suggest the use of <a class="el" href="namespaceipc_1_1util.html#abda2ce5bcdbc26ca63d667b87818439c" title="Maps general Permissions_level specifier to low-level Permissions value, when the underlying resource...">util::shared_resource_permissions()</a> to translate from one of a small handful of levels of access; these apply almost always in practice. The applied permissions shall <em>ignore</em> the process umask and shall thus exactly match <code>perms_on_create</code>, unless an error occurs. </td></tr>
    <tr><td class="paramname">max_n_msg_on_create</td><td>Max # of unpopped messages in created queue if creation is required. </td></tr>
    <tr><td class="paramname">max_msg_sz_on_create</td><td>Max # of bytes in any one message in created queue if creation is required. </td></tr>
    <tr><td class="paramname">err_code</td><td>See <code>flow::Error_code</code> docs for error reporting semantics. <a class="el" href="namespaceipc.html#aa3192e586cc45d3e7c22463bf2760f89" title="Short-hand for flow::Error_code which is very common.">Error_code</a> generated: various. Most likely creation failed due to permissions. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="af74d564d34874d1b86c043dfb7406048" name="af74d564d34874d1b86c043dfb7406048"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af74d564d34874d1b86c043dfb7406048">&#9670;&nbsp;</a></span>Persistent_mq_handle() <span class="overload">[4/5]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">ipc::transport::Persistent_mq_handle::Persistent_mq_handle </td>
          <td>(</td>
          <td class="paramtype">flow::log::Logger *&#160;</td>
          <td class="paramname"><em>logger_ptr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespaceipc_1_1transport.html#a33de1c256addb3964b839dc2dd407d24">Shared_name</a> &amp;&#160;</td>
          <td class="paramname"><em>absolute_name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceipc_1_1util.html#a3e03491b5b2b5fac26551a220946d6e5">util::Open_only</a>&#160;</td>
          <td class="paramname"><em>mode_tag</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceipc.html#aa3192e586cc45d3e7c22463bf2760f89">Error_code</a> *&#160;</td>
          <td class="paramname"><em>err_code</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">explicit</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Construct handle to existing named MQ. </p>
<p >If it does not exist, it is an error. If an error is emitted via <code>*err_code</code>, and you do anything on <code>*this</code> other than invoking dtor or move-assignment, behavior is undefined.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">logger_ptr</td><td>Logger to use for subsequently logging. </td></tr>
    <tr><td class="paramname">absolute_name</td><td>Absolute name at which the persistent MQ lives. </td></tr>
    <tr><td class="paramname">mode_tag</td><td>API-choosing tag <a class="el" href="namespaceipc_1_1util.html#a6a3a6ec85242d073df96978c63464078" title="Tag value indicating an atomic open-if-exists-else-fail operation.">util::OPEN_ONLY</a>. </td></tr>
    <tr><td class="paramname">err_code</td><td>See <code>flow::Error_code</code> docs for error reporting semantics. <a class="el" href="namespaceipc.html#aa3192e586cc45d3e7c22463bf2760f89" title="Short-hand for flow::Error_code which is very common.">Error_code</a> generated: various. Most likely it already existed. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a65d294e8972436e1193fe02baa34b20d" name="a65d294e8972436e1193fe02baa34b20d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a65d294e8972436e1193fe02baa34b20d">&#9670;&nbsp;</a></span>Persistent_mq_handle() <span class="overload">[5/5]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ipc::transport::Persistent_mq_handle::Persistent_mq_handle </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classipc_1_1transport_1_1Persistent__mq__handle.html">Persistent_mq_handle</a> &amp;&amp;&#160;</td>
          <td class="paramname"><em>src</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Constructs handle from the source handle while making the latter invalid. </p>
<p >If you do anything on <code>src</code> after this, other than invoking dtor or move-assignment, behavior is undefined.</p>
<p >Informally: this is a light-weight op.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">src</td><td>Source object which is nullified. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a1fbb936f8f80fedcb1227794ef0a451b" name="a1fbb936f8f80fedcb1227794ef0a451b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1fbb936f8f80fedcb1227794ef0a451b">&#9670;&nbsp;</a></span>~Persistent_mq_handle()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ipc::transport::Persistent_mq_handle::~Persistent_mq_handle </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Destroys this handle (or no-op if no handle was successfully constructed, or if it's a moved-from or default-cted handle). </p>
<p >The underlying MQ (if any) is <em>not</em> destroyed and can be attached-to by another handle. </p>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="a5ef74ca74a9d985710af974fd6518940" name="a5ef74ca74a9d985710af974fd6518940"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5ef74ca74a9d985710af974fd6518940">&#9670;&nbsp;</a></span>absolute_name()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="namespaceipc_1_1transport.html#a33de1c256addb3964b839dc2dd407d24">Shared_name</a> &amp; ipc::transport::Persistent_mq_handle::absolute_name </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns name equal to <code>absolute_name</code> passed to ctor. </p>
<dl class="section return"><dt>Returns</dt><dd>See above. </dd></dl>

<p class="reference">Referenced by <a class="el" href="blob__stream__mq__impl_8hpp_source.html#l00219">ipc::transport::Blob_stream_mq_base_impl&lt; Persistent_mq_handle &gt;::ensure_unique_peer()</a>.</p>
<div class="dynheader">
Here is the caller graph for this function:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="classipc_1_1transport_1_1Persistent__mq__handle_a5ef74ca74a9d985710af974fd6518940_icgraph.svg" width="656" height="131"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe>
</div>
</div>

</div>
</div>
<a id="aaedc972e2ce207875a3e7262f9064b65" name="aaedc972e2ce207875a3e7262f9064b65"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaedc972e2ce207875a3e7262f9064b65">&#9670;&nbsp;</a></span>allow_receives()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool ipc::transport::Persistent_mq_handle::allow_receives </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Disables mode enabled by <a class="el" href="classipc_1_1transport_1_1Persistent__mq__handle.html#a206333d3eb619588d17812f8f49013a2" title="Enables receives-interrupted mode: is_receivable() (future calls), receive() (future or concurrent ca...">interrupt_receives()</a>. </p>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> on success; <code>false</code> if already disabled. </dd></dl>

</div>
</div>
<a id="af43b22d89c5a228c2a72c321c2e24545" name="af43b22d89c5a228c2a72c321c2e24545"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af43b22d89c5a228c2a72c321c2e24545">&#9670;&nbsp;</a></span>allow_sends()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool ipc::transport::Persistent_mq_handle::allow_sends </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Disables mode enabled by <a class="el" href="classipc_1_1transport_1_1Persistent__mq__handle.html#af7a883553df39b16047b49942bd734c0" title="Enables sends-interrupted mode: is_sendable() (future calls), send() (future or concurrent calls),...">interrupt_sends()</a>. </p>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> on success; <code>false</code> if already disabled. </dd></dl>

</div>
</div>
<a id="ac14dd419cdbc97b6630900268f8b7dd2" name="ac14dd419cdbc97b6630900268f8b7dd2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac14dd419cdbc97b6630900268f8b7dd2">&#9670;&nbsp;</a></span>for_each_persistent()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Handle_name_func &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void ipc::transport::Persistent_mq_handle::for_each_persistent </td>
          <td>(</td>
          <td class="paramtype">const Handle_name_func &amp;&#160;</td>
          <td class="paramname"><em>handle_name_func</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Lists all named persistent MQs currently persisting, invoking the given handler synchronously on each one. </p>
<p >Note that, in a sanely set-up OS install, all existing pools will be listed by this function; but permissions/ownership may forbid certain operations the user may typically want to invoke on a given listed name &ndash; for example <a class="el" href="classipc_1_1transport_1_1Persistent__mq__handle.html#a2e8b8102fdbacc064d4759533a725f51" title="Removes the named persistent MQ.">remove_persistent()</a>. This function does <em>not</em> filter-out any potentially inaccessible items.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Handle_name_func</td><td>Function object matching signature <code>void F(const Shared_name&amp;)</code>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">handle_name_func</td><td><code>handle_name_func()</code> shall be invoked for each (matching, if applicable) item. See <code>Handle_name_func</code>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a206333d3eb619588d17812f8f49013a2" name="a206333d3eb619588d17812f8f49013a2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a206333d3eb619588d17812f8f49013a2">&#9670;&nbsp;</a></span>interrupt_receives()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool ipc::transport::Persistent_mq_handle::interrupt_receives </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Enables receives-interrupted mode: <a class="el" href="classipc_1_1transport_1_1Persistent__mq__handle.html#acdf4279219020020b1d8b3ff8a80cbe2" title="Equivalent to try_receive() except stops short of reading anything, with true result indicating that ...">is_receivable()</a> (future calls), <a class="el" href="classipc_1_1transport_1_1Persistent__mq__handle.html#ae1e6822d16d30dc57c95e3e051e5f8a8" title="Blocking receive: pops copy of message from queue into buffer; if queue is empty blocks until it is n...">receive()</a> (future or concurrent calls), <a class="el" href="classipc_1_1transport_1_1Persistent__mq__handle.html#af547b6f1b1e51a7d6f6fbafc14c95f9d" title="Blocking timed receive: pops copy of message from queue into buffer; if queue is empty blocks until i...">timed_receive()</a> (ditto), <a class="el" href="classipc_1_1transport_1_1Persistent__mq__handle.html#a7029f9601aa268022bd8cf7970c512c8" title="Equivalent to receive() except stops short of reading anything, with non-error return indicating that...">wait_receivable()</a> (ditto), <a class="el" href="classipc_1_1transport_1_1Persistent__mq__handle.html#ac4f13853e38ade577faabbf9ef0af74f" title="Equivalent to timed_receive() except stops short of reading anything, with true result indicating tha...">timed_wait_receivable()</a> (ditto) shall emit <a class="el" href="namespaceipc_1_1transport_1_1error.html#adfef15ef4e76cc55d652fbd9c2797297a291f8a813c292ccdb475c345181653ac" title="A blocking operation was intentionally interrupted or preemptively canceled.">error::Code::S_INTERRUPTED</a> as soon as possible. </p>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> on success; <code>false</code> is already enabled. </dd></dl>

</div>
</div>
<a id="af7a883553df39b16047b49942bd734c0" name="af7a883553df39b16047b49942bd734c0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af7a883553df39b16047b49942bd734c0">&#9670;&nbsp;</a></span>interrupt_sends()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool ipc::transport::Persistent_mq_handle::interrupt_sends </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Enables sends-interrupted mode: <a class="el" href="classipc_1_1transport_1_1Persistent__mq__handle.html#ab95e3d32a7ad3fa3630ba54442d8f2ee" title="Equivalent to try_send() except stops short of writing anything, with true result indicating that try...">is_sendable()</a> (future calls), <a class="el" href="classipc_1_1transport_1_1Persistent__mq__handle.html#a9d54e47b729eec9f72dee869326bfa8f" title="Blocking send: pushes copy of message to queue; if queue is full blocks until it is not.">send()</a> (future or concurrent calls), <a class="el" href="classipc_1_1transport_1_1Persistent__mq__handle.html#ab4cba10b83df79acf76c64b0deb7f624" title="Blocking timed send: pushes copy of message to queue; if queue is full blocks until it is not,...">timed_send()</a> (ditto), <a class="el" href="classipc_1_1transport_1_1Persistent__mq__handle.html#a230060aa545bfe11eb263211c84514f1" title="Equivalent to send() except stops short of writing anything, with non-error return indicating that tr...">wait_sendable()</a> (ditto), <a class="el" href="classipc_1_1transport_1_1Persistent__mq__handle.html#aadfffb71ff2fec6508174fdf4b08327e" title="Equivalent to timed_send() except stops short of writing anything, with true result indicating that t...">timed_wait_sendable()</a> (ditto) shall emit <a class="el" href="namespaceipc_1_1transport_1_1error.html#adfef15ef4e76cc55d652fbd9c2797297a291f8a813c292ccdb475c345181653ac" title="A blocking operation was intentionally interrupted or preemptively canceled.">error::Code::S_INTERRUPTED</a> as soon as possible. </p>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> on success; <code>false</code> is already enabled. </dd></dl>

</div>
</div>
<a id="acdf4279219020020b1d8b3ff8a80cbe2" name="acdf4279219020020b1d8b3ff8a80cbe2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acdf4279219020020b1d8b3ff8a80cbe2">&#9670;&nbsp;</a></span>is_receivable()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool ipc::transport::Persistent_mq_handle::is_receivable </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespaceipc.html#aa3192e586cc45d3e7c22463bf2760f89">Error_code</a> *&#160;</td>
          <td class="paramname"><em>err_code</em> = <code>0</code></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Equivalent to <a class="el" href="classipc_1_1transport_1_1Persistent__mq__handle.html#a84f802c77b0ce93d59e7ac78839f14cc" title="Non-blocking receive: pops copy of message from queue into buffer and returns true; if queue is empty...">try_receive()</a> except stops short of reading anything, with <code>true</code> result indicating that <a class="el" href="classipc_1_1transport_1_1Persistent__mq__handle.html#a84f802c77b0ce93d59e7ac78839f14cc" title="Non-blocking receive: pops copy of message from queue into buffer and returns true; if queue is empty...">try_receive()</a> <em>would</em> work at that moment. </p>
<p >If error is emitted, <code>*this</code> shall be considered hosed: Behavior is undefined except dtor or move-assignment. Exception to this: <a class="el" href="classipc_1_1transport_1_1Persistent__mq__handle.html#a206333d3eb619588d17812f8f49013a2" title="Enables receives-interrupted mode: is_receivable() (future calls), receive() (future or concurrent ca...">interrupt_receives()</a> leads to the emission of a particular error which shall be documented below; this is not fatal to `*this.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">err_code</td><td>See <code>flow::Error_code</code> docs for error reporting semantics. <a class="el" href="namespaceipc.html#aa3192e586cc45d3e7c22463bf2760f89" title="Short-hand for flow::Error_code which is very common.">Error_code</a> generated: various. Would-block shall not be emitted. <a class="el" href="namespaceipc_1_1transport_1_1error.html#adfef15ef4e76cc55d652fbd9c2797297a291f8a813c292ccdb475c345181653ac" title="A blocking operation was intentionally interrupted or preemptively canceled.">error::Code::S_INTERRUPTED</a> (preempted by <a class="el" href="classipc_1_1transport_1_1Persistent__mq__handle.html#a206333d3eb619588d17812f8f49013a2" title="Enables receives-interrupted mode: is_receivable() (future calls), receive() (future or concurrent ca...">interrupt_receives()</a>). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if transmissible; <code>false</code> if not, or on error. </dd></dl>

</div>
</div>
<a id="ab95e3d32a7ad3fa3630ba54442d8f2ee" name="ab95e3d32a7ad3fa3630ba54442d8f2ee"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab95e3d32a7ad3fa3630ba54442d8f2ee">&#9670;&nbsp;</a></span>is_sendable()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool ipc::transport::Persistent_mq_handle::is_sendable </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespaceipc.html#aa3192e586cc45d3e7c22463bf2760f89">Error_code</a> *&#160;</td>
          <td class="paramname"><em>err_code</em> = <code>0</code></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Equivalent to <a class="el" href="classipc_1_1transport_1_1Persistent__mq__handle.html#ad9d38e0e16931dd96738d53b787533a1" title="Non-blocking send: pushes copy of message to queue and returns true; if queue is full then no-op and ...">try_send()</a> except stops short of writing anything, with <code>true</code> result indicating that <a class="el" href="classipc_1_1transport_1_1Persistent__mq__handle.html#ad9d38e0e16931dd96738d53b787533a1" title="Non-blocking send: pushes copy of message to queue and returns true; if queue is full then no-op and ...">try_send()</a> <em>would</em> work at that moment. </p>
<p >If error is emitted, <code>*this</code> shall be considered hosed: Behavior is undefined except dtor or move-assignment. Exception to this: <a class="el" href="classipc_1_1transport_1_1Persistent__mq__handle.html#af7a883553df39b16047b49942bd734c0" title="Enables sends-interrupted mode: is_sendable() (future calls), send() (future or concurrent calls),...">interrupt_sends()</a> leads to the emission of a particular error which shall be documented below; this is not fatal to `*this.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">err_code</td><td>See <code>flow::Error_code</code> docs for error reporting semantics. <a class="el" href="namespaceipc.html#aa3192e586cc45d3e7c22463bf2760f89" title="Short-hand for flow::Error_code which is very common.">Error_code</a> generated: various. Would-block shall not be emitted. <a class="el" href="namespaceipc_1_1transport_1_1error.html#adfef15ef4e76cc55d652fbd9c2797297a291f8a813c292ccdb475c345181653ac" title="A blocking operation was intentionally interrupted or preemptively canceled.">error::Code::S_INTERRUPTED</a> (preempted by <a class="el" href="classipc_1_1transport_1_1Persistent__mq__handle.html#af7a883553df39b16047b49942bd734c0" title="Enables sends-interrupted mode: is_sendable() (future calls), send() (future or concurrent calls),...">interrupt_sends()</a>). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if transmissible; <code>false</code> if not, or on error. </dd></dl>

</div>
</div>
<a id="ae2efe92707c53c46bc70b84f96bda217" name="ae2efe92707c53c46bc70b84f96bda217"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae2efe92707c53c46bc70b84f96bda217">&#9670;&nbsp;</a></span>max_msg_size()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t ipc::transport::Persistent_mq_handle::max_msg_size </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the max message size of the underlying queue. </p>
<p >This should at least approximately equal what was passed to ctor when creating the MQ; however the underlying transport may tweak it, such as rounding to page size.</p>
<dl class="section return"><dt>Returns</dt><dd>See above. </dd></dl>

</div>
</div>
<a id="a22575a5750d322ccf87a923a3d662756" name="a22575a5750d322ccf87a923a3d662756"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a22575a5750d322ccf87a923a3d662756">&#9670;&nbsp;</a></span>max_n_msgs()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t ipc::transport::Persistent_mq_handle::max_n_msgs </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the max message count of the underlying queue. </p>
<p >This should at least approximately equal what was passed to ctor when creating the MQ; however the underlying transport may tweak it if it desires.</p>
<dl class="section return"><dt>Returns</dt><dd>See above. </dd></dl>

</div>
</div>
<a id="a25e96c4f060cc3c4b611c4e2de60abaf" name="a25e96c4f060cc3c4b611c4e2de60abaf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a25e96c4f060cc3c4b611c4e2de60abaf">&#9670;&nbsp;</a></span>native_handle()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespaceipc_1_1transport.html#a7ee4551983d9df16ec16a3139bac50e8">Native_handle</a> ipc::transport::Persistent_mq_handle::native_handle </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Available if and only if <a class="el" href="classipc_1_1transport_1_1Persistent__mq__handle.html#ac2c0b560893c6a8b71aac0e748770076" title="true if and only if native_handle() method exists, and the returned value may be waited-on by poll()/...">S_HAS_NATIVE_HANDLE</a> is <code>true</code>: Returns the stored native MQ handle; null means a constructor failed, or <code>*this</code> has been moved-from, hence the handle is to not-a-queue. </p>
<p >See class doc header for important background discussion w/r/t the rationale behind this method.</p>
<p >Medium-length story short: this is (in Linux impl of POSIX MQ) really an FD and as such can be wrapped via <code>boost::asio::posix::descriptor</code> and hence participate in a <code>Task_engine</code> event loop which internally will use <code>epoll()</code> together with all the other waited-on resources; or simply be <code>poll()</code>ed (etc.). E.g., boost.asio <code>async_wait()</code> for readability; then invoke <code>this-&gt;<a class="el" href="classipc_1_1transport_1_1Persistent__mq__handle.html#a84f802c77b0ce93d59e7ac78839f14cc" title="Non-blocking receive: pops copy of message from queue into buffer and returns true; if queue is empty...">try_receive()</a></code> once it is readable.</p>
<p >Behavior is undefined if you operate on this value, such as sending or receiving, concurrently to any transmission APIs acting on <code>*this</code>.</p>
<dl class="section note"><dt>Note</dt><dd>It is possible to get away with not using this by using the <code>*_sendable()</code> and <code>*_receivable()</code> methods. However the blocking and timed variations cannot be straightforwardly interrupted.</dd></dl>
<dl class="section return"><dt>Returns</dt><dd>See above. </dd></dl>

</div>
</div>
<a id="a30b2d1fdc3cae55c9c1fe8a1014247ff" name="a30b2d1fdc3cae55c9c1fe8a1014247ff"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a30b2d1fdc3cae55c9c1fe8a1014247ff">&#9670;&nbsp;</a></span>operator=()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classipc_1_1transport_1_1Persistent__mq__handle.html">Persistent_mq_handle</a> &amp; ipc::transport::Persistent_mq_handle::operator= </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classipc_1_1transport_1_1Persistent__mq__handle.html">Persistent_mq_handle</a> &amp;&amp;&#160;</td>
          <td class="paramname"><em>src</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Replaces handle with the source handle while making the latter invalid. </p>
<p >If you do anything on <code>src</code> after this, other than invoking dtor or move-assignment, behavior is undefined.</p>
<p >Informally: this is a light-weight op.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">src</td><td>Source object which is nullified. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>*this</code>. </dd></dl>

</div>
</div>
<a id="ae1e6822d16d30dc57c95e3e051e5f8a8" name="ae1e6822d16d30dc57c95e3e051e5f8a8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae1e6822d16d30dc57c95e3e051e5f8a8">&#9670;&nbsp;</a></span>receive()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ipc::transport::Persistent_mq_handle::receive </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespaceipc_1_1util.html#a6cb62ae434900f3a8915b33ec5d61a96">util::Blob_mutable</a> *&#160;</td>
          <td class="paramname"><em>blob</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceipc.html#aa3192e586cc45d3e7c22463bf2760f89">Error_code</a> *&#160;</td>
          <td class="paramname"><em>err_code</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Blocking receive: pops copy of message from queue into buffer; if queue is empty blocks until it is not. </p>
<p >On <code>true</code> <code>blob-&gt;size()</code> is modified to store the # of bytes received. A null blob (<code>blob-&gt;size() == 0</code> post-condition) is possible.</p>
<p >If error is emitted, <code>*this</code> shall be considered hosed: Behavior is undefined except dtor or move-assignment. Exception to this: If <code>blob-&gt;size()</code> is less than the required message size (or upper limit on this, if any), a particular error, which shall be documented below, is emitted; this is not fatal to <code>*this</code>. Exception to this: <a class="el" href="classipc_1_1transport_1_1Persistent__mq__handle.html#a206333d3eb619588d17812f8f49013a2" title="Enables receives-interrupted mode: is_receivable() (future calls), receive() (future or concurrent ca...">interrupt_receives()</a> leads to the emission of a particular error which shall be documented below; this is not fatal to `*this.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">blob</td><td>See <a class="el" href="classipc_1_1transport_1_1Persistent__mq__handle.html#a84f802c77b0ce93d59e7ac78839f14cc" title="Non-blocking receive: pops copy of message from queue into buffer and returns true; if queue is empty...">try_receive()</a>. </td></tr>
    <tr><td class="paramname">err_code</td><td>See <code>flow::Error_code</code> docs for error reporting semantics. <a class="el" href="namespaceipc.html#aa3192e586cc45d3e7c22463bf2760f89" title="Short-hand for flow::Error_code which is very common.">Error_code</a> generated: various. Would-block shall not be emitted. <a class="el" href="namespaceipc_1_1transport_1_1error.html#adfef15ef4e76cc55d652fbd9c2797297a9ee20939f859e44681c24f6d153cc36b" title="Low-level message queue send-op buffer overflow (&gt; max size) or receive-op buffer underflow (&lt; max si...">error::Code::S_MQ_MESSAGE_SIZE_OVER_OR_UNDERFLOW</a> (size-underflow error: buffer is smaller than <a class="el" href="classipc_1_1transport_1_1Persistent__mq__handle.html#ae2efe92707c53c46bc70b84f96bda217" title="Returns the max message size of the underlying queue.">max_msg_size()</a>). <a class="el" href="namespaceipc_1_1transport_1_1error.html#adfef15ef4e76cc55d652fbd9c2797297a291f8a813c292ccdb475c345181653ac" title="A blocking operation was intentionally interrupted or preemptively canceled.">error::Code::S_INTERRUPTED</a> (preempted or interrupted by <a class="el" href="classipc_1_1transport_1_1Persistent__mq__handle.html#a206333d3eb619588d17812f8f49013a2" title="Enables receives-interrupted mode: is_receivable() (future calls), receive() (future or concurrent ca...">interrupt_receives()</a>). </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a2e8b8102fdbacc064d4759533a725f51" name="a2e8b8102fdbacc064d4759533a725f51"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2e8b8102fdbacc064d4759533a725f51">&#9670;&nbsp;</a></span>remove_persistent()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void ipc::transport::Persistent_mq_handle::remove_persistent </td>
          <td>(</td>
          <td class="paramtype">flow::log::Logger *&#160;</td>
          <td class="paramname"><em>logger_ptr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespaceipc_1_1transport.html#a33de1c256addb3964b839dc2dd407d24">Shared_name</a> &amp;&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceipc.html#aa3192e586cc45d3e7c22463bf2760f89">Error_code</a> *&#160;</td>
          <td class="paramname"><em>err_code</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Removes the named persistent MQ. </p>
<p >The name <code>name</code> is removed from the system immediately; and the function is non-blocking. However the underlying MQ if any continues to exist until all handles to it are closed; their presence in this or other process is <em>not</em> an error.</p>
<dl class="section see"><dt>See also</dt><dd><code>util::remove_each_persistent_*</code>() for a convenient way to remove more than one item. E.g., <code><a class="el" href="namespaceipc_1_1util.html#ad6be904bf1b0fe6659a11dec0fabbf6b" title="Utility that invokes remove_each_persistent_if() with the filter that returns true (yes,...">util::remove_each_persistent_with_name_prefix</a>&lt;Pool_arena&gt;()</code> combines <a class="el" href="classipc_1_1transport_1_1Persistent__mq__handle.html#a2e8b8102fdbacc064d4759533a725f51" title="Removes the named persistent MQ.">remove_persistent()</a> and <a class="el" href="classipc_1_1transport_1_1Persistent__mq__handle.html#ac14dd419cdbc97b6630900268f8b7dd2" title="Lists all named persistent MQs currently persisting, invoking the given handler synchronously on each...">for_each_persistent()</a> in a common-sense way to remove only those <code>name</code>s starting with a given prefix; or simply all of them.</dd></dl>
<p>Trying to remove a non-existent name <em>is</em> an error.</p>
<p >Logs INFO message.</p>
<dl class="section warning"><dt>Warning</dt><dd>The impl should be carefully checked to conform to this. As of this writing the 2 relevant low-level MQ APIs (bipc and POSIX) do, but there could be more.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">logger_ptr</td><td>Logger to use for subsequently logging. </td></tr>
    <tr><td class="paramname">name</td><td>Absolute name at which the persistent MQ lives. </td></tr>
    <tr><td class="paramname">err_code</td><td>See <code>flow::Error_code</code> docs for error reporting semantics. <a class="el" href="namespaceipc.html#aa3192e586cc45d3e7c22463bf2760f89" title="Short-hand for flow::Error_code which is very common.">Error_code</a> generated: various. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a9d54e47b729eec9f72dee869326bfa8f" name="a9d54e47b729eec9f72dee869326bfa8f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9d54e47b729eec9f72dee869326bfa8f">&#9670;&nbsp;</a></span>send()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ipc::transport::Persistent_mq_handle::send </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespaceipc_1_1util.html#ae0be7edba7e30ffa3f8b742af621f2ab">util::Blob_const</a> &amp;&#160;</td>
          <td class="paramname"><em>blob</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceipc.html#aa3192e586cc45d3e7c22463bf2760f89">Error_code</a> *&#160;</td>
          <td class="paramname"><em>err_code</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Blocking send: pushes copy of message to queue; if queue is full blocks until it is not. </p>
<p >A null blob (<code>blob.size() == 0</code>) is allowed.</p>
<p >If error is emitted, <code>*this</code> shall be considered hosed: Behavior is undefined except dtor or move-assignment. Exception to this: If <code>blob.size()</code> exceeds message size limit (if any), a particular error, which shall be documented below, is emitted; this is not fatal to <code>*this</code>. Exception to this: <a class="el" href="classipc_1_1transport_1_1Persistent__mq__handle.html#af7a883553df39b16047b49942bd734c0" title="Enables sends-interrupted mode: is_sendable() (future calls), send() (future or concurrent calls),...">interrupt_sends()</a> leads to the emission of a particular error which shall be documented below; this is not fatal to `*this.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">blob</td><td>See <a class="el" href="classipc_1_1transport_1_1Persistent__mq__handle.html#ad9d38e0e16931dd96738d53b787533a1" title="Non-blocking send: pushes copy of message to queue and returns true; if queue is full then no-op and ...">try_send()</a>. </td></tr>
    <tr><td class="paramname">err_code</td><td>See <code>flow::Error_code</code> docs for error reporting semantics. <a class="el" href="namespaceipc.html#aa3192e586cc45d3e7c22463bf2760f89" title="Short-hand for flow::Error_code which is very common.">Error_code</a> generated: various. Would-block shall not be emitted. <a class="el" href="namespaceipc_1_1transport_1_1error.html#adfef15ef4e76cc55d652fbd9c2797297a9ee20939f859e44681c24f6d153cc36b" title="Low-level message queue send-op buffer overflow (&gt; max size) or receive-op buffer underflow (&lt; max si...">error::Code::S_MQ_MESSAGE_SIZE_OVER_OR_UNDERFLOW</a> (excessive-size error: buffer exceeds <a class="el" href="classipc_1_1transport_1_1Persistent__mq__handle.html#ae2efe92707c53c46bc70b84f96bda217" title="Returns the max message size of the underlying queue.">max_msg_size()</a>). <a class="el" href="namespaceipc_1_1transport_1_1error.html#adfef15ef4e76cc55d652fbd9c2797297a291f8a813c292ccdb475c345181653ac" title="A blocking operation was intentionally interrupted or preemptively canceled.">error::Code::S_INTERRUPTED</a> (preempted or interrupted by <a class="el" href="classipc_1_1transport_1_1Persistent__mq__handle.html#af7a883553df39b16047b49942bd734c0" title="Enables sends-interrupted mode: is_sendable() (future calls), send() (future or concurrent calls),...">interrupt_sends()</a>). </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="af547b6f1b1e51a7d6f6fbafc14c95f9d" name="af547b6f1b1e51a7d6f6fbafc14c95f9d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af547b6f1b1e51a7d6f6fbafc14c95f9d">&#9670;&nbsp;</a></span>timed_receive()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool ipc::transport::Persistent_mq_handle::timed_receive </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespaceipc_1_1util.html#a6cb62ae434900f3a8915b33ec5d61a96">util::Blob_mutable</a> *&#160;</td>
          <td class="paramname"><em>blob</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceipc_1_1util.html#ac66141280c3b7295a86b65209f31cc58">util::Fine_duration</a>&#160;</td>
          <td class="paramname"><em>timeout_from_now</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceipc.html#aa3192e586cc45d3e7c22463bf2760f89">Error_code</a> *&#160;</td>
          <td class="paramname"><em>err_code</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Blocking timed receive: pops copy of message from queue into buffer; if queue is empty blocks until it is not, or the specified time passes, whichever happens first. </p>
<p >Returns <code>true</code> on success; <code>false</code> on timeout or error. On <code>true</code> <code>blob-&gt;size()</code> is modified to store the # of bytes received. A null blob (<code>blob-&gt;size() == 0</code> post-condition) is possible.</p>
<p >If error is emitted, <code>*this</code> shall be considered hosed: Behavior is undefined except dtor or move-assignment. Exception to this: If <code>blob-&gt;size()</code> is less than the required message size (or upper limit on this, if any), a particular error, which shall be documented below, is emitted; this is not fatal to <code>*this</code>.</p>
<dl class="section warning"><dt>Warning</dt><dd>Read the warning on <a class="el" href="classipc_1_1transport_1_1Persistent__mq__handle.html#ab4cba10b83df79acf76c64b0deb7f624" title="Blocking timed send: pushes copy of message to queue; if queue is full blocks until it is not,...">timed_send()</a> about the accuracy of the timeout. Same applies here.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">blob</td><td>See <a class="el" href="classipc_1_1transport_1_1Persistent__mq__handle.html#a84f802c77b0ce93d59e7ac78839f14cc" title="Non-blocking receive: pops copy of message from queue into buffer and returns true; if queue is empty...">try_receive()</a>. </td></tr>
    <tr><td class="paramname">timeout_from_now</td><td>Now + (this long) = the timeout time point. </td></tr>
    <tr><td class="paramname">err_code</td><td>See <code>flow::Error_code</code> docs for error reporting semantics. <a class="el" href="namespaceipc.html#aa3192e586cc45d3e7c22463bf2760f89" title="Short-hand for flow::Error_code which is very common.">Error_code</a> generated: various. Would-block shall not be emitted. Timeout shall not be emitted. <a class="el" href="namespaceipc_1_1transport_1_1error.html#adfef15ef4e76cc55d652fbd9c2797297a9ee20939f859e44681c24f6d153cc36b" title="Low-level message queue send-op buffer overflow (&gt; max size) or receive-op buffer underflow (&lt; max si...">error::Code::S_MQ_MESSAGE_SIZE_OVER_OR_UNDERFLOW</a> (size-underflow error: buffer is smaller than <a class="el" href="classipc_1_1transport_1_1Persistent__mq__handle.html#ae2efe92707c53c46bc70b84f96bda217" title="Returns the max message size of the underlying queue.">max_msg_size()</a>). <a class="el" href="namespaceipc_1_1transport_1_1error.html#adfef15ef4e76cc55d652fbd9c2797297a291f8a813c292ccdb475c345181653ac" title="A blocking operation was intentionally interrupted or preemptively canceled.">error::Code::S_INTERRUPTED</a> (preempted or interrupted by <a class="el" href="classipc_1_1transport_1_1Persistent__mq__handle.html#a206333d3eb619588d17812f8f49013a2" title="Enables receives-interrupted mode: is_receivable() (future calls), receive() (future or concurrent ca...">interrupt_receives()</a>). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> on success; <code>false</code> on failure; in the latter case <code>*err_code</code> distinguishes between timeout and fatal error. </dd></dl>

</div>
</div>
<a id="ab4cba10b83df79acf76c64b0deb7f624" name="ab4cba10b83df79acf76c64b0deb7f624"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab4cba10b83df79acf76c64b0deb7f624">&#9670;&nbsp;</a></span>timed_send()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool ipc::transport::Persistent_mq_handle::timed_send </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespaceipc_1_1util.html#ae0be7edba7e30ffa3f8b742af621f2ab">util::Blob_const</a> &amp;&#160;</td>
          <td class="paramname"><em>blob</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceipc_1_1util.html#ac66141280c3b7295a86b65209f31cc58">util::Fine_duration</a>&#160;</td>
          <td class="paramname"><em>timeout_from_now</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceipc.html#aa3192e586cc45d3e7c22463bf2760f89">Error_code</a> *&#160;</td>
          <td class="paramname"><em>err_code</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Blocking timed send: pushes copy of message to queue; if queue is full blocks until it is not, or the specified time passes, whichever happens first. </p>
<p >Returns <code>true</code> on success; <code>false</code> on timeout or error. A null blob (<code>blob.size() == 0</code>) is allowed.</p>
<p >If error is emitted, <code>*this</code> shall be considered hosed: Behavior is undefined except dtor or move-assignment. Exception to this: If <code>blob.size()</code> exceeds message size limit (if any), a particular error, which shall be documented below, is emitted; this is not fatal to <code>*this</code>. Exception to this: <a class="el" href="classipc_1_1transport_1_1Persistent__mq__handle.html#af7a883553df39b16047b49942bd734c0" title="Enables sends-interrupted mode: is_sendable() (future calls), send() (future or concurrent calls),...">interrupt_sends()</a> leads to the emission of a particular error which shall be documented below; this is not fatal to `*this.</p>
<dl class="section warning"><dt>Warning</dt><dd>The user must not count on precision/stability &ndash; unlike with, say, boost.asio timers &ndash; here. If timing precision is required, the user will have to add an async layer with more precise timing and not rely on this. For example, informally, suggest: Use <a class="el" href="classipc_1_1transport_1_1Persistent__mq__handle.html#ab4cba10b83df79acf76c64b0deb7f624" title="Blocking timed send: pushes copy of message to queue; if queue is full blocks until it is not,...">timed_send()</a> with 250msec increments to model an interruptible indefinitely-blocking <a class="el" href="classipc_1_1transport_1_1Persistent__mq__handle.html#a9d54e47b729eec9f72dee869326bfa8f" title="Blocking send: pushes copy of message to queue; if queue is full blocks until it is not.">send()</a>. In a parallel thread, if it's time to interrupt the modeled endless <a class="el" href="classipc_1_1transport_1_1Persistent__mq__handle.html#a9d54e47b729eec9f72dee869326bfa8f" title="Blocking send: pushes copy of message to queue; if queue is full blocks until it is not.">send()</a>, set some flag that'll cause the 250msec-long attempts to cease. The last one (that straddles the interruption point) can just be ignored.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">blob</td><td>See <a class="el" href="classipc_1_1transport_1_1Persistent__mq__handle.html#ad9d38e0e16931dd96738d53b787533a1" title="Non-blocking send: pushes copy of message to queue and returns true; if queue is full then no-op and ...">try_send()</a>. </td></tr>
    <tr><td class="paramname">timeout_from_now</td><td>Now + (this long) = the timeout time point. </td></tr>
    <tr><td class="paramname">err_code</td><td>See <code>flow::Error_code</code> docs for error reporting semantics. <a class="el" href="namespaceipc.html#aa3192e586cc45d3e7c22463bf2760f89" title="Short-hand for flow::Error_code which is very common.">Error_code</a> generated: various. Would-block shall not be emitted. Timeout shall not be emitted. <a class="el" href="namespaceipc_1_1transport_1_1error.html#adfef15ef4e76cc55d652fbd9c2797297a9ee20939f859e44681c24f6d153cc36b" title="Low-level message queue send-op buffer overflow (&gt; max size) or receive-op buffer underflow (&lt; max si...">error::Code::S_MQ_MESSAGE_SIZE_OVER_OR_UNDERFLOW</a> (excessive-size error: buffer exceeds <a class="el" href="classipc_1_1transport_1_1Persistent__mq__handle.html#ae2efe92707c53c46bc70b84f96bda217" title="Returns the max message size of the underlying queue.">max_msg_size()</a>). <a class="el" href="namespaceipc_1_1transport_1_1error.html#adfef15ef4e76cc55d652fbd9c2797297a291f8a813c292ccdb475c345181653ac" title="A blocking operation was intentionally interrupted or preemptively canceled.">error::Code::S_INTERRUPTED</a> (preempted or interrupted by <a class="el" href="classipc_1_1transport_1_1Persistent__mq__handle.html#af7a883553df39b16047b49942bd734c0" title="Enables sends-interrupted mode: is_sendable() (future calls), send() (future or concurrent calls),...">interrupt_sends()</a>). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> on success; <code>false</code> on failure; in the latter case <code>*err_code</code> distinguishes between timeout and fatal error. </dd></dl>

</div>
</div>
<a id="ac4f13853e38ade577faabbf9ef0af74f" name="ac4f13853e38ade577faabbf9ef0af74f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac4f13853e38ade577faabbf9ef0af74f">&#9670;&nbsp;</a></span>timed_wait_receivable()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool ipc::transport::Persistent_mq_handle::timed_wait_receivable </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespaceipc_1_1util.html#ac66141280c3b7295a86b65209f31cc58">util::Fine_duration</a>&#160;</td>
          <td class="paramname"><em>timeout_from_now</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceipc.html#aa3192e586cc45d3e7c22463bf2760f89">Error_code</a> *&#160;</td>
          <td class="paramname"><em>err_code</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Equivalent to <a class="el" href="classipc_1_1transport_1_1Persistent__mq__handle.html#af547b6f1b1e51a7d6f6fbafc14c95f9d" title="Blocking timed receive: pops copy of message from queue into buffer; if queue is empty blocks until i...">timed_receive()</a> except stops short of reading anything, with <code>true</code> result indicating that <a class="el" href="classipc_1_1transport_1_1Persistent__mq__handle.html#a84f802c77b0ce93d59e7ac78839f14cc" title="Non-blocking receive: pops copy of message from queue into buffer and returns true; if queue is empty...">try_receive()</a> <em>would</em> work at that moment. </p>
<p >It shall block until fatal error, or <a class="el" href="namespaceipc_1_1transport_1_1error.html#adfef15ef4e76cc55d652fbd9c2797297a291f8a813c292ccdb475c345181653ac" title="A blocking operation was intentionally interrupted or preemptively canceled.">error::Code::S_INTERRUPTED</a>, or timeout, or transmissibility.</p>
<p >If error is emitted, <code>*this</code> shall be considered hosed: Behavior is undefined except dtor or move-assignment. Exception to this: <a class="el" href="classipc_1_1transport_1_1Persistent__mq__handle.html#a206333d3eb619588d17812f8f49013a2" title="Enables receives-interrupted mode: is_receivable() (future calls), receive() (future or concurrent ca...">interrupt_receives()</a> leads to the emission of a particular error which shall be documented below; this is not fatal to `*this.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">timeout_from_now</td><td>See <a class="el" href="classipc_1_1transport_1_1Persistent__mq__handle.html#af547b6f1b1e51a7d6f6fbafc14c95f9d" title="Blocking timed receive: pops copy of message from queue into buffer; if queue is empty blocks until i...">timed_receive()</a>. </td></tr>
    <tr><td class="paramname">err_code</td><td>See <code>flow::Error_code</code> docs for error reporting semantics. <a class="el" href="namespaceipc.html#aa3192e586cc45d3e7c22463bf2760f89" title="Short-hand for flow::Error_code which is very common.">Error_code</a> generated: various. Would-block shall not be emitted. <a class="el" href="namespaceipc_1_1transport_1_1error.html#adfef15ef4e76cc55d652fbd9c2797297a291f8a813c292ccdb475c345181653ac" title="A blocking operation was intentionally interrupted or preemptively canceled.">error::Code::S_INTERRUPTED</a> (preempted or interrupted by <a class="el" href="classipc_1_1transport_1_1Persistent__mq__handle.html#a206333d3eb619588d17812f8f49013a2" title="Enables receives-interrupted mode: is_receivable() (future calls), receive() (future or concurrent ca...">interrupt_receives()</a>). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if transmissible; <code>false</code> if not, or on error or timeout; in the latter case <code>*err_code</code> distinguishes between timeout and fatal error. </dd></dl>

</div>
</div>
<a id="aadfffb71ff2fec6508174fdf4b08327e" name="aadfffb71ff2fec6508174fdf4b08327e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aadfffb71ff2fec6508174fdf4b08327e">&#9670;&nbsp;</a></span>timed_wait_sendable()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool ipc::transport::Persistent_mq_handle::timed_wait_sendable </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespaceipc_1_1util.html#ac66141280c3b7295a86b65209f31cc58">util::Fine_duration</a>&#160;</td>
          <td class="paramname"><em>timeout_from_now</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceipc.html#aa3192e586cc45d3e7c22463bf2760f89">Error_code</a> *&#160;</td>
          <td class="paramname"><em>err_code</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Equivalent to <a class="el" href="classipc_1_1transport_1_1Persistent__mq__handle.html#ab4cba10b83df79acf76c64b0deb7f624" title="Blocking timed send: pushes copy of message to queue; if queue is full blocks until it is not,...">timed_send()</a> except stops short of writing anything, with <code>true</code> result indicating that <a class="el" href="classipc_1_1transport_1_1Persistent__mq__handle.html#ad9d38e0e16931dd96738d53b787533a1" title="Non-blocking send: pushes copy of message to queue and returns true; if queue is full then no-op and ...">try_send()</a> <em>would</em> work at that moment. </p>
<p >It shall block until fatal error, or <a class="el" href="namespaceipc_1_1transport_1_1error.html#adfef15ef4e76cc55d652fbd9c2797297a291f8a813c292ccdb475c345181653ac" title="A blocking operation was intentionally interrupted or preemptively canceled.">error::Code::S_INTERRUPTED</a>, or timeout, or transmissibility.</p>
<p >If error is emitted, <code>*this</code> shall be considered hosed: Behavior is undefined except dtor or move-assignment. Exception to this: <a class="el" href="classipc_1_1transport_1_1Persistent__mq__handle.html#af7a883553df39b16047b49942bd734c0" title="Enables sends-interrupted mode: is_sendable() (future calls), send() (future or concurrent calls),...">interrupt_sends()</a> leads to the emission of a particular error which shall be documented below; this is not fatal to `*this.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">timeout_from_now</td><td>See <a class="el" href="classipc_1_1transport_1_1Persistent__mq__handle.html#ab4cba10b83df79acf76c64b0deb7f624" title="Blocking timed send: pushes copy of message to queue; if queue is full blocks until it is not,...">timed_send()</a>. </td></tr>
    <tr><td class="paramname">err_code</td><td>See <code>flow::Error_code</code> docs for error reporting semantics. <a class="el" href="namespaceipc.html#aa3192e586cc45d3e7c22463bf2760f89" title="Short-hand for flow::Error_code which is very common.">Error_code</a> generated: various. Would-block shall not be emitted. <a class="el" href="namespaceipc_1_1transport_1_1error.html#adfef15ef4e76cc55d652fbd9c2797297a291f8a813c292ccdb475c345181653ac" title="A blocking operation was intentionally interrupted or preemptively canceled.">error::Code::S_INTERRUPTED</a> (preempted or interrupted by <a class="el" href="classipc_1_1transport_1_1Persistent__mq__handle.html#af7a883553df39b16047b49942bd734c0" title="Enables sends-interrupted mode: is_sendable() (future calls), send() (future or concurrent calls),...">interrupt_sends()</a>). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if transmissible; <code>false</code> if not, or on error or timeout; in the latter case <code>*err_code</code> distinguishes between timeout and fatal error. </dd></dl>

</div>
</div>
<a id="a84f802c77b0ce93d59e7ac78839f14cc" name="a84f802c77b0ce93d59e7ac78839f14cc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a84f802c77b0ce93d59e7ac78839f14cc">&#9670;&nbsp;</a></span>try_receive()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool ipc::transport::Persistent_mq_handle::try_receive </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespaceipc_1_1util.html#a6cb62ae434900f3a8915b33ec5d61a96">util::Blob_mutable</a> *&#160;</td>
          <td class="paramname"><em>blob</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceipc.html#aa3192e586cc45d3e7c22463bf2760f89">Error_code</a> *&#160;</td>
          <td class="paramname"><em>err_code</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Non-blocking receive: pops copy of message from queue into buffer and returns <code>true</code>; if queue is empty then no-op and returns <code>false</code>. </p>
<p >On <code>true</code> <code>blob-&gt;size()</code> is modified to store the # of bytes received. A null blob (<code>blob-&gt;size() == 0</code> post-condition) is possible.</p>
<p >If error is emitted, <code>*this</code> shall be considered hosed: Behavior is undefined except dtor or move-assignment. Exception to this: If <code>blob-&gt;size()</code> is less than the required message size (or upper limit on this, if any), a particular error, which shall be documented below, is emitted; this is not fatal to <code>*this</code>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">blob</td><td>Buffer into which to copy into MQ and whose <code>-&gt;size()</code> to update to the # of bytes received; if message empty it is set to zero. Original <code>-&gt;size()</code> value indicates capacity of buffer; if this is insufficient based on either the popped message size or an upper limit (if any), it is an error. </td></tr>
    <tr><td class="paramname">err_code</td><td>See <code>flow::Error_code</code> docs for error reporting semantics. <a class="el" href="namespaceipc.html#aa3192e586cc45d3e7c22463bf2760f89" title="Short-hand for flow::Error_code which is very common.">Error_code</a> generated: various. Would-block shall not be emitted. <a class="el" href="namespaceipc_1_1transport_1_1error.html#adfef15ef4e76cc55d652fbd9c2797297a9ee20939f859e44681c24f6d153cc36b" title="Low-level message queue send-op buffer overflow (&gt; max size) or receive-op buffer underflow (&lt; max si...">error::Code::S_MQ_MESSAGE_SIZE_OVER_OR_UNDERFLOW</a> (size-underflow error: buffer is smaller than <a class="el" href="classipc_1_1transport_1_1Persistent__mq__handle.html#ae2efe92707c53c46bc70b84f96bda217" title="Returns the max message size of the underlying queue.">max_msg_size()</a>). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> on success; <code>false</code> on failure; in the latter case <code>*err_code</code> distinguishes between would-block and fatal error. </dd></dl>

</div>
</div>
<a id="ad9d38e0e16931dd96738d53b787533a1" name="ad9d38e0e16931dd96738d53b787533a1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad9d38e0e16931dd96738d53b787533a1">&#9670;&nbsp;</a></span>try_send()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool ipc::transport::Persistent_mq_handle::try_send </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespaceipc_1_1util.html#ae0be7edba7e30ffa3f8b742af621f2ab">util::Blob_const</a> &amp;&#160;</td>
          <td class="paramname"><em>blob</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceipc.html#aa3192e586cc45d3e7c22463bf2760f89">Error_code</a> *&#160;</td>
          <td class="paramname"><em>err_code</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Non-blocking send: pushes copy of message to queue and returns <code>true</code>; if queue is full then no-op and returns <code>false</code>. </p>
<p >A null blob (<code>blob.size() == 0</code>) is allowed.</p>
<p >If error is emitted, <code>*this</code> shall be considered hosed: Behavior is undefined except dtor or move-assignment. Exception to this: If <code>blob.size()</code> exceeds message size limit (if any), a particular error, which shall be documented below, is emitted; this is not fatal to <code>*this</code>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">blob</td><td>Buffer to copy into MQ; if empty then an empty message is pushed. </td></tr>
    <tr><td class="paramname">err_code</td><td>See <code>flow::Error_code</code> docs for error reporting semantics. <a class="el" href="namespaceipc.html#aa3192e586cc45d3e7c22463bf2760f89" title="Short-hand for flow::Error_code which is very common.">Error_code</a> generated: various. Would-block shall not be emitted. <a class="el" href="namespaceipc_1_1transport_1_1error.html#adfef15ef4e76cc55d652fbd9c2797297a9ee20939f859e44681c24f6d153cc36b" title="Low-level message queue send-op buffer overflow (&gt; max size) or receive-op buffer underflow (&lt; max si...">error::Code::S_MQ_MESSAGE_SIZE_OVER_OR_UNDERFLOW</a> (excessive-size error: buffer exceeds <a class="el" href="classipc_1_1transport_1_1Persistent__mq__handle.html#ae2efe92707c53c46bc70b84f96bda217" title="Returns the max message size of the underlying queue.">max_msg_size()</a>). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> on success; <code>false</code> on failure; in the latter case <code>*err_code</code> distinguishes between would-block and fatal error. </dd></dl>

</div>
</div>
<a id="a7029f9601aa268022bd8cf7970c512c8" name="a7029f9601aa268022bd8cf7970c512c8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7029f9601aa268022bd8cf7970c512c8">&#9670;&nbsp;</a></span>wait_receivable()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ipc::transport::Persistent_mq_handle::wait_receivable </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespaceipc.html#aa3192e586cc45d3e7c22463bf2760f89">Error_code</a> *&#160;</td>
          <td class="paramname"><em>err_code</em> = <code>0</code></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Equivalent to <a class="el" href="classipc_1_1transport_1_1Persistent__mq__handle.html#ae1e6822d16d30dc57c95e3e051e5f8a8" title="Blocking receive: pops copy of message from queue into buffer; if queue is empty blocks until it is n...">receive()</a> except stops short of reading anything, with non-error return indicating that <a class="el" href="classipc_1_1transport_1_1Persistent__mq__handle.html#a84f802c77b0ce93d59e7ac78839f14cc" title="Non-blocking receive: pops copy of message from queue into buffer and returns true; if queue is empty...">try_receive()</a> <em>would</em> work at that moment. </p>
<p >It shall block indefinitely until fatal error, or <a class="el" href="namespaceipc_1_1transport_1_1error.html#adfef15ef4e76cc55d652fbd9c2797297a291f8a813c292ccdb475c345181653ac" title="A blocking operation was intentionally interrupted or preemptively canceled.">error::Code::S_INTERRUPTED</a>, or transmissibility.</p>
<p >If error is emitted, <code>*this</code> shall be considered hosed: Behavior is undefined except dtor or move-assignment. Exception to this: <a class="el" href="classipc_1_1transport_1_1Persistent__mq__handle.html#a206333d3eb619588d17812f8f49013a2" title="Enables receives-interrupted mode: is_receivable() (future calls), receive() (future or concurrent ca...">interrupt_receives()</a> leads to the emission of a particular error which shall be documented below; this is not fatal to `*this.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">err_code</td><td>See <code>flow::Error_code</code> docs for error reporting semantics. <a class="el" href="namespaceipc.html#aa3192e586cc45d3e7c22463bf2760f89" title="Short-hand for flow::Error_code which is very common.">Error_code</a> generated: various. Would-block shall not be emitted. <a class="el" href="namespaceipc_1_1transport_1_1error.html#adfef15ef4e76cc55d652fbd9c2797297a291f8a813c292ccdb475c345181653ac" title="A blocking operation was intentionally interrupted or preemptively canceled.">error::Code::S_INTERRUPTED</a> (preempted or interrupted by <a class="el" href="classipc_1_1transport_1_1Persistent__mq__handle.html#a206333d3eb619588d17812f8f49013a2" title="Enables receives-interrupted mode: is_receivable() (future calls), receive() (future or concurrent ca...">interrupt_receives()</a>). </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a230060aa545bfe11eb263211c84514f1" name="a230060aa545bfe11eb263211c84514f1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a230060aa545bfe11eb263211c84514f1">&#9670;&nbsp;</a></span>wait_sendable()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ipc::transport::Persistent_mq_handle::wait_sendable </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespaceipc.html#aa3192e586cc45d3e7c22463bf2760f89">Error_code</a> *&#160;</td>
          <td class="paramname"><em>err_code</em> = <code>0</code></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Equivalent to <a class="el" href="classipc_1_1transport_1_1Persistent__mq__handle.html#a9d54e47b729eec9f72dee869326bfa8f" title="Blocking send: pushes copy of message to queue; if queue is full blocks until it is not.">send()</a> except stops short of writing anything, with non-error return indicating that <a class="el" href="classipc_1_1transport_1_1Persistent__mq__handle.html#ad9d38e0e16931dd96738d53b787533a1" title="Non-blocking send: pushes copy of message to queue and returns true; if queue is full then no-op and ...">try_send()</a> <em>would</em> work at that moment. </p>
<p >It shall block indefinitely until fatal error, or <a class="el" href="namespaceipc_1_1transport_1_1error.html#adfef15ef4e76cc55d652fbd9c2797297a291f8a813c292ccdb475c345181653ac" title="A blocking operation was intentionally interrupted or preemptively canceled.">error::Code::S_INTERRUPTED</a>, or transmissibility.</p>
<p >If error is emitted, <code>*this</code> shall be considered hosed: Behavior is undefined except dtor or move-assignment. Exception to this: <a class="el" href="classipc_1_1transport_1_1Persistent__mq__handle.html#af7a883553df39b16047b49942bd734c0" title="Enables sends-interrupted mode: is_sendable() (future calls), send() (future or concurrent calls),...">interrupt_sends()</a> leads to the emission of a particular error which shall be documented below; this is not fatal to `*this.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">err_code</td><td>See <code>flow::Error_code</code> docs for error reporting semantics. <a class="el" href="namespaceipc.html#aa3192e586cc45d3e7c22463bf2760f89" title="Short-hand for flow::Error_code which is very common.">Error_code</a> generated: various. Would-block shall not be emitted. <a class="el" href="namespaceipc_1_1transport_1_1error.html#adfef15ef4e76cc55d652fbd9c2797297a291f8a813c292ccdb475c345181653ac" title="A blocking operation was intentionally interrupted or preemptively canceled.">error::Code::S_INTERRUPTED</a> (preempted or interrupted by <a class="el" href="classipc_1_1transport_1_1Persistent__mq__handle.html#af7a883553df39b16047b49942bd734c0" title="Enables sends-interrupted mode: is_sendable() (future calls), send() (future or concurrent calls),...">interrupt_sends()</a>). </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<h2 class="groupheader">Friends And Related Function Documentation</h2>
<a id="a6f670a864f39c533a6a98dbca8fdb224" name="a6f670a864f39c533a6a98dbca8fdb224"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6f670a864f39c533a6a98dbca8fdb224">&#9670;&nbsp;</a></span>swap()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void swap </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classipc_1_1transport_1_1Persistent__mq__handle.html">Persistent_mq_handle</a> &amp;&#160;</td>
          <td class="paramname"><em>val1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classipc_1_1transport_1_1Persistent__mq__handle.html">Persistent_mq_handle</a> &amp;&#160;</td>
          <td class="paramname"><em>val2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Swaps two objects. </p>
<p >Constant-time. Suitable for standard ADL-swap pattern <code>using std::swap; swap(val1, val2);</code>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">val1</td><td>Object. </td></tr>
    <tr><td class="paramname">val2</td><td>Object. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<h2 class="groupheader">Member Data Documentation</h2>
<a id="ac2c0b560893c6a8b71aac0e748770076" name="ac2c0b560893c6a8b71aac0e748770076"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac2c0b560893c6a8b71aac0e748770076">&#9670;&nbsp;</a></span>S_HAS_NATIVE_HANDLE</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr bool ipc::transport::Persistent_mq_handle::S_HAS_NATIVE_HANDLE = unspecified</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><code>true</code> if and only if <a class="el" href="classipc_1_1transport_1_1Persistent__mq__handle.html#a25e96c4f060cc3c4b611c4e2de60abaf" title="Available if and only if S_HAS_NATIVE_HANDLE is true: Returns the stored native MQ handle; null means...">native_handle()</a> method exists, and the returned value may be waited-on by <code>poll()</code>/etc. </p>

<p class="definition">Definition at line <a class="el" href="persistent__mq__handle_8hpp_source.html#l00203">203</a> of file <a class="el" href="persistent__mq__handle_8hpp_source.html">persistent_mq_handle.hpp</a>.</p>

</div>
</div>
<a id="ad49e1049101a5ab6cfb2ed2b3eaedee0" name="ad49e1049101a5ab6cfb2ed2b3eaedee0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad49e1049101a5ab6cfb2ed2b3eaedee0">&#9670;&nbsp;</a></span>S_RESOURCE_TYPE_ID</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="namespaceipc_1_1transport.html#a33de1c256addb3964b839dc2dd407d24">Shared_name</a> ipc::transport::Persistent_mq_handle::S_RESOURCE_TYPE_ID</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Shared_name relative-folder fragment (no separators) identifying this resource type. </p>

<p class="definition">Definition at line <a class="el" href="persistent__mq__handle_8hpp_source.html#l00200">200</a> of file <a class="el" href="persistent__mq__handle_8hpp_source.html">persistent_mq_handle.hpp</a>.</p>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li>transport/<a class="el" href="persistent__mq__handle_8hpp_source.html">persistent_mq_handle.hpp</a></li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Sat Jan 18 2025 05:55:27 for Flow-IPC by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.4
</small></address>
</body>
</html>
