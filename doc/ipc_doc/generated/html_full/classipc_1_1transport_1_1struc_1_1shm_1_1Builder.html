<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.9.4"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Flow-IPC: ipc::transport::struc::shm::Builder&lt; Shm_arena &gt; Class Template Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">Flow-IPC<span id="projectnumber">&#160;1.0</span>
   </div>
   <div id="projectbrief">Flow-IPC project: Full implementation reference.</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.4 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search",'Search','.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespaceipc.html">ipc</a></li><li class="navelem"><a class="el" href="namespaceipc_1_1transport.html">transport</a></li><li class="navelem"><a class="el" href="namespaceipc_1_1transport_1_1struc.html">struc</a></li><li class="navelem"><a class="el" href="namespaceipc_1_1transport_1_1struc_1_1shm.html">shm</a></li><li class="navelem"><a class="el" href="classipc_1_1transport_1_1struc_1_1shm_1_1Builder.html">Builder</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#pub-types">Public Types</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pri-types">Private Types</a> &#124;
<a href="#pri-attribs">Private Attributes</a> &#124;
<a href="#related">Related Functions</a> &#124;
<a href="classipc_1_1transport_1_1struc_1_1shm_1_1Builder-members.html">List of all members</a>  </div>
  <div class="headertitle"><div class="title">ipc::transport::struc::shm::Builder&lt; Shm_arena &gt; Class Template Reference</div></div>
</div><!--header-->
<div class="contents">

<p>Implements <a class="el" href="classipc_1_1transport_1_1struc_1_1Struct__builder.html" title="A documentation-only concept defining the behavior of an object capable of zero-copy-serializing,...">Struct_builder</a> concept with maximal zero-copy perf by (1) storing the actual user-schema-controlled message using the SHM provider of choice, in SHM, and (2) straightforwardly allocating 1 segment in regular heap and placing the SHM handle there for transmission over IPC.  
 <a href="classipc_1_1transport_1_1struc_1_1shm_1_1Builder.html#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="ipc__shm_2src_2ipc_2transport_2struc_2shm_2serializer_8hpp_source.html">serializer.hpp</a>&gt;</code></p>
<div class="dynheader">
Inheritance diagram for ipc::transport::struc::shm::Builder&lt; Shm_arena &gt;:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="classipc_1_1transport_1_1struc_1_1shm_1_1Builder__inherit__graph.svg" width="310" height="131"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe>
</div>
<center><span class="legend">[<a href="graph_legend.html">legend</a>]</span></center></div>
<div class="dynheader">
Collaboration diagram for ipc::transport::struc::shm::Builder&lt; Shm_arena &gt;:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="classipc_1_1transport_1_1struc_1_1shm_1_1Builder__coll__graph.svg" width="854" height="267"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe>
</div>
<center><span class="legend">[<a href="graph_legend.html">legend</a>]</span></center></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="nested-classes" name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structipc_1_1transport_1_1struc_1_1shm_1_1Builder_1_1Config.html">Config</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Implements <a class="el" href="structipc_1_1transport_1_1struc_1_1Struct__builder_1_1Config.html" title="Copy-ctible, copy-assignable, default-ctible type â€“ informally, cheaply copyable and likely an aggreg...">Struct_builder::Config</a> sub-concept.  <a href="structipc_1_1transport_1_1struc_1_1shm_1_1Builder_1_1Config.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-types" name="pub-types"></a>
Public Types</h2></td></tr>
<tr class="memitem:a9bc898884381eebdb03f0dd9f74895de"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classipc_1_1transport_1_1struc_1_1shm_1_1Builder.html#a9bc898884381eebdb03f0dd9f74895de">Arena</a> = Shm_arena</td></tr>
<tr class="memdesc:a9bc898884381eebdb03f0dd9f74895de"><td class="mdescLeft">&#160;</td><td class="mdescRight">Short-hand for <code>Shm_arena</code> template param.  <a href="classipc_1_1transport_1_1struc_1_1shm_1_1Builder.html#a9bc898884381eebdb03f0dd9f74895de">More...</a><br /></td></tr>
<tr class="separator:a9bc898884381eebdb03f0dd9f74895de"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2d9808d9b0c04cf84c8e439b1643506d"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classipc_1_1transport_1_1struc_1_1shm_1_1Builder.html#a2d9808d9b0c04cf84c8e439b1643506d">Session</a> = <a class="el" href="namespaceipc_1_1session_1_1shm.html#af2acc444cc9664e57df8143b66b78d70">session::shm::Arena_to_shm_session_t</a>&lt; <a class="el" href="classipc_1_1transport_1_1struc_1_1shm_1_1Builder.html#a9bc898884381eebdb03f0dd9f74895de">Arena</a> &gt; *</td></tr>
<tr class="memdesc:a2d9808d9b0c04cf84c8e439b1643506d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Implements concept API.  <a href="classipc_1_1transport_1_1struc_1_1shm_1_1Builder.html#a2d9808d9b0c04cf84c8e439b1643506d">More...</a><br /></td></tr>
<tr class="separator:a2d9808d9b0c04cf84c8e439b1643506d"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-methods" name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a9374ce7f0dc46bb841d9359df5d4045f"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classipc_1_1transport_1_1struc_1_1shm_1_1Builder.html#a9374ce7f0dc46bb841d9359df5d4045f">Builder</a> ()</td></tr>
<tr class="memdesc:a9374ce7f0dc46bb841d9359df5d4045f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Implements concept API.  <a href="classipc_1_1transport_1_1struc_1_1shm_1_1Builder.html#a9374ce7f0dc46bb841d9359df5d4045f">More...</a><br /></td></tr>
<tr class="separator:a9374ce7f0dc46bb841d9359df5d4045f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a23b111e2bf7be45589eb958d6ccc24f6"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classipc_1_1transport_1_1struc_1_1shm_1_1Builder.html#a23b111e2bf7be45589eb958d6ccc24f6">Builder</a> (const <a class="el" href="structipc_1_1transport_1_1struc_1_1shm_1_1Builder_1_1Config.html">Config</a> &amp;config)</td></tr>
<tr class="memdesc:a23b111e2bf7be45589eb958d6ccc24f6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Implements concept API.  <a href="classipc_1_1transport_1_1struc_1_1shm_1_1Builder.html#a23b111e2bf7be45589eb958d6ccc24f6">More...</a><br /></td></tr>
<tr class="separator:a23b111e2bf7be45589eb958d6ccc24f6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a785a61db43b5f6ee486863eb0f0a56c4"><td class="memItemLeft" align="right" valign="top"><a id="a785a61db43b5f6ee486863eb0f0a56c4" name="a785a61db43b5f6ee486863eb0f0a56c4"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>Builder</b> (const <a class="el" href="classipc_1_1transport_1_1struc_1_1shm_1_1Builder.html">Builder</a> &amp;)=delete</td></tr>
<tr class="memdesc:a785a61db43b5f6ee486863eb0f0a56c4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Disallow copy construction. <br /></td></tr>
<tr class="separator:a785a61db43b5f6ee486863eb0f0a56c4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac5d54e207503b67b6d2d75c5eb44e76d"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classipc_1_1transport_1_1struc_1_1shm_1_1Builder.html#ac5d54e207503b67b6d2d75c5eb44e76d">Builder</a> (<a class="el" href="classipc_1_1transport_1_1struc_1_1shm_1_1Builder.html">Builder</a> &amp;&amp;src)</td></tr>
<tr class="memdesc:ac5d54e207503b67b6d2d75c5eb44e76d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Implements concept API.  <a href="classipc_1_1transport_1_1struc_1_1shm_1_1Builder.html#ac5d54e207503b67b6d2d75c5eb44e76d">More...</a><br /></td></tr>
<tr class="separator:ac5d54e207503b67b6d2d75c5eb44e76d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af2d88517cf0d99186a6062279d6eb0d3"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classipc_1_1transport_1_1struc_1_1shm_1_1Builder.html#af2d88517cf0d99186a6062279d6eb0d3">~Builder</a> ()</td></tr>
<tr class="memdesc:af2d88517cf0d99186a6062279d6eb0d3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Implements concept API.  <a href="classipc_1_1transport_1_1struc_1_1shm_1_1Builder.html#af2d88517cf0d99186a6062279d6eb0d3">More...</a><br /></td></tr>
<tr class="separator:af2d88517cf0d99186a6062279d6eb0d3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2156d8a6653b0f4a43bb8eaf4806536a"><td class="memItemLeft" align="right" valign="top"><a id="a2156d8a6653b0f4a43bb8eaf4806536a" name="a2156d8a6653b0f4a43bb8eaf4806536a"></a>
<a class="el" href="classipc_1_1transport_1_1struc_1_1shm_1_1Builder.html">Builder</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>operator=</b> (const <a class="el" href="classipc_1_1transport_1_1struc_1_1shm_1_1Builder.html">Builder</a> &amp;)=delete</td></tr>
<tr class="memdesc:a2156d8a6653b0f4a43bb8eaf4806536a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Disallow copy assignment. <br /></td></tr>
<tr class="separator:a2156d8a6653b0f4a43bb8eaf4806536a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1f6e7a9e4b810d1737fdb24240e227c1"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classipc_1_1transport_1_1struc_1_1shm_1_1Builder.html">Builder</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classipc_1_1transport_1_1struc_1_1shm_1_1Builder.html#a1f6e7a9e4b810d1737fdb24240e227c1">operator=</a> (<a class="el" href="classipc_1_1transport_1_1struc_1_1shm_1_1Builder.html">Builder</a> &amp;&amp;src)</td></tr>
<tr class="memdesc:a1f6e7a9e4b810d1737fdb24240e227c1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Implements concept API.  <a href="classipc_1_1transport_1_1struc_1_1shm_1_1Builder.html#a1f6e7a9e4b810d1737fdb24240e227c1">More...</a><br /></td></tr>
<tr class="separator:a1f6e7a9e4b810d1737fdb24240e227c1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaeceaccf183170b1785aa240921ae893"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespaceipc_1_1transport_1_1struc.html#a52405569bf63eaef55f3c2435c885abc">Capnp_msg_builder_interface</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classipc_1_1transport_1_1struc_1_1shm_1_1Builder.html#aaeceaccf183170b1785aa240921ae893">payload_msg_builder</a> ()</td></tr>
<tr class="memdesc:aaeceaccf183170b1785aa240921ae893"><td class="mdescLeft">&#160;</td><td class="mdescRight">Implements concept API.  <a href="classipc_1_1transport_1_1struc_1_1shm_1_1Builder.html#aaeceaccf183170b1785aa240921ae893">More...</a><br /></td></tr>
<tr class="separator:aaeceaccf183170b1785aa240921ae893"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7909a2d1e1d24037fb8af5338fffa783"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classipc_1_1transport_1_1struc_1_1shm_1_1Builder.html#a7909a2d1e1d24037fb8af5338fffa783">emit_serialization</a> (<a class="el" href="namespaceipc_1_1transport_1_1struc.html#a82a69eaa39cbe8a002de1266f1cbb5cb">Segment_ptrs</a> *target_blobs, const <a class="el" href="classipc_1_1transport_1_1struc_1_1shm_1_1Builder.html#a2d9808d9b0c04cf84c8e439b1643506d">Session</a> &amp;session, <a class="el" href="namespaceipc.html#aa3192e586cc45d3e7c22463bf2760f89">Error_code</a> *err_code=0) const</td></tr>
<tr class="memdesc:a7909a2d1e1d24037fb8af5338fffa783"><td class="mdescLeft">&#160;</td><td class="mdescRight">Implements concept API.  <a href="classipc_1_1transport_1_1struc_1_1shm_1_1Builder.html#a7909a2d1e1d24037fb8af5338fffa783">More...</a><br /></td></tr>
<tr class="separator:a7909a2d1e1d24037fb8af5338fffa783"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8f01bec0e66080850379df98a2ecf99e"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classipc_1_1transport_1_1struc_1_1shm_1_1Builder.html#a8f01bec0e66080850379df98a2ecf99e">n_serialization_segments</a> () const</td></tr>
<tr class="memdesc:a8f01bec0e66080850379df98a2ecf99e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Implements concept API.  <a href="classipc_1_1transport_1_1struc_1_1shm_1_1Builder.html#a8f01bec0e66080850379df98a2ecf99e">More...</a><br /></td></tr>
<tr class="separator:a8f01bec0e66080850379df98a2ecf99e"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pri-types" name="pri-types"></a>
Private Types</h2></td></tr>
<tr class="memitem:a1609cbc67e5799de53b6ed6671462b74"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classipc_1_1transport_1_1struc_1_1shm_1_1Builder.html#a1609cbc67e5799de53b6ed6671462b74">Capnp_heap_engine</a> = <a class="el" href="classipc_1_1transport_1_1struc_1_1shm_1_1Capnp__message__builder.html">Capnp_message_builder</a>&lt; <a class="el" href="classipc_1_1transport_1_1struc_1_1shm_1_1Builder.html#a9bc898884381eebdb03f0dd9f74895de">Arena</a> &gt;</td></tr>
<tr class="memdesc:a1609cbc67e5799de53b6ed6671462b74"><td class="mdescLeft">&#160;</td><td class="mdescRight">The work-horse capnp-aware engine in charge of allocating segments in SHM on capnp's request, while user mutates via <a class="el" href="classipc_1_1transport_1_1struc_1_1shm_1_1Builder.html#aaeceaccf183170b1785aa240921ae893" title="Implements concept API.">payload_msg_builder()</a>.  <a href="classipc_1_1transport_1_1struc_1_1shm_1_1Builder.html#a1609cbc67e5799de53b6ed6671462b74">More...</a><br /></td></tr>
<tr class="separator:a1609cbc67e5799de53b6ed6671462b74"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pri-attribs" name="pri-attribs"></a>
Private Attributes</h2></td></tr>
<tr class="memitem:a3283aa7dc43b3851b94ff65f1f01d5e1"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classipc_1_1transport_1_1struc_1_1Heap__fixed__builder.html">Heap_fixed_builder</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classipc_1_1transport_1_1struc_1_1shm_1_1Builder.html#a3283aa7dc43b3851b94ff65f1f01d5e1">m_top_engine</a></td></tr>
<tr class="memdesc:a3283aa7dc43b3851b94ff65f1f01d5e1"><td class="mdescLeft">&#160;</td><td class="mdescRight">The top-serialization builder, namely <a class="el" href="classipc_1_1transport_1_1struc_1_1Heap__fixed__builder.html" title="Implements Struct_builder concept by straightforwardly allocating fixed-size segments on-demand in th...">Heap_fixed_builder</a>, of our simple SHM-handle-bearing schema.  <a href="classipc_1_1transport_1_1struc_1_1shm_1_1Builder.html#a3283aa7dc43b3851b94ff65f1f01d5e1">More...</a><br /></td></tr>
<tr class="separator:a3283aa7dc43b3851b94ff65f1f01d5e1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a828d2e04ba4f62e30ae14518dd33dd63"><td class="memItemLeft" align="right" valign="top">boost::movelib::unique_ptr&lt; <a class="el" href="classipc_1_1transport_1_1struc_1_1shm_1_1Builder.html#a1609cbc67e5799de53b6ed6671462b74">Capnp_heap_engine</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classipc_1_1transport_1_1struc_1_1shm_1_1Builder.html#a828d2e04ba4f62e30ae14518dd33dd63">m_btm_engine</a></td></tr>
<tr class="memdesc:a828d2e04ba4f62e30ae14518dd33dd63"><td class="mdescLeft">&#160;</td><td class="mdescRight">See <a class="el" href="classipc_1_1transport_1_1struc_1_1shm_1_1Builder.html#a1609cbc67e5799de53b6ed6671462b74" title="The work-horse capnp-aware engine in charge of allocating segments in SHM on capnp&#39;s request,...">Capnp_heap_engine</a>.  <a href="classipc_1_1transport_1_1struc_1_1shm_1_1Builder.html#a828d2e04ba4f62e30ae14518dd33dd63">More...</a><br /></td></tr>
<tr class="separator:a828d2e04ba4f62e30ae14518dd33dd63"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="related" name="related"></a>
Related Functions</h2></td></tr>
<tr><td class="ititle" colspan="2"><p >(Note that these are not member functions.) </p>
</td></tr>
<tr class="memitem:a705eab4975089bdd7c6d961b079a2252"><td class="memTemplParams" colspan="2">template&lt;typename Shm_arena &gt; </td></tr>
<tr class="memitem:a705eab4975089bdd7c6d961b079a2252"><td class="memTemplItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classipc_1_1transport_1_1struc_1_1shm_1_1Builder.html#a705eab4975089bdd7c6d961b079a2252">operator&lt;&lt;</a> (std::ostream &amp;os, const <a class="el" href="classipc_1_1transport_1_1struc_1_1shm_1_1Builder.html">Builder</a>&lt; Shm_arena &gt; &amp;val)</td></tr>
<tr class="memdesc:a705eab4975089bdd7c6d961b079a2252"><td class="mdescLeft">&#160;</td><td class="mdescRight">Prints string representation of the given <code><a class="el" href="classipc_1_1transport_1_1struc_1_1shm_1_1Builder.html" title="Implements Struct_builder concept with maximal zero-copy perf by (1) storing the actual user-schema-c...">Builder</a></code> to the given <code>ostream</code>.  <a href="classipc_1_1transport_1_1struc_1_1shm_1_1Builder.html#a705eab4975089bdd7c6d961b079a2252">More...</a><br /></td></tr>
<tr class="separator:a705eab4975089bdd7c6d961b079a2252"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="inherited" name="inherited"></a>
Additional Inherited Members</h2></td></tr>
<tr class="inherit_header pub_static_attribs_classipc_1_1transport_1_1struc_1_1shm_1_1Builder__base"><td colspan="2" onclick="javascript:toggleInherit('pub_static_attribs_classipc_1_1transport_1_1struc_1_1shm_1_1Builder__base')"><img src="closed.png" alt="-"/>&#160;Static Public Attributes inherited from <a class="el" href="classipc_1_1transport_1_1struc_1_1shm_1_1Builder__base.html">ipc::transport::struc::shm::Builder_base</a></td></tr>
<tr class="memitem:a2dae5df49d355c6f2199af42fff9befd inherit pub_static_attribs_classipc_1_1transport_1_1struc_1_1shm_1_1Builder__base"><td class="memItemLeft" align="right" valign="top">static constexpr size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classipc_1_1transport_1_1struc_1_1shm_1_1Builder__base.html#a2dae5df49d355c6f2199af42fff9befd">S_MAX_SERIALIZATION_SEGMENT_SZ</a> = 512</td></tr>
<tr class="memdesc:a2dae5df49d355c6f2199af42fff9befd inherit pub_static_attribs_classipc_1_1transport_1_1struc_1_1shm_1_1Builder__base"><td class="mdescLeft">&#160;</td><td class="mdescRight">A message of this size will be able to completely contain the (single) segment emitted by <a class="el" href="classipc_1_1transport_1_1struc_1_1shm_1_1Builder.html#a7909a2d1e1d24037fb8af5338fffa783" title="Implements concept API.">Builder::emit_serialization()</a> no matter how large or complex the user data loaded into <a class="el" href="classipc_1_1transport_1_1struc_1_1shm_1_1Builder.html#aaeceaccf183170b1785aa240921ae893" title="Implements concept API.">Builder::payload_msg_builder()</a>.  <a href="classipc_1_1transport_1_1struc_1_1shm_1_1Builder__base.html#a2dae5df49d355c6f2199af42fff9befd">More...</a><br /></td></tr>
<tr class="separator:a2dae5df49d355c6f2199af42fff9befd inherit pub_static_attribs_classipc_1_1transport_1_1struc_1_1shm_1_1Builder__base"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><div class="compoundTemplParams">template&lt;typename Shm_arena&gt;<br />
class ipc::transport::struc::shm::Builder&lt; Shm_arena &gt;</div><p >Implements <a class="el" href="classipc_1_1transport_1_1struc_1_1Struct__builder.html" title="A documentation-only concept defining the behavior of an object capable of zero-copy-serializing,...">Struct_builder</a> concept with maximal zero-copy perf by (1) storing the actual user-schema-controlled message using the SHM provider of choice, in SHM, and (2) straightforwardly allocating 1 segment in regular heap and placing the SHM handle there for transmission over IPC. </p>
<p >That is, each mutation via <a class="el" href="classipc_1_1transport_1_1struc_1_1shm_1_1Builder.html#aaeceaccf183170b1785aa240921ae893" title="Implements concept API.">payload_msg_builder()</a> may, as needed, trigger a SHM allocation. In this algorithm, unlike <a class="el" href="classipc_1_1transport_1_1struc_1_1Heap__fixed__builder.html" title="Implements Struct_builder concept by straightforwardly allocating fixed-size segments on-demand in th...">Heap_fixed_builder</a>, the size of each (SHM-)allocated segment will be determined intelligently based on an exponential-growth algorithm, similarly to that mode of capnp's <code>MallocMessageBuilder</code>. Hence there is no knob to control segment size, as it is determined dynamically, internally.</p>
<h3>Failure mode; reasonable uses</h3>
<p >First see "Failure mode" and "Reasonable uses" in <a class="el" href="classipc_1_1transport_1_1struc_1_1Heap__fixed__builder.html" title="Implements Struct_builder concept by straightforwardly allocating fixed-size segments on-demand in th...">Heap_fixed_builder</a> doc header; then come back here. Back already? Good news: that failure mode (leaf-too-big) does <em>not</em> apply here. As long as the SHM provider is able to dole out RAM, there is no limit at all on the size/complexity of what one mutates over <a class="el" href="classipc_1_1transport_1_1struc_1_1shm_1_1Builder.html#aaeceaccf183170b1785aa240921ae893" title="Implements concept API.">payload_msg_builder()</a>. In fact <code>*this</code> provides the "2-layer approach" specified in that doc header section you just came back from reading.</p>
<p >The only realistic failure mode in <code>*this</code> is the following:</p><ol type="1">
<li>User attempts to mutate via <a class="el" href="classipc_1_1transport_1_1struc_1_1shm_1_1Builder.html#aaeceaccf183170b1785aa240921ae893" title="Implements concept API.">payload_msg_builder()</a>.</li>
<li>capnp internals recognize the current segment is used up and asks for a new segment of at least N bytes.</li>
<li><code>*this</code> asks the SHM provider (see template param docs below) to allocate &gt;=N bytes.</li>
<li>The SHM provider determines it has run out of space according to its policies/algorithm/limitations and throws exception, in spirit similar to <code>std::bad_alloc</code>.</li>
<li>This propagates to the user via their <a class="el" href="classipc_1_1transport_1_1struc_1_1shm_1_1Builder.html#aaeceaccf183170b1785aa240921ae893" title="Implements concept API.">payload_msg_builder()</a> mutation statement: it throws.</li>
</ol>
<p >The key here: This cannot be detected via <code>*this</code>. In spirit it is similar to <code><a class="el" href="classipc_1_1transport_1_1struc_1_1Heap__fixed__builder.html" title="Implements Struct_builder concept by straightforwardly allocating fixed-size segments on-demand in th...">Heap_fixed_builder</a></code>-originated mutations by the user running out of regular-heap (even virtual disk heap, if enabled) and is outside our scope to control. The only remedy: choose a SHM provider that does not run out of space beyond simply running out of RAM; e.g., by mapping more SHM pools, or whatever. Otherwise, all the user can do is catch the <code>bad_alloc</code>-like exception around their mutations on <a class="el" href="classipc_1_1transport_1_1struc_1_1shm_1_1Builder.html#aaeceaccf183170b1785aa240921ae893" title="Implements concept API.">payload_msg_builder()</a> and take whatever contingency steps.</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classipc_1_1transport_1_1struc_1_1shm_1_1Reader.html" title="Implements Struct_reader concept by interpreting a serialization by shm::Builder with the same templa...">shm::Reader</a> Counterpart <a class="el" href="classipc_1_1transport_1_1struc_1_1Struct__reader.html" title="A documentation-only concept that is, conceptually, roughly what capnp::MessageReader is to capnp::Me...">Struct_reader</a> implementation that can deserialize data that this has serialized. </dd>
<dd>
<a class="el" href="classipc_1_1transport_1_1struc_1_1Struct__builder.html" title="A documentation-only concept defining the behavior of an object capable of zero-copy-serializing,...">Struct_builder</a>: implemented concept.</dd></dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Shm_arena</td><td>SHM provider type with the ability to allocate STL-compliant data structures directly in SHM, returning a <code>shared_ptr</code> outer-SHM-handle that is possible to <code>lend_object()</code>/<code>borrow_object()</code> via <a class="el" href="classipc_1_1transport_1_1struc_1_1shm_1_1Builder.html#a2d9808d9b0c04cf84c8e439b1643506d" title="Implements concept API.">shm::Builder::Session</a>. <code>Shm_arena::Handle&lt;T&gt;</code> must equal <code>shared_ptr&lt;T&gt;</code> (meaning type with standard <code>shared_ptr&lt;T&gt;</code> semantics; in practice probably either <code>std::shared_ptr&lt;T&gt;</code> or <code>boost::shared_ptr&lt;T&gt;</code>). It must provide a <code>construct&lt;T&gt;()</code> method as exemplified by <a class="el" href="classipc_1_1shm_1_1classic_1_1Pool__arena.html#ab9f7ea056a55183d00dcbce573afcf36" title="Constructs an object of given type with given ctor args, having allocated space directly in attached ...">shm::classic::Pool_arena::construct()</a>. (This is an <em>example</em>; you do not have to use <code>Pool_arena</code> and indeed should choose a SHM provider suitable to your needs, especially as regards to being able to allocate sufficiently large segments.) That is: <code>Handle&lt;T&gt; construct&lt;T&gt;(...ctor_args...)</code>, such that if it returned <code>p</code> then <code><a class="el" href="namespaceipc_1_1session_1_1shm.html#af2acc444cc9664e57df8143b66b78d70" title="Alias that, given an Arena type (with Arena::construct&lt;T&gt;() which allocates/constructs a T),...">session::shm::Arena_to_shm_session_t</a>&lt;Shm_arena&gt;</code> pointee has method <code>flow::util::Blob_sans_log_context lend_object&lt;T&gt;(const Handle&lt;T&gt;&amp; p)</code>. Next, if the returned blob <code>b</code> is bit-wise copied into an IPC transport and copied out of it and then given to counterpart <a class="el" href="classipc_1_1transport_1_1struc_1_1shm_1_1Reader.html" title="Implements Struct_reader concept by interpreting a serialization by shm::Builder with the same templa...">shm::Reader</a>, then <code><a class="el" href="classipc_1_1transport_1_1struc_1_1shm_1_1Reader.html#ae77502abf0b04ad7543266fc6c34f49d" title="See shm::Builder::Session.">shm::Reader::Session</a></code> pointee has method <code>borrow_object&lt;T&gt;(b)</code> that shall return (in the receiving process) <code>Handle&lt;T&gt;</code> that points to the same SHM-stored data structure originally returned by <code>construct()</code>. In addition <code>Shm_arena</code> must be compatible with <code>Stateless_allocator</code> requirements as explained in "Additional formal requirements" below.</td></tr>
  </table>
  </dd>
</dl>
<h3>Additional formal requirements w/r/t <code>Shm_arena</code></h3>
<p >Information on <code>T</code> that <code>*this</code> shall use with <code>Shm_arena::construct&lt;T&gt;()</code>: As of this writing it is <code>list&lt;Basic_blob&gt;</code>, representing (internally) the capnp-requested 1+ segments in which the serialization mutated via <a class="el" href="classipc_1_1transport_1_1struc_1_1shm_1_1Builder.html#aaeceaccf183170b1785aa240921ae893" title="Implements concept API.">payload_msg_builder()</a> is stored in zero-copy fashion. In order for this to work, the <code><a class="el" href="classAllocator.html">Allocator</a></code> template arg on both <code>list</code> and the inner <code>Blob</code>s shall be <a class="el" href="classipc_1_1shm_1_1stl_1_1Stateless__allocator.html" title="Stateless allocator usable with STL-compliant containers to store (or merely read) them directly in S...">ipc::shm::stl::Stateless_allocator</a>. Therefore, the requirement is: <code>Shm_arena</code> must formally meet the requirements for <code>Arena</code> from <a class="el" href="classipc_1_1shm_1_1stl_1_1Stateless__allocator.html" title="Stateless allocator usable with STL-compliant containers to store (or merely read) them directly in S...">ipc::shm::stl::Stateless_allocator</a> doc header. Briefly these are: <code>allocate(n) -&gt; void*</code>, <code>deallocate(void*)</code>, <code>Pointer</code> fancy-pointer type that is SHM-storable.</p>
<p >A simple (likely the simplest) example is <a class="el" href="classipc_1_1shm_1_1classic_1_1Pool__arena.html" title="A SHM-classic interface around a single SHM pool with allocation-algorithm services by boost....">ipc::shm::classic::Pool_arena</a>, which satisfies both <code>Shm_arena</code> and <code><a class="el" href="namespaceipc_1_1session_1_1shm.html#af2acc444cc9664e57df8143b66b78d70" title="Alias that, given an Arena type (with Arena::construct&lt;T&gt;() which allocates/constructs a T),...">session::shm::Arena_to_shm_session_t</a>&lt;Shm_arena&gt;</code>-pointee requirements. However, it has deficiencies w/r/t max pool size having to be specified and a non-industry-strength allocation algorithm. The Jemalloc-based SHM provider in ipc::shm::arena_lend::jemalloc is more complex &ndash; with a separate <code>Arena_to_shm_session_t&lt;Shm_arena&gt;</code> pointee from <code>Shm_arena</code> &ndash; but lacks these problems. </p>

<p class="definition">Definition at line <a class="el" href="ipc__shm_2src_2ipc_2transport_2struc_2shm_2serializer_8hpp_source.html#l00117">117</a> of file <a class="el" href="ipc__shm_2src_2ipc_2transport_2struc_2shm_2serializer_8hpp_source.html">serializer.hpp</a>.</p>
</div><h2 class="groupheader">Member Typedef Documentation</h2>
<a id="a9bc898884381eebdb03f0dd9f74895de" name="a9bc898884381eebdb03f0dd9f74895de"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9bc898884381eebdb03f0dd9f74895de">&#9670;&nbsp;</a></span>Arena</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Shm_arena &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classipc_1_1transport_1_1struc_1_1shm_1_1Builder.html">ipc::transport::struc::shm::Builder</a>&lt; Shm_arena &gt;::Arena =  Shm_arena</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Short-hand for <code>Shm_arena</code> template param. </p>

<p class="definition">Definition at line <a class="el" href="ipc__shm_2src_2ipc_2transport_2struc_2shm_2serializer_8hpp_source.html#l00125">125</a> of file <a class="el" href="ipc__shm_2src_2ipc_2transport_2struc_2shm_2serializer_8hpp_source.html">serializer.hpp</a>.</p>

</div>
</div>
<a id="a1609cbc67e5799de53b6ed6671462b74" name="a1609cbc67e5799de53b6ed6671462b74"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1609cbc67e5799de53b6ed6671462b74">&#9670;&nbsp;</a></span>Capnp_heap_engine</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Shm_arena &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classipc_1_1transport_1_1struc_1_1shm_1_1Builder.html">ipc::transport::struc::shm::Builder</a>&lt; Shm_arena &gt;::Capnp_heap_engine =  <a class="el" href="classipc_1_1transport_1_1struc_1_1shm_1_1Capnp__message__builder.html">Capnp_message_builder</a>&lt;<a class="el" href="classipc_1_1transport_1_1struc_1_1shm_1_1Builder.html#a9bc898884381eebdb03f0dd9f74895de">Arena</a>&gt;</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>The work-horse capnp-aware engine in charge of allocating segments in SHM on capnp's request, while user mutates via <a class="el" href="classipc_1_1transport_1_1struc_1_1shm_1_1Builder.html#aaeceaccf183170b1785aa240921ae893" title="Implements concept API.">payload_msg_builder()</a>. </p>
<p >This is the bottom-serialization builder.</p>
<p >As explained at the top of the class doc header, this one uses a segment-sizing strategy similar that of <code>capnp::MallocMessageBuilder</code> operating in <code>GROW_HEURISTICALLY</code> mode. I.e., it'll start with a reasonable guess for segment 1 size; then grow exponentially each time a new segment is requested. More or less, each new segment's size equals that of the preceding segments' sizes added up. </p>

<p class="definition">Definition at line <a class="el" href="ipc__shm_2src_2ipc_2transport_2struc_2shm_2serializer_8hpp_source.html#l00298">298</a> of file <a class="el" href="ipc__shm_2src_2ipc_2transport_2struc_2shm_2serializer_8hpp_source.html">serializer.hpp</a>.</p>

</div>
</div>
<a id="a2d9808d9b0c04cf84c8e439b1643506d" name="a2d9808d9b0c04cf84c8e439b1643506d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2d9808d9b0c04cf84c8e439b1643506d">&#9670;&nbsp;</a></span>Session</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Shm_arena &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classipc_1_1transport_1_1struc_1_1shm_1_1Builder.html">ipc::transport::struc::shm::Builder</a>&lt; Shm_arena &gt;::Session =  <a class="el" href="namespaceipc_1_1session_1_1shm.html#af2acc444cc9664e57df8143b66b78d70">session::shm::Arena_to_shm_session_t</a>&lt;<a class="el" href="classipc_1_1transport_1_1struc_1_1shm_1_1Builder.html#a9bc898884381eebdb03f0dd9f74895de">Arena</a>&gt;*</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Implements concept API. </p>
<p >This being a zero-copy (SHM-based) <a class="el" href="classipc_1_1transport_1_1struc_1_1Struct__builder.html" title="A documentation-only concept defining the behavior of an object capable of zero-copy-serializing,...">Struct_builder</a>, information is needed for <a class="el" href="classipc_1_1transport_1_1struc_1_1shm_1_1Builder.html#a7909a2d1e1d24037fb8af5338fffa783" title="Implements concept API.">emit_serialization()</a> beyond the payload itself: pointer to a <code>Shm_session</code> object. </p>

<p class="definition">Definition at line <a class="el" href="ipc__shm_2src_2ipc_2transport_2struc_2shm_2serializer_8hpp_source.html#l00174">174</a> of file <a class="el" href="ipc__shm_2src_2ipc_2transport_2struc_2shm_2serializer_8hpp_source.html">serializer.hpp</a>.</p>

</div>
</div>
<h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="a9374ce7f0dc46bb841d9359df5d4045f" name="a9374ce7f0dc46bb841d9359df5d4045f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9374ce7f0dc46bb841d9359df5d4045f">&#9670;&nbsp;</a></span>Builder() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Shm_arena &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classipc_1_1transport_1_1struc_1_1shm_1_1Builder.html">ipc::transport::struc::shm::Builder</a>&lt; Shm_arena &gt;<a class="el" href="classStruct__builder__config_1_1Builder.html">::Builder</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">default</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Implements concept API. </p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classipc_1_1transport_1_1struc_1_1Struct__builder.html#a460aa187c0aaa5adfb81ecc902c7eca9" title="Default ctor, leaving *this in a state only suitable for destruction or being moved-to.">Struct_builder::Struct_builder()</a>: implemented concept. </dd></dl>

</div>
</div>
<a id="a23b111e2bf7be45589eb958d6ccc24f6" name="a23b111e2bf7be45589eb958d6ccc24f6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a23b111e2bf7be45589eb958d6ccc24f6">&#9670;&nbsp;</a></span>Builder() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Shm_arena &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classipc_1_1transport_1_1struc_1_1shm_1_1Builder.html">ipc::transport::struc::shm::Builder</a>&lt; Shm_arena &gt;<a class="el" href="classStruct__builder__config_1_1Builder.html">::Builder</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structipc_1_1transport_1_1struc_1_1shm_1_1Builder_1_1Config.html">Config</a> &amp;&#160;</td>
          <td class="paramname"><em>config</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">explicit</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Implements concept API. </p>
<p >See <a class="el" href="structipc_1_1transport_1_1struc_1_1shm_1_1Builder_1_1Config.html" title="Implements Struct_builder::Config sub-concept.">Config</a> doc header for information on how <code>*this</code> behavior is controlled by <code>config</code>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">config</td><td>See above.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classipc_1_1transport_1_1struc_1_1Struct__builder.html#a460aa187c0aaa5adfb81ecc902c7eca9" title="Default ctor, leaving *this in a state only suitable for destruction or being moved-to.">Struct_builder::Struct_builder()</a>: implemented concept. </dd></dl>

<p class="definition">Definition at line <a class="el" href="ipc__shm_2src_2ipc_2transport_2struc_2shm_2serializer_8hpp_source.html#l00515">515</a> of file <a class="el" href="ipc__shm_2src_2ipc_2transport_2struc_2shm_2serializer_8hpp_source.html">serializer.hpp</a>.</p>

<p class="reference">References <a class="el" href="ipc__shm_2src_2ipc_2transport_2struc_2shm_2serializer_8hpp_source.html#l00164">ipc::transport::struc::shm::Builder&lt; Shm_arena &gt;::Config::m_top_builder_frame_postfix_sz</a>, <a class="el" href="ipc__shm_2src_2ipc_2transport_2struc_2shm_2serializer_8hpp_source.html#l00161">ipc::transport::struc::shm::Builder&lt; Shm_arena &gt;::Config::m_top_builder_frame_prefix_sz</a>, and <a class="el" href="ipc__shm_2src_2ipc_2transport_2struc_2shm_2serializer_8hpp_source.html#l00046">ipc::transport::struc::shm::Builder_base::S_MAX_SERIALIZATION_SEGMENT_SZ</a>.</p>

</div>
</div>
<a id="ac5d54e207503b67b6d2d75c5eb44e76d" name="ac5d54e207503b67b6d2d75c5eb44e76d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac5d54e207503b67b6d2d75c5eb44e76d">&#9670;&nbsp;</a></span>Builder() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Shm_arena &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classipc_1_1transport_1_1struc_1_1shm_1_1Builder.html">ipc::transport::struc::shm::Builder</a>&lt; Shm_arena &gt;<a class="el" href="classStruct__builder__config_1_1Builder.html">::Builder</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classipc_1_1transport_1_1struc_1_1shm_1_1Builder.html">Builder</a>&lt; Shm_arena &gt; &amp;&amp;&#160;</td>
          <td class="paramname"><em>src</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">default</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Implements concept API. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">src</td><td>See above.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classipc_1_1transport_1_1struc_1_1Struct__builder.html#a460aa187c0aaa5adfb81ecc902c7eca9" title="Default ctor, leaving *this in a state only suitable for destruction or being moved-to.">Struct_builder::Struct_builder()</a>: implemented concept. </dd></dl>

</div>
</div>
<a id="af2d88517cf0d99186a6062279d6eb0d3" name="af2d88517cf0d99186a6062279d6eb0d3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af2d88517cf0d99186a6062279d6eb0d3">&#9670;&nbsp;</a></span>~Builder()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Shm_arena &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classipc_1_1transport_1_1struc_1_1shm_1_1Builder.html">ipc::transport::struc::shm::Builder</a>&lt; Shm_arena &gt;::~<a class="el" href="classipc_1_1transport_1_1struc_1_1shm_1_1Builder.html">Builder</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Implements concept API. </p>
<p >In this impl:</p><ul>
<li>frees the top-serialization 1 segment containing the SHM handle;</li>
<li>unregisters this process as an owner of the bottom-serialization (the bulky serialization of 1+ segments in SHM). These bulky SHM-stored segments, therefore, will either be deallocated right now (either because <a class="el" href="classipc_1_1transport_1_1struc_1_1shm_1_1Builder.html#a7909a2d1e1d24037fb8af5338fffa783" title="Implements concept API.">emit_serialization()</a> was not called; or it was, and the counterpart <a class="el" href="classipc_1_1transport_1_1struc_1_1shm_1_1Reader.html#aceb5816f4e9f312a8ce2ef17feb81223" title="Implements concept API.">Reader::deserialization()</a> <em>and dtor</em> ran before us) or not (if <a class="el" href="classipc_1_1transport_1_1struc_1_1shm_1_1Builder.html#a7909a2d1e1d24037fb8af5338fffa783" title="Implements concept API.">emit_serialization()</a> was called, but either the counterpart <a class="el" href="classipc_1_1transport_1_1struc_1_1shm_1_1Reader.html#aceb5816f4e9f312a8ce2ef17feb81223" title="Implements concept API.">shm::Reader::deserialization()</a> or dtor has not yet executed). In other words it's a ref-count (of owner processes) with a max value of 2; and this dtor decrements it by 1.</li>
</ul>
<p >If <a class="el" href="classipc_1_1transport_1_1struc_1_1shm_1_1Builder.html#a7909a2d1e1d24037fb8af5338fffa783" title="Implements concept API.">emit_serialization()</a> is used more than once (and hence deserialized more than once), then the ref-count can grow further beyond 2.</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classipc_1_1transport_1_1struc_1_1Struct__builder.html#a008f6b6456a4b2dab63cdda5f9e4cfe5" title="Destructor. Do not use *payload_msg_builder() or any copies thereof past this.">Struct_builder::~Struct_builder()</a>: implemented concept. </dd></dl>

<p class="definition">Definition at line <a class="el" href="ipc__shm_2src_2ipc_2transport_2struc_2shm_2serializer_8hpp_source.html#l00536">536</a> of file <a class="el" href="ipc__shm_2src_2ipc_2transport_2struc_2shm_2serializer_8hpp_source.html">serializer.hpp</a>.</p>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="a7909a2d1e1d24037fb8af5338fffa783" name="a7909a2d1e1d24037fb8af5338fffa783"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7909a2d1e1d24037fb8af5338fffa783">&#9670;&nbsp;</a></span>emit_serialization()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Shm_arena &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classipc_1_1transport_1_1struc_1_1shm_1_1Builder.html">ipc::transport::struc::shm::Builder</a>&lt; Shm_arena &gt;::emit_serialization </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespaceipc_1_1transport_1_1struc.html#a82a69eaa39cbe8a002de1266f1cbb5cb">Segment_ptrs</a> *&#160;</td>
          <td class="paramname"><em>target_blobs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classipc_1_1transport_1_1struc_1_1shm_1_1Builder.html#a2d9808d9b0c04cf84c8e439b1643506d">Session</a> &amp;&#160;</td>
          <td class="paramname"><em>session</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceipc.html#aa3192e586cc45d3e7c22463bf2760f89">Error_code</a> *&#160;</td>
          <td class="paramname"><em>err_code</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Implements concept API. </p>
<h3>Errors</h3>
<p >As implied in class doc header, the top serialization is just a small SHM-handle, so <a class="el" href="namespaceipc_1_1transport_1_1struc_1_1error.html#a990b9ff850cf9aaf354efdd07d86a71da3deddc950bfa6d35ae03c9494eec15a6" title="Structured message serialization (e.g., when sending over channel): A user-mutated datum (e....">error::Code::S_INTERNAL_ERROR_SERIALIZE_LEAF_TOO_BIG</a> is not realistically possible.</p>
<p >As of this writing no other failure modes exist. However see "Failure mode" notes in <a class="el" href="classipc_1_1transport_1_1struc_1_1shm_1_1Builder.html#aaeceaccf183170b1785aa240921ae893" title="Implements concept API.">payload_msg_builder()</a> doc header. These would manifest before one would have a chance to <a class="el" href="classipc_1_1transport_1_1struc_1_1shm_1_1Builder.html#a7909a2d1e1d24037fb8af5338fffa783" title="Implements concept API.">emit_serialization()</a> though.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">target_blobs</td><td>See above. Also recall (see ctor) that for each returned <code>blob</code> (realistically just one): individual segment sizes shall never exceed Config::m_segment_sz (for the [<code>begin()</code>, <code>end()</code>) area), with <code>start() == Config::m_frame_prefix_sz</code>, and with <code>capacity() - start() - size() &gt;= Config::m_frame_postfix_sz</code>. Config::m_segment_sz is ceiling-nearest-word-adjusted. </td></tr>
    <tr><td class="paramname">session</td><td>See above. In this case... just... see <a class="el" href="classipc_1_1transport_1_1struc_1_1shm_1_1Builder.html#a2d9808d9b0c04cf84c8e439b1643506d" title="Implements concept API.">Session</a>. </td></tr>
    <tr><td class="paramname">err_code</td><td>See above. Long story short: in practice never fails.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classipc_1_1transport_1_1struc_1_1Struct__builder.html#a89874da2fb8c9f112a1152b0b38d2281" title="Returns the serialization in the form of a sequence of 1+ pointers to Blobs which are guaranteed to r...">Struct_builder::emit_serialization()</a>: implemented concept. </dd></dl>

<p class="definition">Definition at line <a class="el" href="ipc__shm_2src_2ipc_2transport_2struc_2shm_2serializer_8hpp_source.html#l00554">554</a> of file <a class="el" href="ipc__shm_2src_2ipc_2transport_2struc_2shm_2serializer_8hpp_source.html">serializer.hpp</a>.</p>

<p class="reference">References <a class="el" href="heap__serializer_8cpp_source.html#l00072">ipc::transport::struc::Heap_fixed_builder::emit_serialization()</a>, and <a class="el" href="heap__serializer_8cpp_source.html#l00035">ipc::transport::struc::NULL_SESSION</a>.</p>
<div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="classipc_1_1transport_1_1struc_1_1shm_1_1Builder_a7909a2d1e1d24037fb8af5338fffa783_cgraph.svg" width="324" height="83"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe>
</div>
</div>

</div>
</div>
<a id="a8f01bec0e66080850379df98a2ecf99e" name="a8f01bec0e66080850379df98a2ecf99e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8f01bec0e66080850379df98a2ecf99e">&#9670;&nbsp;</a></span>n_serialization_segments()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Shm_arena &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">size_t <a class="el" href="classipc_1_1transport_1_1struc_1_1shm_1_1Builder.html">ipc::transport::struc::shm::Builder</a>&lt; Shm_arena &gt;::n_serialization_segments</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Implements concept API. </p>
<p >Additionally: this <em>always</em> returns 1. You may rely on this.</p>
<dl class="section return"><dt>Returns</dt><dd>See above.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classipc_1_1transport_1_1struc_1_1Struct__builder.html#ae1516b0d68c48f2e13baf6aca366ac6c" title="Returns what target_blobs.size() would return after calling emit_serialization(&amp;target_blobs) (with a...">Struct_builder::n_serialization_segments()</a>: implemented concept. </dd></dl>

<p class="definition">Definition at line <a class="el" href="ipc__shm_2src_2ipc_2transport_2struc_2shm_2serializer_8hpp_source.html#l00609">609</a> of file <a class="el" href="ipc__shm_2src_2ipc_2transport_2struc_2shm_2serializer_8hpp_source.html">serializer.hpp</a>.</p>

</div>
</div>
<a id="a1f6e7a9e4b810d1737fdb24240e227c1" name="a1f6e7a9e4b810d1737fdb24240e227c1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1f6e7a9e4b810d1737fdb24240e227c1">&#9670;&nbsp;</a></span>operator=()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Shm_arena &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classipc_1_1transport_1_1struc_1_1shm_1_1Builder.html">Builder</a>&lt; Shm_arena &gt; &amp; <a class="el" href="classipc_1_1transport_1_1struc_1_1shm_1_1Builder.html">ipc::transport::struc::shm::Builder</a>&lt; Shm_arena &gt;::operator= </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classipc_1_1transport_1_1struc_1_1shm_1_1Builder.html">Builder</a>&lt; Shm_arena &gt; &amp;&amp;&#160;</td>
          <td class="paramname"><em>src</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">default</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Implements concept API. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">src</td><td>See above. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>See above.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classipc_1_1transport_1_1struc_1_1Struct__builder.html#a460aa187c0aaa5adfb81ecc902c7eca9" title="Default ctor, leaving *this in a state only suitable for destruction or being moved-to.">Struct_builder::Struct_builder()</a>: implemented concept. </dd></dl>

</div>
</div>
<a id="aaeceaccf183170b1785aa240921ae893" name="aaeceaccf183170b1785aa240921ae893"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaeceaccf183170b1785aa240921ae893">&#9670;&nbsp;</a></span>payload_msg_builder()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Shm_arena &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespaceipc_1_1transport_1_1struc.html#a52405569bf63eaef55f3c2435c885abc">Capnp_msg_builder_interface</a> * <a class="el" href="classipc_1_1transport_1_1struc_1_1shm_1_1Builder.html">ipc::transport::struc::shm::Builder</a>&lt; Shm_arena &gt;::payload_msg_builder</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Implements concept API. </p>
<p >Please see "Failure mode" discussion in our class doc header which notes that any mutation of what <a class="el" href="classipc_1_1transport_1_1struc_1_1shm_1_1Builder.html#aaeceaccf183170b1785aa240921ae893" title="Implements concept API.">payload_msg_builder()</a> returns may throw a bad-alloc exception, if the SHM provider cannot satisfy a capnp-required segment-allocation request.</p>
<dl class="section return"><dt>Returns</dt><dd>See above.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classipc_1_1transport_1_1struc_1_1Struct__builder.html#a9a4b9587c162f85ad4d3e0a5fad8dffb" title="Pointer to the payload Capnp_msg_builder_interface, suitable for mutation by the user.">Struct_builder::payload_msg_builder()</a>: implemented concept. </dd></dl>

<p class="definition">Definition at line <a class="el" href="ipc__shm_2src_2ipc_2transport_2struc_2shm_2serializer_8hpp_source.html#l00546">546</a> of file <a class="el" href="ipc__shm_2src_2ipc_2transport_2struc_2shm_2serializer_8hpp_source.html">serializer.hpp</a>.</p>

</div>
</div>
<h2 class="groupheader">Friends And Related Function Documentation</h2>
<a id="a705eab4975089bdd7c6d961b079a2252" name="a705eab4975089bdd7c6d961b079a2252"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a705eab4975089bdd7c6d961b079a2252">&#9670;&nbsp;</a></span>operator&lt;&lt;()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Shm_arena &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::ostream &amp; operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>os</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classipc_1_1transport_1_1struc_1_1shm_1_1Builder.html">Builder</a>&lt; Shm_arena &gt; &amp;&#160;</td>
          <td class="paramname"><em>val</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Prints string representation of the given <code><a class="el" href="classipc_1_1transport_1_1struc_1_1shm_1_1Builder.html" title="Implements Struct_builder concept with maximal zero-copy perf by (1) storing the actual user-schema-c...">Builder</a></code> to the given <code>ostream</code>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">os</td><td>Stream to which to write. </td></tr>
    <tr><td class="paramname">val</td><td>Object to serialize. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>os</code>. </dd></dl>

<p class="definition">Definition at line <a class="el" href="ipc__shm_2src_2ipc_2transport_2struc_2shm_2serializer_8hpp_source.html#l00617">617</a> of file <a class="el" href="ipc__shm_2src_2ipc_2transport_2struc_2shm_2serializer_8hpp_source.html">serializer.hpp</a>.</p>

</div>
</div>
<h2 class="groupheader">Member Data Documentation</h2>
<a id="a828d2e04ba4f62e30ae14518dd33dd63" name="a828d2e04ba4f62e30ae14518dd33dd63"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a828d2e04ba4f62e30ae14518dd33dd63">&#9670;&nbsp;</a></span>m_btm_engine</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Shm_arena &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">boost::movelib::unique_ptr&lt;<a class="el" href="classipc_1_1transport_1_1struc_1_1shm_1_1Builder.html#a1609cbc67e5799de53b6ed6671462b74">Capnp_heap_engine</a>&gt; <a class="el" href="classipc_1_1transport_1_1struc_1_1shm_1_1Builder.html">ipc::transport::struc::shm::Builder</a>&lt; Shm_arena &gt;::m_btm_engine</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>See <a class="el" href="classipc_1_1transport_1_1struc_1_1shm_1_1Builder.html#a1609cbc67e5799de53b6ed6671462b74" title="The work-horse capnp-aware engine in charge of allocating segments in SHM on capnp&#39;s request,...">Capnp_heap_engine</a>. </p>
<h3>Why the <code>unique_ptr</code> wrapper?</h3>
<p >See similar section in <a class="el" href="classipc_1_1transport_1_1struc_1_1Heap__fixed__builder.html#a8f8e07a71aa5e47d6b8094b2a004cc7d" title="The capnp builder engine which really does the work including owning the needed allocated segments so...">Heap_fixed_builder::m_engine</a> doc header. Same thing here.</p>
<p >Moreover: We also have <a class="el" href="classipc_1_1transport_1_1struc_1_1shm_1_1Builder.html#a3283aa7dc43b3851b94ff65f1f01d5e1" title="The top-serialization builder, namely Heap_fixed_builder, of our simple SHM-handle-bearing schema.">m_top_engine</a>, itself a <a class="el" href="classipc_1_1transport_1_1struc_1_1Heap__fixed__builder.html" title="Implements Struct_builder concept by straightforwardly allocating fixed-size segments on-demand in th...">Heap_fixed_builder</a>, which is cheaply move-ctible/assignable (as of this writing another <code>unique_ptr</code> and a <code>size_t</code>). So a move-from for us means copying those items, plus the wrapping <code>unique_ptr&lt;Capnp_heap_engine&gt;</code> here. That is acceptable perf. Had we not wrapped the 2 <a class="el" href="classCapnp__msg__builder__interface.html">Capnp_msg_builder_interface</a> objects involved (this guy and the one inside <a class="el" href="classipc_1_1transport_1_1struc_1_1shm_1_1Builder.html#a3283aa7dc43b3851b94ff65f1f01d5e1" title="The top-serialization builder, namely Heap_fixed_builder, of our simple SHM-handle-bearing schema.">m_top_engine</a>), a move-from would lug-around something like 400+ bytes; not great. A couple added allocs/deallocs of ~8 bytes should indeed be better. </p>

<p class="definition">Definition at line <a class="el" href="ipc__shm_2src_2ipc_2transport_2struc_2shm_2serializer_8hpp_source.html#l00318">318</a> of file <a class="el" href="ipc__shm_2src_2ipc_2transport_2struc_2shm_2serializer_8hpp_source.html">serializer.hpp</a>.</p>

</div>
</div>
<a id="a3283aa7dc43b3851b94ff65f1f01d5e1" name="a3283aa7dc43b3851b94ff65f1f01d5e1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3283aa7dc43b3851b94ff65f1f01d5e1">&#9670;&nbsp;</a></span>m_top_engine</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Shm_arena &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classipc_1_1transport_1_1struc_1_1Heap__fixed__builder.html">Heap_fixed_builder</a> <a class="el" href="classipc_1_1transport_1_1struc_1_1shm_1_1Builder.html">ipc::transport::struc::shm::Builder</a>&lt; Shm_arena &gt;::m_top_engine</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>The top-serialization builder, namely <a class="el" href="classipc_1_1transport_1_1struc_1_1Heap__fixed__builder.html" title="Implements Struct_builder concept by straightforwardly allocating fixed-size segments on-demand in th...">Heap_fixed_builder</a>, of our simple SHM-handle-bearing schema. </p>

<p class="definition">Definition at line <a class="el" href="ipc__shm_2src_2ipc_2transport_2struc_2shm_2serializer_8hpp_source.html#l00303">303</a> of file <a class="el" href="ipc__shm_2src_2ipc_2transport_2struc_2shm_2serializer_8hpp_source.html">serializer.hpp</a>.</p>

</div>
</div>
<hr/>The documentation for this class was generated from the following files:<ul>
<li>transport/struc/shm/<a class="el" href="ipc__shm_2src_2ipc_2transport_2struc_2shm_2serializer_8hpp_source.html">serializer.hpp</a></li>
<li>transport/struc/shm/<a class="el" href="transport_2struc_2shm_2shm__fwd_8hpp_source.html">shm_fwd.hpp</a></li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Sat Feb 17 2024 01:32:15 for Flow-IPC by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.4
</small></address>
</body>
</html>
