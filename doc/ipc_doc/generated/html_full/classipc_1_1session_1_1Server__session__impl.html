<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.9.4"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Flow-IPC: ipc::session::Server_session_impl&lt; S_MQ_TYPE_OR_NONE, S_TRANSMIT_NATIVE_HANDLES, Mdt_payload, S_SHM_TYPE_OR_NONE, S_SHM_MAX_HNDL_SZ, S_GRACEFUL_FINISH_REQUIRED_V &gt; Class Template Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">Flow-IPC<span id="projectnumber">&#160;2.0.0</span>
   </div>
   <div id="projectbrief">Flow-IPC project: Full implementation reference.</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.4 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search",'Search','.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespaceipc.html">ipc</a></li><li class="navelem"><a class="el" href="namespaceipc_1_1session.html">session</a></li><li class="navelem"><a class="el" href="classipc_1_1session_1_1Server__session__impl.html">Server_session_impl</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#pub-types">Public Types</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pub-static-attribs">Static Public Attributes</a> &#124;
<a href="#pro-types">Protected Types</a> &#124;
<a href="#pro-methods">Protected Member Functions</a> &#124;
<a href="#pri-types">Private Types</a> &#124;
<a href="#pri-methods">Private Member Functions</a> &#124;
<a href="#pri-attribs">Private Attributes</a> &#124;
<a href="#related">Related Functions</a> &#124;
<a href="classipc_1_1session_1_1Server__session__impl-members.html">List of all members</a>  </div>
  <div class="headertitle"><div class="title">ipc::session::Server_session_impl&lt; S_MQ_TYPE_OR_NONE, S_TRANSMIT_NATIVE_HANDLES, Mdt_payload, S_SHM_TYPE_OR_NONE, S_SHM_MAX_HNDL_SZ, S_GRACEFUL_FINISH_REQUIRED_V &gt; Class Template Reference</div></div>
</div><!--header-->
<div class="contents">

<p>Internal, non-movable pImpl-lite implementation of <a class="el" href="classipc_1_1session_1_1Server__session__mv.html" title="Implements Session concept on the Server_app end: a Session that is emitted in almost-PEER state by l...">Server_session_mv</a> class template.  
 <a href="classipc_1_1session_1_1Server__session__impl.html#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="ipc__session_2src_2ipc_2session_2detail_2server__session__impl_8hpp_source.html">server_session_impl.hpp</a>&gt;</code></p>
<div class="dynheader">
Inheritance diagram for ipc::session::Server_session_impl&lt; S_MQ_TYPE_OR_NONE, S_TRANSMIT_NATIVE_HANDLES, Mdt_payload, S_SHM_TYPE_OR_NONE, S_SHM_MAX_HNDL_SZ, S_GRACEFUL_FINISH_REQUIRED_V &gt;:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="classipc_1_1session_1_1Server__session__impl__inherit__graph.svg" width="672" height="120"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe>
</div>
<center><span class="legend">[<a href="graph_legend.html">legend</a>]</span></center></div>
<div class="dynheader">
Collaboration diagram for ipc::session::Server_session_impl&lt; S_MQ_TYPE_OR_NONE, S_TRANSMIT_NATIVE_HANDLES, Mdt_payload, S_SHM_TYPE_OR_NONE, S_SHM_MAX_HNDL_SZ, S_GRACEFUL_FINISH_REQUIRED_V &gt;:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="classipc_1_1session_1_1Server__session__impl__coll__graph.svg" width="1879" height="1328"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe>
</div>
<center><span class="legend">[<a href="graph_legend.html">legend</a>]</span></center></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="nested-classes" name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structipc_1_1session_1_1Server__session__impl_1_1Open__channel__req.html">Open_channel_req</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">An open-channel request out-message.  <a href="structipc_1_1session_1_1Server__session__impl_1_1Open__channel__req.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-types" name="pub-types"></a>
Public Types</h2></td></tr>
<tr class="memitem:a80daf8c8041d8d510f4712156732b09d"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classipc_1_1session_1_1Server__session__impl.html#a80daf8c8041d8d510f4712156732b09d">Base</a> = <a class="el" href="classipc_1_1session_1_1Session__base.html">Session_base</a>&lt; S_MQ_TYPE_OR_NONE, S_TRANSMIT_NATIVE_HANDLES, Mdt_payload &gt;</td></tr>
<tr class="memdesc:a80daf8c8041d8d510f4712156732b09d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Short-hand for base type.  <a href="classipc_1_1session_1_1Server__session__impl.html#a80daf8c8041d8d510f4712156732b09d">More...</a><br /></td></tr>
<tr class="separator:a80daf8c8041d8d510f4712156732b09d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3797b21c6b9c430471e3d9835acb2979"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classipc_1_1session_1_1Server__session__impl.html#a3797b21c6b9c430471e3d9835acb2979">Session_base_obj</a> = <a class="el" href="classipc_1_1session_1_1Server__session__impl.html#a80daf8c8041d8d510f4712156732b09d">Base</a></td></tr>
<tr class="memdesc:a3797b21c6b9c430471e3d9835acb2979"><td class="mdescLeft">&#160;</td><td class="mdescRight">Short-hand for <a class="el" href="classipc_1_1session_1_1Session__base.html" title="Internal type containing data and types common to internal types Server_session_impl and Client_sessi...">Session_base</a> super-class.  <a href="classipc_1_1session_1_1Server__session__impl.html#a3797b21c6b9c430471e3d9835acb2979">More...</a><br /></td></tr>
<tr class="separator:a3797b21c6b9c430471e3d9835acb2979"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7c969c3a1007f8e4ba3ad1c1acd6c290"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classipc_1_1session_1_1Server__session__impl.html#a7c969c3a1007f8e4ba3ad1c1acd6c290">Channel_obj</a> = typename <a class="el" href="classipc_1_1session_1_1Session__base.html#a71f02a809d667c23ff8af29a96940bd1">Base::Channel_obj</a></td></tr>
<tr class="memdesc:a7c969c3a1007f8e4ba3ad1c1acd6c290"><td class="mdescLeft">&#160;</td><td class="mdescRight">See <a class="el" href="classipc_1_1session_1_1Server__session__mv.html" title="Implements Session concept on the Server_app end: a Session that is emitted in almost-PEER state by l...">Server_session_mv</a> counterpart.  <a href="classipc_1_1session_1_1Server__session__impl.html#a7c969c3a1007f8e4ba3ad1c1acd6c290">More...</a><br /></td></tr>
<tr class="separator:a7c969c3a1007f8e4ba3ad1c1acd6c290"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a75df7061f9c57660f9fb944d83da416b"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classipc_1_1session_1_1Server__session__impl.html#a75df7061f9c57660f9fb944d83da416b">Channels</a> = typename <a class="el" href="classipc_1_1session_1_1Session__base.html#a638232ef74a0eb80aeb4f027ee06f9bf">Base::Channels</a></td></tr>
<tr class="memdesc:a75df7061f9c57660f9fb944d83da416b"><td class="mdescLeft">&#160;</td><td class="mdescRight">See <a class="el" href="classipc_1_1session_1_1Session__mv.html" title="Implements the Session concept when it is in PEER state.">Session_mv</a> counterpart.  <a href="classipc_1_1session_1_1Server__session__impl.html#a75df7061f9c57660f9fb944d83da416b">More...</a><br /></td></tr>
<tr class="separator:a75df7061f9c57660f9fb944d83da416b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa9cd0c1e6792a4ee096b55b13b4db803"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classipc_1_1session_1_1Server__session__impl.html#aa9cd0c1e6792a4ee096b55b13b4db803">Mdt_payload_obj</a> = typename <a class="el" href="classipc_1_1session_1_1Session__base.html#a35234981ca87cc2f6b118b3e52452ea8">Base::Mdt_payload_obj</a></td></tr>
<tr class="memdesc:aa9cd0c1e6792a4ee096b55b13b4db803"><td class="mdescLeft">&#160;</td><td class="mdescRight">See <a class="el" href="classipc_1_1session_1_1Server__session__mv.html" title="Implements Session concept on the Server_app end: a Session that is emitted in almost-PEER state by l...">Server_session_mv</a> counterpart.  <a href="classipc_1_1session_1_1Server__session__impl.html#aa9cd0c1e6792a4ee096b55b13b4db803">More...</a><br /></td></tr>
<tr class="separator:aa9cd0c1e6792a4ee096b55b13b4db803"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a78e61f8681c7ec92fa19bae560763ab1"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classipc_1_1session_1_1Server__session__impl.html#a78e61f8681c7ec92fa19bae560763ab1">Mdt_reader_ptr</a> = typename <a class="el" href="classipc_1_1session_1_1Session__base.html#ace4dab42adec6354cc66081dd218ac71">Base::Mdt_reader_ptr</a></td></tr>
<tr class="memdesc:a78e61f8681c7ec92fa19bae560763ab1"><td class="mdescLeft">&#160;</td><td class="mdescRight">See <a class="el" href="classipc_1_1session_1_1Server__session__mv.html" title="Implements Session concept on the Server_app end: a Session that is emitted in almost-PEER state by l...">Server_session_mv</a> counterpart.  <a href="classipc_1_1session_1_1Server__session__impl.html#a78e61f8681c7ec92fa19bae560763ab1">More...</a><br /></td></tr>
<tr class="separator:a78e61f8681c7ec92fa19bae560763ab1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7134fc9c4d26ba1fbc8e5da266d970e5"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classipc_1_1session_1_1Server__session__impl.html#a7134fc9c4d26ba1fbc8e5da266d970e5">Mdt_builder</a> = typename <a class="el" href="classipc_1_1session_1_1Session__base.html#a7d68bbb8c0c09983619d563bca30bd45">Base::Mdt_builder</a></td></tr>
<tr class="memdesc:a7134fc9c4d26ba1fbc8e5da266d970e5"><td class="mdescLeft">&#160;</td><td class="mdescRight">See <a class="el" href="classipc_1_1session_1_1Server__session__mv.html" title="Implements Session concept on the Server_app end: a Session that is emitted in almost-PEER state by l...">Server_session_mv</a> counterpart.  <a href="classipc_1_1session_1_1Server__session__impl.html#a7134fc9c4d26ba1fbc8e5da266d970e5">More...</a><br /></td></tr>
<tr class="separator:a7134fc9c4d26ba1fbc8e5da266d970e5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac4bc7e38574e0495af4887d2e6226b7a"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classipc_1_1session_1_1Server__session__impl.html#ac4bc7e38574e0495af4887d2e6226b7a">Mdt_builder_ptr</a> = typename <a class="el" href="classipc_1_1session_1_1Session__base.html#a4a7a5b83f6ba8bd505685636eabc012b">Base::Mdt_builder_ptr</a></td></tr>
<tr class="memdesc:ac4bc7e38574e0495af4887d2e6226b7a"><td class="mdescLeft">&#160;</td><td class="mdescRight">See <a class="el" href="classipc_1_1session_1_1Server__session__mv.html" title="Implements Session concept on the Server_app end: a Session that is emitted in almost-PEER state by l...">Server_session_mv</a> counterpart.  <a href="classipc_1_1session_1_1Server__session__impl.html#ac4bc7e38574e0495af4887d2e6226b7a">More...</a><br /></td></tr>
<tr class="separator:ac4bc7e38574e0495af4887d2e6226b7a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abff6feea533de655f0cd8017d6ea3293"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classipc_1_1session_1_1Server__session__impl.html#abff6feea533de655f0cd8017d6ea3293">Structured_msg_builder_config</a> = typename <a class="el" href="classipc_1_1session_1_1Session__base.html#aee0db48505c84d3553b7110a9a815036">Base::Structured_msg_builder_config</a></td></tr>
<tr class="memdesc:abff6feea533de655f0cd8017d6ea3293"><td class="mdescLeft">&#160;</td><td class="mdescRight">See <a class="el" href="classipc_1_1session_1_1Session__mv.html" title="Implements the Session concept when it is in PEER state.">Session_mv</a> counterpart.  <a href="classipc_1_1session_1_1Server__session__impl.html#abff6feea533de655f0cd8017d6ea3293">More...</a><br /></td></tr>
<tr class="separator:abff6feea533de655f0cd8017d6ea3293"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab8612a76df11f9db0d4f335848cda822"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classipc_1_1session_1_1Server__session__impl.html#ab8612a76df11f9db0d4f335848cda822">Structured_msg_reader_config</a> = typename <a class="el" href="classipc_1_1session_1_1Session__base.html#abd854f2b9316361ef18f15610c242d4b">Base::Structured_msg_reader_config</a></td></tr>
<tr class="memdesc:ab8612a76df11f9db0d4f335848cda822"><td class="mdescLeft">&#160;</td><td class="mdescRight">See <a class="el" href="classipc_1_1session_1_1Session__mv.html" title="Implements the Session concept when it is in PEER state.">Session_mv</a> counterpart.  <a href="classipc_1_1session_1_1Server__session__impl.html#ab8612a76df11f9db0d4f335848cda822">More...</a><br /></td></tr>
<tr class="separator:ab8612a76df11f9db0d4f335848cda822"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pub_types_classipc_1_1session_1_1Session__base"><td colspan="2" onclick="javascript:toggleInherit('pub_types_classipc_1_1session_1_1Session__base')"><img src="closed.png" alt="-"/>&#160;Public Types inherited from <a class="el" href="classipc_1_1session_1_1Session__base.html">ipc::session::Session_base&lt; S_MQ_TYPE_OR_NONE, S_TRANSMIT_NATIVE_HANDLES, Mdt_payload &gt;</a></td></tr>
<tr class="memitem:a848c0f5247644ada0f8b0ab816eedda8 inherit pub_types_classipc_1_1session_1_1Session__base"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classipc_1_1session_1_1Session__base.html#a848c0f5247644ada0f8b0ab816eedda8">Persistent_mq_handle_from_cfg</a> = std::conditional_t&lt;!<a class="el" href="classipc_1_1session_1_1Session__base.html#a27a5731a648effb6b4b42f0312affa74">S_MQS_ENABLED</a>, <a class="el" href="classipc_1_1transport_1_1Null__peer.html">transport::Null_peer</a>, std::conditional_t&lt; S_MQ_TYPE_OR_NONE==schema::MqType::POSIX, <a class="el" href="classipc_1_1transport_1_1Posix__mq__handle.html">transport::Posix_mq_handle</a>, <a class="el" href="classipc_1_1transport_1_1Bipc__mq__handle.html">transport::Bipc_mq_handle</a> &gt; &gt;</td></tr>
<tr class="memdesc:a848c0f5247644ada0f8b0ab816eedda8 inherit pub_types_classipc_1_1session_1_1Session__base"><td class="mdescLeft">&#160;</td><td class="mdescRight">Relevant only if <a class="el" href="classipc_1_1session_1_1Session__base.html#a27a5731a648effb6b4b42f0312affa74" title="See Session_mv.">S_MQS_ENABLED</a>, this is the Persistent_mq_handle-concept impl type specified by the user via <code>S_MQ_TYPE_OR_NONE</code>.  <a href="classipc_1_1session_1_1Session__base.html#a848c0f5247644ada0f8b0ab816eedda8">More...</a><br /></td></tr>
<tr class="separator:a848c0f5247644ada0f8b0ab816eedda8 inherit pub_types_classipc_1_1session_1_1Session__base"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a71f02a809d667c23ff8af29a96940bd1 inherit pub_types_classipc_1_1session_1_1Session__base"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classipc_1_1session_1_1Session__base.html#a71f02a809d667c23ff8af29a96940bd1">Channel_obj</a> = std::conditional_t&lt; <a class="el" href="classipc_1_1session_1_1Session__base.html#a27a5731a648effb6b4b42f0312affa74">S_MQS_ENABLED</a>, std::conditional_t&lt; S_TRANSMIT_NATIVE_HANDLES, <a class="el" href="classipc_1_1transport_1_1Mqs__socket__stream__channel.html">transport::Mqs_socket_stream_channel</a>&lt; true, <a class="el" href="classipc_1_1session_1_1Session__base.html#a848c0f5247644ada0f8b0ab816eedda8">Persistent_mq_handle_from_cfg</a> &gt;, <a class="el" href="classipc_1_1transport_1_1Mqs__channel.html">transport::Mqs_channel</a>&lt; true, <a class="el" href="classipc_1_1session_1_1Session__base.html#a848c0f5247644ada0f8b0ab816eedda8">Persistent_mq_handle_from_cfg</a> &gt; &gt;, std::conditional_t&lt; S_TRANSMIT_NATIVE_HANDLES, <a class="el" href="classipc_1_1transport_1_1Socket__stream__channel.html">transport::Socket_stream_channel</a>&lt; true &gt;, <a class="el" href="classipc_1_1transport_1_1Socket__stream__channel__of__blobs.html">transport::Socket_stream_channel_of_blobs</a>&lt; true &gt; &gt; &gt;</td></tr>
<tr class="memdesc:a71f02a809d667c23ff8af29a96940bd1 inherit pub_types_classipc_1_1session_1_1Session__base"><td class="mdescLeft">&#160;</td><td class="mdescRight">See <a class="el" href="classipc_1_1session_1_1Session__mv.html" title="Implements the Session concept when it is in PEER state.">Session_mv</a> (or <a class="el" href="classipc_1_1session_1_1Session.html" title="A documentation-only concept defining the local side of an IPC conversation (session) with another en...">Session</a> concept).  <a href="classipc_1_1session_1_1Session__base.html#a71f02a809d667c23ff8af29a96940bd1">More...</a><br /></td></tr>
<tr class="separator:a71f02a809d667c23ff8af29a96940bd1 inherit pub_types_classipc_1_1session_1_1Session__base"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a638232ef74a0eb80aeb4f027ee06f9bf inherit pub_types_classipc_1_1session_1_1Session__base"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classipc_1_1session_1_1Session__base.html#a638232ef74a0eb80aeb4f027ee06f9bf">Channels</a> = std::vector&lt; <a class="el" href="classipc_1_1session_1_1Session__base.html#a71f02a809d667c23ff8af29a96940bd1">Channel_obj</a> &gt;</td></tr>
<tr class="memdesc:a638232ef74a0eb80aeb4f027ee06f9bf inherit pub_types_classipc_1_1session_1_1Session__base"><td class="mdescLeft">&#160;</td><td class="mdescRight">See <a class="el" href="classipc_1_1session_1_1Session__mv.html" title="Implements the Session concept when it is in PEER state.">Session_mv</a>. Note: If changed from <code>vector</code> please update those doc headers too.  <a href="classipc_1_1session_1_1Session__base.html#a638232ef74a0eb80aeb4f027ee06f9bf">More...</a><br /></td></tr>
<tr class="separator:a638232ef74a0eb80aeb4f027ee06f9bf inherit pub_types_classipc_1_1session_1_1Session__base"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a35234981ca87cc2f6b118b3e52452ea8 inherit pub_types_classipc_1_1session_1_1Session__base"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classipc_1_1session_1_1Session__base.html#a35234981ca87cc2f6b118b3e52452ea8">Mdt_payload_obj</a> = Mdt_payload</td></tr>
<tr class="memdesc:a35234981ca87cc2f6b118b3e52452ea8 inherit pub_types_classipc_1_1session_1_1Session__base"><td class="mdescLeft">&#160;</td><td class="mdescRight">See <a class="el" href="classipc_1_1session_1_1Session__mv.html" title="Implements the Session concept when it is in PEER state.">Session_mv</a> (or <a class="el" href="classipc_1_1session_1_1Session.html" title="A documentation-only concept defining the local side of an IPC conversation (session) with another en...">Session</a> concept).  <a href="classipc_1_1session_1_1Session__base.html#a35234981ca87cc2f6b118b3e52452ea8">More...</a><br /></td></tr>
<tr class="separator:a35234981ca87cc2f6b118b3e52452ea8 inherit pub_types_classipc_1_1session_1_1Session__base"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ace4dab42adec6354cc66081dd218ac71 inherit pub_types_classipc_1_1session_1_1Session__base"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classipc_1_1session_1_1Session__base.html#ace4dab42adec6354cc66081dd218ac71">Mdt_reader_ptr</a> = boost::shared_ptr&lt; typename transport::struc::schema::Metadata&lt; <a class="el" href="classipc_1_1session_1_1Session__base.html#a35234981ca87cc2f6b118b3e52452ea8">Mdt_payload_obj</a> &gt;::Reader &gt;</td></tr>
<tr class="memdesc:ace4dab42adec6354cc66081dd218ac71 inherit pub_types_classipc_1_1session_1_1Session__base"><td class="mdescLeft">&#160;</td><td class="mdescRight">See <a class="el" href="classipc_1_1session_1_1Session__mv.html" title="Implements the Session concept when it is in PEER state.">Session_mv</a> (or <a class="el" href="classipc_1_1session_1_1Session.html" title="A documentation-only concept defining the local side of an IPC conversation (session) with another en...">Session</a> concept).  <a href="classipc_1_1session_1_1Session__base.html#ace4dab42adec6354cc66081dd218ac71">More...</a><br /></td></tr>
<tr class="separator:ace4dab42adec6354cc66081dd218ac71 inherit pub_types_classipc_1_1session_1_1Session__base"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7d68bbb8c0c09983619d563bca30bd45 inherit pub_types_classipc_1_1session_1_1Session__base"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classipc_1_1session_1_1Session__base.html#a7d68bbb8c0c09983619d563bca30bd45">Mdt_builder</a> = typename transport::struc::schema::Metadata&lt; <a class="el" href="classipc_1_1session_1_1Session__base.html#a35234981ca87cc2f6b118b3e52452ea8">Mdt_payload_obj</a> &gt;<a class="el" href="classStruct__builder__config_1_1Builder.html">::Builder</a></td></tr>
<tr class="memdesc:a7d68bbb8c0c09983619d563bca30bd45 inherit pub_types_classipc_1_1session_1_1Session__base"><td class="mdescLeft">&#160;</td><td class="mdescRight">See <a class="el" href="classipc_1_1session_1_1Session__mv.html" title="Implements the Session concept when it is in PEER state.">Session_mv</a> (or <a class="el" href="classipc_1_1session_1_1Session.html" title="A documentation-only concept defining the local side of an IPC conversation (session) with another en...">Session</a> concept).  <a href="classipc_1_1session_1_1Session__base.html#a7d68bbb8c0c09983619d563bca30bd45">More...</a><br /></td></tr>
<tr class="separator:a7d68bbb8c0c09983619d563bca30bd45 inherit pub_types_classipc_1_1session_1_1Session__base"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4a7a5b83f6ba8bd505685636eabc012b inherit pub_types_classipc_1_1session_1_1Session__base"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classipc_1_1session_1_1Session__base.html#a4a7a5b83f6ba8bd505685636eabc012b">Mdt_builder_ptr</a> = boost::shared_ptr&lt; <a class="el" href="classipc_1_1session_1_1Session__base.html#a7d68bbb8c0c09983619d563bca30bd45">Mdt_builder</a> &gt;</td></tr>
<tr class="memdesc:a4a7a5b83f6ba8bd505685636eabc012b inherit pub_types_classipc_1_1session_1_1Session__base"><td class="mdescLeft">&#160;</td><td class="mdescRight">See <a class="el" href="classipc_1_1session_1_1Session__mv.html" title="Implements the Session concept when it is in PEER state.">Session_mv</a> (or <a class="el" href="classipc_1_1session_1_1Session.html" title="A documentation-only concept defining the local side of an IPC conversation (session) with another en...">Session</a> concept).  <a href="classipc_1_1session_1_1Session__base.html#a4a7a5b83f6ba8bd505685636eabc012b">More...</a><br /></td></tr>
<tr class="separator:a4a7a5b83f6ba8bd505685636eabc012b inherit pub_types_classipc_1_1session_1_1Session__base"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aee0db48505c84d3553b7110a9a815036 inherit pub_types_classipc_1_1session_1_1Session__base"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classipc_1_1session_1_1Session__base.html#aee0db48505c84d3553b7110a9a815036">Structured_msg_builder_config</a> = <a class="el" href="structipc_1_1transport_1_1struc_1_1Heap__fixed__builder_1_1Config.html">transport::struc::Heap_fixed_builder::Config</a></td></tr>
<tr class="memdesc:aee0db48505c84d3553b7110a9a815036 inherit pub_types_classipc_1_1session_1_1Session__base"><td class="mdescLeft">&#160;</td><td class="mdescRight">See <a class="el" href="classipc_1_1session_1_1Session__mv.html" title="Implements the Session concept when it is in PEER state.">Session_mv</a> (or <a class="el" href="classipc_1_1session_1_1Session.html" title="A documentation-only concept defining the local side of an IPC conversation (session) with another en...">Session</a> concept).  <a href="classipc_1_1session_1_1Session__base.html#aee0db48505c84d3553b7110a9a815036">More...</a><br /></td></tr>
<tr class="separator:aee0db48505c84d3553b7110a9a815036 inherit pub_types_classipc_1_1session_1_1Session__base"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abd854f2b9316361ef18f15610c242d4b inherit pub_types_classipc_1_1session_1_1Session__base"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classipc_1_1session_1_1Session__base.html#abd854f2b9316361ef18f15610c242d4b">Structured_msg_reader_config</a> = <a class="el" href="structipc_1_1transport_1_1struc_1_1Heap__reader_1_1Config.html">transport::struc::Heap_reader::Config</a></td></tr>
<tr class="memdesc:abd854f2b9316361ef18f15610c242d4b inherit pub_types_classipc_1_1session_1_1Session__base"><td class="mdescLeft">&#160;</td><td class="mdescRight">See <a class="el" href="classipc_1_1session_1_1Session__mv.html" title="Implements the Session concept when it is in PEER state.">Session_mv</a> (or <a class="el" href="classipc_1_1session_1_1Session.html" title="A documentation-only concept defining the local side of an IPC conversation (session) with another en...">Session</a> concept).  <a href="classipc_1_1session_1_1Session__base.html#abd854f2b9316361ef18f15610c242d4b">More...</a><br /></td></tr>
<tr class="separator:abd854f2b9316361ef18f15610c242d4b inherit pub_types_classipc_1_1session_1_1Session__base"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-methods" name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a424215b95b49fea0b3b3986688395158"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classipc_1_1session_1_1Server__session__impl.html#a424215b95b49fea0b3b3986688395158">Server_session_impl</a> (flow::log::Logger *logger_ptr, const <a class="el" href="structipc_1_1session_1_1Server__app.html">Server_app</a> &amp;srv_app_ref, <a class="el" href="classipc_1_1transport_1_1sync__io_1_1Native__socket__stream.html">transport::sync_io::Native_socket_stream</a> &amp;&amp;master_channel_sock_stm)</td></tr>
<tr class="memdesc:a424215b95b49fea0b3b3986688395158"><td class="mdescLeft">&#160;</td><td class="mdescRight">For use by internal user <a class="el" href="classipc_1_1session_1_1Session__server.html" title="To be instantiated typically once in a given process, an object of this type asynchronously listens f...">Session_server</a>: See <a class="el" href="classipc_1_1session_1_1Server__session__mv.html" title="Implements Session concept on the Server_app end: a Session that is emitted in almost-PEER state by l...">Server_session_mv</a> counterpart.  <a href="classipc_1_1session_1_1Server__session__impl.html#a424215b95b49fea0b3b3986688395158">More...</a><br /></td></tr>
<tr class="separator:a424215b95b49fea0b3b3986688395158"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a145389df1784d5242adf69e2cc9826cd"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classipc_1_1session_1_1Server__session__impl.html#a145389df1784d5242adf69e2cc9826cd">~Server_session_impl</a> ()</td></tr>
<tr class="memdesc:a145389df1784d5242adf69e2cc9826cd"><td class="mdescLeft">&#160;</td><td class="mdescRight">See <a class="el" href="classipc_1_1session_1_1Server__session__mv.html" title="Implements Session concept on the Server_app end: a Session that is emitted in almost-PEER state by l...">Server_session_mv</a> counterpart.  <a href="classipc_1_1session_1_1Server__session__impl.html#a145389df1784d5242adf69e2cc9826cd">More...</a><br /></td></tr>
<tr class="separator:a145389df1784d5242adf69e2cc9826cd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aee35d521d9997d48f6b5565730e60e93"><td class="memTemplParams" colspan="2">template&lt;typename Session_server_impl_t , typename Task_err , typename Cli_app_lookup_func , typename Cli_namespace_func , typename Pre_rsp_setup_func , typename N_init_channels_by_srv_req_func , typename Mdt_load_func &gt; </td></tr>
<tr class="memitem:aee35d521d9997d48f6b5565730e60e93"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classipc_1_1session_1_1Server__session__impl.html#aee35d521d9997d48f6b5565730e60e93">async_accept_log_in</a> (Session_server_impl_t *srv, <a class="el" href="classipc_1_1session_1_1Server__session__impl.html#a75df7061f9c57660f9fb944d83da416b">Channels</a> *init_channels_by_srv_req, <a class="el" href="classipc_1_1session_1_1Server__session__impl.html#a78e61f8681c7ec92fa19bae560763ab1">Mdt_reader_ptr</a> *mdt_from_cli_or_null, <a class="el" href="classipc_1_1session_1_1Server__session__impl.html#a75df7061f9c57660f9fb944d83da416b">Channels</a> *init_channels_by_cli_req, Cli_app_lookup_func &amp;&amp;cli_app_lookup_func, Cli_namespace_func &amp;&amp;cli_namespace_func, Pre_rsp_setup_func &amp;&amp;pre_rsp_setup_func, N_init_channels_by_srv_req_func &amp;&amp;n_init_channels_by_srv_req_func, Mdt_load_func &amp;&amp;mdt_load_func, Task_err &amp;&amp;on_done_func)</td></tr>
<tr class="memdesc:aee35d521d9997d48f6b5565730e60e93"><td class="mdescLeft">&#160;</td><td class="mdescRight">For use by internal user <a class="el" href="classipc_1_1session_1_1Session__server.html" title="To be instantiated typically once in a given process, an object of this type asynchronously listens f...">Session_server</a>: See <a class="el" href="classipc_1_1session_1_1Server__session__mv.html" title="Implements Session concept on the Server_app end: a Session that is emitted in almost-PEER state by l...">Server_session_mv</a> counterpart.  <a href="classipc_1_1session_1_1Server__session__impl.html#aee35d521d9997d48f6b5565730e60e93">More...</a><br /></td></tr>
<tr class="separator:aee35d521d9997d48f6b5565730e60e93"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3deaeacf53a8fc63ed010394ef82c54c"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="structipc_1_1session_1_1Client__app.html">Client_app</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classipc_1_1session_1_1Server__session__impl.html#a3deaeacf53a8fc63ed010394ef82c54c">client_app</a> () const</td></tr>
<tr class="memdesc:a3deaeacf53a8fc63ed010394ef82c54c"><td class="mdescLeft">&#160;</td><td class="mdescRight">See <a class="el" href="classipc_1_1session_1_1Server__session__mv.html" title="Implements Session concept on the Server_app end: a Session that is emitted in almost-PEER state by l...">Server_session_mv</a> counterpart.  <a href="classipc_1_1session_1_1Server__session__impl.html#a3deaeacf53a8fc63ed010394ef82c54c">More...</a><br /></td></tr>
<tr class="separator:a3deaeacf53a8fc63ed010394ef82c54c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac93040ccdaf5a261a053a8b55bd2e14e"><td class="memTemplParams" colspan="2">template&lt;typename Task_err , typename On_passive_open_channel_handler &gt; </td></tr>
<tr class="memitem:ac93040ccdaf5a261a053a8b55bd2e14e"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classipc_1_1session_1_1Server__session__impl.html#ac93040ccdaf5a261a053a8b55bd2e14e">init_handlers</a> (Task_err &amp;&amp;on_err_func_arg, On_passive_open_channel_handler &amp;&amp;on_passive_open_channel_func_arg)</td></tr>
<tr class="memdesc:ac93040ccdaf5a261a053a8b55bd2e14e"><td class="mdescLeft">&#160;</td><td class="mdescRight">See <a class="el" href="classipc_1_1session_1_1Server__session__mv.html" title="Implements Session concept on the Server_app end: a Session that is emitted in almost-PEER state by l...">Server_session_mv</a> counterpart.  <a href="classipc_1_1session_1_1Server__session__impl.html#ac93040ccdaf5a261a053a8b55bd2e14e">More...</a><br /></td></tr>
<tr class="separator:ac93040ccdaf5a261a053a8b55bd2e14e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a493937b9737f1fc4803364c35ceae83e"><td class="memTemplParams" colspan="2">template&lt;typename Task_err &gt; </td></tr>
<tr class="memitem:a493937b9737f1fc4803364c35ceae83e"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classipc_1_1session_1_1Server__session__impl.html#a493937b9737f1fc4803364c35ceae83e">init_handlers</a> (Task_err &amp;&amp;on_err_func_arg)</td></tr>
<tr class="memdesc:a493937b9737f1fc4803364c35ceae83e"><td class="mdescLeft">&#160;</td><td class="mdescRight">See <a class="el" href="classipc_1_1session_1_1Server__session__mv.html" title="Implements Session concept on the Server_app end: a Session that is emitted in almost-PEER state by l...">Server_session_mv</a> counterpart.  <a href="classipc_1_1session_1_1Server__session__impl.html#a493937b9737f1fc4803364c35ceae83e">More...</a><br /></td></tr>
<tr class="separator:a493937b9737f1fc4803364c35ceae83e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a138956765a655240080491157f316167"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classipc_1_1session_1_1Server__session__impl.html#ac4bc7e38574e0495af4887d2e6226b7a">Mdt_builder_ptr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classipc_1_1session_1_1Server__session__impl.html#a138956765a655240080491157f316167">mdt_builder</a> ()</td></tr>
<tr class="memdesc:a138956765a655240080491157f316167"><td class="mdescLeft">&#160;</td><td class="mdescRight">See <a class="el" href="classipc_1_1session_1_1Server__session__mv.html" title="Implements Session concept on the Server_app end: a Session that is emitted in almost-PEER state by l...">Server_session_mv</a> counterpart.  <a href="classipc_1_1session_1_1Server__session__impl.html#a138956765a655240080491157f316167">More...</a><br /></td></tr>
<tr class="separator:a138956765a655240080491157f316167"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a45a5ae92b706ea539c27be0d19a303c4"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classipc_1_1session_1_1Server__session__impl.html#a45a5ae92b706ea539c27be0d19a303c4">open_channel</a> (<a class="el" href="classipc_1_1session_1_1Server__session__impl.html#a7c969c3a1007f8e4ba3ad1c1acd6c290">Channel_obj</a> *target_channel, const <a class="el" href="classipc_1_1session_1_1Server__session__impl.html#ac4bc7e38574e0495af4887d2e6226b7a">Mdt_builder_ptr</a> &amp;mdt, <a class="el" href="namespaceipc.html#aa3192e586cc45d3e7c22463bf2760f89">Error_code</a> *err_code=0)</td></tr>
<tr class="memdesc:a45a5ae92b706ea539c27be0d19a303c4"><td class="mdescLeft">&#160;</td><td class="mdescRight">See <a class="el" href="classipc_1_1session_1_1Server__session__mv.html" title="Implements Session concept on the Server_app end: a Session that is emitted in almost-PEER state by l...">Server_session_mv</a> counterpart.  <a href="classipc_1_1session_1_1Server__session__impl.html#a45a5ae92b706ea539c27be0d19a303c4">More...</a><br /></td></tr>
<tr class="separator:a45a5ae92b706ea539c27be0d19a303c4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adfb10992398b46be3b0e1ac0c8605ef4"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classipc_1_1session_1_1Server__session__impl.html#adfb10992398b46be3b0e1ac0c8605ef4">open_channel</a> (<a class="el" href="classipc_1_1session_1_1Server__session__impl.html#a7c969c3a1007f8e4ba3ad1c1acd6c290">Channel_obj</a> *target_channel, <a class="el" href="namespaceipc.html#aa3192e586cc45d3e7c22463bf2760f89">Error_code</a> *err_code=0)</td></tr>
<tr class="memdesc:adfb10992398b46be3b0e1ac0c8605ef4"><td class="mdescLeft">&#160;</td><td class="mdescRight">See <a class="el" href="classipc_1_1session_1_1Server__session__mv.html" title="Implements Session concept on the Server_app end: a Session that is emitted in almost-PEER state by l...">Server_session_mv</a> counterpart.  <a href="classipc_1_1session_1_1Server__session__impl.html#adfb10992398b46be3b0e1ac0c8605ef4">More...</a><br /></td></tr>
<tr class="separator:adfb10992398b46be3b0e1ac0c8605ef4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a22e1464a8bc4b806bf3a91e932b31813"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="namespaceipc_1_1session.html#ade2b302f1a3623e8adc9694568d94d2c">Session_token</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classipc_1_1session_1_1Server__session__impl.html#a22e1464a8bc4b806bf3a91e932b31813">session_token</a> () const</td></tr>
<tr class="memdesc:a22e1464a8bc4b806bf3a91e932b31813"><td class="mdescLeft">&#160;</td><td class="mdescRight">See <a class="el" href="classipc_1_1session_1_1Server__session__mv.html" title="Implements Session concept on the Server_app end: a Session that is emitted in almost-PEER state by l...">Server_session_mv</a> counterpart.  <a href="classipc_1_1session_1_1Server__session__impl.html#a22e1464a8bc4b806bf3a91e932b31813">More...</a><br /></td></tr>
<tr class="separator:a22e1464a8bc4b806bf3a91e932b31813"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0992cbc57bf346d6b8df191f2dcb9188"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classipc_1_1session_1_1Server__session__impl.html#a80daf8c8041d8d510f4712156732b09d">Base</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classipc_1_1session_1_1Server__session__impl.html#a0992cbc57bf346d6b8df191f2dcb9188">base</a> () const</td></tr>
<tr class="memdesc:a0992cbc57bf346d6b8df191f2dcb9188"><td class="mdescLeft">&#160;</td><td class="mdescRight">See <a class="el" href="classipc_1_1session_1_1Server__session__mv.html" title="Implements Session concept on the Server_app end: a Session that is emitted in almost-PEER state by l...">Server_session_mv</a> counterpart.  <a href="classipc_1_1session_1_1Server__session__impl.html#a0992cbc57bf346d6b8df191f2dcb9188">More...</a><br /></td></tr>
<tr class="separator:a0992cbc57bf346d6b8df191f2dcb9188"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pub_methods_classipc_1_1session_1_1Session__base"><td colspan="2" onclick="javascript:toggleInherit('pub_methods_classipc_1_1session_1_1Session__base')"><img src="closed.png" alt="-"/>&#160;Public Member Functions inherited from <a class="el" href="classipc_1_1session_1_1Session__base.html">ipc::session::Session_base&lt; S_MQ_TYPE_OR_NONE, S_TRANSMIT_NATIVE_HANDLES, Mdt_payload &gt;</a></td></tr>
<tr class="memitem:a4d1327608d6067ed6690bd4efa323c6f inherit pub_methods_classipc_1_1session_1_1Session__base"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="namespaceipc_1_1session.html#a6d07d9996af19e57eb42416e914110ea">Shared_name</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classipc_1_1session_1_1Session__base.html#a4d1327608d6067ed6690bd4efa323c6f">srv_namespace</a> () const</td></tr>
<tr class="memdesc:a4d1327608d6067ed6690bd4efa323c6f inherit pub_methods_classipc_1_1session_1_1Session__base"><td class="mdescLeft">&#160;</td><td class="mdescRight">See <a class="el" href="classipc_1_1session_1_1Server__session__impl.html" title="Internal, non-movable pImpl-lite implementation of Server_session_mv class template.">Server_session_impl</a>, <a class="el" href="classipc_1_1session_1_1Client__session__impl.html" title="Internal, non-movable pImpl-lite implementation of Client_session_mv class template.">Client_session_impl</a>.  <a href="classipc_1_1session_1_1Session__base.html#a4d1327608d6067ed6690bd4efa323c6f">More...</a><br /></td></tr>
<tr class="separator:a4d1327608d6067ed6690bd4efa323c6f inherit pub_methods_classipc_1_1session_1_1Session__base"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abd1e814b3b640f4bdaa2553352405f26 inherit pub_methods_classipc_1_1session_1_1Session__base"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="namespaceipc_1_1session.html#a6d07d9996af19e57eb42416e914110ea">Shared_name</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classipc_1_1session_1_1Session__base.html#abd1e814b3b640f4bdaa2553352405f26">cli_namespace</a> () const</td></tr>
<tr class="memdesc:abd1e814b3b640f4bdaa2553352405f26 inherit pub_methods_classipc_1_1session_1_1Session__base"><td class="mdescLeft">&#160;</td><td class="mdescRight">See <a class="el" href="classipc_1_1session_1_1Server__session__impl.html" title="Internal, non-movable pImpl-lite implementation of Server_session_mv class template.">Server_session_impl</a>, <a class="el" href="classipc_1_1session_1_1Client__session__impl.html" title="Internal, non-movable pImpl-lite implementation of Client_session_mv class template.">Client_session_impl</a>.  <a href="classipc_1_1session_1_1Session__base.html#abd1e814b3b640f4bdaa2553352405f26">More...</a><br /></td></tr>
<tr class="separator:abd1e814b3b640f4bdaa2553352405f26 inherit pub_methods_classipc_1_1session_1_1Session__base"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3ebdafe7e70719e6d12dd0b15ae85106 inherit pub_methods_classipc_1_1session_1_1Session__base"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="structipc_1_1session_1_1Client__app.html">Client_app</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classipc_1_1session_1_1Session__base.html#a3ebdafe7e70719e6d12dd0b15ae85106">cli_app_ptr</a> () const</td></tr>
<tr class="memdesc:a3ebdafe7e70719e6d12dd0b15ae85106 inherit pub_methods_classipc_1_1session_1_1Session__base"><td class="mdescLeft">&#160;</td><td class="mdescRight">See <a class="el" href="classipc_1_1session_1_1Server__session__impl.html" title="Internal, non-movable pImpl-lite implementation of Server_session_mv class template.">Server_session_impl</a>, <a class="el" href="classipc_1_1session_1_1Client__session__impl.html" title="Internal, non-movable pImpl-lite implementation of Client_session_mv class template.">Client_session_impl</a>.  <a href="classipc_1_1session_1_1Session__base.html#a3ebdafe7e70719e6d12dd0b15ae85106">More...</a><br /></td></tr>
<tr class="separator:a3ebdafe7e70719e6d12dd0b15ae85106 inherit pub_methods_classipc_1_1session_1_1Session__base"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a09cbe99083616bae00928f8e37c8373b inherit pub_methods_classipc_1_1session_1_1Session__base"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespaceipc_1_1session.html#a6d07d9996af19e57eb42416e914110ea">Shared_name</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classipc_1_1session_1_1Session__base.html#a09cbe99083616bae00928f8e37c8373b">cur_ns_store_mutex_absolute_name</a> () const</td></tr>
<tr class="memdesc:a09cbe99083616bae00928f8e37c8373b inherit pub_methods_classipc_1_1session_1_1Session__base"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the name of the interprocess named-mutex used to control reading/writing to the file storing (written by server, read by client) the value for <a class="el" href="classipc_1_1session_1_1Session__base.html#a4d1327608d6067ed6690bd4efa323c6f" title="See Server_session_impl, Client_session_impl.">srv_namespace()</a>.  <a href="classipc_1_1session_1_1Session__base.html#a09cbe99083616bae00928f8e37c8373b">More...</a><br /></td></tr>
<tr class="separator:a09cbe99083616bae00928f8e37c8373b inherit pub_methods_classipc_1_1session_1_1Session__base"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af059faab56cdf384873f9f2aba8f79cf inherit pub_methods_classipc_1_1session_1_1Session__base"><td class="memItemLeft" align="right" valign="top">fs::path&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classipc_1_1session_1_1Session__base.html#af059faab56cdf384873f9f2aba8f79cf">cur_ns_store_absolute_path</a> () const</td></tr>
<tr class="memdesc:af059faab56cdf384873f9f2aba8f79cf inherit pub_methods_classipc_1_1session_1_1Session__base"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the absolute path to file storing (written by server, read by client) the value for <a class="el" href="classipc_1_1session_1_1Session__base.html#a4d1327608d6067ed6690bd4efa323c6f" title="See Server_session_impl, Client_session_impl.">srv_namespace()</a>.  <a href="classipc_1_1session_1_1Session__base.html#af059faab56cdf384873f9f2aba8f79cf">More...</a><br /></td></tr>
<tr class="separator:af059faab56cdf384873f9f2aba8f79cf inherit pub_methods_classipc_1_1session_1_1Session__base"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3d34c5a9c283a6b7c8ab943f344cdd28 inherit pub_methods_classipc_1_1session_1_1Session__base"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespaceipc_1_1session.html#a6d07d9996af19e57eb42416e914110ea">Shared_name</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classipc_1_1session_1_1Session__base.html#a3d34c5a9c283a6b7c8ab943f344cdd28">session_master_socket_stream_acceptor_absolute_name</a> () const</td></tr>
<tr class="memdesc:a3d34c5a9c283a6b7c8ab943f344cdd28 inherit pub_methods_classipc_1_1session_1_1Session__base"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the absolute name at which the server shall set up a <a class="el" href="classipc_1_1transport_1_1Native__socket__stream__acceptor.html" title="A server object that binds to a Shared_name and listens for incoming Native_socket_stream connect att...">transport::Native_socket_stream_acceptor</a> to which client shall <a class="el" href="classipc_1_1transport_1_1Native__socket__stream.html#a89d591db714e83dcb55a52738fed1ebb" title="To be invoked in NULL state only, it synchronously and non-blockingly attempts to connect to an oppos...">transport::Native_socket_stream::sync_connect()</a> in order to establish a PEER-state session.  <a href="classipc_1_1session_1_1Session__base.html#a3d34c5a9c283a6b7c8ab943f344cdd28">More...</a><br /></td></tr>
<tr class="separator:a3d34c5a9c283a6b7c8ab943f344cdd28 inherit pub_methods_classipc_1_1session_1_1Session__base"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-static-attribs" name="pub-static-attribs"></a>
Static Public Attributes</h2></td></tr>
<tr class="memitem:a582c808f7ea2104468e56bc135172296"><td class="memItemLeft" align="right" valign="top">static constexpr schema::ShmType&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classipc_1_1session_1_1Server__session__impl.html#a582c808f7ea2104468e56bc135172296">S_SHM_TYPE</a> = S_SHM_TYPE_OR_NONE</td></tr>
<tr class="memdesc:a582c808f7ea2104468e56bc135172296"><td class="mdescLeft">&#160;</td><td class="mdescRight">See <a class="el" href="classipc_1_1session_1_1Session__mv.html" title="Implements the Session concept when it is in PEER state.">Session_mv</a> counterpart.  <a href="classipc_1_1session_1_1Server__session__impl.html#a582c808f7ea2104468e56bc135172296">More...</a><br /></td></tr>
<tr class="separator:a582c808f7ea2104468e56bc135172296"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1ded7990451b90f29e11f8fa7ce0e80b"><td class="memItemLeft" align="right" valign="top">static constexpr bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classipc_1_1session_1_1Server__session__impl.html#a1ded7990451b90f29e11f8fa7ce0e80b">S_SHM_ENABLED</a> = <a class="el" href="classipc_1_1session_1_1Server__session__impl.html#a582c808f7ea2104468e56bc135172296">S_SHM_TYPE</a> != schema::ShmType::NONE</td></tr>
<tr class="memdesc:a1ded7990451b90f29e11f8fa7ce0e80b"><td class="mdescLeft">&#160;</td><td class="mdescRight">See <a class="el" href="classipc_1_1session_1_1Session__mv.html" title="Implements the Session concept when it is in PEER state.">Session_mv</a> counterpart.  <a href="classipc_1_1session_1_1Server__session__impl.html#a1ded7990451b90f29e11f8fa7ce0e80b">More...</a><br /></td></tr>
<tr class="separator:a1ded7990451b90f29e11f8fa7ce0e80b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a005fcbc9ee215531c03d17fcc49ef544"><td class="memItemLeft" align="right" valign="top">static constexpr bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classipc_1_1session_1_1Server__session__impl.html#a005fcbc9ee215531c03d17fcc49ef544">S_MQS_ENABLED</a> = Base::S_MQS_ENABLED</td></tr>
<tr class="memdesc:a005fcbc9ee215531c03d17fcc49ef544"><td class="mdescLeft">&#160;</td><td class="mdescRight">See <a class="el" href="classipc_1_1session_1_1Server__session__mv.html" title="Implements Session concept on the Server_app end: a Session that is emitted in almost-PEER state by l...">Server_session_mv</a> counterpart.  <a href="classipc_1_1session_1_1Server__session__impl.html#a005fcbc9ee215531c03d17fcc49ef544">More...</a><br /></td></tr>
<tr class="separator:a005fcbc9ee215531c03d17fcc49ef544"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abfa7d61030e1d40cdc0085afacb43b6c"><td class="memItemLeft" align="right" valign="top">static constexpr bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classipc_1_1session_1_1Server__session__impl.html#abfa7d61030e1d40cdc0085afacb43b6c">S_SOCKET_STREAM_ENABLED</a> = Base::S_SOCKET_STREAM_ENABLED</td></tr>
<tr class="memdesc:abfa7d61030e1d40cdc0085afacb43b6c"><td class="mdescLeft">&#160;</td><td class="mdescRight">See <a class="el" href="classipc_1_1session_1_1Server__session__mv.html" title="Implements Session concept on the Server_app end: a Session that is emitted in almost-PEER state by l...">Server_session_mv</a> counterpart.  <a href="classipc_1_1session_1_1Server__session__impl.html#abfa7d61030e1d40cdc0085afacb43b6c">More...</a><br /></td></tr>
<tr class="separator:abfa7d61030e1d40cdc0085afacb43b6c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0dc599111ce0b4b6d8cd003559e6c01c"><td class="memItemLeft" align="right" valign="top">static constexpr bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classipc_1_1session_1_1Server__session__impl.html#a0dc599111ce0b4b6d8cd003559e6c01c">S_GRACEFUL_FINISH_REQUIRED</a> = S_GRACEFUL_FINISH_REQUIRED_V</td></tr>
<tr class="memdesc:a0dc599111ce0b4b6d8cd003559e6c01c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Short-hand for template parameter knob <code>S_GRACEFUL_FINISH_REQUIRED_V</code>: see class template doc header.  <a href="classipc_1_1session_1_1Server__session__impl.html#a0dc599111ce0b4b6d8cd003559e6c01c">More...</a><br /></td></tr>
<tr class="separator:a0dc599111ce0b4b6d8cd003559e6c01c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pub_static_attribs_classipc_1_1session_1_1Session__base"><td colspan="2" onclick="javascript:toggleInherit('pub_static_attribs_classipc_1_1session_1_1Session__base')"><img src="closed.png" alt="-"/>&#160;Static Public Attributes inherited from <a class="el" href="classipc_1_1session_1_1Session__base.html">ipc::session::Session_base&lt; S_MQ_TYPE_OR_NONE, S_TRANSMIT_NATIVE_HANDLES, Mdt_payload &gt;</a></td></tr>
<tr class="memitem:a27a5731a648effb6b4b42f0312affa74 inherit pub_static_attribs_classipc_1_1session_1_1Session__base"><td class="memItemLeft" align="right" valign="top">static constexpr bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classipc_1_1session_1_1Session__base.html#a27a5731a648effb6b4b42f0312affa74">S_MQS_ENABLED</a> = S_MQ_TYPE_OR_NONE != schema::MqType::NONE</td></tr>
<tr class="memdesc:a27a5731a648effb6b4b42f0312affa74 inherit pub_static_attribs_classipc_1_1session_1_1Session__base"><td class="mdescLeft">&#160;</td><td class="mdescRight">See <a class="el" href="classipc_1_1session_1_1Session__mv.html" title="Implements the Session concept when it is in PEER state.">Session_mv</a>.  <a href="classipc_1_1session_1_1Session__base.html#a27a5731a648effb6b4b42f0312affa74">More...</a><br /></td></tr>
<tr class="separator:a27a5731a648effb6b4b42f0312affa74 inherit pub_static_attribs_classipc_1_1session_1_1Session__base"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1f7c4243c8bd55930f51a568884c8aaf inherit pub_static_attribs_classipc_1_1session_1_1Session__base"><td class="memItemLeft" align="right" valign="top">static constexpr bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classipc_1_1session_1_1Session__base.html#a1f7c4243c8bd55930f51a568884c8aaf">S_SOCKET_STREAM_ENABLED</a> = (!<a class="el" href="classipc_1_1session_1_1Session__base.html#a27a5731a648effb6b4b42f0312affa74">S_MQS_ENABLED</a>) || S_TRANSMIT_NATIVE_HANDLES</td></tr>
<tr class="memdesc:a1f7c4243c8bd55930f51a568884c8aaf inherit pub_static_attribs_classipc_1_1session_1_1Session__base"><td class="mdescLeft">&#160;</td><td class="mdescRight">See <a class="el" href="classipc_1_1session_1_1Session__mv.html" title="Implements the Session concept when it is in PEER state.">Session_mv</a>.  <a href="classipc_1_1session_1_1Session__base.html#a1f7c4243c8bd55930f51a568884c8aaf">More...</a><br /></td></tr>
<tr class="separator:a1f7c4243c8bd55930f51a568884c8aaf inherit pub_static_attribs_classipc_1_1session_1_1Session__base"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pro-types" name="pro-types"></a>
Protected Types</h2></td></tr>
<tr class="memitem:a3bc90eb872c3f4d4ff65039a4a36b166"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classipc_1_1session_1_1Server__session__impl.html#a3bc90eb872c3f4d4ff65039a4a36b166">Master_structured_channel</a> = typename <a class="el" href="classipc_1_1session_1_1Session__base.html#a26d038e14e3c0e461e76de88c4ce76c5">Base::Master_structured_channel</a></td></tr>
<tr class="memdesc:a3bc90eb872c3f4d4ff65039a4a36b166"><td class="mdescLeft">&#160;</td><td class="mdescRight">See <a class="el" href="classipc_1_1session_1_1Session__base.html" title="Internal type containing data and types common to internal types Server_session_impl and Client_sessi...">Session_base</a>.  <a href="classipc_1_1session_1_1Server__session__impl.html#a3bc90eb872c3f4d4ff65039a4a36b166">More...</a><br /></td></tr>
<tr class="separator:a3bc90eb872c3f4d4ff65039a4a36b166"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pro_types_classipc_1_1session_1_1Session__base"><td colspan="2" onclick="javascript:toggleInherit('pro_types_classipc_1_1session_1_1Session__base')"><img src="closed.png" alt="-"/>&#160;Protected Types inherited from <a class="el" href="classipc_1_1session_1_1Session__base.html">ipc::session::Session_base&lt; S_MQ_TYPE_OR_NONE, S_TRANSMIT_NATIVE_HANDLES, Mdt_payload &gt;</a></td></tr>
<tr class="memitem:a26d038e14e3c0e461e76de88c4ce76c5 inherit pro_types_classipc_1_1session_1_1Session__base"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classipc_1_1session_1_1Session__base.html#a26d038e14e3c0e461e76de88c4ce76c5">Master_structured_channel</a> = <a class="el" href="namespaceipc_1_1transport_1_1struc.html#aca041b0efd4a9ae18e10088b2ee3c052">transport::struc::Channel_via_heap</a>&lt; <a class="el" href="classipc_1_1transport_1_1Socket__stream__channel.html">transport::Socket_stream_channel</a>&lt; true &gt;, schema::detail::SessionMasterChannelMessageBody&lt; <a class="el" href="classipc_1_1session_1_1Session__base.html#a35234981ca87cc2f6b118b3e52452ea8">Mdt_payload_obj</a> &gt; &gt;</td></tr>
<tr class="memdesc:a26d038e14e3c0e461e76de88c4ce76c5 inherit pro_types_classipc_1_1session_1_1Session__base"><td class="mdescLeft">&#160;</td><td class="mdescRight">The (internally used) session master channel is a <a class="el" href="classipc_1_1transport_1_1struc_1_1Channel.html" title="Owning and wrapping a pre-connected transport::Channel peer (an endpoint of an established channel ov...">transport::struc::Channel</a> of this concrete type.  <a href="classipc_1_1session_1_1Session__base.html#a26d038e14e3c0e461e76de88c4ce76c5">More...</a><br /></td></tr>
<tr class="separator:a26d038e14e3c0e461e76de88c4ce76c5 inherit pro_types_classipc_1_1session_1_1Session__base"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af0ca2a01d7d0d92038aae56fc1cdd505 inherit pro_types_classipc_1_1session_1_1Session__base"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classipc_1_1session_1_1Session__base.html#af0ca2a01d7d0d92038aae56fc1cdd505">Master_structured_channel_ptr</a> = boost::shared_ptr&lt; <a class="el" href="classipc_1_1session_1_1Session__base.html#a26d038e14e3c0e461e76de88c4ce76c5">Master_structured_channel</a> &gt;</td></tr>
<tr class="memdesc:af0ca2a01d7d0d92038aae56fc1cdd505 inherit pro_types_classipc_1_1session_1_1Session__base"><td class="mdescLeft">&#160;</td><td class="mdescRight">Handle to <a class="el" href="classipc_1_1session_1_1Session__base.html#a26d038e14e3c0e461e76de88c4ce76c5" title="The (internally used) session master channel is a transport::struc::Channel of this concrete type.">Master_structured_channel</a>.  <a href="classipc_1_1session_1_1Session__base.html#af0ca2a01d7d0d92038aae56fc1cdd505">More...</a><br /></td></tr>
<tr class="separator:af0ca2a01d7d0d92038aae56fc1cdd505 inherit pro_types_classipc_1_1session_1_1Session__base"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae2a123b29dd044a638e94d1f294c8f28 inherit pro_types_classipc_1_1session_1_1Session__base"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classipc_1_1session_1_1Session__base.html#ae2a123b29dd044a638e94d1f294c8f28">Master_structured_channel_observer</a> = boost::weak_ptr&lt; <a class="el" href="classipc_1_1session_1_1Session__base.html#a26d038e14e3c0e461e76de88c4ce76c5">Master_structured_channel</a> &gt;</td></tr>
<tr class="memdesc:ae2a123b29dd044a638e94d1f294c8f28 inherit pro_types_classipc_1_1session_1_1Session__base"><td class="mdescLeft">&#160;</td><td class="mdescRight">Observer of <a class="el" href="classipc_1_1session_1_1Session__base.html#af0ca2a01d7d0d92038aae56fc1cdd505" title="Handle to Master_structured_channel.">Master_structured_channel_ptr</a>. See its doc header.  <a href="classipc_1_1session_1_1Session__base.html#ae2a123b29dd044a638e94d1f294c8f28">More...</a><br /></td></tr>
<tr class="separator:ae2a123b29dd044a638e94d1f294c8f28 inherit pro_types_classipc_1_1session_1_1Session__base"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3c0824a54ef32915c5c5ea76481f2409 inherit pro_types_classipc_1_1session_1_1Session__base"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classipc_1_1session_1_1Session__base.html#a3c0824a54ef32915c5c5ea76481f2409">On_passive_open_channel_func</a> = <a class="el" href="namespaceipc.html#aa455c7f045059736578ca275fc1a851f">Function</a>&lt; void(<a class="el" href="classipc_1_1session_1_1Session__base.html#a71f02a809d667c23ff8af29a96940bd1">Channel_obj</a> &amp;&amp;new_channel, <a class="el" href="classipc_1_1session_1_1Session__base.html#ace4dab42adec6354cc66081dd218ac71">Mdt_reader_ptr</a> &amp;&amp;new_channel_mdt)&gt;</td></tr>
<tr class="memdesc:a3c0824a54ef32915c5c5ea76481f2409 inherit pro_types_classipc_1_1session_1_1Session__base"><td class="mdescLeft">&#160;</td><td class="mdescRight">Concrete function type for the on-passive-open handler (if any), used for storage.  <a href="classipc_1_1session_1_1Session__base.html#a3c0824a54ef32915c5c5ea76481f2409">More...</a><br /></td></tr>
<tr class="separator:a3c0824a54ef32915c5c5ea76481f2409 inherit pro_types_classipc_1_1session_1_1Session__base"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pro-methods" name="pro-methods"></a>
Protected Member Functions</h2></td></tr>
<tr class="memitem:a2276a6fd556861a9e0856360fde58158"><td class="memTemplParams" colspan="2">template&lt;typename Task &gt; </td></tr>
<tr class="memitem:a2276a6fd556861a9e0856360fde58158"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classipc_1_1session_1_1Server__session__impl.html#a2276a6fd556861a9e0856360fde58158">sub_class_set_deinit_func</a> (Task &amp;&amp;task)</td></tr>
<tr class="memdesc:a2276a6fd556861a9e0856360fde58158"><td class="mdescLeft">&#160;</td><td class="mdescRight">Utility for sub-classes: ensures that <code>task()</code> is invoked near the end of <code>*this</code> dtor's execution, from thread U, after thread W is joined, and any <a class="el" href="classipc_1_1session_1_1Server__session__impl.html#aee35d521d9997d48f6b5565730e60e93" title="For use by internal user Session_server: See Server_session_mv counterpart.">async_accept_log_in()</a> on-done handler has fired with operation-aborted code.  <a href="classipc_1_1session_1_1Server__session__impl.html#a2276a6fd556861a9e0856360fde58158">More...</a><br /></td></tr>
<tr class="separator:a2276a6fd556861a9e0856360fde58158"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a149a11c639d26b8a21279724079f6c2a"><td class="memItemLeft" align="right" valign="top">flow::async::Single_thread_task_loop *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classipc_1_1session_1_1Server__session__impl.html#a149a11c639d26b8a21279724079f6c2a">async_worker</a> ()</td></tr>
<tr class="memdesc:a149a11c639d26b8a21279724079f6c2a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Utility for sub-classes: provides ability to schedule or post tasks onto thread W.  <a href="classipc_1_1session_1_1Server__session__impl.html#a149a11c639d26b8a21279724079f6c2a">More...</a><br /></td></tr>
<tr class="separator:a149a11c639d26b8a21279724079f6c2a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a14d68714c197ba58b4cb485262fb9d51"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classipc_1_1session_1_1Server__session__impl.html#a3bc90eb872c3f4d4ff65039a4a36b166">Master_structured_channel</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classipc_1_1session_1_1Server__session__impl.html#a14d68714c197ba58b4cb485262fb9d51">master_channel</a> ()</td></tr>
<tr class="memdesc:a14d68714c197ba58b4cb485262fb9d51"><td class="mdescLeft">&#160;</td><td class="mdescRight">Utility for sub-classes: provides ability to do work on the session master channel after our <a class="el" href="classipc_1_1session_1_1Server__session__impl.html#aee35d521d9997d48f6b5565730e60e93" title="For use by internal user Session_server: See Server_session_mv counterpart.">async_accept_log_in()</a> succeeds, but before the sub-classed wrapper of its on-done handler succeeds.  <a href="classipc_1_1session_1_1Server__session__impl.html#a14d68714c197ba58b4cb485262fb9d51">More...</a><br /></td></tr>
<tr class="separator:a14d68714c197ba58b4cb485262fb9d51"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaa570a2ceb242370eeccca85d806fbbf"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classipc_1_1session_1_1Server__session__impl.html#a3bc90eb872c3f4d4ff65039a4a36b166">Master_structured_channel</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classipc_1_1session_1_1Server__session__impl.html#aaa570a2ceb242370eeccca85d806fbbf">master_channel_const</a> () const</td></tr>
<tr class="memdesc:aaa570a2ceb242370eeccca85d806fbbf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Analogous to <a class="el" href="classipc_1_1session_1_1Client__session__impl.html#a5f156b23ce19cd878c3e83330e63f56f" title="Utility for sub-classes: provides ability to immutably query the session master channel,...">Client_session_impl::master_channel_const()</a>.  <a href="classipc_1_1session_1_1Server__session__impl.html#aaa570a2ceb242370eeccca85d806fbbf">More...</a><br /></td></tr>
<tr class="separator:aaa570a2ceb242370eeccca85d806fbbf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a28503a7c6622aacc7e08d4904da10da3"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classipc_1_1session_1_1Server__session__impl.html#a28503a7c6622aacc7e08d4904da10da3">dtor_async_worker_stop</a> ()</td></tr>
<tr class="memdesc:a28503a7c6622aacc7e08d4904da10da3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Analogous to <a class="el" href="classipc_1_1session_1_1Client__session__impl.html#afb09c3a23b7e63938b9a494cec6e769b" title="Synchronously stops async_worker() loop, the post-condition being that thread W has been joined; no t...">Client_session_impl::dtor_async_worker_stop()</a>. See that doc header.  <a href="classipc_1_1session_1_1Server__session__impl.html#a28503a7c6622aacc7e08d4904da10da3">More...</a><br /></td></tr>
<tr class="separator:a28503a7c6622aacc7e08d4904da10da3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pro_methods_classipc_1_1session_1_1Session__base"><td colspan="2" onclick="javascript:toggleInherit('pro_methods_classipc_1_1session_1_1Session__base')"><img src="closed.png" alt="-"/>&#160;Protected Member Functions inherited from <a class="el" href="classipc_1_1session_1_1Session__base.html">ipc::session::Session_base&lt; S_MQ_TYPE_OR_NONE, S_TRANSMIT_NATIVE_HANDLES, Mdt_payload &gt;</a></td></tr>
<tr class="memitem:aab2db8b2cdb3d8189c1cc497aed7b2b1 inherit pro_methods_classipc_1_1session_1_1Session__base"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classipc_1_1session_1_1Session__base.html#aab2db8b2cdb3d8189c1cc497aed7b2b1">Session_base</a> (const <a class="el" href="structipc_1_1session_1_1Client__app.html">Client_app</a> &amp;cli_app_ref, const <a class="el" href="structipc_1_1session_1_1Server__app.html">Server_app</a> &amp;srv_app_ref, flow::async::Task_asio_err &amp;&amp;on_err_func, <a class="el" href="classipc_1_1session_1_1Session__base.html#a3c0824a54ef32915c5c5ea76481f2409">On_passive_open_channel_func</a> &amp;&amp;on_passive_open_channel_func_or_empty_arg)</td></tr>
<tr class="memdesc:aab2db8b2cdb3d8189c1cc497aed7b2b1 inherit pro_methods_classipc_1_1session_1_1Session__base"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructs: <a class="el" href="classipc_1_1session_1_1Client__session__impl.html" title="Internal, non-movable pImpl-lite implementation of Client_session_mv class template.">Client_session_impl</a> form (the user is the one constructing the object, though in NULL state).  <a href="classipc_1_1session_1_1Session__base.html#aab2db8b2cdb3d8189c1cc497aed7b2b1">More...</a><br /></td></tr>
<tr class="separator:aab2db8b2cdb3d8189c1cc497aed7b2b1 inherit pro_methods_classipc_1_1session_1_1Session__base"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8d323ca75006777b3fc929bd0720f7df inherit pro_methods_classipc_1_1session_1_1Session__base"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classipc_1_1session_1_1Session__base.html#a8d323ca75006777b3fc929bd0720f7df">Session_base</a> (const <a class="el" href="structipc_1_1session_1_1Server__app.html">Server_app</a> &amp;srv_app_ref)</td></tr>
<tr class="memdesc:a8d323ca75006777b3fc929bd0720f7df inherit pro_methods_classipc_1_1session_1_1Session__base"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructs: <a class="el" href="classipc_1_1session_1_1Server__session__impl.html" title="Internal, non-movable pImpl-lite implementation of Server_session_mv class template.">Server_session_impl</a> form (<a class="el" href="classipc_1_1session_1_1Session__server.html" title="To be instantiated typically once in a given process, an object of this type asynchronously listens f...">Session_server</a> is the one constructing the object, though in NULL state, before log-in has completed, but after the socket-stream connection has been established).  <a href="classipc_1_1session_1_1Session__base.html#a8d323ca75006777b3fc929bd0720f7df">More...</a><br /></td></tr>
<tr class="separator:a8d323ca75006777b3fc929bd0720f7df inherit pro_methods_classipc_1_1session_1_1Session__base"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a28825fcdeaf1249a7bf810a3b2ca7c38 inherit pro_methods_classipc_1_1session_1_1Session__base"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classipc_1_1session_1_1Session__base.html#a28825fcdeaf1249a7bf810a3b2ca7c38">set_srv_namespace</a> (<a class="el" href="namespaceipc_1_1session.html#a6d07d9996af19e57eb42416e914110ea">Shared_name</a> &amp;&amp;srv_namespace_new)</td></tr>
<tr class="memdesc:a28825fcdeaf1249a7bf810a3b2ca7c38 inherit pro_methods_classipc_1_1session_1_1Session__base"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets <a class="el" href="classipc_1_1session_1_1Session__base.html#a4d1327608d6067ed6690bd4efa323c6f" title="See Server_session_impl, Client_session_impl.">srv_namespace()</a> (do not call if already set).  <a href="classipc_1_1session_1_1Session__base.html#a28825fcdeaf1249a7bf810a3b2ca7c38">More...</a><br /></td></tr>
<tr class="separator:a28825fcdeaf1249a7bf810a3b2ca7c38 inherit pro_methods_classipc_1_1session_1_1Session__base"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8cc7a4faa098e0f71c737f44c34d593c inherit pro_methods_classipc_1_1session_1_1Session__base"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classipc_1_1session_1_1Session__base.html#a8cc7a4faa098e0f71c737f44c34d593c">set_cli_namespace</a> (<a class="el" href="namespaceipc_1_1session.html#a6d07d9996af19e57eb42416e914110ea">Shared_name</a> &amp;&amp;cli_namespace_new)</td></tr>
<tr class="memdesc:a8cc7a4faa098e0f71c737f44c34d593c inherit pro_methods_classipc_1_1session_1_1Session__base"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets <a class="el" href="classipc_1_1session_1_1Session__base.html#abd1e814b3b640f4bdaa2553352405f26" title="See Server_session_impl, Client_session_impl.">cli_namespace()</a> (do not call if already set).  <a href="classipc_1_1session_1_1Session__base.html#a8cc7a4faa098e0f71c737f44c34d593c">More...</a><br /></td></tr>
<tr class="separator:a8cc7a4faa098e0f71c737f44c34d593c inherit pro_methods_classipc_1_1session_1_1Session__base"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a60a081ce0f85651202d23b4d543d093c inherit pro_methods_classipc_1_1session_1_1Session__base"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classipc_1_1session_1_1Session__base.html#a60a081ce0f85651202d23b4d543d093c">set_cli_app_ptr</a> (const <a class="el" href="structipc_1_1session_1_1Client__app.html">Client_app</a> *cli_app_ptr_new)</td></tr>
<tr class="memdesc:a60a081ce0f85651202d23b4d543d093c inherit pro_methods_classipc_1_1session_1_1Session__base"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets <a class="el" href="classipc_1_1session_1_1Session__base.html#a3ebdafe7e70719e6d12dd0b15ae85106" title="See Server_session_impl, Client_session_impl.">cli_app_ptr()</a> (do not call if already set).  <a href="classipc_1_1session_1_1Session__base.html#a60a081ce0f85651202d23b4d543d093c">More...</a><br /></td></tr>
<tr class="separator:a60a081ce0f85651202d23b4d543d093c inherit pro_methods_classipc_1_1session_1_1Session__base"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3be1a385c905404621b58c23332b0b96 inherit pro_methods_classipc_1_1session_1_1Session__base"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classipc_1_1session_1_1Session__base.html#a3be1a385c905404621b58c23332b0b96">set_on_passive_open_channel_func</a> (<a class="el" href="classipc_1_1session_1_1Session__base.html#a3c0824a54ef32915c5c5ea76481f2409">On_passive_open_channel_func</a> &amp;&amp;on_passive_open_channel_func)</td></tr>
<tr class="memdesc:a3be1a385c905404621b58c23332b0b96 inherit pro_methods_classipc_1_1session_1_1Session__base"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets <a class="el" href="classipc_1_1session_1_1Session__base.html#a21b146b02d257d95f4aaeaca12b8d320" title="The on-passive-open handler (may be empty even in final state, meaning user wants passive-opens disab...">on_passive_open_channel_func_or_empty()</a> (do not call if already set; do not call if user intends for passive-opens to be disabled on this side).  <a href="classipc_1_1session_1_1Session__base.html#a3be1a385c905404621b58c23332b0b96">More...</a><br /></td></tr>
<tr class="separator:a3be1a385c905404621b58c23332b0b96 inherit pro_methods_classipc_1_1session_1_1Session__base"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae769a82bdec0d16702111ad06716faae inherit pro_methods_classipc_1_1session_1_1Session__base"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classipc_1_1session_1_1Session__base.html#ae769a82bdec0d16702111ad06716faae">set_on_err_func</a> (flow::async::Task_asio_err &amp;&amp;on_err_func_arg)</td></tr>
<tr class="memdesc:ae769a82bdec0d16702111ad06716faae inherit pro_methods_classipc_1_1session_1_1Session__base"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets on_err_func() (do not call if already set).  <a href="classipc_1_1session_1_1Session__base.html#ae769a82bdec0d16702111ad06716faae">More...</a><br /></td></tr>
<tr class="separator:ae769a82bdec0d16702111ad06716faae inherit pro_methods_classipc_1_1session_1_1Session__base"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aca82817beaac36d0006c44012f9fef03 inherit pro_methods_classipc_1_1session_1_1Session__base"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classipc_1_1session_1_1Session__base.html#aca82817beaac36d0006c44012f9fef03">on_err_func_set</a> () const</td></tr>
<tr class="memdesc:aca82817beaac36d0006c44012f9fef03 inherit pro_methods_classipc_1_1session_1_1Session__base"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns <code>true</code> if and only if <a class="el" href="classipc_1_1session_1_1Session__base.html#ae769a82bdec0d16702111ad06716faae" title="Sets on_err_func() (do not call if already set).">set_on_err_func()</a> has been called.  <a href="classipc_1_1session_1_1Session__base.html#aca82817beaac36d0006c44012f9fef03">More...</a><br /></td></tr>
<tr class="separator:aca82817beaac36d0006c44012f9fef03 inherit pro_methods_classipc_1_1session_1_1Session__base"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a21b146b02d257d95f4aaeaca12b8d320 inherit pro_methods_classipc_1_1session_1_1Session__base"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classipc_1_1session_1_1Session__base.html#a3c0824a54ef32915c5c5ea76481f2409">On_passive_open_channel_func</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classipc_1_1session_1_1Session__base.html#a21b146b02d257d95f4aaeaca12b8d320">on_passive_open_channel_func_or_empty</a> () const</td></tr>
<tr class="memdesc:a21b146b02d257d95f4aaeaca12b8d320 inherit pro_methods_classipc_1_1session_1_1Session__base"><td class="mdescLeft">&#160;</td><td class="mdescRight">The on-passive-open handler (may be empty even in final state, meaning user wants passive-opens disabled on this side).  <a href="classipc_1_1session_1_1Session__base.html#a21b146b02d257d95f4aaeaca12b8d320">More...</a><br /></td></tr>
<tr class="separator:a21b146b02d257d95f4aaeaca12b8d320 inherit pro_methods_classipc_1_1session_1_1Session__base"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7f9e67dccbab4f3191734c2834bafb63 inherit pro_methods_classipc_1_1session_1_1Session__base"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classipc_1_1session_1_1Session__base.html#a7f9e67dccbab4f3191734c2834bafb63">hose</a> (const <a class="el" href="namespaceipc.html#aa3192e586cc45d3e7c22463bf2760f89">Error_code</a> &amp;err_code)</td></tr>
<tr class="memdesc:a7f9e67dccbab4f3191734c2834bafb63 inherit pro_methods_classipc_1_1session_1_1Session__base"><td class="mdescLeft">&#160;</td><td class="mdescRight">Marks this session as hosed for (truthy) reason <code>err_code</code>; and <em>synchronously</em> invokes on-error handler; only invoke if not already <a class="el" href="classipc_1_1session_1_1Session__base.html#a398f3e6a30b3fae8e110af9fd1ff75e3" title="Returns true if and only if hose() has been called.">hosed()</a>.  <a href="classipc_1_1session_1_1Session__base.html#a7f9e67dccbab4f3191734c2834bafb63">More...</a><br /></td></tr>
<tr class="separator:a7f9e67dccbab4f3191734c2834bafb63 inherit pro_methods_classipc_1_1session_1_1Session__base"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a398f3e6a30b3fae8e110af9fd1ff75e3 inherit pro_methods_classipc_1_1session_1_1Session__base"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classipc_1_1session_1_1Session__base.html#a398f3e6a30b3fae8e110af9fd1ff75e3">hosed</a> () const</td></tr>
<tr class="memdesc:a398f3e6a30b3fae8e110af9fd1ff75e3 inherit pro_methods_classipc_1_1session_1_1Session__base"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns <code>true</code> if and only if <a class="el" href="classipc_1_1session_1_1Session__base.html#a7f9e67dccbab4f3191734c2834bafb63" title="Marks this session as hosed for (truthy) reason err_code; and synchronously invokes on-error handler;...">hose()</a> has been called.  <a href="classipc_1_1session_1_1Session__base.html#a398f3e6a30b3fae8e110af9fd1ff75e3">More...</a><br /></td></tr>
<tr class="separator:a398f3e6a30b3fae8e110af9fd1ff75e3 inherit pro_methods_classipc_1_1session_1_1Session__base"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pri-types" name="pri-types"></a>
Private Types</h2></td></tr>
<tr class="memitem:aa72ad11c33a4d11d5e3f0480ce0a6ff1"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classipc_1_1session_1_1Server__session__impl.html#aa72ad11c33a4d11d5e3f0480ce0a6ff1">Persistent_mq_handle_from_cfg</a> = typename <a class="el" href="classipc_1_1session_1_1Session__base.html#a848c0f5247644ada0f8b0ab816eedda8">Base::Persistent_mq_handle_from_cfg</a></td></tr>
<tr class="memdesc:aa72ad11c33a4d11d5e3f0480ce0a6ff1"><td class="mdescLeft">&#160;</td><td class="mdescRight">See <a class="el" href="classipc_1_1session_1_1Session__base.html" title="Internal type containing data and types common to internal types Server_session_impl and Client_sessi...">Session_base</a>.  <a href="classipc_1_1session_1_1Server__session__impl.html#aa72ad11c33a4d11d5e3f0480ce0a6ff1">More...</a><br /></td></tr>
<tr class="separator:aa72ad11c33a4d11d5e3f0480ce0a6ff1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af8013f82c2441d07bc82eda7cc3ad835"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classipc_1_1session_1_1Server__session__impl.html#af8013f82c2441d07bc82eda7cc3ad835">On_passive_open_channel_func</a> = typename <a class="el" href="classipc_1_1session_1_1Session__base.html#a3c0824a54ef32915c5c5ea76481f2409">Base::On_passive_open_channel_func</a></td></tr>
<tr class="memdesc:af8013f82c2441d07bc82eda7cc3ad835"><td class="mdescLeft">&#160;</td><td class="mdescRight">See <a class="el" href="classipc_1_1session_1_1Session__base.html" title="Internal type containing data and types common to internal types Server_session_impl and Client_sessi...">Session_base</a>.  <a href="classipc_1_1session_1_1Server__session__impl.html#af8013f82c2441d07bc82eda7cc3ad835">More...</a><br /></td></tr>
<tr class="separator:af8013f82c2441d07bc82eda7cc3ad835"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab6cfad1c0be9815dc5411cd20c131213"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classipc_1_1session_1_1Server__session__impl.html#ab6cfad1c0be9815dc5411cd20c131213">Master_structured_channel_ptr</a> = typename <a class="el" href="classipc_1_1session_1_1Session__base.html#af0ca2a01d7d0d92038aae56fc1cdd505">Base::Master_structured_channel_ptr</a></td></tr>
<tr class="memdesc:ab6cfad1c0be9815dc5411cd20c131213"><td class="mdescLeft">&#160;</td><td class="mdescRight">See <a class="el" href="classipc_1_1session_1_1Session__base.html" title="Internal type containing data and types common to internal types Server_session_impl and Client_sessi...">Session_base</a>.  <a href="classipc_1_1session_1_1Server__session__impl.html#ab6cfad1c0be9815dc5411cd20c131213">More...</a><br /></td></tr>
<tr class="separator:ab6cfad1c0be9815dc5411cd20c131213"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ade0880c766185ca00d12c908c3ddd3ed"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classipc_1_1session_1_1Server__session__impl.html#ade0880c766185ca00d12c908c3ddd3ed">Open_channel_req_ptr</a> = boost::shared_ptr&lt; <a class="el" href="structipc_1_1session_1_1Server__session__impl_1_1Open__channel__req.html">Open_channel_req</a> &gt;</td></tr>
<tr class="memdesc:ade0880c766185ca00d12c908c3ddd3ed"><td class="mdescLeft">&#160;</td><td class="mdescRight">Short-hand for ref-counted pointer to <a class="el" href="structipc_1_1session_1_1Server__session__impl_1_1Open__channel__req.html" title="An open-channel request out-message.">Open_channel_req</a>.  <a href="classipc_1_1session_1_1Server__session__impl.html#ade0880c766185ca00d12c908c3ddd3ed">More...</a><br /></td></tr>
<tr class="separator:ade0880c766185ca00d12c908c3ddd3ed"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pri-methods" name="pri-methods"></a>
Private Member Functions</h2></td></tr>
<tr class="memitem:ad39cb95f2e546cf5be927dfc295306c1"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classipc_1_1session_1_1Server__session__impl.html#ad39cb95f2e546cf5be927dfc295306c1">init_handlers_impl</a> (flow::async::Task_asio_err &amp;&amp;on_err_func_arg, <a class="el" href="classipc_1_1session_1_1Server__session__impl.html#af8013f82c2441d07bc82eda7cc3ad835">On_passive_open_channel_func</a> &amp;&amp;on_passive_open_channel_func_or_empty_arg)</td></tr>
<tr class="memdesc:ad39cb95f2e546cf5be927dfc295306c1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Core of both <a class="el" href="classipc_1_1session_1_1Server__session__impl.html#ac93040ccdaf5a261a053a8b55bd2e14e" title="See Server_session_mv counterpart.">init_handlers()</a> overloads, to be invoked in thread W.  <a href="classipc_1_1session_1_1Server__session__impl.html#ad39cb95f2e546cf5be927dfc295306c1">More...</a><br /></td></tr>
<tr class="separator:ad39cb95f2e546cf5be927dfc295306c1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae33e5c8ca6904844689e78ee764bc2da"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classipc_1_1session_1_1Server__session__impl.html#ae33e5c8ca6904844689e78ee764bc2da">handlers_are_set</a> () const</td></tr>
<tr class="memdesc:ae33e5c8ca6904844689e78ee764bc2da"><td class="mdescLeft">&#160;</td><td class="mdescRight">In thread W, returns whether <a class="el" href="classipc_1_1session_1_1Server__session__impl.html#ad39cb95f2e546cf5be927dfc295306c1" title="Core of both init_handlers() overloads, to be invoked in thread W.">init_handlers_impl()</a> has yet executed.  <a href="classipc_1_1session_1_1Server__session__impl.html#ae33e5c8ca6904844689e78ee764bc2da">More...</a><br /></td></tr>
<tr class="separator:ae33e5c8ca6904844689e78ee764bc2da"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeccf8c9a6774d25bd4274962d69fc0e9"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classipc_1_1session_1_1Server__session__impl.html#aeccf8c9a6774d25bd4274962d69fc0e9">on_master_channel_error</a> (const <a class="el" href="namespaceipc.html#aa3192e586cc45d3e7c22463bf2760f89">Error_code</a> &amp;err_code)</td></tr>
<tr class="memdesc:aeccf8c9a6774d25bd4274962d69fc0e9"><td class="mdescLeft">&#160;</td><td class="mdescRight">In thread W, handler for <a class="el" href="classipc_1_1session_1_1Server__session__impl.html#a81eb6769bc75d900bb3c442047249503" title="The session master channel.">m_master_channel</a> indicating incoming-direction channel-hosing error.  <a href="classipc_1_1session_1_1Server__session__impl.html#aeccf8c9a6774d25bd4274962d69fc0e9">More...</a><br /></td></tr>
<tr class="separator:aeccf8c9a6774d25bd4274962d69fc0e9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a804c629b2da8898376f071db499a2173"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classipc_1_1session_1_1Server__session__impl.html#a804c629b2da8898376f071db499a2173">on_master_channel_open_channel_req</a> (typename Master_structured_channel::Msg_in_ptr &amp;&amp;open_channel_req)</td></tr>
<tr class="memdesc:a804c629b2da8898376f071db499a2173"><td class="mdescLeft">&#160;</td><td class="mdescRight">In thread W, handler for <a class="el" href="classipc_1_1session_1_1Server__session__impl.html#a81eb6769bc75d900bb3c442047249503" title="The session master channel.">m_master_channel</a> receiving a passive-open (a/k/a open-channel-to-server) request.  <a href="classipc_1_1session_1_1Server__session__impl.html#a804c629b2da8898376f071db499a2173">More...</a><br /></td></tr>
<tr class="separator:a804c629b2da8898376f071db499a2173"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6f756d12f9e2b2cc3269564ba49bb354"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classipc_1_1session_1_1Server__session__impl.html#a6f756d12f9e2b2cc3269564ba49bb354">create_channel_and_resources</a> (<a class="el" href="namespaceipc_1_1session.html#a6d07d9996af19e57eb42416e914110ea">Shared_name</a> *mq_name_c2s_or_none_ptr, <a class="el" href="namespaceipc_1_1session.html#a6d07d9996af19e57eb42416e914110ea">Shared_name</a> *mq_name_s2c_or_none_ptr, <a class="el" href="structipc_1_1util_1_1Native__handle.html">util::Native_handle</a> *remote_hndl_or_null_ptr, <a class="el" href="classipc_1_1session_1_1Server__session__impl.html#a7c969c3a1007f8e4ba3ad1c1acd6c290">Channel_obj</a> *opened_channel_ptr, bool active_else_passive)</td></tr>
<tr class="memdesc:a6f756d12f9e2b2cc3269564ba49bb354"><td class="mdescLeft">&#160;</td><td class="mdescRight">In thread W acquires the needed shared sources (MQs and/or <code>Native_handle</code> pair as of this writing) and creates local <a class="el" href="classipc_1_1session_1_1Server__session__impl.html#a7c969c3a1007f8e4ba3ad1c1acd6c290" title="See Server_session_mv counterpart.">Channel_obj</a> to emit to the user thus completing the channel-open on this side.  <a href="classipc_1_1session_1_1Server__session__impl.html#a6f756d12f9e2b2cc3269564ba49bb354">More...</a><br /></td></tr>
<tr class="separator:a6f756d12f9e2b2cc3269564ba49bb354"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a84d54a57d3e06c064cde737d1f4be472"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classipc_1_1session_1_1Server__session__impl.html#a84d54a57d3e06c064cde737d1f4be472">make_channel_mqs</a> (<a class="el" href="classipc_1_1session_1_1Server__session__impl.html#aa72ad11c33a4d11d5e3f0480ce0a6ff1">Persistent_mq_handle_from_cfg</a> *mq_c2s, <a class="el" href="classipc_1_1session_1_1Server__session__impl.html#aa72ad11c33a4d11d5e3f0480ce0a6ff1">Persistent_mq_handle_from_cfg</a> *mq_s2c, <a class="el" href="namespaceipc_1_1session.html#a6d07d9996af19e57eb42416e914110ea">Shared_name</a> *mq_name_c2s, <a class="el" href="namespaceipc_1_1session.html#a6d07d9996af19e57eb42416e914110ea">Shared_name</a> *mq_name_s2c, <a class="el" href="namespaceipc.html#aa3192e586cc45d3e7c22463bf2760f89">Error_code</a> *err_code)</td></tr>
<tr class="memdesc:a84d54a57d3e06c064cde737d1f4be472"><td class="mdescLeft">&#160;</td><td class="mdescRight">Helper for <a class="el" href="classipc_1_1session_1_1Server__session__impl.html#a6f756d12f9e2b2cc3269564ba49bb354" title="In thread W acquires the needed shared sources (MQs and/or Native_handle pair as of this writing) and...">create_channel_and_resources()</a>, invoked and compiled if and only if <a class="el" href="classipc_1_1session_1_1Server__session__impl.html#a005fcbc9ee215531c03d17fcc49ef544" title="See Server_session_mv counterpart.">S_MQS_ENABLED</a>, that <em>creates</em> the underlying client-&gt;server and server-&gt;client MQs and local handles thereto, and outputs these things via out-args.  <a href="classipc_1_1session_1_1Server__session__impl.html#a84d54a57d3e06c064cde737d1f4be472">More...</a><br /></td></tr>
<tr class="separator:a84d54a57d3e06c064cde737d1f4be472"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pri-attribs" name="pri-attribs"></a>
Private Attributes</h2></td></tr>
<tr class="memitem:aeca3e83ea5e99271ba928550ea4fb2d4"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classipc_1_1transport_1_1Protocol__negotiator.html">transport::Protocol_negotiator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classipc_1_1session_1_1Server__session__impl.html#aeca3e83ea5e99271ba928550ea4fb2d4">m_protocol_negotiator</a></td></tr>
<tr class="memdesc:aeca3e83ea5e99271ba928550ea4fb2d4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Handles the protocol negotiation at the start of the pipe, as pertains to algorithms perpetuated by the vanilla <a class="el" href="namespaceipc_1_1session.html" title="Flow-IPC module providing the broad lifecycle and shared-resource organization  via the session conc...">ipc::session</a> <code><a class="el" href="classipc_1_1session_1_1Session.html" title="A documentation-only concept defining the local side of an IPC conversation (session) with another en...">Session</a></code> hierarchy.  <a href="classipc_1_1session_1_1Server__session__impl.html#aeca3e83ea5e99271ba928550ea4fb2d4">More...</a><br /></td></tr>
<tr class="separator:aeca3e83ea5e99271ba928550ea4fb2d4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a891c082930a837694606aff30c7026ed"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classipc_1_1transport_1_1Protocol__negotiator.html">transport::Protocol_negotiator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classipc_1_1session_1_1Server__session__impl.html#a891c082930a837694606aff30c7026ed">m_protocol_negotiator_aux</a></td></tr>
<tr class="memdesc:a891c082930a837694606aff30c7026ed"><td class="mdescLeft">&#160;</td><td class="mdescRight">Analogous to <a class="el" href="classipc_1_1session_1_1Server__session__impl.html#aeca3e83ea5e99271ba928550ea4fb2d4" title="Handles the protocol negotiation at the start of the pipe, as pertains to algorithms perpetuated by t...">m_protocol_negotiator</a> but pertains to algorithms perpetuated by (if relevant) non-vanilla <a class="el" href="namespaceipc_1_1session.html" title="Flow-IPC module providing the broad lifecycle and shared-resource organization  via the session conc...">ipc::session</a> <code><a class="el" href="classipc_1_1session_1_1Session.html" title="A documentation-only concept defining the local side of an IPC conversation (session) with another en...">Session</a></code> hierarchy implemented on top of our vanilla <a class="el" href="namespaceipc_1_1session.html" title="Flow-IPC module providing the broad lifecycle and shared-resource organization  via the session conc...">ipc::session</a> <code><a class="el" href="classipc_1_1session_1_1Session.html" title="A documentation-only concept defining the local side of an IPC conversation (session) with another en...">Session</a></code> hierarchy.  <a href="classipc_1_1session_1_1Server__session__impl.html#a891c082930a837694606aff30c7026ed">More...</a><br /></td></tr>
<tr class="separator:a891c082930a837694606aff30c7026ed"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a59236329cf8e0f75c9ef628def1b97a7"><td class="memItemLeft" align="right" valign="top">flow::async::Task_asio_err&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classipc_1_1session_1_1Server__session__impl.html#a59236329cf8e0f75c9ef628def1b97a7">m_log_in_on_done_func</a></td></tr>
<tr class="memdesc:a59236329cf8e0f75c9ef628def1b97a7"><td class="mdescLeft">&#160;</td><td class="mdescRight">The <code>on_done_func</code> argument to <a class="el" href="classipc_1_1session_1_1Server__session__impl.html#aee35d521d9997d48f6b5565730e60e93" title="For use by internal user Session_server: See Server_session_mv counterpart.">async_accept_log_in()</a>; <code>.empty()</code> except while the (at most one, ever) <a class="el" href="classipc_1_1session_1_1Server__session__impl.html#aee35d521d9997d48f6b5565730e60e93" title="For use by internal user Session_server: See Server_session_mv counterpart.">async_accept_log_in()</a> is outstanding.  <a href="classipc_1_1session_1_1Server__session__impl.html#a59236329cf8e0f75c9ef628def1b97a7">More...</a><br /></td></tr>
<tr class="separator:a59236329cf8e0f75c9ef628def1b97a7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9be157fe8791e7be2dd43bd06480d3eb"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classipc_1_1transport_1_1sync__io_1_1Native__socket__stream.html">transport::sync_io::Native_socket_stream</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classipc_1_1session_1_1Server__session__impl.html#a9be157fe8791e7be2dd43bd06480d3eb">m_master_sock_stm</a></td></tr>
<tr class="memdesc:a9be157fe8791e7be2dd43bd06480d3eb"><td class="mdescLeft">&#160;</td><td class="mdescRight">The pre-connected (PEER-state) socket stream peer; is non-as-if-default-cted only up to <a class="el" href="classipc_1_1session_1_1Server__session__impl.html#aee35d521d9997d48f6b5565730e60e93" title="For use by internal user Session_server: See Server_session_mv counterpart.">async_accept_log_in()</a>, at which point it is moved-to <a class="el" href="classipc_1_1session_1_1Server__session__impl.html#a81eb6769bc75d900bb3c442047249503" title="The session master channel.">m_master_channel</a>.  <a href="classipc_1_1session_1_1Server__session__impl.html#a9be157fe8791e7be2dd43bd06480d3eb">More...</a><br /></td></tr>
<tr class="separator:a9be157fe8791e7be2dd43bd06480d3eb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad9f6932719c1565191da73bfa4a3923f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespaceipc.html#aa3192e586cc45d3e7c22463bf2760f89">Error_code</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classipc_1_1session_1_1Server__session__impl.html#ad9f6932719c1565191da73bfa4a3923f">m_pre_init_err_code</a></td></tr>
<tr class="memdesc:ad9f6932719c1565191da73bfa4a3923f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Unused/falsy except when in almost-PEER state (past successful <a class="el" href="classipc_1_1session_1_1Server__session__impl.html#aee35d521d9997d48f6b5565730e60e93" title="For use by internal user Session_server: See Server_session_mv counterpart.">async_accept_log_in()</a>, before <a class="el" href="classipc_1_1session_1_1Server__session__impl.html#ac93040ccdaf5a261a053a8b55bd2e14e" title="See Server_session_mv counterpart.">init_handlers()</a> invoked by user), and <a class="el" href="classipc_1_1session_1_1Server__session__impl.html#a81eb6769bc75d900bb3c442047249503" title="The session master channel.">m_master_channel</a> reports incoming-direction error.  <a href="classipc_1_1session_1_1Server__session__impl.html#ad9f6932719c1565191da73bfa4a3923f">More...</a><br /></td></tr>
<tr class="separator:ad9f6932719c1565191da73bfa4a3923f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a869571c6ad3555df2396d561768b3f79"><td class="memItemLeft" align="right" valign="top">unsigned int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classipc_1_1session_1_1Server__session__impl.html#a869571c6ad3555df2396d561768b3f79">m_last_passively_opened_channel_id</a></td></tr>
<tr class="memdesc:a869571c6ad3555df2396d561768b3f79"><td class="mdescLeft">&#160;</td><td class="mdescRight">Identical to <a class="el" href="classipc_1_1session_1_1Client__session__impl.html#a89d1ce46faa61df455b6f186eb892711" title="A-la m_last_actively_opened_channel_id but for passively-opened channels (on_master_channel_open_chan...">Client_session_impl::m_last_passively_opened_channel_id</a>.  <a href="classipc_1_1session_1_1Server__session__impl.html#a869571c6ad3555df2396d561768b3f79">More...</a><br /></td></tr>
<tr class="separator:a869571c6ad3555df2396d561768b3f79"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6677dde04bab0c72881848a9b72a8227"><td class="memItemLeft" align="right" valign="top">unsigned int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classipc_1_1session_1_1Server__session__impl.html#a6677dde04bab0c72881848a9b72a8227">m_last_actively_opened_channel_id</a></td></tr>
<tr class="memdesc:a6677dde04bab0c72881848a9b72a8227"><td class="mdescLeft">&#160;</td><td class="mdescRight">Identical to <a class="el" href="classipc_1_1session_1_1Client__session__impl.html#ade1b57a26147ececddbd0234c0b63be9" title="Logging-only *this-unique ID used in nicknaming the last actively-opened (via open_channel()) channel...">Client_session_impl::m_last_actively_opened_channel_id</a>.  <a href="classipc_1_1session_1_1Server__session__impl.html#a6677dde04bab0c72881848a9b72a8227">More...</a><br /></td></tr>
<tr class="separator:a6677dde04bab0c72881848a9b72a8227"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a54af1ca2d4e5485a2709f77d3f13635d"><td class="memItemLeft" align="right" valign="top">unsigned int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classipc_1_1session_1_1Server__session__impl.html#a54af1ca2d4e5485a2709f77d3f13635d">m_last_channel_mq_id</a></td></tr>
<tr class="memdesc:a54af1ca2d4e5485a2709f77d3f13635d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Unique component of MQ names generated by <a class="el" href="classipc_1_1session_1_1Server__session__impl.html#a84d54a57d3e06c064cde737d1f4be472" title="Helper for create_channel_and_resources(), invoked and compiled if and only if S_MQS_ENABLED,...">make_channel_mqs()</a> (if relevant; else untouched).  <a href="classipc_1_1session_1_1Server__session__impl.html#a54af1ca2d4e5485a2709f77d3f13635d">More...</a><br /></td></tr>
<tr class="separator:a54af1ca2d4e5485a2709f77d3f13635d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a73419b3ccb6e3d028d8acc8f9f42e0ac"><td class="memItemLeft" align="right" valign="top">flow::async::Single_thread_task_loop&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classipc_1_1session_1_1Server__session__impl.html#a73419b3ccb6e3d028d8acc8f9f42e0ac">m_async_worker</a></td></tr>
<tr class="memdesc:a73419b3ccb6e3d028d8acc8f9f42e0ac"><td class="mdescLeft">&#160;</td><td class="mdescRight">Worker thread (a/k/a thread W).  <a href="classipc_1_1session_1_1Server__session__impl.html#a73419b3ccb6e3d028d8acc8f9f42e0ac">More...</a><br /></td></tr>
<tr class="separator:a73419b3ccb6e3d028d8acc8f9f42e0ac"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a81eb6769bc75d900bb3c442047249503"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classipc_1_1session_1_1Server__session__impl.html#ab6cfad1c0be9815dc5411cd20c131213">Master_structured_channel_ptr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classipc_1_1session_1_1Server__session__impl.html#a81eb6769bc75d900bb3c442047249503">m_master_channel</a></td></tr>
<tr class="memdesc:a81eb6769bc75d900bb3c442047249503"><td class="mdescLeft">&#160;</td><td class="mdescRight">The session master channel.  <a href="classipc_1_1session_1_1Server__session__impl.html#a81eb6769bc75d900bb3c442047249503">More...</a><br /></td></tr>
<tr class="separator:a81eb6769bc75d900bb3c442047249503"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a02a0feffbe59da064cbf33ba33eb4dac"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespaceipc.html#aa455c7f045059736578ca275fc1a851f">Function</a>&lt; void()&gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classipc_1_1session_1_1Server__session__impl.html#a02a0feffbe59da064cbf33ba33eb4dac">m_deinit_func_or_empty</a></td></tr>
<tr class="memdesc:a02a0feffbe59da064cbf33ba33eb4dac"><td class="mdescLeft">&#160;</td><td class="mdescRight">See <a class="el" href="classipc_1_1session_1_1Server__session__impl.html#a2276a6fd556861a9e0856360fde58158" title="Utility for sub-classes: ensures that task() is invoked near the end of *this dtor&#39;s execution,...">sub_class_set_deinit_func()</a>. <code>.empty()</code> unless that was called at least once.  <a href="classipc_1_1session_1_1Server__session__impl.html#a02a0feffbe59da064cbf33ba33eb4dac">More...</a><br /></td></tr>
<tr class="separator:a02a0feffbe59da064cbf33ba33eb4dac"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac473cff436bde8b069a3f0d55d9c3b51"><td class="memItemLeft" align="right" valign="top">std::optional&lt; typename <a class="el" href="classipc_1_1session_1_1Session__base_1_1Graceful__finisher.html">Base::Graceful_finisher</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classipc_1_1session_1_1Server__session__impl.html#ac473cff436bde8b069a3f0d55d9c3b51">m_graceful_finisher</a></td></tr>
<tr class="memdesc:ac473cff436bde8b069a3f0d55d9c3b51"><td class="mdescLeft">&#160;</td><td class="mdescRight">Null until PEER state is reached, and NULL unless compile-time <a class="el" href="classipc_1_1session_1_1Server__session__impl.html#a0dc599111ce0b4b6d8cd003559e6c01c" title="Short-hand for template parameter knob S_GRACEFUL_FINISH_REQUIRED_V: see class template doc header.">S_GRACEFUL_FINISH_REQUIRED</a> is <code>true</code>, this is used to block at the start of dtor to synchronize with the opposing <code><a class="el" href="classipc_1_1session_1_1Session.html" title="A documentation-only concept defining the local side of an IPC conversation (session) with another en...">Session</a></code> dtor for safety.  <a href="classipc_1_1session_1_1Server__session__impl.html#ac473cff436bde8b069a3f0d55d9c3b51">More...</a><br /></td></tr>
<tr class="separator:ac473cff436bde8b069a3f0d55d9c3b51"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="related" name="related"></a>
Related Functions</h2></td></tr>
<tr><td class="ititle" colspan="2"><p >(Note that these are not member functions.) </p>
</td></tr>
<tr class="memitem:a88b5e68821f26cfab86feb8b4dc5702a"><td class="memTemplParams" colspan="2">template&lt;schema::MqType S_MQ_TYPE_OR_NONE, bool S_TRANSMIT_NATIVE_HANDLES, typename Mdt_payload , schema::ShmType S_SHM_TYPE_OR_NONE, size_t S_SHM_MAX_HNDL_SZ, bool S_GRACEFUL_FINISH_REQUIRED_V&gt; </td></tr>
<tr class="memitem:a88b5e68821f26cfab86feb8b4dc5702a"><td class="memTemplItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classipc_1_1session_1_1Server__session__impl.html#a88b5e68821f26cfab86feb8b4dc5702a">operator&lt;&lt;</a> (std::ostream &amp;os, const <a class="el" href="classipc_1_1session_1_1Server__session__impl.html">Server_session_impl</a>&lt; S_MQ_TYPE_OR_NONE, S_TRANSMIT_NATIVE_HANDLES, Mdt_payload, S_SHM_TYPE_OR_NONE, S_SHM_MAX_HNDL_SZ, S_GRACEFUL_FINISH_REQUIRED_V &gt; &amp;val)</td></tr>
<tr class="memdesc:a88b5e68821f26cfab86feb8b4dc5702a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Prints string representation of the given <code><a class="el" href="classipc_1_1session_1_1Server__session__impl.html" title="Internal, non-movable pImpl-lite implementation of Server_session_mv class template.">Server_session_impl</a></code> to the given <code>ostream</code>.  <a href="classipc_1_1session_1_1Server__session__impl.html#a88b5e68821f26cfab86feb8b4dc5702a">More...</a><br /></td></tr>
<tr class="separator:a88b5e68821f26cfab86feb8b4dc5702a"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="inherited" name="inherited"></a>
Additional Inherited Members</h2></td></tr>
<tr class="inherit_header pub_static_methods_classipc_1_1session_1_1Session__base"><td colspan="2" onclick="javascript:toggleInherit('pub_static_methods_classipc_1_1session_1_1Session__base')"><img src="closed.png" alt="-"/>&#160;Static Public Member Functions inherited from <a class="el" href="classipc_1_1session_1_1Session__base.html">ipc::session::Session_base&lt; S_MQ_TYPE_OR_NONE, S_TRANSMIT_NATIVE_HANDLES, Mdt_payload &gt;</a></td></tr>
<tr class="memitem:a08b3d69a6707dcbb233076b7a48de285 inherit pub_static_methods_classipc_1_1session_1_1Session__base"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classipc_1_1session_1_1Session__base.html#aee0db48505c84d3553b7110a9a815036">Structured_msg_builder_config</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classipc_1_1session_1_1Session__base.html#a08b3d69a6707dcbb233076b7a48de285">heap_fixed_builder_config</a> (flow::log::Logger *logger_ptr)</td></tr>
<tr class="memdesc:a08b3d69a6707dcbb233076b7a48de285 inherit pub_static_methods_classipc_1_1session_1_1Session__base"><td class="mdescLeft">&#160;</td><td class="mdescRight">See <a class="el" href="classipc_1_1session_1_1Session__mv.html#a107684fdd5d233549c6daac26a81a542" title="Utility that obtains a heap-based (non-zero-copy) Struct_builder::Config, constructed with the most e...">Session_mv::heap_fixed_builder_config()</a> (1-arg).  <a href="classipc_1_1session_1_1Session__base.html#a08b3d69a6707dcbb233076b7a48de285">More...</a><br /></td></tr>
<tr class="separator:a08b3d69a6707dcbb233076b7a48de285 inherit pub_static_methods_classipc_1_1session_1_1Session__base"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a489bb6ec7726e39e78dcd4dd2fe3de75 inherit pub_static_methods_classipc_1_1session_1_1Session__base"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classipc_1_1session_1_1Session__base.html#abd854f2b9316361ef18f15610c242d4b">Structured_msg_reader_config</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classipc_1_1session_1_1Session__base.html#a489bb6ec7726e39e78dcd4dd2fe3de75">heap_reader_config</a> (flow::log::Logger *logger_ptr)</td></tr>
<tr class="memdesc:a489bb6ec7726e39e78dcd4dd2fe3de75 inherit pub_static_methods_classipc_1_1session_1_1Session__base"><td class="mdescLeft">&#160;</td><td class="mdescRight">See <a class="el" href="classipc_1_1session_1_1Session__mv.html#ab3c69e3f8ccbd70d315bed86d697255d" title="Deserializing counterpart to non-static heap_fixed_builder_config().">Session_mv::heap_reader_config()</a> (1-arg).  <a href="classipc_1_1session_1_1Session__base.html#a489bb6ec7726e39e78dcd4dd2fe3de75">More...</a><br /></td></tr>
<tr class="separator:a489bb6ec7726e39e78dcd4dd2fe3de75 inherit pub_static_methods_classipc_1_1session_1_1Session__base"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pub_attribs_classipc_1_1session_1_1Session__base"><td colspan="2" onclick="javascript:toggleInherit('pub_attribs_classipc_1_1session_1_1Session__base')"><img src="closed.png" alt="-"/>&#160;Public Attributes inherited from <a class="el" href="classipc_1_1session_1_1Session__base.html">ipc::session::Session_base&lt; S_MQ_TYPE_OR_NONE, S_TRANSMIT_NATIVE_HANDLES, Mdt_payload &gt;</a></td></tr>
<tr class="memitem:afd32d90b86d699263a0f02637dd7c6c6 inherit pub_attribs_classipc_1_1session_1_1Session__base"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="structipc_1_1session_1_1Server__app.html">Server_app</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classipc_1_1session_1_1Session__base.html#afd32d90b86d699263a0f02637dd7c6c6">m_srv_app_ref</a></td></tr>
<tr class="memdesc:afd32d90b86d699263a0f02637dd7c6c6 inherit pub_attribs_classipc_1_1session_1_1Session__base"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reference to <a class="el" href="structipc_1_1session_1_1Server__app.html" title="An App that is used as a server in at least one client-server IPC split.">Server_app</a> (referring to local process in <a class="el" href="classipc_1_1session_1_1Server__session__impl.html" title="Internal, non-movable pImpl-lite implementation of Server_session_mv class template.">Server_session_impl</a>, opposing process in <a class="el" href="classipc_1_1session_1_1Client__session__impl.html" title="Internal, non-movable pImpl-lite implementation of Client_session_mv class template.">Client_session_impl</a>).  <a href="classipc_1_1session_1_1Session__base.html#afd32d90b86d699263a0f02637dd7c6c6">More...</a><br /></td></tr>
<tr class="separator:afd32d90b86d699263a0f02637dd7c6c6 inherit pub_attribs_classipc_1_1session_1_1Session__base"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pro_static_attribs_classipc_1_1session_1_1Session__base"><td colspan="2" onclick="javascript:toggleInherit('pro_static_attribs_classipc_1_1session_1_1Session__base')"><img src="closed.png" alt="-"/>&#160;Static Protected Attributes inherited from <a class="el" href="classipc_1_1session_1_1Session__base.html">ipc::session::Session_base&lt; S_MQ_TYPE_OR_NONE, S_TRANSMIT_NATIVE_HANDLES, Mdt_payload &gt;</a></td></tr>
<tr class="memitem:ae68b7b80ff82ba5cde28a53fa52a5095 inherit pro_static_attribs_classipc_1_1session_1_1Session__base"><td class="memItemLeft" align="right" valign="top">static constexpr <a class="el" href="namespaceipc_1_1util.html#ac66141280c3b7295a86b65209f31cc58">util::Fine_duration</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classipc_1_1session_1_1Session__base.html#ae68b7b80ff82ba5cde28a53fa52a5095">S_OPEN_CHANNEL_TIMEOUT</a> = boost::chrono::seconds(60)</td></tr>
<tr class="memdesc:ae68b7b80ff82ba5cde28a53fa52a5095 inherit pro_static_attribs_classipc_1_1session_1_1Session__base"><td class="mdescLeft">&#160;</td><td class="mdescRight">Internal timeout for <code>open_channel()</code>.  <a href="classipc_1_1session_1_1Session__base.html#ae68b7b80ff82ba5cde28a53fa52a5095">More...</a><br /></td></tr>
<tr class="separator:ae68b7b80ff82ba5cde28a53fa52a5095 inherit pro_static_attribs_classipc_1_1session_1_1Session__base"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af0b52934c6b1204cb3ba676480727d27 inherit pro_static_attribs_classipc_1_1session_1_1Session__base"><td class="memItemLeft" align="right" valign="top">static constexpr size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classipc_1_1session_1_1Session__base.html#af0b52934c6b1204cb3ba676480727d27">S_MQS_MAX_MSG_SZ</a> = 8 * 1024</td></tr>
<tr class="memdesc:af0b52934c6b1204cb3ba676480727d27 inherit pro_static_attribs_classipc_1_1session_1_1Session__base"><td class="mdescLeft">&#160;</td><td class="mdescRight">The max sendable MQ message size as decided by <a class="el" href="classipc_1_1session_1_1Server__session__impl.html#a84d54a57d3e06c064cde737d1f4be472" title="Helper for create_channel_and_resources(), invoked and compiled if and only if S_MQS_ENABLED,...">Server_session_impl::make_channel_mqs()</a> (and imposed on both sides, both directions), if <a class="el" href="classipc_1_1session_1_1Session__base.html#a27a5731a648effb6b4b42f0312affa74" title="See Session_mv.">S_MQS_ENABLED</a> <em>and</em> <a class="el" href="classipc_1_1session_1_1Server__session__impl.html#a1ded7990451b90f29e11f8fa7ce0e80b" title="See Session_mv counterpart.">Server_session_impl::S_SHM_ENABLED</a> is <code>false</code>, when a channel is opened (regardless of which side did the active-open or requested pre-opening at session start).  <a href="classipc_1_1session_1_1Session__base.html#af0b52934c6b1204cb3ba676480727d27">More...</a><br /></td></tr>
<tr class="separator:af0b52934c6b1204cb3ba676480727d27 inherit pro_static_attribs_classipc_1_1session_1_1Session__base"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><div class="compoundTemplParams">template&lt;schema::MqType S_MQ_TYPE_OR_NONE, bool S_TRANSMIT_NATIVE_HANDLES, typename Mdt_payload, schema::ShmType S_SHM_TYPE_OR_NONE, size_t S_SHM_MAX_HNDL_SZ, bool S_GRACEFUL_FINISH_REQUIRED_V&gt;<br />
class ipc::session::Server_session_impl&lt; S_MQ_TYPE_OR_NONE, S_TRANSMIT_NATIVE_HANDLES, Mdt_payload, S_SHM_TYPE_OR_NONE, S_SHM_MAX_HNDL_SZ, S_GRACEFUL_FINISH_REQUIRED_V &gt;</div><p >Internal, non-movable pImpl-lite implementation of <a class="el" href="classipc_1_1session_1_1Server__session__mv.html" title="Implements Session concept on the Server_app end: a Session that is emitted in almost-PEER state by l...">Server_session_mv</a> class template. </p>
<p >In and of itself it would have been directly and publicly usable; however <a class="el" href="classipc_1_1session_1_1Server__session__mv.html" title="Implements Session concept on the Server_app end: a Session that is emitted in almost-PEER state by l...">Server_session_mv</a> adds move semantics.</p>
<dl class="section see"><dt>See also</dt><dd>All discussion of the public (and <code>protected</code>, to be exposed <code>public</code>ly by <a class="el" href="classipc_1_1session_1_1Server__session__dtl.html" title="This is the data-less sub-class of Server_session or any more-advanced (e.g., SHM-capable) variant th...">Server_session_dtl</a>) API is in <a class="el" href="classipc_1_1session_1_1Server__session__mv.html" title="Implements Session concept on the Server_app end: a Session that is emitted in almost-PEER state by l...">Server_session_mv</a> doc header; that class template forwards to this one. All discussion of pImpl-lite-related notions is also there. See that doc header first please. Then come back here.</dd></dl>
<h2>Impl design </h2>
<p >Generally, I (ygoldfel) recommend looking through and understanding <a class="el" href="classipc_1_1session_1_1Client__session__impl.html" title="Internal, non-movable pImpl-lite implementation of Client_session_mv class template.">Client_session_impl</a> first. It is similar but somewhat more complex, and once it is understood, you'll be able to understand <a class="el" href="classipc_1_1session_1_1Server__session__impl.html" title="Internal, non-movable pImpl-lite implementation of Server_session_mv class template.">Server_session_impl</a> easily. Plus its logic is complementary to a <code>*this</code>, as the two directly interoperate via a couple of IPC forms. The below discussion does assume one has read/understood <a class="el" href="classipc_1_1session_1_1Client__session__impl.html" title="Internal, non-movable pImpl-lite implementation of Client_session_mv class template.">Client_session_impl</a> doc header.</p>
<p >Thread U represents all threads other than thread W: since the relevant methods are to be called by the user sans concurrency, those threads as a collection can be thought of as one thread.</p>
<p >Thread W is the async worker thread where most work is done; this helps us entirely avoid mutexes. <a class="el" href="classipc_1_1session_1_1Server__session__impl.html#aee35d521d9997d48f6b5565730e60e93" title="For use by internal user Session_server: See Server_session_mv counterpart.">async_accept_log_in()</a> is called exactly once, internally by <a class="el" href="classipc_1_1session_1_1Session__server.html" title="To be instantiated typically once in a given process, an object of this type asynchronously listens f...">Session_server</a>; and subsequently <a class="el" href="classipc_1_1session_1_1Server__session__impl.html#a45a5ae92b706ea539c27be0d19a303c4" title="See Server_session_mv counterpart.">open_channel()</a> is fairly infrequently called. So it's not necessary to avoid latency by doing work concurrently in threads U and W. So we keep it simple by posting most stuff onto thread W.</p>
<p >The state machine of <a class="el" href="classipc_1_1session_1_1Server__session__impl.html" title="Internal, non-movable pImpl-lite implementation of Server_session_mv class template.">Server_session_impl</a> is simpler than <a class="el" href="classipc_1_1session_1_1Client__session__impl.html" title="Internal, non-movable pImpl-lite implementation of Client_session_mv class template.">Client_session_impl</a>. The asymmetry is, firstly, due to the client-server setup: <a class="el" href="classipc_1_1session_1_1Session__server.html" title="To be instantiated typically once in a given process, an object of this type asynchronously listens f...">Session_server</a> is the one, on the server end, that awaits the initial <a class="el" href="classipc_1_1transport_1_1Native__socket__stream.html" title="Implements both Native_handle_sender and Native_handle_receiver concepts by using a stream-oriented U...">transport::Native_socket_stream</a> connection. Once a PEER-state <code>Native_socket_stream</code> is ready, only then does <a class="el" href="classipc_1_1session_1_1Session__server.html" title="To be instantiated typically once in a given process, an object of this type asynchronously listens f...">Session_server</a> create a <a class="el" href="classipc_1_1session_1_1Server__session__dtl.html" title="This is the data-less sub-class of Server_session or any more-advanced (e.g., SHM-capable) variant th...">Server_session_dtl</a> (which is a <code>public</code> facade to <a class="el" href="classipc_1_1session_1_1Server__session__mv.html" title="Implements Session concept on the Server_app end: a Session that is emitted in almost-PEER state by l...">Server_session_mv</a>, which is a movable <code>unique_ptr</code> wrapper around this <a class="el" href="classipc_1_1session_1_1Server__session__impl.html" title="Internal, non-movable pImpl-lite implementation of Server_session_mv class template.">Server_session_impl</a>). So <code>*this</code>, unlike a <a class="el" href="classipc_1_1session_1_1Client__session__impl.html" title="Internal, non-movable pImpl-lite implementation of Client_session_mv class template.">Client_session_impl</a>, does not need to connect a socket. Next, <a class="el" href="classipc_1_1session_1_1Server__session__impl.html" title="Internal, non-movable pImpl-lite implementation of Server_session_mv class template.">Server_session_impl</a> just needs to complete one async step, which is in practice immediately (and, by contract, only once) invoked: <a class="el" href="classipc_1_1session_1_1Server__session__impl.html#aee35d521d9997d48f6b5565730e60e93" title="For use by internal user Session_server: See Server_session_mv counterpart.">async_accept_log_in()</a>. At this stage user does not have the <a class="el" href="classipc_1_1session_1_1Server__session__mv.html" title="Implements Session concept on the Server_app end: a Session that is emitted in almost-PEER state by l...">Server_session_mv</a> yet, so we're still in internal-code land. (By contrast Client_session is created directly by the user and is immediately publicly available as a stand-alone object.) <a class="el" href="classipc_1_1session_1_1Server__session__impl.html#aee35d521d9997d48f6b5565730e60e93" title="For use by internal user Session_server: See Server_session_mv counterpart.">async_accept_log_in()</a> immediately upgrades the <code>Native_socket_stream</code> to a <a class="el" href="classipc_1_1transport_1_1Channel.html" title="Peer to a bundle of 1-2 full-duplex pipe(s), one for transmitting unstructured binary blobs; the othe...">transport::Channel</a> and then immediately upgrades that to a <a class="el" href="classipc_1_1transport_1_1struc_1_1Channel.html" title="Owning and wrapping a pre-connected transport::Channel peer (an endpoint of an established channel ov...">transport::struc::Channel</a>, saving it to <a class="el" href="classipc_1_1session_1_1Server__session__impl.html#a81eb6769bc75d900bb3c442047249503" title="The session master channel.">m_master_channel</a> (all synchronously). Lastly is the actual async work: awaiting the log-in request from Client_session. Once that is received, we respond via <a class="el" href="classipc_1_1session_1_1Server__session__impl.html#a81eb6769bc75d900bb3c442047249503" title="The session master channel.">m_master_channel</a>, either with log-in success or failure. Assuming success, we invoke the (internal) <a class="el" href="classipc_1_1session_1_1Server__session__impl.html#aee35d521d9997d48f6b5565730e60e93" title="For use by internal user Session_server: See Server_session_mv counterpart.">async_accept_log_in()</a> handler; on failure same thing but with a failure <a class="el" href="namespaceipc.html#aa3192e586cc45d3e7c22463bf2760f89" title="Short-hand for flow::Error_code which is very common.">Error_code</a>.</p>
<h3>Sidebar: Init-channels</h3>
<p >Update (init-channels feature has been added): The preceding paragraph holds fully if and only if:</p><ul>
<li>client (in its log-in request message, <code>LogInReq</code>) requested 0 init-channels to be opened on its behalf; and</li>
<li>server (via the user args from <a class="el" href="classipc_1_1session_1_1Session__server.html#a13887cd64912bb5f5675e2817ff8435f" title="Asynchronously awaits for an opposing Client_session to request session establishment and calls on_do...">Session_server::async_accept()</a> forwarded to <a class="el" href="classipc_1_1session_1_1Server__session__impl.html#aee35d521d9997d48f6b5565730e60e93" title="For use by internal user Session_server: See Server_session_mv counterpart.">async_accept_log_in()</a>) requested 0 init-channels to be opened on local user's behalf.</li>
</ul>
<p >However, if the sum of these 2 numbers (as determined upon successful receipt on <code>LogInReq</code>, and assuming everything else was also successful, up-to-and-including sending successful <code>LogInRsp</code>) is N=1+, then before <a class="el" href="classipc_1_1session_1_1Server__session__impl.html#aee35d521d9997d48f6b5565730e60e93" title="For use by internal user Session_server: See Server_session_mv counterpart.">async_accept_log_in()</a> can reach almost-PEER state (and fire completion handler), there is 1 more async-step:</p><ul>
<li>(send <code>LogInRsp</code> as explained);</li>
<li>(prep) synchronously prepare the N=1+ init-channels (exactly as would occur if user invoked <a class="el" href="classipc_1_1session_1_1Server__session__impl.html#a45a5ae92b706ea539c27be0d19a303c4" title="See Server_session_mv counterpart.">open_channel()</a> N times in PEER state);</li>
<li>(prep) sync-send N <code>OpenChannelToClientReq</code> messages with names/handles for each of the N init-channels (exactly as would occur on N <a class="el" href="classipc_1_1session_1_1Server__session__impl.html#a45a5ae92b706ea539c27be0d19a303c4" title="See Server_session_mv counterpart.">open_channel()</a> calls in PEER state);</li>
<li>async: await a <em>single</em> <code>OpenChannelToClientRsp</code> response, indicating the last of the N channels has been accepted, and client is now in PEER state and ready for passive-opens (i.e., we can enter PEER-state which enabled <a class="el" href="classipc_1_1session_1_1Server__session__impl.html#a45a5ae92b706ea539c27be0d19a303c4" title="See Server_session_mv counterpart.">open_channel()</a> by the local user).</li>
</ul>
<p >Why this last async step? Couldn't we just do the <code>send()</code>s and go to almost-PEER state immediately? Almost: but if we did that, then if the user immediately issued <a class="el" href="classipc_1_1session_1_1Server__session__impl.html#ac93040ccdaf5a261a053a8b55bd2e14e" title="See Server_session_mv counterpart.">init_handlers()</a> and an <a class="el" href="classipc_1_1session_1_1Server__session__impl.html#a45a5ae92b706ea539c27be0d19a303c4" title="See Server_session_mv counterpart.">open_channel()</a>, then the opposing <a class="el" href="classipc_1_1session_1_1Client__session__impl.html" title="Internal, non-movable pImpl-lite implementation of Client_session_mv class template.">Client_session_impl</a> might not, technically, be quick enough to have moved to its own PEER state; then its <code>OpenChannelToClientReq</code> handler from the pre-PEER state (CONNECTING state) might be triggered; this would cause... nothing good. However the ACK from <a class="el" href="classipc_1_1session_1_1Client__session__impl.html" title="Internal, non-movable pImpl-lite implementation of Client_session_mv class template.">Client_session_impl</a> is sent only just before entering PEER state, at which point it is safe for us to issue <a class="el" href="classipc_1_1session_1_1Server__session__impl.html#a45a5ae92b706ea539c27be0d19a303c4" title="See Server_session_mv counterpart.">open_channel()</a>s.</p>
<h3>Back to general impl discussion</h3>
<p >Our <a class="el" href="classipc_1_1session_1_1Server__session__impl.html#aee35d521d9997d48f6b5565730e60e93" title="For use by internal user Session_server: See Server_session_mv counterpart.">async_accept_log_in()</a> is analogous/complementary to <a class="el" href="classipc_1_1session_1_1Client__session__impl.html#a56c0d2b0ff082d1f7b0738e2528b4a92" title="Core implementation of sync_connect().">Client_session_impl::async_connect()</a>, but the diff is that the user only gets access to a <code>*this</code> upon success of this async op; and never gets access upon failure at all. So that's another source of asymmetry versus <a class="el" href="classipc_1_1session_1_1Client__session__impl.html" title="Internal, non-movable pImpl-lite implementation of Client_session_mv class template.">Client_session_impl</a>. Thus:</p><ul>
<li>No need to guard against <a class="el" href="classipc_1_1session_1_1Server__session__impl.html#aee35d521d9997d48f6b5565730e60e93" title="For use by internal user Session_server: See Server_session_mv counterpart.">async_accept_log_in()</a> call while the log-in is outstanding.<ul>
<li>(As of <em>this</em> writing <a class="el" href="classipc_1_1session_1_1Client__session__impl.html" title="Internal, non-movable pImpl-lite implementation of Client_session_mv class template.">Client_session_impl</a> only uses async_connect() internally and does not expose it, so it's not an issue there either; but that would change, if it became network-enabled at some level.)</li>
</ul>
</li>
<li>No need to guard against other API calls, notably <a class="el" href="classipc_1_1session_1_1Server__session__impl.html#a45a5ae92b706ea539c27be0d19a303c4" title="See Server_session_mv counterpart.">open_channel()</a>, before (almost-)PEER state is achieved. (User only gets access to <code>*this</code>, once <code>*this</code> is in (almost-)PEER state.)</li>
</ul>
<p >Therefore there's no need to track an <code>m_state</code> the way <a class="el" href="classipc_1_1session_1_1Client__session__impl.html" title="Internal, non-movable pImpl-lite implementation of Client_session_mv class template.">Client_session_impl</a> does. If <a class="el" href="classipc_1_1session_1_1Server__session__impl.html#a59236329cf8e0f75c9ef628def1b97a7" title="The on_done_func argument to async_accept_log_in(); .empty() except while the (at most one,...">m_log_in_on_done_func</a> is non-empty, then <a class="el" href="classipc_1_1session_1_1Server__session__impl.html#aee35d521d9997d48f6b5565730e60e93" title="For use by internal user Session_server: See Server_session_mv counterpart.">async_accept_log_in()</a> is outstanding (analogous to <a class="el" href="classipc_1_1session_1_1Client__session__impl.html" title="Internal, non-movable pImpl-lite implementation of Client_session_mv class template.">Client_session_impl</a> CONNECTING state). Otherwise see the "almost-PEER" section just below.</p>
<h3>Almost-PEER state impl</h3>
<p >There is a minor wrinkle in <a class="el" href="classipc_1_1session_1_1Server__session__mv.html" title="Implements Session concept on the Server_app end: a Session that is emitted in almost-PEER state by l...">Server_session_mv</a> (and thus <a class="el" href="classipc_1_1session_1_1Server__session__impl.html" title="Internal, non-movable pImpl-lite implementation of Server_session_mv class template.">Server_session_impl</a>). Once the user obtains the <a class="el" href="classipc_1_1session_1_1Server__session__mv.html" title="Implements Session concept on the Server_app end: a Session that is emitted in almost-PEER state by l...">Server_session_mv</a>, it is in the so-called <em>almost-PEER</em> state. That is because it needs 1-2 more pieces of info to be set before it is formally in PEER state as specified by <a class="el" href="classipc_1_1session_1_1Session.html" title="A documentation-only concept defining the local side of an IPC conversation (session) with another en...">Session</a> concept. Namely its on-error handler must be set (mandatory), as must its on-passive-open handler (optional; in that leaving it unspecified is allowed and means passive-opens are disabled on this side). To do so the <em>user</em> shall call <a class="el" href="classipc_1_1session_1_1Server__session__impl.html#ac93040ccdaf5a261a053a8b55bd2e14e" title="See Server_session_mv counterpart.">init_handlers()</a>. Until this is done, <a class="el" href="classipc_1_1session_1_1Server__session__impl.html#a45a5ae92b706ea539c27be0d19a303c4" title="See Server_session_mv counterpart.">open_channel()</a> and other public PEER-state APIs shall no-op and return sentinel/<code>false</code>.</p>
<p >There is a subtlety in how this are-handlers-set check is performed. The crux of it is that <a class="el" href="classipc_1_1session_1_1Server__session__impl.html#a81eb6769bc75d900bb3c442047249503" title="The session master channel.">m_master_channel</a> can report an error at any time starting with <a class="el" href="classipc_1_1session_1_1Server__session__impl.html#aee35d521d9997d48f6b5565730e60e93" title="For use by internal user Session_server: See Server_session_mv counterpart.">async_accept_log_in()</a> (where it is first created), and what to do is quite different in each case:</p><ul>
<li>Before public availability to user (async log-in ongoing).<ul>
<li>Contingency: report failure of <a class="el" href="classipc_1_1session_1_1Server__session__impl.html#aee35d521d9997d48f6b5565730e60e93" title="For use by internal user Session_server: See Server_session_mv counterpart.">async_accept_log_in()</a>, via its on-done handler.</li>
</ul>
</li>
<li>After that but in almost-PEER state (on-error handler not yet set by user).<ul>
<li>Contingency: well, we <em>want</em> to report it via on-error handler... but it's not set yet. So memorize it in special member <a class="el" href="classipc_1_1session_1_1Server__session__impl.html#ad9f6932719c1565191da73bfa4a3923f" title="Unused/falsy except when in almost-PEER state (past successful async_accept_log_in(),...">m_pre_init_err_code</a>. Then in <a class="el" href="classipc_1_1session_1_1Server__session__impl.html#ac93040ccdaf5a261a053a8b55bd2e14e" title="See Server_session_mv counterpart.">init_handlers()</a> immediately fire off the freshly-available on-error handler with that <a class="el" href="namespaceipc.html#aa3192e586cc45d3e7c22463bf2760f89" title="Short-hand for flow::Error_code which is very common.">Error_code</a>.</li>
</ul>
</li>
<li>In PEER state (the handler has been set).<ul>
<li>Contingency: yay, forward the <a class="el" href="classipc_1_1session_1_1Server__session__impl.html#a81eb6769bc75d900bb3c442047249503" title="The session master channel.">m_master_channel</a>-reported <a class="el" href="namespaceipc.html#aa3192e586cc45d3e7c22463bf2760f89" title="Short-hand for flow::Error_code which is very common.">Error_code</a> to the on-error handler.</li>
</ul>
</li>
</ul>
<p >Because the <a class="el" href="classipc_1_1session_1_1Server__session__impl.html#a81eb6769bc75d900bb3c442047249503" title="The session master channel.">m_master_channel</a> error handler is relevant across all of the above, and it is executed in thread W for reasons explained above (avoiding mutexes, etc.), to avoid concurrency difficulties the are-handlers-set check, and the assignment of the handlers, is also done in thread W. Hence, like most code in <a class="el" href="classipc_1_1session_1_1Server__session__impl.html" title="Internal, non-movable pImpl-lite implementation of Server_session_mv class template.">Server_session_impl</a>, <a class="el" href="classipc_1_1session_1_1Server__session__impl.html#ac93040ccdaf5a261a053a8b55bd2e14e" title="See Server_session_mv counterpart.">init_handlers()</a> posts all its work onto thread W. All public APIs, even simple ones like <a class="el" href="classipc_1_1session_1_1Server__session__impl.html#a22e1464a8bc4b806bf3a91e932b31813" title="See Server_session_mv counterpart.">session_token()</a>, do the same, and that thread-W work always begins by ensuring <a class="el" href="classipc_1_1session_1_1Server__session__impl.html#ae33e5c8ca6904844689e78ee764bc2da" title="In thread W, returns whether init_handlers_impl() has yet executed.">handlers_are_set()</a>.</p>
<p >Once PEER state is achieved, to the user <code>*this</code> is (just like <a class="el" href="classipc_1_1session_1_1Client__session__impl.html" title="Internal, non-movable pImpl-lite implementation of Client_session_mv class template.">Client_session_impl</a>) an impl of <a class="el" href="classipc_1_1session_1_1Session.html" title="A documentation-only concept defining the local side of an IPC conversation (session) with another en...">Session</a> concept. Internally it's somewhat different.</p>
<h3>PEER state impl</h3>
<p >Here our algorithm is complementary to the PEER state algorithm in <a class="el" href="classipc_1_1session_1_1Client__session__impl.html" title="Internal, non-movable pImpl-lite implementation of Client_session_mv class template.">Client_session_impl</a>. Namely we expect passive-opens via an appropriate <a class="el" href="classipc_1_1transport_1_1struc_1_1Channel.html#a3376b821b129ca3847484a178e080c67" title="Registers the expectation of 0+ notification in-messages whose Msg_which equals which.">transport::struc::Channel::expect_msgs()</a>; and we allow active-opens via <a class="el" href="classipc_1_1session_1_1Server__session__impl.html#a45a5ae92b706ea539c27be0d19a303c4" title="See Server_session_mv counterpart.">open_channel()</a>. The details of how these work is best understood just by reading that code inline. All in all, publicly it's just like <a class="el" href="classipc_1_1session_1_1Client__session__impl.html" title="Internal, non-movable pImpl-lite implementation of Client_session_mv class template.">Client_session_impl</a>; but internally it is its complement and in fact has different (complementary) responsibilities. Most notably, regarding active-opens and passive-opens:</p><ul>
<li><a class="el" href="classipc_1_1session_1_1Server__session__impl.html" title="Internal, non-movable pImpl-lite implementation of Server_session_mv class template.">Server_session_impl</a> is the one always internally responsible for acquiring the resources needed to establish the channel. Namely:<ul>
<li>If <a class="el" href="classipc_1_1session_1_1Server__session__impl.html#a005fcbc9ee215531c03d17fcc49ef544" title="See Server_session_mv counterpart.">S_MQS_ENABLED</a>: it <em>creates</em> the underlying MQs. This involves choosing a distinct-enough name for each of the 2 MQs (one in each direction, client-&gt;server, server-&gt;client). These names shall be sent-over, via <a class="el" href="classipc_1_1session_1_1Server__session__impl.html#a81eb6769bc75d900bb3c442047249503" title="The session master channel.">m_master_channel</a>, to the <a class="el" href="classipc_1_1session_1_1Client__session__impl.html" title="Internal, non-movable pImpl-lite implementation of Client_session_mv class template.">Client_session_impl</a>.</li>
<li>If <a class="el" href="classipc_1_1session_1_1Server__session__impl.html#abfa7d61030e1d40cdc0085afacb43b6c" title="See Server_session_mv counterpart.">S_SOCKET_STREAM_ENABLED</a>: it <em>creates</em> the pre-connected socket-pair, 1/2 of which (a <code>Native_handle</code>) shall be sent-over, via <a class="el" href="classipc_1_1session_1_1Server__session__impl.html#a81eb6769bc75d900bb3c442047249503" title="The session master channel.">m_master_channel</a>, to the <a class="el" href="classipc_1_1session_1_1Client__session__impl.html" title="Internal, non-movable pImpl-lite implementation of Client_session_mv class template.">Client_session_impl</a>.</li>
</ul>
</li>
<li>Hence:<ul>
<li>An active-open (<a class="el" href="classipc_1_1session_1_1Server__session__impl.html#a45a5ae92b706ea539c27be0d19a303c4" title="See Server_session_mv counterpart.">open_channel()</a>) sends over the references/handles to the above resource(s) in the open-channel-to-client request out-message via <a class="el" href="classipc_1_1session_1_1Server__session__impl.html#a81eb6769bc75d900bb3c442047249503" title="The session master channel.">m_master_channel</a>. It then ensures the client replies with an OK (or failure) response in-message. <a class="el" href="classipc_1_1session_1_1Server__session__impl.html#a45a5ae92b706ea539c27be0d19a303c4" title="See Server_session_mv counterpart.">open_channel()</a> thus succeeds or fails.</li>
<li>A passive-open (<a class="el" href="classipc_1_1session_1_1Server__session__impl.html#a804c629b2da8898376f071db499a2173" title="In thread W, handler for m_master_channel receiving a passive-open (a/k/a open-channel-to-server) req...">on_master_channel_open_channel_req()</a>) involves receiving an open-channel-to-server request in-message via <a class="el" href="classipc_1_1session_1_1Server__session__impl.html#a81eb6769bc75d900bb3c442047249503" title="The session master channel.">m_master_channel</a>. It then acquires the above resource(s) and sends over the refs/handles to said resource(s) in our OK response to that request and invokes the on-passive-open handler locally.</li>
</ul>
</li>
</ul>
<p ><a class="el" href="classipc_1_1session_1_1Client__session__impl.html" title="Internal, non-movable pImpl-lite implementation of Client_session_mv class template.">Client_session_impl</a> active-opens and passive-opens act in a complementary fashion, never acquiring these resources but knowing what to expect.</p>
<p >Otherwise <a class="el" href="classipc_1_1session_1_1Server__session__impl.html#a45a5ae92b706ea539c27be0d19a303c4" title="See Server_session_mv counterpart.">open_channel()</a> is set up similarly to <a class="el" href="classipc_1_1session_1_1Client__session__impl.html#a4a377590fbf55b6d312f24d888d2a1bd" title="See Client_session_mv counterpart.">Client_session_impl::open_channel()</a>, namely the non-blocking/synchronous facade with async-with-timeout internals. See <a class="el" href="classipc_1_1session_1_1Client__session__impl.html" title="Internal, non-movable pImpl-lite implementation of Client_session_mv class template.">Client_session_impl</a> doc header for brief discussion.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">S_MQ_TYPE_OR_NONE</td><td>See <a class="el" href="namespaceipc_1_1session.html#ab01d5bce0ab2f3435ca9dd88d27609dc" title="A vanilla Server_session with no optional capabilities.">Server_session</a> counterpart. </td></tr>
    <tr><td class="paramname">S_TRANSMIT_NATIVE_HANDLES</td><td>See <a class="el" href="namespaceipc_1_1session.html#ab01d5bce0ab2f3435ca9dd88d27609dc" title="A vanilla Server_session with no optional capabilities.">Server_session</a> counterpart. </td></tr>
    <tr><td class="paramname">Mdt_payload</td><td>See <a class="el" href="namespaceipc_1_1session.html#ab01d5bce0ab2f3435ca9dd88d27609dc" title="A vanilla Server_session with no optional capabilities.">Server_session</a> counterpart. </td></tr>
    <tr><td class="paramname">S_SHM_TYPE_OR_NONE</td><td>See common.capnp <code>ShmType</code> capnp-<code>enum</code> definition. </td></tr>
    <tr><td class="paramname">S_SHM_MAX_HNDL_SZ</td><td>Ignored if <code>S_SHM_TYPE_OR_NONE</code> indicates we are not SHM-enabled, this otherwise indicates the max size of a SHM handle's blob serialization. If ignored it must be set to 0 (convention). </td></tr>
    <tr><td class="paramname">S_GRACEFUL_FINISH_REQUIRED_V</td><td><code>true</code> if and only if <a class="el" href="classipc_1_1session_1_1Session__base_1_1Graceful__finisher.html" title="Optional to use by subclasses, this operates a simple state machine that carries out a graceful-sessi...">Session_base::Graceful_finisher</a> must be used. See its doc header for explanation when that would be the case. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="ipc__session_2src_2ipc_2session_2detail_2server__session__impl_8hpp_source.html#l00185">185</a> of file <a class="el" href="ipc__session_2src_2ipc_2session_2detail_2server__session__impl_8hpp_source.html">server_session_impl.hpp</a>.</p>
</div><h2 class="groupheader">Member Typedef Documentation</h2>
<a id="a80daf8c8041d8d510f4712156732b09d" name="a80daf8c8041d8d510f4712156732b09d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a80daf8c8041d8d510f4712156732b09d">&#9670;&nbsp;</a></span>Base</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;schema::MqType S_MQ_TYPE_OR_NONE, bool S_TRANSMIT_NATIVE_HANDLES, typename Mdt_payload , schema::ShmType S_SHM_TYPE_OR_NONE, size_t S_SHM_MAX_HNDL_SZ, bool S_GRACEFUL_FINISH_REQUIRED_V&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classipc_1_1session_1_1Server__session__impl.html">ipc::session::Server_session_impl</a>&lt; S_MQ_TYPE_OR_NONE, S_TRANSMIT_NATIVE_HANDLES, Mdt_payload, S_SHM_TYPE_OR_NONE, S_SHM_MAX_HNDL_SZ, S_GRACEFUL_FINISH_REQUIRED_V &gt;::Base =  <a class="el" href="classipc_1_1session_1_1Session__base.html">Session_base</a>&lt;S_MQ_TYPE_OR_NONE, S_TRANSMIT_NATIVE_HANDLES, Mdt_payload&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Short-hand for base type. </p>

<p class="definition">Definition at line <a class="el" href="ipc__session_2src_2ipc_2session_2detail_2server__session__impl_8hpp_source.html#l00193">193</a> of file <a class="el" href="ipc__session_2src_2ipc_2session_2detail_2server__session__impl_8hpp_source.html">server_session_impl.hpp</a>.</p>

</div>
</div>
<a id="a7c969c3a1007f8e4ba3ad1c1acd6c290" name="a7c969c3a1007f8e4ba3ad1c1acd6c290"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7c969c3a1007f8e4ba3ad1c1acd6c290">&#9670;&nbsp;</a></span>Channel_obj</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;schema::MqType S_MQ_TYPE_OR_NONE, bool S_TRANSMIT_NATIVE_HANDLES, typename Mdt_payload , schema::ShmType S_SHM_TYPE_OR_NONE, size_t S_SHM_MAX_HNDL_SZ, bool S_GRACEFUL_FINISH_REQUIRED_V&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classipc_1_1session_1_1Server__session__impl.html">ipc::session::Server_session_impl</a>&lt; S_MQ_TYPE_OR_NONE, S_TRANSMIT_NATIVE_HANDLES, Mdt_payload, S_SHM_TYPE_OR_NONE, S_SHM_MAX_HNDL_SZ, S_GRACEFUL_FINISH_REQUIRED_V &gt;::Channel_obj =  typename <a class="el" href="classipc_1_1session_1_1Session__base.html#a71f02a809d667c23ff8af29a96940bd1">Base::Channel_obj</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>See <a class="el" href="classipc_1_1session_1_1Server__session__mv.html" title="Implements Session concept on the Server_app end: a Session that is emitted in almost-PEER state by l...">Server_session_mv</a> counterpart. </p>

<p class="definition">Definition at line <a class="el" href="ipc__session_2src_2ipc_2session_2detail_2server__session__impl_8hpp_source.html#l00199">199</a> of file <a class="el" href="ipc__session_2src_2ipc_2session_2detail_2server__session__impl_8hpp_source.html">server_session_impl.hpp</a>.</p>

</div>
</div>
<a id="a75df7061f9c57660f9fb944d83da416b" name="a75df7061f9c57660f9fb944d83da416b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a75df7061f9c57660f9fb944d83da416b">&#9670;&nbsp;</a></span>Channels</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;schema::MqType S_MQ_TYPE_OR_NONE, bool S_TRANSMIT_NATIVE_HANDLES, typename Mdt_payload , schema::ShmType S_SHM_TYPE_OR_NONE, size_t S_SHM_MAX_HNDL_SZ, bool S_GRACEFUL_FINISH_REQUIRED_V&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classipc_1_1session_1_1Server__session__impl.html">ipc::session::Server_session_impl</a>&lt; S_MQ_TYPE_OR_NONE, S_TRANSMIT_NATIVE_HANDLES, Mdt_payload, S_SHM_TYPE_OR_NONE, S_SHM_MAX_HNDL_SZ, S_GRACEFUL_FINISH_REQUIRED_V &gt;::Channels =  typename <a class="el" href="classipc_1_1session_1_1Session__base.html#a638232ef74a0eb80aeb4f027ee06f9bf">Base::Channels</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>See <a class="el" href="classipc_1_1session_1_1Session__mv.html" title="Implements the Session concept when it is in PEER state.">Session_mv</a> counterpart. </p>

<p class="definition">Definition at line <a class="el" href="ipc__session_2src_2ipc_2session_2detail_2server__session__impl_8hpp_source.html#l00202">202</a> of file <a class="el" href="ipc__session_2src_2ipc_2session_2detail_2server__session__impl_8hpp_source.html">server_session_impl.hpp</a>.</p>

</div>
</div>
<a id="a3bc90eb872c3f4d4ff65039a4a36b166" name="a3bc90eb872c3f4d4ff65039a4a36b166"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3bc90eb872c3f4d4ff65039a4a36b166">&#9670;&nbsp;</a></span>Master_structured_channel</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;schema::MqType S_MQ_TYPE_OR_NONE, bool S_TRANSMIT_NATIVE_HANDLES, typename Mdt_payload , schema::ShmType S_SHM_TYPE_OR_NONE, size_t S_SHM_MAX_HNDL_SZ, bool S_GRACEFUL_FINISH_REQUIRED_V&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classipc_1_1session_1_1Server__session__impl.html">ipc::session::Server_session_impl</a>&lt; S_MQ_TYPE_OR_NONE, S_TRANSMIT_NATIVE_HANDLES, Mdt_payload, S_SHM_TYPE_OR_NONE, S_SHM_MAX_HNDL_SZ, S_GRACEFUL_FINISH_REQUIRED_V &gt;::Master_structured_channel =  typename <a class="el" href="classipc_1_1session_1_1Session__base.html#a26d038e14e3c0e461e76de88c4ce76c5">Base::Master_structured_channel</a></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>See <a class="el" href="classipc_1_1session_1_1Session__base.html" title="Internal type containing data and types common to internal types Server_session_impl and Client_sessi...">Session_base</a>. </p>

<p class="definition">Definition at line <a class="el" href="ipc__session_2src_2ipc_2session_2detail_2server__session__impl_8hpp_source.html#l00376">376</a> of file <a class="el" href="ipc__session_2src_2ipc_2session_2detail_2server__session__impl_8hpp_source.html">server_session_impl.hpp</a>.</p>

</div>
</div>
<a id="ab6cfad1c0be9815dc5411cd20c131213" name="ab6cfad1c0be9815dc5411cd20c131213"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab6cfad1c0be9815dc5411cd20c131213">&#9670;&nbsp;</a></span>Master_structured_channel_ptr</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;schema::MqType S_MQ_TYPE_OR_NONE, bool S_TRANSMIT_NATIVE_HANDLES, typename Mdt_payload , schema::ShmType S_SHM_TYPE_OR_NONE, size_t S_SHM_MAX_HNDL_SZ, bool S_GRACEFUL_FINISH_REQUIRED_V&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classipc_1_1session_1_1Server__session__impl.html">ipc::session::Server_session_impl</a>&lt; S_MQ_TYPE_OR_NONE, S_TRANSMIT_NATIVE_HANDLES, Mdt_payload, S_SHM_TYPE_OR_NONE, S_SHM_MAX_HNDL_SZ, S_GRACEFUL_FINISH_REQUIRED_V &gt;::Master_structured_channel_ptr =  typename <a class="el" href="classipc_1_1session_1_1Session__base.html#af0ca2a01d7d0d92038aae56fc1cdd505">Base::Master_structured_channel_ptr</a></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>See <a class="el" href="classipc_1_1session_1_1Session__base.html" title="Internal type containing data and types common to internal types Server_session_impl and Client_sessi...">Session_base</a>. </p>

<p class="definition">Definition at line <a class="el" href="ipc__session_2src_2ipc_2session_2detail_2server__session__impl_8hpp_source.html#l00441">441</a> of file <a class="el" href="ipc__session_2src_2ipc_2session_2detail_2server__session__impl_8hpp_source.html">server_session_impl.hpp</a>.</p>

</div>
</div>
<a id="a7134fc9c4d26ba1fbc8e5da266d970e5" name="a7134fc9c4d26ba1fbc8e5da266d970e5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7134fc9c4d26ba1fbc8e5da266d970e5">&#9670;&nbsp;</a></span>Mdt_builder</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;schema::MqType S_MQ_TYPE_OR_NONE, bool S_TRANSMIT_NATIVE_HANDLES, typename Mdt_payload , schema::ShmType S_SHM_TYPE_OR_NONE, size_t S_SHM_MAX_HNDL_SZ, bool S_GRACEFUL_FINISH_REQUIRED_V&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classipc_1_1session_1_1Server__session__impl.html">ipc::session::Server_session_impl</a>&lt; S_MQ_TYPE_OR_NONE, S_TRANSMIT_NATIVE_HANDLES, Mdt_payload, S_SHM_TYPE_OR_NONE, S_SHM_MAX_HNDL_SZ, S_GRACEFUL_FINISH_REQUIRED_V &gt;::Mdt_builder =  typename <a class="el" href="classipc_1_1session_1_1Session__base.html#a7d68bbb8c0c09983619d563bca30bd45">Base::Mdt_builder</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>See <a class="el" href="classipc_1_1session_1_1Server__session__mv.html" title="Implements Session concept on the Server_app end: a Session that is emitted in almost-PEER state by l...">Server_session_mv</a> counterpart. </p>

<p class="definition">Definition at line <a class="el" href="ipc__session_2src_2ipc_2session_2detail_2server__session__impl_8hpp_source.html#l00211">211</a> of file <a class="el" href="ipc__session_2src_2ipc_2session_2detail_2server__session__impl_8hpp_source.html">server_session_impl.hpp</a>.</p>

</div>
</div>
<a id="ac4bc7e38574e0495af4887d2e6226b7a" name="ac4bc7e38574e0495af4887d2e6226b7a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac4bc7e38574e0495af4887d2e6226b7a">&#9670;&nbsp;</a></span>Mdt_builder_ptr</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;schema::MqType S_MQ_TYPE_OR_NONE, bool S_TRANSMIT_NATIVE_HANDLES, typename Mdt_payload , schema::ShmType S_SHM_TYPE_OR_NONE, size_t S_SHM_MAX_HNDL_SZ, bool S_GRACEFUL_FINISH_REQUIRED_V&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classipc_1_1session_1_1Server__session__impl.html">ipc::session::Server_session_impl</a>&lt; S_MQ_TYPE_OR_NONE, S_TRANSMIT_NATIVE_HANDLES, Mdt_payload, S_SHM_TYPE_OR_NONE, S_SHM_MAX_HNDL_SZ, S_GRACEFUL_FINISH_REQUIRED_V &gt;::Mdt_builder_ptr =  typename <a class="el" href="classipc_1_1session_1_1Session__base.html#a4a7a5b83f6ba8bd505685636eabc012b">Base::Mdt_builder_ptr</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>See <a class="el" href="classipc_1_1session_1_1Server__session__mv.html" title="Implements Session concept on the Server_app end: a Session that is emitted in almost-PEER state by l...">Server_session_mv</a> counterpart. </p>

<p class="definition">Definition at line <a class="el" href="ipc__session_2src_2ipc_2session_2detail_2server__session__impl_8hpp_source.html#l00214">214</a> of file <a class="el" href="ipc__session_2src_2ipc_2session_2detail_2server__session__impl_8hpp_source.html">server_session_impl.hpp</a>.</p>

</div>
</div>
<a id="aa9cd0c1e6792a4ee096b55b13b4db803" name="aa9cd0c1e6792a4ee096b55b13b4db803"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa9cd0c1e6792a4ee096b55b13b4db803">&#9670;&nbsp;</a></span>Mdt_payload_obj</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;schema::MqType S_MQ_TYPE_OR_NONE, bool S_TRANSMIT_NATIVE_HANDLES, typename Mdt_payload , schema::ShmType S_SHM_TYPE_OR_NONE, size_t S_SHM_MAX_HNDL_SZ, bool S_GRACEFUL_FINISH_REQUIRED_V&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classipc_1_1session_1_1Server__session__impl.html">ipc::session::Server_session_impl</a>&lt; S_MQ_TYPE_OR_NONE, S_TRANSMIT_NATIVE_HANDLES, Mdt_payload, S_SHM_TYPE_OR_NONE, S_SHM_MAX_HNDL_SZ, S_GRACEFUL_FINISH_REQUIRED_V &gt;::Mdt_payload_obj =  typename <a class="el" href="classipc_1_1session_1_1Session__base.html#a35234981ca87cc2f6b118b3e52452ea8">Base::Mdt_payload_obj</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>See <a class="el" href="classipc_1_1session_1_1Server__session__mv.html" title="Implements Session concept on the Server_app end: a Session that is emitted in almost-PEER state by l...">Server_session_mv</a> counterpart. </p>

<p class="definition">Definition at line <a class="el" href="ipc__session_2src_2ipc_2session_2detail_2server__session__impl_8hpp_source.html#l00205">205</a> of file <a class="el" href="ipc__session_2src_2ipc_2session_2detail_2server__session__impl_8hpp_source.html">server_session_impl.hpp</a>.</p>

</div>
</div>
<a id="a78e61f8681c7ec92fa19bae560763ab1" name="a78e61f8681c7ec92fa19bae560763ab1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a78e61f8681c7ec92fa19bae560763ab1">&#9670;&nbsp;</a></span>Mdt_reader_ptr</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;schema::MqType S_MQ_TYPE_OR_NONE, bool S_TRANSMIT_NATIVE_HANDLES, typename Mdt_payload , schema::ShmType S_SHM_TYPE_OR_NONE, size_t S_SHM_MAX_HNDL_SZ, bool S_GRACEFUL_FINISH_REQUIRED_V&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classipc_1_1session_1_1Server__session__impl.html">ipc::session::Server_session_impl</a>&lt; S_MQ_TYPE_OR_NONE, S_TRANSMIT_NATIVE_HANDLES, Mdt_payload, S_SHM_TYPE_OR_NONE, S_SHM_MAX_HNDL_SZ, S_GRACEFUL_FINISH_REQUIRED_V &gt;::Mdt_reader_ptr =  typename <a class="el" href="classipc_1_1session_1_1Session__base.html#ace4dab42adec6354cc66081dd218ac71">Base::Mdt_reader_ptr</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>See <a class="el" href="classipc_1_1session_1_1Server__session__mv.html" title="Implements Session concept on the Server_app end: a Session that is emitted in almost-PEER state by l...">Server_session_mv</a> counterpart. </p>

<p class="definition">Definition at line <a class="el" href="ipc__session_2src_2ipc_2session_2detail_2server__session__impl_8hpp_source.html#l00208">208</a> of file <a class="el" href="ipc__session_2src_2ipc_2session_2detail_2server__session__impl_8hpp_source.html">server_session_impl.hpp</a>.</p>

</div>
</div>
<a id="af8013f82c2441d07bc82eda7cc3ad835" name="af8013f82c2441d07bc82eda7cc3ad835"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af8013f82c2441d07bc82eda7cc3ad835">&#9670;&nbsp;</a></span>On_passive_open_channel_func</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;schema::MqType S_MQ_TYPE_OR_NONE, bool S_TRANSMIT_NATIVE_HANDLES, typename Mdt_payload , schema::ShmType S_SHM_TYPE_OR_NONE, size_t S_SHM_MAX_HNDL_SZ, bool S_GRACEFUL_FINISH_REQUIRED_V&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classipc_1_1session_1_1Server__session__impl.html">ipc::session::Server_session_impl</a>&lt; S_MQ_TYPE_OR_NONE, S_TRANSMIT_NATIVE_HANDLES, Mdt_payload, S_SHM_TYPE_OR_NONE, S_SHM_MAX_HNDL_SZ, S_GRACEFUL_FINISH_REQUIRED_V &gt;::On_passive_open_channel_func =  typename <a class="el" href="classipc_1_1session_1_1Session__base.html#a3c0824a54ef32915c5c5ea76481f2409">Base::On_passive_open_channel_func</a></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>See <a class="el" href="classipc_1_1session_1_1Session__base.html" title="Internal type containing data and types common to internal types Server_session_impl and Client_sessi...">Session_base</a>. </p>

<p class="definition">Definition at line <a class="el" href="ipc__session_2src_2ipc_2session_2detail_2server__session__impl_8hpp_source.html#l00438">438</a> of file <a class="el" href="ipc__session_2src_2ipc_2session_2detail_2server__session__impl_8hpp_source.html">server_session_impl.hpp</a>.</p>

</div>
</div>
<a id="ade0880c766185ca00d12c908c3ddd3ed" name="ade0880c766185ca00d12c908c3ddd3ed"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ade0880c766185ca00d12c908c3ddd3ed">&#9670;&nbsp;</a></span>Open_channel_req_ptr</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;schema::MqType S_MQ_TYPE_OR_NONE, bool S_TRANSMIT_NATIVE_HANDLES, typename Mdt_payload , schema::ShmType S_SHM_TYPE_OR_NONE, size_t S_SHM_MAX_HNDL_SZ, bool S_GRACEFUL_FINISH_REQUIRED_V&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classipc_1_1session_1_1Server__session__impl.html">ipc::session::Server_session_impl</a>&lt; S_MQ_TYPE_OR_NONE, S_TRANSMIT_NATIVE_HANDLES, Mdt_payload, S_SHM_TYPE_OR_NONE, S_SHM_MAX_HNDL_SZ, S_GRACEFUL_FINISH_REQUIRED_V &gt;::Open_channel_req_ptr =  boost::shared_ptr&lt;<a class="el" href="structipc_1_1session_1_1Server__session__impl_1_1Open__channel__req.html">Open_channel_req</a>&gt;</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Short-hand for ref-counted pointer to <a class="el" href="structipc_1_1session_1_1Server__session__impl_1_1Open__channel__req.html" title="An open-channel request out-message.">Open_channel_req</a>. </p>
<dl class="section see"><dt>See also</dt><dd>Client_session_impl::Open_channel_req doc header for info on the true nature of such <code>shared_ptr</code> as returned by us. </dd></dl>

<p class="definition">Definition at line <a class="el" href="ipc__session_2src_2ipc_2session_2detail_2server__session__impl_8hpp_source.html#l00472">472</a> of file <a class="el" href="ipc__session_2src_2ipc_2session_2detail_2server__session__impl_8hpp_source.html">server_session_impl.hpp</a>.</p>

</div>
</div>
<a id="aa72ad11c33a4d11d5e3f0480ce0a6ff1" name="aa72ad11c33a4d11d5e3f0480ce0a6ff1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa72ad11c33a4d11d5e3f0480ce0a6ff1">&#9670;&nbsp;</a></span>Persistent_mq_handle_from_cfg</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;schema::MqType S_MQ_TYPE_OR_NONE, bool S_TRANSMIT_NATIVE_HANDLES, typename Mdt_payload , schema::ShmType S_SHM_TYPE_OR_NONE, size_t S_SHM_MAX_HNDL_SZ, bool S_GRACEFUL_FINISH_REQUIRED_V&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classipc_1_1session_1_1Server__session__impl.html">ipc::session::Server_session_impl</a>&lt; S_MQ_TYPE_OR_NONE, S_TRANSMIT_NATIVE_HANDLES, Mdt_payload, S_SHM_TYPE_OR_NONE, S_SHM_MAX_HNDL_SZ, S_GRACEFUL_FINISH_REQUIRED_V &gt;::Persistent_mq_handle_from_cfg =  typename <a class="el" href="classipc_1_1session_1_1Session__base.html#a848c0f5247644ada0f8b0ab816eedda8">Base::Persistent_mq_handle_from_cfg</a></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>See <a class="el" href="classipc_1_1session_1_1Session__base.html" title="Internal type containing data and types common to internal types Server_session_impl and Client_sessi...">Session_base</a>. </p>

<p class="definition">Definition at line <a class="el" href="ipc__session_2src_2ipc_2session_2detail_2server__session__impl_8hpp_source.html#l00435">435</a> of file <a class="el" href="ipc__session_2src_2ipc_2session_2detail_2server__session__impl_8hpp_source.html">server_session_impl.hpp</a>.</p>

</div>
</div>
<a id="a3797b21c6b9c430471e3d9835acb2979" name="a3797b21c6b9c430471e3d9835acb2979"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3797b21c6b9c430471e3d9835acb2979">&#9670;&nbsp;</a></span>Session_base_obj</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;schema::MqType S_MQ_TYPE_OR_NONE, bool S_TRANSMIT_NATIVE_HANDLES, typename Mdt_payload , schema::ShmType S_SHM_TYPE_OR_NONE, size_t S_SHM_MAX_HNDL_SZ, bool S_GRACEFUL_FINISH_REQUIRED_V&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classipc_1_1session_1_1Server__session__impl.html">ipc::session::Server_session_impl</a>&lt; S_MQ_TYPE_OR_NONE, S_TRANSMIT_NATIVE_HANDLES, Mdt_payload, S_SHM_TYPE_OR_NONE, S_SHM_MAX_HNDL_SZ, S_GRACEFUL_FINISH_REQUIRED_V &gt;::Session_base_obj =  <a class="el" href="classipc_1_1session_1_1Server__session__impl.html#a80daf8c8041d8d510f4712156732b09d">Base</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Short-hand for <a class="el" href="classipc_1_1session_1_1Session__base.html" title="Internal type containing data and types common to internal types Server_session_impl and Client_sessi...">Session_base</a> super-class. </p>

<p class="definition">Definition at line <a class="el" href="ipc__session_2src_2ipc_2session_2detail_2server__session__impl_8hpp_source.html#l00196">196</a> of file <a class="el" href="ipc__session_2src_2ipc_2session_2detail_2server__session__impl_8hpp_source.html">server_session_impl.hpp</a>.</p>

</div>
</div>
<a id="abff6feea533de655f0cd8017d6ea3293" name="abff6feea533de655f0cd8017d6ea3293"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abff6feea533de655f0cd8017d6ea3293">&#9670;&nbsp;</a></span>Structured_msg_builder_config</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;schema::MqType S_MQ_TYPE_OR_NONE, bool S_TRANSMIT_NATIVE_HANDLES, typename Mdt_payload , schema::ShmType S_SHM_TYPE_OR_NONE, size_t S_SHM_MAX_HNDL_SZ, bool S_GRACEFUL_FINISH_REQUIRED_V&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classipc_1_1session_1_1Server__session__impl.html">ipc::session::Server_session_impl</a>&lt; S_MQ_TYPE_OR_NONE, S_TRANSMIT_NATIVE_HANDLES, Mdt_payload, S_SHM_TYPE_OR_NONE, S_SHM_MAX_HNDL_SZ, S_GRACEFUL_FINISH_REQUIRED_V &gt;::Structured_msg_builder_config =  typename <a class="el" href="classipc_1_1session_1_1Session__base.html#aee0db48505c84d3553b7110a9a815036">Base::Structured_msg_builder_config</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>See <a class="el" href="classipc_1_1session_1_1Session__mv.html" title="Implements the Session concept when it is in PEER state.">Session_mv</a> counterpart. </p>

<p class="definition">Definition at line <a class="el" href="ipc__session_2src_2ipc_2session_2detail_2server__session__impl_8hpp_source.html#l00217">217</a> of file <a class="el" href="ipc__session_2src_2ipc_2session_2detail_2server__session__impl_8hpp_source.html">server_session_impl.hpp</a>.</p>

</div>
</div>
<a id="ab8612a76df11f9db0d4f335848cda822" name="ab8612a76df11f9db0d4f335848cda822"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab8612a76df11f9db0d4f335848cda822">&#9670;&nbsp;</a></span>Structured_msg_reader_config</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;schema::MqType S_MQ_TYPE_OR_NONE, bool S_TRANSMIT_NATIVE_HANDLES, typename Mdt_payload , schema::ShmType S_SHM_TYPE_OR_NONE, size_t S_SHM_MAX_HNDL_SZ, bool S_GRACEFUL_FINISH_REQUIRED_V&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classipc_1_1session_1_1Server__session__impl.html">ipc::session::Server_session_impl</a>&lt; S_MQ_TYPE_OR_NONE, S_TRANSMIT_NATIVE_HANDLES, Mdt_payload, S_SHM_TYPE_OR_NONE, S_SHM_MAX_HNDL_SZ, S_GRACEFUL_FINISH_REQUIRED_V &gt;::Structured_msg_reader_config =  typename <a class="el" href="classipc_1_1session_1_1Session__base.html#abd854f2b9316361ef18f15610c242d4b">Base::Structured_msg_reader_config</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>See <a class="el" href="classipc_1_1session_1_1Session__mv.html" title="Implements the Session concept when it is in PEER state.">Session_mv</a> counterpart. </p>

<p class="definition">Definition at line <a class="el" href="ipc__session_2src_2ipc_2session_2detail_2server__session__impl_8hpp_source.html#l00220">220</a> of file <a class="el" href="ipc__session_2src_2ipc_2session_2detail_2server__session__impl_8hpp_source.html">server_session_impl.hpp</a>.</p>

</div>
</div>
<h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="a424215b95b49fea0b3b3986688395158" name="a424215b95b49fea0b3b3986688395158"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a424215b95b49fea0b3b3986688395158">&#9670;&nbsp;</a></span>Server_session_impl()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;schema::MqType S_MQ_TYPE_OR_NONE, bool S_TRANSMIT_NATIVE_HANDLES, typename Mdt_payload , schema::ShmType S_SHM_TYPE_OR_NONE, size_t S_SHM_MAX_HNDL_SZ, bool S_GRACEFUL_FINISH_REQUIRED_V&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classipc_1_1session_1_1Server__session__impl.html">ipc::session::Server_session_impl</a>&lt; S_MQ_TYPE_OR_NONE, S_TRANSMIT_NATIVE_HANDLES, Mdt_payload, S_SHM_TYPE_OR_NONE, S_SHM_MAX_HNDL_SZ, S_GRACEFUL_FINISH_REQUIRED_V &gt;::Server_session_impl </td>
          <td>(</td>
          <td class="paramtype">flow::log::Logger *&#160;</td>
          <td class="paramname"><em>logger_ptr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structipc_1_1session_1_1Server__app.html">Server_app</a> &amp;&#160;</td>
          <td class="paramname"><em>srv_app_ref</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classipc_1_1transport_1_1sync__io_1_1Native__socket__stream.html">transport::sync_io::Native_socket_stream</a> &amp;&amp;&#160;</td>
          <td class="paramname"><em>master_channel_sock_stm</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">explicit</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>For use by internal user <a class="el" href="classipc_1_1session_1_1Session__server.html" title="To be instantiated typically once in a given process, an object of this type asynchronously listens f...">Session_server</a>: See <a class="el" href="classipc_1_1session_1_1Server__session__mv.html" title="Implements Session concept on the Server_app end: a Session that is emitted in almost-PEER state by l...">Server_session_mv</a> counterpart. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">logger_ptr</td><td>See <a class="el" href="classipc_1_1session_1_1Server__session__mv.html" title="Implements Session concept on the Server_app end: a Session that is emitted in almost-PEER state by l...">Server_session_mv</a> counterpart. </td></tr>
    <tr><td class="paramname">srv_app_ref</td><td>See <a class="el" href="classipc_1_1session_1_1Server__session__mv.html" title="Implements Session concept on the Server_app end: a Session that is emitted in almost-PEER state by l...">Server_session_mv</a> counterpart. </td></tr>
    <tr><td class="paramname">master_channel_sock_stm</td><td>See <a class="el" href="classipc_1_1session_1_1Server__session__mv.html" title="Implements Session concept on the Server_app end: a Session that is emitted in almost-PEER state by l...">Server_session_mv</a> counterpart. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="ipc__session_2src_2ipc_2session_2detail_2server__session__impl_8hpp_source.html#l00681">681</a> of file <a class="el" href="ipc__session_2src_2ipc_2session_2detail_2server__session__impl_8hpp_source.html">server_session_impl.hpp</a>.</p>

<p class="reference">References <a class="el" href="ipc__session_2src_2ipc_2session_2detail_2server__session__impl_8hpp_source.html#l00643">ipc::session::Server_session_impl&lt; S_MQ_TYPE_OR_NONE, S_TRANSMIT_NATIVE_HANDLES, Mdt_payload, S_SHM_TYPE_OR_NONE, S_SHM_MAX_HNDL_SZ, S_GRACEFUL_FINISH_REQUIRED_V &gt;::m_async_worker</a>, and <a class="el" href="ipc__session_2src_2ipc_2session_2detail_2server__session__impl_8hpp_source.html#l00611">ipc::session::Server_session_impl&lt; S_MQ_TYPE_OR_NONE, S_TRANSMIT_NATIVE_HANDLES, Mdt_payload, S_SHM_TYPE_OR_NONE, S_SHM_MAX_HNDL_SZ, S_GRACEFUL_FINISH_REQUIRED_V &gt;::m_master_sock_stm</a>.</p>

</div>
</div>
<a id="a145389df1784d5242adf69e2cc9826cd" name="a145389df1784d5242adf69e2cc9826cd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a145389df1784d5242adf69e2cc9826cd">&#9670;&nbsp;</a></span>~Server_session_impl()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;schema::MqType S_MQ_TYPE_OR_NONE, bool S_TRANSMIT_NATIVE_HANDLES, typename Mdt_payload , schema::ShmType S_SHM_TYPE_OR_NONE, size_t S_SHM_MAX_HNDL_SZ, bool S_GRACEFUL_FINISH_REQUIRED_V&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classipc_1_1session_1_1Server__session__impl.html">ipc::session::Server_session_impl</a>&lt; S_MQ_TYPE_OR_NONE, S_TRANSMIT_NATIVE_HANDLES, Mdt_payload, S_SHM_TYPE_OR_NONE, S_SHM_MAX_HNDL_SZ, S_GRACEFUL_FINISH_REQUIRED_V &gt;::~<a class="el" href="classipc_1_1session_1_1Server__session__impl.html">Server_session_impl</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>See <a class="el" href="classipc_1_1session_1_1Server__session__mv.html" title="Implements Session concept on the Server_app end: a Session that is emitted in almost-PEER state by l...">Server_session_mv</a> counterpart. </p>

<p class="definition">Definition at line <a class="el" href="ipc__session_2src_2ipc_2session_2detail_2server__session__impl_8hpp_source.html#l00784">784</a> of file <a class="el" href="ipc__session_2src_2ipc_2session_2detail_2server__session__impl_8hpp_source.html">server_session_impl.hpp</a>.</p>

<p class="reference">References <a class="el" href="namespaceipc_1_1session_1_1error.html#a0708d4bec9ae853f4d7e3d7822fc8f2fafe29343445a7bf167cc186a44bd2c6ed">ipc::session::error::S_OBJECT_SHUTDOWN_ABORTED_COMPLETION_HANDLER</a>.</p>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="aee35d521d9997d48f6b5565730e60e93" name="aee35d521d9997d48f6b5565730e60e93"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aee35d521d9997d48f6b5565730e60e93">&#9670;&nbsp;</a></span>async_accept_log_in()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;schema::MqType S_MQ_TYPE_OR_NONE, bool S_TRANSMIT_NATIVE_HANDLES, typename Mdt_payload , schema::ShmType S_SHM_TYPE_OR_NONE, size_t S_SHM_MAX_HNDL_SZ, bool S_GRACEFUL_FINISH_REQUIRED_V&gt; </div>
<div class="memtemplate">
template&lt;typename Session_server_impl_t , typename Task_err , typename Cli_app_lookup_func , typename Cli_namespace_func , typename Pre_rsp_setup_func , typename N_init_channels_by_srv_req_func , typename Mdt_load_func &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classipc_1_1session_1_1Server__session__impl.html">ipc::session::Server_session_impl</a>&lt; S_MQ_TYPE_OR_NONE, S_TRANSMIT_NATIVE_HANDLES, Mdt_payload, S_SHM_TYPE_OR_NONE, S_SHM_MAX_HNDL_SZ, S_GRACEFUL_FINISH_REQUIRED_V &gt;::async_accept_log_in </td>
          <td>(</td>
          <td class="paramtype">Session_server_impl_t *&#160;</td>
          <td class="paramname"><em>srv</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classipc_1_1session_1_1Server__session__impl.html#a75df7061f9c57660f9fb944d83da416b">Channels</a> *&#160;</td>
          <td class="paramname"><em>init_channels_by_srv_req</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classipc_1_1session_1_1Server__session__impl.html#a78e61f8681c7ec92fa19bae560763ab1">Mdt_reader_ptr</a> *&#160;</td>
          <td class="paramname"><em>mdt_from_cli_or_null</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classipc_1_1session_1_1Server__session__impl.html#a75df7061f9c57660f9fb944d83da416b">Channels</a> *&#160;</td>
          <td class="paramname"><em>init_channels_by_cli_req</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Cli_app_lookup_func &amp;&amp;&#160;</td>
          <td class="paramname"><em>cli_app_lookup_func</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Cli_namespace_func &amp;&amp;&#160;</td>
          <td class="paramname"><em>cli_namespace_func</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Pre_rsp_setup_func &amp;&amp;&#160;</td>
          <td class="paramname"><em>pre_rsp_setup_func</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">N_init_channels_by_srv_req_func &amp;&amp;&#160;</td>
          <td class="paramname"><em>n_init_channels_by_srv_req_func</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Mdt_load_func &amp;&amp;&#160;</td>
          <td class="paramname"><em>mdt_load_func</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Task_err &amp;&amp;&#160;</td>
          <td class="paramname"><em>on_done_func</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>For use by internal user <a class="el" href="classipc_1_1session_1_1Session__server.html" title="To be instantiated typically once in a given process, an object of this type asynchronously listens f...">Session_server</a>: See <a class="el" href="classipc_1_1session_1_1Server__session__mv.html" title="Implements Session concept on the Server_app end: a Session that is emitted in almost-PEER state by l...">Server_session_mv</a> counterpart. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">srv</td><td>See <a class="el" href="classipc_1_1session_1_1Server__session__mv.html" title="Implements Session concept on the Server_app end: a Session that is emitted in almost-PEER state by l...">Server_session_mv</a> counterpart. </td></tr>
    <tr><td class="paramname">init_channels_by_srv_req</td><td>See <a class="el" href="classipc_1_1session_1_1Server__session__mv.html" title="Implements Session concept on the Server_app end: a Session that is emitted in almost-PEER state by l...">Server_session_mv</a> counterpart. </td></tr>
    <tr><td class="paramname">mdt_from_cli_or_null</td><td>See <a class="el" href="classipc_1_1session_1_1Server__session__mv.html" title="Implements Session concept on the Server_app end: a Session that is emitted in almost-PEER state by l...">Server_session_mv</a> counterpart. </td></tr>
    <tr><td class="paramname">init_channels_by_cli_req</td><td>See <a class="el" href="classipc_1_1session_1_1Server__session__mv.html" title="Implements Session concept on the Server_app end: a Session that is emitted in almost-PEER state by l...">Server_session_mv</a> counterpart. </td></tr>
    <tr><td class="paramname">cli_app_lookup_func</td><td>See <a class="el" href="classipc_1_1session_1_1Server__session__mv.html" title="Implements Session concept on the Server_app end: a Session that is emitted in almost-PEER state by l...">Server_session_mv</a> counterpart. </td></tr>
    <tr><td class="paramname">cli_namespace_func</td><td>See <a class="el" href="classipc_1_1session_1_1Server__session__mv.html" title="Implements Session concept on the Server_app end: a Session that is emitted in almost-PEER state by l...">Server_session_mv</a> counterpart. </td></tr>
    <tr><td class="paramname">pre_rsp_setup_func</td><td>See <a class="el" href="classipc_1_1session_1_1Server__session__mv.html" title="Implements Session concept on the Server_app end: a Session that is emitted in almost-PEER state by l...">Server_session_mv</a> counterpart. </td></tr>
    <tr><td class="paramname">n_init_channels_by_srv_req_func</td><td>See <a class="el" href="classipc_1_1session_1_1Server__session__mv.html" title="Implements Session concept on the Server_app end: a Session that is emitted in almost-PEER state by l...">Server_session_mv</a> counterpart. </td></tr>
    <tr><td class="paramname">mdt_load_func</td><td>See <a class="el" href="classipc_1_1session_1_1Server__session__mv.html" title="Implements Session concept on the Server_app end: a Session that is emitted in almost-PEER state by l...">Server_session_mv</a> counterpart. </td></tr>
    <tr><td class="paramname">on_done_func</td><td>See <a class="el" href="classipc_1_1session_1_1Server__session__mv.html" title="Implements Session concept on the Server_app end: a Session that is emitted in almost-PEER state by l...">Server_session_mv</a> counterpart. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="ipc__session_2src_2ipc_2session_2detail_2server__session__impl_8hpp_source.html#l01581">1581</a> of file <a class="el" href="ipc__session_2src_2ipc_2session_2detail_2server__session__impl_8hpp_source.html">server_session_impl.hpp</a>.</p>

<p class="reference">References <a class="el" href="ipc__core_2src_2ipc_2transport_2channel_8hpp_source.html#l02211">ipc::transport::Socket_stream_channel&lt; SIO &gt;::remote_peer_process_credentials()</a>, <a class="el" href="namespaceipc_1_1session_1_1error.html#a0708d4bec9ae853f4d7e3d7822fc8f2fac416e988563e44bf15fc6a81743eef53">ipc::session::error::S_INVALID_ARGUMENT</a>, <a class="el" href="channel__base_8hpp_source.html#l00157">ipc::transport::struc::Channel_base::S_SERIALIZE_VIA_HEAP</a>, <a class="el" href="namespaceipc_1_1session_1_1error.html#a0708d4bec9ae853f4d7e3d7822fc8f2faa195e468548ba9602c27590f2d6d49f0">ipc::session::error::S_SERVER_MASTER_LOG_IN_REQUEST_CLIENT_APP_DISALLOWED_OR_UNKNOWN</a>, <a class="el" href="namespaceipc_1_1session_1_1error.html#a0708d4bec9ae853f4d7e3d7822fc8f2fa3f305ed5a242f067c9116216c0674264">ipc::session::error::S_SERVER_MASTER_LOG_IN_REQUEST_CLIENT_APP_INCONSISTENT_CREDS</a>, <a class="el" href="namespaceipc_1_1session_1_1error.html#a0708d4bec9ae853f4d7e3d7822fc8f2fac734bd48bbfe30867f627363a8d5afc4">ipc::session::error::S_SERVER_MASTER_LOG_IN_REQUEST_CONFIG_MISMATCH</a>, <a class="el" href="namespaceipc_1_1session_1_1error.html#a0708d4bec9ae853f4d7e3d7822fc8f2fa10d32cf1382fb003f09a6df2da408574">ipc::session::error::S_SESSION_OPEN_CHANNEL_SERVER_CANNOT_PROCEED_RESOURCE_UNAVAILABLE</a>, and <a class="el" href="shared__name_8cpp_source.html#l00140">ipc::util::Shared_name::str()</a>.</p>
<div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="classipc_1_1session_1_1Server__session__impl_aee35d521d9997d48f6b5565730e60e93_cgraph.svg" width="364" height="107"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe>
</div>
</div>

</div>
</div>
<a id="a149a11c639d26b8a21279724079f6c2a" name="a149a11c639d26b8a21279724079f6c2a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a149a11c639d26b8a21279724079f6c2a">&#9670;&nbsp;</a></span>async_worker()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;schema::MqType S_MQ_TYPE_OR_NONE, bool S_TRANSMIT_NATIVE_HANDLES, typename Mdt_payload , schema::ShmType S_SHM_TYPE_OR_NONE, size_t S_SHM_MAX_HNDL_SZ, bool S_GRACEFUL_FINISH_REQUIRED_V&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">flow::async::Single_thread_task_loop * <a class="el" href="classipc_1_1session_1_1Server__session__impl.html">ipc::session::Server_session_impl</a>&lt; S_MQ_TYPE_OR_NONE, S_TRANSMIT_NATIVE_HANDLES, Mdt_payload, S_SHM_TYPE_OR_NONE, S_SHM_MAX_HNDL_SZ, S_GRACEFUL_FINISH_REQUIRED_V &gt;::async_worker</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Utility for sub-classes: provides ability to schedule or post tasks onto thread W. </p>
<dl class="section return"><dt>Returns</dt><dd>See above. </dd></dl>

<p class="definition">Definition at line <a class="el" href="ipc__session_2src_2ipc_2session_2detail_2server__session__impl_8hpp_source.html#l02188">2188</a> of file <a class="el" href="ipc__session_2src_2ipc_2session_2detail_2server__session__impl_8hpp_source.html">server_session_impl.hpp</a>.</p>

</div>
</div>
<a id="a0992cbc57bf346d6b8df191f2dcb9188" name="a0992cbc57bf346d6b8df191f2dcb9188"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0992cbc57bf346d6b8df191f2dcb9188">&#9670;&nbsp;</a></span>base()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;schema::MqType S_MQ_TYPE_OR_NONE, bool S_TRANSMIT_NATIVE_HANDLES, typename Mdt_payload , schema::ShmType S_SHM_TYPE_OR_NONE, size_t S_SHM_MAX_HNDL_SZ, bool S_GRACEFUL_FINISH_REQUIRED_V&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classipc_1_1session_1_1Server__session__impl.html">Server_session_impl</a>&lt; S_MQ_TYPE_OR_NONE, S_TRANSMIT_NATIVE_HANDLES, Mdt_payload, S_SHM_TYPE_OR_NONE, S_SHM_MAX_HNDL_SZ, S_GRACEFUL_FINISH_REQUIRED_V &gt;<a class="el" href="classipc_1_1session_1_1Server__session__impl.html#a80daf8c8041d8d510f4712156732b09d">::Base</a> &amp; <a class="el" href="classipc_1_1session_1_1Server__session__impl.html">ipc::session::Server_session_impl</a>&lt; S_MQ_TYPE_OR_NONE, S_TRANSMIT_NATIVE_HANDLES, Mdt_payload, S_SHM_TYPE_OR_NONE, S_SHM_MAX_HNDL_SZ, S_GRACEFUL_FINISH_REQUIRED_V &gt;::base</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>See <a class="el" href="classipc_1_1session_1_1Server__session__mv.html" title="Implements Session concept on the Server_app end: a Session that is emitted in almost-PEER state by l...">Server_session_mv</a> counterpart. </p>
<dl class="section return"><dt>Returns</dt><dd>See <a class="el" href="classipc_1_1session_1_1Server__session__mv.html" title="Implements Session concept on the Server_app end: a Session that is emitted in almost-PEER state by l...">Server_session_mv</a> counterpart. </dd></dl>

<p class="definition">Definition at line <a class="el" href="ipc__session_2src_2ipc_2session_2detail_2server__session__impl_8hpp_source.html#l02175">2175</a> of file <a class="el" href="ipc__session_2src_2ipc_2session_2detail_2server__session__impl_8hpp_source.html">server_session_impl.hpp</a>.</p>

</div>
</div>
<a id="a3deaeacf53a8fc63ed010394ef82c54c" name="a3deaeacf53a8fc63ed010394ef82c54c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3deaeacf53a8fc63ed010394ef82c54c">&#9670;&nbsp;</a></span>client_app()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;schema::MqType S_MQ_TYPE_OR_NONE, bool S_TRANSMIT_NATIVE_HANDLES, typename Mdt_payload , schema::ShmType S_SHM_TYPE_OR_NONE, size_t S_SHM_MAX_HNDL_SZ, bool S_GRACEFUL_FINISH_REQUIRED_V&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="structipc_1_1session_1_1Client__app.html">Client_app</a> * <a class="el" href="classipc_1_1session_1_1Server__session__impl.html">ipc::session::Server_session_impl</a>&lt; S_MQ_TYPE_OR_NONE, S_TRANSMIT_NATIVE_HANDLES, Mdt_payload, S_SHM_TYPE_OR_NONE, S_SHM_MAX_HNDL_SZ, S_GRACEFUL_FINISH_REQUIRED_V &gt;::client_app</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>See <a class="el" href="classipc_1_1session_1_1Server__session__mv.html" title="Implements Session concept on the Server_app end: a Session that is emitted in almost-PEER state by l...">Server_session_mv</a> counterpart. </p>
<dl class="section return"><dt>Returns</dt><dd>See <a class="el" href="classipc_1_1session_1_1Server__session__mv.html" title="Implements Session concept on the Server_app end: a Session that is emitted in almost-PEER state by l...">Server_session_mv</a> counterpart. </dd></dl>

<p class="definition">Definition at line <a class="el" href="ipc__session_2src_2ipc_2session_2detail_2server__session__impl_8hpp_source.html#l00829">829</a> of file <a class="el" href="ipc__session_2src_2ipc_2session_2detail_2server__session__impl_8hpp_source.html">server_session_impl.hpp</a>.</p>

</div>
</div>
<a id="a6f756d12f9e2b2cc3269564ba49bb354" name="a6f756d12f9e2b2cc3269564ba49bb354"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6f756d12f9e2b2cc3269564ba49bb354">&#9670;&nbsp;</a></span>create_channel_and_resources()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;schema::MqType S_MQ_TYPE_OR_NONE, bool S_TRANSMIT_NATIVE_HANDLES, typename Mdt_payload , schema::ShmType S_SHM_TYPE_OR_NONE, size_t S_SHM_MAX_HNDL_SZ, bool S_GRACEFUL_FINISH_REQUIRED_V&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classipc_1_1session_1_1Server__session__impl.html">ipc::session::Server_session_impl</a>&lt; S_MQ_TYPE_OR_NONE, S_TRANSMIT_NATIVE_HANDLES, Mdt_payload, S_SHM_TYPE_OR_NONE, S_SHM_MAX_HNDL_SZ, S_GRACEFUL_FINISH_REQUIRED_V &gt;::create_channel_and_resources </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespaceipc_1_1session.html#a6d07d9996af19e57eb42416e914110ea">Shared_name</a> *&#160;</td>
          <td class="paramname"><em>mq_name_c2s_or_none_ptr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceipc_1_1session.html#a6d07d9996af19e57eb42416e914110ea">Shared_name</a> *&#160;</td>
          <td class="paramname"><em>mq_name_s2c_or_none_ptr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structipc_1_1util_1_1Native__handle.html">util::Native_handle</a> *&#160;</td>
          <td class="paramname"><em>remote_hndl_or_null_ptr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classipc_1_1session_1_1Server__session__impl.html#a7c969c3a1007f8e4ba3ad1c1acd6c290">Channel_obj</a> *&#160;</td>
          <td class="paramname"><em>opened_channel_ptr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>active_else_passive</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>In thread W acquires the needed shared sources (MQs and/or <code>Native_handle</code> pair as of this writing) and creates local <a class="el" href="classipc_1_1session_1_1Server__session__impl.html#a7c969c3a1007f8e4ba3ad1c1acd6c290" title="See Server_session_mv counterpart.">Channel_obj</a> to emit to the user thus completing the channel-open on this side. </p>
<p >If active-open on our part, we do this immediately in <a class="el" href="classipc_1_1session_1_1Server__session__impl.html#a138956765a655240080491157f316167" title="See Server_session_mv counterpart.">mdt_builder()</a> &ndash; before <a class="el" href="classipc_1_1session_1_1Server__session__impl.html#a45a5ae92b706ea539c27be0d19a303c4" title="See Server_session_mv counterpart.">open_channel()</a> even &ndash; but before the <a class="el" href="classipc_1_1session_1_1Server__session__impl.html#a7c969c3a1007f8e4ba3ad1c1acd6c290" title="See Server_session_mv counterpart.">Channel_obj</a> can be emitted to the user (1) <a class="el" href="classipc_1_1session_1_1Server__session__impl.html#a45a5ae92b706ea539c27be0d19a303c4" title="See Server_session_mv counterpart.">open_channel()</a> must actually be called (obv) and (2) client must respond OK to our open-channel-to-client request out-message. If passive-open, we do this upon receiving client's open-channel-to-server request, before replying with our OK. Either way we are the ones acquiring the resources, then we send names/refs to those resources to client.</p>
<p >Returns <code>false</code> if and only if could not acquire resources.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">mq_name_c2s_or_none_ptr</td><td>If <a class="el" href="classipc_1_1session_1_1Server__session__impl.html#a005fcbc9ee215531c03d17fcc49ef544" title="See Server_session_mv counterpart.">S_MQS_ENABLED</a> this out-arg is the (non-empty) name of the client-&gt;server unidirectional MQ for the channel. Else ignored. Must be empty at entry or behavior undefined (assertion may trip). </td></tr>
    <tr><td class="paramname">mq_name_s2c_or_none_ptr</td><td>Like the preceding but opposite-direction (server-&gt;client). </td></tr>
    <tr><td class="paramname">remote_hndl_or_null_ptr</td><td>If <a class="el" href="classipc_1_1session_1_1Server__session__impl.html#abfa7d61030e1d40cdc0085afacb43b6c" title="See Server_session_mv counterpart.">S_SOCKET_STREAM_ENABLED</a> this out-arg is the pre-connected <code>Native_handle</code> to send to the other side; we keep the other end and shove it into the <a class="el" href="classipc_1_1session_1_1Server__session__impl.html#a7c969c3a1007f8e4ba3ad1c1acd6c290" title="See Server_session_mv counterpart.">Channel_obj</a> out-arg. Else ignored. Must be <code>.null()</code> or behavior undefined (assertion may trip). </td></tr>
    <tr><td class="paramname">opened_channel_ptr</td><td>Target <a class="el" href="classipc_1_1session_1_1Server__session__impl.html#a7c969c3a1007f8e4ba3ad1c1acd6c290" title="See Server_session_mv counterpart.">Channel_obj</a> we shall try to move-to PEER state. It'll be left unmodified if we return <code>false</code>. </td></tr>
    <tr><td class="paramname">active_else_passive</td><td><code>true</code> if this is from <a class="el" href="classipc_1_1session_1_1Server__session__impl.html#a45a5ae92b706ea539c27be0d19a303c4" title="See Server_session_mv counterpart.">open_channel()</a>; <code>false</code> if from <a class="el" href="classipc_1_1session_1_1Server__session__impl.html#a804c629b2da8898376f071db499a2173" title="In thread W, handler for m_master_channel receiving a passive-open (a/k/a open-channel-to-server) req...">on_master_channel_open_channel_req()</a>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> on success; <code>false</code> if a resource could not be acquired. </dd></dl>

<p class="definition">Definition at line <a class="el" href="ipc__session_2src_2ipc_2session_2detail_2server__session__impl_8hpp_source.html#l01351">1351</a> of file <a class="el" href="ipc__session_2src_2ipc_2session_2detail_2server__session__impl_8hpp_source.html">server_session_impl.hpp</a>.</p>

</div>
</div>
<a id="a28503a7c6622aacc7e08d4904da10da3" name="a28503a7c6622aacc7e08d4904da10da3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a28503a7c6622aacc7e08d4904da10da3">&#9670;&nbsp;</a></span>dtor_async_worker_stop()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;schema::MqType S_MQ_TYPE_OR_NONE, bool S_TRANSMIT_NATIVE_HANDLES, typename Mdt_payload , schema::ShmType S_SHM_TYPE_OR_NONE, size_t S_SHM_MAX_HNDL_SZ, bool S_GRACEFUL_FINISH_REQUIRED_V&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classipc_1_1session_1_1Server__session__impl.html">ipc::session::Server_session_impl</a>&lt; S_MQ_TYPE_OR_NONE, S_TRANSMIT_NATIVE_HANDLES, Mdt_payload, S_SHM_TYPE_OR_NONE, S_SHM_MAX_HNDL_SZ, S_GRACEFUL_FINISH_REQUIRED_V &gt;::dtor_async_worker_stop</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Analogous to <a class="el" href="classipc_1_1session_1_1Client__session__impl.html#afb09c3a23b7e63938b9a494cec6e769b" title="Synchronously stops async_worker() loop, the post-condition being that thread W has been joined; no t...">Client_session_impl::dtor_async_worker_stop()</a>. See that doc header. </p>

<p class="definition">Definition at line <a class="el" href="ipc__session_2src_2ipc_2session_2detail_2server__session__impl_8hpp_source.html#l00708">708</a> of file <a class="el" href="ipc__session_2src_2ipc_2session_2detail_2server__session__impl_8hpp_source.html">server_session_impl.hpp</a>.</p>

<p class="reference">References <a class="el" href="session__base_8hpp_source.html#l01126">ipc::session::Session_base&lt; S_MQ_TYPE_OR_NONE, S_TRANSMIT_NATIVE_HANDLES, Mdt_payload &gt;::Graceful_finisher::on_dtor_start()</a>.</p>
<div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="classipc_1_1session_1_1Server__session__impl_a28503a7c6622aacc7e08d4904da10da3_cgraph.svg" width="378" height="59"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe>
</div>
</div>

</div>
</div>
<a id="ae33e5c8ca6904844689e78ee764bc2da" name="ae33e5c8ca6904844689e78ee764bc2da"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae33e5c8ca6904844689e78ee764bc2da">&#9670;&nbsp;</a></span>handlers_are_set()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;schema::MqType S_MQ_TYPE_OR_NONE, bool S_TRANSMIT_NATIVE_HANDLES, typename Mdt_payload , schema::ShmType S_SHM_TYPE_OR_NONE, size_t S_SHM_MAX_HNDL_SZ, bool S_GRACEFUL_FINISH_REQUIRED_V&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classipc_1_1session_1_1Server__session__impl.html">ipc::session::Server_session_impl</a>&lt; S_MQ_TYPE_OR_NONE, S_TRANSMIT_NATIVE_HANDLES, Mdt_payload, S_SHM_TYPE_OR_NONE, S_SHM_MAX_HNDL_SZ, S_GRACEFUL_FINISH_REQUIRED_V &gt;::handlers_are_set</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>In thread W, returns whether <a class="el" href="classipc_1_1session_1_1Server__session__impl.html#ad39cb95f2e546cf5be927dfc295306c1" title="Core of both init_handlers() overloads, to be invoked in thread W.">init_handlers_impl()</a> has yet executed. </p>
<p >This shall be checked in the thread-W body of ~all APIs in this class.</p>
<dl class="section return"><dt>Returns</dt><dd>See above. </dd></dl>

<p class="definition">Definition at line <a class="el" href="ipc__session_2src_2ipc_2session_2detail_2server__session__impl_8hpp_source.html#l00945">945</a> of file <a class="el" href="ipc__session_2src_2ipc_2session_2detail_2server__session__impl_8hpp_source.html">server_session_impl.hpp</a>.</p>

</div>
</div>
<a id="a493937b9737f1fc4803364c35ceae83e" name="a493937b9737f1fc4803364c35ceae83e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a493937b9737f1fc4803364c35ceae83e">&#9670;&nbsp;</a></span>init_handlers() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;schema::MqType S_MQ_TYPE_OR_NONE, bool S_TRANSMIT_NATIVE_HANDLES, typename Mdt_payload , schema::ShmType S_SHM_TYPE_OR_NONE, size_t S_SHM_MAX_HNDL_SZ, bool S_GRACEFUL_FINISH_REQUIRED_V&gt; </div>
<div class="memtemplate">
template&lt;typename Task_err &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classipc_1_1session_1_1Server__session__impl.html">ipc::session::Server_session_impl</a>&lt; S_MQ_TYPE_OR_NONE, S_TRANSMIT_NATIVE_HANDLES, Mdt_payload, S_SHM_TYPE_OR_NONE, S_SHM_MAX_HNDL_SZ, S_GRACEFUL_FINISH_REQUIRED_V &gt;::init_handlers </td>
          <td>(</td>
          <td class="paramtype">Task_err &amp;&amp;&#160;</td>
          <td class="paramname"><em>on_err_func_arg</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>See <a class="el" href="classipc_1_1session_1_1Server__session__mv.html" title="Implements Session concept on the Server_app end: a Session that is emitted in almost-PEER state by l...">Server_session_mv</a> counterpart. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">on_err_func_arg</td><td>See <a class="el" href="classipc_1_1session_1_1Server__session__mv.html" title="Implements Session concept on the Server_app end: a Session that is emitted in almost-PEER state by l...">Server_session_mv</a> counterpart. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>See <a class="el" href="classipc_1_1session_1_1Server__session__mv.html" title="Implements Session concept on the Server_app end: a Session that is emitted in almost-PEER state by l...">Server_session_mv</a> counterpart. </dd></dl>

<p class="definition">Definition at line <a class="el" href="ipc__session_2src_2ipc_2session_2detail_2server__session__impl_8hpp_source.html#l00857">857</a> of file <a class="el" href="ipc__session_2src_2ipc_2session_2detail_2server__session__impl_8hpp_source.html">server_session_impl.hpp</a>.</p>

</div>
</div>
<a id="ac93040ccdaf5a261a053a8b55bd2e14e" name="ac93040ccdaf5a261a053a8b55bd2e14e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac93040ccdaf5a261a053a8b55bd2e14e">&#9670;&nbsp;</a></span>init_handlers() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;schema::MqType S_MQ_TYPE_OR_NONE, bool S_TRANSMIT_NATIVE_HANDLES, typename Mdt_payload , schema::ShmType S_SHM_TYPE_OR_NONE, size_t S_SHM_MAX_HNDL_SZ, bool S_GRACEFUL_FINISH_REQUIRED_V&gt; </div>
<div class="memtemplate">
template&lt;typename Task_err , typename On_passive_open_channel_handler &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classipc_1_1session_1_1Server__session__impl.html">ipc::session::Server_session_impl</a>&lt; S_MQ_TYPE_OR_NONE, S_TRANSMIT_NATIVE_HANDLES, Mdt_payload, S_SHM_TYPE_OR_NONE, S_SHM_MAX_HNDL_SZ, S_GRACEFUL_FINISH_REQUIRED_V &gt;::init_handlers </td>
          <td>(</td>
          <td class="paramtype">Task_err &amp;&amp;&#160;</td>
          <td class="paramname"><em>on_err_func_arg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">On_passive_open_channel_handler &amp;&amp;&#160;</td>
          <td class="paramname"><em>on_passive_open_channel_func_arg</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>See <a class="el" href="classipc_1_1session_1_1Server__session__mv.html" title="Implements Session concept on the Server_app end: a Session that is emitted in almost-PEER state by l...">Server_session_mv</a> counterpart. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">on_err_func_arg</td><td>See <a class="el" href="classipc_1_1session_1_1Server__session__mv.html" title="Implements Session concept on the Server_app end: a Session that is emitted in almost-PEER state by l...">Server_session_mv</a> counterpart. </td></tr>
    <tr><td class="paramname">on_passive_open_channel_func_arg</td><td>See <a class="el" href="classipc_1_1session_1_1Server__session__mv.html" title="Implements Session concept on the Server_app end: a Session that is emitted in almost-PEER state by l...">Server_session_mv</a> counterpart. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>See <a class="el" href="classipc_1_1session_1_1Server__session__mv.html" title="Implements Session concept on the Server_app end: a Session that is emitted in almost-PEER state by l...">Server_session_mv</a> counterpart. </dd></dl>

<p class="definition">Definition at line <a class="el" href="ipc__session_2src_2ipc_2session_2detail_2server__session__impl_8hpp_source.html#l00837">837</a> of file <a class="el" href="ipc__session_2src_2ipc_2session_2detail_2server__session__impl_8hpp_source.html">server_session_impl.hpp</a>.</p>

</div>
</div>
<a id="ad39cb95f2e546cf5be927dfc295306c1" name="ad39cb95f2e546cf5be927dfc295306c1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad39cb95f2e546cf5be927dfc295306c1">&#9670;&nbsp;</a></span>init_handlers_impl()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;schema::MqType S_MQ_TYPE_OR_NONE, bool S_TRANSMIT_NATIVE_HANDLES, typename Mdt_payload , schema::ShmType S_SHM_TYPE_OR_NONE, size_t S_SHM_MAX_HNDL_SZ, bool S_GRACEFUL_FINISH_REQUIRED_V&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classipc_1_1session_1_1Server__session__impl.html">ipc::session::Server_session_impl</a>&lt; S_MQ_TYPE_OR_NONE, S_TRANSMIT_NATIVE_HANDLES, Mdt_payload, S_SHM_TYPE_OR_NONE, S_SHM_MAX_HNDL_SZ, S_GRACEFUL_FINISH_REQUIRED_V &gt;::init_handlers_impl </td>
          <td>(</td>
          <td class="paramtype">flow::async::Task_asio_err &amp;&amp;&#160;</td>
          <td class="paramname"><em>on_err_func_arg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classipc_1_1session_1_1Server__session__impl.html#af8013f82c2441d07bc82eda7cc3ad835">On_passive_open_channel_func</a> &amp;&amp;&#160;</td>
          <td class="paramname"><em>on_passive_open_channel_func_or_empty_arg</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Core of both <a class="el" href="classipc_1_1session_1_1Server__session__impl.html#ac93040ccdaf5a261a053a8b55bd2e14e" title="See Server_session_mv counterpart.">init_handlers()</a> overloads, to be invoked in thread W. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">on_err_func_arg</td><td>See <a class="el" href="classipc_1_1session_1_1Server__session__impl.html#ac93040ccdaf5a261a053a8b55bd2e14e" title="See Server_session_mv counterpart.">init_handlers()</a>. Concretely-typed version of that arg. </td></tr>
    <tr><td class="paramname">on_passive_open_channel_func_or_empty_arg</td><td>See <a class="el" href="classipc_1_1session_1_1Server__session__impl.html#ac93040ccdaf5a261a053a8b55bd2e14e" title="See Server_session_mv counterpart.">init_handlers()</a>. Concretely-typed version of that arg; or <code>.empty()</code> one if the passive-opens-disabled overload was called. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>See <a class="el" href="classipc_1_1session_1_1Server__session__impl.html#ac93040ccdaf5a261a053a8b55bd2e14e" title="See Server_session_mv counterpart.">init_handlers()</a>. </dd></dl>

<p class="definition">Definition at line <a class="el" href="ipc__session_2src_2ipc_2session_2detail_2server__session__impl_8hpp_source.html#l00875">875</a> of file <a class="el" href="ipc__session_2src_2ipc_2session_2detail_2server__session__impl_8hpp_source.html">server_session_impl.hpp</a>.</p>

</div>
</div>
<a id="a84d54a57d3e06c064cde737d1f4be472" name="a84d54a57d3e06c064cde737d1f4be472"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a84d54a57d3e06c064cde737d1f4be472">&#9670;&nbsp;</a></span>make_channel_mqs()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;schema::MqType S_MQ_TYPE_OR_NONE, bool S_TRANSMIT_NATIVE_HANDLES, typename Mdt_payload , schema::ShmType S_SHM_TYPE_OR_NONE, size_t S_SHM_MAX_HNDL_SZ, bool S_GRACEFUL_FINISH_REQUIRED_V&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classipc_1_1session_1_1Server__session__impl.html">ipc::session::Server_session_impl</a>&lt; S_MQ_TYPE_OR_NONE, S_TRANSMIT_NATIVE_HANDLES, Mdt_payload, S_SHM_TYPE_OR_NONE, S_SHM_MAX_HNDL_SZ, S_GRACEFUL_FINISH_REQUIRED_V &gt;::make_channel_mqs </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classipc_1_1session_1_1Server__session__impl.html#aa72ad11c33a4d11d5e3f0480ce0a6ff1">Persistent_mq_handle_from_cfg</a> *&#160;</td>
          <td class="paramname"><em>mq_c2s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classipc_1_1session_1_1Server__session__impl.html#aa72ad11c33a4d11d5e3f0480ce0a6ff1">Persistent_mq_handle_from_cfg</a> *&#160;</td>
          <td class="paramname"><em>mq_s2c</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceipc_1_1session.html#a6d07d9996af19e57eb42416e914110ea">Shared_name</a> *&#160;</td>
          <td class="paramname"><em>mq_name_c2s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceipc_1_1session.html#a6d07d9996af19e57eb42416e914110ea">Shared_name</a> *&#160;</td>
          <td class="paramname"><em>mq_name_s2c</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceipc.html#aa3192e586cc45d3e7c22463bf2760f89">Error_code</a> *&#160;</td>
          <td class="paramname"><em>err_code</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Helper for <a class="el" href="classipc_1_1session_1_1Server__session__impl.html#a6f756d12f9e2b2cc3269564ba49bb354" title="In thread W acquires the needed shared sources (MQs and/or Native_handle pair as of this writing) and...">create_channel_and_resources()</a>, invoked and compiled if and only if <a class="el" href="classipc_1_1session_1_1Server__session__impl.html#a005fcbc9ee215531c03d17fcc49ef544" title="See Server_session_mv counterpart.">S_MQS_ENABLED</a>, that <em>creates</em> the underlying client-&gt;server and server-&gt;client MQs and local handles thereto, and outputs these things via out-args. </p>
<p >On failure undoes everything it was able to do and returns <code>false</code>; else returns <code>true</code>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">mq_c2s</td><td>On success this is the handle to newly creates client-&gt;server unidirectional MQ for the new channel. </td></tr>
    <tr><td class="paramname">mq_s2c</td><td>Like the preceding but opposite-direction (server-&gt;client). </td></tr>
    <tr><td class="paramname">mq_name_c2s</td><td>Name for <code>mq_c2s</code>. </td></tr>
    <tr><td class="paramname">mq_name_s2c</td><td>Name for <code>mq_s2c</code>. </td></tr>
    <tr><td class="paramname">err_code</td><td>If <code>false</code> returned, this is the (truthy) reason code. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> on success; <code>false</code> on failure. </dd></dl>

<p class="definition">Definition at line <a class="el" href="ipc__session_2src_2ipc_2session_2detail_2server__session__impl_8hpp_source.html#l01484">1484</a> of file <a class="el" href="ipc__session_2src_2ipc_2session_2detail_2server__session__impl_8hpp_source.html">server_session_impl.hpp</a>.</p>

<p class="reference">References <a class="el" href="ipc__session_2src_2ipc_2session_2detail_2session__shared__name_8cpp_source.html#l00044">ipc::session::build_conventional_shared_name()</a>, <a class="el" href="ipc__core_2src_2ipc_2util_2util_8cpp_source.html#l00032">ipc::util::CREATE_ONLY</a>, <a class="el" href="shared__name_8hpp_source.html#l00674">ipc::util::Shared_name::ct()</a>, and <a class="el" href="ipc__core_2src_2ipc_2util_2util_8cpp_source.html#l00037">ipc::util::shared_resource_permissions()</a>.</p>
<div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="classipc_1_1session_1_1Server__session__impl_a84d54a57d3e06c064cde737d1f4be472_cgraph.svg" width="832" height="194"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe>
</div>
</div>

</div>
</div>
<a id="a14d68714c197ba58b4cb485262fb9d51" name="a14d68714c197ba58b4cb485262fb9d51"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a14d68714c197ba58b4cb485262fb9d51">&#9670;&nbsp;</a></span>master_channel()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;schema::MqType S_MQ_TYPE_OR_NONE, bool S_TRANSMIT_NATIVE_HANDLES, typename Mdt_payload , schema::ShmType S_SHM_TYPE_OR_NONE, size_t S_SHM_MAX_HNDL_SZ, bool S_GRACEFUL_FINISH_REQUIRED_V&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classipc_1_1session_1_1Server__session__impl.html">Server_session_impl</a>&lt; S_MQ_TYPE_OR_NONE, S_TRANSMIT_NATIVE_HANDLES, Mdt_payload, S_SHM_TYPE_OR_NONE, S_SHM_MAX_HNDL_SZ, S_GRACEFUL_FINISH_REQUIRED_V &gt;<a class="el" href="classipc_1_1session_1_1Server__session__impl.html#a3bc90eb872c3f4d4ff65039a4a36b166">::Master_structured_channel</a> * <a class="el" href="classipc_1_1session_1_1Server__session__impl.html">ipc::session::Server_session_impl</a>&lt; S_MQ_TYPE_OR_NONE, S_TRANSMIT_NATIVE_HANDLES, Mdt_payload, S_SHM_TYPE_OR_NONE, S_SHM_MAX_HNDL_SZ, S_GRACEFUL_FINISH_REQUIRED_V &gt;::master_channel</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Utility for sub-classes: provides ability to do work on the session master channel after our <a class="el" href="classipc_1_1session_1_1Server__session__impl.html#aee35d521d9997d48f6b5565730e60e93" title="For use by internal user Session_server: See Server_session_mv counterpart.">async_accept_log_in()</a> succeeds, but before the sub-classed wrapper of its on-done handler succeeds. </p>
<p >This is pushing my (ygoldfel) (and from coding guide) suggestion to avoid unrestricted <code>protected</code> access to data members. It still "feels" okay but.... Hmmm.</p>
<dl class="section return"><dt>Returns</dt><dd>See above. </dd></dl>

<p class="definition">Definition at line <a class="el" href="ipc__session_2src_2ipc_2session_2detail_2server__session__impl_8hpp_source.html#l02194">2194</a> of file <a class="el" href="ipc__session_2src_2ipc_2session_2detail_2server__session__impl_8hpp_source.html">server_session_impl.hpp</a>.</p>

</div>
</div>
<a id="aaa570a2ceb242370eeccca85d806fbbf" name="aaa570a2ceb242370eeccca85d806fbbf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaa570a2ceb242370eeccca85d806fbbf">&#9670;&nbsp;</a></span>master_channel_const()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;schema::MqType S_MQ_TYPE_OR_NONE, bool S_TRANSMIT_NATIVE_HANDLES, typename Mdt_payload , schema::ShmType S_SHM_TYPE_OR_NONE, size_t S_SHM_MAX_HNDL_SZ, bool S_GRACEFUL_FINISH_REQUIRED_V&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classipc_1_1session_1_1Server__session__impl.html">Server_session_impl</a>&lt; S_MQ_TYPE_OR_NONE, S_TRANSMIT_NATIVE_HANDLES, Mdt_payload, S_SHM_TYPE_OR_NONE, S_SHM_MAX_HNDL_SZ, S_GRACEFUL_FINISH_REQUIRED_V &gt;<a class="el" href="classipc_1_1session_1_1Server__session__impl.html#a3bc90eb872c3f4d4ff65039a4a36b166">::Master_structured_channel</a> &amp; <a class="el" href="classipc_1_1session_1_1Server__session__impl.html">ipc::session::Server_session_impl</a>&lt; S_MQ_TYPE_OR_NONE, S_TRANSMIT_NATIVE_HANDLES, Mdt_payload, S_SHM_TYPE_OR_NONE, S_SHM_MAX_HNDL_SZ, S_GRACEFUL_FINISH_REQUIRED_V &gt;::master_channel_const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Analogous to <a class="el" href="classipc_1_1session_1_1Client__session__impl.html#a5f156b23ce19cd878c3e83330e63f56f" title="Utility for sub-classes: provides ability to immutably query the session master channel,...">Client_session_impl::master_channel_const()</a>. </p>
<p >See that doc header. </p><dl class="section return"><dt>Returns</dt><dd>See above. </dd></dl>

<p class="definition">Definition at line <a class="el" href="ipc__session_2src_2ipc_2session_2detail_2server__session__impl_8hpp_source.html#l02200">2200</a> of file <a class="el" href="ipc__session_2src_2ipc_2session_2detail_2server__session__impl_8hpp_source.html">server_session_impl.hpp</a>.</p>

</div>
</div>
<a id="a138956765a655240080491157f316167" name="a138956765a655240080491157f316167"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a138956765a655240080491157f316167">&#9670;&nbsp;</a></span>mdt_builder()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;schema::MqType S_MQ_TYPE_OR_NONE, bool S_TRANSMIT_NATIVE_HANDLES, typename Mdt_payload , schema::ShmType S_SHM_TYPE_OR_NONE, size_t S_SHM_MAX_HNDL_SZ, bool S_GRACEFUL_FINISH_REQUIRED_V&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classipc_1_1session_1_1Server__session__impl.html">Server_session_impl</a>&lt; S_MQ_TYPE_OR_NONE, S_TRANSMIT_NATIVE_HANDLES, Mdt_payload, S_SHM_TYPE_OR_NONE, S_SHM_MAX_HNDL_SZ, S_GRACEFUL_FINISH_REQUIRED_V &gt;<a class="el" href="classipc_1_1session_1_1Server__session__impl.html#ac4bc7e38574e0495af4887d2e6226b7a">::Mdt_builder_ptr</a> <a class="el" href="classipc_1_1session_1_1Server__session__impl.html">ipc::session::Server_session_impl</a>&lt; S_MQ_TYPE_OR_NONE, S_TRANSMIT_NATIVE_HANDLES, Mdt_payload, S_SHM_TYPE_OR_NONE, S_SHM_MAX_HNDL_SZ, S_GRACEFUL_FINISH_REQUIRED_V &gt;::mdt_builder</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>See <a class="el" href="classipc_1_1session_1_1Server__session__mv.html" title="Implements Session concept on the Server_app end: a Session that is emitted in almost-PEER state by l...">Server_session_mv</a> counterpart. </p>
<dl class="section return"><dt>Returns</dt><dd>See <a class="el" href="classipc_1_1session_1_1Server__session__mv.html" title="Implements Session concept on the Server_app end: a Session that is emitted in almost-PEER state by l...">Server_session_mv</a> counterpart. </dd></dl>

<p class="definition">Definition at line <a class="el" href="ipc__session_2src_2ipc_2session_2detail_2server__session__impl_8hpp_source.html#l00985">985</a> of file <a class="el" href="ipc__session_2src_2ipc_2session_2detail_2server__session__impl_8hpp_source.html">server_session_impl.hpp</a>.</p>

<p class="reference">References <a class="el" href="shared__name_8cpp_source.html#l00140">ipc::util::Shared_name::str()</a>.</p>
<div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="classipc_1_1session_1_1Server__session__impl_a138956765a655240080491157f316167_cgraph.svg" width="396" height="47"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe>
</div>
</div>

</div>
</div>
<a id="aeccf8c9a6774d25bd4274962d69fc0e9" name="aeccf8c9a6774d25bd4274962d69fc0e9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aeccf8c9a6774d25bd4274962d69fc0e9">&#9670;&nbsp;</a></span>on_master_channel_error()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;schema::MqType S_MQ_TYPE_OR_NONE, bool S_TRANSMIT_NATIVE_HANDLES, typename Mdt_payload , schema::ShmType S_SHM_TYPE_OR_NONE, size_t S_SHM_MAX_HNDL_SZ, bool S_GRACEFUL_FINISH_REQUIRED_V&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classipc_1_1session_1_1Server__session__impl.html">ipc::session::Server_session_impl</a>&lt; S_MQ_TYPE_OR_NONE, S_TRANSMIT_NATIVE_HANDLES, Mdt_payload, S_SHM_TYPE_OR_NONE, S_SHM_MAX_HNDL_SZ, S_GRACEFUL_FINISH_REQUIRED_V &gt;::on_master_channel_error </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespaceipc.html#aa3192e586cc45d3e7c22463bf2760f89">Error_code</a> &amp;&#160;</td>
          <td class="paramname"><em>err_code</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>In thread W, handler for <a class="el" href="classipc_1_1session_1_1Server__session__impl.html#a81eb6769bc75d900bb3c442047249503" title="The session master channel.">m_master_channel</a> indicating incoming-direction channel-hosing error. </p>
<p >It is possible that <a class="el" href="classipc_1_1session_1_1Server__session__impl.html#a81eb6769bc75d900bb3c442047249503" title="The session master channel.">m_master_channel</a> has been <code>.reset()</code> in the meantime, by seeing log-in failure in <a class="el" href="classipc_1_1session_1_1Server__session__impl.html#a804c629b2da8898376f071db499a2173" title="In thread W, handler for m_master_channel receiving a passive-open (a/k/a open-channel-to-server) req...">on_master_channel_open_channel_req()</a>, and no longer exists.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">err_code</td><td>The non-success <a class="el" href="namespaceipc.html#aa3192e586cc45d3e7c22463bf2760f89" title="Short-hand for flow::Error_code which is very common.">Error_code</a> from <a class="el" href="classipc_1_1transport_1_1struc_1_1Channel.html" title="Owning and wrapping a pre-connected transport::Channel peer (an endpoint of an established channel ov...">transport::struc::Channel</a>. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="ipc__session_2src_2ipc_2session_2detail_2server__session__impl_8hpp_source.html#l02108">2108</a> of file <a class="el" href="ipc__session_2src_2ipc_2session_2detail_2server__session__impl_8hpp_source.html">server_session_impl.hpp</a>.</p>

</div>
</div>
<a id="a804c629b2da8898376f071db499a2173" name="a804c629b2da8898376f071db499a2173"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a804c629b2da8898376f071db499a2173">&#9670;&nbsp;</a></span>on_master_channel_open_channel_req()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;schema::MqType S_MQ_TYPE_OR_NONE, bool S_TRANSMIT_NATIVE_HANDLES, typename Mdt_payload , schema::ShmType S_SHM_TYPE_OR_NONE, size_t S_SHM_MAX_HNDL_SZ, bool S_GRACEFUL_FINISH_REQUIRED_V&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classipc_1_1session_1_1Server__session__impl.html">ipc::session::Server_session_impl</a>&lt; S_MQ_TYPE_OR_NONE, S_TRANSMIT_NATIVE_HANDLES, Mdt_payload, S_SHM_TYPE_OR_NONE, S_SHM_MAX_HNDL_SZ, S_GRACEFUL_FINISH_REQUIRED_V &gt;::on_master_channel_open_channel_req </td>
          <td>(</td>
          <td class="paramtype">typename Master_structured_channel::Msg_in_ptr &amp;&amp;&#160;</td>
          <td class="paramname"><em>open_channel_req</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>In thread W, handler for <a class="el" href="classipc_1_1session_1_1Server__session__impl.html#a81eb6769bc75d900bb3c442047249503" title="The session master channel.">m_master_channel</a> receiving a passive-open (a/k/a open-channel-to-server) request. </p>
<p >If there is no issue with this request, and we're able to sync-send the open-channel response to that effect, this shall fire on-passive-open handler, giving it a new <a class="el" href="classipc_1_1session_1_1Server__session__impl.html#a7c969c3a1007f8e4ba3ad1c1acd6c290" title="See Server_session_mv counterpart.">Channel_obj</a> in PEER state + metadata. If there is a problem, then it's not a session-hosing situation; local user is none-the-wiser; except that if the <code>send()</code> reveals a <em>new</em> error, then it is a session-hosing situation, and local user is informed via on-error handler.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">open_channel_req</td><td>The request in-message from <a class="el" href="classipc_1_1transport_1_1struc_1_1Channel.html" title="Owning and wrapping a pre-connected transport::Channel peer (an endpoint of an established channel ov...">transport::struc::Channel</a>. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="ipc__session_2src_2ipc_2session_2detail_2server__session__impl_8hpp_source.html#l01242">1242</a> of file <a class="el" href="ipc__session_2src_2ipc_2session_2detail_2server__session__impl_8hpp_source.html">server_session_impl.hpp</a>.</p>

<p class="reference">References <a class="el" href="shared__name_8cpp_source.html#l00155">ipc::util::Shared_name::empty()</a>, and <a class="el" href="shared__name_8cpp_source.html#l00140">ipc::util::Shared_name::str()</a>.</p>
<div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="classipc_1_1session_1_1Server__session__impl_a804c629b2da8898376f071db499a2173_cgraph.svg" width="403" height="96"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe>
</div>
</div>

</div>
</div>
<a id="a45a5ae92b706ea539c27be0d19a303c4" name="a45a5ae92b706ea539c27be0d19a303c4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a45a5ae92b706ea539c27be0d19a303c4">&#9670;&nbsp;</a></span>open_channel() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;schema::MqType S_MQ_TYPE_OR_NONE, bool S_TRANSMIT_NATIVE_HANDLES, typename Mdt_payload , schema::ShmType S_SHM_TYPE_OR_NONE, size_t S_SHM_MAX_HNDL_SZ, bool S_GRACEFUL_FINISH_REQUIRED_V&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classipc_1_1session_1_1Server__session__impl.html">ipc::session::Server_session_impl</a>&lt; S_MQ_TYPE_OR_NONE, S_TRANSMIT_NATIVE_HANDLES, Mdt_payload, S_SHM_TYPE_OR_NONE, S_SHM_MAX_HNDL_SZ, S_GRACEFUL_FINISH_REQUIRED_V &gt;::open_channel </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classipc_1_1session_1_1Server__session__impl.html#a7c969c3a1007f8e4ba3ad1c1acd6c290">Channel_obj</a> *&#160;</td>
          <td class="paramname"><em>target_channel</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classipc_1_1session_1_1Server__session__impl.html#ac4bc7e38574e0495af4887d2e6226b7a">Mdt_builder_ptr</a> &amp;&#160;</td>
          <td class="paramname"><em>mdt</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceipc.html#aa3192e586cc45d3e7c22463bf2760f89">Error_code</a> *&#160;</td>
          <td class="paramname"><em>err_code</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>See <a class="el" href="classipc_1_1session_1_1Server__session__mv.html" title="Implements Session concept on the Server_app end: a Session that is emitted in almost-PEER state by l...">Server_session_mv</a> counterpart. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">target_channel</td><td>See <a class="el" href="classipc_1_1session_1_1Server__session__mv.html" title="Implements Session concept on the Server_app end: a Session that is emitted in almost-PEER state by l...">Server_session_mv</a> counterpart. </td></tr>
    <tr><td class="paramname">mdt</td><td>See <a class="el" href="classipc_1_1session_1_1Server__session__mv.html" title="Implements Session concept on the Server_app end: a Session that is emitted in almost-PEER state by l...">Server_session_mv</a> counterpart. </td></tr>
    <tr><td class="paramname">err_code</td><td>See <a class="el" href="classipc_1_1session_1_1Server__session__mv.html" title="Implements Session concept on the Server_app end: a Session that is emitted in almost-PEER state by l...">Server_session_mv</a> counterpart. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>See <a class="el" href="classipc_1_1session_1_1Server__session__mv.html" title="Implements Session concept on the Server_app end: a Session that is emitted in almost-PEER state by l...">Server_session_mv</a> counterpart. </dd></dl>

<p class="definition">Definition at line <a class="el" href="ipc__session_2src_2ipc_2session_2detail_2server__session__impl_8hpp_source.html#l01074">1074</a> of file <a class="el" href="ipc__session_2src_2ipc_2session_2detail_2server__session__impl_8hpp_source.html">server_session_impl.hpp</a>.</p>

<p class="reference">References <a class="el" href="namespaceipc_1_1session_1_1error.html#a0708d4bec9ae853f4d7e3d7822fc8f2fa7d85b87223a9b277b8875c1f7971d6ad">ipc::session::error::S_SESSION_OPEN_CHANNEL_ACTIVE_TIMEOUT</a>, <a class="el" href="namespaceipc_1_1session_1_1error.html#a0708d4bec9ae853f4d7e3d7822fc8f2fa2c8c27c65ff6234220a84f96de8a1870">ipc::session::error::S_SESSION_OPEN_CHANNEL_REMOTE_PEER_REJECTED_PASSIVE_OPEN</a>, <a class="el" href="namespaceipc_1_1session_1_1error.html#a0708d4bec9ae853f4d7e3d7822fc8f2fa10d32cf1382fb003f09a6df2da408574">ipc::session::error::S_SESSION_OPEN_CHANNEL_SERVER_CANNOT_PROCEED_RESOURCE_UNAVAILABLE</a>, and <a class="el" href="namespaceipc_1_1transport_1_1error.html#adfef15ef4e76cc55d652fbd9c2797297abcfca4c2347f9d377dd2ac41c41dc027">ipc::transport::error::S_TIMEOUT</a>.</p>

</div>
</div>
<a id="adfb10992398b46be3b0e1ac0c8605ef4" name="adfb10992398b46be3b0e1ac0c8605ef4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adfb10992398b46be3b0e1ac0c8605ef4">&#9670;&nbsp;</a></span>open_channel() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;schema::MqType S_MQ_TYPE_OR_NONE, bool S_TRANSMIT_NATIVE_HANDLES, typename Mdt_payload , schema::ShmType S_SHM_TYPE_OR_NONE, size_t S_SHM_MAX_HNDL_SZ, bool S_GRACEFUL_FINISH_REQUIRED_V&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classipc_1_1session_1_1Server__session__impl.html">ipc::session::Server_session_impl</a>&lt; S_MQ_TYPE_OR_NONE, S_TRANSMIT_NATIVE_HANDLES, Mdt_payload, S_SHM_TYPE_OR_NONE, S_SHM_MAX_HNDL_SZ, S_GRACEFUL_FINISH_REQUIRED_V &gt;::open_channel </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classipc_1_1session_1_1Server__session__impl.html#a7c969c3a1007f8e4ba3ad1c1acd6c290">Channel_obj</a> *&#160;</td>
          <td class="paramname"><em>target_channel</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceipc.html#aa3192e586cc45d3e7c22463bf2760f89">Error_code</a> *&#160;</td>
          <td class="paramname"><em>err_code</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>See <a class="el" href="classipc_1_1session_1_1Server__session__mv.html" title="Implements Session concept on the Server_app end: a Session that is emitted in almost-PEER state by l...">Server_session_mv</a> counterpart. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">target_channel</td><td>See <a class="el" href="classipc_1_1session_1_1Server__session__mv.html" title="Implements Session concept on the Server_app end: a Session that is emitted in almost-PEER state by l...">Server_session_mv</a> counterpart. </td></tr>
    <tr><td class="paramname">err_code</td><td>See <a class="el" href="classipc_1_1session_1_1Server__session__mv.html" title="Implements Session concept on the Server_app end: a Session that is emitted in almost-PEER state by l...">Server_session_mv</a> counterpart. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>See <a class="el" href="classipc_1_1session_1_1Server__session__mv.html" title="Implements Session concept on the Server_app end: a Session that is emitted in almost-PEER state by l...">Server_session_mv</a> counterpart. </dd></dl>

<p class="definition">Definition at line <a class="el" href="ipc__session_2src_2ipc_2session_2detail_2server__session__impl_8hpp_source.html#l01235">1235</a> of file <a class="el" href="ipc__session_2src_2ipc_2session_2detail_2server__session__impl_8hpp_source.html">server_session_impl.hpp</a>.</p>

</div>
</div>
<a id="a22e1464a8bc4b806bf3a91e932b31813" name="a22e1464a8bc4b806bf3a91e932b31813"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a22e1464a8bc4b806bf3a91e932b31813">&#9670;&nbsp;</a></span>session_token()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;schema::MqType S_MQ_TYPE_OR_NONE, bool S_TRANSMIT_NATIVE_HANDLES, typename Mdt_payload , schema::ShmType S_SHM_TYPE_OR_NONE, size_t S_SHM_MAX_HNDL_SZ, bool S_GRACEFUL_FINISH_REQUIRED_V&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="namespaceipc_1_1session.html#ade2b302f1a3623e8adc9694568d94d2c">Session_token</a> &amp; <a class="el" href="classipc_1_1session_1_1Server__session__impl.html">ipc::session::Server_session_impl</a>&lt; S_MQ_TYPE_OR_NONE, S_TRANSMIT_NATIVE_HANDLES, Mdt_payload, S_SHM_TYPE_OR_NONE, S_SHM_MAX_HNDL_SZ, S_GRACEFUL_FINISH_REQUIRED_V &gt;::session_token</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>See <a class="el" href="classipc_1_1session_1_1Server__session__mv.html" title="Implements Session concept on the Server_app end: a Session that is emitted in almost-PEER state by l...">Server_session_mv</a> counterpart. </p>
<dl class="section return"><dt>Returns</dt><dd>See <a class="el" href="classipc_1_1session_1_1Server__session__mv.html" title="Implements Session concept on the Server_app end: a Session that is emitted in almost-PEER state by l...">Server_session_mv</a> counterpart. </dd></dl>

<p class="definition">Definition at line <a class="el" href="ipc__session_2src_2ipc_2session_2detail_2server__session__impl_8hpp_source.html#l00951">951</a> of file <a class="el" href="ipc__session_2src_2ipc_2session_2detail_2server__session__impl_8hpp_source.html">server_session_impl.hpp</a>.</p>

<p class="reference">References <a class="el" href="ipc__transport__structured_2src_2ipc_2transport_2struc_2channel_8cpp_source.html#l00035">ipc::transport::struc::NULL_SESSION_TOKEN</a>.</p>

</div>
</div>
<a id="a2276a6fd556861a9e0856360fde58158" name="a2276a6fd556861a9e0856360fde58158"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2276a6fd556861a9e0856360fde58158">&#9670;&nbsp;</a></span>sub_class_set_deinit_func()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;schema::MqType S_MQ_TYPE_OR_NONE, bool S_TRANSMIT_NATIVE_HANDLES, typename Mdt_payload , schema::ShmType S_SHM_TYPE_OR_NONE, size_t S_SHM_MAX_HNDL_SZ, bool S_GRACEFUL_FINISH_REQUIRED_V&gt; </div>
<div class="memtemplate">
template&lt;typename Task &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classipc_1_1session_1_1Server__session__impl.html">ipc::session::Server_session_impl</a>&lt; S_MQ_TYPE_OR_NONE, S_TRANSMIT_NATIVE_HANDLES, Mdt_payload, S_SHM_TYPE_OR_NONE, S_SHM_MAX_HNDL_SZ, S_GRACEFUL_FINISH_REQUIRED_V &gt;::sub_class_set_deinit_func </td>
          <td>(</td>
          <td class="paramtype">Task &amp;&amp;&#160;</td>
          <td class="paramname"><em>task</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Utility for sub-classes: ensures that <code>task()</code> is invoked near the end of <code>*this</code> dtor's execution, from thread U, after thread W is joined, and any <a class="el" href="classipc_1_1session_1_1Server__session__impl.html#aee35d521d9997d48f6b5565730e60e93" title="For use by internal user Session_server: See Server_session_mv counterpart.">async_accept_log_in()</a> on-done handler has fired with operation-aborted code. </p>
<p >It requires being invoked from thread W. (Behavior is undefined otherwise; assertion may trip.)</p>
<p >The value it adds: A long story best told by specific example. See the original use case which is in <a class="el" href="classipc_1_1session_1_1shm_1_1classic_1_1Server__session__impl.html#a9c78b2c35b853e1702a06ec451545945" title="For use by internal user Session_server: See Server_session_mv counterpart.">shm::classic::Server_session_impl::async_accept_log_in()</a>; it sets up certain SHM cleanup steps to occur, when the session ends.</p>
<p >As of this writing this can be invoked 2+ times if desired, but really the spirit of it is to either never call it, or call it exactly once during a certain stage of <a class="el" href="classipc_1_1session_1_1Server__session__impl.html#aee35d521d9997d48f6b5565730e60e93" title="For use by internal user Session_server: See Server_session_mv counterpart.">async_accept_log_in()</a>'s async portion.</p>
<h3>Watch out!</h3>
<p >At the time <code>task()</code> runs, the calling instance of the sub-class has been destroyed &ndash; thus it is, e.g., usually wrong to capture your <code>this</code> in the <code>task</code> lambda, except for logging. <code>get_logger()</code> and <code>get_log_component()</code> (which are immutable state) are still okay to use.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Task</td><td>Function object invoked as <code>void</code> with no args. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">task</td><td><code>task()</code> shall execute before dtor returns. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="ipc__session_2src_2ipc_2session_2detail_2server__session__impl_8hpp_source.html#l02182">2182</a> of file <a class="el" href="ipc__session_2src_2ipc_2session_2detail_2server__session__impl_8hpp_source.html">server_session_impl.hpp</a>.</p>

</div>
</div>
<h2 class="groupheader">Friends And Related Function Documentation</h2>
<a id="a88b5e68821f26cfab86feb8b4dc5702a" name="a88b5e68821f26cfab86feb8b4dc5702a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a88b5e68821f26cfab86feb8b4dc5702a">&#9670;&nbsp;</a></span>operator&lt;&lt;()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;schema::MqType S_MQ_TYPE_OR_NONE, bool S_TRANSMIT_NATIVE_HANDLES, typename Mdt_payload , schema::ShmType S_SHM_TYPE_OR_NONE, size_t S_SHM_MAX_HNDL_SZ, bool S_GRACEFUL_FINISH_REQUIRED_V&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::ostream &amp; operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>os</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classipc_1_1session_1_1Server__session__impl.html">Server_session_impl</a>&lt; S_MQ_TYPE_OR_NONE, S_TRANSMIT_NATIVE_HANDLES, Mdt_payload, S_SHM_TYPE_OR_NONE, S_SHM_MAX_HNDL_SZ, S_GRACEFUL_FINISH_REQUIRED_V &gt; &amp;&#160;</td>
          <td class="paramname"><em>val</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Prints string representation of the given <code><a class="el" href="classipc_1_1session_1_1Server__session__impl.html" title="Internal, non-movable pImpl-lite implementation of Server_session_mv class template.">Server_session_impl</a></code> to the given <code>ostream</code>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">os</td><td>Stream to which to write. </td></tr>
    <tr><td class="paramname">val</td><td>Object to serialize. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>os</code>. </dd></dl>

<p class="definition">Definition at line <a class="el" href="ipc__session_2src_2ipc_2session_2detail_2server__session__impl_8hpp_source.html#l02206">2206</a> of file <a class="el" href="ipc__session_2src_2ipc_2session_2detail_2server__session__impl_8hpp_source.html">server_session_impl.hpp</a>.</p>

</div>
</div>
<h2 class="groupheader">Member Data Documentation</h2>
<a id="a73419b3ccb6e3d028d8acc8f9f42e0ac" name="a73419b3ccb6e3d028d8acc8f9f42e0ac"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a73419b3ccb6e3d028d8acc8f9f42e0ac">&#9670;&nbsp;</a></span>m_async_worker</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;schema::MqType S_MQ_TYPE_OR_NONE, bool S_TRANSMIT_NATIVE_HANDLES, typename Mdt_payload , schema::ShmType S_SHM_TYPE_OR_NONE, size_t S_SHM_MAX_HNDL_SZ, bool S_GRACEFUL_FINISH_REQUIRED_V&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">flow::async::Single_thread_task_loop <a class="el" href="classipc_1_1session_1_1Server__session__impl.html">ipc::session::Server_session_impl</a>&lt; S_MQ_TYPE_OR_NONE, S_TRANSMIT_NATIVE_HANDLES, Mdt_payload, S_SHM_TYPE_OR_NONE, S_SHM_MAX_HNDL_SZ, S_GRACEFUL_FINISH_REQUIRED_V &gt;::m_async_worker</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">mutable</span><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Worker thread (a/k/a thread W). </p>
<p >Ordering: Should be declared before <a class="el" href="classipc_1_1session_1_1Server__session__impl.html#a81eb6769bc75d900bb3c442047249503" title="The session master channel.">m_master_channel</a>: It should destruct before the <code>Task_engine</code> onto which its queued-up handlers might <code>post()</code> items destructs prematurely.</p>
<h3>Why <code>mutable</code>?</h3>
<p >Well, <a class="el" href="classipc_1_1session_1_1Server__session__impl.html#a22e1464a8bc4b806bf3a91e932b31813" title="See Server_session_mv counterpart.">session_token()</a> is <code>const</code> to the user but must <code>.post()</code> which is non-<code>const</code>. This fits the spirit of <code>mutable</code>. I (ygoldfel) think. </p>

<p class="definition">Definition at line <a class="el" href="ipc__session_2src_2ipc_2session_2detail_2server__session__impl_8hpp_source.html#l00643">643</a> of file <a class="el" href="ipc__session_2src_2ipc_2session_2detail_2server__session__impl_8hpp_source.html">server_session_impl.hpp</a>.</p>

<p class="reference">Referenced by <a class="el" href="ipc__session_2src_2ipc_2session_2detail_2server__session__impl_8hpp_source.html#l00681">ipc::session::Server_session_impl&lt; S_MQ_TYPE_OR_NONE, S_TRANSMIT_NATIVE_HANDLES, Mdt_payload, S_SHM_TYPE_OR_NONE, S_SHM_MAX_HNDL_SZ, S_GRACEFUL_FINISH_REQUIRED_V &gt;::Server_session_impl()</a>.</p>

</div>
</div>
<a id="a02a0feffbe59da064cbf33ba33eb4dac" name="a02a0feffbe59da064cbf33ba33eb4dac"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a02a0feffbe59da064cbf33ba33eb4dac">&#9670;&nbsp;</a></span>m_deinit_func_or_empty</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;schema::MqType S_MQ_TYPE_OR_NONE, bool S_TRANSMIT_NATIVE_HANDLES, typename Mdt_payload , schema::ShmType S_SHM_TYPE_OR_NONE, size_t S_SHM_MAX_HNDL_SZ, bool S_GRACEFUL_FINISH_REQUIRED_V&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespaceipc.html#aa455c7f045059736578ca275fc1a851f">Function</a>&lt;void ()&gt; <a class="el" href="classipc_1_1session_1_1Server__session__impl.html">ipc::session::Server_session_impl</a>&lt; S_MQ_TYPE_OR_NONE, S_TRANSMIT_NATIVE_HANDLES, Mdt_payload, S_SHM_TYPE_OR_NONE, S_SHM_MAX_HNDL_SZ, S_GRACEFUL_FINISH_REQUIRED_V &gt;::m_deinit_func_or_empty</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>See <a class="el" href="classipc_1_1session_1_1Server__session__impl.html#a2276a6fd556861a9e0856360fde58158" title="Utility for sub-classes: ensures that task() is invoked near the end of *this dtor&#39;s execution,...">sub_class_set_deinit_func()</a>. <code>.empty()</code> unless that was called at least once. </p>

<p class="definition">Definition at line <a class="el" href="ipc__session_2src_2ipc_2session_2detail_2server__session__impl_8hpp_source.html#l00656">656</a> of file <a class="el" href="ipc__session_2src_2ipc_2session_2detail_2server__session__impl_8hpp_source.html">server_session_impl.hpp</a>.</p>

</div>
</div>
<a id="ac473cff436bde8b069a3f0d55d9c3b51" name="ac473cff436bde8b069a3f0d55d9c3b51"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac473cff436bde8b069a3f0d55d9c3b51">&#9670;&nbsp;</a></span>m_graceful_finisher</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;schema::MqType S_MQ_TYPE_OR_NONE, bool S_TRANSMIT_NATIVE_HANDLES, typename Mdt_payload , schema::ShmType S_SHM_TYPE_OR_NONE, size_t S_SHM_MAX_HNDL_SZ, bool S_GRACEFUL_FINISH_REQUIRED_V&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::optional&lt;typename <a class="el" href="classipc_1_1session_1_1Session__base_1_1Graceful__finisher.html">Base::Graceful_finisher</a>&gt; <a class="el" href="classipc_1_1session_1_1Server__session__impl.html">ipc::session::Server_session_impl</a>&lt; S_MQ_TYPE_OR_NONE, S_TRANSMIT_NATIVE_HANDLES, Mdt_payload, S_SHM_TYPE_OR_NONE, S_SHM_MAX_HNDL_SZ, S_GRACEFUL_FINISH_REQUIRED_V &gt;::m_graceful_finisher</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Null until PEER state is reached, and NULL unless compile-time <a class="el" href="classipc_1_1session_1_1Server__session__impl.html#a0dc599111ce0b4b6d8cd003559e6c01c" title="Short-hand for template parameter knob S_GRACEFUL_FINISH_REQUIRED_V: see class template doc header.">S_GRACEFUL_FINISH_REQUIRED</a> is <code>true</code>, this is used to block at the start of dtor to synchronize with the opposing <code><a class="el" href="classipc_1_1session_1_1Session.html" title="A documentation-only concept defining the local side of an IPC conversation (session) with another en...">Session</a></code> dtor for safety. </p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classipc_1_1session_1_1Session__base_1_1Graceful__finisher.html" title="Optional to use by subclasses, this operates a simple state machine that carries out a graceful-sessi...">Session_base::Graceful_finisher</a> doc header for all the background ever. </dd></dl>

<p class="definition">Definition at line <a class="el" href="ipc__session_2src_2ipc_2session_2detail_2server__session__impl_8hpp_source.html#l00664">664</a> of file <a class="el" href="ipc__session_2src_2ipc_2session_2detail_2server__session__impl_8hpp_source.html">server_session_impl.hpp</a>.</p>

</div>
</div>
<a id="a6677dde04bab0c72881848a9b72a8227" name="a6677dde04bab0c72881848a9b72a8227"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6677dde04bab0c72881848a9b72a8227">&#9670;&nbsp;</a></span>m_last_actively_opened_channel_id</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;schema::MqType S_MQ_TYPE_OR_NONE, bool S_TRANSMIT_NATIVE_HANDLES, typename Mdt_payload , schema::ShmType S_SHM_TYPE_OR_NONE, size_t S_SHM_MAX_HNDL_SZ, bool S_GRACEFUL_FINISH_REQUIRED_V&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">unsigned int <a class="el" href="classipc_1_1session_1_1Server__session__impl.html">ipc::session::Server_session_impl</a>&lt; S_MQ_TYPE_OR_NONE, S_TRANSMIT_NATIVE_HANDLES, Mdt_payload, S_SHM_TYPE_OR_NONE, S_SHM_MAX_HNDL_SZ, S_GRACEFUL_FINISH_REQUIRED_V &gt;::m_last_actively_opened_channel_id</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Identical to <a class="el" href="classipc_1_1session_1_1Client__session__impl.html#ade1b57a26147ececddbd0234c0b63be9" title="Logging-only *this-unique ID used in nicknaming the last actively-opened (via open_channel()) channel...">Client_session_impl::m_last_actively_opened_channel_id</a>. </p>

<p class="definition">Definition at line <a class="el" href="ipc__session_2src_2ipc_2session_2detail_2server__session__impl_8hpp_source.html#l00623">623</a> of file <a class="el" href="ipc__session_2src_2ipc_2session_2detail_2server__session__impl_8hpp_source.html">server_session_impl.hpp</a>.</p>

</div>
</div>
<a id="a54af1ca2d4e5485a2709f77d3f13635d" name="a54af1ca2d4e5485a2709f77d3f13635d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a54af1ca2d4e5485a2709f77d3f13635d">&#9670;&nbsp;</a></span>m_last_channel_mq_id</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;schema::MqType S_MQ_TYPE_OR_NONE, bool S_TRANSMIT_NATIVE_HANDLES, typename Mdt_payload , schema::ShmType S_SHM_TYPE_OR_NONE, size_t S_SHM_MAX_HNDL_SZ, bool S_GRACEFUL_FINISH_REQUIRED_V&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">unsigned int <a class="el" href="classipc_1_1session_1_1Server__session__impl.html">ipc::session::Server_session_impl</a>&lt; S_MQ_TYPE_OR_NONE, S_TRANSMIT_NATIVE_HANDLES, Mdt_payload, S_SHM_TYPE_OR_NONE, S_SHM_MAX_HNDL_SZ, S_GRACEFUL_FINISH_REQUIRED_V &gt;::m_last_channel_mq_id</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Unique component of MQ names generated by <a class="el" href="classipc_1_1session_1_1Server__session__impl.html#a84d54a57d3e06c064cde737d1f4be472" title="Helper for create_channel_and_resources(), invoked and compiled if and only if S_MQS_ENABLED,...">make_channel_mqs()</a> (if relevant; else untouched). </p>
<p >The mechanic of assigning this (1, 2, ...) is same as <a class="el" href="classipc_1_1session_1_1Server__session__impl.html#a869571c6ad3555df2396d561768b3f79" title="Identical to Client_session_impl::m_last_passively_opened_channel_id.">m_last_passively_opened_channel_id</a>. Note, though, this guy is very much not merely for logging: MQs must have unique names which are transmitted to the other side during the channel-open procedure. </p>

<p class="definition">Definition at line <a class="el" href="ipc__session_2src_2ipc_2session_2detail_2server__session__impl_8hpp_source.html#l00631">631</a> of file <a class="el" href="ipc__session_2src_2ipc_2session_2detail_2server__session__impl_8hpp_source.html">server_session_impl.hpp</a>.</p>

</div>
</div>
<a id="a869571c6ad3555df2396d561768b3f79" name="a869571c6ad3555df2396d561768b3f79"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a869571c6ad3555df2396d561768b3f79">&#9670;&nbsp;</a></span>m_last_passively_opened_channel_id</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;schema::MqType S_MQ_TYPE_OR_NONE, bool S_TRANSMIT_NATIVE_HANDLES, typename Mdt_payload , schema::ShmType S_SHM_TYPE_OR_NONE, size_t S_SHM_MAX_HNDL_SZ, bool S_GRACEFUL_FINISH_REQUIRED_V&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">unsigned int <a class="el" href="classipc_1_1session_1_1Server__session__impl.html">ipc::session::Server_session_impl</a>&lt; S_MQ_TYPE_OR_NONE, S_TRANSMIT_NATIVE_HANDLES, Mdt_payload, S_SHM_TYPE_OR_NONE, S_SHM_MAX_HNDL_SZ, S_GRACEFUL_FINISH_REQUIRED_V &gt;::m_last_passively_opened_channel_id</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Identical to <a class="el" href="classipc_1_1session_1_1Client__session__impl.html#a89d1ce46faa61df455b6f186eb892711" title="A-la m_last_actively_opened_channel_id but for passively-opened channels (on_master_channel_open_chan...">Client_session_impl::m_last_passively_opened_channel_id</a>. </p>

<p class="definition">Definition at line <a class="el" href="ipc__session_2src_2ipc_2session_2detail_2server__session__impl_8hpp_source.html#l00620">620</a> of file <a class="el" href="ipc__session_2src_2ipc_2session_2detail_2server__session__impl_8hpp_source.html">server_session_impl.hpp</a>.</p>

</div>
</div>
<a id="a59236329cf8e0f75c9ef628def1b97a7" name="a59236329cf8e0f75c9ef628def1b97a7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a59236329cf8e0f75c9ef628def1b97a7">&#9670;&nbsp;</a></span>m_log_in_on_done_func</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;schema::MqType S_MQ_TYPE_OR_NONE, bool S_TRANSMIT_NATIVE_HANDLES, typename Mdt_payload , schema::ShmType S_SHM_TYPE_OR_NONE, size_t S_SHM_MAX_HNDL_SZ, bool S_GRACEFUL_FINISH_REQUIRED_V&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">flow::async::Task_asio_err <a class="el" href="classipc_1_1session_1_1Server__session__impl.html">ipc::session::Server_session_impl</a>&lt; S_MQ_TYPE_OR_NONE, S_TRANSMIT_NATIVE_HANDLES, Mdt_payload, S_SHM_TYPE_OR_NONE, S_SHM_MAX_HNDL_SZ, S_GRACEFUL_FINISH_REQUIRED_V &gt;::m_log_in_on_done_func</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>The <code>on_done_func</code> argument to <a class="el" href="classipc_1_1session_1_1Server__session__impl.html#aee35d521d9997d48f6b5565730e60e93" title="For use by internal user Session_server: See Server_session_mv counterpart.">async_accept_log_in()</a>; <code>.empty()</code> except while the (at most one, ever) <a class="el" href="classipc_1_1session_1_1Server__session__impl.html#aee35d521d9997d48f6b5565730e60e93" title="For use by internal user Session_server: See Server_session_mv counterpart.">async_accept_log_in()</a> is outstanding. </p>
<p >In other words it is assigned at entry at <a class="el" href="classipc_1_1session_1_1Server__session__impl.html#aee35d521d9997d48f6b5565730e60e93" title="For use by internal user Session_server: See Server_session_mv counterpart.">async_accept_log_in()</a> and <code>.clear()</code>ed upon being invoked, indicating either success or failure of the log-in. Reminder: <a class="el" href="classipc_1_1session_1_1Server__session__impl.html#aee35d521d9997d48f6b5565730e60e93" title="For use by internal user Session_server: See Server_session_mv counterpart.">async_accept_log_in()</a> may not be re-attempted.</p>
<p >It may be invoked by dtor, if it does not fire before dtor. </p>

<p class="definition">Definition at line <a class="el" href="ipc__session_2src_2ipc_2session_2detail_2server__session__impl_8hpp_source.html#l00604">604</a> of file <a class="el" href="ipc__session_2src_2ipc_2session_2detail_2server__session__impl_8hpp_source.html">server_session_impl.hpp</a>.</p>

</div>
</div>
<a id="a81eb6769bc75d900bb3c442047249503" name="a81eb6769bc75d900bb3c442047249503"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a81eb6769bc75d900bb3c442047249503">&#9670;&nbsp;</a></span>m_master_channel</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;schema::MqType S_MQ_TYPE_OR_NONE, bool S_TRANSMIT_NATIVE_HANDLES, typename Mdt_payload , schema::ShmType S_SHM_TYPE_OR_NONE, size_t S_SHM_MAX_HNDL_SZ, bool S_GRACEFUL_FINISH_REQUIRED_V&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classipc_1_1session_1_1Server__session__impl.html#ab6cfad1c0be9815dc5411cd20c131213">Master_structured_channel_ptr</a> <a class="el" href="classipc_1_1session_1_1Server__session__impl.html">ipc::session::Server_session_impl</a>&lt; S_MQ_TYPE_OR_NONE, S_TRANSMIT_NATIVE_HANDLES, Mdt_payload, S_SHM_TYPE_OR_NONE, S_SHM_MAX_HNDL_SZ, S_GRACEFUL_FINISH_REQUIRED_V &gt;::m_master_channel</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>The session master channel. </p>
<p >Accessed in thread W only (not protected by mutex).</p><ul>
<li>Up to <a class="el" href="classipc_1_1session_1_1Server__session__impl.html#aee35d521d9997d48f6b5565730e60e93" title="For use by internal user Session_server: See Server_session_mv counterpart.">async_accept_log_in()</a>: this is null.</li>
<li>When <a class="el" href="classipc_1_1session_1_1Server__session__impl.html#aee35d521d9997d48f6b5565730e60e93" title="For use by internal user Session_server: See Server_session_mv counterpart.">async_accept_log_in()</a> is outstanding: this is not null.<ul>
<li>If it fails (and it cannot be re-attempted) it is renullified (though it could've been left alone too; realistically dtor is coming soon... maybe reconsider that).</li>
<li>Otherwise it remains non-null and immutable until dtor. </li>
</ul>
</li>
</ul>

<p class="definition">Definition at line <a class="el" href="ipc__session_2src_2ipc_2session_2detail_2server__session__impl_8hpp_source.html#l00653">653</a> of file <a class="el" href="ipc__session_2src_2ipc_2session_2detail_2server__session__impl_8hpp_source.html">server_session_impl.hpp</a>.</p>

</div>
</div>
<a id="a9be157fe8791e7be2dd43bd06480d3eb" name="a9be157fe8791e7be2dd43bd06480d3eb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9be157fe8791e7be2dd43bd06480d3eb">&#9670;&nbsp;</a></span>m_master_sock_stm</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;schema::MqType S_MQ_TYPE_OR_NONE, bool S_TRANSMIT_NATIVE_HANDLES, typename Mdt_payload , schema::ShmType S_SHM_TYPE_OR_NONE, size_t S_SHM_MAX_HNDL_SZ, bool S_GRACEFUL_FINISH_REQUIRED_V&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classipc_1_1transport_1_1sync__io_1_1Native__socket__stream.html">transport::sync_io::Native_socket_stream</a> <a class="el" href="classipc_1_1session_1_1Server__session__impl.html">ipc::session::Server_session_impl</a>&lt; S_MQ_TYPE_OR_NONE, S_TRANSMIT_NATIVE_HANDLES, Mdt_payload, S_SHM_TYPE_OR_NONE, S_SHM_MAX_HNDL_SZ, S_GRACEFUL_FINISH_REQUIRED_V &gt;::m_master_sock_stm</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>The pre-connected (PEER-state) socket stream peer; is non-as-if-default-cted only up to <a class="el" href="classipc_1_1session_1_1Server__session__impl.html#aee35d521d9997d48f6b5565730e60e93" title="For use by internal user Session_server: See Server_session_mv counterpart.">async_accept_log_in()</a>, at which point it is moved-to <a class="el" href="classipc_1_1session_1_1Server__session__impl.html#a81eb6769bc75d900bb3c442047249503" title="The session master channel.">m_master_channel</a>. </p>
<p >Accessed only the one time, in <a class="el" href="classipc_1_1session_1_1Server__session__impl.html#aee35d521d9997d48f6b5565730e60e93" title="For use by internal user Session_server: See Server_session_mv counterpart.">async_accept_log_in()</a>, and immediately emptied there. As of this writing that's in thread W, but that does not matter much. </p>

<p class="definition">Definition at line <a class="el" href="ipc__session_2src_2ipc_2session_2detail_2server__session__impl_8hpp_source.html#l00611">611</a> of file <a class="el" href="ipc__session_2src_2ipc_2session_2detail_2server__session__impl_8hpp_source.html">server_session_impl.hpp</a>.</p>

<p class="reference">Referenced by <a class="el" href="ipc__session_2src_2ipc_2session_2detail_2server__session__impl_8hpp_source.html#l00681">ipc::session::Server_session_impl&lt; S_MQ_TYPE_OR_NONE, S_TRANSMIT_NATIVE_HANDLES, Mdt_payload, S_SHM_TYPE_OR_NONE, S_SHM_MAX_HNDL_SZ, S_GRACEFUL_FINISH_REQUIRED_V &gt;::Server_session_impl()</a>.</p>

</div>
</div>
<a id="ad9f6932719c1565191da73bfa4a3923f" name="ad9f6932719c1565191da73bfa4a3923f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad9f6932719c1565191da73bfa4a3923f">&#9670;&nbsp;</a></span>m_pre_init_err_code</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;schema::MqType S_MQ_TYPE_OR_NONE, bool S_TRANSMIT_NATIVE_HANDLES, typename Mdt_payload , schema::ShmType S_SHM_TYPE_OR_NONE, size_t S_SHM_MAX_HNDL_SZ, bool S_GRACEFUL_FINISH_REQUIRED_V&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespaceipc.html#aa3192e586cc45d3e7c22463bf2760f89">Error_code</a> <a class="el" href="classipc_1_1session_1_1Server__session__impl.html">ipc::session::Server_session_impl</a>&lt; S_MQ_TYPE_OR_NONE, S_TRANSMIT_NATIVE_HANDLES, Mdt_payload, S_SHM_TYPE_OR_NONE, S_SHM_MAX_HNDL_SZ, S_GRACEFUL_FINISH_REQUIRED_V &gt;::m_pre_init_err_code</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Unused/falsy except when in almost-PEER state (past successful <a class="el" href="classipc_1_1session_1_1Server__session__impl.html#aee35d521d9997d48f6b5565730e60e93" title="For use by internal user Session_server: See Server_session_mv counterpart.">async_accept_log_in()</a>, before <a class="el" href="classipc_1_1session_1_1Server__session__impl.html#ac93040ccdaf5a261a053a8b55bd2e14e" title="See Server_session_mv counterpart.">init_handlers()</a> invoked by user), and <a class="el" href="classipc_1_1session_1_1Server__session__impl.html#a81eb6769bc75d900bb3c442047249503" title="The session master channel.">m_master_channel</a> reports incoming-direction error. </p>
<p >See class doc header for background. </p>

<p class="definition">Definition at line <a class="el" href="ipc__session_2src_2ipc_2session_2detail_2server__session__impl_8hpp_source.html#l00617">617</a> of file <a class="el" href="ipc__session_2src_2ipc_2session_2detail_2server__session__impl_8hpp_source.html">server_session_impl.hpp</a>.</p>

</div>
</div>
<a id="aeca3e83ea5e99271ba928550ea4fb2d4" name="aeca3e83ea5e99271ba928550ea4fb2d4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aeca3e83ea5e99271ba928550ea4fb2d4">&#9670;&nbsp;</a></span>m_protocol_negotiator</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;schema::MqType S_MQ_TYPE_OR_NONE, bool S_TRANSMIT_NATIVE_HANDLES, typename Mdt_payload , schema::ShmType S_SHM_TYPE_OR_NONE, size_t S_SHM_MAX_HNDL_SZ, bool S_GRACEFUL_FINISH_REQUIRED_V&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classipc_1_1transport_1_1Protocol__negotiator.html">transport::Protocol_negotiator</a> <a class="el" href="classipc_1_1session_1_1Server__session__impl.html">ipc::session::Server_session_impl</a>&lt; S_MQ_TYPE_OR_NONE, S_TRANSMIT_NATIVE_HANDLES, Mdt_payload, S_SHM_TYPE_OR_NONE, S_SHM_MAX_HNDL_SZ, S_GRACEFUL_FINISH_REQUIRED_V &gt;::m_protocol_negotiator</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Handles the protocol negotiation at the start of the pipe, as pertains to algorithms perpetuated by the vanilla <a class="el" href="namespaceipc_1_1session.html" title="Flow-IPC module providing the broad lifecycle and shared-resource organization  via the session conc...">ipc::session</a> <code><a class="el" href="classipc_1_1session_1_1Session.html" title="A documentation-only concept defining the local side of an IPC conversation (session) with another en...">Session</a></code> hierarchy. </p>
<p >Outgoing-direction state is touched when assembling <code>LogInReq</code> to send to opposing <code>Server_session</code>. Incoming-direction state is touched/verified at the start of interpreting <code>LogInRsp</code> receiver from there.</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classipc_1_1transport_1_1Protocol__negotiator.html" title="A simple state machine that, assuming the opposide side of a comm pathway uses an equivalent state ma...">transport::Protocol_negotiator</a> doc header for key background on the topic. </dd></dl>

<p class="definition">Definition at line <a class="el" href="ipc__session_2src_2ipc_2session_2detail_2server__session__impl_8hpp_source.html#l00584">584</a> of file <a class="el" href="ipc__session_2src_2ipc_2session_2detail_2server__session__impl_8hpp_source.html">server_session_impl.hpp</a>.</p>

</div>
</div>
<a id="a891c082930a837694606aff30c7026ed" name="a891c082930a837694606aff30c7026ed"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a891c082930a837694606aff30c7026ed">&#9670;&nbsp;</a></span>m_protocol_negotiator_aux</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;schema::MqType S_MQ_TYPE_OR_NONE, bool S_TRANSMIT_NATIVE_HANDLES, typename Mdt_payload , schema::ShmType S_SHM_TYPE_OR_NONE, size_t S_SHM_MAX_HNDL_SZ, bool S_GRACEFUL_FINISH_REQUIRED_V&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classipc_1_1transport_1_1Protocol__negotiator.html">transport::Protocol_negotiator</a> <a class="el" href="classipc_1_1session_1_1Server__session__impl.html">ipc::session::Server_session_impl</a>&lt; S_MQ_TYPE_OR_NONE, S_TRANSMIT_NATIVE_HANDLES, Mdt_payload, S_SHM_TYPE_OR_NONE, S_SHM_MAX_HNDL_SZ, S_GRACEFUL_FINISH_REQUIRED_V &gt;::m_protocol_negotiator_aux</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Analogous to <a class="el" href="classipc_1_1session_1_1Server__session__impl.html#aeca3e83ea5e99271ba928550ea4fb2d4" title="Handles the protocol negotiation at the start of the pipe, as pertains to algorithms perpetuated by t...">m_protocol_negotiator</a> but pertains to algorithms perpetuated by (if relevant) non-vanilla <a class="el" href="namespaceipc_1_1session.html" title="Flow-IPC module providing the broad lifecycle and shared-resource organization  via the session conc...">ipc::session</a> <code><a class="el" href="classipc_1_1session_1_1Session.html" title="A documentation-only concept defining the local side of an IPC conversation (session) with another en...">Session</a></code> hierarchy implemented on top of our vanilla <a class="el" href="namespaceipc_1_1session.html" title="Flow-IPC module providing the broad lifecycle and shared-resource organization  via the session conc...">ipc::session</a> <code><a class="el" href="classipc_1_1session_1_1Session.html" title="A documentation-only concept defining the local side of an IPC conversation (session) with another en...">Session</a></code> hierarchy. </p>
<p >For example, <a class="el" href="namespaceipc_1_1session_1_1shm.html" title="ipc::session sub-namespace that groups together facilities for SHM-backed sessions,...">ipc::session::shm</a> hierarchies can use this to version whatever additional protocol is required to establish SHM things.</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classipc_1_1transport_1_1Protocol__negotiator.html" title="A simple state machine that, assuming the opposide side of a comm pathway uses an equivalent state ma...">transport::Protocol_negotiator</a> doc header for key background on the topic. </dd></dl>

<p class="definition">Definition at line <a class="el" href="ipc__session_2src_2ipc_2session_2detail_2server__session__impl_8hpp_source.html#l00594">594</a> of file <a class="el" href="ipc__session_2src_2ipc_2session_2detail_2server__session__impl_8hpp_source.html">server_session_impl.hpp</a>.</p>

</div>
</div>
<a id="a0dc599111ce0b4b6d8cd003559e6c01c" name="a0dc599111ce0b4b6d8cd003559e6c01c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0dc599111ce0b4b6d8cd003559e6c01c">&#9670;&nbsp;</a></span>S_GRACEFUL_FINISH_REQUIRED</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;schema::MqType S_MQ_TYPE_OR_NONE, bool S_TRANSMIT_NATIVE_HANDLES, typename Mdt_payload , schema::ShmType S_SHM_TYPE_OR_NONE, size_t S_SHM_MAX_HNDL_SZ, bool S_GRACEFUL_FINISH_REQUIRED_V&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr bool <a class="el" href="classipc_1_1session_1_1Server__session__impl.html">ipc::session::Server_session_impl</a>&lt; S_MQ_TYPE_OR_NONE, S_TRANSMIT_NATIVE_HANDLES, Mdt_payload, S_SHM_TYPE_OR_NONE, S_SHM_MAX_HNDL_SZ, S_GRACEFUL_FINISH_REQUIRED_V &gt;::S_GRACEFUL_FINISH_REQUIRED = S_GRACEFUL_FINISH_REQUIRED_V</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Short-hand for template parameter knob <code>S_GRACEFUL_FINISH_REQUIRED_V</code>: see class template doc header. </p>

<p class="definition">Definition at line <a class="el" href="ipc__session_2src_2ipc_2session_2detail_2server__session__impl_8hpp_source.html#l00243">243</a> of file <a class="el" href="ipc__session_2src_2ipc_2session_2detail_2server__session__impl_8hpp_source.html">server_session_impl.hpp</a>.</p>

</div>
</div>
<a id="a005fcbc9ee215531c03d17fcc49ef544" name="a005fcbc9ee215531c03d17fcc49ef544"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a005fcbc9ee215531c03d17fcc49ef544">&#9670;&nbsp;</a></span>S_MQS_ENABLED</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;schema::MqType S_MQ_TYPE_OR_NONE, bool S_TRANSMIT_NATIVE_HANDLES, typename Mdt_payload , schema::ShmType S_SHM_TYPE_OR_NONE, size_t S_SHM_MAX_HNDL_SZ, bool S_GRACEFUL_FINISH_REQUIRED_V&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr bool <a class="el" href="classipc_1_1session_1_1Server__session__impl.html">ipc::session::Server_session_impl</a>&lt; S_MQ_TYPE_OR_NONE, S_TRANSMIT_NATIVE_HANDLES, Mdt_payload, S_SHM_TYPE_OR_NONE, S_SHM_MAX_HNDL_SZ, S_GRACEFUL_FINISH_REQUIRED_V &gt;::S_MQS_ENABLED = Base::S_MQS_ENABLED</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>See <a class="el" href="classipc_1_1session_1_1Server__session__mv.html" title="Implements Session concept on the Server_app end: a Session that is emitted in almost-PEER state by l...">Server_session_mv</a> counterpart. </p>

<p class="definition">Definition at line <a class="el" href="ipc__session_2src_2ipc_2session_2detail_2server__session__impl_8hpp_source.html#l00237">237</a> of file <a class="el" href="ipc__session_2src_2ipc_2session_2detail_2server__session__impl_8hpp_source.html">server_session_impl.hpp</a>.</p>

</div>
</div>
<a id="a1ded7990451b90f29e11f8fa7ce0e80b" name="a1ded7990451b90f29e11f8fa7ce0e80b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1ded7990451b90f29e11f8fa7ce0e80b">&#9670;&nbsp;</a></span>S_SHM_ENABLED</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;schema::MqType S_MQ_TYPE_OR_NONE, bool S_TRANSMIT_NATIVE_HANDLES, typename Mdt_payload , schema::ShmType S_SHM_TYPE_OR_NONE, size_t S_SHM_MAX_HNDL_SZ, bool S_GRACEFUL_FINISH_REQUIRED_V&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr bool <a class="el" href="classipc_1_1session_1_1Server__session__impl.html">ipc::session::Server_session_impl</a>&lt; S_MQ_TYPE_OR_NONE, S_TRANSMIT_NATIVE_HANDLES, Mdt_payload, S_SHM_TYPE_OR_NONE, S_SHM_MAX_HNDL_SZ, S_GRACEFUL_FINISH_REQUIRED_V &gt;::S_SHM_ENABLED = <a class="el" href="classipc_1_1session_1_1Server__session__impl.html#a582c808f7ea2104468e56bc135172296">S_SHM_TYPE</a> != schema::ShmType::NONE</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>See <a class="el" href="classipc_1_1session_1_1Session__mv.html" title="Implements the Session concept when it is in PEER state.">Session_mv</a> counterpart. </p>

<p class="definition">Definition at line <a class="el" href="ipc__session_2src_2ipc_2session_2detail_2server__session__impl_8hpp_source.html#l00231">231</a> of file <a class="el" href="ipc__session_2src_2ipc_2session_2detail_2server__session__impl_8hpp_source.html">server_session_impl.hpp</a>.</p>

</div>
</div>
<a id="a582c808f7ea2104468e56bc135172296" name="a582c808f7ea2104468e56bc135172296"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a582c808f7ea2104468e56bc135172296">&#9670;&nbsp;</a></span>S_SHM_TYPE</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;schema::MqType S_MQ_TYPE_OR_NONE, bool S_TRANSMIT_NATIVE_HANDLES, typename Mdt_payload , schema::ShmType S_SHM_TYPE_OR_NONE, size_t S_SHM_MAX_HNDL_SZ, bool S_GRACEFUL_FINISH_REQUIRED_V&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr schema::ShmType <a class="el" href="classipc_1_1session_1_1Server__session__impl.html">ipc::session::Server_session_impl</a>&lt; S_MQ_TYPE_OR_NONE, S_TRANSMIT_NATIVE_HANDLES, Mdt_payload, S_SHM_TYPE_OR_NONE, S_SHM_MAX_HNDL_SZ, S_GRACEFUL_FINISH_REQUIRED_V &gt;::S_SHM_TYPE = S_SHM_TYPE_OR_NONE</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>See <a class="el" href="classipc_1_1session_1_1Session__mv.html" title="Implements the Session concept when it is in PEER state.">Session_mv</a> counterpart. </p>

<p class="definition">Definition at line <a class="el" href="ipc__session_2src_2ipc_2session_2detail_2server__session__impl_8hpp_source.html#l00228">228</a> of file <a class="el" href="ipc__session_2src_2ipc_2session_2detail_2server__session__impl_8hpp_source.html">server_session_impl.hpp</a>.</p>

</div>
</div>
<a id="abfa7d61030e1d40cdc0085afacb43b6c" name="abfa7d61030e1d40cdc0085afacb43b6c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abfa7d61030e1d40cdc0085afacb43b6c">&#9670;&nbsp;</a></span>S_SOCKET_STREAM_ENABLED</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;schema::MqType S_MQ_TYPE_OR_NONE, bool S_TRANSMIT_NATIVE_HANDLES, typename Mdt_payload , schema::ShmType S_SHM_TYPE_OR_NONE, size_t S_SHM_MAX_HNDL_SZ, bool S_GRACEFUL_FINISH_REQUIRED_V&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr bool <a class="el" href="classipc_1_1session_1_1Server__session__impl.html">ipc::session::Server_session_impl</a>&lt; S_MQ_TYPE_OR_NONE, S_TRANSMIT_NATIVE_HANDLES, Mdt_payload, S_SHM_TYPE_OR_NONE, S_SHM_MAX_HNDL_SZ, S_GRACEFUL_FINISH_REQUIRED_V &gt;::S_SOCKET_STREAM_ENABLED = Base::S_SOCKET_STREAM_ENABLED</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>See <a class="el" href="classipc_1_1session_1_1Server__session__mv.html" title="Implements Session concept on the Server_app end: a Session that is emitted in almost-PEER state by l...">Server_session_mv</a> counterpart. </p>

<p class="definition">Definition at line <a class="el" href="ipc__session_2src_2ipc_2session_2detail_2server__session__impl_8hpp_source.html#l00240">240</a> of file <a class="el" href="ipc__session_2src_2ipc_2session_2detail_2server__session__impl_8hpp_source.html">server_session_impl.hpp</a>.</p>

</div>
</div>
<hr/>The documentation for this class was generated from the following files:<ul>
<li>session/detail/<a class="el" href="ipc__session_2src_2ipc_2session_2detail_2server__session__impl_8hpp_source.html">server_session_impl.hpp</a></li>
<li>session/detail/<a class="el" href="detail_2session__fwd_8hpp_source.html">session_fwd.hpp</a></li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Thu Feb 20 2025 03:02:03 for Flow-IPC by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.4
</small></address>
</body>
</html>
