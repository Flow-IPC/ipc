<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.9.4"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Flow-IPC: ipc::transport::struc::Heap_fixed_builder Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">Flow-IPC<span id="projectnumber">&#160;1.0.0</span>
   </div>
   <div id="projectbrief">Flow-IPC project: Full implementation reference.</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.4 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search",'Search','.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespaceipc.html">ipc</a></li><li class="navelem"><a class="el" href="namespaceipc_1_1transport.html">transport</a></li><li class="navelem"><a class="el" href="namespaceipc_1_1transport_1_1struc.html">struc</a></li><li class="navelem"><a class="el" href="classipc_1_1transport_1_1struc_1_1Heap__fixed__builder.html">Heap_fixed_builder</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#pub-types">Public Types</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pri-types">Private Types</a> &#124;
<a href="#pri-attribs">Private Attributes</a> &#124;
<a href="#related">Related Functions</a> &#124;
<a href="classipc_1_1transport_1_1struc_1_1Heap__fixed__builder-members.html">List of all members</a>  </div>
  <div class="headertitle"><div class="title">ipc::transport::struc::Heap_fixed_builder Class Reference</div></div>
</div><!--header-->
<div class="contents">

<p>Implements <a class="el" href="classipc_1_1transport_1_1struc_1_1Struct__builder.html" title="A documentation-only concept defining the behavior of an object capable of zero-copy-serializing,...">Struct_builder</a> concept by straightforwardly allocating fixed-size segments on-demand in the regular heap and serializing directly inside those segments.  
 <a href="classipc_1_1transport_1_1struc_1_1Heap__fixed__builder.html#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="heap__serializer_8hpp_source.html">heap_serializer.hpp</a>&gt;</code></p>
<div class="dynheader">
Inheritance diagram for ipc::transport::struc::Heap_fixed_builder:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="classipc_1_1transport_1_1struc_1_1Heap__fixed__builder__inherit__graph.svg" width="154" height="119"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe>
</div>
<center><span class="legend">[<a href="graph_legend.html">legend</a>]</span></center></div>
<div class="dynheader">
Collaboration diagram for ipc::transport::struc::Heap_fixed_builder:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="classipc_1_1transport_1_1struc_1_1Heap__fixed__builder__coll__graph.svg" width="448" height="155"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe>
</div>
<center><span class="legend">[<a href="graph_legend.html">legend</a>]</span></center></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="nested-classes" name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structipc_1_1transport_1_1struc_1_1Heap__fixed__builder_1_1Config.html">Config</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Implements <a class="el" href="structipc_1_1transport_1_1struc_1_1Struct__builder_1_1Config.html" title="Copy-ctible, copy-assignable, default-ctible type â€“ informally, cheaply copyable and likely an aggreg...">Struct_builder::Config</a> sub-concept.  <a href="structipc_1_1transport_1_1struc_1_1Heap__fixed__builder_1_1Config.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-types" name="pub-types"></a>
Public Types</h2></td></tr>
<tr class="memitem:ab01fea591145a42c216a5bb396cf0be7"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classipc_1_1transport_1_1struc_1_1Heap__fixed__builder.html#ab01fea591145a42c216a5bb396cf0be7">Session</a> = <a class="el" href="structipc_1_1transport_1_1struc_1_1Null__session.html">Null_session</a></td></tr>
<tr class="memdesc:ab01fea591145a42c216a5bb396cf0be7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Implements concept API.  <a href="classipc_1_1transport_1_1struc_1_1Heap__fixed__builder.html#ab01fea591145a42c216a5bb396cf0be7">More...</a><br /></td></tr>
<tr class="separator:ab01fea591145a42c216a5bb396cf0be7"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-methods" name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a6debedf2ddfff80f269d296c24686add"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classipc_1_1transport_1_1struc_1_1Heap__fixed__builder.html#a6debedf2ddfff80f269d296c24686add">Heap_fixed_builder</a> ()</td></tr>
<tr class="memdesc:a6debedf2ddfff80f269d296c24686add"><td class="mdescLeft">&#160;</td><td class="mdescRight">Implements concept API.  <a href="classipc_1_1transport_1_1struc_1_1Heap__fixed__builder.html#a6debedf2ddfff80f269d296c24686add">More...</a><br /></td></tr>
<tr class="separator:a6debedf2ddfff80f269d296c24686add"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac18c78936dffe8edb5990c4222e78fa5"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classipc_1_1transport_1_1struc_1_1Heap__fixed__builder.html#ac18c78936dffe8edb5990c4222e78fa5">Heap_fixed_builder</a> (const <a class="el" href="structipc_1_1transport_1_1struc_1_1Heap__fixed__builder_1_1Config.html">Config</a> &amp;config)</td></tr>
<tr class="memdesc:ac18c78936dffe8edb5990c4222e78fa5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Implements concept API.  <a href="classipc_1_1transport_1_1struc_1_1Heap__fixed__builder.html#ac18c78936dffe8edb5990c4222e78fa5">More...</a><br /></td></tr>
<tr class="separator:ac18c78936dffe8edb5990c4222e78fa5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a66e223d5706a98e64782f20187c795dd"><td class="memItemLeft" align="right" valign="top"><a id="a66e223d5706a98e64782f20187c795dd" name="a66e223d5706a98e64782f20187c795dd"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>Heap_fixed_builder</b> (const <a class="el" href="classipc_1_1transport_1_1struc_1_1Heap__fixed__builder.html">Heap_fixed_builder</a> &amp;)=delete</td></tr>
<tr class="memdesc:a66e223d5706a98e64782f20187c795dd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Disallow copy construction. <br /></td></tr>
<tr class="separator:a66e223d5706a98e64782f20187c795dd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aec92902440d6705137065b4463ef2e11"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classipc_1_1transport_1_1struc_1_1Heap__fixed__builder.html#aec92902440d6705137065b4463ef2e11">Heap_fixed_builder</a> (<a class="el" href="classipc_1_1transport_1_1struc_1_1Heap__fixed__builder.html">Heap_fixed_builder</a> &amp;&amp;src)</td></tr>
<tr class="memdesc:aec92902440d6705137065b4463ef2e11"><td class="mdescLeft">&#160;</td><td class="mdescRight">Implements concept API.  <a href="classipc_1_1transport_1_1struc_1_1Heap__fixed__builder.html#aec92902440d6705137065b4463ef2e11">More...</a><br /></td></tr>
<tr class="separator:aec92902440d6705137065b4463ef2e11"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa670a6356fe677ae5b1e629a3964b355"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classipc_1_1transport_1_1struc_1_1Heap__fixed__builder.html#aa670a6356fe677ae5b1e629a3964b355">~Heap_fixed_builder</a> ()</td></tr>
<tr class="memdesc:aa670a6356fe677ae5b1e629a3964b355"><td class="mdescLeft">&#160;</td><td class="mdescRight">Implements concept API.  <a href="classipc_1_1transport_1_1struc_1_1Heap__fixed__builder.html#aa670a6356fe677ae5b1e629a3964b355">More...</a><br /></td></tr>
<tr class="separator:aa670a6356fe677ae5b1e629a3964b355"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad1f2df842a49ea376749893af71a7a07"><td class="memItemLeft" align="right" valign="top"><a id="ad1f2df842a49ea376749893af71a7a07" name="ad1f2df842a49ea376749893af71a7a07"></a>
<a class="el" href="classipc_1_1transport_1_1struc_1_1Heap__fixed__builder.html">Heap_fixed_builder</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>operator=</b> (const <a class="el" href="classipc_1_1transport_1_1struc_1_1Heap__fixed__builder.html">Heap_fixed_builder</a> &amp;)=delete</td></tr>
<tr class="memdesc:ad1f2df842a49ea376749893af71a7a07"><td class="mdescLeft">&#160;</td><td class="mdescRight">Disallow copy assignment. <br /></td></tr>
<tr class="separator:ad1f2df842a49ea376749893af71a7a07"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5cc609dab2a244f8f9ba8ebe2c901cfe"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classipc_1_1transport_1_1struc_1_1Heap__fixed__builder.html">Heap_fixed_builder</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classipc_1_1transport_1_1struc_1_1Heap__fixed__builder.html#a5cc609dab2a244f8f9ba8ebe2c901cfe">operator=</a> (<a class="el" href="classipc_1_1transport_1_1struc_1_1Heap__fixed__builder.html">Heap_fixed_builder</a> &amp;&amp;src)</td></tr>
<tr class="memdesc:a5cc609dab2a244f8f9ba8ebe2c901cfe"><td class="mdescLeft">&#160;</td><td class="mdescRight">Implements concept API.  <a href="classipc_1_1transport_1_1struc_1_1Heap__fixed__builder.html#a5cc609dab2a244f8f9ba8ebe2c901cfe">More...</a><br /></td></tr>
<tr class="separator:a5cc609dab2a244f8f9ba8ebe2c901cfe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0c054e351753ce326620aa1dec12d923"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespaceipc_1_1transport_1_1struc.html#a52405569bf63eaef55f3c2435c885abc">Capnp_msg_builder_interface</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classipc_1_1transport_1_1struc_1_1Heap__fixed__builder.html#a0c054e351753ce326620aa1dec12d923">payload_msg_builder</a> ()</td></tr>
<tr class="memdesc:a0c054e351753ce326620aa1dec12d923"><td class="mdescLeft">&#160;</td><td class="mdescRight">Implements concept API.  <a href="classipc_1_1transport_1_1struc_1_1Heap__fixed__builder.html#a0c054e351753ce326620aa1dec12d923">More...</a><br /></td></tr>
<tr class="separator:a0c054e351753ce326620aa1dec12d923"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9fb6b2727c7cc0fb8fe7d231385b5517"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classipc_1_1transport_1_1struc_1_1Heap__fixed__builder.html#a9fb6b2727c7cc0fb8fe7d231385b5517">emit_serialization</a> (<a class="el" href="namespaceipc_1_1transport_1_1struc.html#a82a69eaa39cbe8a002de1266f1cbb5cb">Segment_ptrs</a> *target_blobs, const <a class="el" href="classipc_1_1transport_1_1struc_1_1Heap__fixed__builder.html#ab01fea591145a42c216a5bb396cf0be7">Session</a> &amp;session, <a class="el" href="namespaceipc.html#aa3192e586cc45d3e7c22463bf2760f89">Error_code</a> *err_code=0) const</td></tr>
<tr class="memdesc:a9fb6b2727c7cc0fb8fe7d231385b5517"><td class="mdescLeft">&#160;</td><td class="mdescRight">Implements concept API.  <a href="classipc_1_1transport_1_1struc_1_1Heap__fixed__builder.html#a9fb6b2727c7cc0fb8fe7d231385b5517">More...</a><br /></td></tr>
<tr class="separator:a9fb6b2727c7cc0fb8fe7d231385b5517"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0f8b3c876c577aa0550d13faa60e30d2"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classipc_1_1transport_1_1struc_1_1Heap__fixed__builder.html#a0f8b3c876c577aa0550d13faa60e30d2">n_serialization_segments</a> () const</td></tr>
<tr class="memdesc:a0f8b3c876c577aa0550d13faa60e30d2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Implements concept API.  <a href="classipc_1_1transport_1_1struc_1_1Heap__fixed__builder.html#a0f8b3c876c577aa0550d13faa60e30d2">More...</a><br /></td></tr>
<tr class="separator:a0f8b3c876c577aa0550d13faa60e30d2"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pri-types" name="pri-types"></a>
Private Types</h2></td></tr>
<tr class="memitem:a219ab2ebe348b0e45d4a67d414cda199"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classipc_1_1transport_1_1struc_1_1Heap__fixed__builder.html#a219ab2ebe348b0e45d4a67d414cda199">Capnp_heap_engine</a> = <a class="el" href="classipc_1_1transport_1_1struc_1_1Heap__fixed__builder__capnp__message__builder.html">Heap_fixed_builder_capnp_message_builder</a></td></tr>
<tr class="memdesc:a219ab2ebe348b0e45d4a67d414cda199"><td class="mdescLeft">&#160;</td><td class="mdescRight">Alias for the capnp <code>MallocMessageBuilder</code>-like serialization engine of ours.  <a href="classipc_1_1transport_1_1struc_1_1Heap__fixed__builder.html#a219ab2ebe348b0e45d4a67d414cda199">More...</a><br /></td></tr>
<tr class="separator:a219ab2ebe348b0e45d4a67d414cda199"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pri-attribs" name="pri-attribs"></a>
Private Attributes</h2></td></tr>
<tr class="memitem:afa719b263e06eb7359b948a36f251485"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classipc_1_1transport_1_1struc_1_1Heap__fixed__builder.html#afa719b263e06eb7359b948a36f251485">m_segment_sz</a></td></tr>
<tr class="memdesc:afa719b263e06eb7359b948a36f251485"><td class="mdescLeft">&#160;</td><td class="mdescRight">See ctor. We only store it to be able to emit <code>S_INTERNAL_ERROR_SERIALIZE_LEAF_TOO_BIG</code> in <a class="el" href="classipc_1_1transport_1_1struc_1_1Heap__fixed__builder.html#a9fb6b2727c7cc0fb8fe7d231385b5517" title="Implements concept API.">emit_serialization()</a>.  <a href="classipc_1_1transport_1_1struc_1_1Heap__fixed__builder.html#afa719b263e06eb7359b948a36f251485">More...</a><br /></td></tr>
<tr class="separator:afa719b263e06eb7359b948a36f251485"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8f8e07a71aa5e47d6b8094b2a004cc7d"><td class="memItemLeft" align="right" valign="top">boost::movelib::unique_ptr&lt; <a class="el" href="classipc_1_1transport_1_1struc_1_1Heap__fixed__builder.html#a219ab2ebe348b0e45d4a67d414cda199">Capnp_heap_engine</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classipc_1_1transport_1_1struc_1_1Heap__fixed__builder.html#a8f8e07a71aa5e47d6b8094b2a004cc7d">m_engine</a></td></tr>
<tr class="memdesc:a8f8e07a71aa5e47d6b8094b2a004cc7d"><td class="mdescLeft">&#160;</td><td class="mdescRight">The capnp builder engine which really does the work including owning the needed allocated segments so far.  <a href="classipc_1_1transport_1_1struc_1_1Heap__fixed__builder.html#a8f8e07a71aa5e47d6b8094b2a004cc7d">More...</a><br /></td></tr>
<tr class="separator:a8f8e07a71aa5e47d6b8094b2a004cc7d"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="related" name="related"></a>
Related Functions</h2></td></tr>
<tr><td class="ititle" colspan="2"><p >(Note that these are not member functions.) </p>
</td></tr>
<tr class="memitem:ae272f248d74db0486c4d9411715db15d"><td class="memItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classipc_1_1transport_1_1struc_1_1Heap__fixed__builder.html#ae272f248d74db0486c4d9411715db15d">operator&lt;&lt;</a> (std::ostream &amp;os, const <a class="el" href="classipc_1_1transport_1_1struc_1_1Heap__fixed__builder.html">Heap_fixed_builder</a> &amp;val)</td></tr>
<tr class="memdesc:ae272f248d74db0486c4d9411715db15d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Prints string representation of the given <code><a class="el" href="classipc_1_1transport_1_1struc_1_1Heap__fixed__builder.html" title="Implements Struct_builder concept by straightforwardly allocating fixed-size segments on-demand in th...">Heap_fixed_builder</a></code> to the given <code>ostream</code>.  <a href="classipc_1_1transport_1_1struc_1_1Heap__fixed__builder.html#ae272f248d74db0486c4d9411715db15d">More...</a><br /></td></tr>
<tr class="separator:ae272f248d74db0486c4d9411715db15d"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p >Implements <a class="el" href="classipc_1_1transport_1_1struc_1_1Struct__builder.html" title="A documentation-only concept defining the behavior of an object capable of zero-copy-serializing,...">Struct_builder</a> concept by straightforwardly allocating fixed-size segments on-demand in the regular heap and serializing directly inside those segments. </p>
<p >That is, each mutation via <a class="el" href="classipc_1_1transport_1_1struc_1_1Heap__fixed__builder.html#a0c054e351753ce326620aa1dec12d923" title="Implements concept API.">payload_msg_builder()</a> may, as needed, trigger a <code>malloc()</code> (or similar) of size N passed to the ctor of <a class="el" href="classipc_1_1transport_1_1struc_1_1Heap__fixed__builder.html" title="Implements Struct_builder concept by straightforwardly allocating fixed-size segments on-demand in th...">Heap_fixed_builder</a>; and each buffer returned by <a class="el" href="classipc_1_1transport_1_1struc_1_1Heap__fixed__builder.html#a9fb6b2727c7cc0fb8fe7d231385b5517" title="Implements concept API.">emit_serialization()</a> will be of size N or less.</p>
<h3>Failure mode</h3>
<p >As long as each leaf capnp object set via mutation of <a class="el" href="classipc_1_1transport_1_1struc_1_1Heap__fixed__builder.html#a0c054e351753ce326620aa1dec12d923" title="Implements concept API.">payload_msg_builder()</a> can be serialized in N bytes or fewer, <a class="el" href="classipc_1_1transport_1_1struc_1_1Heap__fixed__builder.html#a9fb6b2727c7cc0fb8fe7d231385b5517" title="Implements concept API.">emit_serialization()</a> shall succeed. For fixed-size leaves this is generally not a problem; for reasonable N in the KiB, things such as integers and enumerations won't be a problem. However for variable-size objects, particularly strings and blobs and lists and the like, it can be easy to exceed N. In this case, even though internally the problem could be detected at mutation time, it will be reported in the next <a class="el" href="classipc_1_1transport_1_1struc_1_1Heap__fixed__builder.html#a9fb6b2727c7cc0fb8fe7d231385b5517" title="Implements concept API.">emit_serialization()</a> call (as mandated by the concept API). Specifically <a class="el" href="namespaceipc_1_1transport_1_1struc_1_1error.html#a990b9ff850cf9aaf354efdd07d86a71da3deddc950bfa6d35ae03c9494eec15a6" title="Structured message serialization (e.g., when sending over channel): A user-mutated datum (e....">error::Code::S_INTERNAL_ERROR_SERIALIZE_LEAF_TOO_BIG</a> shall be emitted. See "Reasonable uses" below for discussion on avoiding this fate.</p>
<h3>Reasonable uses</h3>
<p >This is suitable for transmission via a <a class="el" href="classipc_1_1transport_1_1Blob__sender.html" title="A documentation-only concept defining the behavior of an object capable of reliably/in-order sending ...">Blob_sender</a> (or <a class="el" href="classipc_1_1transport_1_1Native__handle__sender.html" title="A documentation-only concept defining the behavior of an object capable of reliably/in-order sending ...">Native_handle_sender</a>) wherein each blob (or meta-blob, respectively) sent has either a hard size limit (meaning a <a class="el" href="classipc_1_1transport_1_1Blob__sender.html#a776b55ae93e65592b90c3943ca99e948" title="In PEER state: Synchronously, non-blockingly sends one discrete message, reliably and in-order,...">Blob_sender::send_blob()</a> or <a class="el" href="classipc_1_1transport_1_1Native__handle__sender.html#ac96b0aa01c286d525f9dcfa6dacc4220" title="In PEER state: Synchronously, non-blockingly sends one discrete message, reliably/in-order,...">Native_handle_sender::send_native_handle()</a> call will fail if this limit is exceeded) or an effective limit (meaning transmission performance is poor in the same event). Indeed the use cases that informed this strategy were:</p><ul>
<li><a class="el" href="classipc_1_1transport_1_1Blob__stream__mq__sender.html#a1d23a47d08ac7c31aa546ea02bb24c55" title="Implements Blob_sender API per contract.">Blob_stream_mq_sender::send_blob()</a> shall fail if <code>blob.size() &gt;= N</code>, where <code>N</code> is the message size limit passed to its ctor.</li>
<li><code>Native_socket_stream::send_*()</code> shall fail if <code>blob.size() &gt;= <a class="el" href="classipc_1_1transport_1_1sync__io_1_1Native__socket__stream.html#a00624e2fc3757012d13e3dc0feb26a21" title="The maximum length of a blob that can be sent by this protocol.">sync_io::Native_socket_stream::S_MAX_META_BLOB_LENGTH</a></code>.<ul>
<li>Moreover <a class="el" href="classipc_1_1transport_1_1Native__socket__stream.html" title="Implements both Native_handle_sender and Native_handle_receiver concepts by using a stream-oriented U...">Native_socket_stream</a> informally is documented to feature good performance compared to the MQ-based streams when not exceeding the "10s-of-KiB range" (quoting its doc header as of this writing).</li>
</ul>
</li>
</ul>
<p >In "Failure mode" above we pointed out an immediate danger if one uses <a class="el" href="classipc_1_1transport_1_1struc_1_1Heap__fixed__builder.html" title="Implements Struct_builder concept by straightforwardly allocating fixed-size segments on-demand in th...">Heap_fixed_builder</a> to naively serialize arbitrary user-supplied schemas. Simply put, if one mutates <a class="el" href="classipc_1_1transport_1_1struc_1_1Heap__fixed__builder.html#a0c054e351753ce326620aa1dec12d923" title="Implements concept API.">payload_msg_builder()</a> in such a way as to introduce a big leaf, such as a large image blob, then <a class="el" href="classipc_1_1transport_1_1struc_1_1Heap__fixed__builder.html#a9fb6b2727c7cc0fb8fe7d231385b5517" title="Implements concept API.">emit_serialization()</a>) will emit <a class="el" href="namespaceipc_1_1transport_1_1struc_1_1error.html#a990b9ff850cf9aaf354efdd07d86a71da3deddc950bfa6d35ae03c9494eec15a6" title="Structured message serialization (e.g., when sending over channel): A user-mutated datum (e....">error::Code::S_INTERNAL_ERROR_SERIALIZE_LEAF_TOO_BIG</a>; and that's the end of that.</p>
<p >Even if one avoids this somehow &ndash; let's say by always fragmenting large things into smaller-size leaves (itself undesirable: the point of serialization of structured data is to not have to worry about data representation at the application level) &ndash; this can lead to, well, a fragmented representation, inefficiently using each N-sized segment with too much unused space. So what to do?</p>
<p >One could write a builder similar to <a class="el" href="classipc_1_1transport_1_1struc_1_1Heap__fixed__builder.html" title="Implements Struct_builder concept by straightforwardly allocating fixed-size segments on-demand in th...">Heap_fixed_builder</a> minus the <code>_fixed</code> part; certainly capnp supplies the tools needed to simply allocate large-enough segments (internally, a <code>capnp::MallocMessageBuilder</code>-like <code>MessageBuilder</code> is used already; we'd just need to use different knob values on <code>MallocMessageBuilder</code> or similar and be less draconian in what segment sizes <a class="el" href="classipc_1_1transport_1_1struc_1_1Heap__fixed__builder.html#a9fb6b2727c7cc0fb8fe7d231385b5517" title="Implements concept API.">emit_serialization()</a>) will allow). Of course then the transport mechanism used for the resulting segments would need to be able to handle larger blobs. <a class="el" href="classipc_1_1transport_1_1Blob__stream__mq__sender.html" title="Implements Blob_sender concept by using an adopted Persistent_mq_handle MQ handle to an MQ (message q...">Blob_stream_mq_sender</a> already supports larger max message sizes, and <a class="el" href="classipc_1_1transport_1_1Native__socket__stream.html" title="Implements both Native_handle_sender and Native_handle_receiver concepts by using a stream-oriented U...">Native_socket_stream</a> with a larger or variable <code>S_MAX_META_BLOB_LENGTH</code> could be written. Or even without that one could split any too-large segments across multiple blobs. However that's hardly consolation in practice: too much RAM use could result; and/or the copying involved would eventually prove too expensive. So... probably the non-<code>_fixed</code>/multi-blob-segment approaches are not good enough, at least not in general. So what to do?</p>
<p >At least one approach is to use a 2-layer approach. The true serialization of the user's schema could be placed in SHared Memory (SHM). Then only a handle (or handles) to this SHM-stored serialization could be transmitted via <a class="el" href="classipc_1_1transport_1_1struc_1_1Heap__fixed__builder.html" title="Implements Struct_builder concept by straightforwardly allocating fixed-size segments on-demand in th...">Heap_fixed_builder</a>; even a <em>single</em> segment of small size would be enough to transmit as much, as each handle is (more or less) a pointer. Although the SHM-based builder (documented elsewhere) would be the one used at the higher level, internally it would leverage <a class="el" href="classipc_1_1transport_1_1struc_1_1Heap__fixed__builder.html" title="Implements Struct_builder concept by straightforwardly allocating fixed-size segments on-demand in th...">Heap_fixed_builder</a> to transmit the handle(s) to SHM.</p>
<p >Hence <a class="el" href="classipc_1_1transport_1_1struc_1_1Heap__fixed__builder.html" title="Implements Struct_builder concept by straightforwardly allocating fixed-size segments on-demand in th...">Heap_fixed_builder</a> remains of use; but keep in mind the above limitations and (at least its original) intended use.</p>
<p >The above discussion is a more specific treatment of the outer-serialization/inner-serialization discussion in the <a class="el" href="classipc_1_1transport_1_1struc_1_1Struct__builder.html" title="A documentation-only concept defining the behavior of an object capable of zero-copy-serializing,...">Struct_builder</a> concept doc header.</p>
<h3>Implementation</h3>
<p >If one is familiar with capnp, then one can probably quickly guess how this class template accomplishes what it promises in just the brief summary at the top of this doc header: <a class="el" href="classipc_1_1transport_1_1struc_1_1Heap__fixed__builder__capnp__message__builder.html" title="A capnp::MessageBuilder used by Heap_fixed_builder: similar to a capnp::MallocMessageBuilder with the...">Heap_fixed_builder_capnp_message_builder</a> is what we use internally; it's like <code>MallocMessageBuilder</code> but (1) mandates the equivalent of <code>AllocationStrategy::FIXED_SIZE</code> always and (2) has support for a framing prefix and postfix coexisting within each allocated buffer per segment (per our ctor args). As it must, that builder (like <code>MallocMessageBuilder</code>) is documented to allocate a larger-than-N segment if necessary to encode a particular too-large leaf. We do not stop this in and of itself; but <a class="el" href="classipc_1_1transport_1_1struc_1_1Heap__fixed__builder.html#a9fb6b2727c7cc0fb8fe7d231385b5517" title="Implements concept API.">emit_serialization()</a> simply refuses to return this resulting serialization, if it detects than indeed such a segment had to be allocated during preceding <a class="el" href="classipc_1_1transport_1_1struc_1_1Heap__fixed__builder.html#a0c054e351753ce326620aa1dec12d923" title="Implements concept API.">payload_msg_builder()</a> mutations. So <code>*this</code> will allocate and eat the needed RAM; but it simply will refuse to return it <code>public</code>ly. </p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classipc_1_1transport_1_1struc_1_1Heap__reader.html" title="Implements Struct_reader concept by straightforwardly interpreting a serialization by Heap_fixed_buil...">Heap_reader</a> Counterpart <a class="el" href="classipc_1_1transport_1_1struc_1_1Struct__reader.html" title="A documentation-only concept that is, conceptually, roughly what capnp::MessageReader is to capnp::Me...">Struct_reader</a> implementation that can deserialize data that this has serialized. </dd>
<dd>
<a class="el" href="classipc_1_1transport_1_1struc_1_1Struct__builder.html" title="A documentation-only concept defining the behavior of an object capable of zero-copy-serializing,...">Struct_builder</a>: implemented concept. </dd></dl>

<p class="definition">Definition at line <a class="el" href="heap__serializer_8hpp_source.html#l00130">130</a> of file <a class="el" href="heap__serializer_8hpp_source.html">heap_serializer.hpp</a>.</p>
</div><h2 class="groupheader">Member Typedef Documentation</h2>
<a id="a219ab2ebe348b0e45d4a67d414cda199" name="a219ab2ebe348b0e45d4a67d414cda199"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a219ab2ebe348b0e45d4a67d414cda199">&#9670;&nbsp;</a></span>Capnp_heap_engine</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classipc_1_1transport_1_1struc_1_1Heap__fixed__builder.html#a219ab2ebe348b0e45d4a67d414cda199">ipc::transport::struc::Heap_fixed_builder::Capnp_heap_engine</a> =  <a class="el" href="classipc_1_1transport_1_1struc_1_1Heap__fixed__builder__capnp__message__builder.html">Heap_fixed_builder_capnp_message_builder</a></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Alias for the capnp <code>MallocMessageBuilder</code>-like serialization engine of ours. </p>

<p class="definition">Definition at line <a class="el" href="heap__serializer_8hpp_source.html#l00278">278</a> of file <a class="el" href="heap__serializer_8hpp_source.html">heap_serializer.hpp</a>.</p>

</div>
</div>
<a id="ab01fea591145a42c216a5bb396cf0be7" name="ab01fea591145a42c216a5bb396cf0be7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab01fea591145a42c216a5bb396cf0be7">&#9670;&nbsp;</a></span>Session</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classipc_1_1transport_1_1struc_1_1Heap__fixed__builder.html#ab01fea591145a42c216a5bb396cf0be7">ipc::transport::struc::Heap_fixed_builder::Session</a> =  <a class="el" href="structipc_1_1transport_1_1struc_1_1Null__session.html">Null_session</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Implements concept API. </p>
<p >This being a non-zero-copy <a class="el" href="classipc_1_1transport_1_1struc_1_1Struct__builder.html" title="A documentation-only concept defining the behavior of an object capable of zero-copy-serializing,...">Struct_builder</a>, no information is needed for <a class="el" href="classipc_1_1transport_1_1struc_1_1Heap__fixed__builder.html#a9fb6b2727c7cc0fb8fe7d231385b5517" title="Implements concept API.">emit_serialization()</a> beyond the payload itself. </p>

<p class="definition">Definition at line <a class="el" href="heap__serializer_8hpp_source.html#l00177">177</a> of file <a class="el" href="heap__serializer_8hpp_source.html">heap_serializer.hpp</a>.</p>

</div>
</div>
<h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="a6debedf2ddfff80f269d296c24686add" name="a6debedf2ddfff80f269d296c24686add"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6debedf2ddfff80f269d296c24686add">&#9670;&nbsp;</a></span>Heap_fixed_builder() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">ipc::transport::struc::Heap_fixed_builder::Heap_fixed_builder </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">default</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Implements concept API. </p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classipc_1_1transport_1_1struc_1_1Struct__builder.html#a460aa187c0aaa5adfb81ecc902c7eca9" title="Default ctor, leaving *this in a state only suitable for destruction or being moved-to.">Struct_builder::Struct_builder()</a>: implemented concept. </dd></dl>

</div>
</div>
<a id="ac18c78936dffe8edb5990c4222e78fa5" name="ac18c78936dffe8edb5990c4222e78fa5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac18c78936dffe8edb5990c4222e78fa5">&#9670;&nbsp;</a></span>Heap_fixed_builder() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">ipc::transport::struc::Heap_fixed_builder::Heap_fixed_builder </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structipc_1_1transport_1_1struc_1_1Heap__fixed__builder_1_1Config.html">Config</a> &amp;&#160;</td>
          <td class="paramname"><em>config</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">explicit</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Implements concept API. </p>
<p >See <a class="el" href="structipc_1_1transport_1_1struc_1_1Heap__fixed__builder_1_1Config.html" title="Implements Struct_builder::Config sub-concept.">Config</a> doc header for information on how <code>*this</code> behavior is controlled by <code>config</code>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">config</td><td>See above.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classipc_1_1transport_1_1struc_1_1Struct__builder.html#a460aa187c0aaa5adfb81ecc902c7eca9" title="Default ctor, leaving *this in a state only suitable for destruction or being moved-to.">Struct_builder::Struct_builder()</a>: implemented concept. </dd></dl>

<p class="definition">Definition at line <a class="el" href="heap__serializer_8cpp_source.html#l00041">41</a> of file <a class="el" href="heap__serializer_8cpp_source.html">heap_serializer.cpp</a>.</p>

<p class="reference">References <a class="el" href="heap__serializer_8hpp_source.html#l00283">m_segment_sz</a>.</p>

</div>
</div>
<a id="aec92902440d6705137065b4463ef2e11" name="aec92902440d6705137065b4463ef2e11"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aec92902440d6705137065b4463ef2e11">&#9670;&nbsp;</a></span>Heap_fixed_builder() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">ipc::transport::struc::Heap_fixed_builder::Heap_fixed_builder </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classipc_1_1transport_1_1struc_1_1Heap__fixed__builder.html">Heap_fixed_builder</a> &amp;&amp;&#160;</td>
          <td class="paramname"><em>src</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">default</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Implements concept API. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">src</td><td>See above.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classipc_1_1transport_1_1struc_1_1Struct__builder.html#a460aa187c0aaa5adfb81ecc902c7eca9" title="Default ctor, leaving *this in a state only suitable for destruction or being moved-to.">Struct_builder::Struct_builder()</a>: implemented concept. </dd></dl>

</div>
</div>
<a id="aa670a6356fe677ae5b1e629a3964b355" name="aa670a6356fe677ae5b1e629a3964b355"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa670a6356fe677ae5b1e629a3964b355">&#9670;&nbsp;</a></span>~Heap_fixed_builder()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ipc::transport::struc::Heap_fixed_builder::~Heap_fixed_builder </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Implements concept API. </p>
<p >In this impl: frees all segments allocated on-demand so far. </p><dl class="section see"><dt>See also</dt><dd><a class="el" href="classipc_1_1transport_1_1struc_1_1Struct__builder.html#a008f6b6456a4b2dab63cdda5f9e4cfe5" title="Destructor. Do not use *payload_msg_builder() or any copies thereof past this.">Struct_builder::~Struct_builder()</a>: implemented concept. </dd></dl>

<p class="definition">Definition at line <a class="el" href="heap__serializer_8cpp_source.html#l00057">57</a> of file <a class="el" href="heap__serializer_8cpp_source.html">heap_serializer.cpp</a>.</p>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="a9fb6b2727c7cc0fb8fe7d231385b5517" name="a9fb6b2727c7cc0fb8fe7d231385b5517"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9fb6b2727c7cc0fb8fe7d231385b5517">&#9670;&nbsp;</a></span>emit_serialization()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ipc::transport::struc::Heap_fixed_builder::emit_serialization </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespaceipc_1_1transport_1_1struc.html#a82a69eaa39cbe8a002de1266f1cbb5cb">Segment_ptrs</a> *&#160;</td>
          <td class="paramname"><em>target_blobs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classipc_1_1transport_1_1struc_1_1Heap__fixed__builder.html#ab01fea591145a42c216a5bb396cf0be7">Session</a> &amp;&#160;</td>
          <td class="paramname"><em>session</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceipc.html#aa3192e586cc45d3e7c22463bf2760f89">Error_code</a> *&#160;</td>
          <td class="paramname"><em>err_code</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Implements concept API. </p>
<h3>Errors</h3>
<p >As discussed in class doc header, you should be on guard for the particular error <a class="el" href="namespaceipc_1_1transport_1_1struc_1_1error.html#a990b9ff850cf9aaf354efdd07d86a71da3deddc950bfa6d35ae03c9494eec15a6" title="Structured message serialization (e.g., when sending over channel): A user-mutated datum (e....">error::Code::S_INTERNAL_ERROR_SERIALIZE_LEAF_TOO_BIG</a>. See class doc header for discussion on how to avoid it. As of this writing no other failure modes exist.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">target_blobs</td><td>See above. Also recall (see ctor) that for each returned <code>blob</code>: individual segment sizes shall never exceed <a class="el" href="structipc_1_1transport_1_1struc_1_1Heap__fixed__builder_1_1Config.html#a9e759098107b22d8e40238eeb74c7f0b" title="See struct doc header.">Config::m_segment_sz</a> (for the [<code>begin()</code>, <code>end()</code>) area), with <code>start() == m_frame_prefix_sz</code>, and with <code>capacity() - start() - size() &gt;= m_frame_postfix_sz</code>. </td></tr>
    <tr><td class="paramname">session</td><td>See above. In this case the proper value is <code>NULL_SESSION</code>. </td></tr>
    <tr><td class="paramname">err_code</td><td>See above. <a class="el" href="namespaceipc.html#aa3192e586cc45d3e7c22463bf2760f89" title="Short-hand for flow::Error_code which is very common.">Error_code</a> generated: <a class="el" href="namespaceipc_1_1transport_1_1struc_1_1error.html#a990b9ff850cf9aaf354efdd07d86a71da3deddc950bfa6d35ae03c9494eec15a6" title="Structured message serialization (e.g., when sending over channel): A user-mutated datum (e....">error::Code::S_INTERNAL_ERROR_SERIALIZE_LEAF_TOO_BIG</a> (a previous mutation introduced a leaf whose serialization would necessitate allocating a segment exceeding <a class="el" href="structipc_1_1transport_1_1struc_1_1Heap__fixed__builder_1_1Config.html#a9e759098107b22d8e40238eeb74c7f0b" title="See struct doc header.">Config::m_segment_sz</a> &ndash; see ctor &ndash; in size).</td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classipc_1_1transport_1_1struc_1_1Struct__builder.html#af5085934123f075c6d0701e9e45e4bcc" title="Returns the serialization in the form of a sequence of 1+ pointers to Blobs which are guaranteed to r...">Struct_builder::emit_serialization()</a>: implemented concept. </dd></dl>

<p class="definition">Definition at line <a class="el" href="heap__serializer_8cpp_source.html#l00072">72</a> of file <a class="el" href="heap__serializer_8cpp_source.html">heap_serializer.cpp</a>.</p>

<p class="reference">References <a class="el" href="heap__serializer_8cpp_source.html#l00072">emit_serialization()</a>, <a class="el" href="heap__serializer_8hpp_source.html#l00300">m_engine</a>, <a class="el" href="heap__serializer_8hpp_source.html#l00283">m_segment_sz</a>, and <a class="el" href="namespaceipc_1_1transport_1_1struc_1_1error.html#a990b9ff850cf9aaf354efdd07d86a71da3deddc950bfa6d35ae03c9494eec15a6">ipc::transport::struc::error::S_INTERNAL_ERROR_SERIALIZE_LEAF_TOO_BIG</a>.</p>

<p class="reference">Referenced by <a class="el" href="ipc__shm_2src_2ipc_2transport_2struc_2shm_2serializer_8hpp_source.html#l00554">ipc::transport::struc::shm::Builder&lt; Shm_arena &gt;::emit_serialization()</a>, and <a class="el" href="heap__serializer_8cpp_source.html#l00072">emit_serialization()</a>.</p>
<div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="classipc_1_1transport_1_1struc_1_1Heap__fixed__builder_a9fb6b2727c7cc0fb8fe7d231385b5517_cgraph.svg" width="146" height="83"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe>
</div>
</div>
<div class="dynheader">
Here is the caller graph for this function:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="classipc_1_1transport_1_1struc_1_1Heap__fixed__builder_a9fb6b2727c7cc0fb8fe7d231385b5517_icgraph.svg" width="324" height="83"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe>
</div>
</div>

</div>
</div>
<a id="a0f8b3c876c577aa0550d13faa60e30d2" name="a0f8b3c876c577aa0550d13faa60e30d2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0f8b3c876c577aa0550d13faa60e30d2">&#9670;&nbsp;</a></span>n_serialization_segments()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t ipc::transport::struc::Heap_fixed_builder::n_serialization_segments </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Implements concept API. </p>
<dl class="section return"><dt>Returns</dt><dd>See above.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classipc_1_1transport_1_1struc_1_1Struct__builder.html#ae1516b0d68c48f2e13baf6aca366ac6c" title="Returns what target_blobs.size() would return after calling emit_serialization(&amp;target_blobs) (with a...">Struct_builder::n_serialization_segments()</a>: implemented concept. </dd></dl>

<p class="definition">Definition at line <a class="el" href="heap__serializer_8cpp_source.html#l00125">125</a> of file <a class="el" href="heap__serializer_8cpp_source.html">heap_serializer.cpp</a>.</p>

<p class="reference">References <a class="el" href="heap__serializer_8hpp_source.html#l00300">m_engine</a>.</p>

</div>
</div>
<a id="a5cc609dab2a244f8f9ba8ebe2c901cfe" name="a5cc609dab2a244f8f9ba8ebe2c901cfe"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5cc609dab2a244f8f9ba8ebe2c901cfe">&#9670;&nbsp;</a></span>operator=()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classipc_1_1transport_1_1struc_1_1Heap__fixed__builder.html">Heap_fixed_builder</a> &amp; ipc::transport::struc::Heap_fixed_builder::operator= </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classipc_1_1transport_1_1struc_1_1Heap__fixed__builder.html">Heap_fixed_builder</a> &amp;&amp;&#160;</td>
          <td class="paramname"><em>src</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">default</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Implements concept API. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">src</td><td>See above. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>See above.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classipc_1_1transport_1_1struc_1_1Struct__builder.html#a460aa187c0aaa5adfb81ecc902c7eca9" title="Default ctor, leaving *this in a state only suitable for destruction or being moved-to.">Struct_builder::Struct_builder()</a>: implemented concept. </dd></dl>

</div>
</div>
<a id="a0c054e351753ce326620aa1dec12d923" name="a0c054e351753ce326620aa1dec12d923"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0c054e351753ce326620aa1dec12d923">&#9670;&nbsp;</a></span>payload_msg_builder()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespaceipc_1_1transport_1_1struc.html#a52405569bf63eaef55f3c2435c885abc">Capnp_msg_builder_interface</a> * ipc::transport::struc::Heap_fixed_builder::payload_msg_builder </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Implements concept API. </p>
<dl class="section return"><dt>Returns</dt><dd>See above.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classipc_1_1transport_1_1struc_1_1Struct__builder.html#a9a4b9587c162f85ad4d3e0a5fad8dffb" title="Pointer to the payload Capnp_msg_builder_interface, suitable for mutation by the user.">Struct_builder::payload_msg_builder()</a>: implemented concept. </dd></dl>

<p class="definition">Definition at line <a class="el" href="heap__serializer_8cpp_source.html#l00065">65</a> of file <a class="el" href="heap__serializer_8cpp_source.html">heap_serializer.cpp</a>.</p>

<p class="reference">References <a class="el" href="heap__serializer_8hpp_source.html#l00300">m_engine</a>.</p>

<p class="reference">Referenced by <a class="el" href="ipc__transport__structured_2src_2ipc_2transport_2struc_2sync__io_2channel_8hpp_source.html#l04573">ipc::transport::struc::sync_io::Channel&lt; Channel_obj, Message_body, Struct_builder_config, Struct_reader_config &gt;::send_proto_neg()</a>.</p>
<div class="dynheader">
Here is the caller graph for this function:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="classipc_1_1transport_1_1struc_1_1Heap__fixed__builder_a0c054e351753ce326620aa1dec12d923_icgraph.svg" width="363" height="59"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe>
</div>
</div>

</div>
</div>
<h2 class="groupheader">Friends And Related Function Documentation</h2>
<a id="ae272f248d74db0486c4d9411715db15d" name="ae272f248d74db0486c4d9411715db15d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae272f248d74db0486c4d9411715db15d">&#9670;&nbsp;</a></span>operator&lt;&lt;()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::ostream &amp; operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>os</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classipc_1_1transport_1_1struc_1_1Heap__fixed__builder.html">Heap_fixed_builder</a> &amp;&#160;</td>
          <td class="paramname"><em>val</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Prints string representation of the given <code><a class="el" href="classipc_1_1transport_1_1struc_1_1Heap__fixed__builder.html" title="Implements Struct_builder concept by straightforwardly allocating fixed-size segments on-demand in th...">Heap_fixed_builder</a></code> to the given <code>ostream</code>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">os</td><td>Stream to which to write. </td></tr>
    <tr><td class="paramname">val</td><td>Object to serialize. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>os</code>. </dd></dl>

<p class="definition">Definition at line <a class="el" href="heap__serializer_8cpp_source.html#l00132">132</a> of file <a class="el" href="heap__serializer_8cpp_source.html">heap_serializer.cpp</a>.</p>

</div>
</div>
<h2 class="groupheader">Member Data Documentation</h2>
<a id="a8f8e07a71aa5e47d6b8094b2a004cc7d" name="a8f8e07a71aa5e47d6b8094b2a004cc7d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8f8e07a71aa5e47d6b8094b2a004cc7d">&#9670;&nbsp;</a></span>m_engine</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">boost::movelib::unique_ptr&lt;<a class="el" href="classipc_1_1transport_1_1struc_1_1Heap__fixed__builder.html#a219ab2ebe348b0e45d4a67d414cda199">Capnp_heap_engine</a>&gt; ipc::transport::struc::Heap_fixed_builder::m_engine</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>The capnp builder engine which really does the work including owning the needed allocated segments so far. </p>
<p ><a class="el" href="classipc_1_1transport_1_1struc_1_1Heap__fixed__builder.html#a0c054e351753ce326620aa1dec12d923" title="Implements concept API.">payload_msg_builder()</a> simply returns (up-cast of) <code>&amp;m_engine</code>.</p>
<h3>Why the <code>unique_ptr</code> wrapper?</h3>
<p >This is subtler than it appears: We need to be move-ctible and move-assignable; and <a class="el" href="classipc_1_1transport_1_1struc_1_1Heap__fixed__builder.html#a8f8e07a71aa5e47d6b8094b2a004cc7d" title="The capnp builder engine which really does the work including owning the needed allocated segments so...">m_engine</a> therefore does too &ndash; and in fact <a class="el" href="classipc_1_1transport_1_1struc_1_1Heap__fixed__builder.html#a219ab2ebe348b0e45d4a67d414cda199" title="Alias for the capnp MallocMessageBuilder-like serialization engine of ours.">Capnp_heap_engine</a> <em>is</em>. So the <code>unique_ptr</code> wrapping appears superfluous and a waste of compute and space at least. However, see the note on move-ctibility/assignability in <a class="el" href="classipc_1_1transport_1_1struc_1_1Heap__fixed__builder__capnp__message__builder.html" title="A capnp::MessageBuilder used by Heap_fixed_builder: similar to a capnp::MallocMessageBuilder with the...">Heap_fixed_builder_capnp_message_builder</a> doc header: It <em>is</em> those things, because super-class (interface) <a class="el" href="classCapnp__msg__builder__interface.html">Capnp_msg_builder_interface</a> is, but any <a class="el" href="classCapnp__msg__builder__interface.html">Capnp_msg_builder_interface</a> sub-class's move (if available) has to copy ~200 bytes at least. Whether the extra alloc/dealloc is better than a copy of that length is a bit questionable, but we suspect it is at least somewhat better.</p>
<p >As a side benefit: it's an easy way to detect a moved-from <code>*this</code> and <code>assert()</code> in some situations. </p>

<p class="definition">Definition at line <a class="el" href="heap__serializer_8hpp_source.html#l00300">300</a> of file <a class="el" href="heap__serializer_8hpp_source.html">heap_serializer.hpp</a>.</p>

<p class="reference">Referenced by <a class="el" href="heap__serializer_8cpp_source.html#l00072">emit_serialization()</a>, <a class="el" href="heap__serializer_8cpp_source.html#l00125">n_serialization_segments()</a>, and <a class="el" href="heap__serializer_8cpp_source.html#l00065">payload_msg_builder()</a>.</p>

</div>
</div>
<a id="afa719b263e06eb7359b948a36f251485" name="afa719b263e06eb7359b948a36f251485"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afa719b263e06eb7359b948a36f251485">&#9670;&nbsp;</a></span>m_segment_sz</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_t ipc::transport::struc::Heap_fixed_builder::m_segment_sz</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>See ctor. We only store it to be able to emit <code>S_INTERNAL_ERROR_SERIALIZE_LEAF_TOO_BIG</code> in <a class="el" href="classipc_1_1transport_1_1struc_1_1Heap__fixed__builder.html#a9fb6b2727c7cc0fb8fe7d231385b5517" title="Implements concept API.">emit_serialization()</a>. </p>

<p class="definition">Definition at line <a class="el" href="heap__serializer_8hpp_source.html#l00283">283</a> of file <a class="el" href="heap__serializer_8hpp_source.html">heap_serializer.hpp</a>.</p>

<p class="reference">Referenced by <a class="el" href="heap__serializer_8cpp_source.html#l00072">emit_serialization()</a>, and <a class="el" href="heap__serializer_8cpp_source.html#l00041">Heap_fixed_builder()</a>.</p>

</div>
</div>
<hr/>The documentation for this class was generated from the following files:<ul>
<li>transport/struc/<a class="el" href="heap__serializer_8hpp_source.html">heap_serializer.hpp</a></li>
<li>transport/struc/<a class="el" href="heap__serializer_8cpp_source.html">heap_serializer.cpp</a></li>
<li>transport/struc/<a class="el" href="struc__fwd_8hpp_source.html">struc_fwd.hpp</a></li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Sun Mar 3 2024 05:42:43 for Flow-IPC by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.4
</small></address>
</body>
</html>
