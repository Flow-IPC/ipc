<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.9.4"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Flow-IPC: ipc::session::Server_session_mv&lt; Server_session_impl_t &gt; Class Template Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">Flow-IPC<span id="projectnumber">&#160;1.0.0</span>
   </div>
   <div id="projectbrief">Flow-IPC project: Full implementation reference.</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.4 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search",'Search','.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespaceipc.html">ipc</a></li><li class="navelem"><a class="el" href="namespaceipc_1_1session.html">session</a></li><li class="navelem"><a class="el" href="classipc_1_1session_1_1Server__session__mv.html">Server_session_mv</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-types">Public Types</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pro-methods">Protected Member Functions</a> &#124;
<a href="#related">Related Functions</a> &#124;
<a href="classipc_1_1session_1_1Server__session__mv-members.html">List of all members</a>  </div>
  <div class="headertitle"><div class="title">ipc::session::Server_session_mv&lt; Server_session_impl_t &gt; Class Template Reference</div></div>
</div><!--header-->
<div class="contents">

<p>Implements <a class="el" href="classipc_1_1session_1_1Session.html" title="A documentation-only concept defining the local side of an IPC conversation (session) with another en...">Session</a> concept on the <a class="el" href="structipc_1_1session_1_1Server__app.html" title="An App that is used as a server in at least one client-server IPC split.">Server_app</a> end: a <a class="el" href="classipc_1_1session_1_1Session.html" title="A documentation-only concept defining the local side of an IPC conversation (session) with another en...">Session</a> that is emitted in almost-PEER state by local <a class="el" href="classipc_1_1session_1_1Session__server.html" title="To be instantiated typically once in a given process, an object of this type asynchronously listens f...">Session_server</a> accepting a connection by an opposing <code><a class="el" href="classipc_1_1session_1_1Client__session__mv.html#ab971ea979200828d572638c60d7d9f44" title="To be invoked in NULL state only, and not as-if default-cted, it synchronously and non-blockingly att...">Client_session_mv::sync_connect()</a></code>.  
 <a href="classipc_1_1session_1_1Server__session__mv.html#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="ipc__session_2src_2ipc_2session_2server__session_8hpp_source.html">server_session.hpp</a>&gt;</code></p>
<div class="dynheader">
Inheritance diagram for ipc::session::Server_session_mv&lt; Server_session_impl_t &gt;:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="classipc_1_1session_1_1Server__session__mv__inherit__graph.svg" width="198" height="143"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe>
</div>
<center><span class="legend">[<a href="graph_legend.html">legend</a>]</span></center></div>
<div class="dynheader">
Collaboration diagram for ipc::session::Server_session_mv&lt; Server_session_impl_t &gt;:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="classipc_1_1session_1_1Server__session__mv__coll__graph.svg" width="796" height="174"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe>
</div>
<center><span class="legend">[<a href="graph_legend.html">legend</a>]</span></center></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-types" name="pub-types"></a>
Public Types</h2></td></tr>
<tr class="memitem:a17a6288bac54ea18317582121ed8e10d"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classipc_1_1session_1_1Server__session__mv.html#a17a6288bac54ea18317582121ed8e10d">Base</a> = <a class="el" href="classipc_1_1session_1_1Session__mv.html">Session_mv</a>&lt; Server_session_impl_t &gt;</td></tr>
<tr class="memdesc:a17a6288bac54ea18317582121ed8e10d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Short-hand for our base class. To the user: note its <code>public</code> API is inherited.  <a href="classipc_1_1session_1_1Server__session__mv.html#a17a6288bac54ea18317582121ed8e10d">More...</a><br /></td></tr>
<tr class="separator:a17a6288bac54ea18317582121ed8e10d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pub_types_classipc_1_1session_1_1Session__mv"><td colspan="2" onclick="javascript:toggleInherit('pub_types_classipc_1_1session_1_1Session__mv')"><img src="closed.png" alt="-"/>&#160;Public Types inherited from <a class="el" href="classipc_1_1session_1_1Session__mv.html">ipc::session::Session_mv&lt; Server_session_impl_t &gt;</a></td></tr>
<tr class="memitem:ab92df09d894e6e1aaf3c2733da594fd2 inherit pub_types_classipc_1_1session_1_1Session__mv"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classipc_1_1session_1_1Session__mv.html#ab92df09d894e6e1aaf3c2733da594fd2">Channel_obj</a> = typename Impl::Channel_obj</td></tr>
<tr class="memdesc:ab92df09d894e6e1aaf3c2733da594fd2 inherit pub_types_classipc_1_1session_1_1Session__mv"><td class="mdescLeft">&#160;</td><td class="mdescRight">Implements Session API per contract.  <a href="classipc_1_1session_1_1Session__mv.html#ab92df09d894e6e1aaf3c2733da594fd2">More...</a><br /></td></tr>
<tr class="separator:ab92df09d894e6e1aaf3c2733da594fd2 inherit pub_types_classipc_1_1session_1_1Session__mv"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af87da439644b2afd73d6a13d97e7985f inherit pub_types_classipc_1_1session_1_1Session__mv"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classipc_1_1session_1_1Session__mv.html#af87da439644b2afd73d6a13d97e7985f">Channels</a> = typename Impl::Channels</td></tr>
<tr class="memdesc:af87da439644b2afd73d6a13d97e7985f inherit pub_types_classipc_1_1session_1_1Session__mv"><td class="mdescLeft">&#160;</td><td class="mdescRight">Container (<code>vector&lt;&gt;</code>) of <a class="el" href="classipc_1_1session_1_1Session__mv.html#ab92df09d894e6e1aaf3c2733da594fd2" title="Implements Session API per contract.">Channel_obj</a>.  <a href="classipc_1_1session_1_1Session__mv.html#af87da439644b2afd73d6a13d97e7985f">More...</a><br /></td></tr>
<tr class="separator:af87da439644b2afd73d6a13d97e7985f inherit pub_types_classipc_1_1session_1_1Session__mv"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acccbc643f29f002075e66cd134da70bd inherit pub_types_classipc_1_1session_1_1Session__mv"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classipc_1_1session_1_1Session__mv.html#acccbc643f29f002075e66cd134da70bd">Mdt_payload_obj</a> = typename Impl::Mdt_payload_obj</td></tr>
<tr class="memdesc:acccbc643f29f002075e66cd134da70bd inherit pub_types_classipc_1_1session_1_1Session__mv"><td class="mdescLeft">&#160;</td><td class="mdescRight">Implements Session API per contract.  <a href="classipc_1_1session_1_1Session__mv.html#acccbc643f29f002075e66cd134da70bd">More...</a><br /></td></tr>
<tr class="separator:acccbc643f29f002075e66cd134da70bd inherit pub_types_classipc_1_1session_1_1Session__mv"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af10f452e602e4ea7389c6a77dd9a0f88 inherit pub_types_classipc_1_1session_1_1Session__mv"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classipc_1_1session_1_1Session__mv.html#af10f452e602e4ea7389c6a77dd9a0f88">Mdt_builder</a> = typename Impl::Mdt_builder</td></tr>
<tr class="memdesc:af10f452e602e4ea7389c6a77dd9a0f88 inherit pub_types_classipc_1_1session_1_1Session__mv"><td class="mdescLeft">&#160;</td><td class="mdescRight">Implements Session API per contract.  <a href="classipc_1_1session_1_1Session__mv.html#af10f452e602e4ea7389c6a77dd9a0f88">More...</a><br /></td></tr>
<tr class="separator:af10f452e602e4ea7389c6a77dd9a0f88 inherit pub_types_classipc_1_1session_1_1Session__mv"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a787253f02859ea6b99ce3eba92766431 inherit pub_types_classipc_1_1session_1_1Session__mv"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classipc_1_1session_1_1Session__mv.html#a787253f02859ea6b99ce3eba92766431">Mdt_builder_ptr</a> = typename Impl::Mdt_builder_ptr</td></tr>
<tr class="memdesc:a787253f02859ea6b99ce3eba92766431 inherit pub_types_classipc_1_1session_1_1Session__mv"><td class="mdescLeft">&#160;</td><td class="mdescRight">Implements Session API per contract.  <a href="classipc_1_1session_1_1Session__mv.html#a787253f02859ea6b99ce3eba92766431">More...</a><br /></td></tr>
<tr class="separator:a787253f02859ea6b99ce3eba92766431 inherit pub_types_classipc_1_1session_1_1Session__mv"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2b1215fb0c9738b9fcfbb337d23c43df inherit pub_types_classipc_1_1session_1_1Session__mv"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classipc_1_1session_1_1Session__mv.html#a2b1215fb0c9738b9fcfbb337d23c43df">Mdt_reader_ptr</a> = typename Impl::Mdt_reader_ptr</td></tr>
<tr class="memdesc:a2b1215fb0c9738b9fcfbb337d23c43df inherit pub_types_classipc_1_1session_1_1Session__mv"><td class="mdescLeft">&#160;</td><td class="mdescRight">Implements Session API per contract.  <a href="classipc_1_1session_1_1Session__mv.html#a2b1215fb0c9738b9fcfbb337d23c43df">More...</a><br /></td></tr>
<tr class="separator:a2b1215fb0c9738b9fcfbb337d23c43df inherit pub_types_classipc_1_1session_1_1Session__mv"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac205819d4a3a066f31b5af311ff40a2a inherit pub_types_classipc_1_1session_1_1Session__mv"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classipc_1_1session_1_1Session__mv.html#ac205819d4a3a066f31b5af311ff40a2a">Structured_channel</a> = typename <a class="el" href="namespaceipc_1_1transport_1_1struc.html#aca041b0efd4a9ae18e10088b2ee3c052">transport::struc::Channel_via_heap</a>&lt; <a class="el" href="classipc_1_1session_1_1Session__mv.html#ab92df09d894e6e1aaf3c2733da594fd2">Channel_obj</a>, Message_body &gt;</td></tr>
<tr class="memdesc:ac205819d4a3a066f31b5af311ff40a2a inherit pub_types_classipc_1_1session_1_1Session__mv"><td class="mdescLeft">&#160;</td><td class="mdescRight">Implements Session API per contract.  <a href="classipc_1_1session_1_1Session__mv.html#ac205819d4a3a066f31b5af311ff40a2a">More...</a><br /></td></tr>
<tr class="separator:ac205819d4a3a066f31b5af311ff40a2a inherit pub_types_classipc_1_1session_1_1Session__mv"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9f6e9a57f6e6ab420d554a2c0eba7877 inherit pub_types_classipc_1_1session_1_1Session__mv"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classipc_1_1session_1_1Session__mv.html#a9f6e9a57f6e6ab420d554a2c0eba7877">Structured_msg_builder_config</a> = typename Impl::Structured_msg_builder_config</td></tr>
<tr class="memdesc:a9f6e9a57f6e6ab420d554a2c0eba7877 inherit pub_types_classipc_1_1session_1_1Session__mv"><td class="mdescLeft">&#160;</td><td class="mdescRight">Implements Session API per contract.  <a href="classipc_1_1session_1_1Session__mv.html#a9f6e9a57f6e6ab420d554a2c0eba7877">More...</a><br /></td></tr>
<tr class="separator:a9f6e9a57f6e6ab420d554a2c0eba7877 inherit pub_types_classipc_1_1session_1_1Session__mv"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a335c3585402cc9430f8c909e8c7e55f4 inherit pub_types_classipc_1_1session_1_1Session__mv"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classipc_1_1session_1_1Session__mv.html#a335c3585402cc9430f8c909e8c7e55f4">Structured_msg_reader_config</a> = typename Impl::Structured_msg_builder_config</td></tr>
<tr class="memdesc:a335c3585402cc9430f8c909e8c7e55f4 inherit pub_types_classipc_1_1session_1_1Session__mv"><td class="mdescLeft">&#160;</td><td class="mdescRight">Implements Session API per contract.  <a href="classipc_1_1session_1_1Session__mv.html#a335c3585402cc9430f8c909e8c7e55f4">More...</a><br /></td></tr>
<tr class="separator:a335c3585402cc9430f8c909e8c7e55f4 inherit pub_types_classipc_1_1session_1_1Session__mv"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-methods" name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:ac873543383b7a6da94d4353231f34ec2"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="structipc_1_1session_1_1Client__app.html">Client_app</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classipc_1_1session_1_1Server__session__mv.html#ac873543383b7a6da94d4353231f34ec2">client_app</a> () const</td></tr>
<tr class="memdesc:ac873543383b7a6da94d4353231f34ec2"><td class="mdescLeft">&#160;</td><td class="mdescRight">The opposing application is described by a <a class="el" href="structipc_1_1session_1_1Client__app.html" title="An App that is used as a client in at least one client-server IPC split.">Client_app</a>; this is that description.  <a href="classipc_1_1session_1_1Server__session__mv.html#ac873543383b7a6da94d4353231f34ec2">More...</a><br /></td></tr>
<tr class="separator:ac873543383b7a6da94d4353231f34ec2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a99097e5aa6883877c74f8a93ebc9f3e1"><td class="memTemplParams" colspan="2">template&lt;typename Task_err , typename On_passive_open_channel_handler &gt; </td></tr>
<tr class="memitem:a99097e5aa6883877c74f8a93ebc9f3e1"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classipc_1_1session_1_1Server__session__mv.html#a99097e5aa6883877c74f8a93ebc9f3e1">init_handlers</a> (Task_err &amp;&amp;on_err_func_arg, On_passive_open_channel_handler &amp;&amp;on_passive_open_channel_func_arg)</td></tr>
<tr class="memdesc:a99097e5aa6883877c74f8a93ebc9f3e1"><td class="mdescLeft">&#160;</td><td class="mdescRight">To be invoked by public user upon first obtaining <code>*this</code>: memorizes the given on-error and on-passive-open handlers thus moving this <a class="el" href="classipc_1_1session_1_1Server__session__mv.html" title="Implements Session concept on the Server_app end: a Session that is emitted in almost-PEER state by l...">Server_session_mv</a> to PEER state wherein it is a formal <a class="el" href="classipc_1_1session_1_1Session.html" title="A documentation-only concept defining the local side of an IPC conversation (session) with another en...">Session</a> concept impl.  <a href="classipc_1_1session_1_1Server__session__mv.html#a99097e5aa6883877c74f8a93ebc9f3e1">More...</a><br /></td></tr>
<tr class="separator:a99097e5aa6883877c74f8a93ebc9f3e1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac1ea393b9d0d7de60f7433cbc7dad0d4"><td class="memTemplParams" colspan="2">template&lt;typename Task_err &gt; </td></tr>
<tr class="memitem:ac1ea393b9d0d7de60f7433cbc7dad0d4"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classipc_1_1session_1_1Server__session__mv.html#ac1ea393b9d0d7de60f7433cbc7dad0d4">init_handlers</a> (Task_err &amp;&amp;on_err_func_arg)</td></tr>
<tr class="memdesc:ac1ea393b9d0d7de60f7433cbc7dad0d4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Alternative to the other <a class="el" href="classipc_1_1session_1_1Server__session__mv.html#a99097e5aa6883877c74f8a93ebc9f3e1" title="To be invoked by public user upon first obtaining *this: memorizes the given on-error and on-passive-...">init_handlers()</a>.  <a href="classipc_1_1session_1_1Server__session__mv.html#ac1ea393b9d0d7de60f7433cbc7dad0d4">More...</a><br /></td></tr>
<tr class="separator:ac1ea393b9d0d7de60f7433cbc7dad0d4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pub_methods_classipc_1_1session_1_1Session__mv"><td colspan="2" onclick="javascript:toggleInherit('pub_methods_classipc_1_1session_1_1Session__mv')"><img src="closed.png" alt="-"/>&#160;Public Member Functions inherited from <a class="el" href="classipc_1_1session_1_1Session__mv.html">ipc::session::Session_mv&lt; Server_session_impl_t &gt;</a></td></tr>
<tr class="memitem:af964cb260766684d46503b43d0faa777 inherit pub_methods_classipc_1_1session_1_1Session__mv"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classipc_1_1session_1_1Session__mv.html#af964cb260766684d46503b43d0faa777">Session_mv</a> ()</td></tr>
<tr class="memdesc:af964cb260766684d46503b43d0faa777 inherit pub_methods_classipc_1_1session_1_1Session__mv"><td class="mdescLeft">&#160;</td><td class="mdescRight">Implements Session API per contract.  <a href="classipc_1_1session_1_1Session__mv.html#af964cb260766684d46503b43d0faa777">More...</a><br /></td></tr>
<tr class="separator:af964cb260766684d46503b43d0faa777 inherit pub_methods_classipc_1_1session_1_1Session__mv"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad1cffabdbc41809399b4bda9330f5367 inherit pub_methods_classipc_1_1session_1_1Session__mv"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classipc_1_1session_1_1Session__mv.html#ad1cffabdbc41809399b4bda9330f5367">Session_mv</a> (<a class="el" href="classipc_1_1session_1_1Session__mv.html">Session_mv</a> &amp;&amp;src)</td></tr>
<tr class="memdesc:ad1cffabdbc41809399b4bda9330f5367 inherit pub_methods_classipc_1_1session_1_1Session__mv"><td class="mdescLeft">&#160;</td><td class="mdescRight">Implements Session API per contract.  <a href="classipc_1_1session_1_1Session__mv.html#ad1cffabdbc41809399b4bda9330f5367">More...</a><br /></td></tr>
<tr class="separator:ad1cffabdbc41809399b4bda9330f5367 inherit pub_methods_classipc_1_1session_1_1Session__mv"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1293a6369b78d12bad869ca812be0f74 inherit pub_methods_classipc_1_1session_1_1Session__mv"><td class="memItemLeft" align="right" valign="top"><a id="a1293a6369b78d12bad869ca812be0f74" name="a1293a6369b78d12bad869ca812be0f74"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>Session_mv</b> (const <a class="el" href="classipc_1_1session_1_1Session__mv.html">Session_mv</a> &amp;)=delete</td></tr>
<tr class="memdesc:a1293a6369b78d12bad869ca812be0f74 inherit pub_methods_classipc_1_1session_1_1Session__mv"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy ction is disallowed. <br /></td></tr>
<tr class="separator:a1293a6369b78d12bad869ca812be0f74 inherit pub_methods_classipc_1_1session_1_1Session__mv"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0b4f0cdde3221b0922e0b44cbb6011a2 inherit pub_methods_classipc_1_1session_1_1Session__mv"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classipc_1_1session_1_1Session__mv.html#a0b4f0cdde3221b0922e0b44cbb6011a2">~Session_mv</a> ()</td></tr>
<tr class="memdesc:a0b4f0cdde3221b0922e0b44cbb6011a2 inherit pub_methods_classipc_1_1session_1_1Session__mv"><td class="mdescLeft">&#160;</td><td class="mdescRight">Implements Session API per contract.  <a href="classipc_1_1session_1_1Session__mv.html#a0b4f0cdde3221b0922e0b44cbb6011a2">More...</a><br /></td></tr>
<tr class="separator:a0b4f0cdde3221b0922e0b44cbb6011a2 inherit pub_methods_classipc_1_1session_1_1Session__mv"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac000e14183b5dcb523ff0eaaf030968c inherit pub_methods_classipc_1_1session_1_1Session__mv"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classipc_1_1session_1_1Session__mv.html">Session_mv</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classipc_1_1session_1_1Session__mv.html#ac000e14183b5dcb523ff0eaaf030968c">operator=</a> (<a class="el" href="classipc_1_1session_1_1Session__mv.html">Session_mv</a> &amp;&amp;src)</td></tr>
<tr class="memdesc:ac000e14183b5dcb523ff0eaaf030968c inherit pub_methods_classipc_1_1session_1_1Session__mv"><td class="mdescLeft">&#160;</td><td class="mdescRight">Implements Session API per contract.  <a href="classipc_1_1session_1_1Session__mv.html#ac000e14183b5dcb523ff0eaaf030968c">More...</a><br /></td></tr>
<tr class="separator:ac000e14183b5dcb523ff0eaaf030968c inherit pub_methods_classipc_1_1session_1_1Session__mv"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeb7d7965c0fc0736b6c59f5f81a3e8c2 inherit pub_methods_classipc_1_1session_1_1Session__mv"><td class="memItemLeft" align="right" valign="top"><a id="aeb7d7965c0fc0736b6c59f5f81a3e8c2" name="aeb7d7965c0fc0736b6c59f5f81a3e8c2"></a>
<a class="el" href="classipc_1_1session_1_1Session__mv.html">Session_mv</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>operator=</b> (const <a class="el" href="classipc_1_1session_1_1Session__mv.html">Session_mv</a> &amp;)=delete</td></tr>
<tr class="memdesc:aeb7d7965c0fc0736b6c59f5f81a3e8c2 inherit pub_methods_classipc_1_1session_1_1Session__mv"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy assignment is disallowed. <br /></td></tr>
<tr class="separator:aeb7d7965c0fc0736b6c59f5f81a3e8c2 inherit pub_methods_classipc_1_1session_1_1Session__mv"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aba79f245e6f726ac6aa573e45e0bfdf3 inherit pub_methods_classipc_1_1session_1_1Session__mv"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classipc_1_1session_1_1Session__mv.html#a787253f02859ea6b99ce3eba92766431">Mdt_builder_ptr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classipc_1_1session_1_1Session__mv.html#aba79f245e6f726ac6aa573e45e0bfdf3">mdt_builder</a> ()</td></tr>
<tr class="memdesc:aba79f245e6f726ac6aa573e45e0bfdf3 inherit pub_methods_classipc_1_1session_1_1Session__mv"><td class="mdescLeft">&#160;</td><td class="mdescRight">Implements Session API per contract.  <a href="classipc_1_1session_1_1Session__mv.html#aba79f245e6f726ac6aa573e45e0bfdf3">More...</a><br /></td></tr>
<tr class="separator:aba79f245e6f726ac6aa573e45e0bfdf3 inherit pub_methods_classipc_1_1session_1_1Session__mv"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6d8cdbb86140056a7e7d2931ea642b18 inherit pub_methods_classipc_1_1session_1_1Session__mv"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classipc_1_1session_1_1Session__mv.html#a6d8cdbb86140056a7e7d2931ea642b18">open_channel</a> (<a class="el" href="classipc_1_1session_1_1Session__mv.html#ab92df09d894e6e1aaf3c2733da594fd2">Channel_obj</a> *target_channel, const <a class="el" href="classipc_1_1session_1_1Session__mv.html#a787253f02859ea6b99ce3eba92766431">Mdt_builder_ptr</a> &amp;mdt, <a class="el" href="namespaceipc.html#aa3192e586cc45d3e7c22463bf2760f89">Error_code</a> *err_code=0)</td></tr>
<tr class="memdesc:a6d8cdbb86140056a7e7d2931ea642b18 inherit pub_methods_classipc_1_1session_1_1Session__mv"><td class="mdescLeft">&#160;</td><td class="mdescRight">Implements Session API per contract.  <a href="classipc_1_1session_1_1Session__mv.html#a6d8cdbb86140056a7e7d2931ea642b18">More...</a><br /></td></tr>
<tr class="separator:a6d8cdbb86140056a7e7d2931ea642b18 inherit pub_methods_classipc_1_1session_1_1Session__mv"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a84e80e24d7b16da0a9ecf83057acfd8e inherit pub_methods_classipc_1_1session_1_1Session__mv"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classipc_1_1session_1_1Session__mv.html#a84e80e24d7b16da0a9ecf83057acfd8e">open_channel</a> (<a class="el" href="classipc_1_1session_1_1Session__mv.html#ab92df09d894e6e1aaf3c2733da594fd2">Channel_obj</a> *target_channel, <a class="el" href="namespaceipc.html#aa3192e586cc45d3e7c22463bf2760f89">Error_code</a> *err_code=0)</td></tr>
<tr class="memdesc:a84e80e24d7b16da0a9ecf83057acfd8e inherit pub_methods_classipc_1_1session_1_1Session__mv"><td class="mdescLeft">&#160;</td><td class="mdescRight">Implements Session API per contract.  <a href="classipc_1_1session_1_1Session__mv.html#a84e80e24d7b16da0a9ecf83057acfd8e">More...</a><br /></td></tr>
<tr class="separator:a84e80e24d7b16da0a9ecf83057acfd8e inherit pub_methods_classipc_1_1session_1_1Session__mv"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a749f1f679f858d2dce8562cdddc60195 inherit pub_methods_classipc_1_1session_1_1Session__mv"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="namespaceipc_1_1session.html#ade2b302f1a3623e8adc9694568d94d2c">Session_token</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classipc_1_1session_1_1Session__mv.html#a749f1f679f858d2dce8562cdddc60195">session_token</a> () const</td></tr>
<tr class="memdesc:a749f1f679f858d2dce8562cdddc60195 inherit pub_methods_classipc_1_1session_1_1Session__mv"><td class="mdescLeft">&#160;</td><td class="mdescRight">Implements Session API per contract.  <a href="classipc_1_1session_1_1Session__mv.html#a749f1f679f858d2dce8562cdddc60195">More...</a><br /></td></tr>
<tr class="separator:a749f1f679f858d2dce8562cdddc60195 inherit pub_methods_classipc_1_1session_1_1Session__mv"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a107684fdd5d233549c6daac26a81a542 inherit pub_methods_classipc_1_1session_1_1Session__mv"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structipc_1_1transport_1_1struc_1_1Heap__fixed__builder_1_1Config.html">transport::struc::Heap_fixed_builder::Config</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classipc_1_1session_1_1Session__mv.html#a107684fdd5d233549c6daac26a81a542">heap_fixed_builder_config</a> ()</td></tr>
<tr class="memdesc:a107684fdd5d233549c6daac26a81a542 inherit pub_methods_classipc_1_1session_1_1Session__mv"><td class="mdescLeft">&#160;</td><td class="mdescRight">Utility that obtains a heap-based (non-zero-copy) Struct_builder::Config, constructed with the most efficient yet safe values, for transport::struc::Msg_out (out-messages) compatible with <a class="el" href="classipc_1_1session_1_1Session__mv.html#ac205819d4a3a066f31b5af311ff40a2a" title="Implements Session API per contract.">Structured_channel</a> upgraded-from <a class="el" href="classipc_1_1session_1_1Session__mv.html#ab92df09d894e6e1aaf3c2733da594fd2" title="Implements Session API per contract.">Channel_obj</a> channels opened via <code>*this</code> Session_mv.  <a href="classipc_1_1session_1_1Session__mv.html#a107684fdd5d233549c6daac26a81a542">More...</a><br /></td></tr>
<tr class="separator:a107684fdd5d233549c6daac26a81a542 inherit pub_methods_classipc_1_1session_1_1Session__mv"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab3c69e3f8ccbd70d315bed86d697255d inherit pub_methods_classipc_1_1session_1_1Session__mv"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structipc_1_1transport_1_1struc_1_1Heap__reader_1_1Config.html">transport::struc::Heap_reader::Config</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classipc_1_1session_1_1Session__mv.html#ab3c69e3f8ccbd70d315bed86d697255d">heap_reader_config</a> ()</td></tr>
<tr class="memdesc:ab3c69e3f8ccbd70d315bed86d697255d inherit pub_methods_classipc_1_1session_1_1Session__mv"><td class="mdescLeft">&#160;</td><td class="mdescRight">Deserializing counterpart to non-<code>static</code> <a class="el" href="classipc_1_1session_1_1Session__mv.html#a107684fdd5d233549c6daac26a81a542" title="Utility that obtains a heap-based (non-zero-copy) Struct_builder::Config, constructed with the most e...">heap_fixed_builder_config()</a>.  <a href="classipc_1_1session_1_1Session__mv.html#ab3c69e3f8ccbd70d315bed86d697255d">More...</a><br /></td></tr>
<tr class="separator:ab3c69e3f8ccbd70d315bed86d697255d inherit pub_methods_classipc_1_1session_1_1Session__mv"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a142df6d6db09962a1dc0f536bf4977f0 inherit pub_methods_classipc_1_1session_1_1Session__mv"><td class="memItemLeft" align="right" valign="top">flow::log::Logger *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classipc_1_1session_1_1Session__mv.html#a142df6d6db09962a1dc0f536bf4977f0">get_logger</a> () const</td></tr>
<tr class="memdesc:a142df6d6db09962a1dc0f536bf4977f0 inherit pub_methods_classipc_1_1session_1_1Session__mv"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns logger (possibly null).  <a href="classipc_1_1session_1_1Session__mv.html#a142df6d6db09962a1dc0f536bf4977f0">More...</a><br /></td></tr>
<tr class="separator:a142df6d6db09962a1dc0f536bf4977f0 inherit pub_methods_classipc_1_1session_1_1Session__mv"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a23b43187319871c4974755175973008e inherit pub_methods_classipc_1_1session_1_1Session__mv"><td class="memItemLeft" align="right" valign="top">const flow::log::Component &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classipc_1_1session_1_1Session__mv.html#a23b43187319871c4974755175973008e">get_log_component</a> () const</td></tr>
<tr class="memdesc:a23b43187319871c4974755175973008e inherit pub_methods_classipc_1_1session_1_1Session__mv"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns log component.  <a href="classipc_1_1session_1_1Session__mv.html#a23b43187319871c4974755175973008e">More...</a><br /></td></tr>
<tr class="separator:a23b43187319871c4974755175973008e inherit pub_methods_classipc_1_1session_1_1Session__mv"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pro-methods" name="pro-methods"></a>
Protected Member Functions</h2></td></tr>
<tr class="memitem:ae190ff87b86aab1a68374789791553e1"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classipc_1_1session_1_1Server__session__mv.html#ae190ff87b86aab1a68374789791553e1">Server_session_mv</a> (flow::log::Logger *logger_ptr, const <a class="el" href="structipc_1_1session_1_1Server__app.html">Server_app</a> &amp;srv_app_ref, <a class="el" href="classipc_1_1transport_1_1sync__io_1_1Native__socket__stream.html">transport::sync_io::Native_socket_stream</a> &amp;&amp;master_channel_sock_stm)</td></tr>
<tr class="memdesc:ae190ff87b86aab1a68374789791553e1"><td class="mdescLeft">&#160;</td><td class="mdescRight">For use by internal user <a class="el" href="classipc_1_1session_1_1Session__server__impl.html" title="Internal class template comprising API/logic common to every Session_server variant,...">Session_server_impl</a>: constructor.  <a href="classipc_1_1session_1_1Server__session__mv.html#ae190ff87b86aab1a68374789791553e1">More...</a><br /></td></tr>
<tr class="separator:ae190ff87b86aab1a68374789791553e1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a74d647e2f555465c28065dc11cd092cb"><td class="memTemplParams" colspan="2">template&lt;typename Session_server_impl_t , typename Task_err , typename Cli_app_lookup_func , typename Cli_namespace_func , typename Pre_rsp_setup_func , typename N_init_channels_by_srv_req_func , typename Mdt_load_func &gt; </td></tr>
<tr class="memitem:a74d647e2f555465c28065dc11cd092cb"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classipc_1_1session_1_1Server__session__mv.html#a74d647e2f555465c28065dc11cd092cb">async_accept_log_in</a> (Session_server_impl_t *srv, typename <a class="el" href="classipc_1_1session_1_1Session__mv.html#af87da439644b2afd73d6a13d97e7985f">Base::Channels</a> *init_channels_by_srv_req, typename <a class="el" href="classipc_1_1session_1_1Session__mv.html#a2b1215fb0c9738b9fcfbb337d23c43df">Base::Mdt_reader_ptr</a> *mdt_from_cli_or_null, typename <a class="el" href="classipc_1_1session_1_1Session__mv.html#af87da439644b2afd73d6a13d97e7985f">Base::Channels</a> *init_channels_by_cli_req, Cli_app_lookup_func &amp;&amp;cli_app_lookup_func, Cli_namespace_func &amp;&amp;cli_namespace_func, Pre_rsp_setup_func &amp;&amp;pre_rsp_setup_func, N_init_channels_by_srv_req_func &amp;&amp;n_init_channels_by_srv_req_func, Mdt_load_func &amp;&amp;mdt_load_func, Task_err &amp;&amp;on_done_func)</td></tr>
<tr class="memdesc:a74d647e2f555465c28065dc11cd092cb"><td class="mdescLeft">&#160;</td><td class="mdescRight">For use by internal user <a class="el" href="classipc_1_1session_1_1Session__server.html" title="To be instantiated typically once in a given process, an object of this type asynchronously listens f...">Session_server</a>: called no more than once, ideally immediately following ctor, this attempts to get <code>*this</code> asynchronously to almost-PEER state by undergoing the log-in request/response (plus, if needed, init-channel-opening) procedure (the other side of which is done by <a class="el" href="classipc_1_1session_1_1Client__session__impl.html#ab8b6d1a2dff86fb565936f4bd048c146" title="See Client_session_mv counterpart.">Client_session_impl::sync_connect()</a>).  <a href="classipc_1_1session_1_1Server__session__mv.html#a74d647e2f555465c28065dc11cd092cb">More...</a><br /></td></tr>
<tr class="separator:a74d647e2f555465c28065dc11cd092cb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pro_methods_classipc_1_1session_1_1Session__mv"><td colspan="2" onclick="javascript:toggleInherit('pro_methods_classipc_1_1session_1_1Session__mv')"><img src="closed.png" alt="-"/>&#160;Protected Member Functions inherited from <a class="el" href="classipc_1_1session_1_1Session__mv.html">ipc::session::Session_mv&lt; Server_session_impl_t &gt;</a></td></tr>
<tr class="memitem:a7589e9e086afae1d8be969c8e6c1987d inherit pro_methods_classipc_1_1session_1_1Session__mv"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classipc_1_1session_1_1Session__mv.html#acb47dfa0f5645cf2da7d62ac5862e8cc">Session_base_obj</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classipc_1_1session_1_1Session__mv.html#a7589e9e086afae1d8be969c8e6c1987d">base</a> () const</td></tr>
<tr class="memdesc:a7589e9e086afae1d8be969c8e6c1987d inherit pro_methods_classipc_1_1session_1_1Session__mv"><td class="mdescLeft">&#160;</td><td class="mdescRight">Provides <code>const</code> access to Session_base super-object.  <a href="classipc_1_1session_1_1Session__mv.html#a7589e9e086afae1d8be969c8e6c1987d">More...</a><br /></td></tr>
<tr class="separator:a7589e9e086afae1d8be969c8e6c1987d inherit pro_methods_classipc_1_1session_1_1Session__mv"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae5e646ae3649914384cb2e7f94aa7a25 inherit pro_methods_classipc_1_1session_1_1Session__mv"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classipc_1_1session_1_1Session__mv.html#a457c661352bf3111ca4f707c15d51b3e">Impl_ptr</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classipc_1_1session_1_1Session__mv.html#ae5e646ae3649914384cb2e7f94aa7a25">impl</a> ()</td></tr>
<tr class="memdesc:ae5e646ae3649914384cb2e7f94aa7a25 inherit pro_methods_classipc_1_1session_1_1Session__mv"><td class="mdescLeft">&#160;</td><td class="mdescRight">pImpl target; particularly for sub-classes that must add to the above <code>public</code> API.  <a href="classipc_1_1session_1_1Session__mv.html#ae5e646ae3649914384cb2e7f94aa7a25">More...</a><br /></td></tr>
<tr class="separator:ae5e646ae3649914384cb2e7f94aa7a25 inherit pro_methods_classipc_1_1session_1_1Session__mv"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a025cd4b449dbfc68008ac9379a07ca63 inherit pro_methods_classipc_1_1session_1_1Session__mv"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classipc_1_1session_1_1Session__mv.html#a457c661352bf3111ca4f707c15d51b3e">Impl_ptr</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classipc_1_1session_1_1Session__mv.html#a025cd4b449dbfc68008ac9379a07ca63">impl</a> () const</td></tr>
<tr class="memdesc:a025cd4b449dbfc68008ac9379a07ca63 inherit pro_methods_classipc_1_1session_1_1Session__mv"><td class="mdescLeft">&#160;</td><td class="mdescRight">pImpl target; particularly for sub-classes that must add to the above <code>public</code> API.  <a href="classipc_1_1session_1_1Session__mv.html#a025cd4b449dbfc68008ac9379a07ca63">More...</a><br /></td></tr>
<tr class="separator:a025cd4b449dbfc68008ac9379a07ca63 inherit pro_methods_classipc_1_1session_1_1Session__mv"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="related" name="related"></a>
Related Functions</h2></td></tr>
<tr><td class="ititle" colspan="2"><p >(Note that these are not member functions.) </p>
</td></tr>
<tr class="memitem:aed5397fd025606507ad8dab74479762f"><td class="memTemplParams" colspan="2">template&lt;typename Server_session_impl_t &gt; </td></tr>
<tr class="memitem:aed5397fd025606507ad8dab74479762f"><td class="memTemplItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classipc_1_1session_1_1Server__session__mv.html#aed5397fd025606507ad8dab74479762f">operator&lt;&lt;</a> (std::ostream &amp;os, const <a class="el" href="classipc_1_1session_1_1Server__session__mv.html">Server_session_mv</a>&lt; Server_session_impl_t &gt; &amp;val)</td></tr>
<tr class="memdesc:aed5397fd025606507ad8dab74479762f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Prints string representation of the given <code><a class="el" href="classipc_1_1session_1_1Server__session__mv.html" title="Implements Session concept on the Server_app end: a Session that is emitted in almost-PEER state by l...">Server_session_mv</a></code> to the given <code>ostream</code>.  <a href="classipc_1_1session_1_1Server__session__mv.html#aed5397fd025606507ad8dab74479762f">More...</a><br /></td></tr>
<tr class="separator:aed5397fd025606507ad8dab74479762f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header related_classipc_1_1session_1_1Session__mv"><td colspan="2" onclick="javascript:toggleInherit('related_classipc_1_1session_1_1Session__mv')"><img src="closed.png" alt="-"/>&#160;Related Functions inherited from <a class="el" href="classipc_1_1session_1_1Session__mv.html">ipc::session::Session_mv&lt; Server_session_impl_t &gt;</a></td></tr>
<tr class="memitem:a07c2d7a228f070e32bf4f1fbc64e1f6d inherit related_classipc_1_1session_1_1Session__mv"><td class="memItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classipc_1_1session_1_1Session__mv.html#a07c2d7a228f070e32bf4f1fbc64e1f6d">operator&lt;&lt;</a> (std::ostream &amp;os, const <a class="el" href="classipc_1_1session_1_1Session__mv.html">Session_mv</a>&lt; Server_session_impl_t &gt; &amp;val)</td></tr>
<tr class="memdesc:a07c2d7a228f070e32bf4f1fbc64e1f6d inherit related_classipc_1_1session_1_1Session__mv"><td class="mdescLeft">&#160;</td><td class="mdescRight">Prints string representation of the given <code>Session_mv</code> to the given <code>ostream</code>.  <a href="classipc_1_1session_1_1Session__mv.html#a07c2d7a228f070e32bf4f1fbc64e1f6d">More...</a><br /></td></tr>
<tr class="separator:a07c2d7a228f070e32bf4f1fbc64e1f6d inherit related_classipc_1_1session_1_1Session__mv"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="inherited" name="inherited"></a>
Additional Inherited Members</h2></td></tr>
<tr class="inherit_header pub_static_methods_classipc_1_1session_1_1Session__mv"><td colspan="2" onclick="javascript:toggleInherit('pub_static_methods_classipc_1_1session_1_1Session__mv')"><img src="closed.png" alt="-"/>&#160;Static Public Member Functions inherited from <a class="el" href="classipc_1_1session_1_1Session__mv.html">ipc::session::Session_mv&lt; Server_session_impl_t &gt;</a></td></tr>
<tr class="memitem:a26dfe4dd3ff57daab5a36a037f835c4e inherit pub_static_methods_classipc_1_1session_1_1Session__mv"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="structipc_1_1transport_1_1struc_1_1Heap__fixed__builder_1_1Config.html">transport::struc::Heap_fixed_builder::Config</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classipc_1_1session_1_1Session__mv.html#a26dfe4dd3ff57daab5a36a037f835c4e">heap_fixed_builder_config</a> (flow::log::Logger *logger_ptr)</td></tr>
<tr class="memdesc:a26dfe4dd3ff57daab5a36a037f835c4e inherit pub_static_methods_classipc_1_1session_1_1Session__mv"><td class="mdescLeft">&#160;</td><td class="mdescRight">Utility that obtains a heap-based (non-zero-copy) Struct_builder::Config, constructed with the most efficient yet safe values, for transport::struc::Msg_out (out-messages) compatible with <a class="el" href="classipc_1_1session_1_1Session__mv.html#ac205819d4a3a066f31b5af311ff40a2a" title="Implements Session API per contract.">Structured_channel</a> upgraded-from <a class="el" href="classipc_1_1session_1_1Session__mv.html#ab92df09d894e6e1aaf3c2733da594fd2" title="Implements Session API per contract.">Channel_obj</a> channels opened via this Session_mv type.  <a href="classipc_1_1session_1_1Session__mv.html#a26dfe4dd3ff57daab5a36a037f835c4e">More...</a><br /></td></tr>
<tr class="separator:a26dfe4dd3ff57daab5a36a037f835c4e inherit pub_static_methods_classipc_1_1session_1_1Session__mv"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a411feb974e2b7ed48b08ac50bcdf43b3 inherit pub_static_methods_classipc_1_1session_1_1Session__mv"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="structipc_1_1transport_1_1struc_1_1Heap__reader_1_1Config.html">transport::struc::Heap_reader::Config</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classipc_1_1session_1_1Session__mv.html#a411feb974e2b7ed48b08ac50bcdf43b3">heap_reader_config</a> (flow::log::Logger *logger_ptr)</td></tr>
<tr class="memdesc:a411feb974e2b7ed48b08ac50bcdf43b3 inherit pub_static_methods_classipc_1_1session_1_1Session__mv"><td class="mdescLeft">&#160;</td><td class="mdescRight">Deserializing counterpart to <code>static</code> <a class="el" href="classipc_1_1session_1_1Session__mv.html#a107684fdd5d233549c6daac26a81a542" title="Utility that obtains a heap-based (non-zero-copy) Struct_builder::Config, constructed with the most e...">heap_fixed_builder_config()</a>.  <a href="classipc_1_1session_1_1Session__mv.html#a411feb974e2b7ed48b08ac50bcdf43b3">More...</a><br /></td></tr>
<tr class="separator:a411feb974e2b7ed48b08ac50bcdf43b3 inherit pub_static_methods_classipc_1_1session_1_1Session__mv"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pub_static_attribs_classipc_1_1session_1_1Session__mv"><td colspan="2" onclick="javascript:toggleInherit('pub_static_attribs_classipc_1_1session_1_1Session__mv')"><img src="closed.png" alt="-"/>&#160;Static Public Attributes inherited from <a class="el" href="classipc_1_1session_1_1Session__mv.html">ipc::session::Session_mv&lt; Server_session_impl_t &gt;</a></td></tr>
<tr class="memitem:a74af091662cb7c32e0f1c60baac3613b inherit pub_static_attribs_classipc_1_1session_1_1Session__mv"><td class="memItemLeft" align="right" valign="top">static constexpr schema::ShmType&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classipc_1_1session_1_1Session__mv.html#a74af091662cb7c32e0f1c60baac3613b">S_SHM_TYPE</a></td></tr>
<tr class="memdesc:a74af091662cb7c32e0f1c60baac3613b inherit pub_static_attribs_classipc_1_1session_1_1Session__mv"><td class="mdescLeft">&#160;</td><td class="mdescRight">Implements Session API per contract.  <a href="classipc_1_1session_1_1Session__mv.html#a74af091662cb7c32e0f1c60baac3613b">More...</a><br /></td></tr>
<tr class="separator:a74af091662cb7c32e0f1c60baac3613b inherit pub_static_attribs_classipc_1_1session_1_1Session__mv"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a62945e465ae734523036215750c90ba4 inherit pub_static_attribs_classipc_1_1session_1_1Session__mv"><td class="memItemLeft" align="right" valign="top">static constexpr bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classipc_1_1session_1_1Session__mv.html#a62945e465ae734523036215750c90ba4">S_SHM_ENABLED</a></td></tr>
<tr class="memdesc:a62945e465ae734523036215750c90ba4 inherit pub_static_attribs_classipc_1_1session_1_1Session__mv"><td class="mdescLeft">&#160;</td><td class="mdescRight">Implements Session API per contract.  <a href="classipc_1_1session_1_1Session__mv.html#a62945e465ae734523036215750c90ba4">More...</a><br /></td></tr>
<tr class="separator:a62945e465ae734523036215750c90ba4 inherit pub_static_attribs_classipc_1_1session_1_1Session__mv"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6a87002dccab497da76bb286d5a4bf95 inherit pub_static_attribs_classipc_1_1session_1_1Session__mv"><td class="memItemLeft" align="right" valign="top">static constexpr bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classipc_1_1session_1_1Session__mv.html#a6a87002dccab497da76bb286d5a4bf95">S_MQS_ENABLED</a></td></tr>
<tr class="memdesc:a6a87002dccab497da76bb286d5a4bf95 inherit pub_static_attribs_classipc_1_1session_1_1Session__mv"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compile-time-known constant indicating whether <a class="el" href="classipc_1_1session_1_1Session__mv.html#ab92df09d894e6e1aaf3c2733da594fd2" title="Implements Session API per contract.">Channel_obj</a> shall use a blobs pipe over message queues (MQs).  <a href="classipc_1_1session_1_1Session__mv.html#a6a87002dccab497da76bb286d5a4bf95">More...</a><br /></td></tr>
<tr class="separator:a6a87002dccab497da76bb286d5a4bf95 inherit pub_static_attribs_classipc_1_1session_1_1Session__mv"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:addc597e6bf3555dc3788116c8cc179dd inherit pub_static_attribs_classipc_1_1session_1_1Session__mv"><td class="memItemLeft" align="right" valign="top">static constexpr bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classipc_1_1session_1_1Session__mv.html#addc597e6bf3555dc3788116c8cc179dd">S_SOCKET_STREAM_ENABLED</a></td></tr>
<tr class="memdesc:addc597e6bf3555dc3788116c8cc179dd inherit pub_static_attribs_classipc_1_1session_1_1Session__mv"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compile-time-known constant indicating whether <a class="el" href="classipc_1_1session_1_1Session__mv.html#ab92df09d894e6e1aaf3c2733da594fd2" title="Implements Session API per contract.">Channel_obj</a> shall use socket stream for any type of pipe.  <a href="classipc_1_1session_1_1Session__mv.html#addc597e6bf3555dc3788116c8cc179dd">More...</a><br /></td></tr>
<tr class="separator:addc597e6bf3555dc3788116c8cc179dd inherit pub_static_attribs_classipc_1_1session_1_1Session__mv"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pro_types_classipc_1_1session_1_1Session__mv"><td colspan="2" onclick="javascript:toggleInherit('pro_types_classipc_1_1session_1_1Session__mv')"><img src="closed.png" alt="-"/>&#160;Protected Types inherited from <a class="el" href="classipc_1_1session_1_1Session__mv.html">ipc::session::Session_mv&lt; Server_session_impl_t &gt;</a></td></tr>
<tr class="memitem:af2c186e7b4be09bff30b42aa2482dd93 inherit pro_types_classipc_1_1session_1_1Session__mv"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classipc_1_1session_1_1Session__mv.html#af2c186e7b4be09bff30b42aa2482dd93">Impl</a> = Server_session_impl_t</td></tr>
<tr class="memdesc:af2c186e7b4be09bff30b42aa2482dd93 inherit pro_types_classipc_1_1session_1_1Session__mv"><td class="mdescLeft">&#160;</td><td class="mdescRight">Short-hand for pImpl-lite impl type. This shall be the deepest impl sub-class desired.  <a href="classipc_1_1session_1_1Session__mv.html#af2c186e7b4be09bff30b42aa2482dd93">More...</a><br /></td></tr>
<tr class="separator:af2c186e7b4be09bff30b42aa2482dd93 inherit pro_types_classipc_1_1session_1_1Session__mv"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acb47dfa0f5645cf2da7d62ac5862e8cc inherit pro_types_classipc_1_1session_1_1Session__mv"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classipc_1_1session_1_1Session__mv.html#acb47dfa0f5645cf2da7d62ac5862e8cc">Session_base_obj</a> = typename Impl::Session_base_obj</td></tr>
<tr class="memdesc:acb47dfa0f5645cf2da7d62ac5862e8cc inherit pro_types_classipc_1_1session_1_1Session__mv"><td class="mdescLeft">&#160;</td><td class="mdescRight">Short-hand for <a class="el" href="classipc_1_1session_1_1Session__mv.html#af2c186e7b4be09bff30b42aa2482dd93" title="Short-hand for pImpl-lite impl type. This shall be the deepest impl sub-class desired.">Impl</a>'s Session_base super-class.  <a href="classipc_1_1session_1_1Session__mv.html#acb47dfa0f5645cf2da7d62ac5862e8cc">More...</a><br /></td></tr>
<tr class="separator:acb47dfa0f5645cf2da7d62ac5862e8cc inherit pro_types_classipc_1_1session_1_1Session__mv"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a457c661352bf3111ca4f707c15d51b3e inherit pro_types_classipc_1_1session_1_1Session__mv"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classipc_1_1session_1_1Session__mv.html#a457c661352bf3111ca4f707c15d51b3e">Impl_ptr</a> = std::experimental::propagate_const&lt; boost::movelib::unique_ptr&lt; <a class="el" href="classipc_1_1session_1_1Session__mv.html#af2c186e7b4be09bff30b42aa2482dd93">Impl</a> &gt; &gt;</td></tr>
<tr class="memdesc:a457c661352bf3111ca4f707c15d51b3e inherit pro_types_classipc_1_1session_1_1Session__mv"><td class="mdescLeft">&#160;</td><td class="mdescRight">Short-hand for <code>const</code>-respecting wrapper around <a class="el" href="classipc_1_1session_1_1Session__mv.html#af2c186e7b4be09bff30b42aa2482dd93" title="Short-hand for pImpl-lite impl type. This shall be the deepest impl sub-class desired.">Impl</a> for the pImpl idiom. See <a class="el" href="classipc_1_1session_1_1Session__mv.html#ae5e646ae3649914384cb2e7f94aa7a25" title="pImpl target; particularly for sub-classes that must add to the above public API.">impl()</a>.  <a href="classipc_1_1session_1_1Session__mv.html#a457c661352bf3111ca4f707c15d51b3e">More...</a><br /></td></tr>
<tr class="separator:a457c661352bf3111ca4f707c15d51b3e inherit pro_types_classipc_1_1session_1_1Session__mv"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><div class="compoundTemplParams">template&lt;typename Server_session_impl_t&gt;<br />
class ipc::session::Server_session_mv&lt; Server_session_impl_t &gt;</div><p >Implements <a class="el" href="classipc_1_1session_1_1Session.html" title="A documentation-only concept defining the local side of an IPC conversation (session) with another en...">Session</a> concept on the <a class="el" href="structipc_1_1session_1_1Server__app.html" title="An App that is used as a server in at least one client-server IPC split.">Server_app</a> end: a <a class="el" href="classipc_1_1session_1_1Session.html" title="A documentation-only concept defining the local side of an IPC conversation (session) with another en...">Session</a> that is emitted in almost-PEER state by local <a class="el" href="classipc_1_1session_1_1Session__server.html" title="To be instantiated typically once in a given process, an object of this type asynchronously listens f...">Session_server</a> accepting a connection by an opposing <code><a class="el" href="classipc_1_1session_1_1Client__session__mv.html#ab971ea979200828d572638c60d7d9f44" title="To be invoked in NULL state only, and not as-if default-cted, it synchronously and non-blockingly att...">Client_session_mv::sync_connect()</a></code>. </p>
<p >By "almost-PEER state" we mean that the user, upon obtaining a new <code><a class="el" href="classipc_1_1session_1_1Server__session__mv.html" title="Implements Session concept on the Server_app end: a Session that is emitted in almost-PEER state by l...">Server_session_mv</a></code>, must still call <a class="el" href="classipc_1_1session_1_1Server__session__mv.html#a99097e5aa6883877c74f8a93ebc9f3e1" title="To be invoked by public user upon first obtaining *this: memorizes the given on-error and on-passive-...">init_handlers()</a> to enter PEER state. See overview of <a class="el" href="classipc_1_1session_1_1Session.html" title="A documentation-only concept defining the local side of an IPC conversation (session) with another en...">Session</a> hierarchy in namespace <a class="el" href="namespaceipc_1_1session.html" title="Flow-IPC module providing the broad lifecycle and shared-resource organization – via the session conc...">ipc::session</a> doc header; then come back here if desired.</p>
<p >It is unusual to use <a class="el" href="classipc_1_1session_1_1Server__session__mv.html" title="Implements Session concept on the Server_app end: a Session that is emitted in almost-PEER state by l...">Server_session_mv</a> template directly. If you do wish to set up a server-side session peer, and you do not require SHM support, then use <a class="el" href="namespaceipc_1_1session.html#ab01d5bce0ab2f3435ca9dd88d27609dc" title="A vanilla Server_session with no optional capabilities.">Server_session</a> alias template; target it with a <a class="el" href="classipc_1_1session_1_1Session__server.html#a13887cd64912bb5f5675e2817ff8435f" title="Asynchronously awaits for an opposing Client_session to request session establishment and calls on_do...">Session_server::async_accept()</a> call. The server-specific API, particularly <a class="el" href="classipc_1_1session_1_1Server__session__mv.html#a99097e5aa6883877c74f8a93ebc9f3e1" title="To be invoked by public user upon first obtaining *this: memorizes the given on-error and on-passive-...">init_handlers()</a>, is in <a class="el" href="classipc_1_1session_1_1Server__session__mv.html" title="Implements Session concept on the Server_app end: a Session that is emitted in almost-PEER state by l...">Server_session_mv</a> and documented here. The side-agnostic API &ndash; active once PEER state is achieved &ndash; is described by <a class="el" href="classipc_1_1session_1_1Session.html" title="A documentation-only concept defining the local side of an IPC conversation (session) with another en...">Session</a> (concept) doc header and implemented concretely by <a class="el" href="classipc_1_1session_1_1Session__mv.html" title="Implements the Session concept when it is in PEER state.">Session_mv</a> which is our <code>public</code>, non-<code>virtual</code> super-class.</p>
<p >If you do wish to set up a server-side session peer, but you <em>do</em> require SHM support, then use <a class="el" href="classipc_1_1session_1_1shm_1_1classic_1_1Server__session.html" title="Identical to session::Server_session in every way, except that it makes available two SHM arenas,...">shm::classic::Server_session</a> or similar (for other SHM-provider(s)); target it with a <a class="el" href="classipc_1_1session_1_1shm_1_1classic_1_1Session__server.html#ac6733bac776ecd2995f41cb0feb81d63" title="Contract identical to simpler session::Session_server::async_accept() overload; but internally ensure...">shm::classic::Session_server::async_accept()</a> (or similar for other SHM-provider(s)). However <a class="el" href="namespaceipc_1_1session.html#ab01d5bce0ab2f3435ca9dd88d27609dc" title="A vanilla Server_session with no optional capabilities.">Server_session</a> (hence <a class="el" href="classipc_1_1session_1_1Server__session__mv.html" title="Implements Session concept on the Server_app end: a Session that is emitted in almost-PEER state by l...">Server_session_mv</a> to which it aliases) is its super-class, and until PEER state is reached its API (<a class="el" href="classipc_1_1session_1_1Server__session__mv.html#a99097e5aa6883877c74f8a93ebc9f3e1" title="To be invoked by public user upon first obtaining *this: memorizes the given on-error and on-passive-...">init_handlers()</a>) remains the only relevant API to use. Once <a class="el" href="classipc_1_1session_1_1Server__session__mv.html#a99097e5aa6883877c74f8a93ebc9f3e1" title="To be invoked by public user upon first obtaining *this: memorizes the given on-error and on-passive-...">Server_session_mv::init_handlers()</a> puts <code>*this</code> into PEER state, super-class <a class="el" href="classipc_1_1session_1_1Session__mv.html" title="Implements the Session concept when it is in PEER state.">Session_mv</a> (= <a class="el" href="classipc_1_1session_1_1Session.html" title="A documentation-only concept defining the local side of an IPC conversation (session) with another en...">Session</a> concept) API continues to be relevant. Also in PEER state SHM-relevant additional API members (e.g. shm::classic::Session::app_shm()`) become of interest. The last two sentences describe the situation identically for <a class="el" href="classipc_1_1session_1_1Client__session__mv.html" title="Implements Session concept on the Client_app end: a Session_mv that first achieves PEER state by conn...">Client_session_mv</a> as well (see its doc header for context).</p>
<p >Summary hierarchy (contrast with similar spot in <a class="el" href="classipc_1_1session_1_1Client__session__mv.html" title="Implements Session concept on the Client_app end: a Session_mv that first achieves PEER state by conn...">Client_session_mv</a> doc header):</p><ul>
<li><a class="el" href="classipc_1_1session_1_1Session__mv.html" title="Implements the Session concept when it is in PEER state.">Session_mv</a> (<a class="el" href="classipc_1_1session_1_1Session.html" title="A documentation-only concept defining the local side of an IPC conversation (session) with another en...">Session</a> concept impl)</li>
<li>^&ndash; <a class="el" href="classipc_1_1session_1_1Server__session__mv.html" title="Implements Session concept on the Server_app end: a Session that is emitted in almost-PEER state by l...">Server_session_mv</a> (adds <a class="el" href="classipc_1_1session_1_1Server__session__mv.html#a99097e5aa6883877c74f8a93ebc9f3e1" title="To be invoked by public user upon first obtaining *this: memorizes the given on-error and on-passive-...">init_handlers()</a>)</li>
<li>=alias= <a class="el" href="namespaceipc_1_1session.html#ab01d5bce0ab2f3435ca9dd88d27609dc" title="A vanilla Server_session with no optional capabilities.">Server_session</a> (parameterizes by transport-configuring knobs = template params)</li>
<li>^&ndash; <a class="el" href="classipc_1_1session_1_1shm_1_1classic_1_1Session__mv.html" title="Implements the SHM-related API common to shm::classic::Server_session and shm::classic::Client_sessio...">shm::classic::Session_mv</a> (adds <code>session_shm()</code>...; suitable for <a class="el" href="structipc_1_1transport_1_1struc_1_1Channel__base_1_1Serialize__via__session__shm.html" title="Tag type for ctor selection: Backing RAM for serialization comes from a given session::Session&#39;s SHM ...">transport::struc::Channel_base::Serialize_via_session_shm</a>)</li>
<li>^&ndash; <a class="el" href="classipc_1_1session_1_1shm_1_1classic_1_1Server__session.html" title="Identical to session::Server_session in every way, except that it makes available two SHM arenas,...">shm::classic::Server_session</a> (parameterizes by aforementioned knobs = template params)</li>
</ul>
<p >We may refer to <a class="el" href="classipc_1_1session_1_1Server__session__mv.html" title="Implements Session concept on the Server_app end: a Session that is emitted in almost-PEER state by l...">Server_session_mv</a> as <a class="el" href="namespaceipc_1_1session.html#ab01d5bce0ab2f3435ca9dd88d27609dc" title="A vanilla Server_session with no optional capabilities.">Server_session</a> below; particularly since it is likeliest used in that form by the user.</p>
<h3>How to use</h3>
<p >Per the <a class="el" href="classipc_1_1session_1_1Session.html" title="A documentation-only concept defining the local side of an IPC conversation (session) with another en...">Session</a> concept a <a class="el" href="namespaceipc_1_1session.html#ab01d5bce0ab2f3435ca9dd88d27609dc" title="A vanilla Server_session with no optional capabilities.">Server_session</a> is open/capable of operation when in PEER state only. A publicly available <a class="el" href="namespaceipc_1_1session.html#ab01d5bce0ab2f3435ca9dd88d27609dc" title="A vanilla Server_session with no optional capabilities.">Server_session</a> object is always in one of 2 states:</p><ul>
<li>Almost-PEER. At this stage you must call <a class="el" href="classipc_1_1session_1_1Server__session__mv.html#a99097e5aa6883877c74f8a93ebc9f3e1" title="To be invoked by public user upon first obtaining *this: memorizes the given on-error and on-passive-...">init_handlers()</a> to enter PEER state. Until then other APIs will no-op/return sentinel, and no handler will fire.</li>
<li>PEER. At this stage it exactly implements the <a class="el" href="classipc_1_1session_1_1Session.html" title="A documentation-only concept defining the local side of an IPC conversation (session) with another en...">Session</a> concept. See <a class="el" href="classipc_1_1session_1_1Session__mv.html" title="Implements the Session concept when it is in PEER state.">Session_mv</a>. Reminder: It is not possible to exit PEER state.</li>
</ul>
<p >Once in PEER state <a class="el" href="namespaceipc_1_1session.html#ab01d5bce0ab2f3435ca9dd88d27609dc" title="A vanilla Server_session with no optional capabilities.">Server_session</a> simply follows <a class="el" href="classipc_1_1session_1_1Session.html" title="A documentation-only concept defining the local side of an IPC conversation (session) with another en...">Session</a> concept semantics. At this stage our super-class <a class="el" href="classipc_1_1session_1_1Session__mv.html" title="Implements the Session concept when it is in PEER state.">Session_mv</a> implements that concept in particular. See either doc header (<a class="el" href="classipc_1_1session_1_1Session.html" title="A documentation-only concept defining the local side of an IPC conversation (session) with another en...">Session</a>, <a class="el" href="classipc_1_1session_1_1Session__mv.html" title="Implements the Session concept when it is in PEER state.">Session_mv</a>).</p>
<h3>Error handling</h3>
<p >Once in PEER state, error handling follows the <a class="el" href="classipc_1_1session_1_1Session.html" title="A documentation-only concept defining the local side of an IPC conversation (session) with another en...">Session</a> concept (= <a class="el" href="classipc_1_1session_1_1Session__mv.html" title="Implements the Session concept when it is in PEER state.">Session_mv</a> concrete class) doc header. However, up to that point it can emit no errors. You must call <a class="el" href="classipc_1_1session_1_1Server__session__mv.html#a99097e5aa6883877c74f8a93ebc9f3e1" title="To be invoked by public user upon first obtaining *this: memorizes the given on-error and on-passive-...">init_handlers()</a> first to enter PEER state.</p>
<h3>Implementation design/rationale</h3>
<p >See section in the same spot of <a class="el" href="classipc_1_1session_1_1Client__session__mv.html" title="Implements Session concept on the Client_app end: a Session_mv that first achieves PEER state by conn...">Client_session_mv</a> doc header. A symmetrical situation (w/r/t pImpl-lite design) occurs here. But let's be explicit at the risk of some copy/pasting:</p>
<p ><a class="el" href="classipc_1_1session_1_1Session__mv.html" title="Implements the Session concept when it is in PEER state.">Session_mv</a> is the highest (<code>public</code>) super-class and begins the pImpl-lite-for-movability technique. It pImpl-wraps the Session-concept impl methods/stuff. <a class="el" href="classipc_1_1session_1_1Server__session__mv.html" title="Implements Session concept on the Server_app end: a Session that is emitted in almost-PEER state by l...">Server_session_mv</a> merely repeats the same technique but on the API additions at its own level; in particular <a class="el" href="classipc_1_1session_1_1Server__session__mv.html#a99097e5aa6883877c74f8a93ebc9f3e1" title="To be invoked by public user upon first obtaining *this: memorizes the given on-error and on-passive-...">init_handlers()</a>.</p>
<p >The impl object is available via <a class="el" href="classipc_1_1session_1_1Session__mv.html#ae5e646ae3649914384cb2e7f94aa7a25" title="pImpl target; particularly for sub-classes that must add to the above public API.">Session_mv::impl()</a> (which is <code>protected</code>). What type does this object have though? Answer: <code>Server_session_impl_t</code>, our template param! This shall be the proper <code>..._impl</code> internal-use type that matches the level of API (<code>public</code> sub-class) the user chose: E.g.:</p><ul>
<li>Chose <a class="el" href="namespaceipc_1_1session.html#ab01d5bce0ab2f3435ca9dd88d27609dc" title="A vanilla Server_session with no optional capabilities.">Server_session</a> =&gt; impl = <a class="el" href="classipc_1_1session_1_1Server__session__impl.html" title="Internal, non-movable pImpl-lite implementation of Server_session_mv class template.">Server_session_impl</a>.</li>
<li>Chose <a class="el" href="classipc_1_1session_1_1shm_1_1classic_1_1Server__session.html" title="Identical to session::Server_session in every way, except that it makes available two SHM arenas,...">shm::classic::Server_session</a> =&gt; impl = <a class="el" href="classipc_1_1session_1_1shm_1_1classic_1_1Server__session__impl.html" title="Core internally-used implementation of shm::classic::Server_session: it is to the latter what its pub...">shm::classic::Server_session_impl</a>.</li>
</ul>
<p >So basically each of the public-API types visible to the user adds the pImpl-wrapping of the methods of the <code>..._impl</code> type matching their name; and the public/movable-API hierarchy has a parallel internal/non-movable hierarchy, both using <code>public</code>/non-<code>virtual</code> inheritance.</p>
<h3>Facade design</h3>
<p ><a class="el" href="classipc_1_1session_1_1Session__server.html" title="To be instantiated typically once in a given process, an object of this type asynchronously listens f...">Session_server</a> emits a <a class="el" href="classipc_1_1session_1_1Server__session__mv.html" title="Implements Session concept on the Server_app end: a Session that is emitted in almost-PEER state by l...">Server_session_mv</a> only once it's in almost-PEER state. Before then it is dealing with it privately. Namely &ndash; details are in <a class="el" href="classipc_1_1session_1_1Server__session__impl.html" title="Internal, non-movable pImpl-lite implementation of Server_session_mv class template.">Server_session_impl</a> &ndash; it must</p><ol type="1">
<li>construct it;</li>
<li>call <a class="el" href="classipc_1_1session_1_1Server__session__mv.html#a74d647e2f555465c28065dc11cd092cb" title="For use by internal user Session_server: called no more than once, ideally immediately following ctor...">async_accept_log_in()</a> and await its success.</li>
</ol>
<p >These APIs are <code>protected</code> in <a class="el" href="classipc_1_1session_1_1Server__session__mv.html" title="Implements Session concept on the Server_app end: a Session that is emitted in almost-PEER state by l...">Server_session_mv</a>. The detail/ sub-class <a class="el" href="classipc_1_1session_1_1Server__session__dtl.html" title="This is the data-less sub-class of Server_session or any more-advanced (e.g., SHM-capable) variant th...">Server_session_dtl</a> exposes them publicly (but only accessible, by convention, internally; namely by <a class="el" href="classipc_1_1session_1_1Session__server.html" title="To be instantiated typically once in a given process, an object of this type asynchronously listens f...">Session_server</a>).</p>
<p >As of this writing the SHM-enabled <a class="el" href="classipc_1_1session_1_1Session__server.html" title="To be instantiated typically once in a given process, an object of this type asynchronously listens f...">Session_server</a> variants (e.g., <a class="el" href="classipc_1_1session_1_1shm_1_1classic_1_1Session__server.html" title="This is to vanilla Session_server what shm::classic::Server_session is to vanilla Server_session: it ...">shm::classic::Session_server</a>) do not require any additional internally-accessed APIs. Instead they employ 3 "customization points" using which avoids such a need; see <a class="el" href="classipc_1_1session_1_1Session__server__impl.html" title="Internal class template comprising API/logic common to every Session_server variant,...">Session_server_impl</a>. Therefore there is no detail/ facade beyond <a class="el" href="classipc_1_1session_1_1Server__session__dtl.html" title="This is the data-less sub-class of Server_session or any more-advanced (e.g., SHM-capable) variant th...">Server_session_dtl</a>.</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classipc_1_1session_1_1Server__session__impl.html" title="Internal, non-movable pImpl-lite implementation of Server_session_mv class template.">Server_session_impl</a> doc header. </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classipc_1_1session_1_1Session.html" title="A documentation-only concept defining the local side of an IPC conversation (session) with another en...">Session</a>: implemented concept.</dd></dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Server_session_impl_t</td><td>An implementation detail. Use one of the aliases prescribed near the top of this doc header to set this correctly. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="ipc__session_2src_2ipc_2session_2server__session_8hpp_source.html#l00122">122</a> of file <a class="el" href="ipc__session_2src_2ipc_2session_2server__session_8hpp_source.html">server_session.hpp</a>.</p>
</div><h2 class="groupheader">Member Typedef Documentation</h2>
<a id="a17a6288bac54ea18317582121ed8e10d" name="a17a6288bac54ea18317582121ed8e10d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a17a6288bac54ea18317582121ed8e10d">&#9670;&nbsp;</a></span>Base</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Server_session_impl_t &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classipc_1_1session_1_1Server__session__mv.html">ipc::session::Server_session_mv</a>&lt; Server_session_impl_t &gt;::Base =  <a class="el" href="classipc_1_1session_1_1Session__mv.html">Session_mv</a>&lt;Server_session_impl_t&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Short-hand for our base class. To the user: note its <code>public</code> API is inherited. </p>

<p class="definition">Definition at line <a class="el" href="ipc__session_2src_2ipc_2session_2server__session_8hpp_source.html#l00129">129</a> of file <a class="el" href="ipc__session_2src_2ipc_2session_2server__session_8hpp_source.html">server_session.hpp</a>.</p>

</div>
</div>
<h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="ae190ff87b86aab1a68374789791553e1" name="ae190ff87b86aab1a68374789791553e1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae190ff87b86aab1a68374789791553e1">&#9670;&nbsp;</a></span>Server_session_mv()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Server_session_impl_t &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classipc_1_1session_1_1Server__session__mv.html">ipc::session::Server_session_mv</a>&lt; Server_session_impl_t &gt;::Server_session_mv </td>
          <td>(</td>
          <td class="paramtype">flow::log::Logger *&#160;</td>
          <td class="paramname"><em>logger_ptr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structipc_1_1session_1_1Server__app.html">Server_app</a> &amp;&#160;</td>
          <td class="paramname"><em>srv_app_ref</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classipc_1_1transport_1_1sync__io_1_1Native__socket__stream.html">transport::sync_io::Native_socket_stream</a> &amp;&amp;&#160;</td>
          <td class="paramname"><em>master_channel_sock_stm</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">explicit</span><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>For use by internal user <a class="el" href="classipc_1_1session_1_1Session__server__impl.html" title="Internal class template comprising API/logic common to every Session_server variant,...">Session_server_impl</a>: constructor. </p>
<p >Invoke <a class="el" href="classipc_1_1session_1_1Server__session__mv.html#a74d647e2f555465c28065dc11cd092cb" title="For use by internal user Session_server: called no more than once, ideally immediately following ctor...">async_accept_log_in()</a> to move forward toward PEER state.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">logger_ptr</td><td>Logger to use for logging subsequently. </td></tr>
    <tr><td class="paramname">srv_app_ref</td><td>Properties of this server application. The address is copied; the object is not copied. </td></tr>
    <tr><td class="paramname">master_channel_sock_stm</td><td>The PEER-state <a class="el" href="classipc_1_1transport_1_1sync__io_1_1Native__socket__stream.html" title="Implements both sync_io::Native_handle_sender and sync_io::Native_handle_receiver concepts by using a...">transport::sync_io::Native_socket_stream</a> that just connected to an opposing <a class="el" href="classipc_1_1session_1_1Client__session__impl.html" title="Internal, non-movable pImpl-lite implementation of Client_session_mv class template.">Client_session_impl</a>. It is moved-to <code>*this</code> (and hence becomes <code>.null()</code>). </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="ipc__session_2src_2ipc_2session_2server__session_8hpp_source.html#l00315">315</a> of file <a class="el" href="ipc__session_2src_2ipc_2session_2server__session_8hpp_source.html">server_session.hpp</a>.</p>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="a74d647e2f555465c28065dc11cd092cb" name="a74d647e2f555465c28065dc11cd092cb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a74d647e2f555465c28065dc11cd092cb">&#9670;&nbsp;</a></span>async_accept_log_in()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Server_session_impl_t &gt; </div>
<div class="memtemplate">
template&lt;typename Session_server_impl_t , typename Task_err , typename Cli_app_lookup_func , typename Cli_namespace_func , typename Pre_rsp_setup_func , typename N_init_channels_by_srv_req_func , typename Mdt_load_func &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classipc_1_1session_1_1Server__session__mv.html">ipc::session::Server_session_mv</a>&lt; Server_session_impl_t &gt;::async_accept_log_in </td>
          <td>(</td>
          <td class="paramtype">Session_server_impl_t *&#160;</td>
          <td class="paramname"><em>srv</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">typename <a class="el" href="classipc_1_1session_1_1Session__mv.html#af87da439644b2afd73d6a13d97e7985f">Base::Channels</a> *&#160;</td>
          <td class="paramname"><em>init_channels_by_srv_req</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">typename <a class="el" href="classipc_1_1session_1_1Session__mv.html#a2b1215fb0c9738b9fcfbb337d23c43df">Base::Mdt_reader_ptr</a> *&#160;</td>
          <td class="paramname"><em>mdt_from_cli_or_null</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">typename <a class="el" href="classipc_1_1session_1_1Session__mv.html#af87da439644b2afd73d6a13d97e7985f">Base::Channels</a> *&#160;</td>
          <td class="paramname"><em>init_channels_by_cli_req</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Cli_app_lookup_func &amp;&amp;&#160;</td>
          <td class="paramname"><em>cli_app_lookup_func</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Cli_namespace_func &amp;&amp;&#160;</td>
          <td class="paramname"><em>cli_namespace_func</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Pre_rsp_setup_func &amp;&amp;&#160;</td>
          <td class="paramname"><em>pre_rsp_setup_func</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">N_init_channels_by_srv_req_func &amp;&amp;&#160;</td>
          <td class="paramname"><em>n_init_channels_by_srv_req_func</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Mdt_load_func &amp;&amp;&#160;</td>
          <td class="paramname"><em>mdt_load_func</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Task_err &amp;&amp;&#160;</td>
          <td class="paramname"><em>on_done_func</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>For use by internal user <a class="el" href="classipc_1_1session_1_1Session__server.html" title="To be instantiated typically once in a given process, an object of this type asynchronously listens f...">Session_server</a>: called no more than once, ideally immediately following ctor, this attempts to get <code>*this</code> asynchronously to almost-PEER state by undergoing the log-in request/response (plus, if needed, init-channel-opening) procedure (the other side of which is done by <a class="el" href="classipc_1_1session_1_1Client__session__impl.html#ab8b6d1a2dff86fb565936f4bd048c146" title="See Client_session_mv counterpart.">Client_session_impl::sync_connect()</a>). </p>
<p >On success, <code>on_done_func(Error_code())</code> is invoked from unspecified thread that is not the user's calling thread. On failure, it does similarly but with a non-success code. If the op does not complete before dtor, then <code>on_done_func(error::Code::S_OBJECT_SHUTDOWN_ABORTED_COMPLETION_HANDLER)</code> is invoked at that point.</p>
<p >In the success-case firing, <code>*this</code> is ready to be given to the public user. However it is in almost-PEER state. To achieve PEER state they shall first call <a class="el" href="classipc_1_1session_1_1Server__session__mv.html#a99097e5aa6883877c74f8a93ebc9f3e1" title="To be invoked by public user upon first obtaining *this: memorizes the given on-error and on-passive-...">init_handlers()</a>.</p>
<p ><a class="el" href="namespaceipc.html#aa3192e586cc45d3e7c22463bf2760f89" title="Short-hand for flow::Error_code which is very common.">Error_code</a> generated and passed to <code>on_done_func()</code>: <a class="el" href="namespaceipc_1_1session_1_1error.html#a0708d4bec9ae853f4d7e3d7822fc8f2fafe29343445a7bf167cc186a44bd2c6ed" title="Async completion handler is being called prematurely, because underlying object is shutting down,...">session::error::Code::S_OBJECT_SHUTDOWN_ABORTED_COMPLETION_HANDLER</a> (see above), those returned by <a class="el" href="classipc_1_1transport_1_1Native__socket__stream.html#af63671c0e30d39d3460331c4dd3742b2" title="OS-reported process credential (PID, etc.) info about the other connected peer&#39;s process,...">transport::Native_socket_stream::remote_peer_process_credentials()</a>, those emitted by <a class="el" href="classipc_1_1transport_1_1struc_1_1Channel.html#ae645cb58ad9ea6374970f1f32c5da448" title="In the synchronous/non-blocking manner of Blob_sender::send_blob() or Native_handle_sender::send_nati...">transport::struc::Channel::send()</a>, those emitted by <a class="el" href="classipc_1_1transport_1_1struc_1_1Channel.html" title="Owning and wrapping a pre-connected transport::Channel peer (an endpoint of an established channel ov...">transport::struc::Channel</a> via on-error handler (most likely <a class="el" href="namespaceipc_1_1transport_1_1error.html#adfef15ef4e76cc55d652fbd9c2797297aad44f87d53255ba573d57086dfeab805" title="Will not receive message: either opposing user sent graceful-close via API.">transport::error::Code::S_RECEIVES_FINISHED_CANNOT_RECEIVE</a> indicating graceful shutdown of opposing process coincidentally during log-in procedure, prematurely ending session while it was starting), <a class="el" href="namespaceipc_1_1session_1_1error.html#a0708d4bec9ae853f4d7e3d7822fc8f2faa195e468548ba9602c27590f2d6d49f0" title="Session master channel: log-in as server: client identifies self as unknown client-app or one that is...">error::Code::S_SERVER_MASTER_LOG_IN_REQUEST_CLIENT_APP_DISALLOWED_OR_UNKNOWN</a>, <a class="el" href="namespaceipc_1_1session_1_1error.html#a0708d4bec9ae853f4d7e3d7822fc8f2fa3f305ed5a242f067c9116216c0674264" title="Session master channel: log-in as server: client application-level process credentials (UID,...">error::Code::S_SERVER_MASTER_LOG_IN_REQUEST_CLIENT_APP_INCONSISTENT_CREDS</a>, those emitted by <code>pre_rsp_setup_func()</code> (in-arg).</p>
<dl class="section note"><dt>Note</dt><dd>If the above list substantially changes, please update <a class="el" href="classipc_1_1session_1_1Session__server.html#a13887cd64912bb5f5675e2817ff8435f" title="Asynchronously awaits for an opposing Client_session to request session establishment and calls on_do...">Session_server::async_accept()</a> doc header accordingly for user convenience.</dd></dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Session_server_impl_t</td><td>See <code>srv</code>. </td></tr>
    <tr><td class="paramname">Task_err</td><td>Handler type matching signature of <code>flow::async::Task_asio_err</code>. </td></tr>
    <tr><td class="paramname">Cli_app_lookup_func</td><td>Function type that takes a supposed <a class="el" href="structipc_1_1session_1_1App.html#a8e67b57829fe43a122a23c699b5de8fd" title="Brief application name, readable to humans and unique across all other applications&#39; names; used both...">Client_app::m_name</a> and returns the <code>const Client_app*</code> with that matching name; or null if it is not a validly registered name according to the data given to the internal user. </td></tr>
    <tr><td class="paramname">Cli_namespace_func</td><td>Function type that returns a sufficiently-distinct value for <a class="el" href="classipc_1_1session_1_1Session__base.html#abd1e814b3b640f4bdaa2553352405f26" title="See Server_session_impl, Client_session_impl.">Session_base::cli_namespace()</a>, as <a class="el" href="classipc_1_1session_1_1Session__base.html#a8cc7a4faa098e0f71c737f44c34d593c" title="Sets cli_namespace() (do not call if already set).">Session_base::set_cli_namespace()</a> is required before <a class="el" href="namespaceipc_1_1session.html#ab01d5bce0ab2f3435ca9dd88d27609dc" title="A vanilla Server_session with no optional capabilities.">Server_session</a> can be in PEER state and available to the public user. </td></tr>
    <tr><td class="paramname">Pre_rsp_setup_func</td><td>Function type with signature <code>Error_code F()</code>. </td></tr>
    <tr><td class="paramname">N_init_channels_by_srv_req_func</td><td>See <a class="el" href="classipc_1_1session_1_1Session__server.html#a13887cd64912bb5f5675e2817ff8435f" title="Asynchronously awaits for an opposing Client_session to request session establishment and calls on_do...">Session_server::async_accept()</a>. Type and arg value forwarded from there. </td></tr>
    <tr><td class="paramname">Mdt_load_func</td><td>See <a class="el" href="classipc_1_1session_1_1Session__server.html#a13887cd64912bb5f5675e2817ff8435f" title="Asynchronously awaits for an opposing Client_session to request session establishment and calls on_do...">Session_server::async_accept()</a>. Type and arg value forwarded from there. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">srv</td><td>The <a class="el" href="classipc_1_1session_1_1Session__server__impl.html" title="Internal class template comprising API/logic common to every Session_server variant,...">Session_server_impl</a> whose <a class="el" href="classipc_1_1session_1_1Session__server__impl.html#a60ec88b23d73c354959a1e11636dc717" title="See Session_server method.">Session_server_impl::async_accept()</a> is invoking the present method. <code>*srv</code> must exist at least while <code>*this</code> does, or behavior is undefined. This allows for interaction/cooperation with the "parent" <code><a class="el" href="classipc_1_1session_1_1Session__server.html" title="To be instantiated typically once in a given process, an object of this type asynchronously listens f...">Session_server</a></code> if necessary, such as for shared cross-session resources. Note: you may use <code>srv-&gt;this_session_srv()</code> to obtain a pointer to the <code><a class="el" href="classipc_1_1session_1_1Session__server.html" title="To be instantiated typically once in a given process, an object of this type asynchronously listens f...">Session_server</a></code>-like object on which the user invoked <code>async_accept()</code>. E.g.: <a class="el" href="classipc_1_1session_1_1Server__session__impl.html#a92861565c698467bc58e44fbe471e356" title="For use by internal user Session_server: See Server_session_mv counterpart.">Server_session_impl::async_accept_log_in()</a> would get a <code>Session_server*</code>; <a class="el" href="classipc_1_1session_1_1shm_1_1classic_1_1Server__session__impl.html#a9c78b2c35b853e1702a06ec451545945" title="For use by internal user Session_server: See Server_session_mv counterpart.">shm::classic::Server_session_impl::async_accept_log_in()</a> would get a <code><a class="el" href="classipc_1_1session_1_1shm_1_1classic_1_1Session__server.html" title="This is to vanilla Session_server what shm::classic::Server_session is to vanilla Server_session: it ...">shm::classic::Session_server</a>*</code>. </td></tr>
    <tr><td class="paramname">init_channels_by_srv_req</td><td>See <a class="el" href="classipc_1_1session_1_1Session__server.html#a13887cd64912bb5f5675e2817ff8435f" title="Asynchronously awaits for an opposing Client_session to request session establishment and calls on_do...">Session_server::async_accept()</a>. Arg value forwarded from there. </td></tr>
    <tr><td class="paramname">mdt_from_cli_or_null</td><td>See <a class="el" href="classipc_1_1session_1_1Session__server.html#a13887cd64912bb5f5675e2817ff8435f" title="Asynchronously awaits for an opposing Client_session to request session establishment and calls on_do...">Session_server::async_accept()</a>. Arg value forwarded from there. </td></tr>
    <tr><td class="paramname">init_channels_by_cli_req</td><td>See <a class="el" href="classipc_1_1session_1_1Session__server.html#a13887cd64912bb5f5675e2817ff8435f" title="Asynchronously awaits for an opposing Client_session to request session establishment and calls on_do...">Session_server::async_accept()</a>. Arg value forwarded from there. </td></tr>
    <tr><td class="paramname">cli_app_lookup_func</td><td>See <code>Cli_app_lookup_func</code>. </td></tr>
    <tr><td class="paramname">cli_namespace_func</td><td>See <code>Cli_namespace_func</code>. </td></tr>
    <tr><td class="paramname">pre_rsp_setup_func</td><td>Invoked just before sending successful log-in response to opposing client, which completes the log-in. It takes no arguments &ndash; but all <code>*this</code> accessors up to/including <code>cli_app_ptr()</code> shall return real values &ndash; and shall return falsy on success; or the reason for failure as <a class="el" href="namespaceipc.html#aa3192e586cc45d3e7c22463bf2760f89" title="Short-hand for flow::Error_code which is very common.">Error_code</a>. In the latter case this method shall emit that code as the reason for overall failure. This can be used for setting up resources, such as SHM arena(s), that the client shall count on being available (perhaps at known <a class="el" href="namespaceipc_1_1session.html#a6d07d9996af19e57eb42416e914110ea" title="Convenience alias for the commonly used type util::Shared_name.">Shared_name</a> based on <code>*this</code> accessor values). </td></tr>
    <tr><td class="paramname">n_init_channels_by_srv_req_func</td><td>See <code>N_init_channels_by_srv_req_func</code>. </td></tr>
    <tr><td class="paramname">mdt_load_func</td><td>See <code>Mdt_load_func</code>. </td></tr>
    <tr><td class="paramname">on_done_func</td><td>See above. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="ipc__session_2src_2ipc_2session_2server__session_8hpp_source.html#l00332">332</a> of file <a class="el" href="ipc__session_2src_2ipc_2session_2server__session_8hpp_source.html">server_session.hpp</a>.</p>

</div>
</div>
<a id="ac873543383b7a6da94d4353231f34ec2" name="ac873543383b7a6da94d4353231f34ec2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac873543383b7a6da94d4353231f34ec2">&#9670;&nbsp;</a></span>client_app()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Server_session_impl_t &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="structipc_1_1session_1_1Client__app.html">Client_app</a> * <a class="el" href="classipc_1_1session_1_1Server__session__mv.html">ipc::session::Server_session_mv</a>&lt; Server_session_impl_t &gt;::client_app</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The opposing application is described by a <a class="el" href="structipc_1_1session_1_1Client__app.html" title="An App that is used as a client in at least one client-server IPC split.">Client_app</a>; this is that description. </p>
<p >May be useful in particular when deciding what handlers to set up in <a class="el" href="classipc_1_1session_1_1Server__session__mv.html#a99097e5aa6883877c74f8a93ebc9f3e1" title="To be invoked by public user upon first obtaining *this: memorizes the given on-error and on-passive-...">init_handlers()</a> when entering PEER state. Returns null if <code>*this</code> is as-if default-cted (i.e., default-cted + not moved-to otherwise; or moved-from).</p>
<dl class="section return"><dt>Returns</dt><dd>Pointer to immutable <a class="el" href="structipc_1_1session_1_1Client__app.html" title="An App that is used as a client in at least one client-server IPC split.">Client_app</a>; or null if <code>*this</code> is as-if default-cted. The pointer returned, when not straddling a move-to or move-from, is always the same. </dd></dl>

<p class="definition">Definition at line <a class="el" href="ipc__session_2src_2ipc_2session_2server__session_8hpp_source.html#l00323">323</a> of file <a class="el" href="ipc__session_2src_2ipc_2session_2server__session_8hpp_source.html">server_session.hpp</a>.</p>

</div>
</div>
<a id="ac1ea393b9d0d7de60f7433cbc7dad0d4" name="ac1ea393b9d0d7de60f7433cbc7dad0d4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac1ea393b9d0d7de60f7433cbc7dad0d4">&#9670;&nbsp;</a></span>init_handlers() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Server_session_impl_t &gt; </div>
<div class="memtemplate">
template&lt;typename Task_err &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classipc_1_1session_1_1Server__session__mv.html">ipc::session::Server_session_mv</a>&lt; Server_session_impl_t &gt;::init_handlers </td>
          <td>(</td>
          <td class="paramtype">Task_err &amp;&amp;&#160;</td>
          <td class="paramname"><em>on_err_func_arg</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Alternative to the other <a class="el" href="classipc_1_1session_1_1Server__session__mv.html#a99097e5aa6883877c74f8a93ebc9f3e1" title="To be invoked by public user upon first obtaining *this: memorizes the given on-error and on-passive-...">init_handlers()</a>. </p>
<p >Using this overload indicates passive-opens are disabled on this side. Otherwise identical to the other <a class="el" href="classipc_1_1session_1_1Server__session__mv.html#a99097e5aa6883877c74f8a93ebc9f3e1" title="To be invoked by public user upon first obtaining *this: memorizes the given on-error and on-passive-...">init_handlers()</a> overload.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Task_err</td><td>See other <a class="el" href="classipc_1_1session_1_1Server__session__mv.html#a99097e5aa6883877c74f8a93ebc9f3e1" title="To be invoked by public user upon first obtaining *this: memorizes the given on-error and on-passive-...">init_handlers()</a>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">on_err_func_arg</td><td>See other <a class="el" href="classipc_1_1session_1_1Server__session__mv.html#a99097e5aa6883877c74f8a93ebc9f3e1" title="To be invoked by public user upon first obtaining *this: memorizes the given on-error and on-passive-...">init_handlers()</a>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> normally; <code>false</code> if invoked after already having called an <a class="el" href="classipc_1_1session_1_1Server__session__mv.html#a99097e5aa6883877c74f8a93ebc9f3e1" title="To be invoked by public user upon first obtaining *this: memorizes the given on-error and on-passive-...">init_handlers()</a> or as-if default-cted. </dd></dl>

<p class="definition">Definition at line <a class="el" href="ipc__session_2src_2ipc_2session_2server__session_8hpp_source.html#l00369">369</a> of file <a class="el" href="ipc__session_2src_2ipc_2session_2server__session_8hpp_source.html">server_session.hpp</a>.</p>

</div>
</div>
<a id="a99097e5aa6883877c74f8a93ebc9f3e1" name="a99097e5aa6883877c74f8a93ebc9f3e1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a99097e5aa6883877c74f8a93ebc9f3e1">&#9670;&nbsp;</a></span>init_handlers() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Server_session_impl_t &gt; </div>
<div class="memtemplate">
template&lt;typename Task_err , typename On_passive_open_channel_handler &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classipc_1_1session_1_1Server__session__mv.html">ipc::session::Server_session_mv</a>&lt; Server_session_impl_t &gt;::init_handlers </td>
          <td>(</td>
          <td class="paramtype">Task_err &amp;&amp;&#160;</td>
          <td class="paramname"><em>on_err_func_arg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">On_passive_open_channel_handler &amp;&amp;&#160;</td>
          <td class="paramname"><em>on_passive_open_channel_func_arg</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>To be invoked by public user upon first obtaining <code>*this</code>: memorizes the given on-error and on-passive-open handlers thus moving this <a class="el" href="classipc_1_1session_1_1Server__session__mv.html" title="Implements Session concept on the Server_app end: a Session that is emitted in almost-PEER state by l...">Server_session_mv</a> to PEER state wherein it is a formal <a class="el" href="classipc_1_1session_1_1Session.html" title="A documentation-only concept defining the local side of an IPC conversation (session) with another en...">Session</a> concept impl. </p>
<p >Using this overload indicates passive-opens are enabled on this side.</p>
<p >Suggestion: use <a class="el" href="classipc_1_1session_1_1Server__session__mv.html#ac873543383b7a6da94d4353231f34ec2" title="The opposing application is described by a Client_app; this is that description.">client_app()</a> to determine the opposing <a class="el" href="structipc_1_1session_1_1Client__app.html" title="An App that is used as a client in at least one client-server IPC split.">Client_app</a>, particularly if this <a class="el" href="structipc_1_1session_1_1Server__app.html" title="An App that is used as a server in at least one client-server IPC split.">Server_app</a> is designed to accept sessions from 2+ <code><a class="el" href="structipc_1_1session_1_1Client__app.html" title="An App that is used as a client in at least one client-server IPC split.">Client_app</a></code>s. (To be clear: Multiple <em>instances</em> (processes) of a <em>given</em> <a class="el" href="structipc_1_1session_1_1Client__app.html" title="An App that is used as a client in at least one client-server IPC split.">Client_app</a> are always supported. However a given <a class="el" href="structipc_1_1session_1_1Server__app.html" title="An App that is used as a server in at least one client-server IPC split.">Server_app</a> &ndash; specified at <a class="el" href="classipc_1_1session_1_1Session__server.html" title="To be instantiated typically once in a given process, an object of this type asynchronously listens f...">Session_server</a> construction time &ndash; may well specify only one allowed opposing <a class="el" href="structipc_1_1session_1_1Client__app.html" title="An App that is used as a client in at least one client-server IPC split.">Client_app</a>.) It is likely that a different on-passive-open handler would be useful depending on <a class="el" href="structipc_1_1session_1_1Client__app.html" title="An App that is used as a client in at least one client-server IPC split.">Client_app</a>; possibly also different on-error handler.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Task_err</td><td>See <a class="el" href="classipc_1_1session_1_1Session.html" title="A documentation-only concept defining the local side of an IPC conversation (session) with another en...">Session</a> concept doc header for semantics. </td></tr>
    <tr><td class="paramname">On_passive_open_channel_handler</td><td>See <a class="el" href="classipc_1_1session_1_1Session.html" title="A documentation-only concept defining the local side of an IPC conversation (session) with another en...">Session</a> concept doc header for semantics. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">on_err_func_arg</td><td>On-error handler per semantics in <a class="el" href="classipc_1_1session_1_1Session.html" title="A documentation-only concept defining the local side of an IPC conversation (session) with another en...">Session</a> concept doc header. </td></tr>
    <tr><td class="paramname">on_passive_open_channel_func_arg</td><td>On-passive-open handler per semantics in <a class="el" href="classipc_1_1session_1_1Session.html" title="A documentation-only concept defining the local side of an IPC conversation (session) with another en...">Session</a> concept doc header. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> normally; <code>false</code> if invoked after already having called an <a class="el" href="classipc_1_1session_1_1Server__session__mv.html#a99097e5aa6883877c74f8a93ebc9f3e1" title="To be invoked by public user upon first obtaining *this: memorizes the given on-error and on-passive-...">init_handlers()</a> or as-if default-cted. </dd></dl>

<p class="definition">Definition at line <a class="el" href="ipc__session_2src_2ipc_2session_2server__session_8hpp_source.html#l00359">359</a> of file <a class="el" href="ipc__session_2src_2ipc_2session_2server__session_8hpp_source.html">server_session.hpp</a>.</p>

</div>
</div>
<h2 class="groupheader">Friends And Related Function Documentation</h2>
<a id="aed5397fd025606507ad8dab74479762f" name="aed5397fd025606507ad8dab74479762f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aed5397fd025606507ad8dab74479762f">&#9670;&nbsp;</a></span>operator&lt;&lt;()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Server_session_impl_t &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::ostream &amp; operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>os</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classipc_1_1session_1_1Server__session__mv.html">Server_session_mv</a>&lt; Server_session_impl_t &gt; &amp;&#160;</td>
          <td class="paramname"><em>val</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Prints string representation of the given <code><a class="el" href="classipc_1_1session_1_1Server__session__mv.html" title="Implements Session concept on the Server_app end: a Session that is emitted in almost-PEER state by l...">Server_session_mv</a></code> to the given <code>ostream</code>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">os</td><td>Stream to which to write. </td></tr>
    <tr><td class="paramname">val</td><td>Object to serialize. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>os</code>. </dd></dl>

<p class="definition">Definition at line <a class="el" href="ipc__session_2src_2ipc_2session_2server__session_8hpp_source.html#l00375">375</a> of file <a class="el" href="ipc__session_2src_2ipc_2session_2server__session_8hpp_source.html">server_session.hpp</a>.</p>

</div>
</div>
<hr/>The documentation for this class was generated from the following files:<ul>
<li>session/<a class="el" href="ipc__session_2src_2ipc_2session_2server__session_8hpp_source.html">server_session.hpp</a></li>
<li>session/<a class="el" href="session__fwd_8hpp_source.html">session_fwd.hpp</a></li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Tue Mar 5 2024 06:04:43 for Flow-IPC by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.4
</small></address>
</body>
</html>
