<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.9.4"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Flow-IPC: ipc::session::shm::classic::Server_session&lt; S_MQ_TYPE_OR_NONE, S_TRANSMIT_NATIVE_HANDLES, Mdt_payload &gt; Class Template Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">Flow-IPC<span id="projectnumber">&#160;1.0</span>
   </div>
   <div id="projectbrief">Flow-IPC project: Full implementation reference.</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.4 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search",'Search','.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespaceipc.html">ipc</a></li><li class="navelem"><a class="el" href="namespaceipc_1_1session.html">session</a></li><li class="navelem"><a class="el" href="namespaceipc_1_1session_1_1shm.html">shm</a></li><li class="navelem"><a class="el" href="namespaceipc_1_1session_1_1shm_1_1classic.html">classic</a></li><li class="navelem"><a class="el" href="classipc_1_1session_1_1shm_1_1classic_1_1Server__session.html">Server_session</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-types">Public Types</a> &#124;
<a href="#pro-methods">Protected Member Functions</a> &#124;
<a href="#related">Related Functions</a> &#124;
<a href="classipc_1_1session_1_1shm_1_1classic_1_1Server__session-members.html">List of all members</a>  </div>
  <div class="headertitle"><div class="title">ipc::session::shm::classic::Server_session&lt; S_MQ_TYPE_OR_NONE, S_TRANSMIT_NATIVE_HANDLES, Mdt_payload &gt; Class Template Reference</div></div>
</div><!--header-->
<div class="contents">

<p>Identical to <a class="el" href="namespaceipc_1_1session.html#ab01d5bce0ab2f3435ca9dd88d27609dc" title="A vanilla Server_session with no optional capabilities.">session::Server_session</a> in every way, except that it makes available two SHM arenas, from the SHM-classic provider (<a class="el" href="classipc_1_1shm_1_1classic_1_1Pool__arena.html" title="A SHM-classic interface around a single SHM pool with allocation-algorithm services by boost....">ipc::shm::classic::Pool_arena</a>), symmetrically accessible by the opposing side.  
 <a href="classipc_1_1session_1_1shm_1_1classic_1_1Server__session.html#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="ipc__shm_2src_2ipc_2session_2shm_2classic_2server__session_8hpp_source.html">server_session.hpp</a>&gt;</code></p>
<div class="dynheader">
Inheritance diagram for ipc::session::shm::classic::Server_session&lt; S_MQ_TYPE_OR_NONE, S_TRANSMIT_NATIVE_HANDLES, Mdt_payload &gt;:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="classipc_1_1session_1_1shm_1_1classic_1_1Server__session__inherit__graph.svg" width="195" height="251"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe>
</div>
<center><span class="legend">[<a href="graph_legend.html">legend</a>]</span></center></div>
<div class="dynheader">
Collaboration diagram for ipc::session::shm::classic::Server_session&lt; S_MQ_TYPE_OR_NONE, S_TRANSMIT_NATIVE_HANDLES, Mdt_payload &gt;:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="classipc_1_1session_1_1shm_1_1classic_1_1Server__session__coll__graph.svg" width="195" height="251"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe>
</div>
<center><span class="legend">[<a href="graph_legend.html">legend</a>]</span></center></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-types" name="pub-types"></a>
Public Types</h2></td></tr>
<tr class="memitem:a1507bab4b191f908e9c45470fdb8d296"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classipc_1_1session_1_1shm_1_1classic_1_1Server__session.html#a1507bab4b191f908e9c45470fdb8d296">Base</a> = <a class="el" href="classipc_1_1session_1_1shm_1_1classic_1_1Session__mv.html">Session_mv</a>&lt; <a class="el" href="classipc_1_1session_1_1Server__session__mv.html">session::Server_session_mv</a>&lt; <a class="el" href="classipc_1_1session_1_1shm_1_1classic_1_1Server__session__impl.html">Server_session_impl</a>&lt; S_MQ_TYPE_OR_NONE, S_TRANSMIT_NATIVE_HANDLES, Mdt_payload &gt; &gt; &gt;</td></tr>
<tr class="memdesc:a1507bab4b191f908e9c45470fdb8d296"><td class="mdescLeft">&#160;</td><td class="mdescRight">Short-hand for our base class. To the user: note its <code>public</code> API is inherited.  <a href="classipc_1_1session_1_1shm_1_1classic_1_1Server__session.html#a1507bab4b191f908e9c45470fdb8d296">More...</a><br /></td></tr>
<tr class="separator:a1507bab4b191f908e9c45470fdb8d296"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac11498f4b8a526f2525de8e3d2dcf08c"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classipc_1_1session_1_1shm_1_1classic_1_1Server__session.html#ac11498f4b8a526f2525de8e3d2dcf08c">Base</a> = <a class="el" href="classSession__t.html">Session_t</a></td></tr>
<tr class="memdesc:ac11498f4b8a526f2525de8e3d2dcf08c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Inherit default, move ctors.  <a href="classipc_1_1session_1_1shm_1_1classic_1_1Server__session.html#ac11498f4b8a526f2525de8e3d2dcf08c">More...</a><br /></td></tr>
<tr class="separator:ac11498f4b8a526f2525de8e3d2dcf08c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pub_types_classipc_1_1session_1_1shm_1_1classic_1_1Session__mv"><td colspan="2" onclick="javascript:toggleInherit('pub_types_classipc_1_1session_1_1shm_1_1classic_1_1Session__mv')"><img src="closed.png" alt="-"/>&#160;Public Types inherited from <a class="el" href="classipc_1_1session_1_1shm_1_1classic_1_1Session__mv.html">ipc::session::shm::classic::Session_mv&lt; Session_t &gt;</a></td></tr>
<tr class="memitem:ac11498f4b8a526f2525de8e3d2dcf08c inherit pub_types_classipc_1_1session_1_1shm_1_1classic_1_1Session__mv"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classipc_1_1session_1_1shm_1_1classic_1_1Session__mv.html#ac11498f4b8a526f2525de8e3d2dcf08c">Base</a> = <a class="el" href="classSession__t.html">Session_t</a></td></tr>
<tr class="memdesc:ac11498f4b8a526f2525de8e3d2dcf08c inherit pub_types_classipc_1_1session_1_1shm_1_1classic_1_1Session__mv"><td class="mdescLeft">&#160;</td><td class="mdescRight">Short-hand for our base class. To the user: note its <code>public</code> API is inherited.  <a href="classipc_1_1session_1_1shm_1_1classic_1_1Session__mv.html#ac11498f4b8a526f2525de8e3d2dcf08c">More...</a><br /></td></tr>
<tr class="separator:ac11498f4b8a526f2525de8e3d2dcf08c inherit pub_types_classipc_1_1session_1_1shm_1_1classic_1_1Session__mv"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a07c9b1803567c2714ae48433e756047f inherit pub_types_classipc_1_1session_1_1shm_1_1classic_1_1Session__mv"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classipc_1_1session_1_1shm_1_1classic_1_1Session__mv.html#a07c9b1803567c2714ae48433e756047f">Arena</a> = typename Base::Base::Impl::Arena</td></tr>
<tr class="memdesc:a07c9b1803567c2714ae48433e756047f inherit pub_types_classipc_1_1session_1_1shm_1_1classic_1_1Session__mv"><td class="mdescLeft">&#160;</td><td class="mdescRight">The arena object on which one may call <code>construct&lt;T&gt;(ctor_args...)</code>, where <code>ctor_args</code> are arguments to the <code>T::T()</code> constructor.  <a href="classipc_1_1session_1_1shm_1_1classic_1_1Session__mv.html#a07c9b1803567c2714ae48433e756047f">More...</a><br /></td></tr>
<tr class="separator:a07c9b1803567c2714ae48433e756047f inherit pub_types_classipc_1_1session_1_1shm_1_1classic_1_1Session__mv"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeb1fceac476bc8bd159710b7d01f0fe3 inherit pub_types_classipc_1_1session_1_1shm_1_1classic_1_1Session__mv"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:aeb1fceac476bc8bd159710b7d01f0fe3 inherit pub_types_classipc_1_1session_1_1shm_1_1classic_1_1Session__mv"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classipc_1_1session_1_1shm_1_1classic_1_1Session__mv.html#aeb1fceac476bc8bd159710b7d01f0fe3">Allocator</a> = <a class="el" href="classipc_1_1shm_1_1stl_1_1Stateless__allocator.html">ipc::shm::stl::Stateless_allocator</a>&lt; T, <a class="el" href="classipc_1_1session_1_1shm_1_1classic_1_1Session__mv.html#a07c9b1803567c2714ae48433e756047f">Arena</a> &gt;</td></tr>
<tr class="memdesc:aeb1fceac476bc8bd159710b7d01f0fe3 inherit pub_types_classipc_1_1session_1_1shm_1_1classic_1_1Session__mv"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convenience alias to be used in STL-compliant <code>T</code>s with <code>"Arena::construct&lt;T&gt;()"</code>, our own <a class="el" href="classipc_1_1session_1_1shm_1_1classic_1_1Session__mv.html#a794f83a8111428b3b1feec7216f692dd" title="Adds an owner process to the owner set of the given session_shm-&gt;construct()- or app_shm()-&gt;construct...">lend_object&lt;T&gt;()</a>, and <code>"Arena::lend_object&lt;T&gt;()"</code>.  <a href="classipc_1_1session_1_1shm_1_1classic_1_1Session__mv.html#aeb1fceac476bc8bd159710b7d01f0fe3">More...</a><br /></td></tr>
<tr class="separator:aeb1fceac476bc8bd159710b7d01f0fe3 inherit pub_types_classipc_1_1session_1_1shm_1_1classic_1_1Session__mv"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aecfab9c96933a832be7d2ad91be33532 inherit pub_types_classipc_1_1session_1_1shm_1_1classic_1_1Session__mv"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:aecfab9c96933a832be7d2ad91be33532 inherit pub_types_classipc_1_1session_1_1shm_1_1classic_1_1Session__mv"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classipc_1_1session_1_1shm_1_1classic_1_1Session__mv.html#aecfab9c96933a832be7d2ad91be33532">Borrower_allocator</a> = <a class="el" href="classipc_1_1shm_1_1stl_1_1Stateless__allocator.html">ipc::shm::stl::Stateless_allocator</a>&lt; T, <a class="el" href="namespaceipc_1_1shm.html#a6c8474d5b7dda220ed1f6693fc2e3c89">ipc::shm::Arena_to_borrower_allocator_arena_t</a>&lt; <a class="el" href="classipc_1_1session_1_1shm_1_1classic_1_1Session__mv.html#a07c9b1803567c2714ae48433e756047f">Arena</a> &gt; &gt;</td></tr>
<tr class="memdesc:aecfab9c96933a832be7d2ad91be33532 inherit pub_types_classipc_1_1session_1_1shm_1_1classic_1_1Session__mv"><td class="mdescLeft">&#160;</td><td class="mdescRight">Equals <a class="el" href="classAllocator.html">Allocator</a>; provided for generic programming for algorithms that would use <a class="el" href="classipc_1_1session_1_1shm_1_1classic_1_1Session__mv.html" title="Implements the SHM-related API common to shm::classic::Server_session and shm::classic::Client_sessio...">classic::Session_mv</a> interchangeably with <a class="el" href="classipc_1_1session_1_1shm_1_1arena__lend_1_1jemalloc_1_1Session__mv.html" title="Implements the SHM-related API common to shm::arena_lend::jemalloc::Server_session and shm::arena_len...">shm::arena_lend::jemalloc::Session_mv</a>.  <a href="classipc_1_1session_1_1shm_1_1classic_1_1Session__mv.html#aecfab9c96933a832be7d2ad91be33532">More...</a><br /></td></tr>
<tr class="separator:aecfab9c96933a832be7d2ad91be33532 inherit pub_types_classipc_1_1session_1_1shm_1_1classic_1_1Session__mv"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a96f6b597be7cc29f9207df909a4816c4 inherit pub_types_classipc_1_1session_1_1shm_1_1classic_1_1Session__mv"><td class="memTemplParams" colspan="2">template&lt;typename Message_body &gt; </td></tr>
<tr class="memitem:a96f6b597be7cc29f9207df909a4816c4 inherit pub_types_classipc_1_1session_1_1shm_1_1classic_1_1Session__mv"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classipc_1_1session_1_1shm_1_1classic_1_1Session__mv.html#a96f6b597be7cc29f9207df909a4816c4">Structured_channel</a> = typename <a class="el" href="namespaceipc_1_1transport_1_1struc_1_1shm_1_1classic.html#ac543b500a85f556564e592cbbefb6185">transport::struc::shm::classic::Channel</a>&lt; typename Base::Base::Impl::Session_base_obj::Channel_obj, Message_body &gt;</td></tr>
<tr class="memdesc:a96f6b597be7cc29f9207df909a4816c4 inherit pub_types_classipc_1_1session_1_1shm_1_1classic_1_1Session__mv"><td class="mdescLeft">&#160;</td><td class="mdescRight">Implements <a class="el" href="classipc_1_1session_1_1Session.html" title="A documentation-only concept defining the local side of an IPC conversation (session) with another en...">Session</a> API per contract.  <a href="classipc_1_1session_1_1shm_1_1classic_1_1Session__mv.html#a96f6b597be7cc29f9207df909a4816c4">More...</a><br /></td></tr>
<tr class="separator:a96f6b597be7cc29f9207df909a4816c4 inherit pub_types_classipc_1_1session_1_1shm_1_1classic_1_1Session__mv"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a23d60bbc945c72cd6f19fdadd7ce014d inherit pub_types_classipc_1_1session_1_1shm_1_1classic_1_1Session__mv"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classipc_1_1session_1_1shm_1_1classic_1_1Session__mv.html#a23d60bbc945c72cd6f19fdadd7ce014d">Structured_msg_builder_config</a> = typename Base::Base::Impl::Structured_msg_builder_config</td></tr>
<tr class="memdesc:a23d60bbc945c72cd6f19fdadd7ce014d inherit pub_types_classipc_1_1session_1_1shm_1_1classic_1_1Session__mv"><td class="mdescLeft">&#160;</td><td class="mdescRight">Implements <a class="el" href="classipc_1_1session_1_1Session.html" title="A documentation-only concept defining the local side of an IPC conversation (session) with another en...">Session</a> API per contract.  <a href="classipc_1_1session_1_1shm_1_1classic_1_1Session__mv.html#a23d60bbc945c72cd6f19fdadd7ce014d">More...</a><br /></td></tr>
<tr class="separator:a23d60bbc945c72cd6f19fdadd7ce014d inherit pub_types_classipc_1_1session_1_1shm_1_1classic_1_1Session__mv"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2b27e91465c5dbdefcb12a6913a9ad4c inherit pub_types_classipc_1_1session_1_1shm_1_1classic_1_1Session__mv"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classipc_1_1session_1_1shm_1_1classic_1_1Session__mv.html#a2b27e91465c5dbdefcb12a6913a9ad4c">Structured_msg_reader_config</a> = typename Base::Base::Impl::Structured_msg_reader_config</td></tr>
<tr class="memdesc:a2b27e91465c5dbdefcb12a6913a9ad4c inherit pub_types_classipc_1_1session_1_1shm_1_1classic_1_1Session__mv"><td class="mdescLeft">&#160;</td><td class="mdescRight">Implements <a class="el" href="classipc_1_1session_1_1Session.html" title="A documentation-only concept defining the local side of an IPC conversation (session) with another en...">Session</a> API per contract.  <a href="classipc_1_1session_1_1shm_1_1classic_1_1Session__mv.html#a2b27e91465c5dbdefcb12a6913a9ad4c">More...</a><br /></td></tr>
<tr class="separator:a2b27e91465c5dbdefcb12a6913a9ad4c inherit pub_types_classipc_1_1session_1_1shm_1_1classic_1_1Session__mv"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3ca151e694dc819205aff5995c16ba76 inherit pub_types_classipc_1_1session_1_1shm_1_1classic_1_1Session__mv"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classipc_1_1session_1_1shm_1_1classic_1_1Session__mv.html#a3ca151e694dc819205aff5995c16ba76">Blob</a> = typename Base::Base::Impl::Blob</td></tr>
<tr class="memdesc:a3ca151e694dc819205aff5995c16ba76 inherit pub_types_classipc_1_1session_1_1shm_1_1classic_1_1Session__mv"><td class="mdescLeft">&#160;</td><td class="mdescRight">Alias for a light-weight blob used in <a class="el" href="classipc_1_1session_1_1shm_1_1classic_1_1Session__mv.html#a4223fc944735adb6946a9d1938d06a20" title="Completes the cross-process operation begun by oppsing Session_mv::lend_object() that returned serial...">borrow_object()</a> and <a class="el" href="classipc_1_1session_1_1shm_1_1classic_1_1Session__mv.html#a794f83a8111428b3b1feec7216f692dd" title="Adds an owner process to the owner set of the given session_shm-&gt;construct()- or app_shm()-&gt;construct...">lend_object()</a>.  <a href="classipc_1_1session_1_1shm_1_1classic_1_1Session__mv.html#a3ca151e694dc819205aff5995c16ba76">More...</a><br /></td></tr>
<tr class="separator:a3ca151e694dc819205aff5995c16ba76 inherit pub_types_classipc_1_1session_1_1shm_1_1classic_1_1Session__mv"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pro-methods" name="pro-methods"></a>
Protected Member Functions</h2></td></tr>
<tr class="memitem:a785acb973864773f6c9b2892af7e9474"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classipc_1_1session_1_1shm_1_1classic_1_1Server__session.html#a785acb973864773f6c9b2892af7e9474">Server_session</a> (flow::log::Logger *logger_ptr, const <a class="el" href="structipc_1_1session_1_1Server__app.html">Server_app</a> &amp;srv_app_ref, <a class="el" href="classipc_1_1transport_1_1Native__socket__stream.html">transport::Native_socket_stream</a> &amp;&amp;master_channel_sock_stm)</td></tr>
<tr class="memdesc:a785acb973864773f6c9b2892af7e9474"><td class="mdescLeft">&#160;</td><td class="mdescRight">For use by internal user <a class="el" href="classipc_1_1session_1_1Session__server__impl.html" title="Internal class template comprising API/logic common to every Session_server variant,...">Session_server_impl</a>: constructor.  <a href="classipc_1_1session_1_1shm_1_1classic_1_1Server__session.html#a785acb973864773f6c9b2892af7e9474">More...</a><br /></td></tr>
<tr class="separator:a785acb973864773f6c9b2892af7e9474"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="related" name="related"></a>
Related Functions</h2></td></tr>
<tr><td class="ititle" colspan="2"><p >(Note that these are not member functions.) </p>
</td></tr>
<tr class="memitem:a8fc81db9a5adc7b6efc8529b5f1d98d2"><td class="memTemplParams" colspan="2">template&lt;schema::MqType S_MQ_TYPE_OR_NONE, bool S_TRANSMIT_NATIVE_HANDLES, typename Mdt_payload &gt; </td></tr>
<tr class="memitem:a8fc81db9a5adc7b6efc8529b5f1d98d2"><td class="memTemplItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classipc_1_1session_1_1shm_1_1classic_1_1Server__session.html#a8fc81db9a5adc7b6efc8529b5f1d98d2">operator&lt;&lt;</a> (std::ostream &amp;os, const <a class="el" href="classipc_1_1session_1_1shm_1_1classic_1_1Server__session.html">Server_session</a>&lt; S_MQ_TYPE_OR_NONE, S_TRANSMIT_NATIVE_HANDLES, Mdt_payload &gt; &amp;val)</td></tr>
<tr class="memdesc:a8fc81db9a5adc7b6efc8529b5f1d98d2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Prints string representation of the given <code><a class="el" href="classipc_1_1session_1_1shm_1_1classic_1_1Server__session.html" title="Identical to session::Server_session in every way, except that it makes available two SHM arenas,...">Server_session</a></code> to the given <code>ostream</code>.  <a href="classipc_1_1session_1_1shm_1_1classic_1_1Server__session.html#a8fc81db9a5adc7b6efc8529b5f1d98d2">More...</a><br /></td></tr>
<tr class="separator:a8fc81db9a5adc7b6efc8529b5f1d98d2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header related_classipc_1_1session_1_1shm_1_1classic_1_1Session__mv"><td colspan="2" onclick="javascript:toggleInherit('related_classipc_1_1session_1_1shm_1_1classic_1_1Session__mv')"><img src="closed.png" alt="-"/>&#160;Related Functions inherited from <a class="el" href="classipc_1_1session_1_1shm_1_1classic_1_1Session__mv.html">ipc::session::shm::classic::Session_mv&lt; Session_t &gt;</a></td></tr>
<tr class="memitem:aea882d38a00f81a98d6604e300c5a01a inherit related_classipc_1_1session_1_1shm_1_1classic_1_1Session__mv"><td class="memTemplParams" colspan="2">template&lt;typename <a class="el" href="classSession__t.html">Session_t</a> &gt; </td></tr>
<tr class="memitem:aea882d38a00f81a98d6604e300c5a01a inherit related_classipc_1_1session_1_1shm_1_1classic_1_1Session__mv"><td class="memTemplItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classipc_1_1session_1_1shm_1_1classic_1_1Session__mv.html#aea882d38a00f81a98d6604e300c5a01a">operator&lt;&lt;</a> (std::ostream &amp;os, const <a class="el" href="classipc_1_1session_1_1shm_1_1classic_1_1Session__mv.html">Session_mv</a>&lt; <a class="el" href="classSession__t.html">Session_t</a> &gt; &amp;val)</td></tr>
<tr class="memdesc:aea882d38a00f81a98d6604e300c5a01a inherit related_classipc_1_1session_1_1shm_1_1classic_1_1Session__mv"><td class="mdescLeft">&#160;</td><td class="mdescRight">Prints string representation of the given <code><a class="el" href="classipc_1_1session_1_1shm_1_1classic_1_1Session__mv.html" title="Implements the SHM-related API common to shm::classic::Server_session and shm::classic::Client_sessio...">Session_mv</a></code> to the given <code>ostream</code>.  <a href="classipc_1_1session_1_1shm_1_1classic_1_1Session__mv.html#aea882d38a00f81a98d6604e300c5a01a">More...</a><br /></td></tr>
<tr class="separator:aea882d38a00f81a98d6604e300c5a01a inherit related_classipc_1_1session_1_1shm_1_1classic_1_1Session__mv"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="inherited" name="inherited"></a>
Additional Inherited Members</h2></td></tr>
<tr class="inherit_header pub_methods_classipc_1_1session_1_1shm_1_1classic_1_1Session__mv"><td colspan="2" onclick="javascript:toggleInherit('pub_methods_classipc_1_1session_1_1shm_1_1classic_1_1Session__mv')"><img src="closed.png" alt="-"/>&#160;Public Member Functions inherited from <a class="el" href="classipc_1_1session_1_1shm_1_1classic_1_1Session__mv.html">ipc::session::shm::classic::Session_mv&lt; Session_t &gt;</a></td></tr>
<tr class="memitem:a9ff21b10fd753fccfa4882834e677ccf inherit pub_methods_classipc_1_1session_1_1shm_1_1classic_1_1Session__mv"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classipc_1_1session_1_1shm_1_1classic_1_1Session__mv.html#a07c9b1803567c2714ae48433e756047f">Arena</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classipc_1_1session_1_1shm_1_1classic_1_1Session__mv.html#a9ff21b10fd753fccfa4882834e677ccf">session_shm</a> ()</td></tr>
<tr class="memdesc:a9ff21b10fd753fccfa4882834e677ccf inherit pub_methods_classipc_1_1session_1_1shm_1_1classic_1_1Session__mv"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns SHM <a class="el" href="classipc_1_1session_1_1shm_1_1classic_1_1Session__mv.html#a07c9b1803567c2714ae48433e756047f" title="The arena object on which one may call construct&lt;T&gt;(ctor_args...), where ctor_args are arguments to t...">Arena</a> with per-session-scope, meaning it shall be accessible only during the lifetime of this session, by this <a class="el" href="classipc_1_1session_1_1Session.html" title="A documentation-only concept defining the local side of an IPC conversation (session) with another en...">Session</a> (via this accessor) and the opposing <a class="el" href="classipc_1_1session_1_1Session.html" title="A documentation-only concept defining the local side of an IPC conversation (session) with another en...">Session</a> (via its counterpart thereof).  <a href="classipc_1_1session_1_1shm_1_1classic_1_1Session__mv.html#a9ff21b10fd753fccfa4882834e677ccf">More...</a><br /></td></tr>
<tr class="separator:a9ff21b10fd753fccfa4882834e677ccf inherit pub_methods_classipc_1_1session_1_1shm_1_1classic_1_1Session__mv"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac6a4f1fbafb583f37d7586c6a199430f inherit pub_methods_classipc_1_1session_1_1shm_1_1classic_1_1Session__mv"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classipc_1_1session_1_1shm_1_1classic_1_1Session__mv.html#a07c9b1803567c2714ae48433e756047f">Arena</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classipc_1_1session_1_1shm_1_1classic_1_1Session__mv.html#ac6a4f1fbafb583f37d7586c6a199430f">app_shm</a> ()</td></tr>
<tr class="memdesc:ac6a4f1fbafb583f37d7586c6a199430f inherit pub_methods_classipc_1_1session_1_1shm_1_1classic_1_1Session__mv"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns SHM <a class="el" href="classipc_1_1session_1_1shm_1_1classic_1_1Session__mv.html#a07c9b1803567c2714ae48433e756047f" title="The arena object on which one may call construct&lt;T&gt;(ctor_args...), where ctor_args are arguments to t...">Arena</a> with per-app scope, meaning its pool shall be accessible potentially beyond the lifetime of this session but rather until the generating <a class="el" href="classipc_1_1session_1_1shm_1_1classic_1_1Session__server.html" title="This is to vanilla Session_server what shm::classic::Server_session is to vanilla Server_session: it ...">Session_server</a> (i.e., server process) shuts down, by any <a class="el" href="classipc_1_1session_1_1Session.html" title="A documentation-only concept defining the local side of an IPC conversation (session) with another en...">Session</a> under that umbrella, now or in the future, as long as its <a class="el" href="structipc_1_1session_1_1Client__app.html" title="An App that is used as a client in at least one client-server IPC split.">Client_app</a> equals that of <code>*this</code> session.  <a href="classipc_1_1session_1_1shm_1_1classic_1_1Session__mv.html#ac6a4f1fbafb583f37d7586c6a199430f">More...</a><br /></td></tr>
<tr class="separator:ac6a4f1fbafb583f37d7586c6a199430f inherit pub_methods_classipc_1_1session_1_1shm_1_1classic_1_1Session__mv"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a794f83a8111428b3b1feec7216f692dd inherit pub_methods_classipc_1_1session_1_1shm_1_1classic_1_1Session__mv"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a794f83a8111428b3b1feec7216f692dd inherit pub_methods_classipc_1_1session_1_1shm_1_1classic_1_1Session__mv"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classipc_1_1session_1_1shm_1_1classic_1_1Session__mv.html#a3ca151e694dc819205aff5995c16ba76">Blob</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classipc_1_1session_1_1shm_1_1classic_1_1Session__mv.html#a794f83a8111428b3b1feec7216f692dd">lend_object</a> (const typename Arena::template Handle&lt; T &gt; &amp;handle)</td></tr>
<tr class="memdesc:a794f83a8111428b3b1feec7216f692dd inherit pub_methods_classipc_1_1session_1_1shm_1_1classic_1_1Session__mv"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds an owner process to the owner set of the given <code>session_shm-&gt;construct()</code>- or <code><a class="el" href="classipc_1_1session_1_1shm_1_1classic_1_1Session__mv.html#ac6a4f1fbafb583f37d7586c6a199430f" title="Returns SHM Arena with per-app scope, meaning its pool shall be accessible potentially beyond the lif...">app_shm()</a>-&gt;construct()</code>-created handle, and returns an opaque blob, such that if one passes it to opposing <a class="el" href="classipc_1_1session_1_1shm_1_1classic_1_1Session__mv.html#a4223fc944735adb6946a9d1938d06a20" title="Completes the cross-process operation begun by oppsing Session_mv::lend_object() that returned serial...">Session_mv::borrow_object()</a> in the receiving process, that <code><a class="el" href="classipc_1_1session_1_1shm_1_1classic_1_1Session__mv.html#a4223fc944735adb6946a9d1938d06a20" title="Completes the cross-process operation begun by oppsing Session_mv::lend_object() that returned serial...">borrow_object()</a></code> shall return an equivalent <code>Handle</code> in that process.  <a href="classipc_1_1session_1_1shm_1_1classic_1_1Session__mv.html#a794f83a8111428b3b1feec7216f692dd">More...</a><br /></td></tr>
<tr class="separator:a794f83a8111428b3b1feec7216f692dd inherit pub_methods_classipc_1_1session_1_1shm_1_1classic_1_1Session__mv"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4223fc944735adb6946a9d1938d06a20 inherit pub_methods_classipc_1_1session_1_1shm_1_1classic_1_1Session__mv"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a4223fc944735adb6946a9d1938d06a20 inherit pub_methods_classipc_1_1session_1_1shm_1_1classic_1_1Session__mv"><td class="memTemplItemLeft" align="right" valign="top">Arena::template Handle&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classipc_1_1session_1_1shm_1_1classic_1_1Session__mv.html#a4223fc944735adb6946a9d1938d06a20">borrow_object</a> (const <a class="el" href="classipc_1_1session_1_1shm_1_1classic_1_1Session__mv.html#a3ca151e694dc819205aff5995c16ba76">Blob</a> &amp;serialization)</td></tr>
<tr class="memdesc:a4223fc944735adb6946a9d1938d06a20 inherit pub_methods_classipc_1_1session_1_1shm_1_1classic_1_1Session__mv"><td class="mdescLeft">&#160;</td><td class="mdescRight">Completes the cross-process operation begun by oppsing <a class="el" href="classipc_1_1session_1_1shm_1_1classic_1_1Session__mv.html#a794f83a8111428b3b1feec7216f692dd" title="Adds an owner process to the owner set of the given session_shm-&gt;construct()- or app_shm()-&gt;construct...">Session_mv::lend_object()</a> that returned <code>serialization</code>; to be invoked in the intended new owner process which is operating <code>*this</code>.  <a href="classipc_1_1session_1_1shm_1_1classic_1_1Session__mv.html#a4223fc944735adb6946a9d1938d06a20">More...</a><br /></td></tr>
<tr class="separator:a4223fc944735adb6946a9d1938d06a20 inherit pub_methods_classipc_1_1session_1_1shm_1_1classic_1_1Session__mv"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a85bb0b948b7b54c06557edd3d03d66bd inherit pub_methods_classipc_1_1session_1_1shm_1_1classic_1_1Session__mv"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classipc_1_1session_1_1shm_1_1classic_1_1Session__mv.html#a23d60bbc945c72cd6f19fdadd7ce014d">Structured_msg_builder_config</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classipc_1_1session_1_1shm_1_1classic_1_1Session__mv.html#a85bb0b948b7b54c06557edd3d03d66bd">session_shm_builder_config</a> ()</td></tr>
<tr class="memdesc:a85bb0b948b7b54c06557edd3d03d66bd inherit pub_methods_classipc_1_1session_1_1shm_1_1classic_1_1Session__mv"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns builder config suitable for capnp-serializing out-messages in SHM arena <a class="el" href="classipc_1_1session_1_1shm_1_1classic_1_1Session__mv.html#a9ff21b10fd753fccfa4882834e677ccf" title="Returns SHM Arena with per-session-scope, meaning it shall be accessible only during the lifetime of ...">session_shm()</a>.  <a href="classipc_1_1session_1_1shm_1_1classic_1_1Session__mv.html#a85bb0b948b7b54c06557edd3d03d66bd">More...</a><br /></td></tr>
<tr class="separator:a85bb0b948b7b54c06557edd3d03d66bd inherit pub_methods_classipc_1_1session_1_1shm_1_1classic_1_1Session__mv"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3af67219e611f450402824e5b8b162d6 inherit pub_methods_classipc_1_1session_1_1shm_1_1classic_1_1Session__mv"><td class="memItemLeft" align="right" valign="top">Structured_msg_builder_config::Builder::Session&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classipc_1_1session_1_1shm_1_1classic_1_1Session__mv.html#a3af67219e611f450402824e5b8b162d6">session_shm_lender_session</a> ()</td></tr>
<tr class="memdesc:a3af67219e611f450402824e5b8b162d6 inherit pub_methods_classipc_1_1session_1_1shm_1_1classic_1_1Session__mv"><td class="mdescLeft">&#160;</td><td class="mdescRight">When transmitting items originating in <a class="el" href="classipc_1_1session_1_1shm_1_1classic_1_1Session__mv.html#a07c9b1803567c2714ae48433e756047f" title="The arena object on which one may call construct&lt;T&gt;(ctor_args...), where ctor_args are arguments to t...">Arena</a> <a class="el" href="classipc_1_1session_1_1shm_1_1classic_1_1Session__mv.html#a9ff21b10fd753fccfa4882834e677ccf" title="Returns SHM Arena with per-session-scope, meaning it shall be accessible only during the lifetime of ...">session_shm()</a> via <a class="el" href="classipc_1_1transport_1_1struc_1_1shm_1_1Builder.html#a7909a2d1e1d24037fb8af5338fffa783" title="Implements concept API.">transport::struc::shm::Builder::emit_serialization()</a>(and/or <a class="el" href="classipc_1_1transport_1_1struc_1_1Channel.html" title="Owning and wrapping a pre-connected transport::Channel peer (an endpoint of an established channel ov...">transport::struc::Channel</a> send facilities), returns additional-to-payload information necessary to target the opposing process properly.  <a href="classipc_1_1session_1_1shm_1_1classic_1_1Session__mv.html#a3af67219e611f450402824e5b8b162d6">More...</a><br /></td></tr>
<tr class="separator:a3af67219e611f450402824e5b8b162d6 inherit pub_methods_classipc_1_1session_1_1shm_1_1classic_1_1Session__mv"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9e73c65e57a4de3811613763da3c628b inherit pub_methods_classipc_1_1session_1_1shm_1_1classic_1_1Session__mv"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classipc_1_1session_1_1shm_1_1classic_1_1Session__mv.html#a2b27e91465c5dbdefcb12a6913a9ad4c">Structured_msg_reader_config</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classipc_1_1session_1_1shm_1_1classic_1_1Session__mv.html#a9e73c65e57a4de3811613763da3c628b">session_shm_reader_config</a> ()</td></tr>
<tr class="memdesc:a9e73c65e57a4de3811613763da3c628b inherit pub_methods_classipc_1_1session_1_1shm_1_1classic_1_1Session__mv"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns reader config counterpart to the opposing <code>Session::session_shm_builder_config()</code> and <code>Session::session_shm_lender_session()</code>.  <a href="classipc_1_1session_1_1shm_1_1classic_1_1Session__mv.html#a9e73c65e57a4de3811613763da3c628b">More...</a><br /></td></tr>
<tr class="separator:a9e73c65e57a4de3811613763da3c628b inherit pub_methods_classipc_1_1session_1_1shm_1_1classic_1_1Session__mv"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0fbea0563835e852069cdaab506dd92c inherit pub_methods_classipc_1_1session_1_1shm_1_1classic_1_1Session__mv"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classipc_1_1session_1_1shm_1_1classic_1_1Session__mv.html#a23d60bbc945c72cd6f19fdadd7ce014d">Structured_msg_builder_config</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classipc_1_1session_1_1shm_1_1classic_1_1Session__mv.html#a0fbea0563835e852069cdaab506dd92c">app_shm_builder_config</a> ()</td></tr>
<tr class="memdesc:a0fbea0563835e852069cdaab506dd92c inherit pub_methods_classipc_1_1session_1_1shm_1_1classic_1_1Session__mv"><td class="mdescLeft">&#160;</td><td class="mdescRight">Identical to <a class="el" href="classipc_1_1session_1_1shm_1_1classic_1_1Session__mv.html#a85bb0b948b7b54c06557edd3d03d66bd" title="Returns builder config suitable for capnp-serializing out-messages in SHM arena session_shm().">session_shm_builder_config()</a> but backed by SHM arena <a class="el" href="classipc_1_1session_1_1shm_1_1classic_1_1Session__mv.html#ac6a4f1fbafb583f37d7586c6a199430f" title="Returns SHM Arena with per-app scope, meaning its pool shall be accessible potentially beyond the lif...">app_shm()</a> instead of <a class="el" href="classipc_1_1session_1_1shm_1_1classic_1_1Session__mv.html#a9ff21b10fd753fccfa4882834e677ccf" title="Returns SHM Arena with per-session-scope, meaning it shall be accessible only during the lifetime of ...">session_shm()</a>.  <a href="classipc_1_1session_1_1shm_1_1classic_1_1Session__mv.html#a0fbea0563835e852069cdaab506dd92c">More...</a><br /></td></tr>
<tr class="separator:a0fbea0563835e852069cdaab506dd92c inherit pub_methods_classipc_1_1session_1_1shm_1_1classic_1_1Session__mv"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0b7540b33fcedeaba37a3fece1bdec7a inherit pub_methods_classipc_1_1session_1_1shm_1_1classic_1_1Session__mv"><td class="memItemLeft" align="right" valign="top">Structured_msg_builder_config::Builder::Session&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classipc_1_1session_1_1shm_1_1classic_1_1Session__mv.html#a0b7540b33fcedeaba37a3fece1bdec7a">app_shm_lender_session</a> ()</td></tr>
<tr class="memdesc:a0b7540b33fcedeaba37a3fece1bdec7a inherit pub_methods_classipc_1_1session_1_1shm_1_1classic_1_1Session__mv"><td class="mdescLeft">&#160;</td><td class="mdescRight">When transmitting items originating in <a class="el" href="classipc_1_1session_1_1shm_1_1classic_1_1Session__mv.html#a07c9b1803567c2714ae48433e756047f" title="The arena object on which one may call construct&lt;T&gt;(ctor_args...), where ctor_args are arguments to t...">Arena</a> <a class="el" href="classipc_1_1session_1_1shm_1_1classic_1_1Session__mv.html#ac6a4f1fbafb583f37d7586c6a199430f" title="Returns SHM Arena with per-app scope, meaning its pool shall be accessible potentially beyond the lif...">app_shm()</a> via <a class="el" href="classipc_1_1transport_1_1struc_1_1shm_1_1Builder.html#a7909a2d1e1d24037fb8af5338fffa783" title="Implements concept API.">transport::struc::shm::Builder::emit_serialization()</a> (and/or <a class="el" href="classipc_1_1transport_1_1struc_1_1Channel.html" title="Owning and wrapping a pre-connected transport::Channel peer (an endpoint of an established channel ov...">transport::struc::Channel</a> send facilities), returns additional-to-payload information necessary to target the opposing process properly.  <a href="classipc_1_1session_1_1shm_1_1classic_1_1Session__mv.html#a0b7540b33fcedeaba37a3fece1bdec7a">More...</a><br /></td></tr>
<tr class="separator:a0b7540b33fcedeaba37a3fece1bdec7a inherit pub_methods_classipc_1_1session_1_1shm_1_1classic_1_1Session__mv"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaeeacd92acfefb73ed9af3ef22917f14 inherit pub_methods_classipc_1_1session_1_1shm_1_1classic_1_1Session__mv"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classipc_1_1session_1_1shm_1_1classic_1_1Session__mv.html#a2b27e91465c5dbdefcb12a6913a9ad4c">Structured_msg_reader_config</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classipc_1_1session_1_1shm_1_1classic_1_1Session__mv.html#aaeeacd92acfefb73ed9af3ef22917f14">app_shm_reader_config</a> ()</td></tr>
<tr class="memdesc:aaeeacd92acfefb73ed9af3ef22917f14 inherit pub_methods_classipc_1_1session_1_1shm_1_1classic_1_1Session__mv"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns reader config counterpart to <a class="el" href="classipc_1_1session_1_1shm_1_1classic_1_1Session__mv.html#a0fbea0563835e852069cdaab506dd92c" title="Identical to session_shm_builder_config() but backed by SHM arena app_shm() instead of session_shm().">app_shm_builder_config()</a>.  <a href="classipc_1_1session_1_1shm_1_1classic_1_1Session__mv.html#aaeeacd92acfefb73ed9af3ef22917f14">More...</a><br /></td></tr>
<tr class="separator:aaeeacd92acfefb73ed9af3ef22917f14 inherit pub_methods_classipc_1_1session_1_1shm_1_1classic_1_1Session__mv"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><div class="compoundTemplParams">template&lt;schema::MqType S_MQ_TYPE_OR_NONE, bool S_TRANSMIT_NATIVE_HANDLES, typename Mdt_payload&gt;<br />
class ipc::session::shm::classic::Server_session&lt; S_MQ_TYPE_OR_NONE, S_TRANSMIT_NATIVE_HANDLES, Mdt_payload &gt;</div><p >Identical to <a class="el" href="namespaceipc_1_1session.html#ab01d5bce0ab2f3435ca9dd88d27609dc" title="A vanilla Server_session with no optional capabilities.">session::Server_session</a> in every way, except that it makes available two SHM arenas, from the SHM-classic provider (<a class="el" href="classipc_1_1shm_1_1classic_1_1Pool__arena.html" title="A SHM-classic interface around a single SHM pool with allocation-algorithm services by boost....">ipc::shm::classic::Pool_arena</a>), symmetrically accessible by the opposing side. </p>
<p >These SHM arenas (see <a class="el" href="classipc_1_1session_1_1shm_1_1classic_1_1Session__mv.html#a07c9b1803567c2714ae48433e756047f" title="The arena object on which one may call construct&lt;T&gt;(ctor_args...), where ctor_args are arguments to t...">Arena</a> doc header) have different scopes:</p><ul>
<li>Per-session-scope, accessible via <a class="el" href="classipc_1_1session_1_1shm_1_1classic_1_1Session__mv.html#a9ff21b10fd753fccfa4882834e677ccf" title="Returns SHM Arena with per-session-scope, meaning it shall be accessible only during the lifetime of ...">session_shm()</a>: meaning it shall be accessible only during the lifetime of this session, by this <a class="el" href="classipc_1_1session_1_1Session.html" title="A documentation-only concept defining the local side of an IPC conversation (session) with another en...">Session</a> (via this accessor) and the opposing <a class="el" href="classipc_1_1session_1_1Session.html" title="A documentation-only concept defining the local side of an IPC conversation (session) with another en...">Session</a> (via its counterpart thereof).<ul>
<li>Hence this arena is created at the time both mutually opposing <a class="el" href="classipc_1_1session_1_1Session.html" title="A documentation-only concept defining the local side of an IPC conversation (session) with another en...">Session</a> objects, including <code>*this</code>, enter PEER state (more precisely just before the <a class="el" href="namespaceipc_1_1session_1_1shm_1_1classic.html#ac6c443a72e0f22710c83bb1e8c229618" title="This is to session::Client_session what shm::classic::Server_session is to session::Server_session.">shm::classic::Client_session</a> receives word from <code>*this</code> that log-in is successful). When <code>*this</code> is destroyed or hosed, the arena is invalidated.</li>
</ul>
</li>
<li>Per-app-scope, meaning its pool shall be accessible potentially beyond the lifetime of this session but rather until the generating <a class="el" href="classipc_1_1session_1_1shm_1_1classic_1_1Session__server.html" title="This is to vanilla Session_server what shm::classic::Server_session is to vanilla Server_session: it ...">Session_server</a> (i.e., server process) shuts down, by any <a class="el" href="classipc_1_1session_1_1Session.html" title="A documentation-only concept defining the local side of an IPC conversation (session) with another en...">Session</a> under that umbrella, now or in the future, as long as its <a class="el" href="structipc_1_1session_1_1Client__app.html" title="An App that is used as a client in at least one client-server IPC split.">Client_app</a> equals that of <code>*this</code> session.<ul>
<li>Hence this arena is created at the time the <a class="el" href="classipc_1_1session_1_1shm_1_1classic_1_1Session__server.html" title="This is to vanilla Session_server what shm::classic::Server_session is to vanilla Server_session: it ...">shm::classic::Session_server</a> (emitter of <code>*this</code> to user) first establishes a session with the <em>first</em> <a class="el" href="namespaceipc_1_1session_1_1shm_1_1classic.html#ac6c443a72e0f22710c83bb1e8c229618" title="This is to session::Client_session what shm::classic::Server_session is to session::Server_session.">shm::classic::Client_session</a> matching the same <a class="el" href="structipc_1_1session_1_1Client__app.html" title="An App that is used as a client in at least one client-server IPC split.">Client_app</a> as <code>*this</code>. I.e., it's created at the same time as <code>this-&gt;<a class="el" href="classipc_1_1session_1_1shm_1_1classic_1_1Session__mv.html#a9ff21b10fd753fccfa4882834e677ccf" title="Returns SHM Arena with per-session-scope, meaning it shall be accessible only during the lifetime of ...">session_shm()</a></code> is, if <code>*this</code> is the first such session; otherwise earlier. When <code>*this</code> is destroyed or hosed (gracefully at least), the arena is <em>not</em> invalidated but persists.</li>
</ul>
</li>
</ul>
<h3>Explicitly constructing an object in SHM; lending to opposing side</h3>
<p >This setup is symmetrical w/r/t a given <a class="el" href="classipc_1_1session_1_1shm_1_1classic_1_1Server__session.html" title="Identical to session::Server_session in every way, except that it makes available two SHM arenas,...">shm::classic::Server_session</a>&lt;-&gt;<a class="el" href="namespaceipc_1_1session_1_1shm_1_1classic.html#ac6c443a72e0f22710c83bb1e8c229618" title="This is to session::Client_session what shm::classic::Server_session is to session::Server_session.">shm::classic::Client_session</a> object pair. Both can create new objects (via respective <code>Arena::construct()</code> methods). Both can write and, of course, read. Lastly each can transmit any outer handle, returned by <code>construct()</code>, to the opposing side. To do this, call <a class="el" href="classipc_1_1session_1_1shm_1_1classic_1_1Session__mv.html#a794f83a8111428b3b1feec7216f692dd" title="Adds an owner process to the owner set of the given session_shm-&gt;construct()- or app_shm()-&gt;construct...">lend_object()</a>, transmit the returned <code>Blob</code> to the opposing side via any desired IPC form (probably a <a class="el" href="classipc_1_1transport_1_1Channel.html" title="Peer to a bundle of 1-2 full-duplex pipe(s), one for transmitting unstructured binary blobs; the othe...">transport::Channel</a> or <a class="el" href="classipc_1_1transport_1_1struc_1_1Channel.html" title="Owning and wrapping a pre-connected transport::Channel peer (an endpoint of an established channel ov...">transport::struc::Channel</a>), then recover a handle via <a class="el" href="classipc_1_1session_1_1shm_1_1classic_1_1Session__mv.html#a4223fc944735adb6946a9d1938d06a20" title="Completes the cross-process operation begun by oppsing Session_mv::lend_object() that returned serial...">borrow_object()</a> on that opposing side.</p>
<p >By using <code><a class="el" href="classipc_1_1shm_1_1stl_1_1Arena__activator.html" title="RAII-style class operating a stack-like notion of a the given thread&#39;s currently active SHM-aware Are...">shm::stl::Arena_activator</a>&lt;Arena&gt;</code> (alias <a class="el" href="namespaceipc_1_1shm_1_1classic.html#a82a112f42002eca08a819b9b00a71245" title="Convenience alias for a shm::stl::Arena_activator w/r/t Pool_arena.">shm::classic::Pool_arena_activator</a>) and <a class="el" href="classAllocator.html">Allocator</a> (alias <a class="el" href="namespaceipc_1_1shm_1_1classic.html#ae783c814337577d6e06a65e1b43de043" title="Convenience alias for a shm::stl::Stateless_allocator&gt; w/r/t Pool_arena; use with Pool_arena_activato...">shm::classic::Pool_arena_allocator</a>) it is possible to construct and transmit not just POD (Plain Old Datatype) objects but combinations of those with unlimited nested levels of STL-compliant containers. On the borrowing side use <a class="el" href="classipc_1_1session_1_1shm_1_1classic_1_1Session__mv.html#aecfab9c96933a832be7d2ad91be33532" title="Equals Allocator; provided for generic programming for algorithms that would use classic::Session_mv ...">Borrower_allocator</a> for maximum SHM-provider-independence of your code. (But see the following note: your algorithm may require features not available in the alternative, SHM-jemalloc, in which case... well, read the note.)</p>
<dl class="section note"><dt>Note</dt><dd>For SHM-classic, <a class="el" href="classipc_1_1session_1_1shm_1_1classic_1_1Session__mv.html#aecfab9c96933a832be7d2ad91be33532" title="Equals Allocator; provided for generic programming for algorithms that would use classic::Session_mv ...">Borrower_allocator</a> <em>is</em> <a class="el" href="classAllocator.html">Allocator</a>. If the borrowing side means to make changes to the data itself, it (stylistically speaking) can simply use <a class="el" href="classAllocator.html">Allocator</a> (and <code>Arena_activator&lt;Arena&gt;</code> again). However, if the borrowing side maintains read-only access throughout, then by using <a class="el" href="classipc_1_1session_1_1shm_1_1classic_1_1Session__mv.html#aecfab9c96933a832be7d2ad91be33532" title="Equals Allocator; provided for generic programming for algorithms that would use classic::Session_mv ...">Borrower_allocator</a> the code will remain SHM-provider-agnostic and continue working if the <a class="el" href="namespaceipc_1_1session.html" title="Flow-IPC module providing the broad lifecycle and shared-resource organization – via the session conc...">ipc::session</a> sub-namespace is changed back and forth betweeen <code>classic</code> and <code><a class="el" href="namespaceipc_1_1session_1_1shm_1_1arena__lend_1_1jemalloc.html" title="Support for SHM-backed ipc::session sessions and session-servers with the SHM-jemalloc (ipc::shm::are...">arena_lend::jemalloc</a></code>.</dd></dl>
<p>Detailed instructions can be found in those <a class="el" href="namespaceipc_1_1shm_1_1stl.html" title="ipc::shm sub-module providing integration between STL-compliant components (including containers) and...">shm::stl</a> and ipc::shm::arena_lend doc headers.</p>
<h3>Using SHM as backing memory for <a class="el" href="classipc_1_1transport_1_1struc_1_1Channel.html" title="Owning and wrapping a pre-connected transport::Channel peer (an endpoint of an established channel ov...">transport::struc::Channel</a></h3>
<p >Another use of <a class="el" href="classipc_1_1session_1_1shm_1_1classic_1_1Session__mv.html#a9ff21b10fd753fccfa4882834e677ccf" title="Returns SHM Arena with per-session-scope, meaning it shall be accessible only during the lifetime of ...">session_shm()</a> and <a class="el" href="classipc_1_1session_1_1shm_1_1classic_1_1Session__mv.html#ac6a4f1fbafb583f37d7586c6a199430f" title="Returns SHM Arena with per-app scope, meaning its pool shall be accessible potentially beyond the lif...">app_shm()</a> &ndash; in some ways perhaps superior &ndash; is indirect. The above technique involves manually constructing a C++ data structure and transmitting a short handle to it over IPC thus achieving high performance. It may be desirable, instead, to use a structured message, filled out according to schema. This, of course, is why <a class="el" href="classipc_1_1transport_1_1struc_1_1Channel.html" title="Owning and wrapping a pre-connected transport::Channel peer (an endpoint of an established channel ov...">transport::struc::Channel</a> exists. As is explained in its docs, there is nothing SHM-centered about it. It does however have the key feature that allows one to supply, at compile-time, the builder and reader engines that acquire memory while the user mutates an out-message and later accesses it upon IPC-receipt. Naturally one of the builder/reader pairs uses SHM, instead of regular heap, as the supplier of RAM. Thus when one invokes <a class="el" href="classipc_1_1transport_1_1struc_1_1Channel.html#ae645cb58ad9ea6374970f1f32c5da448" title="In the synchronous/non-blocking manner of Blob_sender::send_blob() or Native_handle_sender::send_nati...">transport::struc::Channel::send()</a> and receives it in the opposing object, the actual bits copied into/out of the low-level transport are merely the SHM handle (and all of this is hidden from the user outside of the delightful near-zero-copy perf properties).</p>
<p >There are two ways to make this happen. The easiest and best way is, when constructing the <code>struc::Channel</code>, to use the tag-form ctor with tag transport::struc::Channel_base::Serialize_via_shm_classic. Simply provide that tag, <code>this</code> (or, symmetrically, <code>shm::classic::Client_session::this</code> on the other side), and specify which of the 2 scopes you desire (per-session or per-app: a <code>bool</code>).</p>
<p >The harder way, albeit allowing for certain advanced setups, is to manually create a <code>transport::struc::shm::classic::Builder::Config</code> and/or <code>Reader::Config</code>, passing in <code>this-&gt;<a class="el" href="classipc_1_1session_1_1shm_1_1classic_1_1Session__mv.html#a9ff21b10fd753fccfa4882834e677ccf" title="Returns SHM Arena with per-session-scope, meaning it shall be accessible only during the lifetime of ...">session_shm()</a></code> and/or <code>this-&gt;<a class="el" href="classipc_1_1session_1_1shm_1_1classic_1_1Session__mv.html#ac6a4f1fbafb583f37d7586c6a199430f" title="Returns SHM Arena with per-app scope, meaning its pool shall be accessible potentially beyond the lif...">app_shm()</a></code>, to those; and then pass the <code>Config</code> or <code>Config</code>s to the non-tag-form of <code>struc::Channel</code> ctor.</p>
<p >This is all documented on <a class="el" href="classipc_1_1transport_1_1struc_1_1Channel.html" title="Owning and wrapping a pre-connected transport::Channel peer (an endpoint of an established channel ov...">transport::struc::Channel</a>. Do realize, though, that those niceties are really built on this class template and/or the opposing <a class="el" href="namespaceipc_1_1session_1_1shm_1_1classic.html#ac6c443a72e0f22710c83bb1e8c229618" title="This is to session::Client_session what shm::classic::Server_session is to session::Server_session.">shm::classic::Client_session</a>. To use them with <a class="el" href="namespaceipc_1_1session.html" title="Flow-IPC module providing the broad lifecycle and shared-resource organization – via the session conc...">ipc::session</a>, you must thus choose <a class="el" href="classipc_1_1session_1_1shm_1_1classic_1_1Server__session.html" title="Identical to session::Server_session in every way, except that it makes available two SHM arenas,...">shm::classic::Server_session</a> and <a class="el" href="namespaceipc_1_1session_1_1shm_1_1classic.html#ac6c443a72e0f22710c83bb1e8c229618" title="This is to session::Client_session what shm::classic::Server_session is to session::Server_session.">shm::classic::Client_session</a> as your <a class="el" href="classipc_1_1session_1_1Session.html" title="A documentation-only concept defining the local side of an IPC conversation (session) with another en...">Session</a> impls.</p>
<h3>Implementation</h3>
<p >It is probably not too difficult to understand how it works by just reading the code and doc headers. The key is that the core is still just what's supplied by a vanilla (non-SHM-aware) <a class="el" href="classipc_1_1session_1_1shm_1_1classic_1_1Server__session.html#a785acb973864773f6c9b2892af7e9474" title="For use by internal user Session_server_impl: constructor.">Server_session</a>. Ultimately all we need to add is a bit of setup near the end of the vanilla session-opening procedure. This is easiest to discuss holistically, meaning both the server (<code>*this</code>) and client (opposing) side, so the discussion is all here.</p>
<p >As with the vanilla session setup, remember that while in PEER state the APIs are identical/symmetrical, the roles of the server and client vary quite sharply internally &ndash; especially before PEER state. The general outline is: <a class="el" href="classipc_1_1session_1_1shm_1_1classic_1_1Session__server.html" title="This is to vanilla Session_server what shm::classic::Server_session is to vanilla Server_session: it ...">Session_server</a> listens for socket connections; a given <code><a class="el" href="classipc_1_1session_1_1Client__session__mv.html#ae0992c43ab3a978a1023d320d043d8de" title="To be invoked in NULL state only, and not as-if default-cted, it asynchronously attempts to connect t...">Client_session::async_connect()</a></code> connects; at this stage <a class="el" href="classipc_1_1session_1_1shm_1_1classic_1_1Session__server.html" title="This is to vanilla Session_server what shm::classic::Server_session is to vanilla Server_session: it ...">Session_server</a> constructs a not-yet-user-emitted <a class="el" href="classipc_1_1session_1_1shm_1_1classic_1_1Server__session.html#a785acb973864773f6c9b2892af7e9474" title="For use by internal user Session_server_impl: constructor.">Server_session</a> and invokes its <code>async_accept_log_in()</code>. Now the <a class="el" href="namespaceipc_1_1session_1_1shm_1_1classic.html#ac6c443a72e0f22710c83bb1e8c229618" title="This is to session::Client_session what shm::classic::Server_session is to session::Server_session.">Client_session</a> and <a class="el" href="classipc_1_1session_1_1shm_1_1classic_1_1Server__session.html#a785acb973864773f6c9b2892af7e9474" title="For use by internal user Session_server_impl: constructor.">Server_session</a> have established a channel (internal-use session master channel) and undergo the log-in exchange. <a class="el" href="namespaceipc_1_1session_1_1shm_1_1classic.html#ac6c443a72e0f22710c83bb1e8c229618" title="This is to session::Client_session what shm::classic::Server_session is to session::Server_session.">Client_session</a> sends log-in request. <a class="el" href="classipc_1_1session_1_1shm_1_1classic_1_1Server__session.html#a785acb973864773f6c9b2892af7e9474" title="For use by internal user Session_server_impl: constructor.">Server_session</a> verifies that, then replies with log-in response (including important bits of generated naming) and enters PEER state. Once <a class="el" href="namespaceipc_1_1session_1_1shm_1_1classic.html#ac6c443a72e0f22710c83bb1e8c229618" title="This is to session::Client_session what shm::classic::Server_session is to session::Server_session.">Client_session</a> (shortly) receives this response, it knows the session is ready to rock and also enters PEER state. Voila.</p>
<p >Where does SHM-classic setup hook into this? Fairly naturally: The server side is in charge of setting up shared resources &ndash; any required SHM arena(s) &ndash; and once they exist, and only then, can it send log-in response. The client side <em>then</em> opens them, since by then they're guaranteed to exist. In the case of these SHM-classic <code>Pool_arena</code>s, the way that part works is simple: the server side names each pool according to a certain convention, so the client (knowing that the timing is right) opens each pool according to the same convention (and the information received in the log-in response is part of that).</p>
<p >Thus:</p><ul>
<li>The additional (SHM-classic-related steps) take place during log-in over session master channel, no earlier.</li>
<li>The server, first (before log-in response but <em>after</em> it knows everything else about the budding session &ndash; so in fact <em>right</em> before sending log-in response), ensures the 2 SHM arenas (per-session and per-app) required to be shared have been created. Then it sends the log-in response like usual.</li>
<li>The client, like usual, awaits log-in response; and once that arrives it completes the normal vanilla entry to PEER state. However the additional step it needs is to open the 2 SHM areans guaranteed to exist, since log-in succeeded. Once it has done that, we're done.</li>
</ul>
<p >Now to discuss the specifics of each SHM scope. The simpler one is per-session (<a class="el" href="classipc_1_1session_1_1shm_1_1classic_1_1Session__mv.html#a9ff21b10fd753fccfa4882834e677ccf" title="Returns SHM Arena with per-session-scope, meaning it shall be accessible only during the lifetime of ...">session_shm()</a>). It is, naturally, created once for each session; so it has to be just before <a class="el" href="classipc_1_1session_1_1shm_1_1classic_1_1Server__session__impl.html" title="Core internally-used implementation of shm::classic::Server_session: it is to the latter what its pub...">Server_session_impl</a> <code>send()</code>s the log-in response. The naming is by the standard convention (see <a class="el" href="classipc_1_1util_1_1Shared__name.html" title="String-wrapping abstraction representing a name uniquely distinguishing a kernel-persistent entity fr...">util::Shared_name</a> doc header; see <a class="el" href="namespaceipc_1_1session.html#a365d2d63f77b738e67e206af6b702634" title="Builds an absolute name according to the path convention explained in Shared_name class doc header; t...">build_conventional_shared_name()</a> which applies the convention). <code>Pool_arena</code> constructed in <code>CREATE_ONLY</code> mode (1) creates underlying named pool; and (2) retains an open handle to it. So we just do that which gives us the thing to return in <a class="el" href="classipc_1_1session_1_1shm_1_1classic_1_1Session__mv.html#a9ff21b10fd753fccfa4882834e677ccf" title="Returns SHM Arena with per-session-scope, meaning it shall be accessible only during the lifetime of ...">session_shm()</a> from then on.</p>
<p >Slightly trickier is per-app (<a class="el" href="classipc_1_1session_1_1shm_1_1classic_1_1Session__mv.html#ac6a4f1fbafb583f37d7586c6a199430f" title="Returns SHM Arena with per-app scope, meaning its pool shall be accessible potentially beyond the lif...">app_shm()</a>). It is actually similar in terms of timing: it's done just then as well, because why not? However, for a given distinct <a class="el" href="structipc_1_1session_1_1Client__app.html" title="An App that is used as a client in at least one client-server IPC split.">Client_app</a>, pool has to be <em>created</em> only the first time <a class="el" href="classipc_1_1session_1_1shm_1_1classic_1_1Session__server.html" title="This is to vanilla Session_server what shm::classic::Server_session is to vanilla Server_session: it ...">Session_server</a> encounters an instance of the application described by that <a class="el" href="structipc_1_1session_1_1Client__app.html" title="An App that is used as a client in at least one client-server IPC split.">Client_app</a>; after that it's already created, so no creation is necessary. Either way, keep the handle around to return in <a class="el" href="classipc_1_1session_1_1shm_1_1classic_1_1Session__mv.html#ac6a4f1fbafb583f37d7586c6a199430f" title="Returns SHM Arena with per-app scope, meaning its pool shall be accessible potentially beyond the lif...">app_shm()</a>. However, by definition, a given per-app arena is to stay alive until the entire server (<a class="el" href="classipc_1_1session_1_1shm_1_1classic_1_1Session__server.html" title="This is to vanilla Session_server what shm::classic::Server_session is to vanilla Server_session: it ...">shm::classic::Session_server</a>) is destroyed; resources (including <a class="el" href="classipc_1_1transport_1_1struc_1_1Msg__out.html" title="A structured out-message suitable to be sent via struc::Channel::send().">transport::struc::Msg_out</a>) residing in an <a class="el" href="classipc_1_1session_1_1shm_1_1classic_1_1Session__mv.html#ac6a4f1fbafb583f37d7586c6a199430f" title="Returns SHM Arena with per-app scope, meaning its pool shall be accessible potentially beyond the lif...">app_shm()</a>-returned arena stay around potentially over 2+ sessions and can be shared via any of them (as long as they apply to the same <a class="el" href="structipc_1_1session_1_1Client__app.html" title="An App that is used as a client in at least one client-server IPC split.">Client_app</a>). Because of this more-than-session lifetime, the <a class="el" href="classipc_1_1session_1_1shm_1_1classic_1_1Session__mv.html#ac6a4f1fbafb583f37d7586c6a199430f" title="Returns SHM Arena with per-app scope, meaning its pool shall be accessible potentially beyond the lif...">app_shm()</a>-returned arenas are actually tracked in the parent <a class="el" href="classipc_1_1session_1_1shm_1_1classic_1_1Session__server.html" title="This is to vanilla Session_server what shm::classic::Server_session is to vanilla Server_session: it ...">shm::classic::Session_server</a>; it uses one of the <a class="el" href="classipc_1_1session_1_1Session__server__impl.html" title="Internal class template comprising API/logic common to every Session_server variant,...">Session_server_impl</a> customization points to create the per-Client_app arena as needed at just the right moment during the log-in process; then the <a class="el" href="classipc_1_1session_1_1shm_1_1classic_1_1Server__session__impl.html" title="Core internally-used implementation of shm::classic::Server_session: it is to the latter what its pub...">shm::classic::Server_session_impl</a> saves that pointer for quick return via <code>this-&gt;<a class="el" href="classipc_1_1session_1_1shm_1_1classic_1_1Session__mv.html#ac6a4f1fbafb583f37d7586c6a199430f" title="Returns SHM Arena with per-app scope, meaning its pool shall be accessible potentially beyond the lif...">app_shm()</a></code>. The same arena can also be accessed from the central store via <a class="el" href="classipc_1_1session_1_1shm_1_1classic_1_1Session__server.html#ae3e011716068f4e669bd7eed487cf207" title="Returns pointer to the per-app SHM-arena, whose lifetime extends until *this is destroyed; or null if...">shm::classic::Session_server::app_shm()</a> (which takes a <code>const <a class="el" href="structipc_1_1session_1_1Client__app.html" title="An App that is used as a client in at least one client-server IPC split.">Client_app</a>&amp;</code> and looks it up in an internal map).</p>
<p >Other than that, per-app-scope arenas are created and remembered similarly to per-session-scope ones: create (centrally across server-sessions, on-demand) in <code>CREATE_ONLY</code> mode; retain (in each relevant server-session) a pointer for return via <code>this-&gt;<a class="el" href="classipc_1_1session_1_1shm_1_1classic_1_1Session__mv.html#ac6a4f1fbafb583f37d7586c6a199430f" title="Returns SHM Arena with per-app scope, meaning its pool shall be accessible potentially beyond the lif...">app_shm()</a></code>. See <a class="el" href="classipc_1_1session_1_1shm_1_1classic_1_1Server__session__impl.html" title="Core internally-used implementation of shm::classic::Server_session: it is to the latter what its pub...">shm::classic::Server_session_impl</a> doc header and code inside <a class="el" href="classipc_1_1session_1_1shm_1_1classic_1_1Server__session__impl.html#a9c78b2c35b853e1702a06ec451545945" title="For use by internal user Session_server: See Server_session_mv counterpart.">shm::classic::Server_session_impl::async_accept_log_in()</a>.</p>
<p >So then to recap:</p><ul>
<li>Server: Open handle for <a class="el" href="classipc_1_1session_1_1shm_1_1classic_1_1Session__mv.html#a9ff21b10fd753fccfa4882834e677ccf" title="Returns SHM Arena with per-session-scope, meaning it shall be accessible only during the lifetime of ...">session_shm()</a> (create-only mode) and for <a class="el" href="classipc_1_1session_1_1shm_1_1classic_1_1Session__mv.html#ac6a4f1fbafb583f37d7586c6a199430f" title="Returns SHM Arena with per-app scope, meaning its pool shall be accessible potentially beyond the lif...">app_shm()</a> (same), just before send of log-in response, for each log-in. <a class="el" href="classipc_1_1session_1_1shm_1_1classic_1_1Session__mv.html#ac6a4f1fbafb583f37d7586c6a199430f" title="Returns SHM Arena with per-app scope, meaning its pool shall be accessible potentially beyond the lif...">app_shm()</a> is stored centrally in originating <a class="el" href="classipc_1_1session_1_1shm_1_1classic_1_1Session__server.html" title="This is to vanilla Session_server what shm::classic::Server_session is to vanilla Server_session: it ...">shm::classic::Session_server</a>. Insertion point: <em>during</em> vanilla opening procedure.<ul>
<li>Use <a class="el" href="classipc_1_1session_1_1shm_1_1classic_1_1Server__session__impl.html#a9c78b2c35b853e1702a06ec451545945" title="For use by internal user Session_server: See Server_session_mv counterpart.">Server_session_impl::async_accept_log_in()</a><code>'s</code>pre_rsp_setup_func()` arg for this purpose; in turn inside the body supplied for that guy <a class="el" href="classipc_1_1session_1_1shm_1_1classic_1_1Session__server.html" title="This is to vanilla Session_server what shm::classic::Server_session is to vanilla Server_session: it ...">shm::classic::Session_server</a> uses the <a class="el" href="classipc_1_1session_1_1Session__server__impl.html" title="Internal class template comprising API/logic common to every Session_server variant,...">Session_server_impl</a> ctor's <code>per_app_setup_func()</code> arg (customization point) for the centrally-performed <a class="el" href="classipc_1_1session_1_1shm_1_1classic_1_1Session__mv.html#ac6a4f1fbafb583f37d7586c6a199430f" title="Returns SHM Arena with per-app scope, meaning its pool shall be accessible potentially beyond the lif...">app_shm()</a> arena generation on-demand.</li>
</ul>
</li>
<li>Client: Open handle for <a class="el" href="classipc_1_1session_1_1shm_1_1classic_1_1Session__mv.html#a9ff21b10fd753fccfa4882834e677ccf" title="Returns SHM Arena with per-session-scope, meaning it shall be accessible only during the lifetime of ...">session_shm()</a> and <a class="el" href="classipc_1_1session_1_1shm_1_1classic_1_1Session__mv.html#ac6a4f1fbafb583f37d7586c6a199430f" title="Returns SHM Arena with per-app scope, meaning its pool shall be accessible potentially beyond the lif...">app_shm()</a> (open-only mode for each), just after fully completing the vanilla entry to PEER state (past log-in response receipt).<ul>
<li><a class="el" href="namespaceipc_1_1session_1_1shm_1_1classic.html#ac6c443a72e0f22710c83bb1e8c229618" title="This is to session::Client_session what shm::classic::Server_session is to session::Server_session.">shm::classic::Client_session</a> just wraps <code>async_connect()</code> by tacking on the pool-openings (which are synchronous) onto its user-supplied on-done handler. Mechanically: Details left to <a class="el" href="namespaceipc_1_1session_1_1shm_1_1classic.html#ac6c443a72e0f22710c83bb1e8c229618" title="This is to session::Client_session what shm::classic::Server_session is to session::Server_session.">shm::classic::Client_session</a> docs.</li>
</ul>
</li>
</ul>
<p >In <code>*this</code>, mechanically: the true implementation of the needed setup and accessors (explained above) is split between <a class="el" href="classipc_1_1session_1_1shm_1_1classic_1_1Session__mv.html" title="Implements the SHM-related API common to shm::classic::Server_session and shm::classic::Client_sessio...">shm::classic::Session_mv</a> (common with <code><a class="el" href="classipc_1_1session_1_1shm_1_1classic_1_1Client__session__impl.html" title="Core internally-used implementation of shm::classic::Client_session: it is to the latter what its pub...">Client_session_impl</a></code>) and <a class="el" href="classipc_1_1session_1_1shm_1_1classic_1_1Server__session__impl.html" title="Core internally-used implementation of shm::classic::Server_session: it is to the latter what its pub...">shm::classic::Server_session_impl</a>, with the vanilla core in super-class <a class="el" href="classipc_1_1session_1_1Server__session__impl.html" title="Internal, non-movable pImpl-lite implementation of Server_session_mv class template.">session::Server_session_impl</a>. There's an app-scope snippet in <a class="el" href="classipc_1_1session_1_1shm_1_1classic_1_1Session__server.html" title="This is to vanilla Session_server what shm::classic::Server_session is to vanilla Server_session: it ...">shm::classic::Session_server</a>.</p>
<p >That's the key; then <a class="el" href="classipc_1_1session_1_1Server__session__mv.html" title="Implements Session concept on the Server_app end: a Session that is emitted in almost-PEER state by l...">session::Server_session_mv</a> adds movability around <a class="el" href="classipc_1_1session_1_1Server__session__impl.html" title="Internal, non-movable pImpl-lite implementation of Server_session_mv class template.">session::Server_session_impl</a>; and lastly this class sub-classes <em>that</em> (by way of <code><a class="el" href="classipc_1_1session_1_1shm_1_1classic_1_1Session__mv.html" title="Implements the SHM-related API common to shm::classic::Server_session and shm::classic::Client_sessio...">Session_mv</a></code>) and completes the puzzle by pImpl-forwarding to the added (SHM-focused) API. (<a class="el" href="classipc_1_1session_1_1Server__session__mv.html" title="Implements Session concept on the Server_app end: a Session that is emitted in almost-PEER state by l...">session::Server_session_mv</a> only pImpl-forwards to the vanilla API.)</p>
<p >The last and most boring piece of the puzzle are the pImpl-lite wrappers around the SHM-specific API that <a class="el" href="classipc_1_1session_1_1shm_1_1classic_1_1Server__session.html" title="Identical to session::Server_session in every way, except that it makes available two SHM arenas,...">shm::classic::Server_session</a> adds to super-class <a class="el" href="classipc_1_1session_1_1shm_1_1classic_1_1Server__session__mv.html">Server_session_mv</a>: <code><a class="el" href="classipc_1_1session_1_1shm_1_1classic_1_1Session__mv.html#a9ff21b10fd753fccfa4882834e677ccf" title="Returns SHM Arena with per-session-scope, meaning it shall be accessible only during the lifetime of ...">session_shm()</a></code> and so on. Because this API is exactly identical for both <a class="el" href="classipc_1_1session_1_1shm_1_1classic_1_1Server__session.html" title="Identical to session::Server_session in every way, except that it makes available two SHM arenas,...">shm::classic::Server_session</a> and <a class="el" href="namespaceipc_1_1session_1_1shm_1_1classic.html#ac6c443a72e0f22710c83bb1e8c229618" title="This is to session::Client_session what shm::classic::Server_session is to session::Server_session.">shm::classic::Client_session</a>, to avoid torturous copy/pasting these wrappers are collected in <a class="el" href="classipc_1_1session_1_1shm_1_1classic_1_1Session__mv.html" title="Implements the SHM-related API common to shm::classic::Server_session and shm::classic::Client_sessio...">shm::classic::Session_mv</a> which we sub-class. So the <code>public</code> API is distributed as follows from bottom to top:</p><ul>
<li><a class="el" href="classipc_1_1session_1_1shm_1_1classic_1_1Server__session.html" title="Identical to session::Server_session in every way, except that it makes available two SHM arenas,...">shm::classic::Server_session</a> =&gt; <a class="el" href="classipc_1_1session_1_1shm_1_1classic_1_1Session__mv.html" title="Implements the SHM-related API common to shm::classic::Server_session and shm::classic::Client_sessio...">shm::classic::Session_mv</a> =&gt; <a class="el" href="classipc_1_1session_1_1Server__session__mv.html" title="Implements Session concept on the Server_app end: a Session that is emitted in almost-PEER state by l...">session::Server_session_mv</a> =&gt; <a class="el" href="classipc_1_1session_1_1Session__mv.html" title="Implements the Session concept when it is in PEER state.">session::Session_mv</a> =&gt; <a class="el" href="classipc_1_1session_1_1shm_1_1classic_1_1Server__session__impl.html" title="Core internally-used implementation of shm::classic::Server_session: it is to the latter what its pub...">shm::classic::Server_session_impl</a></li>
<li><a class="el" href="namespaceipc_1_1session_1_1shm_1_1classic.html#ac6c443a72e0f22710c83bb1e8c229618" title="This is to session::Client_session what shm::classic::Server_session is to session::Server_session.">shm::classic::Client_session</a> == <a class="el" href="classipc_1_1session_1_1shm_1_1classic_1_1Session__mv.html" title="Implements the SHM-related API common to shm::classic::Server_session and shm::classic::Client_sessio...">shm::classic::Session_mv</a> =&gt; <a class="el" href="classipc_1_1session_1_1Client__session__mv.html" title="Implements Session concept on the Client_app end: a Session_mv that first achieves PEER state by conn...">session::Client_session_mv</a> =&gt; <a class="el" href="classipc_1_1session_1_1Session__mv.html" title="Implements the Session concept when it is in PEER state.">session::Session_mv</a> =&gt; <a class="el" href="classipc_1_1session_1_1shm_1_1classic_1_1Client__session__impl.html" title="Core internally-used implementation of shm::classic::Client_session: it is to the latter what its pub...">shm::classic::Client_session_impl</a><ul>
<li>The bottom two in this case are not even inherited but one aliases to the other. This is because there's nothing added API-wise on the client side. On the server side, as you see below, an internal-use ctor is necessary to add, so we can't alias and must sub-class. It's close to an alias though.</li>
</ul>
</li>
</ul>
<p >You'll notice, like, <code><a class="el" href="classipc_1_1session_1_1Session__mv.html#af2c186e7b4be09bff30b42aa2482dd93" title="Short-hand for pImpl-lite impl type. This shall be the deepest impl sub-class desired.">Base::Base::Base::Impl</a></code> and <code><a class="el" href="classipc_1_1session_1_1Session__mv.html#af2c186e7b4be09bff30b42aa2482dd93" title="Short-hand for pImpl-lite impl type. This shall be the deepest impl sub-class desired.">Base::Base::Base::Impl()</a></code> in certain code below; that's navigating the above hierarchy.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">S_MQ_TYPE_OR_NONE</td><td>Identical to <a class="el" href="namespaceipc_1_1session.html#ab01d5bce0ab2f3435ca9dd88d27609dc" title="A vanilla Server_session with no optional capabilities.">session::Server_session</a>. </td></tr>
    <tr><td class="paramname">S_TRANSMIT_NATIVE_HANDLES</td><td>Identical to <a class="el" href="namespaceipc_1_1session.html#ab01d5bce0ab2f3435ca9dd88d27609dc" title="A vanilla Server_session with no optional capabilities.">session::Server_session</a>. </td></tr>
    <tr><td class="paramname">Mdt_payload</td><td>Identical to <a class="el" href="namespaceipc_1_1session.html#ab01d5bce0ab2f3435ca9dd88d27609dc" title="A vanilla Server_session with no optional capabilities.">session::Server_session</a>. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="ipc__shm_2src_2ipc_2session_2shm_2classic_2server__session_8hpp_source.html#l00215">215</a> of file <a class="el" href="ipc__shm_2src_2ipc_2session_2shm_2classic_2server__session_8hpp_source.html">server_session.hpp</a>.</p>
</div><h2 class="groupheader">Member Typedef Documentation</h2>
<a id="a1507bab4b191f908e9c45470fdb8d296" name="a1507bab4b191f908e9c45470fdb8d296"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1507bab4b191f908e9c45470fdb8d296">&#9670;&nbsp;</a></span>Base <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;schema::MqType S_MQ_TYPE_OR_NONE, bool S_TRANSMIT_NATIVE_HANDLES, typename Mdt_payload &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classipc_1_1session_1_1shm_1_1classic_1_1Server__session.html">ipc::session::shm::classic::Server_session</a>&lt; S_MQ_TYPE_OR_NONE, S_TRANSMIT_NATIVE_HANDLES, Mdt_payload &gt;::Base =  <a class="el" href="classipc_1_1session_1_1shm_1_1classic_1_1Session__mv.html">Session_mv</a> &lt;<a class="el" href="classipc_1_1session_1_1Server__session__mv.html">session::Server_session_mv</a> &lt;<a class="el" href="classipc_1_1session_1_1shm_1_1classic_1_1Server__session__impl.html">Server_session_impl</a>&lt;S_MQ_TYPE_OR_NONE, S_TRANSMIT_NATIVE_HANDLES, Mdt_payload&gt; &gt;&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Short-hand for our base class. To the user: note its <code>public</code> API is inherited. </p>

<p class="definition">Definition at line <a class="el" href="ipc__shm_2src_2ipc_2session_2shm_2classic_2server__session_8hpp_source.html#l00223">223</a> of file <a class="el" href="ipc__shm_2src_2ipc_2session_2shm_2classic_2server__session_8hpp_source.html">server_session.hpp</a>.</p>

</div>
</div>
<a id="ac11498f4b8a526f2525de8e3d2dcf08c" name="ac11498f4b8a526f2525de8e3d2dcf08c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac11498f4b8a526f2525de8e3d2dcf08c">&#9670;&nbsp;</a></span>Base <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;schema::MqType S_MQ_TYPE_OR_NONE, bool S_TRANSMIT_NATIVE_HANDLES, typename Mdt_payload &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classipc_1_1session_1_1shm_1_1classic_1_1Session__mv.html">ipc::session::shm::classic::Session_mv</a>&lt; <a class="el" href="classSession__t.html">Session_t</a> &gt;::Base =  <a class="el" href="classSession__t.html">Session_t</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Inherit default, move ctors. </p>

<p class="definition">Definition at line <a class="el" href="ipc__shm_2src_2ipc_2session_2shm_2classic_2session_8hpp_source.html#l00049">49</a> of file <a class="el" href="ipc__shm_2src_2ipc_2session_2shm_2classic_2session_8hpp_source.html">session.hpp</a>.</p>

</div>
</div>
<h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="a785acb973864773f6c9b2892af7e9474" name="a785acb973864773f6c9b2892af7e9474"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a785acb973864773f6c9b2892af7e9474">&#9670;&nbsp;</a></span>Server_session()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;schema::MqType S_MQ_TYPE_OR_NONE, bool S_TRANSMIT_NATIVE_HANDLES, typename Mdt_payload &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classipc_1_1session_1_1shm_1_1classic_1_1Server__session.html">ipc::session::shm::classic::Server_session</a>&lt; S_MQ_TYPE_OR_NONE, S_TRANSMIT_NATIVE_HANDLES, Mdt_payload &gt;::Server_session </td>
          <td>(</td>
          <td class="paramtype">flow::log::Logger *&#160;</td>
          <td class="paramname"><em>logger_ptr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structipc_1_1session_1_1Server__app.html">Server_app</a> &amp;&#160;</td>
          <td class="paramname"><em>srv_app_ref</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classipc_1_1transport_1_1Native__socket__stream.html">transport::Native_socket_stream</a> &amp;&amp;&#160;</td>
          <td class="paramname"><em>master_channel_sock_stm</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">explicit</span><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>For use by internal user <a class="el" href="classipc_1_1session_1_1Session__server__impl.html" title="Internal class template comprising API/logic common to every Session_server variant,...">Session_server_impl</a>: constructor. </p>
<p >Identical to <a class="el" href="classipc_1_1session_1_1shm_1_1classic_1_1Server__session__mv.html">Server_session_mv</a> ctor.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">logger_ptr</td><td>See <a class="el" href="classipc_1_1session_1_1shm_1_1classic_1_1Server__session__mv.html">Server_session_mv</a> ctor. </td></tr>
    <tr><td class="paramname">srv_app_ref</td><td>See <a class="el" href="classipc_1_1session_1_1shm_1_1classic_1_1Server__session__mv.html">Server_session_mv</a> ctor. </td></tr>
    <tr><td class="paramname">master_channel_sock_stm</td><td>See <a class="el" href="classipc_1_1session_1_1shm_1_1classic_1_1Server__session__mv.html">Server_session_mv</a> ctor. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="ipc__shm_2src_2ipc_2session_2shm_2classic_2server__session_8hpp_source.html#l00261">261</a> of file <a class="el" href="ipc__shm_2src_2ipc_2session_2shm_2classic_2server__session_8hpp_source.html">server_session.hpp</a>.</p>

</div>
</div>
<h2 class="groupheader">Friends And Related Function Documentation</h2>
<a id="a8fc81db9a5adc7b6efc8529b5f1d98d2" name="a8fc81db9a5adc7b6efc8529b5f1d98d2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8fc81db9a5adc7b6efc8529b5f1d98d2">&#9670;&nbsp;</a></span>operator&lt;&lt;()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;schema::MqType S_MQ_TYPE_OR_NONE, bool S_TRANSMIT_NATIVE_HANDLES, typename Mdt_payload &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::ostream &amp; operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>os</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classipc_1_1session_1_1shm_1_1classic_1_1Server__session.html">Server_session</a>&lt; S_MQ_TYPE_OR_NONE, S_TRANSMIT_NATIVE_HANDLES, Mdt_payload &gt; &amp;&#160;</td>
          <td class="paramname"><em>val</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Prints string representation of the given <code><a class="el" href="classipc_1_1session_1_1shm_1_1classic_1_1Server__session.html" title="Identical to session::Server_session in every way, except that it makes available two SHM arenas,...">Server_session</a></code> to the given <code>ostream</code>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">os</td><td>Stream to which to write. </td></tr>
    <tr><td class="paramname">val</td><td>Object to serialize. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>os</code>. </dd></dl>

<p class="definition">Definition at line <a class="el" href="ipc__shm_2src_2ipc_2session_2shm_2classic_2server__session_8hpp_source.html#l00269">269</a> of file <a class="el" href="ipc__shm_2src_2ipc_2session_2shm_2classic_2server__session_8hpp_source.html">server_session.hpp</a>.</p>

</div>
</div>
<hr/>The documentation for this class was generated from the following files:<ul>
<li>session/shm/classic/<a class="el" href="session_2shm_2classic_2classic__fwd_8hpp_source.html">classic_fwd.hpp</a></li>
<li>session/shm/classic/<a class="el" href="ipc__shm_2src_2ipc_2session_2shm_2classic_2server__session_8hpp_source.html">server_session.hpp</a></li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Thu Feb 8 2024 21:52:50 for Flow-IPC by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.4
</small></address>
</body>
</html>
