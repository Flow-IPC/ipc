<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.9.4"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Flow-IPC: ipc::transport::sync_io::Blob_stream_mq_receiver_impl&lt; Persistent_mq_handle &gt; Class Template Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">Flow-IPC<span id="projectnumber">&#160;1.0.0</span>
   </div>
   <div id="projectbrief">Flow-IPC project: Full implementation reference.</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.4 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search",'Search','.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespaceipc.html">ipc</a></li><li class="navelem"><a class="el" href="namespaceipc_1_1transport.html">transport</a></li><li class="navelem"><a class="el" href="namespaceipc_1_1transport_1_1sync__io.html">sync_io</a></li><li class="navelem"><a class="el" href="classipc_1_1transport_1_1sync__io_1_1Blob__stream__mq__receiver__impl.html">Blob_stream_mq_receiver_impl</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#pub-types">Public Types</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pri-types">Private Types</a> &#124;
<a href="#pri-methods">Private Member Functions</a> &#124;
<a href="#pri-attribs">Private Attributes</a> &#124;
<a href="#related">Related Functions</a> &#124;
<a href="classipc_1_1transport_1_1sync__io_1_1Blob__stream__mq__receiver__impl-members.html">List of all members</a>  </div>
  <div class="headertitle"><div class="title">ipc::transport::sync_io::Blob_stream_mq_receiver_impl&lt; Persistent_mq_handle &gt; Class Template Reference</div></div>
</div><!--header-->
<div class="contents">

<p>Internal, non-movable pImpl-lite implementation of <a class="el" href="classipc_1_1transport_1_1sync__io_1_1Blob__stream__mq__receiver.html" title="Implements sync_io::Blob_receiver concept by using an adopted Persistent_mq_handle MQ handle to an MQ...">sync_io::Blob_stream_mq_receiver</a> class template.  
 <a href="classipc_1_1transport_1_1sync__io_1_1Blob__stream__mq__receiver__impl.html#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="sync__io_2detail_2blob__stream__mq__rcv__impl_8hpp_source.html">blob_stream_mq_rcv_impl.hpp</a>&gt;</code></p>
<div class="dynheader">
Inheritance diagram for ipc::transport::sync_io::Blob_stream_mq_receiver_impl&lt; Persistent_mq_handle &gt;:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="classipc_1_1transport_1_1sync__io_1_1Blob__stream__mq__receiver__impl__inherit__graph.svg" width="418" height="155"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe>
</div>
<center><span class="legend">[<a href="graph_legend.html">legend</a>]</span></center></div>
<div class="dynheader">
Collaboration diagram for ipc::transport::sync_io::Blob_stream_mq_receiver_impl&lt; Persistent_mq_handle &gt;:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="classipc_1_1transport_1_1sync__io_1_1Blob__stream__mq__receiver__impl__coll__graph.svg" width="1192" height="1707"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe>
</div>
<center><span class="legend">[<a href="graph_legend.html">legend</a>]</span></center></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="nested-classes" name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structipc_1_1transport_1_1sync__io_1_1Blob__stream__mq__receiver__impl_1_1User__request.html">User_request</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Identical to <a class="el" href="structipc_1_1transport_1_1sync__io_1_1Async__adapter__receiver_1_1User__request.html" title="Data store representing a deficit user async-receive request: either one being currently handled by m...">sync_io::Async_adapter_receiver::User_request</a>, except we only keep at most 1 of these and thus don't need a <code>Ptr</code> alias inside; and we need not worry about transmitting <code>Native_handle</code>s.  <a href="structipc_1_1transport_1_1sync__io_1_1Blob__stream__mq__receiver__impl_1_1User__request.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-types" name="pub-types"></a>
Public Types</h2></td></tr>
<tr class="memitem:ac3d293643835e752560de34116554624"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classipc_1_1transport_1_1sync__io_1_1Blob__stream__mq__receiver__impl.html#ac3d293643835e752560de34116554624">Base</a> = <a class="el" href="classipc_1_1transport_1_1Blob__stream__mq__base__impl.html">Blob_stream_mq_base_impl</a>&lt; <a class="el" href="classipc_1_1transport_1_1Persistent__mq__handle.html">Persistent_mq_handle</a> &gt;</td></tr>
<tr class="memdesc:ac3d293643835e752560de34116554624"><td class="mdescLeft">&#160;</td><td class="mdescRight">Short-hand for our base with <code>static</code> goodies at least.  <a href="classipc_1_1transport_1_1sync__io_1_1Blob__stream__mq__receiver__impl.html#ac3d293643835e752560de34116554624">More...</a><br /></td></tr>
<tr class="separator:ac3d293643835e752560de34116554624"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a465dcd2a80871028ba8a97402be1cf2a"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classipc_1_1transport_1_1sync__io_1_1Blob__stream__mq__receiver__impl.html#a465dcd2a80871028ba8a97402be1cf2a">Mq</a> = typename <a class="el" href="classipc_1_1transport_1_1Blob__stream__mq__base__impl.html#a8fac0ed5fff23aa42e0a601db6fee42d">Base::Mq</a></td></tr>
<tr class="memdesc:a465dcd2a80871028ba8a97402be1cf2a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Short-hand for template arg for underlying MQ handle type.  <a href="classipc_1_1transport_1_1sync__io_1_1Blob__stream__mq__receiver__impl.html#a465dcd2a80871028ba8a97402be1cf2a">More...</a><br /></td></tr>
<tr class="separator:a465dcd2a80871028ba8a97402be1cf2a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pub_types_classipc_1_1transport_1_1Blob__stream__mq__base__impl"><td colspan="2" onclick="javascript:toggleInherit('pub_types_classipc_1_1transport_1_1Blob__stream__mq__base__impl')"><img src="closed.png" alt="-"/>&#160;Public Types inherited from <a class="el" href="classipc_1_1transport_1_1Blob__stream__mq__base__impl.html">ipc::transport::Blob_stream_mq_base_impl&lt; Persistent_mq_handle &gt;</a></td></tr>
<tr class="memitem:a8fac0ed5fff23aa42e0a601db6fee42d inherit pub_types_classipc_1_1transport_1_1Blob__stream__mq__base__impl"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classipc_1_1transport_1_1Blob__stream__mq__base__impl.html#a8fac0ed5fff23aa42e0a601db6fee42d">Mq</a> = <a class="el" href="classipc_1_1transport_1_1Persistent__mq__handle.html">Persistent_mq_handle</a></td></tr>
<tr class="memdesc:a8fac0ed5fff23aa42e0a601db6fee42d inherit pub_types_classipc_1_1transport_1_1Blob__stream__mq__base__impl"><td class="mdescLeft">&#160;</td><td class="mdescRight">Short-hand for template arg for underlying MQ handle type.  <a href="classipc_1_1transport_1_1Blob__stream__mq__base__impl.html#a8fac0ed5fff23aa42e0a601db6fee42d">More...</a><br /></td></tr>
<tr class="separator:a8fac0ed5fff23aa42e0a601db6fee42d inherit pub_types_classipc_1_1transport_1_1Blob__stream__mq__base__impl"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aab7c4c91d42c746c93e61eb367572eb1 inherit pub_types_classipc_1_1transport_1_1Blob__stream__mq__base__impl"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classipc_1_1transport_1_1Blob__stream__mq__base__impl.html#aab7c4c91d42c746c93e61eb367572eb1">Auto_closing_mq</a> = boost::movelib::unique_ptr&lt; <a class="el" href="classipc_1_1transport_1_1Blob__stream__mq__base__impl.html#a8fac0ed5fff23aa42e0a601db6fee42d">Mq</a>, <a class="el" href="namespaceipc.html#aa455c7f045059736578ca275fc1a851f">Function</a>&lt; void(<a class="el" href="classipc_1_1transport_1_1Blob__stream__mq__base__impl.html#a8fac0ed5fff23aa42e0a601db6fee42d">Mq</a> *)&gt; &gt;</td></tr>
<tr class="memdesc:aab7c4c91d42c746c93e61eb367572eb1 inherit pub_types_classipc_1_1transport_1_1Blob__stream__mq__base__impl"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classipc_1_1transport_1_1Persistent__mq__handle.html" title="A documentation-only concept defining the behavior of an object representing a light-weight handle to...">Persistent_mq_handle</a> holder that takes a deleter lambda on construction, intended here to perform additional deinit steps in addition to closing the <a class="el" href="classipc_1_1transport_1_1Blob__stream__mq__base__impl.html#a8fac0ed5fff23aa42e0a601db6fee42d" title="Short-hand for template arg for underlying MQ handle type.">Mq</a> by deleting it.  <a href="classipc_1_1transport_1_1Blob__stream__mq__base__impl.html#aab7c4c91d42c746c93e61eb367572eb1">More...</a><br /></td></tr>
<tr class="separator:aab7c4c91d42c746c93e61eb367572eb1 inherit pub_types_classipc_1_1transport_1_1Blob__stream__mq__base__impl"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-methods" name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a3e1c13dc986985621ab05de16f9e811c"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classipc_1_1transport_1_1sync__io_1_1Blob__stream__mq__receiver__impl.html#a3e1c13dc986985621ab05de16f9e811c">Blob_stream_mq_receiver_impl</a> (flow::log::Logger *logger_ptr, <a class="el" href="namespaceipc_1_1util.html#ae6ac47812a90d1287c61e0b7de7bc4f5">util::String_view</a> nickname_str, <a class="el" href="classipc_1_1transport_1_1Blob__stream__mq__base__impl.html#a8fac0ed5fff23aa42e0a601db6fee42d">Mq</a> &amp;&amp;mq_moved, <a class="el" href="namespaceipc.html#aa3192e586cc45d3e7c22463bf2760f89">Error_code</a> *err_code)</td></tr>
<tr class="memdesc:a3e1c13dc986985621ab05de16f9e811c"><td class="mdescLeft">&#160;</td><td class="mdescRight">See <a class="el" href="classipc_1_1transport_1_1sync__io_1_1Blob__stream__mq__receiver.html" title="Implements sync_io::Blob_receiver concept by using an adopted Persistent_mq_handle MQ handle to an MQ...">Blob_stream_mq_receiver</a> counterpart.  <a href="classipc_1_1transport_1_1sync__io_1_1Blob__stream__mq__receiver__impl.html#a3e1c13dc986985621ab05de16f9e811c">More...</a><br /></td></tr>
<tr class="separator:a3e1c13dc986985621ab05de16f9e811c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a08712e065d9a6778a0bb18de94009f22"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classipc_1_1transport_1_1sync__io_1_1Blob__stream__mq__receiver__impl.html#a08712e065d9a6778a0bb18de94009f22">~Blob_stream_mq_receiver_impl</a> ()</td></tr>
<tr class="memdesc:a08712e065d9a6778a0bb18de94009f22"><td class="mdescLeft">&#160;</td><td class="mdescRight">See <a class="el" href="classipc_1_1transport_1_1sync__io_1_1Blob__stream__mq__receiver.html" title="Implements sync_io::Blob_receiver concept by using an adopted Persistent_mq_handle MQ handle to an MQ...">Blob_stream_mq_receiver</a> counterpart.  <a href="classipc_1_1transport_1_1sync__io_1_1Blob__stream__mq__receiver__impl.html#a08712e065d9a6778a0bb18de94009f22">More...</a><br /></td></tr>
<tr class="separator:a08712e065d9a6778a0bb18de94009f22"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3ee71a39a443e78c86f82652d8d0601e"><td class="memTemplParams" colspan="2">template&lt;typename Create_ev_wait_hndl_func &gt; </td></tr>
<tr class="memitem:a3ee71a39a443e78c86f82652d8d0601e"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classipc_1_1transport_1_1sync__io_1_1Blob__stream__mq__receiver__impl.html#a3ee71a39a443e78c86f82652d8d0601e">replace_event_wait_handles</a> (const Create_ev_wait_hndl_func &amp;create_ev_wait_hndl_func)</td></tr>
<tr class="memdesc:a3ee71a39a443e78c86f82652d8d0601e"><td class="mdescLeft">&#160;</td><td class="mdescRight">See <a class="el" href="classipc_1_1transport_1_1sync__io_1_1Blob__stream__mq__receiver.html" title="Implements sync_io::Blob_receiver concept by using an adopted Persistent_mq_handle MQ handle to an MQ...">Blob_stream_mq_receiver</a> counterpart.  <a href="classipc_1_1transport_1_1sync__io_1_1Blob__stream__mq__receiver__impl.html#a3ee71a39a443e78c86f82652d8d0601e">More...</a><br /></td></tr>
<tr class="separator:a3ee71a39a443e78c86f82652d8d0601e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8df5929fc0f3413079df8e2be08bf972"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classipc_1_1transport_1_1sync__io_1_1Blob__stream__mq__receiver__impl.html#a8df5929fc0f3413079df8e2be08bf972">receive_blob_max_size</a> () const</td></tr>
<tr class="memdesc:a8df5929fc0f3413079df8e2be08bf972"><td class="mdescLeft">&#160;</td><td class="mdescRight">See <a class="el" href="classipc_1_1transport_1_1sync__io_1_1Blob__stream__mq__receiver.html" title="Implements sync_io::Blob_receiver concept by using an adopted Persistent_mq_handle MQ handle to an MQ...">Blob_stream_mq_receiver</a> counterpart, but assuming PEER state.  <a href="classipc_1_1transport_1_1sync__io_1_1Blob__stream__mq__receiver__impl.html#a8df5929fc0f3413079df8e2be08bf972">More...</a><br /></td></tr>
<tr class="separator:a8df5929fc0f3413079df8e2be08bf972"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1e286f452b6e3a74d64e1f795795afe2"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classipc_1_1transport_1_1sync__io_1_1Blob__stream__mq__receiver__impl.html#a1e286f452b6e3a74d64e1f795795afe2">start_receive_blob_ops</a> (<a class="el" href="namespaceipc_1_1util_1_1sync__io.html#aa0b9a3cc6bdc7dedbef4f9e06851aa24">util::sync_io::Event_wait_func</a> &amp;&amp;ev_wait_func)</td></tr>
<tr class="memdesc:a1e286f452b6e3a74d64e1f795795afe2"><td class="mdescLeft">&#160;</td><td class="mdescRight">See <a class="el" href="classipc_1_1transport_1_1sync__io_1_1Blob__stream__mq__receiver.html" title="Implements sync_io::Blob_receiver concept by using an adopted Persistent_mq_handle MQ handle to an MQ...">Blob_stream_mq_receiver</a> counterpart.  <a href="classipc_1_1transport_1_1sync__io_1_1Blob__stream__mq__receiver__impl.html#a1e286f452b6e3a74d64e1f795795afe2">More...</a><br /></td></tr>
<tr class="separator:a1e286f452b6e3a74d64e1f795795afe2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8d1a81d379e1a31031adb9cccbbabd35"><td class="memTemplParams" colspan="2">template&lt;typename Task_err_sz &gt; </td></tr>
<tr class="memitem:a8d1a81d379e1a31031adb9cccbbabd35"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classipc_1_1transport_1_1sync__io_1_1Blob__stream__mq__receiver__impl.html#a8d1a81d379e1a31031adb9cccbbabd35">async_receive_blob</a> (const <a class="el" href="namespaceipc_1_1util.html#a6cb62ae434900f3a8915b33ec5d61a96">util::Blob_mutable</a> &amp;target_blob, <a class="el" href="namespaceipc.html#aa3192e586cc45d3e7c22463bf2760f89">Error_code</a> *sync_err_code, size_t *sync_sz, Task_err_sz &amp;&amp;on_done_func)</td></tr>
<tr class="memdesc:a8d1a81d379e1a31031adb9cccbbabd35"><td class="mdescLeft">&#160;</td><td class="mdescRight">See <a class="el" href="classipc_1_1transport_1_1sync__io_1_1Blob__stream__mq__receiver.html" title="Implements sync_io::Blob_receiver concept by using an adopted Persistent_mq_handle MQ handle to an MQ...">Blob_stream_mq_receiver</a> counterpart, but assuming PEER state.  <a href="classipc_1_1transport_1_1sync__io_1_1Blob__stream__mq__receiver__impl.html#a8d1a81d379e1a31031adb9cccbbabd35">More...</a><br /></td></tr>
<tr class="separator:a8d1a81d379e1a31031adb9cccbbabd35"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a878fa03873bcdea5aa9d938a4791325f"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classipc_1_1transport_1_1sync__io_1_1Blob__stream__mq__receiver__impl.html#a878fa03873bcdea5aa9d938a4791325f">idle_timer_run</a> (<a class="el" href="namespaceipc_1_1util.html#ac66141280c3b7295a86b65209f31cc58">util::Fine_duration</a> timeout)</td></tr>
<tr class="memdesc:a878fa03873bcdea5aa9d938a4791325f"><td class="mdescLeft">&#160;</td><td class="mdescRight">See <a class="el" href="classipc_1_1transport_1_1sync__io_1_1Blob__stream__mq__receiver.html" title="Implements sync_io::Blob_receiver concept by using an adopted Persistent_mq_handle MQ handle to an MQ...">Blob_stream_mq_receiver</a> counterpart, but assuming PEER state.  <a href="classipc_1_1transport_1_1sync__io_1_1Blob__stream__mq__receiver__impl.html#a878fa03873bcdea5aa9d938a4791325f">More...</a><br /></td></tr>
<tr class="separator:a878fa03873bcdea5aa9d938a4791325f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adaf3579ec3abf0b5d85258965d264660"><td class="memItemLeft" align="right" valign="top">const std::string &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classipc_1_1transport_1_1sync__io_1_1Blob__stream__mq__receiver__impl.html#adaf3579ec3abf0b5d85258965d264660">nickname</a> () const</td></tr>
<tr class="memdesc:adaf3579ec3abf0b5d85258965d264660"><td class="mdescLeft">&#160;</td><td class="mdescRight">See <a class="el" href="classipc_1_1transport_1_1sync__io_1_1Blob__stream__mq__receiver.html" title="Implements sync_io::Blob_receiver concept by using an adopted Persistent_mq_handle MQ handle to an MQ...">Blob_stream_mq_receiver</a> counterpart, but assuming PEER state.  <a href="classipc_1_1transport_1_1sync__io_1_1Blob__stream__mq__receiver__impl.html#adaf3579ec3abf0b5d85258965d264660">More...</a><br /></td></tr>
<tr class="separator:adaf3579ec3abf0b5d85258965d264660"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acf5dd76c0d00746137fe6adedfa4c26d"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="namespaceipc_1_1transport.html#a33de1c256addb3964b839dc2dd407d24">Shared_name</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classipc_1_1transport_1_1sync__io_1_1Blob__stream__mq__receiver__impl.html#acf5dd76c0d00746137fe6adedfa4c26d">absolute_name</a> () const</td></tr>
<tr class="memdesc:acf5dd76c0d00746137fe6adedfa4c26d"><td class="mdescLeft">&#160;</td><td class="mdescRight">See <a class="el" href="classipc_1_1transport_1_1sync__io_1_1Blob__stream__mq__receiver.html" title="Implements sync_io::Blob_receiver concept by using an adopted Persistent_mq_handle MQ handle to an MQ...">Blob_stream_mq_receiver</a> counterpart, but assuming PEER state.  <a href="classipc_1_1transport_1_1sync__io_1_1Blob__stream__mq__receiver__impl.html#acf5dd76c0d00746137fe6adedfa4c26d">More...</a><br /></td></tr>
<tr class="separator:acf5dd76c0d00746137fe6adedfa4c26d"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pri-types" name="pri-types"></a>
Private Types</h2></td></tr>
<tr class="memitem:add17b83b9c20b617a13dcdc22e9b8d8d"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classipc_1_1transport_1_1sync__io_1_1Blob__stream__mq__receiver__impl.html#add17b83b9c20b617a13dcdc22e9b8d8d">Control_cmd</a> = typename <a class="el" href="classipc_1_1transport_1_1Blob__stream__mq__base__impl.html#a2e46672d40fbf38cf6054edfad69e705">Base::Control_cmd</a></td></tr>
<tr class="memdesc:add17b83b9c20b617a13dcdc22e9b8d8d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Short-hand for <a class="el" href="classipc_1_1transport_1_1Blob__stream__mq__base__impl.html#a2e46672d40fbf38cf6054edfad69e705" title="If Blob_stream_mq_sender_impl sends an empty message, in NORMAL state Blob_stream_mq_receiver enters ...">Blob_stream_mq_base_impl::Control_cmd</a>.  <a href="classipc_1_1transport_1_1sync__io_1_1Blob__stream__mq__receiver__impl.html#add17b83b9c20b617a13dcdc22e9b8d8d">More...</a><br /></td></tr>
<tr class="separator:add17b83b9c20b617a13dcdc22e9b8d8d"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pri-methods" name="pri-methods"></a>
Private Member Functions</h2></td></tr>
<tr class="memitem:a5c46890c19e4fe69d9276647205af786"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classipc_1_1transport_1_1sync__io_1_1Blob__stream__mq__receiver__impl.html#a5c46890c19e4fe69d9276647205af786">on_ev_idle_timer_fired</a> ()</td></tr>
<tr class="memdesc:a5c46890c19e4fe69d9276647205af786"><td class="mdescLeft">&#160;</td><td class="mdescRight">Handler for the async-wait, via <a class="el" href="classipc_1_1util_1_1sync__io_1_1Timer__event__emitter.html" title="An object of this type, used internally to implement sync_io-pattern objects that require timer event...">util::sync_io::Timer_event_emitter</a>, of the idle timer firing; if still relevant it records the idle-timeout error in <a class="el" href="classipc_1_1transport_1_1sync__io_1_1Blob__stream__mq__receiver__impl.html#a415d72c8ed4bed42fc84bf46f716742a" title="The first and only MQ-hosing error condition detected when attempting to low-level-read on m_mq; or f...">m_pending_err_code</a>; and if an <a class="el" href="classipc_1_1transport_1_1sync__io_1_1Blob__stream__mq__receiver__impl.html#a8d1a81d379e1a31031adb9cccbbabd35" title="See Blob_stream_mq_receiver counterpart, but assuming PEER state.">async_receive_blob()</a> is in progress (awaiting data via async-wait), it completes that operation with the appropriate idle-timeout error (completion handler in <a class="el" href="classipc_1_1transport_1_1sync__io_1_1Blob__stream__mq__receiver__impl.html#a819d349f5cafcba88f3dff63968d74b0" title="Null if no async_receive_blob()` is currently pending; else describes the arguments to that pending a...">m_user_request</a> runs synchronously).  <a href="classipc_1_1transport_1_1sync__io_1_1Blob__stream__mq__receiver__impl.html#a5c46890c19e4fe69d9276647205af786">More...</a><br /></td></tr>
<tr class="separator:a5c46890c19e4fe69d9276647205af786"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad98d5cf3970b4cef4932d59679c7d5b9"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classipc_1_1transport_1_1sync__io_1_1Blob__stream__mq__receiver__impl.html#ad98d5cf3970b4cef4932d59679c7d5b9">not_idle</a> ()</td></tr>
<tr class="memdesc:ad98d5cf3970b4cef4932d59679c7d5b9"><td class="mdescLeft">&#160;</td><td class="mdescRight">No-ops if <a class="el" href="classipc_1_1transport_1_1sync__io_1_1Blob__stream__mq__receiver__impl.html#a878fa03873bcdea5aa9d938a4791325f" title="See Blob_stream_mq_receiver counterpart, but assuming PEER state.">idle_timer_run()</a> is not engaged; otherwise reacts to non-idleness of the in-pipe by rescheduling idle timer to occur in <a class="el" href="classipc_1_1transport_1_1sync__io_1_1Blob__stream__mq__receiver__impl.html#a370d5984484667dae6fd227e7ef0d4ff" title="timeout from idle_timer_run() args; or zero() if not yet called.">m_idle_timeout</a> again.  <a href="classipc_1_1transport_1_1sync__io_1_1Blob__stream__mq__receiver__impl.html#ad98d5cf3970b4cef4932d59679c7d5b9">More...</a><br /></td></tr>
<tr class="separator:ad98d5cf3970b4cef4932d59679c7d5b9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6c1e656d4ce90d13b4f2f38fa5ad5cf9"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classipc_1_1transport_1_1sync__io_1_1Blob__stream__mq__receiver__impl.html#a6c1e656d4ce90d13b4f2f38fa5ad5cf9">read_msg</a> (<a class="el" href="namespaceipc.html#aa3192e586cc45d3e7c22463bf2760f89">Error_code</a> *sync_err_code, size_t *sync_sz)</td></tr>
<tr class="memdesc:a6c1e656d4ce90d13b4f2f38fa5ad5cf9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Begins read chain (completing it as synchronously as possible, async-completing the rest) for the next in-message.  <a href="classipc_1_1transport_1_1sync__io_1_1Blob__stream__mq__receiver__impl.html#a6c1e656d4ce90d13b4f2f38fa5ad5cf9">More...</a><br /></td></tr>
<tr class="separator:a6c1e656d4ce90d13b4f2f38fa5ad5cf9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a013d5b8cd991e0ba9d2e26a0f532fed8"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classipc_1_1transport_1_1sync__io_1_1Blob__stream__mq__receiver__impl.html#a013d5b8cd991e0ba9d2e26a0f532fed8">op_started</a> (<a class="el" href="namespaceipc_1_1util.html#ae6ac47812a90d1287c61e0b7de7bc4f5">util::String_view</a> context) const</td></tr>
<tr class="memdesc:a013d5b8cd991e0ba9d2e26a0f532fed8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Helper that returns <code>true</code> silently if <code>start_*_ops()</code> has been called; else logs WARNING and returns <code>false</code>.  <a href="classipc_1_1transport_1_1sync__io_1_1Blob__stream__mq__receiver__impl.html#a013d5b8cd991e0ba9d2e26a0f532fed8">More...</a><br /></td></tr>
<tr class="separator:a013d5b8cd991e0ba9d2e26a0f532fed8"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pri-attribs" name="pri-attribs"></a>
Private Attributes</h2></td></tr>
<tr class="memitem:ac892341e6a1fcc6ef8739bce8403fb6d"><td class="memItemLeft" align="right" valign="top">const std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classipc_1_1transport_1_1sync__io_1_1Blob__stream__mq__receiver__impl.html#ac892341e6a1fcc6ef8739bce8403fb6d">m_nickname</a></td></tr>
<tr class="memdesc:ac892341e6a1fcc6ef8739bce8403fb6d"><td class="mdescLeft">&#160;</td><td class="mdescRight">See <a class="el" href="classipc_1_1transport_1_1sync__io_1_1Blob__stream__mq__receiver__impl.html#adaf3579ec3abf0b5d85258965d264660" title="See Blob_stream_mq_receiver counterpart, but assuming PEER state.">nickname()</a>.  <a href="classipc_1_1transport_1_1sync__io_1_1Blob__stream__mq__receiver__impl.html#ac892341e6a1fcc6ef8739bce8403fb6d">More...</a><br /></td></tr>
<tr class="separator:ac892341e6a1fcc6ef8739bce8403fb6d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeec08979b985498aa0738892c947a8a9"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classipc_1_1transport_1_1Protocol__negotiator.html">Protocol_negotiator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classipc_1_1transport_1_1sync__io_1_1Blob__stream__mq__receiver__impl.html#aeec08979b985498aa0738892c947a8a9">m_protocol_negotiator</a></td></tr>
<tr class="memdesc:aeec08979b985498aa0738892c947a8a9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Handles the protocol negotiation at the start of the pipe and subsequently stores the result of that negotiation.  <a href="classipc_1_1transport_1_1sync__io_1_1Blob__stream__mq__receiver__impl.html#aeec08979b985498aa0738892c947a8a9">More...</a><br /></td></tr>
<tr class="separator:aeec08979b985498aa0738892c947a8a9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:add6affc3ee78f02c3a48a10115ec82ea"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="namespaceipc_1_1transport.html#a33de1c256addb3964b839dc2dd407d24">Shared_name</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classipc_1_1transport_1_1sync__io_1_1Blob__stream__mq__receiver__impl.html#add6affc3ee78f02c3a48a10115ec82ea">m_absolute_name</a></td></tr>
<tr class="memdesc:add6affc3ee78f02c3a48a10115ec82ea"><td class="mdescLeft">&#160;</td><td class="mdescRight">See <a class="el" href="classipc_1_1transport_1_1sync__io_1_1Blob__stream__mq__receiver__impl.html#acf5dd76c0d00746137fe6adedfa4c26d" title="See Blob_stream_mq_receiver counterpart, but assuming PEER state.">absolute_name()</a>.  <a href="classipc_1_1transport_1_1sync__io_1_1Blob__stream__mq__receiver__impl.html#add6affc3ee78f02c3a48a10115ec82ea">More...</a><br /></td></tr>
<tr class="separator:add6affc3ee78f02c3a48a10115ec82ea"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9f1120b92ea20944b2de416d870644ce"><td class="memItemLeft" align="right" valign="top">std::optional&lt; flow::util::Task_engine &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classipc_1_1transport_1_1sync__io_1_1Blob__stream__mq__receiver__impl.html#a9f1120b92ea20944b2de416d870644ce">m_nb_task_engine</a></td></tr>
<tr class="memdesc:a9f1120b92ea20944b2de416d870644ce"><td class="mdescLeft">&#160;</td><td class="mdescRight">The <code>Task_engine</code> for <code>m_mq_ready_*</code>.  <a href="classipc_1_1transport_1_1sync__io_1_1Blob__stream__mq__receiver__impl.html#a9f1120b92ea20944b2de416d870644ce">More...</a><br /></td></tr>
<tr class="separator:a9f1120b92ea20944b2de416d870644ce"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa3b1062b158606ea1760a3952b978e73"><td class="memItemLeft" align="right" valign="top">flow::util::Task_engine&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classipc_1_1transport_1_1sync__io_1_1Blob__stream__mq__receiver__impl.html#aa3b1062b158606ea1760a3952b978e73">m_ev_hndl_task_engine_unused</a></td></tr>
<tr class="memdesc:aa3b1062b158606ea1760a3952b978e73"><td class="mdescLeft">&#160;</td><td class="mdescRight">The <code>Task_engine</code> for <code>m_ev_wait_hndl_*</code>, unless it is replaced via <a class="el" href="classipc_1_1transport_1_1sync__io_1_1Blob__stream__mq__receiver__impl.html#a3ee71a39a443e78c86f82652d8d0601e" title="See Blob_stream_mq_receiver counterpart.">replace_event_wait_handles()</a>.  <a href="classipc_1_1transport_1_1sync__io_1_1Blob__stream__mq__receiver__impl.html#aa3b1062b158606ea1760a3952b978e73">More...</a><br /></td></tr>
<tr class="separator:aa3b1062b158606ea1760a3952b978e73"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae71fa0a5594915910b0b8dd88743f62e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classipc_1_1transport_1_1Blob__stream__mq__base__impl.html#aab7c4c91d42c746c93e61eb367572eb1">Base::Auto_closing_mq</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classipc_1_1transport_1_1sync__io_1_1Blob__stream__mq__receiver__impl.html#ae71fa0a5594915910b0b8dd88743f62e">m_mq</a></td></tr>
<tr class="memdesc:ae71fa0a5594915910b0b8dd88743f62e"><td class="mdescLeft">&#160;</td><td class="mdescRight">The MQ handle adopted by the ctor, through which nb-receives and blocking-waits are executed.  <a href="classipc_1_1transport_1_1sync__io_1_1Blob__stream__mq__receiver__impl.html#ae71fa0a5594915910b0b8dd88743f62e">More...</a><br /></td></tr>
<tr class="separator:ae71fa0a5594915910b0b8dd88743f62e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a25ec1b85b46e3b9ad9a4fe59bc158f45"><td class="memItemLeft" align="right" valign="top">const size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classipc_1_1transport_1_1sync__io_1_1Blob__stream__mq__receiver__impl.html#a25ec1b85b46e3b9ad9a4fe59bc158f45">m_mq_max_msg_sz</a></td></tr>
<tr class="memdesc:a25ec1b85b46e3b9ad9a4fe59bc158f45"><td class="mdescLeft">&#160;</td><td class="mdescRight">Equals <code>m_mq.max_msg_size()</code>.  <a href="classipc_1_1transport_1_1sync__io_1_1Blob__stream__mq__receiver__impl.html#a25ec1b85b46e3b9ad9a4fe59bc158f45">More...</a><br /></td></tr>
<tr class="separator:a25ec1b85b46e3b9ad9a4fe59bc158f45"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af742578435fde1d0c536196698ddbc75"><td class="memItemLeft" align="right" valign="top">std::optional&lt; <a class="el" href="namespaceipc_1_1util.html#aaf368acf8243bb25de3eef4e836c15de">util::Pipe_reader</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classipc_1_1transport_1_1sync__io_1_1Blob__stream__mq__receiver__impl.html#af742578435fde1d0c536196698ddbc75">m_mq_ready_reader</a></td></tr>
<tr class="memdesc:af742578435fde1d0c536196698ddbc75"><td class="mdescLeft">&#160;</td><td class="mdescRight">Read-end of IPC-pipe used by thread U to detect that a thread-W transmissibility-wait has completed, meaning would-block has cleared, and therefore thread U can attempt to nb-transmit again.  <a href="classipc_1_1transport_1_1sync__io_1_1Blob__stream__mq__receiver__impl.html#af742578435fde1d0c536196698ddbc75">More...</a><br /></td></tr>
<tr class="separator:af742578435fde1d0c536196698ddbc75"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac181b33a0b5cdb0e89753b62d86af50f"><td class="memItemLeft" align="right" valign="top">std::optional&lt; <a class="el" href="namespaceipc_1_1util.html#a844d5ca9c17b672644fc8d9dbe758db0">util::Pipe_writer</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classipc_1_1transport_1_1sync__io_1_1Blob__stream__mq__receiver__impl.html#ac181b33a0b5cdb0e89753b62d86af50f">m_mq_ready_writer</a></td></tr>
<tr class="memdesc:ac181b33a0b5cdb0e89753b62d86af50f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Write-end of IPC-pipe used by thread W to inform thread U that a thread-W transmissibility-wait has completed, meaning would-block has cleared, and therefore thread U can attempt to nb-transmit again.  <a href="classipc_1_1transport_1_1sync__io_1_1Blob__stream__mq__receiver__impl.html#ac181b33a0b5cdb0e89753b62d86af50f">More...</a><br /></td></tr>
<tr class="separator:ac181b33a0b5cdb0e89753b62d86af50f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a87df1a6c9a98542a8fb00a9d85570c64"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classipc_1_1util_1_1sync__io_1_1Asio__waitable__native__handle.html">util::sync_io::Asio_waitable_native_handle</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classipc_1_1transport_1_1sync__io_1_1Blob__stream__mq__receiver__impl.html#a87df1a6c9a98542a8fb00a9d85570c64">m_ev_wait_hndl_mq</a></td></tr>
<tr class="memdesc:a87df1a6c9a98542a8fb00a9d85570c64"><td class="mdescLeft">&#160;</td><td class="mdescRight">Descriptor waitable by outside event loop async-waits &ndash; storing the same <code>Native_handle</code> as (and thus being used to wait on events from) <a class="el" href="classipc_1_1transport_1_1sync__io_1_1Blob__stream__mq__receiver__impl.html#af742578435fde1d0c536196698ddbc75" title="Read-end of IPC-pipe used by thread U to detect that a thread-W transmissibility-wait has completed,...">m_mq_ready_reader</a>; or if <a class="el" href="classipc_1_1transport_1_1sync__io_1_1Blob__stream__mq__receiver__impl.html#ae71fa0a5594915910b0b8dd88743f62e" title="The MQ handle adopted by the ctor, through which nb-receives and blocking-waits are executed.">m_mq</a> can be watched directly (known at compile-time) then as <code>m_mq</code> itself.  <a href="classipc_1_1transport_1_1sync__io_1_1Blob__stream__mq__receiver__impl.html#a87df1a6c9a98542a8fb00a9d85570c64">More...</a><br /></td></tr>
<tr class="separator:a87df1a6c9a98542a8fb00a9d85570c64"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aae2ee292cd7b9742b32e68dfd84d8361"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classipc_1_1util_1_1sync__io_1_1Timer__event__emitter.html">util::sync_io::Timer_event_emitter</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classipc_1_1transport_1_1sync__io_1_1Blob__stream__mq__receiver__impl.html#aae2ee292cd7b9742b32e68dfd84d8361">m_timer_worker</a></td></tr>
<tr class="memdesc:aae2ee292cd7b9742b32e68dfd84d8361"><td class="mdescLeft">&#160;</td><td class="mdescRight">As typical in timer-needing <code><a class="el" href="namespaceipc_1_1transport_1_1sync__io.html" title="sync_io-pattern counterparts to async-I/O-pattern object types in parent namespace ipc::transport.">sync_io</a></code>-pattern-implementing objects, maintains a thread exclusively for <code>Timer</code> wait completion handlers which ferry timer-fired events to internal IPC-mechanisms waitable by the <code><a class="el" href="namespaceipc_1_1transport_1_1sync__io.html" title="sync_io-pattern counterparts to async-I/O-pattern object types in parent namespace ipc::transport.">sync_io</a></code>-pattern-using outside event loop.  <a href="classipc_1_1transport_1_1sync__io_1_1Blob__stream__mq__receiver__impl.html#aae2ee292cd7b9742b32e68dfd84d8361">More...</a><br /></td></tr>
<tr class="separator:aae2ee292cd7b9742b32e68dfd84d8361"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a819d349f5cafcba88f3dff63968d74b0"><td class="memItemLeft" align="right" valign="top">std::optional&lt; <a class="el" href="structipc_1_1transport_1_1sync__io_1_1Blob__stream__mq__receiver__impl_1_1User__request.html">User_request</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classipc_1_1transport_1_1sync__io_1_1Blob__stream__mq__receiver__impl.html#a819d349f5cafcba88f3dff63968d74b0">m_user_request</a></td></tr>
<tr class="memdesc:a819d349f5cafcba88f3dff63968d74b0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Null if no <a class="el" href="classipc_1_1transport_1_1sync__io_1_1Blob__stream__mq__receiver__impl.html#a8d1a81d379e1a31031adb9cccbbabd35" title="See Blob_stream_mq_receiver counterpart, but assuming PEER state.">async_receive_blob()</a>` is currently pending; else describes the arguments to that pending <a class="el" href="classipc_1_1transport_1_1sync__io_1_1Blob__stream__mq__receiver__impl.html#a8d1a81d379e1a31031adb9cccbbabd35" title="See Blob_stream_mq_receiver counterpart, but assuming PEER state.">async_receive_blob()</a>.  <a href="classipc_1_1transport_1_1sync__io_1_1Blob__stream__mq__receiver__impl.html#a819d349f5cafcba88f3dff63968d74b0">More...</a><br /></td></tr>
<tr class="separator:a819d349f5cafcba88f3dff63968d74b0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a276f39d3d52038a341bf2ec86b4640ef"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classipc_1_1transport_1_1sync__io_1_1Blob__stream__mq__receiver__impl.html#a276f39d3d52038a341bf2ec86b4640ef">m_control_state</a></td></tr>
<tr class="memdesc:a276f39d3d52038a341bf2ec86b4640ef"><td class="mdescLeft">&#160;</td><td class="mdescRight">At steady-state <code>false</code>, becomes <code>true</code> if a low-level "escape" payload (empty message) was last received meaning the next message will be the encoding of a <a class="el" href="classipc_1_1transport_1_1sync__io_1_1Blob__stream__mq__receiver__impl.html#add17b83b9c20b617a13dcdc22e9b8d8d" title="Short-hand for Blob_stream_mq_base_impl::Control_cmd.">Control_cmd</a> enumeration value, receiving which shall reset this to <code>false</code>.  <a href="classipc_1_1transport_1_1sync__io_1_1Blob__stream__mq__receiver__impl.html#a276f39d3d52038a341bf2ec86b4640ef">More...</a><br /></td></tr>
<tr class="separator:a276f39d3d52038a341bf2ec86b4640ef"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af308d3f1ff50138070c8422552f069a5"><td class="memItemLeft" align="right" valign="top">flow::util::Blob&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classipc_1_1transport_1_1sync__io_1_1Blob__stream__mq__receiver__impl.html#af308d3f1ff50138070c8422552f069a5">m_target_control_blob</a></td></tr>
<tr class="memdesc:af308d3f1ff50138070c8422552f069a5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Used only when <a class="el" href="classipc_1_1transport_1_1sync__io_1_1Blob__stream__mq__receiver__impl.html#a276f39d3d52038a341bf2ec86b4640ef" title="At steady-state false, becomes true if a low-level &quot;escape&quot; payload (empty message) was last received...">m_control_state</a> is <code>true</code>, this is where payload 2 (the <a class="el" href="classipc_1_1transport_1_1sync__io_1_1Blob__stream__mq__receiver__impl.html#add17b83b9c20b617a13dcdc22e9b8d8d" title="Short-hand for Blob_stream_mq_base_impl::Control_cmd.">Control_cmd</a>) is placed.  <a href="classipc_1_1transport_1_1sync__io_1_1Blob__stream__mq__receiver__impl.html#af308d3f1ff50138070c8422552f069a5">More...</a><br /></td></tr>
<tr class="separator:af308d3f1ff50138070c8422552f069a5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a415d72c8ed4bed42fc84bf46f716742a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespaceipc.html#aa3192e586cc45d3e7c22463bf2760f89">Error_code</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classipc_1_1transport_1_1sync__io_1_1Blob__stream__mq__receiver__impl.html#a415d72c8ed4bed42fc84bf46f716742a">m_pending_err_code</a></td></tr>
<tr class="memdesc:a415d72c8ed4bed42fc84bf46f716742a"><td class="mdescLeft">&#160;</td><td class="mdescRight">The first and only MQ-hosing error condition detected when attempting to low-level-read on <a class="el" href="classipc_1_1transport_1_1sync__io_1_1Blob__stream__mq__receiver__impl.html#ae71fa0a5594915910b0b8dd88743f62e" title="The MQ handle adopted by the ctor, through which nb-receives and blocking-waits are executed.">m_mq</a>; or falsy if no such error has yet been detected.  <a href="classipc_1_1transport_1_1sync__io_1_1Blob__stream__mq__receiver__impl.html#a415d72c8ed4bed42fc84bf46f716742a">More...</a><br /></td></tr>
<tr class="separator:a415d72c8ed4bed42fc84bf46f716742a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a370d5984484667dae6fd227e7ef0d4ff"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespaceipc_1_1util.html#ac66141280c3b7295a86b65209f31cc58">util::Fine_duration</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classipc_1_1transport_1_1sync__io_1_1Blob__stream__mq__receiver__impl.html#a370d5984484667dae6fd227e7ef0d4ff">m_idle_timeout</a></td></tr>
<tr class="memdesc:a370d5984484667dae6fd227e7ef0d4ff"><td class="mdescLeft">&#160;</td><td class="mdescRight"><code>timeout</code> from <a class="el" href="classipc_1_1transport_1_1sync__io_1_1Blob__stream__mq__receiver__impl.html#a878fa03873bcdea5aa9d938a4791325f" title="See Blob_stream_mq_receiver counterpart, but assuming PEER state.">idle_timer_run()</a> args; or <code>zero()</code> if not yet called.  <a href="classipc_1_1transport_1_1sync__io_1_1Blob__stream__mq__receiver__impl.html#a370d5984484667dae6fd227e7ef0d4ff">More...</a><br /></td></tr>
<tr class="separator:a370d5984484667dae6fd227e7ef0d4ff"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7f3ac613026a5c7704641ba5b3971fe5"><td class="memItemLeft" align="right" valign="top">flow::util::Timer&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classipc_1_1transport_1_1sync__io_1_1Blob__stream__mq__receiver__impl.html#a7f3ac613026a5c7704641ba5b3971fe5">m_idle_timer</a></td></tr>
<tr class="memdesc:a7f3ac613026a5c7704641ba5b3971fe5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Timer that fires <a class="el" href="classipc_1_1transport_1_1sync__io_1_1Blob__stream__mq__receiver__impl.html#a5c46890c19e4fe69d9276647205af786" title="Handler for the async-wait, via util::sync_io::Timer_event_emitter, of the idle timer firing; if stil...">on_ev_idle_timer_fired()</a> (which hoses the pipe with idle timeour error) and is (re)scheduled to fire in <a class="el" href="classipc_1_1transport_1_1sync__io_1_1Blob__stream__mq__receiver__impl.html#a370d5984484667dae6fd227e7ef0d4ff" title="timeout from idle_timer_run() args; or zero() if not yet called.">m_idle_timeout</a> each time <code>*this</code> receives a complete message on <a class="el" href="classipc_1_1transport_1_1sync__io_1_1Blob__stream__mq__receiver__impl.html#ae71fa0a5594915910b0b8dd88743f62e" title="The MQ handle adopted by the ctor, through which nb-receives and blocking-waits are executed.">m_mq</a>.  <a href="classipc_1_1transport_1_1sync__io_1_1Blob__stream__mq__receiver__impl.html#a7f3ac613026a5c7704641ba5b3971fe5">More...</a><br /></td></tr>
<tr class="separator:a7f3ac613026a5c7704641ba5b3971fe5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a64d71115e8212c896eb7baa82f005c82"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classipc_1_1util_1_1sync__io_1_1Timer__event__emitter.html#a1533a54927a64579fda02c61ec94b735">util::sync_io::Timer_event_emitter::Timer_fired_read_end</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classipc_1_1transport_1_1sync__io_1_1Blob__stream__mq__receiver__impl.html#a64d71115e8212c896eb7baa82f005c82">m_idle_timer_fired_peer</a></td></tr>
<tr class="memdesc:a64d71115e8212c896eb7baa82f005c82"><td class="mdescLeft">&#160;</td><td class="mdescRight">Read-end of IPC-mechanism used by <a class="el" href="classipc_1_1transport_1_1sync__io_1_1Blob__stream__mq__receiver__impl.html#aae2ee292cd7b9742b32e68dfd84d8361" title="As typical in timer-needing sync_io-pattern-implementing objects, maintains a thread exclusively for ...">m_timer_worker</a> to ferry timer-fired events from <a class="el" href="classipc_1_1transport_1_1sync__io_1_1Blob__stream__mq__receiver__impl.html#a7f3ac613026a5c7704641ba5b3971fe5" title="Timer that fires on_ev_idle_timer_fired() (which hoses the pipe with idle timeour error) and is (re)s...">m_idle_timer</a> to <code><a class="el" href="namespaceipc_1_1transport_1_1sync__io.html" title="sync_io-pattern counterparts to async-I/O-pattern object types in parent namespace ipc::transport.">sync_io</a></code> outside async-wait to our actual on-timer-fired handler logic.  <a href="classipc_1_1transport_1_1sync__io_1_1Blob__stream__mq__receiver__impl.html#a64d71115e8212c896eb7baa82f005c82">More...</a><br /></td></tr>
<tr class="separator:a64d71115e8212c896eb7baa82f005c82"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0511a6453387e65378f0e66d80886bcd"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classipc_1_1util_1_1sync__io_1_1Asio__waitable__native__handle.html">util::sync_io::Asio_waitable_native_handle</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classipc_1_1transport_1_1sync__io_1_1Blob__stream__mq__receiver__impl.html#a0511a6453387e65378f0e66d80886bcd">m_ev_wait_hndl_idle_timer_fired_peer</a></td></tr>
<tr class="memdesc:a0511a6453387e65378f0e66d80886bcd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Descriptor waitable by outside event loop async-waits &ndash; storing the same <code>Native_handle</code> as (and thus being used to wait on events from) <a class="el" href="classipc_1_1transport_1_1sync__io_1_1Blob__stream__mq__receiver__impl.html#a64d71115e8212c896eb7baa82f005c82" title="Read-end of IPC-mechanism used by m_timer_worker to ferry timer-fired events from m_idle_timer to syn...">m_idle_timer_fired_peer</a>.  <a href="classipc_1_1transport_1_1sync__io_1_1Blob__stream__mq__receiver__impl.html#a0511a6453387e65378f0e66d80886bcd">More...</a><br /></td></tr>
<tr class="separator:a0511a6453387e65378f0e66d80886bcd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1c8ac9998df02ead0180c6bc00bc58dd"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespaceipc_1_1util_1_1sync__io.html#aa0b9a3cc6bdc7dedbef4f9e06851aa24">util::sync_io::Event_wait_func</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classipc_1_1transport_1_1sync__io_1_1Blob__stream__mq__receiver__impl.html#a1c8ac9998df02ead0180c6bc00bc58dd">m_ev_wait_func</a></td></tr>
<tr class="memdesc:a1c8ac9998df02ead0180c6bc00bc58dd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function (set forever in <a class="el" href="classipc_1_1transport_1_1sync__io_1_1Blob__stream__mq__receiver__impl.html#a1e286f452b6e3a74d64e1f795795afe2" title="See Blob_stream_mq_receiver counterpart.">start_receive_blob_ops()</a>) through which we invoke the outside event loop's async-wait facility for descriptors/events relevant to our ops.  <a href="classipc_1_1transport_1_1sync__io_1_1Blob__stream__mq__receiver__impl.html#a1c8ac9998df02ead0180c6bc00bc58dd">More...</a><br /></td></tr>
<tr class="separator:a1c8ac9998df02ead0180c6bc00bc58dd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad233c7b57cbb817fb243bec5d338ec2e"><td class="memItemLeft" align="right" valign="top">std::optional&lt; flow::async::Single_thread_task_loop &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classipc_1_1transport_1_1sync__io_1_1Blob__stream__mq__receiver__impl.html#ad233c7b57cbb817fb243bec5d338ec2e">m_blocking_worker</a></td></tr>
<tr class="memdesc:ad233c7b57cbb817fb243bec5d338ec2e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Worker thread W always in one of 2 states: idle; or (when <a class="el" href="classipc_1_1transport_1_1sync__io_1_1Blob__stream__mq__receiver__impl.html#ae71fa0a5594915910b0b8dd88743f62e" title="The MQ handle adopted by the ctor, through which nb-receives and blocking-waits are executed.">m_mq</a> is in would-block condition) executing an indefinite, interrupting blocking wait for transmissibility of <a class="el" href="classipc_1_1transport_1_1sync__io_1_1Blob__stream__mq__receiver__impl.html#ae71fa0a5594915910b0b8dd88743f62e" title="The MQ handle adopted by the ctor, through which nb-receives and blocking-waits are executed.">m_mq</a>.  <a href="classipc_1_1transport_1_1sync__io_1_1Blob__stream__mq__receiver__impl.html#ad233c7b57cbb817fb243bec5d338ec2e">More...</a><br /></td></tr>
<tr class="separator:ad233c7b57cbb817fb243bec5d338ec2e"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="related" name="related"></a>
Related Functions</h2></td></tr>
<tr><td class="ititle" colspan="2"><p >(Note that these are not member functions.) </p>
</td></tr>
<tr class="memitem:a4efecbe0fe86aa7d61b86f9c5edf20b4"><td class="memTemplParams" colspan="2">template&lt;typename <a class="el" href="classipc_1_1transport_1_1Persistent__mq__handle.html">Persistent_mq_handle</a> &gt; </td></tr>
<tr class="memitem:a4efecbe0fe86aa7d61b86f9c5edf20b4"><td class="memTemplItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classipc_1_1transport_1_1sync__io_1_1Blob__stream__mq__receiver__impl.html#a4efecbe0fe86aa7d61b86f9c5edf20b4">operator&lt;&lt;</a> (std::ostream &amp;os, const <a class="el" href="classipc_1_1transport_1_1sync__io_1_1Blob__stream__mq__receiver__impl.html">Blob_stream_mq_receiver_impl</a>&lt; <a class="el" href="classipc_1_1transport_1_1Persistent__mq__handle.html">Persistent_mq_handle</a> &gt; &amp;val)</td></tr>
<tr class="memdesc:a4efecbe0fe86aa7d61b86f9c5edf20b4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Prints string representation of the given <code><a class="el" href="classipc_1_1transport_1_1sync__io_1_1Blob__stream__mq__receiver__impl.html" title="Internal, non-movable pImpl-lite implementation of sync_io::Blob_stream_mq_receiver class template.">Blob_stream_mq_receiver_impl</a></code> to the given <code>ostream</code>.  <a href="classipc_1_1transport_1_1sync__io_1_1Blob__stream__mq__receiver__impl.html#a4efecbe0fe86aa7d61b86f9c5edf20b4">More...</a><br /></td></tr>
<tr class="separator:a4efecbe0fe86aa7d61b86f9c5edf20b4"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="inherited" name="inherited"></a>
Additional Inherited Members</h2></td></tr>
<tr class="inherit_header pub_static_methods_classipc_1_1transport_1_1Blob__stream__mq__base__impl"><td colspan="2" onclick="javascript:toggleInherit('pub_static_methods_classipc_1_1transport_1_1Blob__stream__mq__base__impl')"><img src="closed.png" alt="-"/>&#160;Static Public Member Functions inherited from <a class="el" href="classipc_1_1transport_1_1Blob__stream__mq__base__impl.html">ipc::transport::Blob_stream_mq_base_impl&lt; Persistent_mq_handle &gt;</a></td></tr>
<tr class="memitem:a8877f75af055ab927a4b4c993f0873a2 inherit pub_static_methods_classipc_1_1transport_1_1Blob__stream__mq__base__impl"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classipc_1_1transport_1_1Blob__stream__mq__base__impl.html#a8877f75af055ab927a4b4c993f0873a2">remove_persistent</a> (flow::log::Logger *logger_ptr, const <a class="el" href="namespaceipc_1_1transport.html#a33de1c256addb3964b839dc2dd407d24">Shared_name</a> &amp;name, <a class="el" href="namespaceipc.html#aa3192e586cc45d3e7c22463bf2760f89">Error_code</a> *err_code)</td></tr>
<tr class="memdesc:a8877f75af055ab927a4b4c993f0873a2 inherit pub_static_methods_classipc_1_1transport_1_1Blob__stream__mq__base__impl"><td class="mdescLeft">&#160;</td><td class="mdescRight">See <a class="el" href="classipc_1_1transport_1_1Blob__stream__mq__base.html" title="Base of Blob_stream_mq_sender and Blob_stream_mq_receiver containing certain static facilities,...">Blob_stream_mq_base</a> counterpart.  <a href="classipc_1_1transport_1_1Blob__stream__mq__base__impl.html#a8877f75af055ab927a4b4c993f0873a2">More...</a><br /></td></tr>
<tr class="separator:a8877f75af055ab927a4b4c993f0873a2 inherit pub_static_methods_classipc_1_1transport_1_1Blob__stream__mq__base__impl"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a88105803396fe1f60faab3b0bad97785 inherit pub_static_methods_classipc_1_1transport_1_1Blob__stream__mq__base__impl"><td class="memTemplParams" colspan="2">template&lt;typename Handle_name_func &gt; </td></tr>
<tr class="memitem:a88105803396fe1f60faab3b0bad97785 inherit pub_static_methods_classipc_1_1transport_1_1Blob__stream__mq__base__impl"><td class="memTemplItemLeft" align="right" valign="top">static void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classipc_1_1transport_1_1Blob__stream__mq__base__impl.html#a88105803396fe1f60faab3b0bad97785">for_each_persistent</a> (const Handle_name_func &amp;handle_name_func)</td></tr>
<tr class="memdesc:a88105803396fe1f60faab3b0bad97785 inherit pub_static_methods_classipc_1_1transport_1_1Blob__stream__mq__base__impl"><td class="mdescLeft">&#160;</td><td class="mdescRight">See <a class="el" href="classipc_1_1transport_1_1Blob__stream__mq__base.html" title="Base of Blob_stream_mq_sender and Blob_stream_mq_receiver containing certain static facilities,...">Blob_stream_mq_base</a> counterpart.  <a href="classipc_1_1transport_1_1Blob__stream__mq__base__impl.html#a88105803396fe1f60faab3b0bad97785">More...</a><br /></td></tr>
<tr class="separator:a88105803396fe1f60faab3b0bad97785 inherit pub_static_methods_classipc_1_1transport_1_1Blob__stream__mq__base__impl"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4776b5f569ccac03eccb3fc2f360fcc9 inherit pub_static_methods_classipc_1_1transport_1_1Blob__stream__mq__base__impl"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classipc_1_1transport_1_1Blob__stream__mq__base__impl.html#aab7c4c91d42c746c93e61eb367572eb1">Auto_closing_mq</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classipc_1_1transport_1_1Blob__stream__mq__base__impl.html#a4776b5f569ccac03eccb3fc2f360fcc9">ensure_unique_peer</a> (flow::log::Logger *logger_ptr, <a class="el" href="classipc_1_1transport_1_1Blob__stream__mq__base__impl.html#a8fac0ed5fff23aa42e0a601db6fee42d">Mq</a> &amp;&amp;mq, bool snd_else_rcv, <a class="el" href="namespaceipc.html#aa3192e586cc45d3e7c22463bf2760f89">Error_code</a> *err_code)</td></tr>
<tr class="memdesc:a4776b5f569ccac03eccb3fc2f360fcc9 inherit pub_static_methods_classipc_1_1transport_1_1Blob__stream__mq__base__impl"><td class="mdescLeft">&#160;</td><td class="mdescRight">Internal helper for <a class="el" href="classipc_1_1transport_1_1Blob__stream__mq__sender.html" title="Implements Blob_sender concept by using an adopted Persistent_mq_handle MQ handle to an MQ (message q...">Blob_stream_mq_sender</a> and <a class="el" href="classipc_1_1transport_1_1Blob__stream__mq__receiver.html" title="Implements Blob_receiver concept by using an adopted Persistent_mq_handle MQ handle to an MQ (message...">Blob_stream_mq_receiver</a> that operates both the start and end of the anti-dupe-endpoint machinery used by those 2 classes to prevent more than 1 <code>_sender</code> and more than 1 <code>_receiver</code> for a given underlying MQ.  <a href="classipc_1_1transport_1_1Blob__stream__mq__base__impl.html#a4776b5f569ccac03eccb3fc2f360fcc9">More...</a><br /></td></tr>
<tr class="separator:a4776b5f569ccac03eccb3fc2f360fcc9 inherit pub_static_methods_classipc_1_1transport_1_1Blob__stream__mq__base__impl"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pro_types_classipc_1_1transport_1_1Blob__stream__mq__base__impl"><td colspan="2" onclick="javascript:toggleInherit('pro_types_classipc_1_1transport_1_1Blob__stream__mq__base__impl')"><img src="closed.png" alt="-"/>&#160;Protected Types inherited from <a class="el" href="classipc_1_1transport_1_1Blob__stream__mq__base__impl.html">ipc::transport::Blob_stream_mq_base_impl&lt; Persistent_mq_handle &gt;</a></td></tr>
<tr class="memitem:a2e46672d40fbf38cf6054edfad69e705 inherit pro_types_classipc_1_1transport_1_1Blob__stream__mq__base__impl"><td class="memItemLeft" align="right" valign="top">enum class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classipc_1_1transport_1_1Blob__stream__mq__base__impl.html#a2e46672d40fbf38cf6054edfad69e705">Control_cmd</a> : int64_t { <a class="el" href="classipc_1_1transport_1_1Blob__stream__mq__base__impl.html#a2e46672d40fbf38cf6054edfad69e705ad584ea5a5dbf02d7e925adb912f3051a">S_END_SENDING</a>
, <a class="el" href="classipc_1_1transport_1_1Blob__stream__mq__base__impl.html#a2e46672d40fbf38cf6054edfad69e705ad79c2ad1486703a583c7516555a907e9">S_PING</a>
, <a class="el" href="classipc_1_1transport_1_1Blob__stream__mq__base__impl.html#a2e46672d40fbf38cf6054edfad69e705a6fba12db09e5bebfaa04f6372c41c2cf">S_END_SENTINEL</a>
 }</td></tr>
<tr class="memdesc:a2e46672d40fbf38cf6054edfad69e705"><td class="mdescLeft">&#160;</td><td class="mdescRight">If <a class="el" href="classipc_1_1transport_1_1Blob__stream__mq__sender__impl.html" title="Internal, non-movable pImpl-lite implementation of Blob_stream_mq_sender class template.">Blob_stream_mq_sender_impl</a> sends an empty message, in NORMAL state <a class="el" href="classipc_1_1transport_1_1Blob__stream__mq__receiver.html" title="Implements Blob_receiver concept by using an adopted Persistent_mq_handle MQ handle to an MQ (message...">Blob_stream_mq_receiver</a> enters CONTROL state and expects one of these values in the next message, to react as documented per <code>enum</code> value (upon re-entering NORMAL state).  <a href="classipc_1_1transport_1_1Blob__stream__mq__base__impl.html#a2e46672d40fbf38cf6054edfad69e705">More...</a><br /></td></tr>
<tr class="separator:a2e46672d40fbf38cf6054edfad69e705 inherit pro_types_classipc_1_1transport_1_1Blob__stream__mq__base__impl"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><div class="compoundTemplParams">template&lt;typename <a class="el" href="classipc_1_1transport_1_1Persistent__mq__handle.html">Persistent_mq_handle</a>&gt;<br />
class ipc::transport::sync_io::Blob_stream_mq_receiver_impl&lt; Persistent_mq_handle &gt;</div><p >Internal, non-movable pImpl-lite implementation of <a class="el" href="classipc_1_1transport_1_1sync__io_1_1Blob__stream__mq__receiver.html" title="Implements sync_io::Blob_receiver concept by using an adopted Persistent_mq_handle MQ handle to an MQ...">sync_io::Blob_stream_mq_receiver</a> class template. </p>
<p >In and of itself it would have been directly and publicly usable; however <a class="el" href="classipc_1_1transport_1_1sync__io_1_1Blob__stream__mq__receiver.html" title="Implements sync_io::Blob_receiver concept by using an adopted Persistent_mq_handle MQ handle to an MQ...">Blob_stream_mq_receiver</a> adds move semantics which are essential to cooperation with the rest of the API, <a class="el" href="classipc_1_1transport_1_1Channel.html" title="Peer to a bundle of 1-2 full-duplex pipe(s), one for transmitting unstructured binary blobs; the othe...">Channel</a> in particular.</p>
<dl class="section see"><dt>See also</dt><dd>All discussion of the public API is in <a class="el" href="classipc_1_1transport_1_1sync__io_1_1Blob__stream__mq__receiver.html" title="Implements sync_io::Blob_receiver concept by using an adopted Persistent_mq_handle MQ handle to an MQ...">Blob_stream_mq_receiver</a> doc header; that class template forwards to this one. All discussion of pImpl-lite-related notions is also there. See that doc header first please. Then come back here.</dd></dl>
<h3>Impl design</h3>
<p >See <a class="el" href="classipc_1_1transport_1_1sync__io_1_1Blob__stream__mq__sender__impl.html" title="Internal, non-movable pImpl-lite implementation of sync_io::Blob_stream_mq_sender class template.">sync_io::Blob_stream_mq_sender_impl</a>. The same notes apply. That isn't to say our algorithm is the same at all: we are receiving; they are sending. However, obviously, they speak the same protocol. And beyond that it is again about (1) understanding the <code><a class="el" href="namespaceipc_1_1transport_1_1sync__io.html" title="sync_io-pattern counterparts to async-I/O-pattern object types in parent namespace ipc::transport.">sync_io</a></code> pattern (<a class="el" href="namespaceipc_1_1util_1_1sync__io.html" title="Contains common code, as well as important explanatory documentation in the following text,...">util::sync_io</a> doc header) and (2) jumping into the code.</p>
<p >Again, for that last part, we recommend starting with the data member doc headers.</p>
<h3>Protocol negotiation</h3>
<p >Do see the same-named section in <a class="el" href="classipc_1_1transport_1_1sync__io_1_1Blob__stream__mq__sender__impl.html" title="Internal, non-movable pImpl-lite implementation of sync_io::Blob_stream_mq_sender class template.">sync_io::Blob_stream_mq_sender_impl</a> doc header. Naturally again we're mirroring the same protocol; but we're receiving; they're sending. Due to the latter difference, though, a couple additional notes:</p><ul>
<li>We are the guy receiving the preceding-all-messages message containing the opposing side's preferred (highest) protocol version. As of this writing we only speak v1, but they might speak a range &ndash; including or excluding it. However our <a class="el" href="classipc_1_1transport_1_1Protocol__negotiator.html" title="A simple state machine that, assuming the opposide side of a comm pathway uses an equivalent state ma...">Protocol_negotiator</a> takes care of all that; and we only need to add logic to emit fatal error, if <a class="el" href="classipc_1_1transport_1_1Protocol__negotiator.html" title="A simple state machine that, assuming the opposide side of a comm pathway uses an equivalent state ma...">Protocol_negotiator</a> reports that we're incompatible with opposing side.<ul>
<li>Having gotten past that without error, we simply then speak the only version we know how (v1).</li>
</ul>
</li>
<li>Since only protocol v1 exists as of this writing, there's no need yet for an API to signal a partner MQ-sender object of the negotiated protocol version, once we have it. As noted in <a class="el" href="classipc_1_1transport_1_1sync__io_1_1Blob__stream__mq__sender__impl.html" title="Internal, non-movable pImpl-lite implementation of sync_io::Blob_stream_mq_sender class template.">sync_io::Blob_stream_mq_sender_impl</a> doc header, that may change in the future.</li>
</ul>
<dl class="section note"><dt>Note</dt><dd>We suggest that if version 2, etc., is/are added, then the above notes be kept more or less intact; then add updates to show changes. This will provide a good overview of how the protocol evolved; and our backwards-compatibility story (even if we decide to have no backwards-compatibility).</dd></dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname"><a class="el" href="classipc_1_1transport_1_1Persistent__mq__handle.html" title="A documentation-only concept defining the behavior of an object representing a light-weight handle to...">Persistent_mq_handle</a></td><td>See <a class="el" href="classipc_1_1transport_1_1Persistent__mq__handle.html" title="A documentation-only concept defining the behavior of an object representing a light-weight handle to...">Persistent_mq_handle</a> concept doc header. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="sync__io_2detail_2blob__stream__mq__rcv__impl_8hpp_source.html#l00071">71</a> of file <a class="el" href="sync__io_2detail_2blob__stream__mq__rcv__impl_8hpp_source.html">blob_stream_mq_rcv_impl.hpp</a>.</p>
</div><h2 class="groupheader">Member Typedef Documentation</h2>
<a id="ac3d293643835e752560de34116554624" name="ac3d293643835e752560de34116554624"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac3d293643835e752560de34116554624">&#9670;&nbsp;</a></span>Base</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename <a class="el" href="classipc_1_1transport_1_1Persistent__mq__handle.html">Persistent_mq_handle</a> &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classipc_1_1transport_1_1sync__io_1_1Blob__stream__mq__receiver__impl.html">ipc::transport::sync_io::Blob_stream_mq_receiver_impl</a>&lt; <a class="el" href="classipc_1_1transport_1_1Persistent__mq__handle.html">Persistent_mq_handle</a> &gt;::Base =  <a class="el" href="classipc_1_1transport_1_1Blob__stream__mq__base__impl.html">Blob_stream_mq_base_impl</a>&lt;<a class="el" href="classipc_1_1transport_1_1Persistent__mq__handle.html">Persistent_mq_handle</a>&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Short-hand for our base with <code>static</code> goodies at least. </p>

<p class="definition">Definition at line <a class="el" href="sync__io_2detail_2blob__stream__mq__rcv__impl_8hpp_source.html#l00080">80</a> of file <a class="el" href="sync__io_2detail_2blob__stream__mq__rcv__impl_8hpp_source.html">blob_stream_mq_rcv_impl.hpp</a>.</p>

</div>
</div>
<a id="add17b83b9c20b617a13dcdc22e9b8d8d" name="add17b83b9c20b617a13dcdc22e9b8d8d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#add17b83b9c20b617a13dcdc22e9b8d8d">&#9670;&nbsp;</a></span>Control_cmd</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename <a class="el" href="classipc_1_1transport_1_1Persistent__mq__handle.html">Persistent_mq_handle</a> &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classipc_1_1transport_1_1sync__io_1_1Blob__stream__mq__receiver__impl.html">ipc::transport::sync_io::Blob_stream_mq_receiver_impl</a>&lt; <a class="el" href="classipc_1_1transport_1_1Persistent__mq__handle.html">Persistent_mq_handle</a> &gt;::Control_cmd =  typename <a class="el" href="classipc_1_1transport_1_1Blob__stream__mq__base__impl.html#a2e46672d40fbf38cf6054edfad69e705">Base::Control_cmd</a></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Short-hand for <a class="el" href="classipc_1_1transport_1_1Blob__stream__mq__base__impl.html#a2e46672d40fbf38cf6054edfad69e705" title="If Blob_stream_mq_sender_impl sends an empty message, in NORMAL state Blob_stream_mq_receiver enters ...">Blob_stream_mq_base_impl::Control_cmd</a>. </p>

<p class="definition">Definition at line <a class="el" href="sync__io_2detail_2blob__stream__mq__rcv__impl_8hpp_source.html#l00194">194</a> of file <a class="el" href="sync__io_2detail_2blob__stream__mq__rcv__impl_8hpp_source.html">blob_stream_mq_rcv_impl.hpp</a>.</p>

</div>
</div>
<a id="a465dcd2a80871028ba8a97402be1cf2a" name="a465dcd2a80871028ba8a97402be1cf2a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a465dcd2a80871028ba8a97402be1cf2a">&#9670;&nbsp;</a></span>Mq</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename <a class="el" href="classipc_1_1transport_1_1Persistent__mq__handle.html">Persistent_mq_handle</a> &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classipc_1_1transport_1_1sync__io_1_1Blob__stream__mq__receiver__impl.html">ipc::transport::sync_io::Blob_stream_mq_receiver_impl</a>&lt; <a class="el" href="classipc_1_1transport_1_1Persistent__mq__handle.html">Persistent_mq_handle</a> &gt;::Mq =  typename <a class="el" href="classipc_1_1transport_1_1Blob__stream__mq__base__impl.html#a8fac0ed5fff23aa42e0a601db6fee42d">Base::Mq</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Short-hand for template arg for underlying MQ handle type. </p>

<p class="definition">Definition at line <a class="el" href="sync__io_2detail_2blob__stream__mq__rcv__impl_8hpp_source.html#l00083">83</a> of file <a class="el" href="sync__io_2detail_2blob__stream__mq__rcv__impl_8hpp_source.html">blob_stream_mq_rcv_impl.hpp</a>.</p>

</div>
</div>
<h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="a3e1c13dc986985621ab05de16f9e811c" name="a3e1c13dc986985621ab05de16f9e811c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3e1c13dc986985621ab05de16f9e811c">&#9670;&nbsp;</a></span>Blob_stream_mq_receiver_impl()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename <a class="el" href="classipc_1_1transport_1_1Persistent__mq__handle.html">Persistent_mq_handle</a> &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classipc_1_1transport_1_1sync__io_1_1Blob__stream__mq__receiver__impl.html">ipc::transport::sync_io::Blob_stream_mq_receiver_impl</a>&lt; <a class="el" href="classipc_1_1transport_1_1Persistent__mq__handle.html">Persistent_mq_handle</a> &gt;::Blob_stream_mq_receiver_impl </td>
          <td>(</td>
          <td class="paramtype">flow::log::Logger *&#160;</td>
          <td class="paramname"><em>logger_ptr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceipc_1_1util.html#ae6ac47812a90d1287c61e0b7de7bc4f5">util::String_view</a>&#160;</td>
          <td class="paramname"><em>nickname_str</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classipc_1_1transport_1_1Blob__stream__mq__base__impl.html#a8fac0ed5fff23aa42e0a601db6fee42d">Mq</a> &amp;&amp;&#160;</td>
          <td class="paramname"><em>mq_moved</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceipc.html#aa3192e586cc45d3e7c22463bf2760f89">Error_code</a> *&#160;</td>
          <td class="paramname"><em>err_code</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">explicit</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>See <a class="el" href="classipc_1_1transport_1_1sync__io_1_1Blob__stream__mq__receiver.html" title="Implements sync_io::Blob_receiver concept by using an adopted Persistent_mq_handle MQ handle to an MQ...">Blob_stream_mq_receiver</a> counterpart. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">logger_ptr</td><td>See <a class="el" href="classipc_1_1transport_1_1sync__io_1_1Blob__stream__mq__receiver.html" title="Implements sync_io::Blob_receiver concept by using an adopted Persistent_mq_handle MQ handle to an MQ...">Blob_stream_mq_receiver</a> counterpart. </td></tr>
    <tr><td class="paramname">mq_moved</td><td>See <a class="el" href="classipc_1_1transport_1_1sync__io_1_1Blob__stream__mq__receiver.html" title="Implements sync_io::Blob_receiver concept by using an adopted Persistent_mq_handle MQ handle to an MQ...">Blob_stream_mq_receiver</a> counterpart. </td></tr>
    <tr><td class="paramname">nickname_str</td><td>See <a class="el" href="classipc_1_1transport_1_1sync__io_1_1Blob__stream__mq__receiver.html" title="Implements sync_io::Blob_receiver concept by using an adopted Persistent_mq_handle MQ handle to an MQ...">Blob_stream_mq_receiver</a> counterpart. </td></tr>
    <tr><td class="paramname">err_code</td><td>See <a class="el" href="classipc_1_1transport_1_1sync__io_1_1Blob__stream__mq__receiver.html" title="Implements sync_io::Blob_receiver concept by using an adopted Persistent_mq_handle MQ handle to an MQ...">Blob_stream_mq_receiver</a> counterpart. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="sync__io_2detail_2blob__stream__mq__rcv__impl_8hpp_source.html#l00476">476</a> of file <a class="el" href="sync__io_2detail_2blob__stream__mq__rcv__impl_8hpp_source.html">blob_stream_mq_rcv_impl.hpp</a>.</p>

<p class="reference">References <a class="el" href="asio__waitable__native__hndl_8cpp_source.html#l00065">ipc::util::sync_io::Asio_waitable_native_handle::assign()</a>, <a class="el" href="blob__stream__mq__impl_8hpp_source.html#l00219">ipc::transport::Blob_stream_mq_base_impl&lt; Persistent_mq_handle &gt;::ensure_unique_peer()</a>, <a class="el" href="sync__io_2detail_2blob__stream__mq__rcv__impl_8hpp_source.html#l00468">ipc::transport::sync_io::Blob_stream_mq_receiver_impl&lt; Persistent_mq_handle &gt;::m_blocking_worker</a>, <a class="el" href="sync__io_2detail_2blob__stream__mq__rcv__impl_8hpp_source.html#l00353">ipc::transport::sync_io::Blob_stream_mq_receiver_impl&lt; Persistent_mq_handle &gt;::m_ev_wait_hndl_mq</a>, <a class="el" href="sync__io_2detail_2blob__stream__mq__rcv__impl_8hpp_source.html#l00311">ipc::transport::sync_io::Blob_stream_mq_receiver_impl&lt; Persistent_mq_handle &gt;::m_mq</a>, <a class="el" href="sync__io_2detail_2blob__stream__mq__rcv__impl_8hpp_source.html#l00331">ipc::transport::sync_io::Blob_stream_mq_receiver_impl&lt; Persistent_mq_handle &gt;::m_mq_ready_reader</a>, <a class="el" href="sync__io_2detail_2blob__stream__mq__rcv__impl_8hpp_source.html#l00342">ipc::transport::sync_io::Blob_stream_mq_receiver_impl&lt; Persistent_mq_handle &gt;::m_mq_ready_writer</a>, <a class="el" href="sync__io_2detail_2blob__stream__mq__rcv__impl_8hpp_source.html#l00278">ipc::transport::sync_io::Blob_stream_mq_receiver_impl&lt; Persistent_mq_handle &gt;::m_nb_task_engine</a>, <a class="el" href="sync__io_2detail_2blob__stream__mq__rcv__impl_8hpp_source.html#l00408">ipc::transport::sync_io::Blob_stream_mq_receiver_impl&lt; Persistent_mq_handle &gt;::m_pending_err_code</a>, and <a class="el" href="sync__io_2detail_2blob__stream__mq__rcv__impl_8hpp_source.html#l01248">ipc::transport::sync_io::Blob_stream_mq_receiver_impl&lt; Persistent_mq_handle &gt;::nickname()</a>.</p>
<div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="classipc_1_1transport_1_1sync__io_1_1Blob__stream__mq__receiver__impl_a3e1c13dc986985621ab05de16f9e811c_cgraph.svg" width="887" height="203"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe>
</div>
</div>

</div>
</div>
<a id="a08712e065d9a6778a0bb18de94009f22" name="a08712e065d9a6778a0bb18de94009f22"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a08712e065d9a6778a0bb18de94009f22">&#9670;&nbsp;</a></span>~Blob_stream_mq_receiver_impl()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename <a class="el" href="classipc_1_1transport_1_1Persistent__mq__handle.html">Persistent_mq_handle</a> &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classipc_1_1transport_1_1sync__io_1_1Blob__stream__mq__receiver__impl.html">ipc::transport::sync_io::Blob_stream_mq_receiver_impl</a>&lt; <a class="el" href="classipc_1_1transport_1_1Persistent__mq__handle.html">Persistent_mq_handle</a> &gt;::~<a class="el" href="classipc_1_1transport_1_1sync__io_1_1Blob__stream__mq__receiver__impl.html">Blob_stream_mq_receiver_impl</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>See <a class="el" href="classipc_1_1transport_1_1sync__io_1_1Blob__stream__mq__receiver.html" title="Implements sync_io::Blob_receiver concept by using an adopted Persistent_mq_handle MQ handle to an MQ...">Blob_stream_mq_receiver</a> counterpart. </p>

<p class="definition">Definition at line <a class="el" href="sync__io_2detail_2blob__stream__mq__rcv__impl_8hpp_source.html#l00575">575</a> of file <a class="el" href="sync__io_2detail_2blob__stream__mq__rcv__impl_8hpp_source.html">blob_stream_mq_rcv_impl.hpp</a>.</p>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="acf5dd76c0d00746137fe6adedfa4c26d" name="acf5dd76c0d00746137fe6adedfa4c26d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acf5dd76c0d00746137fe6adedfa4c26d">&#9670;&nbsp;</a></span>absolute_name()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename <a class="el" href="classipc_1_1transport_1_1Persistent__mq__handle.html">Persistent_mq_handle</a> &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="namespaceipc_1_1transport.html#a33de1c256addb3964b839dc2dd407d24">Shared_name</a> &amp; <a class="el" href="classipc_1_1transport_1_1sync__io_1_1Blob__stream__mq__receiver__impl.html">ipc::transport::sync_io::Blob_stream_mq_receiver_impl</a>&lt; <a class="el" href="classipc_1_1transport_1_1Persistent__mq__handle.html">Persistent_mq_handle</a> &gt;::absolute_name</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>See <a class="el" href="classipc_1_1transport_1_1sync__io_1_1Blob__stream__mq__receiver.html" title="Implements sync_io::Blob_receiver concept by using an adopted Persistent_mq_handle MQ handle to an MQ...">Blob_stream_mq_receiver</a> counterpart, but assuming PEER state. </p>
<dl class="section return"><dt>Returns</dt><dd>See <a class="el" href="classipc_1_1transport_1_1sync__io_1_1Blob__stream__mq__receiver.html" title="Implements sync_io::Blob_receiver concept by using an adopted Persistent_mq_handle MQ handle to an MQ...">Blob_stream_mq_receiver</a> counterpart. </dd></dl>

<p class="definition">Definition at line <a class="el" href="sync__io_2detail_2blob__stream__mq__rcv__impl_8hpp_source.html#l01242">1242</a> of file <a class="el" href="sync__io_2detail_2blob__stream__mq__rcv__impl_8hpp_source.html">blob_stream_mq_rcv_impl.hpp</a>.</p>

<p class="reference">Referenced by <a class="el" href="sync__io_2detail_2blob__stream__mq__rcv__impl_8hpp_source.html#l01254">ipc::transport::sync_io::Blob_stream_mq_receiver_impl&lt; Persistent_mq_handle &gt;::operator&lt;&lt;()</a>.</p>
<div class="dynheader">
Here is the caller graph for this function:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="classipc_1_1transport_1_1sync__io_1_1Blob__stream__mq__receiver__impl_acf5dd76c0d00746137fe6adedfa4c26d_icgraph.svg" width="424" height="59"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe>
</div>
</div>

</div>
</div>
<a id="a8d1a81d379e1a31031adb9cccbbabd35" name="a8d1a81d379e1a31031adb9cccbbabd35"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8d1a81d379e1a31031adb9cccbbabd35">&#9670;&nbsp;</a></span>async_receive_blob()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename <a class="el" href="classipc_1_1transport_1_1Persistent__mq__handle.html">Persistent_mq_handle</a> &gt; </div>
<div class="memtemplate">
template&lt;typename Task_err_sz &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classipc_1_1transport_1_1sync__io_1_1Blob__stream__mq__receiver__impl.html">ipc::transport::sync_io::Blob_stream_mq_receiver_impl</a>&lt; <a class="el" href="classipc_1_1transport_1_1Persistent__mq__handle.html">Persistent_mq_handle</a> &gt;::async_receive_blob </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespaceipc_1_1util.html#a6cb62ae434900f3a8915b33ec5d61a96">util::Blob_mutable</a> &amp;&#160;</td>
          <td class="paramname"><em>target_blob</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceipc.html#aa3192e586cc45d3e7c22463bf2760f89">Error_code</a> *&#160;</td>
          <td class="paramname"><em>sync_err_code</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t *&#160;</td>
          <td class="paramname"><em>sync_sz</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Task_err_sz &amp;&amp;&#160;</td>
          <td class="paramname"><em>on_done_func</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>See <a class="el" href="classipc_1_1transport_1_1sync__io_1_1Blob__stream__mq__receiver.html" title="Implements sync_io::Blob_receiver concept by using an adopted Persistent_mq_handle MQ handle to an MQ...">Blob_stream_mq_receiver</a> counterpart, but assuming PEER state. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">target_blob</td><td>See <a class="el" href="classipc_1_1transport_1_1sync__io_1_1Blob__stream__mq__receiver.html" title="Implements sync_io::Blob_receiver concept by using an adopted Persistent_mq_handle MQ handle to an MQ...">Blob_stream_mq_receiver</a> counterpart. </td></tr>
    <tr><td class="paramname">sync_err_code</td><td>See <a class="el" href="classipc_1_1transport_1_1sync__io_1_1Blob__stream__mq__receiver.html" title="Implements sync_io::Blob_receiver concept by using an adopted Persistent_mq_handle MQ handle to an MQ...">Blob_stream_mq_receiver</a> counterpart. </td></tr>
    <tr><td class="paramname">sync_sz</td><td>See <a class="el" href="classipc_1_1transport_1_1sync__io_1_1Blob__stream__mq__receiver.html" title="Implements sync_io::Blob_receiver concept by using an adopted Persistent_mq_handle MQ handle to an MQ...">Blob_stream_mq_receiver</a> counterpart. </td></tr>
    <tr><td class="paramname">on_done_func</td><td>See <a class="el" href="classipc_1_1transport_1_1sync__io_1_1Blob__stream__mq__receiver.html" title="Implements sync_io::Blob_receiver concept by using an adopted Persistent_mq_handle MQ handle to an MQ...">Blob_stream_mq_receiver</a> counterpart. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>See <a class="el" href="classipc_1_1transport_1_1sync__io_1_1Blob__stream__mq__receiver.html" title="Implements sync_io::Blob_receiver concept by using an adopted Persistent_mq_handle MQ handle to an MQ...">Blob_stream_mq_receiver</a> counterpart. </dd></dl>

<p class="definition">Definition at line <a class="el" href="sync__io_2detail_2blob__stream__mq__rcv__impl_8hpp_source.html#l00667">667</a> of file <a class="el" href="sync__io_2detail_2blob__stream__mq__rcv__impl_8hpp_source.html">blob_stream_mq_rcv_impl.hpp</a>.</p>

<p class="reference">References <a class="el" href="namespaceipc_1_1transport_1_1error.html#adfef15ef4e76cc55d652fbd9c2797297ac416e988563e44bf15fc6a81743eef53">ipc::transport::error::S_INVALID_ARGUMENT</a>, and <a class="el" href="namespaceipc_1_1transport_1_1error.html#adfef15ef4e76cc55d652fbd9c2797297aa667487757f9d6300f6888bac40bcc24">ipc::transport::error::S_SYNC_IO_WOULD_BLOCK</a>.</p>

</div>
</div>
<a id="a878fa03873bcdea5aa9d938a4791325f" name="a878fa03873bcdea5aa9d938a4791325f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a878fa03873bcdea5aa9d938a4791325f">&#9670;&nbsp;</a></span>idle_timer_run()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename <a class="el" href="classipc_1_1transport_1_1Persistent__mq__handle.html">Persistent_mq_handle</a> &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classipc_1_1transport_1_1sync__io_1_1Blob__stream__mq__receiver__impl.html">ipc::transport::sync_io::Blob_stream_mq_receiver_impl</a>&lt; <a class="el" href="classipc_1_1transport_1_1Persistent__mq__handle.html">Persistent_mq_handle</a> &gt;::idle_timer_run </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespaceipc_1_1util.html#ac66141280c3b7295a86b65209f31cc58">util::Fine_duration</a>&#160;</td>
          <td class="paramname"><em>timeout</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>See <a class="el" href="classipc_1_1transport_1_1sync__io_1_1Blob__stream__mq__receiver.html" title="Implements sync_io::Blob_receiver concept by using an adopted Persistent_mq_handle MQ handle to an MQ...">Blob_stream_mq_receiver</a> counterpart, but assuming PEER state. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">timeout</td><td>See <a class="el" href="classipc_1_1transport_1_1sync__io_1_1Blob__stream__mq__receiver.html" title="Implements sync_io::Blob_receiver concept by using an adopted Persistent_mq_handle MQ handle to an MQ...">Blob_stream_mq_receiver</a> counterpart. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>See <a class="el" href="classipc_1_1transport_1_1sync__io_1_1Blob__stream__mq__receiver.html" title="Implements sync_io::Blob_receiver concept by using an adopted Persistent_mq_handle MQ handle to an MQ...">Blob_stream_mq_receiver</a> counterpart. </dd></dl>

<p class="definition">Definition at line <a class="el" href="sync__io_2detail_2blob__stream__mq__rcv__impl_8hpp_source.html#l00777">777</a> of file <a class="el" href="sync__io_2detail_2blob__stream__mq__rcv__impl_8hpp_source.html">blob_stream_mq_rcv_impl.hpp</a>.</p>

</div>
</div>
<a id="adaf3579ec3abf0b5d85258965d264660" name="adaf3579ec3abf0b5d85258965d264660"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adaf3579ec3abf0b5d85258965d264660">&#9670;&nbsp;</a></span>nickname()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename <a class="el" href="classipc_1_1transport_1_1Persistent__mq__handle.html">Persistent_mq_handle</a> &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">const std::string &amp; <a class="el" href="classipc_1_1transport_1_1sync__io_1_1Blob__stream__mq__receiver__impl.html">ipc::transport::sync_io::Blob_stream_mq_receiver_impl</a>&lt; <a class="el" href="classipc_1_1transport_1_1Persistent__mq__handle.html">Persistent_mq_handle</a> &gt;::nickname</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>See <a class="el" href="classipc_1_1transport_1_1sync__io_1_1Blob__stream__mq__receiver.html" title="Implements sync_io::Blob_receiver concept by using an adopted Persistent_mq_handle MQ handle to an MQ...">Blob_stream_mq_receiver</a> counterpart, but assuming PEER state. </p>
<dl class="section return"><dt>Returns</dt><dd>See <a class="el" href="classipc_1_1transport_1_1sync__io_1_1Blob__stream__mq__receiver.html" title="Implements sync_io::Blob_receiver concept by using an adopted Persistent_mq_handle MQ handle to an MQ...">Blob_stream_mq_receiver</a> counterpart. </dd></dl>

<p class="definition">Definition at line <a class="el" href="sync__io_2detail_2blob__stream__mq__rcv__impl_8hpp_source.html#l01248">1248</a> of file <a class="el" href="sync__io_2detail_2blob__stream__mq__rcv__impl_8hpp_source.html">blob_stream_mq_rcv_impl.hpp</a>.</p>

<p class="reference">Referenced by <a class="el" href="sync__io_2detail_2blob__stream__mq__rcv__impl_8hpp_source.html#l00477">ipc::transport::sync_io::Blob_stream_mq_receiver_impl&lt; Persistent_mq_handle &gt;::Blob_stream_mq_receiver_impl()</a>, and <a class="el" href="sync__io_2detail_2blob__stream__mq__rcv__impl_8hpp_source.html#l01254">ipc::transport::sync_io::Blob_stream_mq_receiver_impl&lt; Persistent_mq_handle &gt;::operator&lt;&lt;()</a>.</p>
<div class="dynheader">
Here is the caller graph for this function:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="classipc_1_1transport_1_1sync__io_1_1Blob__stream__mq__receiver__impl_adaf3579ec3abf0b5d85258965d264660_icgraph.svg" width="466" height="131"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe>
</div>
</div>

</div>
</div>
<a id="ad98d5cf3970b4cef4932d59679c7d5b9" name="ad98d5cf3970b4cef4932d59679c7d5b9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad98d5cf3970b4cef4932d59679c7d5b9">&#9670;&nbsp;</a></span>not_idle()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename <a class="el" href="classipc_1_1transport_1_1Persistent__mq__handle.html">Persistent_mq_handle</a> &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classipc_1_1transport_1_1sync__io_1_1Blob__stream__mq__receiver__impl.html">ipc::transport::sync_io::Blob_stream_mq_receiver_impl</a>&lt; <a class="el" href="classipc_1_1transport_1_1Persistent__mq__handle.html">Persistent_mq_handle</a> &gt;::not_idle</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>No-ops if <a class="el" href="classipc_1_1transport_1_1sync__io_1_1Blob__stream__mq__receiver__impl.html#a878fa03873bcdea5aa9d938a4791325f" title="See Blob_stream_mq_receiver counterpart, but assuming PEER state.">idle_timer_run()</a> is not engaged; otherwise reacts to non-idleness of the in-pipe by rescheduling idle timer to occur in <a class="el" href="classipc_1_1transport_1_1sync__io_1_1Blob__stream__mq__receiver__impl.html#a370d5984484667dae6fd227e7ef0d4ff" title="timeout from idle_timer_run() args; or zero() if not yet called.">m_idle_timeout</a> again. </p>
<p >(Other code calls this, as of this writing, on receipt of a complete message.)</p>
<p >Note that this can only occur while an <a class="el" href="classipc_1_1transport_1_1sync__io_1_1Blob__stream__mq__receiver__impl.html#a8d1a81d379e1a31031adb9cccbbabd35" title="See Blob_stream_mq_receiver counterpart, but assuming PEER state.">async_receive_blob()</a> is in progress; as otherwise we will not be reading the low-level pipe at all. This is a requirement for using <a class="el" href="classipc_1_1transport_1_1sync__io_1_1Blob__stream__mq__receiver__impl.html#a878fa03873bcdea5aa9d938a4791325f" title="See Blob_stream_mq_receiver counterpart, but assuming PEER state.">idle_timer_run()</a>, so it's not our fault, if they don't do it and get timed-out. </p>

<p class="definition">Definition at line <a class="el" href="sync__io_2detail_2blob__stream__mq__rcv__impl_8hpp_source.html#l00869">869</a> of file <a class="el" href="sync__io_2detail_2blob__stream__mq__rcv__impl_8hpp_source.html">blob_stream_mq_rcv_impl.hpp</a>.</p>

</div>
</div>
<a id="a5c46890c19e4fe69d9276647205af786" name="a5c46890c19e4fe69d9276647205af786"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5c46890c19e4fe69d9276647205af786">&#9670;&nbsp;</a></span>on_ev_idle_timer_fired()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename <a class="el" href="classipc_1_1transport_1_1Persistent__mq__handle.html">Persistent_mq_handle</a> &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classipc_1_1transport_1_1sync__io_1_1Blob__stream__mq__receiver__impl.html">ipc::transport::sync_io::Blob_stream_mq_receiver_impl</a>&lt; <a class="el" href="classipc_1_1transport_1_1Persistent__mq__handle.html">Persistent_mq_handle</a> &gt;::on_ev_idle_timer_fired</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Handler for the async-wait, via <a class="el" href="classipc_1_1util_1_1sync__io_1_1Timer__event__emitter.html" title="An object of this type, used internally to implement sync_io-pattern objects that require timer event...">util::sync_io::Timer_event_emitter</a>, of the idle timer firing; if still relevant it records the idle-timeout error in <a class="el" href="classipc_1_1transport_1_1sync__io_1_1Blob__stream__mq__receiver__impl.html#a415d72c8ed4bed42fc84bf46f716742a" title="The first and only MQ-hosing error condition detected when attempting to low-level-read on m_mq; or f...">m_pending_err_code</a>; and if an <a class="el" href="classipc_1_1transport_1_1sync__io_1_1Blob__stream__mq__receiver__impl.html#a8d1a81d379e1a31031adb9cccbbabd35" title="See Blob_stream_mq_receiver counterpart, but assuming PEER state.">async_receive_blob()</a> is in progress (awaiting data via async-wait), it completes that operation with the appropriate idle-timeout error (completion handler in <a class="el" href="classipc_1_1transport_1_1sync__io_1_1Blob__stream__mq__receiver__impl.html#a819d349f5cafcba88f3dff63968d74b0" title="Null if no async_receive_blob()` is currently pending; else describes the arguments to that pending a...">m_user_request</a> runs synchronously). </p>
<p >If not still relevant &ndash; <a class="el" href="classipc_1_1transport_1_1sync__io_1_1Blob__stream__mq__receiver__impl.html#a415d72c8ed4bed42fc84bf46f716742a" title="The first and only MQ-hosing error condition detected when attempting to low-level-read on m_mq; or f...">m_pending_err_code</a> already is truthy &ndash; then no-ops. </p>

<p class="definition">Definition at line <a class="el" href="sync__io_2detail_2blob__stream__mq__rcv__impl_8hpp_source.html#l00834">834</a> of file <a class="el" href="sync__io_2detail_2blob__stream__mq__rcv__impl_8hpp_source.html">blob_stream_mq_rcv_impl.hpp</a>.</p>

<p class="reference">References <a class="el" href="namespaceipc_1_1transport_1_1error.html#adfef15ef4e76cc55d652fbd9c2797297aba920b52e9801e4927dd346ad83ce815">ipc::transport::error::S_RECEIVER_IDLE_TIMEOUT</a>.</p>

</div>
</div>
<a id="a013d5b8cd991e0ba9d2e26a0f532fed8" name="a013d5b8cd991e0ba9d2e26a0f532fed8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a013d5b8cd991e0ba9d2e26a0f532fed8">&#9670;&nbsp;</a></span>op_started()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename <a class="el" href="classipc_1_1transport_1_1Persistent__mq__handle.html">Persistent_mq_handle</a> &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classipc_1_1transport_1_1sync__io_1_1Blob__stream__mq__receiver__impl.html">ipc::transport::sync_io::Blob_stream_mq_receiver_impl</a>&lt; <a class="el" href="classipc_1_1transport_1_1Persistent__mq__handle.html">Persistent_mq_handle</a> &gt;::op_started </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespaceipc_1_1util.html#ae6ac47812a90d1287c61e0b7de7bc4f5">util::String_view</a>&#160;</td>
          <td class="paramname"><em>context</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Helper that returns <code>true</code> silently if <code>start_*_ops()</code> has been called; else logs WARNING and returns <code>false</code>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">context</td><td>For logging: the algorithmic context (function name or whatever). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>See above. </dd></dl>

<p class="definition">Definition at line <a class="el" href="sync__io_2detail_2blob__stream__mq__rcv__impl_8hpp_source.html#l00652">652</a> of file <a class="el" href="sync__io_2detail_2blob__stream__mq__rcv__impl_8hpp_source.html">blob_stream_mq_rcv_impl.hpp</a>.</p>

</div>
</div>
<a id="a6c1e656d4ce90d13b4f2f38fa5ad5cf9" name="a6c1e656d4ce90d13b4f2f38fa5ad5cf9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6c1e656d4ce90d13b4f2f38fa5ad5cf9">&#9670;&nbsp;</a></span>read_msg()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename <a class="el" href="classipc_1_1transport_1_1Persistent__mq__handle.html">Persistent_mq_handle</a> &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classipc_1_1transport_1_1sync__io_1_1Blob__stream__mq__receiver__impl.html">ipc::transport::sync_io::Blob_stream_mq_receiver_impl</a>&lt; <a class="el" href="classipc_1_1transport_1_1Persistent__mq__handle.html">Persistent_mq_handle</a> &gt;::read_msg </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespaceipc.html#aa3192e586cc45d3e7c22463bf2760f89">Error_code</a> *&#160;</td>
          <td class="paramname"><em>sync_err_code</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t *&#160;</td>
          <td class="paramname"><em>sync_sz</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Begins read chain (completing it as synchronously as possible, async-completing the rest) for the next in-message. </p>
<p >Given the pre-condition that (1) <a class="el" href="classipc_1_1transport_1_1sync__io_1_1Blob__stream__mq__receiver__impl.html#a8d1a81d379e1a31031adb9cccbbabd35" title="See Blob_stream_mq_receiver counterpart, but assuming PEER state.">async_receive_blob()</a> is oustanding (<a class="el" href="classipc_1_1transport_1_1sync__io_1_1Blob__stream__mq__receiver__impl.html#a819d349f5cafcba88f3dff63968d74b0" title="Null if no async_receive_blob()` is currently pending; else describes the arguments to that pending a...">m_user_request</a> not null), (2) in the pipe we expect payload 1 (of 1 or 2) of the next in-message next, (3) there is no known pipe error already detected, and (4) there is no known would-block condition on the in-pipe: this reads (asynchronously if would-block is encountered at some point in there) the next message.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">sync_err_code</td><td>Outcome out-arg: <a class="el" href="namespaceipc_1_1transport_1_1error.html#adfef15ef4e76cc55d652fbd9c2797297aa667487757f9d6300f6888bac40bcc24" title="A sync_io operation could not immediately complete; it will complete contingent on active async-wait ...">error::Code::S_SYNC_IO_WOULD_BLOCK</a> if async-wait triggered, as message could not be fully read synchronously; falsy if message fully read synchronously; non-would-block truthy value, if pipe-hosing condition encountered. </td></tr>
    <tr><td class="paramname">sync_sz</td><td>Outcome out-arg: If <code>*sync_err_code</code> truthy then zero; else size of completed in-message. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="sync__io_2detail_2blob__stream__mq__rcv__impl_8hpp_source.html#l00905">905</a> of file <a class="el" href="sync__io_2detail_2blob__stream__mq__rcv__impl_8hpp_source.html">blob_stream_mq_rcv_impl.hpp</a>.</p>

<p class="reference">References <a class="el" href="ipc__core_2src_2ipc_2util_2detail_2util_8cpp_source.html#l00096">ipc::util::pipe_consume()</a>, <a class="el" href="ipc__core_2src_2ipc_2util_2detail_2util_8cpp_source.html#l00067">ipc::util::pipe_produce()</a>, <a class="el" href="namespaceipc_1_1transport_1_1error.html#adfef15ef4e76cc55d652fbd9c2797297a0ba1798bc135b43eebd7ce2481151348">ipc::transport::error::S_BLOB_STREAM_MQ_RECEIVER_BAD_CTL_CMD</a>, <a class="el" href="namespaceipc_1_1transport_1_1error.html#adfef15ef4e76cc55d652fbd9c2797297a291f8a813c292ccdb475c345181653ac">ipc::transport::error::S_INTERRUPTED</a>, <a class="el" href="namespaceipc_1_1transport_1_1error.html#adfef15ef4e76cc55d652fbd9c2797297aad44f87d53255ba573d57086dfeab805">ipc::transport::error::S_RECEIVES_FINISHED_CANNOT_RECEIVE</a>, <a class="el" href="namespaceipc_1_1transport_1_1error.html#adfef15ef4e76cc55d652fbd9c2797297aa667487757f9d6300f6888bac40bcc24">ipc::transport::error::S_SYNC_IO_WOULD_BLOCK</a>, and <a class="el" href="protocol__negotiator_8hpp_source.html#l00215">ipc::transport::Protocol_negotiator::S_VER_UNKNOWN</a>.</p>
<div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="classipc_1_1transport_1_1sync__io_1_1Blob__stream__mq__receiver__impl_a6c1e656d4ce90d13b4f2f38fa5ad5cf9_cgraph.svg" width="392" height="83"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe>
</div>
</div>

</div>
</div>
<a id="a8df5929fc0f3413079df8e2be08bf972" name="a8df5929fc0f3413079df8e2be08bf972"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8df5929fc0f3413079df8e2be08bf972">&#9670;&nbsp;</a></span>receive_blob_max_size()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename <a class="el" href="classipc_1_1transport_1_1Persistent__mq__handle.html">Persistent_mq_handle</a> &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">size_t <a class="el" href="classipc_1_1transport_1_1sync__io_1_1Blob__stream__mq__receiver__impl.html">ipc::transport::sync_io::Blob_stream_mq_receiver_impl</a>&lt; <a class="el" href="classipc_1_1transport_1_1Persistent__mq__handle.html">Persistent_mq_handle</a> &gt;::receive_blob_max_size</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>See <a class="el" href="classipc_1_1transport_1_1sync__io_1_1Blob__stream__mq__receiver.html" title="Implements sync_io::Blob_receiver concept by using an adopted Persistent_mq_handle MQ handle to an MQ...">Blob_stream_mq_receiver</a> counterpart, but assuming PEER state. </p>
<dl class="section return"><dt>Returns</dt><dd>See <a class="el" href="classipc_1_1transport_1_1sync__io_1_1Blob__stream__mq__receiver.html" title="Implements sync_io::Blob_receiver concept by using an adopted Persistent_mq_handle MQ handle to an MQ...">Blob_stream_mq_receiver</a> counterpart. </dd></dl>

<p class="definition">Definition at line <a class="el" href="sync__io_2detail_2blob__stream__mq__rcv__impl_8hpp_source.html#l01236">1236</a> of file <a class="el" href="sync__io_2detail_2blob__stream__mq__rcv__impl_8hpp_source.html">blob_stream_mq_rcv_impl.hpp</a>.</p>

</div>
</div>
<a id="a3ee71a39a443e78c86f82652d8d0601e" name="a3ee71a39a443e78c86f82652d8d0601e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3ee71a39a443e78c86f82652d8d0601e">&#9670;&nbsp;</a></span>replace_event_wait_handles()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename <a class="el" href="classipc_1_1transport_1_1Persistent__mq__handle.html">Persistent_mq_handle</a> &gt; </div>
<div class="memtemplate">
template&lt;typename Create_ev_wait_hndl_func &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classipc_1_1transport_1_1sync__io_1_1Blob__stream__mq__receiver__impl.html">ipc::transport::sync_io::Blob_stream_mq_receiver_impl</a>&lt; <a class="el" href="classipc_1_1transport_1_1Persistent__mq__handle.html">Persistent_mq_handle</a> &gt;::replace_event_wait_handles </td>
          <td>(</td>
          <td class="paramtype">const Create_ev_wait_hndl_func &amp;&#160;</td>
          <td class="paramname"><em>create_ev_wait_hndl_func</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>See <a class="el" href="classipc_1_1transport_1_1sync__io_1_1Blob__stream__mq__receiver.html" title="Implements sync_io::Blob_receiver concept by using an adopted Persistent_mq_handle MQ handle to an MQ...">Blob_stream_mq_receiver</a> counterpart. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Create_ev_wait_hndl_func</td><td>See <a class="el" href="classipc_1_1transport_1_1sync__io_1_1Blob__stream__mq__receiver.html" title="Implements sync_io::Blob_receiver concept by using an adopted Persistent_mq_handle MQ handle to an MQ...">Blob_stream_mq_receiver</a> counterpart. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">create_ev_wait_hndl_func</td><td>See <a class="el" href="classipc_1_1transport_1_1sync__io_1_1Blob__stream__mq__receiver.html" title="Implements sync_io::Blob_receiver concept by using an adopted Persistent_mq_handle MQ handle to an MQ...">Blob_stream_mq_receiver</a> counterpart. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>See <a class="el" href="classipc_1_1transport_1_1sync__io_1_1Blob__stream__mq__receiver.html" title="Implements sync_io::Blob_receiver concept by using an adopted Persistent_mq_handle MQ handle to an MQ...">Blob_stream_mq_receiver</a> counterpart. </dd></dl>

<p class="definition">Definition at line <a class="el" href="sync__io_2detail_2blob__stream__mq__rcv__impl_8hpp_source.html#l00594">594</a> of file <a class="el" href="sync__io_2detail_2blob__stream__mq__rcv__impl_8hpp_source.html">blob_stream_mq_rcv_impl.hpp</a>.</p>

<p class="reference">References <a class="el" href="native__handle_8hpp_source.html#l00084">ipc::util::Native_handle::m_native_handle</a>.</p>

</div>
</div>
<a id="a1e286f452b6e3a74d64e1f795795afe2" name="a1e286f452b6e3a74d64e1f795795afe2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1e286f452b6e3a74d64e1f795795afe2">&#9670;&nbsp;</a></span>start_receive_blob_ops()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename <a class="el" href="classipc_1_1transport_1_1Persistent__mq__handle.html">Persistent_mq_handle</a> &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classipc_1_1transport_1_1sync__io_1_1Blob__stream__mq__receiver__impl.html">ipc::transport::sync_io::Blob_stream_mq_receiver_impl</a>&lt; <a class="el" href="classipc_1_1transport_1_1Persistent__mq__handle.html">Persistent_mq_handle</a> &gt;::start_receive_blob_ops </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespaceipc_1_1util_1_1sync__io.html#aa0b9a3cc6bdc7dedbef4f9e06851aa24">util::sync_io::Event_wait_func</a> &amp;&amp;&#160;</td>
          <td class="paramname"><em>ev_wait_func</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>See <a class="el" href="classipc_1_1transport_1_1sync__io_1_1Blob__stream__mq__receiver.html" title="Implements sync_io::Blob_receiver concept by using an adopted Persistent_mq_handle MQ handle to an MQ...">Blob_stream_mq_receiver</a> counterpart. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ev_wait_func</td><td>See <a class="el" href="classipc_1_1transport_1_1sync__io_1_1Blob__stream__mq__receiver.html" title="Implements sync_io::Blob_receiver concept by using an adopted Persistent_mq_handle MQ handle to an MQ...">Blob_stream_mq_receiver</a> counterpart. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>See <a class="el" href="classipc_1_1transport_1_1sync__io_1_1Blob__stream__mq__receiver.html" title="Implements sync_io::Blob_receiver concept by using an adopted Persistent_mq_handle MQ handle to an MQ...">Blob_stream_mq_receiver</a> counterpart. </dd></dl>

<p class="definition">Definition at line <a class="el" href="sync__io_2detail_2blob__stream__mq__rcv__impl_8hpp_source.html#l00634">634</a> of file <a class="el" href="sync__io_2detail_2blob__stream__mq__rcv__impl_8hpp_source.html">blob_stream_mq_rcv_impl.hpp</a>.</p>

</div>
</div>
<h2 class="groupheader">Friends And Related Function Documentation</h2>
<a id="a4efecbe0fe86aa7d61b86f9c5edf20b4" name="a4efecbe0fe86aa7d61b86f9c5edf20b4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4efecbe0fe86aa7d61b86f9c5edf20b4">&#9670;&nbsp;</a></span>operator&lt;&lt;()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename <a class="el" href="classipc_1_1transport_1_1Persistent__mq__handle.html">Persistent_mq_handle</a> &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::ostream &amp; operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>os</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classipc_1_1transport_1_1sync__io_1_1Blob__stream__mq__receiver__impl.html">Blob_stream_mq_receiver_impl</a>&lt; <a class="el" href="classipc_1_1transport_1_1Persistent__mq__handle.html">Persistent_mq_handle</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>val</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Prints string representation of the given <code><a class="el" href="classipc_1_1transport_1_1sync__io_1_1Blob__stream__mq__receiver__impl.html" title="Internal, non-movable pImpl-lite implementation of sync_io::Blob_stream_mq_receiver class template.">Blob_stream_mq_receiver_impl</a></code> to the given <code>ostream</code>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">os</td><td>Stream to which to write. </td></tr>
    <tr><td class="paramname">val</td><td>Object to serialize. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>os</code>. </dd></dl>

<p class="definition">Definition at line <a class="el" href="sync__io_2detail_2blob__stream__mq__rcv__impl_8hpp_source.html#l01254">1254</a> of file <a class="el" href="sync__io_2detail_2blob__stream__mq__rcv__impl_8hpp_source.html">blob_stream_mq_rcv_impl.hpp</a>.</p>

<p class="reference">References <a class="el" href="sync__io_2detail_2blob__stream__mq__rcv__impl_8hpp_source.html#l01242">ipc::transport::sync_io::Blob_stream_mq_receiver_impl&lt; Persistent_mq_handle &gt;::absolute_name()</a>, and <a class="el" href="sync__io_2detail_2blob__stream__mq__rcv__impl_8hpp_source.html#l01248">ipc::transport::sync_io::Blob_stream_mq_receiver_impl&lt; Persistent_mq_handle &gt;::nickname()</a>.</p>
<div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="classipc_1_1transport_1_1sync__io_1_1Blob__stream__mq__receiver__impl_a4efecbe0fe86aa7d61b86f9c5edf20b4_cgraph.svg" width="424" height="131"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe>
</div>
</div>

</div>
</div>
<h2 class="groupheader">Member Data Documentation</h2>
<a id="add6affc3ee78f02c3a48a10115ec82ea" name="add6affc3ee78f02c3a48a10115ec82ea"></a>
<h2 class="memtitle"><span class="permalink"><a href="#add6affc3ee78f02c3a48a10115ec82ea">&#9670;&nbsp;</a></span>m_absolute_name</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename <a class="el" href="classipc_1_1transport_1_1Persistent__mq__handle.html">Persistent_mq_handle</a> &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="namespaceipc_1_1transport.html#a33de1c256addb3964b839dc2dd407d24">Shared_name</a> <a class="el" href="classipc_1_1transport_1_1sync__io_1_1Blob__stream__mq__receiver__impl.html">ipc::transport::sync_io::Blob_stream_mq_receiver_impl</a>&lt; <a class="el" href="classipc_1_1transport_1_1Persistent__mq__handle.html">Persistent_mq_handle</a> &gt;::m_absolute_name</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>See <a class="el" href="classipc_1_1transport_1_1sync__io_1_1Blob__stream__mq__receiver__impl.html#acf5dd76c0d00746137fe6adedfa4c26d" title="See Blob_stream_mq_receiver counterpart, but assuming PEER state.">absolute_name()</a>. </p>

<p class="definition">Definition at line <a class="el" href="sync__io_2detail_2blob__stream__mq__rcv__impl_8hpp_source.html#l00261">261</a> of file <a class="el" href="sync__io_2detail_2blob__stream__mq__rcv__impl_8hpp_source.html">blob_stream_mq_rcv_impl.hpp</a>.</p>

</div>
</div>
<a id="ad233c7b57cbb817fb243bec5d338ec2e" name="ad233c7b57cbb817fb243bec5d338ec2e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad233c7b57cbb817fb243bec5d338ec2e">&#9670;&nbsp;</a></span>m_blocking_worker</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename <a class="el" href="classipc_1_1transport_1_1Persistent__mq__handle.html">Persistent_mq_handle</a> &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::optional&lt;flow::async::Single_thread_task_loop&gt; <a class="el" href="classipc_1_1transport_1_1sync__io_1_1Blob__stream__mq__receiver__impl.html">ipc::transport::sync_io::Blob_stream_mq_receiver_impl</a>&lt; <a class="el" href="classipc_1_1transport_1_1Persistent__mq__handle.html">Persistent_mq_handle</a> &gt;::m_blocking_worker</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Worker thread W always in one of 2 states: idle; or (when <a class="el" href="classipc_1_1transport_1_1sync__io_1_1Blob__stream__mq__receiver__impl.html#ae71fa0a5594915910b0b8dd88743f62e" title="The MQ handle adopted by the ctor, through which nb-receives and blocking-waits are executed.">m_mq</a> is in would-block condition) executing an indefinite, interrupting blocking wait for transmissibility of <a class="el" href="classipc_1_1transport_1_1sync__io_1_1Blob__stream__mq__receiver__impl.html#ae71fa0a5594915910b0b8dd88743f62e" title="The MQ handle adopted by the ctor, through which nb-receives and blocking-waits are executed.">m_mq</a>. </p>
<p >When thread U wants to receive a payload but gets would-block, it issues the wait on this thread W and a <code><a class="el" href="namespaceipc_1_1transport_1_1sync__io.html" title="sync_io-pattern counterparts to async-I/O-pattern object types in parent namespace ipc::transport.">sync_io</a></code>-pattern async-wait for <a class="el" href="classipc_1_1transport_1_1sync__io_1_1Blob__stream__mq__receiver__impl.html#a87df1a6c9a98542a8fb00a9d85570c64" title="Descriptor waitable by outside event loop async-waits  storing the same Native_handle as (and thus b...">m_ev_wait_hndl_mq</a>; once that wait completes in thread W, it writes a byte to an internal IPC-pipe. <a class="el" href="classipc_1_1transport_1_1sync__io_1_1Blob__stream__mq__receiver__impl.html#a87df1a6c9a98542a8fb00a9d85570c64" title="Descriptor waitable by outside event loop async-waits  storing the same Native_handle as (and thus b...">m_ev_wait_hndl_mq</a> becomes readable, the outside event loop lets <code>*this</code> know, which completes the async-wait.</p>
<p >In dtor we stop thread W, including using <a class="el" href="classipc_1_1transport_1_1Persistent__mq__handle.html#a206333d3eb619588d17812f8f49013a2" title="Enables receives-interrupted mode: is_receivable() (future calls), receive() (future or concurrent ca...">Persistent_mq_handle::interrupt_receives()</a> to abort the indefinite wait in thread W, as it will no longer be used once <code>*this</code> is destroyed.</p>
<p >Ordering: If we want to let things get auto-destroyed without explicit <code>m_blocking_worker-&gt;stop()</code> or nullifying wrappers in an explicit order, then this must be declared after <a class="el" href="classipc_1_1transport_1_1sync__io_1_1Blob__stream__mq__receiver__impl.html#ae71fa0a5594915910b0b8dd88743f62e" title="The MQ handle adopted by the ctor, through which nb-receives and blocking-waits are executed.">m_mq</a>. Otherwise code may still be finishing up in thread W when <a class="el" href="classipc_1_1transport_1_1sync__io_1_1Blob__stream__mq__receiver__impl.html#ae71fa0a5594915910b0b8dd88743f62e" title="The MQ handle adopted by the ctor, through which nb-receives and blocking-waits are executed.">m_mq</a> is destroyed already. Anyway &ndash; as long as this is destroyed or <code>.stop()</code>ed before <a class="el" href="classipc_1_1transport_1_1sync__io_1_1Blob__stream__mq__receiver__impl.html#ae71fa0a5594915910b0b8dd88743f62e" title="The MQ handle adopted by the ctor, through which nb-receives and blocking-waits are executed.">m_mq</a> is gone, you're cool.</p>
<p >Never touched if <a class="el" href="classipc_1_1transport_1_1Persistent__mq__handle.html#ac2c0b560893c6a8b71aac0e748770076" title="true if and only if native_handle() method exists, and the returned value may be waited-on by poll()/...">Persistent_mq_handle::S_HAS_NATIVE_HANDLE</a>. </p>

<p class="definition">Definition at line <a class="el" href="sync__io_2detail_2blob__stream__mq__rcv__impl_8hpp_source.html#l00468">468</a> of file <a class="el" href="sync__io_2detail_2blob__stream__mq__rcv__impl_8hpp_source.html">blob_stream_mq_rcv_impl.hpp</a>.</p>

<p class="reference">Referenced by <a class="el" href="sync__io_2detail_2blob__stream__mq__rcv__impl_8hpp_source.html#l00477">ipc::transport::sync_io::Blob_stream_mq_receiver_impl&lt; Persistent_mq_handle &gt;::Blob_stream_mq_receiver_impl()</a>.</p>

</div>
</div>
<a id="a276f39d3d52038a341bf2ec86b4640ef" name="a276f39d3d52038a341bf2ec86b4640ef"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a276f39d3d52038a341bf2ec86b4640ef">&#9670;&nbsp;</a></span>m_control_state</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename <a class="el" href="classipc_1_1transport_1_1Persistent__mq__handle.html">Persistent_mq_handle</a> &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classipc_1_1transport_1_1sync__io_1_1Blob__stream__mq__receiver__impl.html">ipc::transport::sync_io::Blob_stream_mq_receiver_impl</a>&lt; <a class="el" href="classipc_1_1transport_1_1Persistent__mq__handle.html">Persistent_mq_handle</a> &gt;::m_control_state</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>At steady-state <code>false</code>, becomes <code>true</code> if a low-level "escape" payload (empty message) was last received meaning the next message will be the encoding of a <a class="el" href="classipc_1_1transport_1_1sync__io_1_1Blob__stream__mq__receiver__impl.html#add17b83b9c20b617a13dcdc22e9b8d8d" title="Short-hand for Blob_stream_mq_base_impl::Control_cmd.">Control_cmd</a> enumeration value, receiving which shall reset this to <code>false</code>. </p>

<p class="definition">Definition at line <a class="el" href="sync__io_2detail_2blob__stream__mq__rcv__impl_8hpp_source.html#l00385">385</a> of file <a class="el" href="sync__io_2detail_2blob__stream__mq__rcv__impl_8hpp_source.html">blob_stream_mq_rcv_impl.hpp</a>.</p>

</div>
</div>
<a id="aa3b1062b158606ea1760a3952b978e73" name="aa3b1062b158606ea1760a3952b978e73"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa3b1062b158606ea1760a3952b978e73">&#9670;&nbsp;</a></span>m_ev_hndl_task_engine_unused</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename <a class="el" href="classipc_1_1transport_1_1Persistent__mq__handle.html">Persistent_mq_handle</a> &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">flow::util::Task_engine <a class="el" href="classipc_1_1transport_1_1sync__io_1_1Blob__stream__mq__receiver__impl.html">ipc::transport::sync_io::Blob_stream_mq_receiver_impl</a>&lt; <a class="el" href="classipc_1_1transport_1_1Persistent__mq__handle.html">Persistent_mq_handle</a> &gt;::m_ev_hndl_task_engine_unused</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>The <code>Task_engine</code> for <code>m_ev_wait_hndl_*</code>, unless it is replaced via <a class="el" href="classipc_1_1transport_1_1sync__io_1_1Blob__stream__mq__receiver__impl.html#a3ee71a39a443e78c86f82652d8d0601e" title="See Blob_stream_mq_receiver counterpart.">replace_event_wait_handles()</a>. </p>
<p >There are 2 possibilities:</p><ul>
<li>They leave this guy associated with <code>m_ev_wait_hndl_*</code>. Then no one shall be doing <code>.async_wait()</code> on them, and instead the user aims to perhaps use raw <code>[e]poll*()</code> on their <code>.native_handle()</code>s. We still need some <code>Task_engine</code> to construct them though, so we use this.</li>
<li>They use <a class="el" href="classipc_1_1transport_1_1sync__io_1_1Blob__stream__mq__receiver__impl.html#a3ee71a39a443e78c86f82652d8d0601e" title="See Blob_stream_mq_receiver counterpart.">replace_event_wait_handles()</a>, and therefore this becomes dissociated with <code>m_ev_wait_hndl_*</code> and becomes completely unused in any fashion, period. Then they shall probably be doing their own <code>.async_wait()</code> &ndash; associated with their own <code>Task_engine</code> &ndash; on <code>m_ev_wait_hndl_*</code>.</li>
</ul>
<p >This is all to fulfill the <code><a class="el" href="namespaceipc_1_1transport_1_1sync__io.html" title="sync_io-pattern counterparts to async-I/O-pattern object types in parent namespace ipc::transport.">sync_io</a></code> pattern. </p>

<p class="definition">Definition at line <a class="el" href="sync__io_2detail_2blob__stream__mq__rcv__impl_8hpp_source.html#l00292">292</a> of file <a class="el" href="sync__io_2detail_2blob__stream__mq__rcv__impl_8hpp_source.html">blob_stream_mq_rcv_impl.hpp</a>.</p>

</div>
</div>
<a id="a1c8ac9998df02ead0180c6bc00bc58dd" name="a1c8ac9998df02ead0180c6bc00bc58dd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1c8ac9998df02ead0180c6bc00bc58dd">&#9670;&nbsp;</a></span>m_ev_wait_func</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename <a class="el" href="classipc_1_1transport_1_1Persistent__mq__handle.html">Persistent_mq_handle</a> &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespaceipc_1_1util_1_1sync__io.html#aa0b9a3cc6bdc7dedbef4f9e06851aa24">util::sync_io::Event_wait_func</a> <a class="el" href="classipc_1_1transport_1_1sync__io_1_1Blob__stream__mq__receiver__impl.html">ipc::transport::sync_io::Blob_stream_mq_receiver_impl</a>&lt; <a class="el" href="classipc_1_1transport_1_1Persistent__mq__handle.html">Persistent_mq_handle</a> &gt;::m_ev_wait_func</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Function (set forever in <a class="el" href="classipc_1_1transport_1_1sync__io_1_1Blob__stream__mq__receiver__impl.html#a1e286f452b6e3a74d64e1f795795afe2" title="See Blob_stream_mq_receiver counterpart.">start_receive_blob_ops()</a>) through which we invoke the outside event loop's async-wait facility for descriptors/events relevant to our ops. </p>
<p >See <a class="el" href="namespaceipc_1_1util_1_1sync__io.html#aa0b9a3cc6bdc7dedbef4f9e06851aa24" title="In sync_io pattern, concrete type storing user-supplied function invoked by pattern-implementing ipc:...">util::sync_io::Event_wait_func</a> doc header for a refresher on this mechanic. </p>

<p class="definition">Definition at line <a class="el" href="sync__io_2detail_2blob__stream__mq__rcv__impl_8hpp_source.html#l00449">449</a> of file <a class="el" href="sync__io_2detail_2blob__stream__mq__rcv__impl_8hpp_source.html">blob_stream_mq_rcv_impl.hpp</a>.</p>

</div>
</div>
<a id="a0511a6453387e65378f0e66d80886bcd" name="a0511a6453387e65378f0e66d80886bcd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0511a6453387e65378f0e66d80886bcd">&#9670;&nbsp;</a></span>m_ev_wait_hndl_idle_timer_fired_peer</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename <a class="el" href="classipc_1_1transport_1_1Persistent__mq__handle.html">Persistent_mq_handle</a> &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classipc_1_1util_1_1sync__io_1_1Asio__waitable__native__handle.html">util::sync_io::Asio_waitable_native_handle</a> <a class="el" href="classipc_1_1transport_1_1sync__io_1_1Blob__stream__mq__receiver__impl.html">ipc::transport::sync_io::Blob_stream_mq_receiver_impl</a>&lt; <a class="el" href="classipc_1_1transport_1_1Persistent__mq__handle.html">Persistent_mq_handle</a> &gt;::m_ev_wait_hndl_idle_timer_fired_peer</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Descriptor waitable by outside event loop async-waits &ndash; storing the same <code>Native_handle</code> as (and thus being used to wait on events from) <a class="el" href="classipc_1_1transport_1_1sync__io_1_1Blob__stream__mq__receiver__impl.html#a64d71115e8212c896eb7baa82f005c82" title="Read-end of IPC-mechanism used by m_timer_worker to ferry timer-fired events from m_idle_timer to syn...">m_idle_timer_fired_peer</a>. </p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classipc_1_1transport_1_1sync__io_1_1Blob__stream__mq__receiver__impl.html#aae2ee292cd7b9742b32e68dfd84d8361" title="As typical in timer-needing sync_io-pattern-implementing objects, maintains a thread exclusively for ...">m_timer_worker</a> for more info. </dd></dl>

<p class="definition">Definition at line <a class="el" href="sync__io_2detail_2blob__stream__mq__rcv__impl_8hpp_source.html#l00442">442</a> of file <a class="el" href="sync__io_2detail_2blob__stream__mq__rcv__impl_8hpp_source.html">blob_stream_mq_rcv_impl.hpp</a>.</p>

</div>
</div>
<a id="a87df1a6c9a98542a8fb00a9d85570c64" name="a87df1a6c9a98542a8fb00a9d85570c64"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a87df1a6c9a98542a8fb00a9d85570c64">&#9670;&nbsp;</a></span>m_ev_wait_hndl_mq</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename <a class="el" href="classipc_1_1transport_1_1Persistent__mq__handle.html">Persistent_mq_handle</a> &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classipc_1_1util_1_1sync__io_1_1Asio__waitable__native__handle.html">util::sync_io::Asio_waitable_native_handle</a> <a class="el" href="classipc_1_1transport_1_1sync__io_1_1Blob__stream__mq__receiver__impl.html">ipc::transport::sync_io::Blob_stream_mq_receiver_impl</a>&lt; <a class="el" href="classipc_1_1transport_1_1Persistent__mq__handle.html">Persistent_mq_handle</a> &gt;::m_ev_wait_hndl_mq</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Descriptor waitable by outside event loop async-waits &ndash; storing the same <code>Native_handle</code> as (and thus being used to wait on events from) <a class="el" href="classipc_1_1transport_1_1sync__io_1_1Blob__stream__mq__receiver__impl.html#af742578435fde1d0c536196698ddbc75" title="Read-end of IPC-pipe used by thread U to detect that a thread-W transmissibility-wait has completed,...">m_mq_ready_reader</a>; or if <a class="el" href="classipc_1_1transport_1_1sync__io_1_1Blob__stream__mq__receiver__impl.html#ae71fa0a5594915910b0b8dd88743f62e" title="The MQ handle adopted by the ctor, through which nb-receives and blocking-waits are executed.">m_mq</a> can be watched directly (known at compile-time) then as <code>m_mq</code> itself. </p>
<p >Its name suggests it's watching <a class="el" href="classipc_1_1transport_1_1sync__io_1_1Blob__stream__mq__receiver__impl.html#ae71fa0a5594915910b0b8dd88743f62e" title="The MQ handle adopted by the ctor, through which nb-receives and blocking-waits are executed.">m_mq</a> (for transmissibility), and that's true: In the latter case one directly watches it for transmissibility in the proper direction; in the former case <a class="el" href="classipc_1_1transport_1_1Persistent__mq__handle.html" title="A documentation-only concept defining the behavior of an object representing a light-weight handle to...">Persistent_mq_handle</a> lacks a <a class="el" href="namespaceipc_1_1transport.html#a7ee4551983d9df16ec16a3139bac50e8" title="Convenience alias for the commonly used type util::Native_handle.">Native_handle</a> to watch directly &ndash; but we use the <code>m_mq_ready_*</code> pipe and a background thread to simulate it having one. Thus in that case <a class="el" href="classipc_1_1transport_1_1sync__io_1_1Blob__stream__mq__receiver__impl.html#af742578435fde1d0c536196698ddbc75" title="Read-end of IPC-pipe used by thread U to detect that a thread-W transmissibility-wait has completed,...">m_mq_ready_reader</a> FD = this FD, and it being transmissible = MQ being transmissible. </p>

<p class="definition">Definition at line <a class="el" href="sync__io_2detail_2blob__stream__mq__rcv__impl_8hpp_source.html#l00353">353</a> of file <a class="el" href="sync__io_2detail_2blob__stream__mq__rcv__impl_8hpp_source.html">blob_stream_mq_rcv_impl.hpp</a>.</p>

<p class="reference">Referenced by <a class="el" href="sync__io_2detail_2blob__stream__mq__rcv__impl_8hpp_source.html#l00477">ipc::transport::sync_io::Blob_stream_mq_receiver_impl&lt; Persistent_mq_handle &gt;::Blob_stream_mq_receiver_impl()</a>.</p>

</div>
</div>
<a id="a370d5984484667dae6fd227e7ef0d4ff" name="a370d5984484667dae6fd227e7ef0d4ff"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a370d5984484667dae6fd227e7ef0d4ff">&#9670;&nbsp;</a></span>m_idle_timeout</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename <a class="el" href="classipc_1_1transport_1_1Persistent__mq__handle.html">Persistent_mq_handle</a> &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespaceipc_1_1util.html#ac66141280c3b7295a86b65209f31cc58">util::Fine_duration</a> <a class="el" href="classipc_1_1transport_1_1sync__io_1_1Blob__stream__mq__receiver__impl.html">ipc::transport::sync_io::Blob_stream_mq_receiver_impl</a>&lt; <a class="el" href="classipc_1_1transport_1_1Persistent__mq__handle.html">Persistent_mq_handle</a> &gt;::m_idle_timeout</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><code>timeout</code> from <a class="el" href="classipc_1_1transport_1_1sync__io_1_1Blob__stream__mq__receiver__impl.html#a878fa03873bcdea5aa9d938a4791325f" title="See Blob_stream_mq_receiver counterpart, but assuming PEER state.">idle_timer_run()</a> args; or <code>zero()</code> if not yet called. </p>
<p ><a class="el" href="classipc_1_1transport_1_1sync__io_1_1Blob__stream__mq__receiver__impl.html#a7f3ac613026a5c7704641ba5b3971fe5" title="Timer that fires on_ev_idle_timer_fired() (which hoses the pipe with idle timeour error) and is (re)s...">m_idle_timer</a> stays inactive until this becomes not-<code>zero()</code>. </p>

<p class="definition">Definition at line <a class="el" href="sync__io_2detail_2blob__stream__mq__rcv__impl_8hpp_source.html#l00414">414</a> of file <a class="el" href="sync__io_2detail_2blob__stream__mq__rcv__impl_8hpp_source.html">blob_stream_mq_rcv_impl.hpp</a>.</p>

</div>
</div>
<a id="a7f3ac613026a5c7704641ba5b3971fe5" name="a7f3ac613026a5c7704641ba5b3971fe5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7f3ac613026a5c7704641ba5b3971fe5">&#9670;&nbsp;</a></span>m_idle_timer</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename <a class="el" href="classipc_1_1transport_1_1Persistent__mq__handle.html">Persistent_mq_handle</a> &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">flow::util::Timer <a class="el" href="classipc_1_1transport_1_1sync__io_1_1Blob__stream__mq__receiver__impl.html">ipc::transport::sync_io::Blob_stream_mq_receiver_impl</a>&lt; <a class="el" href="classipc_1_1transport_1_1Persistent__mq__handle.html">Persistent_mq_handle</a> &gt;::m_idle_timer</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Timer that fires <a class="el" href="classipc_1_1transport_1_1sync__io_1_1Blob__stream__mq__receiver__impl.html#a5c46890c19e4fe69d9276647205af786" title="Handler for the async-wait, via util::sync_io::Timer_event_emitter, of the idle timer firing; if stil...">on_ev_idle_timer_fired()</a> (which hoses the pipe with idle timeour error) and is (re)scheduled to fire in <a class="el" href="classipc_1_1transport_1_1sync__io_1_1Blob__stream__mq__receiver__impl.html#a370d5984484667dae6fd227e7ef0d4ff" title="timeout from idle_timer_run() args; or zero() if not yet called.">m_idle_timeout</a> each time <code>*this</code> receives a complete message on <a class="el" href="classipc_1_1transport_1_1sync__io_1_1Blob__stream__mq__receiver__impl.html#ae71fa0a5594915910b0b8dd88743f62e" title="The MQ handle adopted by the ctor, through which nb-receives and blocking-waits are executed.">m_mq</a>. </p>
<p >If it does fire, without being preempted by some error to have occurred since then, the pipe is hosed with a particular error indicating idle-timeout (so that <code>Error_code</code> is saved to <a class="el" href="classipc_1_1transport_1_1sync__io_1_1Blob__stream__mq__receiver__impl.html#a415d72c8ed4bed42fc84bf46f716742a" title="The first and only MQ-hosing error condition detected when attempting to low-level-read on m_mq; or f...">m_pending_err_code</a>).</p>
<p >Since we implement <code><a class="el" href="namespaceipc_1_1transport_1_1sync__io.html" title="sync_io-pattern counterparts to async-I/O-pattern object types in parent namespace ipc::transport.">sync_io</a></code> pattern, the timer is obtained from, and used via, <a class="el" href="classipc_1_1util_1_1sync__io_1_1Timer__event__emitter.html" title="An object of this type, used internally to implement sync_io-pattern objects that require timer event...">util::sync_io::Timer_event_emitter</a> <a class="el" href="classipc_1_1transport_1_1sync__io_1_1Blob__stream__mq__receiver__impl.html#aae2ee292cd7b9742b32e68dfd84d8361" title="As typical in timer-needing sync_io-pattern-implementing objects, maintains a thread exclusively for ...">m_timer_worker</a>. See that member's doc header for more info. </p>

<p class="definition">Definition at line <a class="el" href="sync__io_2detail_2blob__stream__mq__rcv__impl_8hpp_source.html#l00426">426</a> of file <a class="el" href="sync__io_2detail_2blob__stream__mq__rcv__impl_8hpp_source.html">blob_stream_mq_rcv_impl.hpp</a>.</p>

</div>
</div>
<a id="a64d71115e8212c896eb7baa82f005c82" name="a64d71115e8212c896eb7baa82f005c82"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a64d71115e8212c896eb7baa82f005c82">&#9670;&nbsp;</a></span>m_idle_timer_fired_peer</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename <a class="el" href="classipc_1_1transport_1_1Persistent__mq__handle.html">Persistent_mq_handle</a> &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classipc_1_1util_1_1sync__io_1_1Timer__event__emitter.html#a1533a54927a64579fda02c61ec94b735">util::sync_io::Timer_event_emitter::Timer_fired_read_end</a>* <a class="el" href="classipc_1_1transport_1_1sync__io_1_1Blob__stream__mq__receiver__impl.html">ipc::transport::sync_io::Blob_stream_mq_receiver_impl</a>&lt; <a class="el" href="classipc_1_1transport_1_1Persistent__mq__handle.html">Persistent_mq_handle</a> &gt;::m_idle_timer_fired_peer</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Read-end of IPC-mechanism used by <a class="el" href="classipc_1_1transport_1_1sync__io_1_1Blob__stream__mq__receiver__impl.html#aae2ee292cd7b9742b32e68dfd84d8361" title="As typical in timer-needing sync_io-pattern-implementing objects, maintains a thread exclusively for ...">m_timer_worker</a> to ferry timer-fired events from <a class="el" href="classipc_1_1transport_1_1sync__io_1_1Blob__stream__mq__receiver__impl.html#a7f3ac613026a5c7704641ba5b3971fe5" title="Timer that fires on_ev_idle_timer_fired() (which hoses the pipe with idle timeour error) and is (re)s...">m_idle_timer</a> to <code><a class="el" href="namespaceipc_1_1transport_1_1sync__io.html" title="sync_io-pattern counterparts to async-I/O-pattern object types in parent namespace ipc::transport.">sync_io</a></code> outside async-wait to our actual on-timer-fired handler logic. </p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classipc_1_1transport_1_1sync__io_1_1Blob__stream__mq__receiver__impl.html#aae2ee292cd7b9742b32e68dfd84d8361" title="As typical in timer-needing sync_io-pattern-implementing objects, maintains a thread exclusively for ...">m_timer_worker</a> for more info. </dd></dl>

<p class="definition">Definition at line <a class="el" href="sync__io_2detail_2blob__stream__mq__rcv__impl_8hpp_source.html#l00434">434</a> of file <a class="el" href="sync__io_2detail_2blob__stream__mq__rcv__impl_8hpp_source.html">blob_stream_mq_rcv_impl.hpp</a>.</p>

</div>
</div>
<a id="ae71fa0a5594915910b0b8dd88743f62e" name="ae71fa0a5594915910b0b8dd88743f62e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae71fa0a5594915910b0b8dd88743f62e">&#9670;&nbsp;</a></span>m_mq</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename <a class="el" href="classipc_1_1transport_1_1Persistent__mq__handle.html">Persistent_mq_handle</a> &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classipc_1_1transport_1_1Blob__stream__mq__base__impl.html#aab7c4c91d42c746c93e61eb367572eb1">Base::Auto_closing_mq</a> <a class="el" href="classipc_1_1transport_1_1sync__io_1_1Blob__stream__mq__receiver__impl.html">ipc::transport::sync_io::Blob_stream_mq_receiver_impl</a>&lt; <a class="el" href="classipc_1_1transport_1_1Persistent__mq__handle.html">Persistent_mq_handle</a> &gt;::m_mq</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>The MQ handle adopted by the ctor, through which nb-receives and blocking-waits are executed. </p>
<p >It is not directly protected by any mutex; however it is accessed exclusively as follows:</p><ul>
<li>By thread W, when <a class="el" href="classipc_1_1transport_1_1sync__io_1_1Blob__stream__mq__receiver__impl.html#a819d349f5cafcba88f3dff63968d74b0" title="Null if no async_receive_blob()` is currently pending; else describes the arguments to that pending a...">m_user_request</a> is non-null (would-block state), thus thread U has tasked it with awaiting readability &ndash; which it is doing and is not yet done doing.</li>
<li>By thread U, when <a class="el" href="classipc_1_1transport_1_1sync__io_1_1Blob__stream__mq__receiver__impl.html#a819d349f5cafcba88f3dff63968d74b0" title="Null if no async_receive_blob()` is currently pending; else describes the arguments to that pending a...">m_user_request</a> is null (no would-block at the moment); or it is not null, but thread W has signaled it is done awaiting non-would-block, so thread U is trying to nullify it via nb-reads.</li>
</ul>
<p >Exception: <code>m_mq-&gt;interrupt_receives()</code> is done from thread U (dtor), potentially <em>while</em> thread W is inside <code>m_mq-&gt;wait_receivable()</code>. However that specific action is allowed by <a class="el" href="classipc_1_1transport_1_1Persistent__mq__handle.html" title="A documentation-only concept defining the behavior of an object representing a light-weight handle to...">Persistent_mq_handle</a> contract (in fact that is the main utility of <a class="el" href="classipc_1_1transport_1_1Persistent__mq__handle.html#a206333d3eb619588d17812f8f49013a2" title="Enables receives-interrupted mode: is_receivable() (future calls), receive() (future or concurrent ca...">Persistent_mq_handle::interrupt_receives()</a>). It makes the <a class="el" href="classipc_1_1transport_1_1Persistent__mq__handle.html#a7029f9601aa268022bd8cf7970c512c8" title="Equivalent to receive() except stops short of reading anything, with non-error return indicating that...">Persistent_mq_handle::wait_receivable()</a> immediately return.</p>
<p >If and only if <a class="el" href="classipc_1_1transport_1_1sync__io_1_1Blob__stream__mq__receiver__impl.html#a415d72c8ed4bed42fc84bf46f716742a" title="The first and only MQ-hosing error condition detected when attempting to low-level-read on m_mq; or f...">m_pending_err_code</a> is truthy, <a class="el" href="classipc_1_1transport_1_1sync__io_1_1Blob__stream__mq__receiver__impl.html#ae71fa0a5594915910b0b8dd88743f62e" title="The MQ handle adopted by the ctor, through which nb-receives and blocking-waits are executed.">m_mq</a> is null; hence the handle's system resources (and the handle object's memory itself) are given back at the earliest possible time. </p>

<p class="definition">Definition at line <a class="el" href="sync__io_2detail_2blob__stream__mq__rcv__impl_8hpp_source.html#l00311">311</a> of file <a class="el" href="sync__io_2detail_2blob__stream__mq__rcv__impl_8hpp_source.html">blob_stream_mq_rcv_impl.hpp</a>.</p>

<p class="reference">Referenced by <a class="el" href="sync__io_2detail_2blob__stream__mq__rcv__impl_8hpp_source.html#l00477">ipc::transport::sync_io::Blob_stream_mq_receiver_impl&lt; Persistent_mq_handle &gt;::Blob_stream_mq_receiver_impl()</a>.</p>

</div>
</div>
<a id="a25ec1b85b46e3b9ad9a4fe59bc158f45" name="a25ec1b85b46e3b9ad9a4fe59bc158f45"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a25ec1b85b46e3b9ad9a4fe59bc158f45">&#9670;&nbsp;</a></span>m_mq_max_msg_sz</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename <a class="el" href="classipc_1_1transport_1_1Persistent__mq__handle.html">Persistent_mq_handle</a> &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const size_t <a class="el" href="classipc_1_1transport_1_1sync__io_1_1Blob__stream__mq__receiver__impl.html">ipc::transport::sync_io::Blob_stream_mq_receiver_impl</a>&lt; <a class="el" href="classipc_1_1transport_1_1Persistent__mq__handle.html">Persistent_mq_handle</a> &gt;::m_mq_max_msg_sz</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Equals <code>m_mq.max_msg_size()</code>. </p>
<h3>Rationale</h3>
<p >It is saved in ctor, instead of invoking <code>m_mq-&gt;max_msg_size()</code> when needed, to keep the rules for when <a class="el" href="classipc_1_1transport_1_1sync__io_1_1Blob__stream__mq__receiver__impl.html#ae71fa0a5594915910b0b8dd88743f62e" title="The MQ handle adopted by the ctor, through which nb-receives and blocking-waits are executed.">m_mq</a> is accessed simple and as described in its doc header. After all this value would never change anyway. </p>

<p class="definition">Definition at line <a class="el" href="sync__io_2detail_2blob__stream__mq__rcv__impl_8hpp_source.html#l00319">319</a> of file <a class="el" href="sync__io_2detail_2blob__stream__mq__rcv__impl_8hpp_source.html">blob_stream_mq_rcv_impl.hpp</a>.</p>

</div>
</div>
<a id="af742578435fde1d0c536196698ddbc75" name="af742578435fde1d0c536196698ddbc75"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af742578435fde1d0c536196698ddbc75">&#9670;&nbsp;</a></span>m_mq_ready_reader</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename <a class="el" href="classipc_1_1transport_1_1Persistent__mq__handle.html">Persistent_mq_handle</a> &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::optional&lt;<a class="el" href="namespaceipc_1_1util.html#aaf368acf8243bb25de3eef4e836c15de">util::Pipe_reader</a>&gt; <a class="el" href="classipc_1_1transport_1_1sync__io_1_1Blob__stream__mq__receiver__impl.html">ipc::transport::sync_io::Blob_stream_mq_receiver_impl</a>&lt; <a class="el" href="classipc_1_1transport_1_1Persistent__mq__handle.html">Persistent_mq_handle</a> &gt;::m_mq_ready_reader</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Read-end of IPC-pipe used by thread U to detect that a thread-W transmissibility-wait has completed, meaning would-block has cleared, and therefore thread U can attempt to nb-transmit again. </p>
<p >The signal byte is read out of <a class="el" href="classipc_1_1transport_1_1sync__io_1_1Blob__stream__mq__receiver__impl.html#af742578435fde1d0c536196698ddbc75" title="Read-end of IPC-pipe used by thread U to detect that a thread-W transmissibility-wait has completed,...">m_mq_ready_reader</a>, making it empty again (the steady-state before the next time would-block occurs, and a byte is written to it making it non-empty).</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classipc_1_1transport_1_1sync__io_1_1Blob__stream__mq__receiver__impl.html#ac181b33a0b5cdb0e89753b62d86af50f" title="Write-end of IPC-pipe used by thread W to inform thread U that a thread-W transmissibility-wait has c...">m_mq_ready_writer</a>.</dd></dl>
<p>Never touched if <a class="el" href="classipc_1_1transport_1_1Persistent__mq__handle.html#ac2c0b560893c6a8b71aac0e748770076" title="true if and only if native_handle() method exists, and the returned value may be waited-on by poll()/...">Persistent_mq_handle::S_HAS_NATIVE_HANDLE</a>. </p>

<p class="definition">Definition at line <a class="el" href="sync__io_2detail_2blob__stream__mq__rcv__impl_8hpp_source.html#l00331">331</a> of file <a class="el" href="sync__io_2detail_2blob__stream__mq__rcv__impl_8hpp_source.html">blob_stream_mq_rcv_impl.hpp</a>.</p>

<p class="reference">Referenced by <a class="el" href="sync__io_2detail_2blob__stream__mq__rcv__impl_8hpp_source.html#l00477">ipc::transport::sync_io::Blob_stream_mq_receiver_impl&lt; Persistent_mq_handle &gt;::Blob_stream_mq_receiver_impl()</a>.</p>

</div>
</div>
<a id="ac181b33a0b5cdb0e89753b62d86af50f" name="ac181b33a0b5cdb0e89753b62d86af50f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac181b33a0b5cdb0e89753b62d86af50f">&#9670;&nbsp;</a></span>m_mq_ready_writer</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename <a class="el" href="classipc_1_1transport_1_1Persistent__mq__handle.html">Persistent_mq_handle</a> &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::optional&lt;<a class="el" href="namespaceipc_1_1util.html#a844d5ca9c17b672644fc8d9dbe758db0">util::Pipe_writer</a>&gt; <a class="el" href="classipc_1_1transport_1_1sync__io_1_1Blob__stream__mq__receiver__impl.html">ipc::transport::sync_io::Blob_stream_mq_receiver_impl</a>&lt; <a class="el" href="classipc_1_1transport_1_1Persistent__mq__handle.html">Persistent_mq_handle</a> &gt;::m_mq_ready_writer</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Write-end of IPC-pipe used by thread W to inform thread U that a thread-W transmissibility-wait has completed, meaning would-block has cleared, and therefore thread U can attempt to nb-transmit again. </p>
<p >A signal byte is written to <a class="el" href="classipc_1_1transport_1_1sync__io_1_1Blob__stream__mq__receiver__impl.html#ac181b33a0b5cdb0e89753b62d86af50f" title="Write-end of IPC-pipe used by thread W to inform thread U that a thread-W transmissibility-wait has c...">m_mq_ready_writer</a>, making it non-empty.</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classipc_1_1transport_1_1sync__io_1_1Blob__stream__mq__receiver__impl.html#af742578435fde1d0c536196698ddbc75" title="Read-end of IPC-pipe used by thread U to detect that a thread-W transmissibility-wait has completed,...">m_mq_ready_reader</a>.</dd></dl>
<p>Never touched if <a class="el" href="classipc_1_1transport_1_1Persistent__mq__handle.html#ac2c0b560893c6a8b71aac0e748770076" title="true if and only if native_handle() method exists, and the returned value may be waited-on by poll()/...">Persistent_mq_handle::S_HAS_NATIVE_HANDLE</a>. </p>

<p class="definition">Definition at line <a class="el" href="sync__io_2detail_2blob__stream__mq__rcv__impl_8hpp_source.html#l00342">342</a> of file <a class="el" href="sync__io_2detail_2blob__stream__mq__rcv__impl_8hpp_source.html">blob_stream_mq_rcv_impl.hpp</a>.</p>

<p class="reference">Referenced by <a class="el" href="sync__io_2detail_2blob__stream__mq__rcv__impl_8hpp_source.html#l00477">ipc::transport::sync_io::Blob_stream_mq_receiver_impl&lt; Persistent_mq_handle &gt;::Blob_stream_mq_receiver_impl()</a>.</p>

</div>
</div>
<a id="a9f1120b92ea20944b2de416d870644ce" name="a9f1120b92ea20944b2de416d870644ce"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9f1120b92ea20944b2de416d870644ce">&#9670;&nbsp;</a></span>m_nb_task_engine</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename <a class="el" href="classipc_1_1transport_1_1Persistent__mq__handle.html">Persistent_mq_handle</a> &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::optional&lt;flow::util::Task_engine&gt; <a class="el" href="classipc_1_1transport_1_1sync__io_1_1Blob__stream__mq__receiver__impl.html">ipc::transport::sync_io::Blob_stream_mq_receiver_impl</a>&lt; <a class="el" href="classipc_1_1transport_1_1Persistent__mq__handle.html">Persistent_mq_handle</a> &gt;::m_nb_task_engine</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>The <code>Task_engine</code> for <code>m_mq_ready_*</code>. </p>
<p >It is necessary to construct those pipe-end objects, but we never use that guy's <code>-&gt;async_*()</code> APIs &ndash; only non-blocking operations, essentially leveraging boost.asio's portable transmission APIs but not its actual, um, async-I/O abilities in this case. Accordingly we never load any tasks onto <a class="el" href="classipc_1_1transport_1_1sync__io_1_1Blob__stream__mq__receiver__impl.html#a9f1120b92ea20944b2de416d870644ce" title="The Task_engine for m_mq_ready_*.">m_nb_task_engine</a> and certainly never <code>.run()</code> (or <code>.poll()</code> or ...) it.</p>
<p >In the <code><a class="el" href="namespaceipc_1_1transport_1_1sync__io.html" title="sync_io-pattern counterparts to async-I/O-pattern object types in parent namespace ipc::transport.">sync_io</a></code> pattern the user's outside event loop is responsible for awaiting readability/writability of a guy like <a class="el" href="classipc_1_1transport_1_1sync__io_1_1Blob__stream__mq__receiver__impl.html#af742578435fde1d0c536196698ddbc75" title="Read-end of IPC-pipe used by thread U to detect that a thread-W transmissibility-wait has completed,...">m_mq_ready_reader</a> via our exporting of its <code>.native_handle()</code>.</p>
<p >Never touched if <a class="el" href="classipc_1_1transport_1_1Persistent__mq__handle.html#ac2c0b560893c6a8b71aac0e748770076" title="true if and only if native_handle() method exists, and the returned value may be waited-on by poll()/...">Persistent_mq_handle::S_HAS_NATIVE_HANDLE</a>.</p>
<dl class="todo"><dt><b><a class="el" href="todo.html#_todo000012">Todo:</a></b></dt><dd>Consider using specialization instead of or in addition <code>if constexpr()</code> w/r/t <code>Mq::S_HAS_NATIVE_HANDLE</code>-based compile-time branching: it could save some RAM by eliminating <code>optional</code>s such as the one near this to-do; though code would likely become wordier. </dd></dl>

<p class="definition">Definition at line <a class="el" href="sync__io_2detail_2blob__stream__mq__rcv__impl_8hpp_source.html#l00278">278</a> of file <a class="el" href="sync__io_2detail_2blob__stream__mq__rcv__impl_8hpp_source.html">blob_stream_mq_rcv_impl.hpp</a>.</p>

<p class="reference">Referenced by <a class="el" href="sync__io_2detail_2blob__stream__mq__rcv__impl_8hpp_source.html#l00477">ipc::transport::sync_io::Blob_stream_mq_receiver_impl&lt; Persistent_mq_handle &gt;::Blob_stream_mq_receiver_impl()</a>.</p>

</div>
</div>
<a id="ac892341e6a1fcc6ef8739bce8403fb6d" name="ac892341e6a1fcc6ef8739bce8403fb6d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac892341e6a1fcc6ef8739bce8403fb6d">&#9670;&nbsp;</a></span>m_nickname</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename <a class="el" href="classipc_1_1transport_1_1Persistent__mq__handle.html">Persistent_mq_handle</a> &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const std::string <a class="el" href="classipc_1_1transport_1_1sync__io_1_1Blob__stream__mq__receiver__impl.html">ipc::transport::sync_io::Blob_stream_mq_receiver_impl</a>&lt; <a class="el" href="classipc_1_1transport_1_1Persistent__mq__handle.html">Persistent_mq_handle</a> &gt;::m_nickname</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>See <a class="el" href="classipc_1_1transport_1_1sync__io_1_1Blob__stream__mq__receiver__impl.html#adaf3579ec3abf0b5d85258965d264660" title="See Blob_stream_mq_receiver counterpart, but assuming PEER state.">nickname()</a>. </p>

<p class="definition">Definition at line <a class="el" href="sync__io_2detail_2blob__stream__mq__rcv__impl_8hpp_source.html#l00249">249</a> of file <a class="el" href="sync__io_2detail_2blob__stream__mq__rcv__impl_8hpp_source.html">blob_stream_mq_rcv_impl.hpp</a>.</p>

</div>
</div>
<a id="a415d72c8ed4bed42fc84bf46f716742a" name="a415d72c8ed4bed42fc84bf46f716742a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a415d72c8ed4bed42fc84bf46f716742a">&#9670;&nbsp;</a></span>m_pending_err_code</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename <a class="el" href="classipc_1_1transport_1_1Persistent__mq__handle.html">Persistent_mq_handle</a> &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespaceipc.html#aa3192e586cc45d3e7c22463bf2760f89">Error_code</a> <a class="el" href="classipc_1_1transport_1_1sync__io_1_1Blob__stream__mq__receiver__impl.html">ipc::transport::sync_io::Blob_stream_mq_receiver_impl</a>&lt; <a class="el" href="classipc_1_1transport_1_1Persistent__mq__handle.html">Persistent_mq_handle</a> &gt;::m_pending_err_code</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>The first and only MQ-hosing error condition detected when attempting to low-level-read on <a class="el" href="classipc_1_1transport_1_1sync__io_1_1Blob__stream__mq__receiver__impl.html#ae71fa0a5594915910b0b8dd88743f62e" title="The MQ handle adopted by the ctor, through which nb-receives and blocking-waits are executed.">m_mq</a>; or falsy if no such error has yet been detected. </p>
<p >Among possible other uses, it is emitted to the ongoing-at-the-time <a class="el" href="classipc_1_1transport_1_1sync__io_1_1Blob__stream__mq__receiver__impl.html#a8d1a81d379e1a31031adb9cccbbabd35" title="See Blob_stream_mq_receiver counterpart, but assuming PEER state.">async_receive_blob()</a>'s completion handler (if one is indeed outstanding) and immediately to any subsequent <a class="el" href="classipc_1_1transport_1_1sync__io_1_1Blob__stream__mq__receiver__impl.html#a8d1a81d379e1a31031adb9cccbbabd35" title="See Blob_stream_mq_receiver counterpart, but assuming PEER state.">async_receive_blob()</a>. </p>

<p class="definition">Definition at line <a class="el" href="sync__io_2detail_2blob__stream__mq__rcv__impl_8hpp_source.html#l00408">408</a> of file <a class="el" href="sync__io_2detail_2blob__stream__mq__rcv__impl_8hpp_source.html">blob_stream_mq_rcv_impl.hpp</a>.</p>

<p class="reference">Referenced by <a class="el" href="sync__io_2detail_2blob__stream__mq__rcv__impl_8hpp_source.html#l00477">ipc::transport::sync_io::Blob_stream_mq_receiver_impl&lt; Persistent_mq_handle &gt;::Blob_stream_mq_receiver_impl()</a>.</p>

</div>
</div>
<a id="aeec08979b985498aa0738892c947a8a9" name="aeec08979b985498aa0738892c947a8a9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aeec08979b985498aa0738892c947a8a9">&#9670;&nbsp;</a></span>m_protocol_negotiator</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename <a class="el" href="classipc_1_1transport_1_1Persistent__mq__handle.html">Persistent_mq_handle</a> &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classipc_1_1transport_1_1Protocol__negotiator.html">Protocol_negotiator</a> <a class="el" href="classipc_1_1transport_1_1sync__io_1_1Blob__stream__mq__receiver__impl.html">ipc::transport::sync_io::Blob_stream_mq_receiver_impl</a>&lt; <a class="el" href="classipc_1_1transport_1_1Persistent__mq__handle.html">Persistent_mq_handle</a> &gt;::m_protocol_negotiator</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Handles the protocol negotiation at the start of the pipe and subsequently stores the result of that negotiation. </p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classipc_1_1transport_1_1Protocol__negotiator.html" title="A simple state machine that, assuming the opposide side of a comm pathway uses an equivalent state ma...">Protocol_negotiator</a> doc header for key background on the topic. </dd>
<dd>
<a class="el" href="classipc_1_1transport_1_1sync__io_1_1Blob__stream__mq__sender__impl.html#a28485fe8e4fbeea78f05eadc69a31c20" title="Handles the protocol negotiation at the start of the pipe.">Blob_stream_mq_sender_impl::m_protocol_negotiator</a> doc header which contains notes relevant to possible future development of the present class regarding speaking multiple protocol versions. </dd></dl>

<p class="definition">Definition at line <a class="el" href="sync__io_2detail_2blob__stream__mq__rcv__impl_8hpp_source.html#l00258">258</a> of file <a class="el" href="sync__io_2detail_2blob__stream__mq__rcv__impl_8hpp_source.html">blob_stream_mq_rcv_impl.hpp</a>.</p>

</div>
</div>
<a id="af308d3f1ff50138070c8422552f069a5" name="af308d3f1ff50138070c8422552f069a5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af308d3f1ff50138070c8422552f069a5">&#9670;&nbsp;</a></span>m_target_control_blob</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename <a class="el" href="classipc_1_1transport_1_1Persistent__mq__handle.html">Persistent_mq_handle</a> &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">flow::util::Blob <a class="el" href="classipc_1_1transport_1_1sync__io_1_1Blob__stream__mq__receiver__impl.html">ipc::transport::sync_io::Blob_stream_mq_receiver_impl</a>&lt; <a class="el" href="classipc_1_1transport_1_1Persistent__mq__handle.html">Persistent_mq_handle</a> &gt;::m_target_control_blob</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Used only when <a class="el" href="classipc_1_1transport_1_1sync__io_1_1Blob__stream__mq__receiver__impl.html#a276f39d3d52038a341bf2ec86b4640ef" title="At steady-state false, becomes true if a low-level &quot;escape&quot; payload (empty message) was last received...">m_control_state</a> is <code>true</code>, this is where payload 2 (the <a class="el" href="classipc_1_1transport_1_1sync__io_1_1Blob__stream__mq__receiver__impl.html#add17b83b9c20b617a13dcdc22e9b8d8d" title="Short-hand for Blob_stream_mq_base_impl::Control_cmd.">Control_cmd</a>) is placed. </p>
<p >Though in reality it should only require <code>sizeof(Control_cmd)</code> bytes, <a class="el" href="classipc_1_1transport_1_1sync__io_1_1Blob__stream__mq__receiver__impl.html#ae71fa0a5594915910b0b8dd88743f62e" title="The MQ handle adopted by the ctor, through which nb-receives and blocking-waits are executed.">m_mq</a> receive will emit an error if it cannot hold <a class="el" href="classipc_1_1transport_1_1sync__io_1_1Blob__stream__mq__receiver__impl.html#a25ec1b85b46e3b9ad9a4fe59bc158f45" title="Equals m_mq.max_msg_size().">m_mq_max_msg_sz</a> bytes (that is just how <a class="el" href="classipc_1_1transport_1_1Persistent__mq__handle.html" title="A documentation-only concept defining the behavior of an object representing a light-weight handle to...">Persistent_mq_handle</a> works; though we do not care why here the reason is that's how both ipc and POSIX MQ APIs work).</p>
<p >We could also abuse <a class="el" href="classipc_1_1transport_1_1sync__io_1_1Blob__stream__mq__receiver__impl.html#a819d349f5cafcba88f3dff63968d74b0" title="Null if no async_receive_blob()` is currently pending; else describes the arguments to that pending a...">m_user_request</a> <code>m_target_blob</code>; but that seems uncool.</p>
<dl class="todo"><dt><b><a class="el" href="todo.html#_todo000013">Todo:</a></b></dt><dd>Maybe we should indeed use <code>m_user_request-&gt;m_target_blob</code> (instead of locally stored <a class="el" href="classipc_1_1transport_1_1sync__io_1_1Blob__stream__mq__receiver__impl.html#af308d3f1ff50138070c8422552f069a5" title="Used only when m_control_state is true, this is where payload 2 (the Control_cmd) is placed.">m_target_control_blob</a>) to save RAM/a few cycles? Technically at least user should not care if some garbage is temporarily placed there (after PING a real message should arrive and replace it; or else on error or graceful-close who cares?). </dd></dl>

<p class="definition">Definition at line <a class="el" href="sync__io_2detail_2blob__stream__mq__rcv__impl_8hpp_source.html#l00400">400</a> of file <a class="el" href="sync__io_2detail_2blob__stream__mq__rcv__impl_8hpp_source.html">blob_stream_mq_rcv_impl.hpp</a>.</p>

</div>
</div>
<a id="aae2ee292cd7b9742b32e68dfd84d8361" name="aae2ee292cd7b9742b32e68dfd84d8361"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aae2ee292cd7b9742b32e68dfd84d8361">&#9670;&nbsp;</a></span>m_timer_worker</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename <a class="el" href="classipc_1_1transport_1_1Persistent__mq__handle.html">Persistent_mq_handle</a> &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classipc_1_1util_1_1sync__io_1_1Timer__event__emitter.html">util::sync_io::Timer_event_emitter</a> <a class="el" href="classipc_1_1transport_1_1sync__io_1_1Blob__stream__mq__receiver__impl.html">ipc::transport::sync_io::Blob_stream_mq_receiver_impl</a>&lt; <a class="el" href="classipc_1_1transport_1_1Persistent__mq__handle.html">Persistent_mq_handle</a> &gt;::m_timer_worker</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>As typical in timer-needing <code><a class="el" href="namespaceipc_1_1transport_1_1sync__io.html" title="sync_io-pattern counterparts to async-I/O-pattern object types in parent namespace ipc::transport.">sync_io</a></code>-pattern-implementing objects, maintains a thread exclusively for <code>Timer</code> wait completion handlers which ferry timer-fired events to internal IPC-mechanisms waitable by the <code><a class="el" href="namespaceipc_1_1transport_1_1sync__io.html" title="sync_io-pattern counterparts to async-I/O-pattern object types in parent namespace ipc::transport.">sync_io</a></code>-pattern-using outside event loop. </p>
<p >In our case we (optionally) maintain the idle timer.</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classipc_1_1util_1_1sync__io_1_1Timer__event__emitter.html" title="An object of this type, used internally to implement sync_io-pattern objects that require timer event...">util::sync_io::Timer_event_emitter</a> doc header for design/rationale discussion. </dd></dl>

<p class="definition">Definition at line <a class="el" href="sync__io_2detail_2blob__stream__mq__rcv__impl_8hpp_source.html#l00362">362</a> of file <a class="el" href="sync__io_2detail_2blob__stream__mq__rcv__impl_8hpp_source.html">blob_stream_mq_rcv_impl.hpp</a>.</p>

</div>
</div>
<a id="a819d349f5cafcba88f3dff63968d74b0" name="a819d349f5cafcba88f3dff63968d74b0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a819d349f5cafcba88f3dff63968d74b0">&#9670;&nbsp;</a></span>m_user_request</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename <a class="el" href="classipc_1_1transport_1_1Persistent__mq__handle.html">Persistent_mq_handle</a> &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::optional&lt;<a class="el" href="structipc_1_1transport_1_1sync__io_1_1Blob__stream__mq__receiver__impl_1_1User__request.html">User_request</a>&gt; <a class="el" href="classipc_1_1transport_1_1sync__io_1_1Blob__stream__mq__receiver__impl.html">ipc::transport::sync_io::Blob_stream_mq_receiver_impl</a>&lt; <a class="el" href="classipc_1_1transport_1_1Persistent__mq__handle.html">Persistent_mq_handle</a> &gt;::m_user_request</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Null if no <a class="el" href="classipc_1_1transport_1_1sync__io_1_1Blob__stream__mq__receiver__impl.html#a8d1a81d379e1a31031adb9cccbbabd35" title="See Blob_stream_mq_receiver counterpart, but assuming PEER state.">async_receive_blob()</a>` is currently pending; else describes the arguments to that pending <a class="el" href="classipc_1_1transport_1_1sync__io_1_1Blob__stream__mq__receiver__impl.html#a8d1a81d379e1a31031adb9cccbbabd35" title="See Blob_stream_mq_receiver counterpart, but assuming PEER state.">async_receive_blob()</a>. </p>
<h3>Rationale</h3>
<p >It exists for a hopefully obvious reasons: At least a non-immediately-completed <a class="el" href="classipc_1_1transport_1_1sync__io_1_1Blob__stream__mq__receiver__impl.html#a8d1a81d379e1a31031adb9cccbbabd35" title="See Blob_stream_mq_receiver counterpart, but assuming PEER state.">async_receive_blob()</a> needs to keep track of the request so as to know where to place results and what completion handler to invoke.</p>
<p >As for it being nullable: this is used to guard against <code>async_receive_*()</code> being invoked while another is already outstanding. We do not queue pending requests per <a class="el" href="classipc_1_1transport_1_1sync__io_1_1Blob__receiver.html" title="A documentation-only concept: what transport::Blob_receiver is to transport::Native_handle_receiver (...">sync_io::Blob_receiver</a> concept. (However the non-<code><a class="el" href="namespaceipc_1_1transport_1_1sync__io.html" title="sync_io-pattern counterparts to async-I/O-pattern object types in parent namespace ipc::transport.">sync_io</a></code> a/k/a async-I/O <a class="el" href="classipc_1_1transport_1_1sync__io_1_1Blob__receiver.html" title="A documentation-only concept: what transport::Blob_receiver is to transport::Native_handle_receiver (...">Blob_receiver</a> <a class="el" href="classipc_1_1transport_1_1Blob__stream__mq__receiver.html" title="Implements Blob_receiver concept by using an adopted Persistent_mq_handle MQ handle to an MQ (message...">transport::Blob_stream_mq_receiver</a> does. Therefore the latter class does internally implement a <code><a class="el" href="structipc_1_1transport_1_1sync__io_1_1Blob__stream__mq__receiver__impl_1_1User__request.html" title="Identical to sync_io::Async_adapter_receiver::User_request, except we only keep at most 1 of these an...">User_request</a></code> queue.) </p>

<p class="definition">Definition at line <a class="el" href="sync__io_2detail_2blob__stream__mq__rcv__impl_8hpp_source.html#l00378">378</a> of file <a class="el" href="sync__io_2detail_2blob__stream__mq__rcv__impl_8hpp_source.html">blob_stream_mq_rcv_impl.hpp</a>.</p>

</div>
</div>
<hr/>The documentation for this class was generated from the following files:<ul>
<li>transport/detail/<a class="el" href="detail_2transport__fwd_8hpp_source.html">transport_fwd.hpp</a></li>
<li>transport/sync_io/detail/<a class="el" href="sync__io_2detail_2blob__stream__mq__rcv__impl_8hpp_source.html">blob_stream_mq_rcv_impl.hpp</a></li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Wed Mar 13 2024 09:08:24 for Flow-IPC by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.4
</small></address>
</body>
</html>
