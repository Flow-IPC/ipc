<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.9.4"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Flow-IPC: ipc::transport::Blob_stream_mq_sender&lt; Persistent_mq_handle &gt; Class Template Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">Flow-IPC<span id="projectnumber">&#160;1.0</span>
   </div>
   <div id="projectbrief">Flow-IPC project: Full implementation reference.</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.4 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search",'Search','.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespaceipc.html">ipc</a></li><li class="navelem"><a class="el" href="namespaceipc_1_1transport.html">transport</a></li><li class="navelem"><a class="el" href="classipc_1_1transport_1_1Blob__stream__mq__sender.html">Blob_stream_mq_sender</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-types">Public Types</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pub-static-attribs">Static Public Attributes</a> &#124;
<a href="#pri-types">Private Types</a> &#124;
<a href="#pri-attribs">Private Attributes</a> &#124;
<a href="#friends">Friends</a> &#124;
<a href="#related">Related Functions</a> &#124;
<a href="classipc_1_1transport_1_1Blob__stream__mq__sender-members.html">List of all members</a>  </div>
  <div class="headertitle"><div class="title">ipc::transport::Blob_stream_mq_sender&lt; Persistent_mq_handle &gt; Class Template Reference</div></div>
</div><!--header-->
<div class="contents">

<p>Implements <a class="el" href="classipc_1_1transport_1_1Blob__sender.html" title="A documentation-only concept defining the behavior of an object capable of reliably/in-order sending ...">Blob_sender</a> concept by using an adopted <a class="el" href="classipc_1_1transport_1_1Persistent__mq__handle.html" title="A documentation-only concept defining the behavior of an object representing a light-weight handle to...">Persistent_mq_handle</a> MQ handle to an MQ (message queue) of that type, such as a POSIX or bipc MQ.  
 <a href="classipc_1_1transport_1_1Blob__stream__mq__sender.html#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="blob__stream__mq__snd_8hpp_source.html">blob_stream_mq_snd.hpp</a>&gt;</code></p>
<div class="dynheader">
Inheritance diagram for ipc::transport::Blob_stream_mq_sender&lt; Persistent_mq_handle &gt;:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="classipc_1_1transport_1_1Blob__stream__mq__sender__inherit__graph.svg" width="207" height="155"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe>
</div>
<center><span class="legend">[<a href="graph_legend.html">legend</a>]</span></center></div>
<div class="dynheader">
Collaboration diagram for ipc::transport::Blob_stream_mq_sender&lt; Persistent_mq_handle &gt;:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="classipc_1_1transport_1_1Blob__stream__mq__sender__coll__graph.svg" width="980" height="312"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe>
</div>
<center><span class="legend">[<a href="graph_legend.html">legend</a>]</span></center></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-types" name="pub-types"></a>
Public Types</h2></td></tr>
<tr class="memitem:a57ed4042d5b70b0c1b73bcb75a9e5f85"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classipc_1_1transport_1_1Blob__stream__mq__sender.html#a57ed4042d5b70b0c1b73bcb75a9e5f85">Base</a> = <a class="el" href="classipc_1_1transport_1_1Blob__stream__mq__base.html">Blob_stream_mq_base</a>&lt; <a class="el" href="classipc_1_1transport_1_1Persistent__mq__handle.html">Persistent_mq_handle</a> &gt;</td></tr>
<tr class="memdesc:a57ed4042d5b70b0c1b73bcb75a9e5f85"><td class="mdescLeft">&#160;</td><td class="mdescRight">Short-hand for our base with <code>static</code> goodies at least.  <a href="classipc_1_1transport_1_1Blob__stream__mq__sender.html#a57ed4042d5b70b0c1b73bcb75a9e5f85">More...</a><br /></td></tr>
<tr class="separator:a57ed4042d5b70b0c1b73bcb75a9e5f85"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa2cb5c8fc525ae45edf8ab1b257f328d"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classipc_1_1transport_1_1Blob__stream__mq__sender.html#aa2cb5c8fc525ae45edf8ab1b257f328d">Mq</a> = typename <a class="el" href="classipc_1_1transport_1_1Blob__stream__mq__sender__impl.html">Blob_stream_mq_sender_impl</a>&lt; <a class="el" href="classipc_1_1transport_1_1Persistent__mq__handle.html">Persistent_mq_handle</a> &gt;::Mq</td></tr>
<tr class="memdesc:aa2cb5c8fc525ae45edf8ab1b257f328d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Short-hand for template arg for underlying MQ handle type.  <a href="classipc_1_1transport_1_1Blob__stream__mq__sender.html#aa2cb5c8fc525ae45edf8ab1b257f328d">More...</a><br /></td></tr>
<tr class="separator:aa2cb5c8fc525ae45edf8ab1b257f328d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acf4adb7cf4114d25386a886ed9e73aa8"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classipc_1_1transport_1_1Blob__stream__mq__sender.html#acf4adb7cf4114d25386a886ed9e73aa8">Sync_io_obj</a> = <a class="el" href="classipc_1_1transport_1_1sync__io_1_1Blob__stream__mq__sender.html">sync_io::Blob_stream_mq_sender</a>&lt; <a class="el" href="classipc_1_1transport_1_1Blob__stream__mq__sender.html#aa2cb5c8fc525ae45edf8ab1b257f328d">Mq</a> &gt;</td></tr>
<tr class="memdesc:acf4adb7cf4114d25386a886ed9e73aa8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Useful for generic programming, the <code><a class="el" href="namespaceipc_1_1transport_1_1sync__io.html" title="sync_io-pattern counterparts to async-I/O-pattern object types in parent namespace ipc::transport.">sync_io</a></code>-pattern counterpart to <code>*this</code> type.  <a href="classipc_1_1transport_1_1Blob__stream__mq__sender.html#acf4adb7cf4114d25386a886ed9e73aa8">More...</a><br /></td></tr>
<tr class="separator:acf4adb7cf4114d25386a886ed9e73aa8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a96cccfae5eb2ceb480422869e8cca0d5"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classipc_1_1transport_1_1Blob__stream__mq__sender.html#a96cccfae5eb2ceb480422869e8cca0d5">Async_io_obj</a> = <a class="el" href="classipc_1_1transport_1_1Null__peer.html">Null_peer</a></td></tr>
<tr class="memdesc:a96cccfae5eb2ceb480422869e8cca0d5"><td class="mdescLeft">&#160;</td><td class="mdescRight">You may disregard.  <a href="classipc_1_1transport_1_1Blob__stream__mq__sender.html#a96cccfae5eb2ceb480422869e8cca0d5">More...</a><br /></td></tr>
<tr class="separator:a96cccfae5eb2ceb480422869e8cca0d5"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-methods" name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:ab316cad18622921becc6c1ab54b8ed2a"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classipc_1_1transport_1_1Blob__stream__mq__sender.html#ab316cad18622921becc6c1ab54b8ed2a">Blob_stream_mq_sender</a> (flow::log::Logger *logger_ptr, <a class="el" href="namespaceipc_1_1util.html#ae6ac47812a90d1287c61e0b7de7bc4f5">util::String_view</a> nickname_str, <a class="el" href="classipc_1_1transport_1_1Blob__stream__mq__sender.html#aa2cb5c8fc525ae45edf8ab1b257f328d">Mq</a> &amp;&amp;mq_moved, <a class="el" href="namespaceipc.html#aa3192e586cc45d3e7c22463bf2760f89">Error_code</a> *err_code=0)</td></tr>
<tr class="memdesc:ab316cad18622921becc6c1ab54b8ed2a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructs the sender by taking over an already-opened MQ handle.  <a href="classipc_1_1transport_1_1Blob__stream__mq__sender.html#ab316cad18622921becc6c1ab54b8ed2a">More...</a><br /></td></tr>
<tr class="separator:ab316cad18622921becc6c1ab54b8ed2a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af9c44e5fb0285373202abba8b41d177d"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classipc_1_1transport_1_1Blob__stream__mq__sender.html#af9c44e5fb0285373202abba8b41d177d">Blob_stream_mq_sender</a> (<a class="el" href="classipc_1_1transport_1_1Blob__stream__mq__sender.html#acf4adb7cf4114d25386a886ed9e73aa8">Sync_io_obj</a> &amp;&amp;sync_io_core_in_peer_state_moved)</td></tr>
<tr class="memdesc:af9c44e5fb0285373202abba8b41d177d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Implements <a class="el" href="classipc_1_1transport_1_1Blob__sender.html" title="A documentation-only concept defining the behavior of an object capable of reliably/in-order sending ...">Blob_sender</a> API, per its concept contract.  <a href="classipc_1_1transport_1_1Blob__stream__mq__sender.html#af9c44e5fb0285373202abba8b41d177d">More...</a><br /></td></tr>
<tr class="separator:af9c44e5fb0285373202abba8b41d177d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa4537d9d39f2ba775dc98ef6d3fc6d4e"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classipc_1_1transport_1_1Blob__stream__mq__sender.html#aa4537d9d39f2ba775dc98ef6d3fc6d4e">Blob_stream_mq_sender</a> ()</td></tr>
<tr class="memdesc:aa4537d9d39f2ba775dc98ef6d3fc6d4e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Implements <a class="el" href="classipc_1_1transport_1_1Blob__sender.html" title="A documentation-only concept defining the behavior of an object capable of reliably/in-order sending ...">Blob_sender</a> API, per its concept contract.  <a href="classipc_1_1transport_1_1Blob__stream__mq__sender.html#aa4537d9d39f2ba775dc98ef6d3fc6d4e">More...</a><br /></td></tr>
<tr class="separator:aa4537d9d39f2ba775dc98ef6d3fc6d4e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae8782f3758e07a82853115c2d7305dc7"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classipc_1_1transport_1_1Blob__stream__mq__sender.html#ae8782f3758e07a82853115c2d7305dc7">Blob_stream_mq_sender</a> (<a class="el" href="classipc_1_1transport_1_1Blob__stream__mq__sender.html">Blob_stream_mq_sender</a> &amp;&amp;src)</td></tr>
<tr class="memdesc:ae8782f3758e07a82853115c2d7305dc7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Move-constructs from <code>src</code>; <code>src</code> becomes as-if default-cted (therefore in NULL state).  <a href="classipc_1_1transport_1_1Blob__stream__mq__sender.html#ae8782f3758e07a82853115c2d7305dc7">More...</a><br /></td></tr>
<tr class="separator:ae8782f3758e07a82853115c2d7305dc7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad3cef9a7f7218295790ad2fcd5520224"><td class="memItemLeft" align="right" valign="top"><a id="ad3cef9a7f7218295790ad2fcd5520224" name="ad3cef9a7f7218295790ad2fcd5520224"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>Blob_stream_mq_sender</b> (const <a class="el" href="classipc_1_1transport_1_1Blob__stream__mq__sender.html">Blob_stream_mq_sender</a> &amp;)=delete</td></tr>
<tr class="memdesc:ad3cef9a7f7218295790ad2fcd5520224"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy construction is disallowed. <br /></td></tr>
<tr class="separator:ad3cef9a7f7218295790ad2fcd5520224"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0986c0ee166edfdbb96b4a581678d01e"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classipc_1_1transport_1_1Blob__stream__mq__sender.html#a0986c0ee166edfdbb96b4a581678d01e">~Blob_stream_mq_sender</a> ()</td></tr>
<tr class="memdesc:a0986c0ee166edfdbb96b4a581678d01e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Implements <a class="el" href="classipc_1_1transport_1_1Blob__sender.html" title="A documentation-only concept defining the behavior of an object capable of reliably/in-order sending ...">Blob_sender</a> API.  <a href="classipc_1_1transport_1_1Blob__stream__mq__sender.html#a0986c0ee166edfdbb96b4a581678d01e">More...</a><br /></td></tr>
<tr class="separator:a0986c0ee166edfdbb96b4a581678d01e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a632ad9aa40e557a9d5edef4b122ddaf9"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classipc_1_1transport_1_1Blob__stream__mq__sender.html">Blob_stream_mq_sender</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classipc_1_1transport_1_1Blob__stream__mq__sender.html#a632ad9aa40e557a9d5edef4b122ddaf9">operator=</a> (<a class="el" href="classipc_1_1transport_1_1Blob__stream__mq__sender.html">Blob_stream_mq_sender</a> &amp;&amp;src)</td></tr>
<tr class="memdesc:a632ad9aa40e557a9d5edef4b122ddaf9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Move-assigns from <code>src</code>; <code>*this</code> acts as if destructed; <code>src</code> becomes as-if default-cted (therefore in NULL state).  <a href="classipc_1_1transport_1_1Blob__stream__mq__sender.html#a632ad9aa40e557a9d5edef4b122ddaf9">More...</a><br /></td></tr>
<tr class="separator:a632ad9aa40e557a9d5edef4b122ddaf9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a76419b55b2411de21b704b4385b1eac7"><td class="memItemLeft" align="right" valign="top"><a id="a76419b55b2411de21b704b4385b1eac7" name="a76419b55b2411de21b704b4385b1eac7"></a>
<a class="el" href="classipc_1_1transport_1_1Blob__stream__mq__sender.html">Blob_stream_mq_sender</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>operator=</b> (const <a class="el" href="classipc_1_1transport_1_1Blob__stream__mq__sender.html">Blob_stream_mq_sender</a> &amp;)=delete</td></tr>
<tr class="memdesc:a76419b55b2411de21b704b4385b1eac7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy assignment is disallowed. <br /></td></tr>
<tr class="separator:a76419b55b2411de21b704b4385b1eac7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4e5d7add242439e01c56cab3697aebb6"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classipc_1_1transport_1_1Blob__stream__mq__sender.html#a4e5d7add242439e01c56cab3697aebb6">send_blob_max_size</a> () const</td></tr>
<tr class="memdesc:a4e5d7add242439e01c56cab3697aebb6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Implements <a class="el" href="classipc_1_1transport_1_1Blob__sender.html" title="A documentation-only concept defining the behavior of an object capable of reliably/in-order sending ...">Blob_sender</a> API per contract.  <a href="classipc_1_1transport_1_1Blob__stream__mq__sender.html#a4e5d7add242439e01c56cab3697aebb6">More...</a><br /></td></tr>
<tr class="separator:a4e5d7add242439e01c56cab3697aebb6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1d23a47d08ac7c31aa546ea02bb24c55"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classipc_1_1transport_1_1Blob__stream__mq__sender.html#a1d23a47d08ac7c31aa546ea02bb24c55">send_blob</a> (const <a class="el" href="namespaceipc_1_1util.html#ae0be7edba7e30ffa3f8b742af621f2ab">util::Blob_const</a> &amp;blob, <a class="el" href="namespaceipc.html#aa3192e586cc45d3e7c22463bf2760f89">Error_code</a> *err_code=0)</td></tr>
<tr class="memdesc:a1d23a47d08ac7c31aa546ea02bb24c55"><td class="mdescLeft">&#160;</td><td class="mdescRight">Implements <a class="el" href="classipc_1_1transport_1_1Blob__sender.html" title="A documentation-only concept defining the behavior of an object capable of reliably/in-order sending ...">Blob_sender</a> API per contract.  <a href="classipc_1_1transport_1_1Blob__stream__mq__sender.html#a1d23a47d08ac7c31aa546ea02bb24c55">More...</a><br /></td></tr>
<tr class="separator:a1d23a47d08ac7c31aa546ea02bb24c55"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af47c711508c0d4fa9766d8d3481ff583"><td class="memTemplParams" colspan="2">template&lt;typename Task_err &gt; </td></tr>
<tr class="memitem:af47c711508c0d4fa9766d8d3481ff583"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classipc_1_1transport_1_1Blob__stream__mq__sender.html#af47c711508c0d4fa9766d8d3481ff583">async_end_sending</a> (Task_err &amp;&amp;on_done_func)</td></tr>
<tr class="memdesc:af47c711508c0d4fa9766d8d3481ff583"><td class="mdescLeft">&#160;</td><td class="mdescRight">Implements <a class="el" href="classipc_1_1transport_1_1Blob__sender.html" title="A documentation-only concept defining the behavior of an object capable of reliably/in-order sending ...">Blob_sender</a> API per contract.  <a href="classipc_1_1transport_1_1Blob__stream__mq__sender.html#af47c711508c0d4fa9766d8d3481ff583">More...</a><br /></td></tr>
<tr class="separator:af47c711508c0d4fa9766d8d3481ff583"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2d6eac56c4f66d9a39fb3e4d1b5218d8"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classipc_1_1transport_1_1Blob__stream__mq__sender.html#a2d6eac56c4f66d9a39fb3e4d1b5218d8">end_sending</a> ()</td></tr>
<tr class="memdesc:a2d6eac56c4f66d9a39fb3e4d1b5218d8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Implements <a class="el" href="classipc_1_1transport_1_1Blob__sender.html" title="A documentation-only concept defining the behavior of an object capable of reliably/in-order sending ...">Blob_sender</a> API per contract.  <a href="classipc_1_1transport_1_1Blob__stream__mq__sender.html#a2d6eac56c4f66d9a39fb3e4d1b5218d8">More...</a><br /></td></tr>
<tr class="separator:a2d6eac56c4f66d9a39fb3e4d1b5218d8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5453dccb1253f77975fcc0e2ad4cc0ea"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classipc_1_1transport_1_1Blob__stream__mq__sender.html#a5453dccb1253f77975fcc0e2ad4cc0ea">auto_ping</a> (<a class="el" href="namespaceipc_1_1util.html#ac66141280c3b7295a86b65209f31cc58">util::Fine_duration</a> period=boost::chrono::seconds(2))</td></tr>
<tr class="memdesc:a5453dccb1253f77975fcc0e2ad4cc0ea"><td class="mdescLeft">&#160;</td><td class="mdescRight">Implements <a class="el" href="classipc_1_1transport_1_1Blob__sender.html" title="A documentation-only concept defining the behavior of an object capable of reliably/in-order sending ...">Blob_sender</a> API per contract.  <a href="classipc_1_1transport_1_1Blob__stream__mq__sender.html#a5453dccb1253f77975fcc0e2ad4cc0ea">More...</a><br /></td></tr>
<tr class="separator:a5453dccb1253f77975fcc0e2ad4cc0ea"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab4ae64f241761ab94ed005f65a55a318"><td class="memItemLeft" align="right" valign="top">const std::string &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classipc_1_1transport_1_1Blob__stream__mq__sender.html#ab4ae64f241761ab94ed005f65a55a318">nickname</a> () const</td></tr>
<tr class="memdesc:ab4ae64f241761ab94ed005f65a55a318"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns nickname, a brief string suitable for logging.  <a href="classipc_1_1transport_1_1Blob__stream__mq__sender.html#ab4ae64f241761ab94ed005f65a55a318">More...</a><br /></td></tr>
<tr class="separator:ab4ae64f241761ab94ed005f65a55a318"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa116304df6214c3ae5d18dbf3305da87"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="namespaceipc_1_1transport.html#a33de1c256addb3964b839dc2dd407d24">Shared_name</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classipc_1_1transport_1_1Blob__stream__mq__sender.html#aa116304df6214c3ae5d18dbf3305da87">absolute_name</a> () const</td></tr>
<tr class="memdesc:aa116304df6214c3ae5d18dbf3305da87"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns name equal to <code>mq.absolute_name()</code>, where <code>mq</code> was passed to ctor, at the time it was passed to ctor.  <a href="classipc_1_1transport_1_1Blob__stream__mq__sender.html#aa116304df6214c3ae5d18dbf3305da87">More...</a><br /></td></tr>
<tr class="separator:aa116304df6214c3ae5d18dbf3305da87"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-static-attribs" name="pub-static-attribs"></a>
Static Public Attributes</h2></td></tr>
<tr class="memitem:a57164996725324b544aedf6707d158d1"><td class="memItemLeft" align="right" valign="top">static const <a class="el" href="namespaceipc_1_1transport.html#a33de1c256addb3964b839dc2dd407d24">Shared_name</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classipc_1_1transport_1_1Blob__stream__mq__sender.html#a57164996725324b544aedf6707d158d1">S_RESOURCE_TYPE_ID</a> = Mq::S_RESOURCE_TYPE_ID</td></tr>
<tr class="memdesc:a57164996725324b544aedf6707d158d1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Implements concept API. Equals <code>Mq::S_RESOURCE_TYPE_ID</code>.  <a href="classipc_1_1transport_1_1Blob__stream__mq__sender.html#a57164996725324b544aedf6707d158d1">More...</a><br /></td></tr>
<tr class="separator:a57164996725324b544aedf6707d158d1"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pri-types" name="pri-types"></a>
Private Types</h2></td></tr>
<tr class="memitem:ac97c9d7d3dad9e48151f92f884d5f12e"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classipc_1_1transport_1_1Blob__stream__mq__sender.html#ac97c9d7d3dad9e48151f92f884d5f12e">Impl_ptr</a> = std::experimental::propagate_const&lt; boost::movelib::unique_ptr&lt; <a class="el" href="classipc_1_1transport_1_1Blob__stream__mq__sender__impl.html">Blob_stream_mq_sender_impl</a>&lt; <a class="el" href="classipc_1_1transport_1_1Blob__stream__mq__sender.html#aa2cb5c8fc525ae45edf8ab1b257f328d">Mq</a> &gt; &gt; &gt;</td></tr>
<tr class="memdesc:ac97c9d7d3dad9e48151f92f884d5f12e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Short-hand for <code>const</code>-respecting wrapper around <a class="el" href="classipc_1_1transport_1_1Blob__stream__mq__sender__impl.html" title="Internal, non-movable pImpl-lite implementation of Blob_stream_mq_sender class template.">Blob_stream_mq_sender_impl</a> for the pImpl idiom.  <a href="classipc_1_1transport_1_1Blob__stream__mq__sender.html#ac97c9d7d3dad9e48151f92f884d5f12e">More...</a><br /></td></tr>
<tr class="separator:ac97c9d7d3dad9e48151f92f884d5f12e"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pri-attribs" name="pri-attribs"></a>
Private Attributes</h2></td></tr>
<tr class="memitem:af81738986da26bdd1bb3eef3ccd29296"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classipc_1_1transport_1_1Blob__stream__mq__sender.html#ac97c9d7d3dad9e48151f92f884d5f12e">Impl_ptr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classipc_1_1transport_1_1Blob__stream__mq__sender.html#af81738986da26bdd1bb3eef3ccd29296">m_impl</a></td></tr>
<tr class="memdesc:af81738986da26bdd1bb3eef3ccd29296"><td class="mdescLeft">&#160;</td><td class="mdescRight">The true implementation of this class. See also our class doc header.  <a href="classipc_1_1transport_1_1Blob__stream__mq__sender.html#af81738986da26bdd1bb3eef3ccd29296">More...</a><br /></td></tr>
<tr class="separator:af81738986da26bdd1bb3eef3ccd29296"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="friends" name="friends"></a>
Friends</h2></td></tr>
<tr class="memitem:ac705c3a4a0a532bf9e432aa3ba0db7da"><td class="memTemplParams" colspan="2"><a id="ac705c3a4a0a532bf9e432aa3ba0db7da" name="ac705c3a4a0a532bf9e432aa3ba0db7da"></a>
template&lt;typename Persistent_mq_handle2 &gt; </td></tr>
<tr class="memitem:ac705c3a4a0a532bf9e432aa3ba0db7da"><td class="memTemplItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>operator&lt;&lt;</b> (std::ostream &amp;os, const <a class="el" href="classipc_1_1transport_1_1Blob__stream__mq__sender.html">Blob_stream_mq_sender</a>&lt; Persistent_mq_handle2 &gt; &amp;val)</td></tr>
<tr class="memdesc:ac705c3a4a0a532bf9e432aa3ba0db7da"><td class="mdescLeft">&#160;</td><td class="mdescRight">Friend of <a class="el" href="classipc_1_1transport_1_1Blob__stream__mq__sender.html" title="Implements Blob_sender concept by using an adopted Persistent_mq_handle MQ handle to an MQ (message q...">Blob_stream_mq_sender</a>. <br /></td></tr>
<tr class="separator:ac705c3a4a0a532bf9e432aa3ba0db7da"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="related" name="related"></a>
Related Functions</h2></td></tr>
<tr><td class="ititle" colspan="2"><p >(Note that these are not member functions.) </p>
</td></tr>
<tr class="memitem:acb29aca9de166fd1f24a09d08afe2fcc"><td class="memTemplParams" colspan="2">template&lt;typename <a class="el" href="classipc_1_1transport_1_1Persistent__mq__handle.html">Persistent_mq_handle</a> &gt; </td></tr>
<tr class="memitem:acb29aca9de166fd1f24a09d08afe2fcc"><td class="memTemplItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classipc_1_1transport_1_1Blob__stream__mq__sender.html#acb29aca9de166fd1f24a09d08afe2fcc">operator&lt;&lt;</a> (std::ostream &amp;os, const <a class="el" href="classipc_1_1transport_1_1Blob__stream__mq__sender.html">Blob_stream_mq_sender</a>&lt; <a class="el" href="classipc_1_1transport_1_1Persistent__mq__handle.html">Persistent_mq_handle</a> &gt; &amp;val)</td></tr>
<tr class="memdesc:acb29aca9de166fd1f24a09d08afe2fcc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Prints string representation of the given <code><a class="el" href="classipc_1_1transport_1_1Blob__stream__mq__sender.html" title="Implements Blob_sender concept by using an adopted Persistent_mq_handle MQ handle to an MQ (message q...">Blob_stream_mq_sender</a></code> to the given <code>ostream</code>.  <a href="classipc_1_1transport_1_1Blob__stream__mq__sender.html#acb29aca9de166fd1f24a09d08afe2fcc">More...</a><br /></td></tr>
<tr class="separator:acb29aca9de166fd1f24a09d08afe2fcc"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="inherited" name="inherited"></a>
Additional Inherited Members</h2></td></tr>
<tr class="inherit_header pub_static_methods_classipc_1_1transport_1_1Blob__stream__mq__base"><td colspan="2" onclick="javascript:toggleInherit('pub_static_methods_classipc_1_1transport_1_1Blob__stream__mq__base')"><img src="closed.png" alt="-"/>&#160;Static Public Member Functions inherited from <a class="el" href="classipc_1_1transport_1_1Blob__stream__mq__base.html">ipc::transport::Blob_stream_mq_base&lt; Persistent_mq_handle &gt;</a></td></tr>
<tr class="memitem:ac1230ff7e73783da730b8639c30511e2 inherit pub_static_methods_classipc_1_1transport_1_1Blob__stream__mq__base"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classipc_1_1transport_1_1Blob__stream__mq__base.html#ac1230ff7e73783da730b8639c30511e2">remove_persistent</a> (flow::log::Logger *logger_ptr, const <a class="el" href="namespaceipc_1_1transport.html#a33de1c256addb3964b839dc2dd407d24">Shared_name</a> &amp;name, <a class="el" href="namespaceipc.html#aa3192e586cc45d3e7c22463bf2760f89">Error_code</a> *err_code=0)</td></tr>
<tr class="memdesc:ac1230ff7e73783da730b8639c30511e2 inherit pub_static_methods_classipc_1_1transport_1_1Blob__stream__mq__base"><td class="mdescLeft">&#160;</td><td class="mdescRight">Removes the <a class="el" href="classipc_1_1transport_1_1Blob__stream__mq__sender.html" title="Implements Blob_sender concept by using an adopted Persistent_mq_handle MQ handle to an MQ (message q...">Blob_stream_mq_sender</a> and/or <a class="el" href="classipc_1_1transport_1_1Blob__stream__mq__receiver.html" title="Implements Blob_receiver concept by using an adopted Persistent_mq_handle MQ handle to an MQ (message...">Blob_stream_mq_receiver</a> persistent resources associated with a <a class="el" href="classipc_1_1transport_1_1Persistent__mq__handle.html" title="A documentation-only concept defining the behavior of an object representing a light-weight handle to...">Persistent_mq_handle</a> with the given name.  <a href="classipc_1_1transport_1_1Blob__stream__mq__base.html#ac1230ff7e73783da730b8639c30511e2">More...</a><br /></td></tr>
<tr class="separator:ac1230ff7e73783da730b8639c30511e2 inherit pub_static_methods_classipc_1_1transport_1_1Blob__stream__mq__base"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8ef2c620fae98180ecd482f0093da44f inherit pub_static_methods_classipc_1_1transport_1_1Blob__stream__mq__base"><td class="memTemplParams" colspan="2">template&lt;typename Handle_name_func &gt; </td></tr>
<tr class="memitem:a8ef2c620fae98180ecd482f0093da44f inherit pub_static_methods_classipc_1_1transport_1_1Blob__stream__mq__base"><td class="memTemplItemLeft" align="right" valign="top">static void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classipc_1_1transport_1_1Blob__stream__mq__base.html#a8ef2c620fae98180ecd482f0093da44f">for_each_persistent</a> (const Handle_name_func &amp;handle_name_func)</td></tr>
<tr class="memdesc:a8ef2c620fae98180ecd482f0093da44f inherit pub_static_methods_classipc_1_1transport_1_1Blob__stream__mq__base"><td class="mdescLeft">&#160;</td><td class="mdescRight">Forwards to <a class="el" href="classipc_1_1transport_1_1Persistent__mq__handle.html#ac14dd419cdbc97b6630900268f8b7dd2" title="Lists all named persistent MQs currently persisting, invoking the given handler synchronously on each...">Persistent_mq_handle::for_each_persistent()</a>.  <a href="classipc_1_1transport_1_1Blob__stream__mq__base.html#a8ef2c620fae98180ecd482f0093da44f">More...</a><br /></td></tr>
<tr class="separator:a8ef2c620fae98180ecd482f0093da44f inherit pub_static_methods_classipc_1_1transport_1_1Blob__stream__mq__base"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><div class="compoundTemplParams">template&lt;typename <a class="el" href="classipc_1_1transport_1_1Persistent__mq__handle.html">Persistent_mq_handle</a>&gt;<br />
class ipc::transport::Blob_stream_mq_sender&lt; Persistent_mq_handle &gt;</div><p >Implements <a class="el" href="classipc_1_1transport_1_1Blob__sender.html" title="A documentation-only concept defining the behavior of an object capable of reliably/in-order sending ...">Blob_sender</a> concept by using an adopted <a class="el" href="classipc_1_1transport_1_1Persistent__mq__handle.html" title="A documentation-only concept defining the behavior of an object representing a light-weight handle to...">Persistent_mq_handle</a> MQ handle to an MQ (message queue) of that type, such as a POSIX or bipc MQ. </p>
<p >This allows for high-performance, potentially zero-copy (except for copying into the transport MQ) of discrete messages, each containing a binary blob. This is a low-level (core) transport mechanism; higher-level (structured) transport mechanisms may use <a class="el" href="classipc_1_1transport_1_1Blob__stream__mq__sender.html" title="Implements Blob_sender concept by using an adopted Persistent_mq_handle MQ handle to an MQ (message q...">Blob_stream_mq_sender</a> (and <a class="el" href="classipc_1_1transport_1_1Blob__stream__mq__receiver.html" title="Implements Blob_receiver concept by using an adopted Persistent_mq_handle MQ handle to an MQ (message...">Blob_stream_mq_receiver</a>) to enable their work.</p>
<h3>Informal comparison to other core transport mechanisms</h3>
<p >It is intended for transmission of relatively short messages &ndash; rough guidance being for max length being in the 10s-of-KiB range. With a modern Linux kernel on server hardware from about 2014 to 2020, our performance tests show that its raw speed for messages of aforementioned size is comparable to non-zero-copy mechanism based on Unix domain sockets. Technically we found <code>Blob_stream_mq_*&lt;<a class="el" href="classipc_1_1transport_1_1Posix__mq__handle.html" title="Implements the Persistent_mq_handle concept by wrapping the POSIX message queue API (see man mq_overv...">Posix_mq_handle</a>&gt;</code> to be somewhat faster; and <code>Blob_stream_*&lt;<a class="el" href="classipc_1_1transport_1_1Bipc__mq__handle.html" title="Implements the Persistent_mq_handle concept by thinly wrapping bipc::message_queue,...">Bipc_mq_handle</a>&gt;</code> (internally, SHM-based) somewhat slower. However, for best perf, it is recommended to send handles to SHM areas containing arbitrarily long structured messages (such as ones [de]serialized using zero-copy builders: capnp and the like). This further reduces the importance of relative perf compared to other low-level transports (which, as noted, is pretty close regardless &ndash; though this is bound to stop being true for much longer messages, if the send-SHM-handles technique were to <em>not</em> be used).</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classipc_1_1transport_1_1Native__socket__stream.html" title="Implements both Native_handle_sender and Native_handle_receiver concepts by using a stream-oriented U...">Native_socket_stream</a> which also implements <a class="el" href="classipc_1_1transport_1_1Blob__sender.html" title="A documentation-only concept defining the behavior of an object capable of reliably/in-order sending ...">Blob_sender</a> (and <a class="el" href="classipc_1_1transport_1_1Blob__receiver.html" title="A documentation-only concept defining the behavior of an object capable of reliably/in-order receivin...">Blob_receiver</a>) in its degraded mode (where one does not transmit native handles, only blobs).</dd></dl>
<h3>Relationship between <code>Blob_stream_mq_*</code>, the underlying MQ resource, and its Shared_name</h3>
<p >If one is familiar with MQs (doesn't matter whether POSIX or bipc &ndash; their persistence semantics are identical), it is easy to become confused as to what <code>Blob_stream_mq_*</code> is modeling. To explain it then:</p>
<ul>
<li>Think of the MQ itself as a file &ndash; albeit in RAM &ndash; a bulky thing that can store a certain number of bytes.</li>
<li>Think of its Shared_name as a directory entry, essentially a file name in a certain directory in the file system.</li>
<li>Think of a <a class="el" href="classipc_1_1transport_1_1Persistent__mq__handle.html" title="A documentation-only concept defining the behavior of an object representing a light-weight handle to...">Persistent_mq_handle</a> (the actual type being a template param; namely as of this writing <a class="el" href="classipc_1_1transport_1_1Posix__mq__handle.html" title="Implements the Persistent_mq_handle concept by wrapping the POSIX message queue API (see man mq_overv...">Posix_mq_handle</a> or <a class="el" href="classipc_1_1transport_1_1Bipc__mq__handle.html" title="Implements the Persistent_mq_handle concept by thinly wrapping bipc::message_queue,...">Bipc_mq_handle</a>) as a file handle. They can be opened for reading, writing, or both. More than 1 can be opened simultaneously.<ul>
<li>Writing through this handle <em>pushes</em> a message but really writes those bytes somewhere in the "file" (MQ) in RAM. Any handle can be used for this; one can write through handle X and then right after that read through same handle X if desired.</li>
<li>Reading, similarly, <em>pops</em> a message by reading bytes from the "file."</li>
<li>One can open handle X, close handle X, wait 5 minutes, and from even another process open handle Y to the same name: the "stuff" (un-popped messages) will still be there.</li>
</ul>
</li>
</ul>
<p >So that's MQs. However, <code>Blob_stream_mq_*</code> &ndash; implementing <a class="el" href="classipc_1_1transport_1_1Blob__sender.html" title="A documentation-only concept defining the behavior of an object capable of reliably/in-order sending ...">Blob_sender</a> and <a class="el" href="classipc_1_1transport_1_1Blob__receiver.html" title="A documentation-only concept defining the behavior of an object capable of reliably/in-order receivin...">Blob_receiver</a> as they do &ndash; emphatically does <em>not</em> model that kind of free-for-all access (read/write, through 3+ handles if desired). Instead it models a <em>one-direction pipe</em>. So: there is up to 1 (exactly 1, if you want it to be useful) <a class="el" href="classipc_1_1transport_1_1Blob__stream__mq__sender.html" title="Implements Blob_sender concept by using an adopted Persistent_mq_handle MQ handle to an MQ (message q...">Blob_stream_mq_sender</a> per Shared_name. It <em>only</em> writes (pushes). There is up to 1 (exactly 1, if...) <a class="el" href="classipc_1_1transport_1_1Blob__stream__mq__receiver.html" title="Implements Blob_receiver concept by using an adopted Persistent_mq_handle MQ handle to an MQ (message...">Blob_stream_mq_receiver</a> per Shared_name. It <em>only</em> reads (pops). Therefore trying to create a 2nd <code>_sender</code>, when 1 already exists &ndash; in <em>any</em> process &ndash; is an error and does not work (an error is emitted from ctor; see its doc header). Same thing for <code>_receiver</code>.</p>
<p >Moreover it is not a persistent pipe, either, even though the underlying MQ is quite capable of persistence (until reboot at any rate). Per Blob_sender/Blob_receiver concept, when a destructor for <em>either</em> the 1 <a class="el" href="classipc_1_1transport_1_1Blob__stream__mq__sender.html" title="Implements Blob_sender concept by using an adopted Persistent_mq_handle MQ handle to an MQ (message q...">Blob_stream_mq_sender</a> <em>or</em> the 1 <a class="el" href="classipc_1_1transport_1_1Blob__stream__mq__receiver.html" title="Implements Blob_receiver concept by using an adopted Persistent_mq_handle MQ handle to an MQ (message...">Blob_stream_mq_receiver</a> is called (whichever happens first):</p><ul>
<li>The Shared_name "directory entry" is deleted. The MQ becomes anonymous: creating an MQ with the same name will begin working &ndash; and will create a totally new MQ.<ul>
<li>(Caveat/corner case: In practice this is only useful after <em>both</em> destructors have run. Indeed MQ creation is possible after 1, but not the other, has executed; but then that "the other" will sadly delete the new, same-named MQ. So don't.)</li>
</ul>
</li>
<li>The MQ handle is closed.</li>
</ul>
<p >Then once the other peer object (whether receiver or sender) dtor also executes:</p><ul>
<li>(There is no "directory entry" to delete any longer.)</li>
<li>The MQ handle is closed.</li>
</ul>
<p >That last step brings the ref-count of things referring to the underlying MQ "file" (in RAM) to 0. Hence the MQ "file" (in RAM) is deleted (RAM is freed, becoming usable by other stuff, like maybe the general heap).</p>
<p >That is how the Blob_sender/Blob_receiver one-direction pipe concept is satisfied, even though a general MQ has greater capabilities. That's not to say one should not use those; just not what this class is for; but one can use Posix_mq_handle/Bipc_mq_handle directly if necessary.</p>
<h3>Cleanup</h3>
<p >As just described, the two <code>Blob_stream_mq_*</code> classes are fairly aggressive about deleting the underlying MQ RAM resource. It is, generally, important not to leave those lying around post-use, as they can take non-trivial RAM.</p>
<p >However, MQs (being kernel-persistent at least) require an even greater amount of care in cleanup than that. Assuming buglessness of the classes themselves and a graceful shutdown of the program &ndash; including on clean exception handling, wherein the stack fully unwinds, and the destructors all run &ndash; there is no problem.</p>
<p >However, if something (a hard crash perhaps) prevents a <a class="el" href="classipc_1_1transport_1_1Blob__stream__mq__sender.html" title="Implements Blob_sender concept by using an adopted Persistent_mq_handle MQ handle to an MQ (message q...">Blob_stream_mq_sender</a> or <a class="el" href="classipc_1_1transport_1_1Blob__stream__mq__receiver.html" title="Implements Blob_receiver concept by using an adopted Persistent_mq_handle MQ handle to an MQ (message...">Blob_stream_mq_receiver</a> dtor from running, the MQ "file" (in RAM) shall leak. It is your responsibility to implement a contingency for such leaks. (Note that, beyond RAM, there are limits on the number of MQs &ndash; and certain other internally used kernel-persistent objects &ndash; that exist system-wide. If reached &ndash; which is not hard &ndash; then things will screech to a halt, until something cleans up the leaks.) We provide 2 techniques to aid this.</p>
<ul>
<li>You can maintain a <em>persistent</em> registry of created MQ streams. In that case you'll have a list of <code>mq.absolute_name()</code>s (where <code>mq</code> is passed to our and the receiver peer's ctors). After any potential abort, in another instance (process) of the application, invoke <a class="el" href="classipc_1_1transport_1_1Blob__stream__mq__base.html#ac1230ff7e73783da730b8639c30511e2" title="Removes the Blob_stream_mq_sender and/or Blob_stream_mq_receiver persistent resources associated with...">Blob_stream_mq_base::remove_persistent()</a> on each such name.</li>
<li>To avoid the persistent registry, a much easier, though less surgical/definitive, technique is to maintain a prefix-based naming convention for <code>mq.absolute_name()</code>. Then: After any potential abort, in another instance (process) of the application, invoke <a class="el" href="namespaceipc_1_1util.html#ad6be904bf1b0fe6659a11dec0fabbf6b" title="Utility that invokes remove_each_persistent_if() with the filter that returns true (yes,...">remove_each_persistent_with_name_prefix&lt;Blob_stream_mq_base&gt;()</a>, passing in the applicable Shared_name prefix. Having done so, the leaks (if any) should be cleaned.</li>
</ul>
<p ><a class="el" href="namespaceipc_1_1session.html" title="Flow-IPC module providing the broad lifecycle and shared-resource organization – via the session conc...">ipc::session</a> uses the 2nd technique.</p>
<h3>Reusing the same <a class="el" href="classipc_1_1transport_1_1Blob__stream__mq__sender.html#aa116304df6214c3ae5d18dbf3305da87" title="Returns name equal to mq.absolute_name(), where mq was passed to ctor, at the time it was passed to c...">absolute_name()</a> for a new MQ and one-direction pipe</h3>
<p >Formally, as pointed out in various docs, this is possible no later than the return of the later of the <a class="el" href="classipc_1_1transport_1_1Blob__stream__mq__sender.html" title="Implements Blob_sender concept by using an adopted Persistent_mq_handle MQ handle to an MQ (message q...">Blob_stream_mq_sender</a> and <a class="el" href="classipc_1_1transport_1_1Blob__stream__mq__receiver.html" title="Implements Blob_receiver concept by using an adopted Persistent_mq_handle MQ handle to an MQ (message...">Blob_stream_mq_receiver</a> dtors. Informally, we recommend against this if it can be avoided. Sure, it's fine if you can guarantee no process &ndash; even <em>another</em> process &ndash; would try to do so until in fact both of those dtors has run. This may not be trivial; it might even require more IPC to coordinate! It is better to segregate these things via unique names, using a namespace from something like a PID which will not, within reason, repeat before reboot. <a class="el" href="namespaceipc_1_1session.html" title="Flow-IPC module providing the broad lifecycle and shared-resource organization – via the session conc...">ipc::session</a> uses this technique for various kernel-persistent resources including (not limited to) these MQs.</p>
<h3>Thread safety</h3>
<p >We add no more thread safety guarantees than those mandated by <a class="el" href="classipc_1_1transport_1_1Blob__sender.html" title="A documentation-only concept defining the behavior of an object capable of reliably/in-order sending ...">Blob_sender</a> concept.</p>
<h3>Implementation design/rationale</h3>
<p >Internally this class template uses uses the pImpl idiom (see <a href="https://en.cppreference.com/w/cpp/language/pimpl">https://en.cppreference.com/w/cpp/language/pimpl</a> for an excellent overview), except it is what I (ygoldfel) term "pImpl-lite". That is: it is pImpl that achieves performant and easily-coded move-semantics &ndash; in the face of fairly complex async impl details &ndash; but does <em>not</em> achieve a stable ABI (the thing where one can change impl method bodies without recompiling the code/changing the binary signature of the class). Long story short:</p><ul>
<li>See <a class="el" href="classipc_1_1transport_1_1Native__socket__stream.html" title="Implements both Native_handle_sender and Native_handle_receiver concepts by using a stream-oriented U...">Native_socket_stream</a>'s "Implementation design/rationale" for why they chose pImpl. The same applies here.</li>
<li>However, we are a template, and this template-ness is not reasonably possible to elide (via type erasure or something) into a non-template impl class. Therefore, simply, there is the non-movable <a class="el" href="classipc_1_1transport_1_1Blob__stream__mq__sender__impl.html" title="Internal, non-movable pImpl-lite implementation of Blob_stream_mq_sender class template.">Blob_stream_mq_sender_impl</a> class <em>template</em> which is in detail/ and not to be <code>#include</code>d by the user; but <em>we</em> simply <code>#include</code> it above this doc header; and then write <a class="el" href="classipc_1_1transport_1_1Blob__stream__mq__sender.html" title="Implements Blob_sender concept by using an adopted Persistent_mq_handle MQ handle to an MQ (message q...">Blob_stream_mq_sender</a> in terms of it.</li>
<li>So we get the quick/easy move-semantics that pImpl gives; but we don't get the binary separation between interface and implementation.<ul>
<li>Also, stylistically, I (ygoldfel) did not bother to make <a class="el" href="classipc_1_1transport_1_1Blob__stream__mq__sender__impl.html" title="Internal, non-movable pImpl-lite implementation of Blob_stream_mq_sender class template.">Blob_stream_mq_sender_impl</a> an inner class. It's in detail/ which means user must not instantiate it; this is a common pattern. I did not bother vaguely because it's not full pImpl anyway, and the circular reference nonsense would be annoying.</li>
</ul>
</li>
</ul>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classipc_1_1transport_1_1Blob__stream__mq__sender__impl.html" title="Internal, non-movable pImpl-lite implementation of Blob_stream_mq_sender class template.">Blob_stream_mq_sender_impl</a> doc header.</dd></dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname"><a class="el" href="classipc_1_1transport_1_1Persistent__mq__handle.html" title="A documentation-only concept defining the behavior of an object representing a light-weight handle to...">Persistent_mq_handle</a></td><td>See <a class="el" href="classipc_1_1transport_1_1Persistent__mq__handle.html" title="A documentation-only concept defining the behavior of an object representing a light-weight handle to...">Persistent_mq_handle</a> concept doc header.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classipc_1_1transport_1_1Blob__sender.html" title="A documentation-only concept defining the behavior of an object capable of reliably/in-order sending ...">Blob_sender</a>: implemented concept. </dd></dl>

<p class="definition">Definition at line <a class="el" href="blob__stream__mq__snd_8hpp_source.html#l00163">163</a> of file <a class="el" href="blob__stream__mq__snd_8hpp_source.html">blob_stream_mq_snd.hpp</a>.</p>
</div><h2 class="groupheader">Member Typedef Documentation</h2>
<a id="a96cccfae5eb2ceb480422869e8cca0d5" name="a96cccfae5eb2ceb480422869e8cca0d5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a96cccfae5eb2ceb480422869e8cca0d5">&#9670;&nbsp;</a></span>Async_io_obj</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename <a class="el" href="classipc_1_1transport_1_1Persistent__mq__handle.html">Persistent_mq_handle</a> &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classipc_1_1transport_1_1Blob__stream__mq__sender.html">ipc::transport::Blob_stream_mq_sender</a>&lt; <a class="el" href="classipc_1_1transport_1_1Persistent__mq__handle.html">Persistent_mq_handle</a> &gt;::Async_io_obj =  <a class="el" href="classipc_1_1transport_1_1Null__peer.html">Null_peer</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>You may disregard. </p>

<p class="definition">Definition at line <a class="el" href="blob__stream__mq__snd_8hpp_source.html#l00177">177</a> of file <a class="el" href="blob__stream__mq__snd_8hpp_source.html">blob_stream_mq_snd.hpp</a>.</p>

</div>
</div>
<a id="a57ed4042d5b70b0c1b73bcb75a9e5f85" name="a57ed4042d5b70b0c1b73bcb75a9e5f85"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a57ed4042d5b70b0c1b73bcb75a9e5f85">&#9670;&nbsp;</a></span>Base</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename <a class="el" href="classipc_1_1transport_1_1Persistent__mq__handle.html">Persistent_mq_handle</a> &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classipc_1_1transport_1_1Blob__stream__mq__sender.html">ipc::transport::Blob_stream_mq_sender</a>&lt; <a class="el" href="classipc_1_1transport_1_1Persistent__mq__handle.html">Persistent_mq_handle</a> &gt;::Base =  <a class="el" href="classipc_1_1transport_1_1Blob__stream__mq__base.html">Blob_stream_mq_base</a>&lt;<a class="el" href="classipc_1_1transport_1_1Persistent__mq__handle.html">Persistent_mq_handle</a>&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Short-hand for our base with <code>static</code> goodies at least. </p>

<p class="definition">Definition at line <a class="el" href="blob__stream__mq__snd_8hpp_source.html#l00169">169</a> of file <a class="el" href="blob__stream__mq__snd_8hpp_source.html">blob_stream_mq_snd.hpp</a>.</p>

</div>
</div>
<a id="ac97c9d7d3dad9e48151f92f884d5f12e" name="ac97c9d7d3dad9e48151f92f884d5f12e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac97c9d7d3dad9e48151f92f884d5f12e">&#9670;&nbsp;</a></span>Impl_ptr</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename <a class="el" href="classipc_1_1transport_1_1Persistent__mq__handle.html">Persistent_mq_handle</a> &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classipc_1_1transport_1_1Blob__stream__mq__sender.html">ipc::transport::Blob_stream_mq_sender</a>&lt; <a class="el" href="classipc_1_1transport_1_1Persistent__mq__handle.html">Persistent_mq_handle</a> &gt;::Impl_ptr =  std::experimental::propagate_const&lt;boost::movelib::unique_ptr&lt;<a class="el" href="classipc_1_1transport_1_1Blob__stream__mq__sender__impl.html">Blob_stream_mq_sender_impl</a>&lt;<a class="el" href="classipc_1_1transport_1_1Blob__stream__mq__sender.html#aa2cb5c8fc525ae45edf8ab1b257f328d">Mq</a>&gt; &gt;&gt;</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Short-hand for <code>const</code>-respecting wrapper around <a class="el" href="classipc_1_1transport_1_1Blob__stream__mq__sender__impl.html" title="Internal, non-movable pImpl-lite implementation of Blob_stream_mq_sender class template.">Blob_stream_mq_sender_impl</a> for the pImpl idiom. </p>

<p class="definition">Definition at line <a class="el" href="blob__stream__mq__snd_8hpp_source.html#l00423">423</a> of file <a class="el" href="blob__stream__mq__snd_8hpp_source.html">blob_stream_mq_snd.hpp</a>.</p>

</div>
</div>
<a id="aa2cb5c8fc525ae45edf8ab1b257f328d" name="aa2cb5c8fc525ae45edf8ab1b257f328d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa2cb5c8fc525ae45edf8ab1b257f328d">&#9670;&nbsp;</a></span>Mq</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename <a class="el" href="classipc_1_1transport_1_1Persistent__mq__handle.html">Persistent_mq_handle</a> &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classipc_1_1transport_1_1Blob__stream__mq__sender.html">ipc::transport::Blob_stream_mq_sender</a>&lt; <a class="el" href="classipc_1_1transport_1_1Persistent__mq__handle.html">Persistent_mq_handle</a> &gt;::Mq =  typename <a class="el" href="classipc_1_1transport_1_1Blob__stream__mq__sender__impl.html">Blob_stream_mq_sender_impl</a>&lt;<a class="el" href="classipc_1_1transport_1_1Persistent__mq__handle.html">Persistent_mq_handle</a>&gt;::Mq</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Short-hand for template arg for underlying MQ handle type. </p>

<p class="definition">Definition at line <a class="el" href="blob__stream__mq__snd_8hpp_source.html#l00172">172</a> of file <a class="el" href="blob__stream__mq__snd_8hpp_source.html">blob_stream_mq_snd.hpp</a>.</p>

</div>
</div>
<a id="acf4adb7cf4114d25386a886ed9e73aa8" name="acf4adb7cf4114d25386a886ed9e73aa8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acf4adb7cf4114d25386a886ed9e73aa8">&#9670;&nbsp;</a></span>Sync_io_obj</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename <a class="el" href="classipc_1_1transport_1_1Persistent__mq__handle.html">Persistent_mq_handle</a> &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classipc_1_1transport_1_1Blob__stream__mq__sender.html">ipc::transport::Blob_stream_mq_sender</a>&lt; <a class="el" href="classipc_1_1transport_1_1Persistent__mq__handle.html">Persistent_mq_handle</a> &gt;::Sync_io_obj =  <a class="el" href="classipc_1_1transport_1_1sync__io_1_1Blob__stream__mq__sender.html">sync_io::Blob_stream_mq_sender</a>&lt;<a class="el" href="classipc_1_1transport_1_1Blob__stream__mq__sender.html#aa2cb5c8fc525ae45edf8ab1b257f328d">Mq</a>&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Useful for generic programming, the <code><a class="el" href="namespaceipc_1_1transport_1_1sync__io.html" title="sync_io-pattern counterparts to async-I/O-pattern object types in parent namespace ipc::transport.">sync_io</a></code>-pattern counterpart to <code>*this</code> type. </p>

<p class="definition">Definition at line <a class="el" href="blob__stream__mq__snd_8hpp_source.html#l00175">175</a> of file <a class="el" href="blob__stream__mq__snd_8hpp_source.html">blob_stream_mq_snd.hpp</a>.</p>

</div>
</div>
<h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="ab316cad18622921becc6c1ab54b8ed2a" name="ab316cad18622921becc6c1ab54b8ed2a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab316cad18622921becc6c1ab54b8ed2a">&#9670;&nbsp;</a></span>Blob_stream_mq_sender() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename <a class="el" href="classipc_1_1transport_1_1Persistent__mq__handle.html">Persistent_mq_handle</a> &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classipc_1_1transport_1_1Blob__stream__mq__sender.html">ipc::transport::Blob_stream_mq_sender</a>&lt; <a class="el" href="classipc_1_1transport_1_1Persistent__mq__handle.html">Persistent_mq_handle</a> &gt;::Blob_stream_mq_sender </td>
          <td>(</td>
          <td class="paramtype">flow::log::Logger *&#160;</td>
          <td class="paramname"><em>logger_ptr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceipc_1_1util.html#ae6ac47812a90d1287c61e0b7de7bc4f5">util::String_view</a>&#160;</td>
          <td class="paramname"><em>nickname_str</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classipc_1_1transport_1_1Blob__stream__mq__sender.html#aa2cb5c8fc525ae45edf8ab1b257f328d">Mq</a> &amp;&amp;&#160;</td>
          <td class="paramname"><em>mq_moved</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceipc.html#aa3192e586cc45d3e7c22463bf2760f89">Error_code</a> *&#160;</td>
          <td class="paramname"><em>err_code</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">explicit</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Constructs the sender by taking over an already-opened MQ handle. </p>
<p >Note that this op does not implement any concept; <a class="el" href="classipc_1_1transport_1_1Blob__sender.html" title="A documentation-only concept defining the behavior of an object capable of reliably/in-order sending ...">Blob_sender</a> concept does not define how a <a class="el" href="classipc_1_1transport_1_1Blob__sender.html" title="A documentation-only concept defining the behavior of an object capable of reliably/in-order sending ...">Blob_sender</a> is created in this explicit fashion.</p>
<p >No traffic must have occurred on <code>mq_moved</code> up to this call. Otherwise behavior is undefined.</p>
<p >If this fails (sets <code>*err_code</code> to truthy if not null; throws if null), all transmission calls on <code>*this</code> will fail with the post-value in <code>*err_code</code> emitted. In particular, <a class="el" href="namespaceipc_1_1transport_1_1error.html#adfef15ef4e76cc55d652fbd9c2797297a5026917d99ad25df8bc708cc6628f28c" title="Message-queue blob stream outgoing-direction peer could not be created, because one already exists at...">error::Code::S_BLOB_STREAM_MQ_SENDER_EXISTS</a> is that code, if the reason for failure was that another <a class="el" href="classipc_1_1transport_1_1Blob__stream__mq__sender.html" title="Implements Blob_sender concept by using an adopted Persistent_mq_handle MQ handle to an MQ (message q...">Blob_stream_mq_sender</a> to <code>mq_moved.absolute_name()</code> has already been created in this or other process. See class doc header for discussion of the relationship between <a class="el" href="classipc_1_1transport_1_1Blob__stream__mq__sender.html" title="Implements Blob_sender concept by using an adopted Persistent_mq_handle MQ handle to an MQ (message q...">Blob_stream_mq_sender</a>, <a class="el" href="classipc_1_1transport_1_1Blob__stream__mq__receiver.html" title="Implements Blob_receiver concept by using an adopted Persistent_mq_handle MQ handle to an MQ (message...">Blob_stream_mq_receiver</a>, the underlying MQ at a given Shared_name, and that Shared_name as registered in the OS. In short: there is to be up to 1 <a class="el" href="classipc_1_1transport_1_1Blob__stream__mq__sender.html" title="Implements Blob_sender concept by using an adopted Persistent_mq_handle MQ handle to an MQ (message q...">Blob_stream_mq_sender</a> and up to 1 <a class="el" href="classipc_1_1transport_1_1Blob__stream__mq__receiver.html" title="Implements Blob_receiver concept by using an adopted Persistent_mq_handle MQ handle to an MQ (message...">Blob_stream_mq_receiver</a> for a given named persistent MQ. In this way, it is one single-direction pipe with 2 peers, like half of <a class="el" href="classipc_1_1transport_1_1Native__socket__stream.html" title="Implements both Native_handle_sender and Native_handle_receiver concepts by using a stream-oriented U...">Native_socket_stream</a> pipe: it is not a MQ with back-and-forth traffic nor multiple senders or multiple receivers. The underlying MQ supports such things; but that is not what the Blob_sender/Blob_receiver concepts model.</p>
<p >Along those same lines note that the dtor (at the latest &ndash; which happens if no fatal error occurs throughout) will not only close the MQ handle acquired from <code>mq_moved</code> but will execute <code>Mq::remove_persistent(name)</code>, where <code>name == mq_moved.absolute_name()</code> pre-this-ctor.</p>
<h3>Leaks of persistent resources</h3>
<p >If something prevents the destructor from running &ndash; a hard crash, say &ndash; the underlying MQ and/or the name may be leaked. External measures taken by <a class="el" href="namespaceipc_1_1session.html" title="Flow-IPC module providing the broad lifecycle and shared-resource organization – via the session conc...">ipc::session</a> machinery are likely necessary to subsequently clean up the resource which, depending on the parameters passed to the <a class="el" href="classipc_1_1transport_1_1Blob__stream__mq__sender.html#aa2cb5c8fc525ae45edf8ab1b257f328d" title="Short-hand for template arg for underlying MQ handle type.">Mq</a> ctor when originally creating the MQ, may use non-trivial RAM.</p>
<h3>Performance</h3>
<p >The taking over of <code>mq_moved</code> should be thought of as light-weight.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">logger_ptr</td><td>Logger to use for subsequently logging. </td></tr>
    <tr><td class="paramname">mq_moved</td><td>An MQ handle to an MQ with no traffic on it so far. Unless an error is emitted, <code>mq_moved</code> becomes nullified upon return from this ctor. <code>*this</code> owns the MQ handle from this point on and is reponsible for closing it. </td></tr>
    <tr><td class="paramname">nickname_str</td><td>Human-readable nickname of the new object, as of this writing for use in <code>operator&lt;&lt;(ostream)</code> and logging only. </td></tr>
    <tr><td class="paramname">err_code</td><td>See <code>flow::Error_code</code> docs for error reporting semantics. <a class="el" href="namespaceipc.html#aa3192e586cc45d3e7c22463bf2760f89" title="Short-hand for boost.interprocess namespace.">Error_code</a> generated: <a class="el" href="namespaceipc_1_1transport_1_1error.html#adfef15ef4e76cc55d652fbd9c2797297a5026917d99ad25df8bc708cc6628f28c" title="Message-queue blob stream outgoing-direction peer could not be created, because one already exists at...">error::Code::S_BLOB_STREAM_MQ_SENDER_EXISTS</a> (another <a class="el" href="classipc_1_1transport_1_1Blob__stream__mq__sender.html" title="Implements Blob_sender concept by using an adopted Persistent_mq_handle MQ handle to an MQ (message q...">Blob_stream_mq_sender</a> exists), system codes (other errors, all to do with the creation of a separate internally used tiny SHM pool used to prevent duplicate <a class="el" href="classipc_1_1transport_1_1Blob__stream__mq__sender.html" title="Implements Blob_sender concept by using an adopted Persistent_mq_handle MQ handle to an MQ (message q...">Blob_stream_mq_sender</a> in the system). </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="blob__stream__mq__snd_8hpp_source.html#l00461">461</a> of file <a class="el" href="blob__stream__mq__snd_8hpp_source.html">blob_stream_mq_snd.hpp</a>.</p>

</div>
</div>
<a id="af9c44e5fb0285373202abba8b41d177d" name="af9c44e5fb0285373202abba8b41d177d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af9c44e5fb0285373202abba8b41d177d">&#9670;&nbsp;</a></span>Blob_stream_mq_sender() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename <a class="el" href="classipc_1_1transport_1_1Persistent__mq__handle.html">Persistent_mq_handle</a> &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classipc_1_1transport_1_1Blob__stream__mq__sender.html">ipc::transport::Blob_stream_mq_sender</a>&lt; <a class="el" href="classipc_1_1transport_1_1Persistent__mq__handle.html">Persistent_mq_handle</a> &gt;::Blob_stream_mq_sender </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classipc_1_1transport_1_1Blob__stream__mq__sender.html#acf4adb7cf4114d25386a886ed9e73aa8">Sync_io_obj</a> &amp;&amp;&#160;</td>
          <td class="paramname"><em>sync_io_core_in_peer_state_moved</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">explicit</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Implements <a class="el" href="classipc_1_1transport_1_1Blob__sender.html" title="A documentation-only concept defining the behavior of an object capable of reliably/in-order sending ...">Blob_sender</a> API, per its concept contract. </p>
<p >All the notes for that concept's core-adopting ctor apply.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">sync_io_core_in_peer_state_moved</td><td>See above.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classipc_1_1transport_1_1Blob__sender.html#a072e2f3b5c18d1188c75501bc5620f6f" title="Default ctor: Creates a peer object in NULL (neither connected nor connecting) state.">Blob_sender::Blob_sender()</a>: implemented concept. </dd></dl>

<p class="definition">Definition at line <a class="el" href="blob__stream__mq__snd_8hpp_source.html#l00470">470</a> of file <a class="el" href="blob__stream__mq__snd_8hpp_source.html">blob_stream_mq_snd.hpp</a>.</p>

</div>
</div>
<a id="aa4537d9d39f2ba775dc98ef6d3fc6d4e" name="aa4537d9d39f2ba775dc98ef6d3fc6d4e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa4537d9d39f2ba775dc98ef6d3fc6d4e">&#9670;&nbsp;</a></span>Blob_stream_mq_sender() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename <a class="el" href="classipc_1_1transport_1_1Persistent__mq__handle.html">Persistent_mq_handle</a> &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classipc_1_1transport_1_1Blob__stream__mq__sender.html">ipc::transport::Blob_stream_mq_sender</a>&lt; <a class="el" href="classipc_1_1transport_1_1Persistent__mq__handle.html">Persistent_mq_handle</a> &gt;::Blob_stream_mq_sender </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">default</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Implements <a class="el" href="classipc_1_1transport_1_1Blob__sender.html" title="A documentation-only concept defining the behavior of an object capable of reliably/in-order sending ...">Blob_sender</a> API, per its concept contract. </p>
<p >All the notes for that concept's default ctor apply.</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classipc_1_1transport_1_1Blob__sender.html#a072e2f3b5c18d1188c75501bc5620f6f" title="Default ctor: Creates a peer object in NULL (neither connected nor connecting) state.">Blob_sender::Blob_sender()</a>: implemented concept. </dd></dl>

</div>
</div>
<a id="ae8782f3758e07a82853115c2d7305dc7" name="ae8782f3758e07a82853115c2d7305dc7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae8782f3758e07a82853115c2d7305dc7">&#9670;&nbsp;</a></span>Blob_stream_mq_sender() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename <a class="el" href="classipc_1_1transport_1_1Persistent__mq__handle.html">Persistent_mq_handle</a> &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classipc_1_1transport_1_1Blob__stream__mq__sender.html">ipc::transport::Blob_stream_mq_sender</a>&lt; <a class="el" href="classipc_1_1transport_1_1Persistent__mq__handle.html">Persistent_mq_handle</a> &gt;::Blob_stream_mq_sender </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classipc_1_1transport_1_1Blob__stream__mq__sender.html">Blob_stream_mq_sender</a>&lt; <a class="el" href="classipc_1_1transport_1_1Persistent__mq__handle.html">Persistent_mq_handle</a> &gt; &amp;&amp;&#160;</td>
          <td class="paramname"><em>src</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">default</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Move-constructs from <code>src</code>; <code>src</code> becomes as-if default-cted (therefore in NULL state). </p>
<p >Implements <a class="el" href="classipc_1_1transport_1_1Blob__sender.html" title="A documentation-only concept defining the behavior of an object capable of reliably/in-order sending ...">Blob_sender</a> API, per its concept contract.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">src</td><td>See above.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classipc_1_1transport_1_1Blob__sender.html#a072e2f3b5c18d1188c75501bc5620f6f" title="Default ctor: Creates a peer object in NULL (neither connected nor connecting) state.">Blob_sender::Blob_sender()</a>: implemented concept. </dd></dl>

</div>
</div>
<a id="a0986c0ee166edfdbb96b4a581678d01e" name="a0986c0ee166edfdbb96b4a581678d01e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0986c0ee166edfdbb96b4a581678d01e">&#9670;&nbsp;</a></span>~Blob_stream_mq_sender()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename <a class="el" href="classipc_1_1transport_1_1Persistent__mq__handle.html">Persistent_mq_handle</a> &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classipc_1_1transport_1_1Blob__stream__mq__sender.html">ipc::transport::Blob_stream_mq_sender</a>&lt; <a class="el" href="classipc_1_1transport_1_1Persistent__mq__handle.html">Persistent_mq_handle</a> &gt;::~<a class="el" href="classipc_1_1transport_1_1Blob__stream__mq__sender.html">Blob_stream_mq_sender</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">default</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Implements <a class="el" href="classipc_1_1transport_1_1Blob__sender.html" title="A documentation-only concept defining the behavior of an object capable of reliably/in-order sending ...">Blob_sender</a> API. </p>
<p >All the notes for the concept's destructor apply but as a reminder:</p>
<p >Destroys this peer endpoint which will end the one-direction pipe and cancel any pending completion handlers by invoking it ASAP with <a class="el" href="namespaceipc_1_1transport_1_1error.html#adfef15ef4e76cc55d652fbd9c2797297afe29343445a7bf167cc186a44bd2c6ed" title="Async completion handler is being called prematurely, because underlying object is shutting down,...">error::Code::S_OBJECT_SHUTDOWN_ABORTED_COMPLETION_HANDLER</a>. As of this writing these are the completion handlers that would therefore be called:</p><ul>
<li>The handler passed to <a class="el" href="classipc_1_1transport_1_1Blob__stream__mq__sender.html#af47c711508c0d4fa9766d8d3481ff583" title="Implements Blob_sender API per contract.">async_end_sending()</a> if not yet invoked. Since it is not valid to call <a class="el" href="classipc_1_1transport_1_1Blob__stream__mq__sender.html#af47c711508c0d4fa9766d8d3481ff583" title="Implements Blob_sender API per contract.">async_end_sending()</a> more than once, there is at most 1 of these.</li>
</ul>
<h3>Fate of underlying MQ and its <code>.<a class="el" href="classipc_1_1transport_1_1Blob__stream__mq__sender.html#aa116304df6214c3ae5d18dbf3305da87" title="Returns name equal to mq.absolute_name(), where mq was passed to ctor, at the time it was passed to c...">absolute_name()</a></code></h3>
<p >No later than the return of this destructor:</p><ul>
<li>The MQ name, namely <code>mq_moved.absolute_name()</code> from ctor, shall have been deleted. Therefore one will be able to util::Create a new <a class="el" href="classipc_1_1transport_1_1Blob__stream__mq__sender.html#aa2cb5c8fc525ae45edf8ab1b257f328d" title="Short-hand for template arg for underlying MQ handle type.">Mq</a>; whereas before the dtor is called and returns it may (most likely will) not be possible to do so. This shall decrease the ref-count for the underlying MQ resource to at most 2. (Its ref-count is ever at most 3: 1 from the OS-registered Shared_name in the file system; 1 from <code>*this</code> <a class="el" href="classipc_1_1transport_1_1Blob__stream__mq__sender.html" title="Implements Blob_sender concept by using an adopted Persistent_mq_handle MQ handle to an MQ (message q...">Blob_stream_mq_sender</a>; and 1 from the peer <a class="el" href="classipc_1_1transport_1_1Blob__stream__mq__receiver.html" title="Implements Blob_receiver concept by using an adopted Persistent_mq_handle MQ handle to an MQ (message...">Blob_stream_mq_receiver</a>).</li>
<li>The ref-count for the underlying MQ resource shall further decrease from 2 to 1 (if the counterpart <a class="el" href="classipc_1_1transport_1_1Blob__stream__mq__sender.html" title="Implements Blob_sender concept by using an adopted Persistent_mq_handle MQ handle to an MQ (message q...">Blob_stream_mq_sender</a> still lives) or from 1 to 0 (if not). In the latter case the MQ itself shall be deleted, its bulk resources (in RAM) freed.</li>
</ul>
<p >While indeed util::Create of a new <a class="el" href="classipc_1_1transport_1_1Blob__stream__mq__sender.html#aa2cb5c8fc525ae45edf8ab1b257f328d" title="Short-hand for template arg for underlying MQ handle type.">Mq</a> is possible after this dtor returns:</p><ul>
<li>In practice it should only be done after <em>both</em> (sender and receiver) dtors have returned. Otherwise the later of the 2 will delete the new underlying MQ too: probably not what you want.</li>
<li>Even having accomplished that, it is still best not to reuse names if possible, at least not anytime soon. See class doc header for brief discussion.</li>
</ul>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classipc_1_1transport_1_1Blob__sender.html#aa66f12eb20f59154d51899b76dc6cdad" title="Destroys this peer endpoint which will end the conceptual outgoing-direction pipe (in PEER state,...">Blob_sender::~Blob_sender()</a>: implemented concept. </dd></dl>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="aa116304df6214c3ae5d18dbf3305da87" name="aa116304df6214c3ae5d18dbf3305da87"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa116304df6214c3ae5d18dbf3305da87">&#9670;&nbsp;</a></span>absolute_name()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename <a class="el" href="classipc_1_1transport_1_1Persistent__mq__handle.html">Persistent_mq_handle</a> &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="namespaceipc_1_1transport.html#a33de1c256addb3964b839dc2dd407d24">Shared_name</a> &amp; <a class="el" href="classipc_1_1transport_1_1Blob__stream__mq__sender.html">ipc::transport::Blob_stream_mq_sender</a>&lt; <a class="el" href="classipc_1_1transport_1_1Persistent__mq__handle.html">Persistent_mq_handle</a> &gt;::absolute_name</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns name equal to <code>mq.absolute_name()</code>, where <code>mq</code> was passed to ctor, at the time it was passed to ctor. </p>
<p >If this object is default-cted (or moved-from), this will return <a class="el" href="classipc_1_1util_1_1Shared__name.html#a5bbfb4d3b378cf7b9a1bcaf5d6c5a067" title="A (default-cted) Shared_name. May be useful for functions returning const Shared_name&amp;.">Shared_name::S_EMPTY</a>.</p>
<dl class="section return"><dt>Returns</dt><dd>See above. Always the same value except across move-assignment. </dd></dl>

<p class="definition">Definition at line <a class="el" href="blob__stream__mq__snd_8hpp_source.html#l00516">516</a> of file <a class="el" href="blob__stream__mq__snd_8hpp_source.html">blob_stream_mq_snd.hpp</a>.</p>

<p class="reference">References <a class="el" href="shared__name_8hpp_source.html#l00247">ipc::util::Shared_name::S_EMPTY</a>.</p>

</div>
</div>
<a id="af47c711508c0d4fa9766d8d3481ff583" name="af47c711508c0d4fa9766d8d3481ff583"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af47c711508c0d4fa9766d8d3481ff583">&#9670;&nbsp;</a></span>async_end_sending()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename <a class="el" href="classipc_1_1transport_1_1Persistent__mq__handle.html">Persistent_mq_handle</a> &gt; </div>
<div class="memtemplate">
template&lt;typename Task_err &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classipc_1_1transport_1_1Blob__stream__mq__sender.html">ipc::transport::Blob_stream_mq_sender</a>&lt; <a class="el" href="classipc_1_1transport_1_1Persistent__mq__handle.html">Persistent_mq_handle</a> &gt;::async_end_sending </td>
          <td>(</td>
          <td class="paramtype">Task_err &amp;&amp;&#160;</td>
          <td class="paramname"><em>on_done_func</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Implements <a class="el" href="classipc_1_1transport_1_1Blob__sender.html" title="A documentation-only concept defining the behavior of an object capable of reliably/in-order sending ...">Blob_sender</a> API per contract. </p>
<p >Reminder: It's not thread-safe to call this concurrently with other transmission methods or destructor on the same <code>*this</code>.</p>
<p ><a class="el" href="namespaceipc.html#aa3192e586cc45d3e7c22463bf2760f89" title="Short-hand for boost.interprocess namespace.">Error_code</a> generated and passed to <code>on_done_func()</code>: system codes (but never would-block) (same as for <a class="el" href="classipc_1_1transport_1_1Blob__stream__mq__sender.html#a1d23a47d08ac7c31aa546ea02bb24c55" title="Implements Blob_sender API per contract.">send_blob()</a>), <a class="el" href="namespaceipc_1_1transport_1_1error.html#adfef15ef4e76cc55d652fbd9c2797297afe29343445a7bf167cc186a44bd2c6ed" title="Async completion handler is being called prematurely, because underlying object is shutting down,...">error::Code::S_OBJECT_SHUTDOWN_ABORTED_COMPLETION_HANDLER</a> (destructor called, canceling all pending ops; spiritually identical to <code>boost::asio::error::operation_aborted</code>),</p>
<p >Reminder: In rare circumstances, an error emitted there may represent something detected during handling of a preceding <a class="el" href="classipc_1_1transport_1_1Blob__stream__mq__sender.html#a1d23a47d08ac7c31aa546ea02bb24c55" title="Implements Blob_sender API per contract.">send_blob()</a> call but after it returned.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Task_err</td><td>See above. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">on_done_func</td><td>See above. Reminder: any moved/copied version of this callback's associated captured state will be freed soon after it returns. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>See above. Reminder: If and only if it returns <code>false</code>, we're in NULL state, or <code>*end_sending()</code> has already been called; and <code>on_done_func()</code> will never be called.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classipc_1_1transport_1_1Blob__sender.html#a440ecfbfc9bda7d824c0acfa54b23ca9" title="Equivalent to send_blob() but sends a graceful-close message instead of the usual payload; the opposi...">Blob_sender::async_end_sending()</a>: implemented concept. </dd></dl>

<p class="definition">Definition at line <a class="el" href="blob__stream__mq__snd_8hpp_source.html#l00498">498</a> of file <a class="el" href="blob__stream__mq__snd_8hpp_source.html">blob_stream_mq_snd.hpp</a>.</p>

</div>
</div>
<a id="a5453dccb1253f77975fcc0e2ad4cc0ea" name="a5453dccb1253f77975fcc0e2ad4cc0ea"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5453dccb1253f77975fcc0e2ad4cc0ea">&#9670;&nbsp;</a></span>auto_ping()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename <a class="el" href="classipc_1_1transport_1_1Persistent__mq__handle.html">Persistent_mq_handle</a> &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classipc_1_1transport_1_1Blob__stream__mq__sender.html">ipc::transport::Blob_stream_mq_sender</a>&lt; <a class="el" href="classipc_1_1transport_1_1Persistent__mq__handle.html">Persistent_mq_handle</a> &gt;::auto_ping </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespaceipc_1_1util.html#ac66141280c3b7295a86b65209f31cc58">util::Fine_duration</a>&#160;</td>
          <td class="paramname"><em>period</em> = <code>boost::chrono::seconds(2)</code></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Implements <a class="el" href="classipc_1_1transport_1_1Blob__sender.html" title="A documentation-only concept defining the behavior of an object capable of reliably/in-order sending ...">Blob_sender</a> API per contract. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">period</td><td>See above. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>See above.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classipc_1_1transport_1_1Blob__sender.html#ac41990a469e61a26ca9cefaf6a291a2e" title="In PEER state: Irreversibly enables periodic auto-pinging of opposing receiver with low-level message...">Blob_sender::auto_ping()</a>: implemented concept. </dd></dl>

<p class="definition">Definition at line <a class="el" href="blob__stream__mq__snd_8hpp_source.html#l00510">510</a> of file <a class="el" href="blob__stream__mq__snd_8hpp_source.html">blob_stream_mq_snd.hpp</a>.</p>

</div>
</div>
<a id="a2d6eac56c4f66d9a39fb3e4d1b5218d8" name="a2d6eac56c4f66d9a39fb3e4d1b5218d8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2d6eac56c4f66d9a39fb3e4d1b5218d8">&#9670;&nbsp;</a></span>end_sending()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename <a class="el" href="classipc_1_1transport_1_1Persistent__mq__handle.html">Persistent_mq_handle</a> &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classipc_1_1transport_1_1Blob__stream__mq__sender.html">ipc::transport::Blob_stream_mq_sender</a>&lt; <a class="el" href="classipc_1_1transport_1_1Persistent__mq__handle.html">Persistent_mq_handle</a> &gt;::end_sending</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Implements <a class="el" href="classipc_1_1transport_1_1Blob__sender.html" title="A documentation-only concept defining the behavior of an object capable of reliably/in-order sending ...">Blob_sender</a> API per contract. </p>
<p >Reminder: It is equivalent to <a class="el" href="classipc_1_1transport_1_1Blob__stream__mq__sender.html#af47c711508c0d4fa9766d8d3481ff583" title="Implements Blob_sender API per contract.">async_end_sending()</a> but with a no-op <code>on_done_func</code>.</p>
<dl class="section return"><dt>Returns</dt><dd>See above. Reminder: If and only if it returns <code>false</code>, we're in NULL state, or <code>*end_sending()</code> has already been called.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classipc_1_1transport_1_1Blob__sender.html#a2a14c51a9d8b03008b567917589ab813" title="Equivalent to async_end_sending(F) wherein F() does nothing.">Blob_sender::end_sending()</a>: implemented concept. </dd></dl>

<p class="definition">Definition at line <a class="el" href="blob__stream__mq__snd_8hpp_source.html#l00504">504</a> of file <a class="el" href="blob__stream__mq__snd_8hpp_source.html">blob_stream_mq_snd.hpp</a>.</p>

</div>
</div>
<a id="ab4ae64f241761ab94ed005f65a55a318" name="ab4ae64f241761ab94ed005f65a55a318"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab4ae64f241761ab94ed005f65a55a318">&#9670;&nbsp;</a></span>nickname()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename <a class="el" href="classipc_1_1transport_1_1Persistent__mq__handle.html">Persistent_mq_handle</a> &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">const std::string &amp; <a class="el" href="classipc_1_1transport_1_1Blob__stream__mq__sender.html">ipc::transport::Blob_stream_mq_sender</a>&lt; <a class="el" href="classipc_1_1transport_1_1Persistent__mq__handle.html">Persistent_mq_handle</a> &gt;::nickname</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns nickname, a brief string suitable for logging. </p>
<p >This is included in the output by the <code>ostream&lt;&lt;</code> operator as well. This method is thread-safe in that it always returns the same value.</p>
<p >If this object is default-cted (or moved-from), this will return a value equal to "".</p>
<dl class="section return"><dt>Returns</dt><dd>See above. </dd></dl>

<p class="definition">Definition at line <a class="el" href="blob__stream__mq__snd_8hpp_source.html#l00522">522</a> of file <a class="el" href="blob__stream__mq__snd_8hpp_source.html">blob_stream_mq_snd.hpp</a>.</p>

<p class="reference">References <a class="el" href="ipc__core_2src_2ipc_2util_2util_8cpp_source.html#l00033">ipc::util::EMPTY_STRING</a>.</p>

</div>
</div>
<a id="a632ad9aa40e557a9d5edef4b122ddaf9" name="a632ad9aa40e557a9d5edef4b122ddaf9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a632ad9aa40e557a9d5edef4b122ddaf9">&#9670;&nbsp;</a></span>operator=()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename <a class="el" href="classipc_1_1transport_1_1Persistent__mq__handle.html">Persistent_mq_handle</a> &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classipc_1_1transport_1_1Blob__stream__mq__sender.html">Blob_stream_mq_sender</a>&lt; <a class="el" href="classipc_1_1transport_1_1Persistent__mq__handle.html">Persistent_mq_handle</a> &gt; &amp; <a class="el" href="classipc_1_1transport_1_1Blob__stream__mq__sender.html">ipc::transport::Blob_stream_mq_sender</a>&lt; <a class="el" href="classipc_1_1transport_1_1Persistent__mq__handle.html">Persistent_mq_handle</a> &gt;::operator= </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classipc_1_1transport_1_1Blob__stream__mq__sender.html">Blob_stream_mq_sender</a>&lt; <a class="el" href="classipc_1_1transport_1_1Persistent__mq__handle.html">Persistent_mq_handle</a> &gt; &amp;&amp;&#160;</td>
          <td class="paramname"><em>src</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">default</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Move-assigns from <code>src</code>; <code>*this</code> acts as if destructed; <code>src</code> becomes as-if default-cted (therefore in NULL state). </p>
<p >No-op if <code>&amp;src == this</code>. Implements <a class="el" href="classipc_1_1transport_1_1Blob__sender.html" title="A documentation-only concept defining the behavior of an object capable of reliably/in-order sending ...">Blob_sender</a> API, per its concept contract.</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classipc_1_1transport_1_1Blob__stream__mq__sender.html#a0986c0ee166edfdbb96b4a581678d01e" title="Implements Blob_sender API.">~Blob_stream_mq_sender()</a>.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">src</td><td>See above. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>See above.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classipc_1_1transport_1_1Blob__sender.html" title="A documentation-only concept defining the behavior of an object capable of reliably/in-order sending ...">Blob_sender</a> move assignment: implemented concept. </dd></dl>

</div>
</div>
<a id="a1d23a47d08ac7c31aa546ea02bb24c55" name="a1d23a47d08ac7c31aa546ea02bb24c55"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1d23a47d08ac7c31aa546ea02bb24c55">&#9670;&nbsp;</a></span>send_blob()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename <a class="el" href="classipc_1_1transport_1_1Persistent__mq__handle.html">Persistent_mq_handle</a> &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classipc_1_1transport_1_1Blob__stream__mq__sender.html">ipc::transport::Blob_stream_mq_sender</a>&lt; <a class="el" href="classipc_1_1transport_1_1Persistent__mq__handle.html">Persistent_mq_handle</a> &gt;::send_blob </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespaceipc_1_1util.html#ae0be7edba7e30ffa3f8b742af621f2ab">util::Blob_const</a> &amp;&#160;</td>
          <td class="paramname"><em>blob</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceipc.html#aa3192e586cc45d3e7c22463bf2760f89">Error_code</a> *&#160;</td>
          <td class="paramname"><em>err_code</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Implements <a class="el" href="classipc_1_1transport_1_1Blob__sender.html" title="A documentation-only concept defining the behavior of an object capable of reliably/in-order sending ...">Blob_sender</a> API per contract. </p>
<p >Reminder: It's not thread-safe to call this concurrently with other transmission methods or destructor on the same <code>*this</code>.</p>
<p >Reminder: <code>blob.size() == 0</code> results in undefined behavior (assertion may trip).</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">blob</td><td>See above. Reminder: The memory area described by this arg need only be valid until this method returns. Perf reminder: That area will not be copied except for rare circumstances. </td></tr>
    <tr><td class="paramname">err_code</td><td>See above. Reminder: In rare circumstances, an error emitted here may represent something detected during handling of a <em>preceding</em> <a class="el" href="classipc_1_1transport_1_1Blob__stream__mq__sender.html#a1d23a47d08ac7c31aa546ea02bb24c55" title="Implements Blob_sender API per contract.">send_blob()</a> call but after it returned. <a class="el" href="namespaceipc.html#aa3192e586cc45d3e7c22463bf2760f89" title="Short-hand for boost.interprocess namespace.">Error_code</a> generated: <a class="el" href="namespaceipc_1_1transport_1_1error.html#adfef15ef4e76cc55d652fbd9c2797297ac416e988563e44bf15fc6a81743eef53" title="User called an API with 1 or more arguments against the API spec.">error::Code::S_INVALID_ARGUMENT</a> (<code>blob.size()</code> exceeds max_msg_size()), <a class="el" href="namespaceipc_1_1transport_1_1error.html#adfef15ef4e76cc55d652fbd9c2797297a42d41c622e92e9053177ba73e75633fe" title="Will not send message: local user already ended sending via API marking this.">error::Code::S_SENDS_FINISHED_CANNOT_SEND</a> (<code>*end_sending()</code> was called earlier), system codes (but never would-block), indicating the underlying transport is hosed for that specific reason, as detected during outgoing-direction processing. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>See above.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classipc_1_1transport_1_1Native__handle__sender.html#ac96b0aa01c286d525f9dcfa6dacc4220" title="In PEER state: Synchronously, non-blockingly sends one discrete message, reliably/in-order,...">Native_handle_sender::send_native_handle()</a>: implemented concept. </dd></dl>

<p class="definition">Definition at line <a class="el" href="blob__stream__mq__snd_8hpp_source.html#l00490">490</a> of file <a class="el" href="blob__stream__mq__snd_8hpp_source.html">blob_stream_mq_snd.hpp</a>.</p>

</div>
</div>
<a id="a4e5d7add242439e01c56cab3697aebb6" name="a4e5d7add242439e01c56cab3697aebb6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4e5d7add242439e01c56cab3697aebb6">&#9670;&nbsp;</a></span>send_blob_max_size()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename <a class="el" href="classipc_1_1transport_1_1Persistent__mq__handle.html">Persistent_mq_handle</a> &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">size_t <a class="el" href="classipc_1_1transport_1_1Blob__stream__mq__sender.html">ipc::transport::Blob_stream_mq_sender</a>&lt; <a class="el" href="classipc_1_1transport_1_1Persistent__mq__handle.html">Persistent_mq_handle</a> &gt;::send_blob_max_size</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Implements <a class="el" href="classipc_1_1transport_1_1Blob__sender.html" title="A documentation-only concept defining the behavior of an object capable of reliably/in-order sending ...">Blob_sender</a> API per contract. </p>
<p >Note this value equals "remote" peer's value for the same call at any given time which is <em>not</em> a concept requirement and may be untrue of other concept co-implementing classes.</p>
<dl class="section return"><dt>Returns</dt><dd>See above.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classipc_1_1transport_1_1Blob__sender.html#af5d889f8a209353b3d69f70b44a2095c" title="In PEER state: Returns max blob.size() such that send_blob() shall not fail due to too-long payload w...">Blob_sender::send_blob_max_size()</a>: implemented concept. </dd></dl>

<p class="definition">Definition at line <a class="el" href="blob__stream__mq__snd_8hpp_source.html#l00484">484</a> of file <a class="el" href="blob__stream__mq__snd_8hpp_source.html">blob_stream_mq_snd.hpp</a>.</p>

</div>
</div>
<h2 class="groupheader">Friends And Related Function Documentation</h2>
<a id="acb29aca9de166fd1f24a09d08afe2fcc" name="acb29aca9de166fd1f24a09d08afe2fcc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acb29aca9de166fd1f24a09d08afe2fcc">&#9670;&nbsp;</a></span>operator&lt;&lt;()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename <a class="el" href="classipc_1_1transport_1_1Persistent__mq__handle.html">Persistent_mq_handle</a> &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::ostream &amp; operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>os</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classipc_1_1transport_1_1Blob__stream__mq__sender.html">Blob_stream_mq_sender</a>&lt; <a class="el" href="classipc_1_1transport_1_1Persistent__mq__handle.html">Persistent_mq_handle</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>val</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Prints string representation of the given <code><a class="el" href="classipc_1_1transport_1_1Blob__stream__mq__sender.html" title="Implements Blob_sender concept by using an adopted Persistent_mq_handle MQ handle to an MQ (message q...">Blob_stream_mq_sender</a></code> to the given <code>ostream</code>. </p>
<p >If object is default-cted (or moved-from), this will output something graceful indicating this.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">os</td><td>Stream to which to write. </td></tr>
    <tr><td class="paramname">val</td><td>Object to serialize. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>os</code>. </dd></dl>

<p class="definition">Definition at line <a class="el" href="blob__stream__mq__snd_8hpp_source.html#l00530">530</a> of file <a class="el" href="blob__stream__mq__snd_8hpp_source.html">blob_stream_mq_snd.hpp</a>.</p>

<p class="reference">References <a class="el" href="blob__stream__mq__snd_8hpp_source.html#l00434">ipc::transport::Blob_stream_mq_sender&lt; Persistent_mq_handle &gt;::m_impl</a>.</p>

</div>
</div>
<h2 class="groupheader">Member Data Documentation</h2>
<a id="af81738986da26bdd1bb3eef3ccd29296" name="af81738986da26bdd1bb3eef3ccd29296"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af81738986da26bdd1bb3eef3ccd29296">&#9670;&nbsp;</a></span>m_impl</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename <a class="el" href="classipc_1_1transport_1_1Persistent__mq__handle.html">Persistent_mq_handle</a> &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classipc_1_1transport_1_1Blob__stream__mq__sender.html#ac97c9d7d3dad9e48151f92f884d5f12e">Impl_ptr</a> <a class="el" href="classipc_1_1transport_1_1Blob__stream__mq__sender.html">ipc::transport::Blob_stream_mq_sender</a>&lt; <a class="el" href="classipc_1_1transport_1_1Persistent__mq__handle.html">Persistent_mq_handle</a> &gt;::m_impl</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>The true implementation of this class. See also our class doc header. </p>

<p class="definition">Definition at line <a class="el" href="blob__stream__mq__snd_8hpp_source.html#l00434">434</a> of file <a class="el" href="blob__stream__mq__snd_8hpp_source.html">blob_stream_mq_snd.hpp</a>.</p>

<p class="reference">Referenced by <a class="el" href="blob__stream__mq__snd_8hpp_source.html#l00530">ipc::transport::Blob_stream_mq_sender&lt; Persistent_mq_handle &gt;::operator&lt;&lt;()</a>.</p>

</div>
</div>
<a id="a57164996725324b544aedf6707d158d1" name="a57164996725324b544aedf6707d158d1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a57164996725324b544aedf6707d158d1">&#9670;&nbsp;</a></span>S_RESOURCE_TYPE_ID</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename <a class="el" href="classipc_1_1transport_1_1Persistent__mq__handle.html">Persistent_mq_handle</a> &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="namespaceipc_1_1transport.html#a33de1c256addb3964b839dc2dd407d24">Shared_name</a> <a class="el" href="classipc_1_1transport_1_1Blob__stream__mq__sender.html">ipc::transport::Blob_stream_mq_sender</a>&lt; <a class="el" href="classipc_1_1transport_1_1Persistent__mq__handle.html">Persistent_mq_handle</a> &gt;::S_RESOURCE_TYPE_ID = Mq::S_RESOURCE_TYPE_ID</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Implements concept API. Equals <code>Mq::S_RESOURCE_TYPE_ID</code>. </p>

<p class="definition">Definition at line <a class="el" href="blob__stream__mq__snd_8hpp_source.html#l00182">182</a> of file <a class="el" href="blob__stream__mq__snd_8hpp_source.html">blob_stream_mq_snd.hpp</a>.</p>

</div>
</div>
<hr/>The documentation for this class was generated from the following files:<ul>
<li>transport/<a class="el" href="blob__stream__mq__snd_8hpp_source.html">blob_stream_mq_snd.hpp</a></li>
<li>transport/<a class="el" href="transport__fwd_8hpp_source.html">transport_fwd.hpp</a></li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Fri Jan 19 2024 23:56:27 for Flow-IPC by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.4
</small></address>
</body>
</html>
