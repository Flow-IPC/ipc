<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.9.4"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Flow-IPC: ipc::transport::sync_io::Async_adapter_receiver&lt; Core_t &gt; Class Template Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">Flow-IPC<span id="projectnumber">&#160;1.0</span>
   </div>
   <div id="projectbrief">Flow-IPC project: Full implementation reference.</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.4 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search",'Search','.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespaceipc.html">ipc</a></li><li class="navelem"><a class="el" href="namespaceipc_1_1transport.html">transport</a></li><li class="navelem"><a class="el" href="namespaceipc_1_1transport_1_1sync__io.html">sync_io</a></li><li class="navelem"><a class="el" href="classipc_1_1transport_1_1sync__io_1_1Async__adapter__receiver.html">Async_adapter_receiver</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#pub-types">Public Types</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pri-methods">Private Member Functions</a> &#124;
<a href="#pri-attribs">Private Attributes</a> &#124;
<a href="classipc_1_1transport_1_1sync__io_1_1Async__adapter__receiver-members.html">List of all members</a>  </div>
  <div class="headertitle"><div class="title">ipc::transport::sync_io::Async_adapter_receiver&lt; Core_t &gt; Class Template Reference</div></div>
</div><!--header-->
<div class="contents">

<p>Internal-use type that adapts a given PEER-state <a class="el" href="classipc_1_1transport_1_1sync__io_1_1Native__handle__receiver.html" title="A documentation-only concept defining the behavior of an object that is the sync_io-pattern counterpa...">sync_io::Native_handle_receiver</a> or <a class="el" href="classipc_1_1transport_1_1sync__io_1_1Blob__receiver.html" title="A documentation-only concept: what transport::Blob_receiver is to transport::Native_handle_receiver (...">sync_io::Blob_receiver</a> <em>core</em> into the async-I/O-pattern <a class="el" href="classipc_1_1transport_1_1sync__io_1_1Native__handle__receiver.html" title="A documentation-only concept defining the behavior of an object that is the sync_io-pattern counterpa...">Native_handle_receiver</a> or <a class="el" href="classipc_1_1transport_1_1sync__io_1_1Blob__receiver.html" title="A documentation-only concept: what transport::Blob_receiver is to transport::Native_handle_receiver (...">Blob_receiver</a>.  
 <a href="classipc_1_1transport_1_1sync__io_1_1Async__adapter__receiver.html#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="async__adapter__rcv_8hpp_source.html">async_adapter_rcv.hpp</a>&gt;</code></p>
<div class="dynheader">
Inheritance diagram for ipc::transport::sync_io::Async_adapter_receiver&lt; Core_t &gt;:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="classipc_1_1transport_1_1sync__io_1_1Async__adapter__receiver__inherit__graph.svg" width="310" height="131"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe>
</div>
<center><span class="legend">[<a href="graph_legend.html">legend</a>]</span></center></div>
<div class="dynheader">
Collaboration diagram for ipc::transport::sync_io::Async_adapter_receiver&lt; Core_t &gt;:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="classipc_1_1transport_1_1sync__io_1_1Async__adapter__receiver__coll__graph.svg" width="791" height="398"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe>
</div>
<center><span class="legend">[<a href="graph_legend.html">legend</a>]</span></center></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="nested-classes" name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structipc_1_1transport_1_1sync__io_1_1Async__adapter__receiver_1_1User__request.html">User_request</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Data store representing a deficit user async-receive request: either one being currently handled by <code>m_sync_io</code> &ndash; which can handle one <code>m_sync_io.async_receive_*()</code> at a time, no more &ndash; or one queued up behind it, if <code>async_receive_*()</code> was called before the current one could complete.  <a href="structipc_1_1transport_1_1sync__io_1_1Async__adapter__receiver_1_1User__request.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-types" name="pub-types"></a>
Public Types</h2></td></tr>
<tr class="memitem:aeb37be595e9cfce9e0185acee7eeac80"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classipc_1_1transport_1_1sync__io_1_1Async__adapter__receiver.html#aeb37be595e9cfce9e0185acee7eeac80">Core</a> = Core_t</td></tr>
<tr class="memdesc:aeb37be595e9cfce9e0185acee7eeac80"><td class="mdescLeft">&#160;</td><td class="mdescRight">The <code>sync_io::X</code> type being adapted into async-I/O-pattern <code>X</code>.  <a href="classipc_1_1transport_1_1sync__io_1_1Async__adapter__receiver.html#aeb37be595e9cfce9e0185acee7eeac80">More...</a><br /></td></tr>
<tr class="separator:aeb37be595e9cfce9e0185acee7eeac80"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-methods" name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a2f32f38020a0d21499b1c0b724ff332b"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classipc_1_1transport_1_1sync__io_1_1Async__adapter__receiver.html#a2f32f38020a0d21499b1c0b724ff332b">Async_adapter_receiver</a> (flow::log::Logger *logger_ptr, <a class="el" href="namespaceipc_1_1util.html#ae6ac47812a90d1287c61e0b7de7bc4f5">util::String_view</a> log_pfx, flow::async::Single_thread_task_loop *worker, <a class="el" href="classipc_1_1transport_1_1sync__io_1_1Async__adapter__receiver.html#aeb37be595e9cfce9e0185acee7eeac80">Core</a> *sync_io)</td></tr>
<tr class="memdesc:a2f32f38020a0d21499b1c0b724ff332b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructs the adapter around <code>sync_io::X</code> object <code>*sync_io</code>.  <a href="classipc_1_1transport_1_1sync__io_1_1Async__adapter__receiver.html#a2f32f38020a0d21499b1c0b724ff332b">More...</a><br /></td></tr>
<tr class="separator:a2f32f38020a0d21499b1c0b724ff332b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a80428aeb0d3f9e836fe897fc1e42601a"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classipc_1_1transport_1_1sync__io_1_1Async__adapter__receiver.html#a80428aeb0d3f9e836fe897fc1e42601a">~Async_adapter_receiver</a> ()</td></tr>
<tr class="memdesc:a80428aeb0d3f9e836fe897fc1e42601a"><td class="mdescLeft">&#160;</td><td class="mdescRight">To be invoked after <code>-&gt;stop()</code>ping <code>*worker</code> (from ctor), as well as flushing any still-queued tasks in its <code>Task_engine</code> (via <code>.restart()</code> and <code>.poll()</code>), this satisfies the customer adapter dtor's contract which is to invoke any not-yet-fired completion handlers with special operation-aborted error code.  <a href="classipc_1_1transport_1_1sync__io_1_1Async__adapter__receiver.html#a80428aeb0d3f9e836fe897fc1e42601a">More...</a><br /></td></tr>
<tr class="separator:a80428aeb0d3f9e836fe897fc1e42601a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abcbc91de36b298c68e5461997a9a0263"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classipc_1_1transport_1_1sync__io_1_1Async__adapter__receiver.html#abcbc91de36b298c68e5461997a9a0263">async_receive_native_handle</a> (<a class="el" href="namespaceipc_1_1transport.html#a7ee4551983d9df16ec16a3139bac50e8">Native_handle</a> *target_hndl, const <a class="el" href="namespaceipc_1_1util.html#a6cb62ae434900f3a8915b33ec5d61a96">util::Blob_mutable</a> &amp;target_meta_blob, flow::async::Task_asio_err_sz &amp;&amp;on_done_func)</td></tr>
<tr class="memdesc:abcbc91de36b298c68e5461997a9a0263"><td class="mdescLeft">&#160;</td><td class="mdescRight">See <a class="el" href="classipc_1_1transport_1_1sync__io_1_1Native__handle__sender.html" title="A documentation-only concept defining the behavior of an object that is the sync_io-pattern counterpa...">Native_handle_sender</a> counterpart.  <a href="classipc_1_1transport_1_1sync__io_1_1Async__adapter__receiver.html#abcbc91de36b298c68e5461997a9a0263">More...</a><br /></td></tr>
<tr class="separator:abcbc91de36b298c68e5461997a9a0263"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ade3098cb69a47a374cf0354677e2fb0b"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classipc_1_1transport_1_1sync__io_1_1Async__adapter__receiver.html#ade3098cb69a47a374cf0354677e2fb0b">async_receive_blob</a> (const <a class="el" href="namespaceipc_1_1util.html#a6cb62ae434900f3a8915b33ec5d61a96">util::Blob_mutable</a> &amp;target_blob, flow::async::Task_asio_err_sz &amp;&amp;on_done_func)</td></tr>
<tr class="memdesc:ade3098cb69a47a374cf0354677e2fb0b"><td class="mdescLeft">&#160;</td><td class="mdescRight">See <a class="el" href="classipc_1_1transport_1_1sync__io_1_1Blob__receiver.html" title="A documentation-only concept: what transport::Blob_receiver is to transport::Native_handle_receiver (...">Blob_receiver</a> counterpart.  <a href="classipc_1_1transport_1_1sync__io_1_1Async__adapter__receiver.html#ade3098cb69a47a374cf0354677e2fb0b">More...</a><br /></td></tr>
<tr class="separator:ade3098cb69a47a374cf0354677e2fb0b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2067b525e54efd90bdc584cf77f7ae4b"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classipc_1_1transport_1_1sync__io_1_1Async__adapter__receiver.html#a2067b525e54efd90bdc584cf77f7ae4b">idle_timer_run</a> (<a class="el" href="namespaceipc_1_1util.html#ac66141280c3b7295a86b65209f31cc58">util::Fine_duration</a> timeout)</td></tr>
<tr class="memdesc:a2067b525e54efd90bdc584cf77f7ae4b"><td class="mdescLeft">&#160;</td><td class="mdescRight">See <a class="el" href="classipc_1_1transport_1_1sync__io_1_1Native__handle__receiver.html" title="A documentation-only concept defining the behavior of an object that is the sync_io-pattern counterpa...">Native_handle_receiver</a> counterpart.  <a href="classipc_1_1transport_1_1sync__io_1_1Async__adapter__receiver.html#a2067b525e54efd90bdc584cf77f7ae4b">More...</a><br /></td></tr>
<tr class="separator:a2067b525e54efd90bdc584cf77f7ae4b"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pri-methods" name="pri-methods"></a>
Private Member Functions</h2></td></tr>
<tr class="memitem:a6cf425ab8e3258924e6d1db12da2fbf5"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classipc_1_1transport_1_1sync__io_1_1Async__adapter__receiver.html#a6cf425ab8e3258924e6d1db12da2fbf5">async_receive_native_handle_impl</a> (<a class="el" href="namespaceipc_1_1transport.html#a7ee4551983d9df16ec16a3139bac50e8">Native_handle</a> *target_hndl_or_null, const <a class="el" href="namespaceipc_1_1util.html#a6cb62ae434900f3a8915b33ec5d61a96">util::Blob_mutable</a> &amp;target_meta_blob, flow::async::Task_asio_err_sz &amp;&amp;on_done_func)</td></tr>
<tr class="memdesc:a6cf425ab8e3258924e6d1db12da2fbf5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Body of <a class="el" href="classipc_1_1transport_1_1sync__io_1_1Async__adapter__receiver.html#abcbc91de36b298c68e5461997a9a0263" title="See Native_handle_sender counterpart.">async_receive_native_handle()</a> and <a class="el" href="classipc_1_1transport_1_1sync__io_1_1Async__adapter__receiver.html#ade3098cb69a47a374cf0354677e2fb0b" title="See Blob_receiver counterpart.">async_receive_blob()</a>; with <code>target_hndl</code> null if and only if it's the latter as opposed to the former.  <a href="classipc_1_1transport_1_1sync__io_1_1Async__adapter__receiver.html#a6cf425ab8e3258924e6d1db12da2fbf5">More...</a><br /></td></tr>
<tr class="separator:a6cf425ab8e3258924e6d1db12da2fbf5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a98d7b3caa0f0b00c75671278e7971017"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classipc_1_1transport_1_1sync__io_1_1Async__adapter__receiver.html#a98d7b3caa0f0b00c75671278e7971017">on_sync_io_rcv_done</a> (const <a class="el" href="namespaceipc.html#aa3192e586cc45d3e7c22463bf2760f89">Error_code</a> &amp;err_code, size_t sz)</td></tr>
<tr class="memdesc:a98d7b3caa0f0b00c75671278e7971017"><td class="mdescLeft">&#160;</td><td class="mdescRight">Invoked via active-event API, handles the async completion of <code>m_sync_io.async_receive_*()</code> operation.  <a href="classipc_1_1transport_1_1sync__io_1_1Async__adapter__receiver.html#a98d7b3caa0f0b00c75671278e7971017">More...</a><br /></td></tr>
<tr class="separator:a98d7b3caa0f0b00c75671278e7971017"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afa5b0ab6ad54e0d3c93550226bfe2b33"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classipc_1_1transport_1_1sync__io_1_1Async__adapter__receiver.html#afa5b0ab6ad54e0d3c93550226bfe2b33">process_msg_or_error</a> (const <a class="el" href="namespaceipc.html#aa3192e586cc45d3e7c22463bf2760f89">Error_code</a> &amp;err_code, size_t sz)</td></tr>
<tr class="memdesc:afa5b0ab6ad54e0d3c93550226bfe2b33"><td class="mdescLeft">&#160;</td><td class="mdescRight">Invoked from thread U/W (<a class="el" href="classipc_1_1transport_1_1sync__io_1_1Async__adapter__receiver.html#a6cf425ab8e3258924e6d1db12da2fbf5" title="Body of async_receive_native_handle() and async_receive_blob(); with target_hndl null if and only if ...">async_receive_native_handle_impl()</a>) or thread W (active-event API), handles a completed <code>m_sync_io.async_receive_*()</code> &ndash; whose results are to be given as args &ndash; by (1) updating <a class="el" href="classipc_1_1transport_1_1sync__io_1_1Async__adapter__receiver.html#a76d81cb59e1b91c7f379064dd285aa93" title="The head slot containing the currently-being-serviced &quot;deficit&quot; async-receive request,...">m_user_request</a> and <a class="el" href="classipc_1_1transport_1_1sync__io_1_1Async__adapter__receiver.html#a13a636ca275a188bd3727e2d7c247f0e" title="Queue storing deficit async-receive requests queued up due to m_user_request being not null while mor...">m_pending_user_requests_q</a> and (2) posting any appropriate handlers onto thread W.  <a href="classipc_1_1transport_1_1sync__io_1_1Async__adapter__receiver.html#afa5b0ab6ad54e0d3c93550226bfe2b33">More...</a><br /></td></tr>
<tr class="separator:afa5b0ab6ad54e0d3c93550226bfe2b33"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pri-attribs" name="pri-attribs"></a>
Private Attributes</h2></td></tr>
<tr class="memitem:a5dd1bf37b817a3ebbb968d34f0d240b1"><td class="memItemLeft" align="right" valign="top">const std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classipc_1_1transport_1_1sync__io_1_1Async__adapter__receiver.html#a5dd1bf37b817a3ebbb968d34f0d240b1">m_log_pfx</a></td></tr>
<tr class="memdesc:a5dd1bf37b817a3ebbb968d34f0d240b1"><td class="mdescLeft">&#160;</td><td class="mdescRight">See <code>log_pfx</code> arg of ctor.  <a href="classipc_1_1transport_1_1sync__io_1_1Async__adapter__receiver.html#a5dd1bf37b817a3ebbb968d34f0d240b1">More...</a><br /></td></tr>
<tr class="separator:a5dd1bf37b817a3ebbb968d34f0d240b1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a76d81cb59e1b91c7f379064dd285aa93"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structipc_1_1transport_1_1sync__io_1_1Async__adapter__receiver_1_1User__request.html#ad716a5458992596636d5e3e4f9d83e9b">User_request::Ptr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classipc_1_1transport_1_1sync__io_1_1Async__adapter__receiver.html#a76d81cb59e1b91c7f379064dd285aa93">m_user_request</a></td></tr>
<tr class="memdesc:a76d81cb59e1b91c7f379064dd285aa93"><td class="mdescLeft">&#160;</td><td class="mdescRight">The <em>head slot</em> containing the currently-being-serviced "deficit" async-receive request, with a meta-blob <em>potentially</em> being async-written to; null if there is no pending <a class="el" href="classipc_1_1transport_1_1sync__io_1_1Async__adapter__receiver.html#abcbc91de36b298c68e5461997a9a0263" title="See Native_handle_sender counterpart.">async_receive_native_handle()</a>.  <a href="classipc_1_1transport_1_1sync__io_1_1Async__adapter__receiver.html#a76d81cb59e1b91c7f379064dd285aa93">More...</a><br /></td></tr>
<tr class="separator:a76d81cb59e1b91c7f379064dd285aa93"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a13a636ca275a188bd3727e2d7c247f0e"><td class="memItemLeft" align="right" valign="top">std::queue&lt; typename <a class="el" href="structipc_1_1transport_1_1sync__io_1_1Async__adapter__receiver_1_1User__request.html#ad716a5458992596636d5e3e4f9d83e9b">User_request::Ptr</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classipc_1_1transport_1_1sync__io_1_1Async__adapter__receiver.html#a13a636ca275a188bd3727e2d7c247f0e">m_pending_user_requests_q</a></td></tr>
<tr class="memdesc:a13a636ca275a188bd3727e2d7c247f0e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Queue storing deficit async-receive requests queued up due to <a class="el" href="classipc_1_1transport_1_1sync__io_1_1Async__adapter__receiver.html#a76d81cb59e1b91c7f379064dd285aa93" title="The head slot containing the currently-being-serviced &quot;deficit&quot; async-receive request,...">m_user_request</a> being not null while more <code>async_receive_*()</code> invocations being made by user.  <a href="classipc_1_1transport_1_1sync__io_1_1Async__adapter__receiver.html#a13a636ca275a188bd3727e2d7c247f0e">More...</a><br /></td></tr>
<tr class="separator:a13a636ca275a188bd3727e2d7c247f0e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a113a43c175209f7e3293f75ab4bcd794"><td class="memItemLeft" align="right" valign="top">flow::util::Mutex_non_recursive&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classipc_1_1transport_1_1sync__io_1_1Async__adapter__receiver.html#a113a43c175209f7e3293f75ab4bcd794">m_mutex</a></td></tr>
<tr class="memdesc:a113a43c175209f7e3293f75ab4bcd794"><td class="mdescLeft">&#160;</td><td class="mdescRight">Protects <a class="el" href="classipc_1_1transport_1_1sync__io_1_1Async__adapter__receiver.html#a76d81cb59e1b91c7f379064dd285aa93" title="The head slot containing the currently-being-serviced &quot;deficit&quot; async-receive request,...">m_user_request</a>, <a class="el" href="classipc_1_1transport_1_1sync__io_1_1Async__adapter__receiver.html#a13a636ca275a188bd3727e2d7c247f0e" title="Queue storing deficit async-receive requests queued up due to m_user_request being not null while mor...">m_pending_user_requests_q</a>, and receive-ops data of <a class="el" href="classipc_1_1transport_1_1sync__io_1_1Async__adapter__receiver.html#af07534b8b9beb4e47b1af513d82d7460" title="The core Core engine, implementing the sync_io pattern (see util::sync_io doc header).">m_sync_io</a>.  <a href="classipc_1_1transport_1_1sync__io_1_1Async__adapter__receiver.html#a113a43c175209f7e3293f75ab4bcd794">More...</a><br /></td></tr>
<tr class="separator:a113a43c175209f7e3293f75ab4bcd794"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0df3c0d0291cb4d3ea7fbd8214a12cb8"><td class="memItemLeft" align="right" valign="top">flow::async::Single_thread_task_loop &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classipc_1_1transport_1_1sync__io_1_1Async__adapter__receiver.html#a0df3c0d0291cb4d3ea7fbd8214a12cb8">m_worker</a></td></tr>
<tr class="memdesc:a0df3c0d0291cb4d3ea7fbd8214a12cb8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Single-thread worker pool for all internal async work. Referred to as thread W in comments.  <a href="classipc_1_1transport_1_1sync__io_1_1Async__adapter__receiver.html#a0df3c0d0291cb4d3ea7fbd8214a12cb8">More...</a><br /></td></tr>
<tr class="separator:a0df3c0d0291cb4d3ea7fbd8214a12cb8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af07534b8b9beb4e47b1af513d82d7460"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classipc_1_1transport_1_1sync__io_1_1Async__adapter__receiver.html#aeb37be595e9cfce9e0185acee7eeac80">Core</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classipc_1_1transport_1_1sync__io_1_1Async__adapter__receiver.html#af07534b8b9beb4e47b1af513d82d7460">m_sync_io</a></td></tr>
<tr class="memdesc:af07534b8b9beb4e47b1af513d82d7460"><td class="mdescLeft">&#160;</td><td class="mdescRight">The core <a class="el" href="classipc_1_1transport_1_1sync__io_1_1Async__adapter__receiver.html#aeb37be595e9cfce9e0185acee7eeac80" title="The sync_io::X type being adapted into async-I/O-pattern X.">Core</a> engine, implementing the <code><a class="el" href="namespaceipc_1_1transport_1_1sync__io.html" title="sync_io-pattern counterparts to async-I/O-pattern object types in parent namespace ipc::transport.">sync_io</a></code> pattern (see <a class="el" href="namespaceipc_1_1util_1_1sync__io.html" title="Contains common code, as well as important explanatory documentation in the following text,...">util::sync_io</a> doc header).  <a href="classipc_1_1transport_1_1sync__io_1_1Async__adapter__receiver.html#af07534b8b9beb4e47b1af513d82d7460">More...</a><br /></td></tr>
<tr class="separator:af07534b8b9beb4e47b1af513d82d7460"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><div class="compoundTemplParams">template&lt;typename Core_t&gt;<br />
class ipc::transport::sync_io::Async_adapter_receiver&lt; Core_t &gt;</div><p >Internal-use type that adapts a given PEER-state <a class="el" href="classipc_1_1transport_1_1sync__io_1_1Native__handle__receiver.html" title="A documentation-only concept defining the behavior of an object that is the sync_io-pattern counterpa...">sync_io::Native_handle_receiver</a> or <a class="el" href="classipc_1_1transport_1_1sync__io_1_1Blob__receiver.html" title="A documentation-only concept: what transport::Blob_receiver is to transport::Native_handle_receiver (...">sync_io::Blob_receiver</a> <em>core</em> into the async-I/O-pattern <a class="el" href="classipc_1_1transport_1_1sync__io_1_1Native__handle__receiver.html" title="A documentation-only concept defining the behavior of an object that is the sync_io-pattern counterpa...">Native_handle_receiver</a> or <a class="el" href="classipc_1_1transport_1_1sync__io_1_1Blob__receiver.html" title="A documentation-only concept: what transport::Blob_receiver is to transport::Native_handle_receiver (...">Blob_receiver</a>. </p>
<p >State-mutating logic of the latter is forwarded to a <code>*this</code>; while trivial <code>const</code> (in PEER state) things like <code>.receive_blob_max_size()</code> are forwarded directly to the core <code>sync_io::X</code>.</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classipc_1_1transport_1_1Native__socket__stream_1_1Impl.html" title="Internal, non-movable pImpl implementation of Native_socket_stream class.">transport::Native_socket_stream::Impl</a> uses this for 99% of its incoming-direction (PEER-state by definition) logic. </dd>
<dd>
<a class="el" href="classipc_1_1transport_1_1Blob__stream__mq__receiver__impl.html" title="Internal, non-movable pImpl-lite implementation of Blob_stream_mq_receiver class template.">transport::Blob_stream_mq_receiver_impl</a> uses this for 99% of its logic.</dd>
<dd>
<a class="el" href="classipc_1_1transport_1_1sync__io_1_1Async__adapter__sender.html" title="Internal-use type that adapts a given PEER-state sync_io::Native_handle_sender or sync_io::Blob_sende...">Async_adapter_sender</a> for the opposite-direction thing. E.g., <a class="el" href="classipc_1_1transport_1_1Native__socket__stream_1_1Impl.html" title="Internal, non-movable pImpl implementation of Native_socket_stream class.">transport::Native_socket_stream::Impl</a> uses that for 99% of its outgoing-direction logic.</dd></dl>
<h3>Threads and thread nomenclature; locking</h3>
<p >Thread U, thread W... locking... just see those sections in <a class="el" href="classipc_1_1transport_1_1Native__socket__stream_1_1Impl.html" title="Internal, non-movable pImpl implementation of Native_socket_stream class.">transport::Native_socket_stream::Impl</a> class doc header. We adopt that nomenclature and logic. However, as we are concerned with only one direction (op-type), we only deal with code in either thread U or W concerned with that. The other-direction code &ndash; if applicable (e.g., applicable for <code><a class="el" href="classipc_1_1transport_1_1sync__io_1_1Native__socket__stream.html" title="Implements both sync_io::Native_handle_sender and sync_io::Native_handle_receiver concepts by using a...">Native_socket_stream</a></code> which deals with both over 1 socket connection; N/A for <code>Blob_stream_mq_*</code> which uses separate objects entirely) &ndash; simply co-exists in the same thread W and "thread" U. (If <code><a class="el" href="classipc_1_1transport_1_1sync__io_1_1Native__socket__stream.html" title="Implements both sync_io::Native_handle_sender and sync_io::Native_handle_receiver concepts by using a...">Native_socket_stream</a></code> wanted to, it could even parallelize stuff in thread W by using separate worker threads Ws and Wr. As of this writing it does not, but it could &ndash; nothing in <code>*this</code> would change.)</p>
<p >Note, again, that we have our own <code>m_mutex</code>. If there is an opposing-direction counterpart <a class="el" href="classipc_1_1transport_1_1sync__io_1_1Async__adapter__sender.html" title="Internal-use type that adapts a given PEER-state sync_io::Native_handle_sender or sync_io::Blob_sende...">Async_adapter_sender</a>, then it has its own <code>m_mutex</code>; hence things can proceed concurrently.</p>
<h3>Impl design</h3>
<p >This is almost entirely subsumed by our <code><a class="el" href="namespaceipc_1_1transport_1_1sync__io.html" title="sync_io-pattern counterparts to async-I/O-pattern object types in parent namespace ipc::transport.">sync_io</a></code> core, <a class="el" href="classipc_1_1transport_1_1sync__io_1_1Async__adapter__receiver.html#aeb37be595e9cfce9e0185acee7eeac80" title="The sync_io::X type being adapted into async-I/O-pattern X.">Async_adapter_receiver::Core</a>, an instance of <a class="el" href="classipc_1_1transport_1_1sync__io_1_1Native__handle__receiver.html" title="A documentation-only concept defining the behavior of an object that is the sync_io-pattern counterpa...">sync_io::Native_handle_receiver</a> or <a class="el" href="classipc_1_1transport_1_1sync__io_1_1Blob__receiver.html" title="A documentation-only concept: what transport::Blob_receiver is to transport::Native_handle_receiver (...">sync_io::Blob_receiver</a>. It has a receive op-type (possibly among others), so we invoke its <code>"sync_io::*_sender:start_receive_blob_ops()"</code> during our initialization. After that:</p>
<p >For <a class="el" href="classipc_1_1transport_1_1sync__io_1_1Async__adapter__receiver.html#a2067b525e54efd90bdc584cf77f7ae4b" title="See Native_handle_receiver counterpart.">idle_timer_run()</a>, we can again just forward it to <code>m_sync_io</code>. There's no completion handler either, unlike with <code>.async_end_sending()</code>, so it's even simpler &ndash; just straight forwarding to the <code><a class="el" href="namespaceipc_1_1transport_1_1sync__io.html" title="sync_io-pattern counterparts to async-I/O-pattern object types in parent namespace ipc::transport.">sync_io</a></code> core.</p>
<p >For <a class="el" href="classipc_1_1transport_1_1sync__io_1_1Async__adapter__receiver.html#abcbc91de36b298c68e5461997a9a0263" title="See Native_handle_sender counterpart.">async_receive_native_handle()</a> (and its degenerate version <a class="el" href="classipc_1_1transport_1_1sync__io_1_1Async__adapter__receiver.html#ade3098cb69a47a374cf0354677e2fb0b" title="See Blob_receiver counterpart.">async_receive_blob()</a>) the <code>*_receiver</code> concept we implement has an extra feature on top of <a class="el" href="classipc_1_1transport_1_1sync__io_1_1Native__handle__receiver.html" title="A documentation-only concept defining the behavior of an object that is the sync_io-pattern counterpa...">sync_io::Native_handle_receiver</a> (and degenerate version, <a class="el" href="classipc_1_1transport_1_1sync__io_1_1Blob__receiver.html" title="A documentation-only concept: what transport::Blob_receiver is to transport::Native_handle_receiver (...">sync_io::Blob_receiver</a>): when 1 <a class="el" href="classipc_1_1transport_1_1sync__io_1_1Async__adapter__receiver.html#abcbc91de36b298c68e5461997a9a0263" title="See Native_handle_sender counterpart.">async_receive_native_handle()</a> is in progress asynchronously, it is allowed to invoke it again an arbitrary number of times, and they are to be served in the order they were called. Therefore:</p><ul>
<li>We maintain a "deficit" queue of these requests. The currently-served request is stored in <code><a class="el" href="structipc_1_1transport_1_1sync__io_1_1Async__adapter__receiver_1_1User__request.html" title="Data store representing a deficit user async-receive request: either one being currently handled by m...">User_request</a> m_user_request</code>. The queued-up subsequent ones are stored in queue with that same element type, <code>m_pending_user_requests_q</code>.</li>
<li>When the ongoing (single) <code>m_sync_io.async_receive_*()</code> does complete &ndash; which occurs in thread W &ndash; we emit the result (<code>Error_code</code>, <code>sz</code>) to the <code>"User_request::m_on_done_func"</code> (the completion handler from the user). Then we pop <code>m_pending_user_requests_q</code> (unless empty &ndash; no further "deficit") into <code>m_user_request</code> and service <em>that</em> one via <code>m_sync_io.async_receive_*()</code>. Rinse/repeat.</li>
</ul>
<p >If the destructor is invoked before <code>m_user_request</code> can get serviced, then in the dtor we execute <code>on_done_func(E)</code>, where E is operation-aborted. Once that's done the dtor can finish. </p>

<p class="definition">Definition at line <a class="el" href="async__adapter__rcv_8hpp_source.html#l00084">84</a> of file <a class="el" href="async__adapter__rcv_8hpp_source.html">async_adapter_rcv.hpp</a>.</p>
</div><h2 class="groupheader">Member Typedef Documentation</h2>
<a id="aeb37be595e9cfce9e0185acee7eeac80" name="aeb37be595e9cfce9e0185acee7eeac80"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aeb37be595e9cfce9e0185acee7eeac80">&#9670;&nbsp;</a></span>Core</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Core_t &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classipc_1_1transport_1_1sync__io_1_1Async__adapter__receiver.html">ipc::transport::sync_io::Async_adapter_receiver</a>&lt; Core_t &gt;::Core =  Core_t</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The <code>sync_io::X</code> type being adapted into async-I/O-pattern <code>X</code>. </p>

<p class="definition">Definition at line <a class="el" href="async__adapter__rcv_8hpp_source.html#l00092">92</a> of file <a class="el" href="async__adapter__rcv_8hpp_source.html">async_adapter_rcv.hpp</a>.</p>

</div>
</div>
<h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="a2f32f38020a0d21499b1c0b724ff332b" name="a2f32f38020a0d21499b1c0b724ff332b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2f32f38020a0d21499b1c0b724ff332b">&#9670;&nbsp;</a></span>Async_adapter_receiver()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Core_t &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classipc_1_1transport_1_1sync__io_1_1Async__adapter__receiver.html">ipc::transport::sync_io::Async_adapter_receiver</a>&lt; Core_t &gt;::Async_adapter_receiver </td>
          <td>(</td>
          <td class="paramtype">flow::log::Logger *&#160;</td>
          <td class="paramname"><em>logger_ptr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceipc_1_1util.html#ae6ac47812a90d1287c61e0b7de7bc4f5">util::String_view</a>&#160;</td>
          <td class="paramname"><em>log_pfx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">flow::async::Single_thread_task_loop *&#160;</td>
          <td class="paramname"><em>worker</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classipc_1_1transport_1_1sync__io_1_1Async__adapter__receiver.html#aeb37be595e9cfce9e0185acee7eeac80">Core</a> *&#160;</td>
          <td class="paramname"><em>sync_io</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Constructs the adapter around <code>sync_io::X</code> object <code>*sync_io</code>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">logger_ptr</td><td>Logger to use for logging subsequently. </td></tr>
    <tr><td class="paramname">log_pfx</td><td>String that shall precede ~all logged messages (e.g., <code>lexical_cast&lt;string&gt;(x)</code>, where <code>x</code> is an <code>X</code>.) </td></tr>
    <tr><td class="paramname">worker</td><td>The worker thread loop of <code>X</code>. Background work, as needed, will be posted onto this "thread W." Note that <code>X</code> may (or may not) share this thread with unrelated tasks; for example <code><a class="el" href="classipc_1_1transport_1_1sync__io_1_1Native__socket__stream.html" title="Implements both sync_io::Native_handle_sender and sync_io::Native_handle_receiver concepts by using a...">Native_socket_stream</a></code> uses it for both a <code>*this</code> (outgoing-direction) and an <a class="el" href="classipc_1_1transport_1_1sync__io_1_1Async__adapter__receiver.html" title="Internal-use type that adapts a given PEER-state sync_io::Native_handle_receiver or sync_io::Blob_rec...">Async_adapter_receiver</a> (incoming-direction). <code>*worker* must already be</code>-&gt;start()`ed. </td></tr>
    <tr><td class="paramname"><a class="el" href="namespaceipc_1_1transport_1_1sync__io.html" title="sync_io-pattern counterparts to async-I/O-pattern object types in parent namespace ipc::transport.">sync_io</a></td><td>The core object of <code>X</code>. It should have just (irreversibly) entered state PEER. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="async__adapter__rcv_8hpp_source.html#l00303">303</a> of file <a class="el" href="async__adapter__rcv_8hpp_source.html">async_adapter_rcv.hpp</a>.</p>

<p class="reference">References <a class="el" href="async__adapter__rcv_8hpp_source.html#l00250">ipc::transport::sync_io::Async_adapter_receiver&lt; Core_t &gt;::m_log_pfx</a>, <a class="el" href="async__adapter__rcv_8hpp_source.html#l00282">ipc::transport::sync_io::Async_adapter_receiver&lt; Core_t &gt;::m_mutex</a>, and <a class="el" href="async__adapter__rcv_8hpp_source.html#l00297">ipc::transport::sync_io::Async_adapter_receiver&lt; Core_t &gt;::m_sync_io</a>.</p>

</div>
</div>
<a id="a80428aeb0d3f9e836fe897fc1e42601a" name="a80428aeb0d3f9e836fe897fc1e42601a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a80428aeb0d3f9e836fe897fc1e42601a">&#9670;&nbsp;</a></span>~Async_adapter_receiver()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Core_t &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classipc_1_1transport_1_1sync__io_1_1Async__adapter__receiver.html">ipc::transport::sync_io::Async_adapter_receiver</a>&lt; Core_t &gt;::~<a class="el" href="classipc_1_1transport_1_1sync__io_1_1Async__adapter__receiver.html">Async_adapter_receiver</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>To be invoked after <code>-&gt;stop()</code>ping <code>*worker</code> (from ctor), as well as flushing any still-queued tasks in its <code>Task_engine</code> (via <code>.restart()</code> and <code>.poll()</code>), this satisfies the customer adapter dtor's contract which is to invoke any not-yet-fired completion handlers with special operation-aborted error code. </p>
<p >In our case that is either nothing or 1 <code>async_end_sending()</code> completion handler. If applicable the dtor returns once that handler has completed in an unspecified thread that is not the calling thread. </p>

<p class="definition">Definition at line <a class="el" href="async__adapter__rcv_8hpp_source.html#l00376">376</a> of file <a class="el" href="async__adapter__rcv_8hpp_source.html">async_adapter_rcv.hpp</a>.</p>

<p class="reference">References <a class="el" href="namespaceipc_1_1transport_1_1error.html#adfef15ef4e76cc55d652fbd9c2797297afe29343445a7bf167cc186a44bd2c6ed">ipc::transport::error::S_OBJECT_SHUTDOWN_ABORTED_COMPLETION_HANDLER</a>.</p>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="ade3098cb69a47a374cf0354677e2fb0b" name="ade3098cb69a47a374cf0354677e2fb0b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ade3098cb69a47a374cf0354677e2fb0b">&#9670;&nbsp;</a></span>async_receive_blob()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Core_t &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classipc_1_1transport_1_1sync__io_1_1Async__adapter__receiver.html">ipc::transport::sync_io::Async_adapter_receiver</a>&lt; Core_t &gt;::async_receive_blob </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespaceipc_1_1util.html#a6cb62ae434900f3a8915b33ec5d61a96">util::Blob_mutable</a> &amp;&#160;</td>
          <td class="paramname"><em>target_blob</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">flow::async::Task_asio_err_sz &amp;&amp;&#160;</td>
          <td class="paramname"><em>on_done_func</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>See <a class="el" href="classipc_1_1transport_1_1sync__io_1_1Blob__receiver.html" title="A documentation-only concept: what transport::Blob_receiver is to transport::Native_handle_receiver (...">Blob_receiver</a> counterpart. </p>
<p >However, this one is <code>void</code>, as there is no way <code>*this</code> is not in PEER state (by definition).</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">target_blob</td><td>See <a class="el" href="classipc_1_1transport_1_1sync__io_1_1Blob__receiver.html" title="A documentation-only concept: what transport::Blob_receiver is to transport::Native_handle_receiver (...">Blob_receiver</a> counterpart. </td></tr>
    <tr><td class="paramname">on_done_func</td><td>See <a class="el" href="classipc_1_1transport_1_1sync__io_1_1Blob__receiver.html" title="A documentation-only concept: what transport::Blob_receiver is to transport::Native_handle_receiver (...">Blob_receiver</a> counterpart. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="async__adapter__rcv_8hpp_source.html#l00428">428</a> of file <a class="el" href="async__adapter__rcv_8hpp_source.html">async_adapter_rcv.hpp</a>.</p>

</div>
</div>
<a id="abcbc91de36b298c68e5461997a9a0263" name="abcbc91de36b298c68e5461997a9a0263"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abcbc91de36b298c68e5461997a9a0263">&#9670;&nbsp;</a></span>async_receive_native_handle()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Core_t &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classipc_1_1transport_1_1sync__io_1_1Async__adapter__receiver.html">ipc::transport::sync_io::Async_adapter_receiver</a>&lt; Core_t &gt;::async_receive_native_handle </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespaceipc_1_1transport.html#a7ee4551983d9df16ec16a3139bac50e8">Native_handle</a> *&#160;</td>
          <td class="paramname"><em>target_hndl</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespaceipc_1_1util.html#a6cb62ae434900f3a8915b33ec5d61a96">util::Blob_mutable</a> &amp;&#160;</td>
          <td class="paramname"><em>target_meta_blob</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">flow::async::Task_asio_err_sz &amp;&amp;&#160;</td>
          <td class="paramname"><em>on_done_func</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>See <a class="el" href="classipc_1_1transport_1_1sync__io_1_1Native__handle__sender.html" title="A documentation-only concept defining the behavior of an object that is the sync_io-pattern counterpa...">Native_handle_sender</a> counterpart. </p>
<p >However, this one is <code>void</code>, as there is no way <code>*this</code> is not in PEER state (by definition).</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">target_hndl</td><td>See <a class="el" href="classipc_1_1transport_1_1sync__io_1_1Native__handle__sender.html" title="A documentation-only concept defining the behavior of an object that is the sync_io-pattern counterpa...">Native_handle_sender</a> counterpart. </td></tr>
    <tr><td class="paramname">target_meta_blob</td><td>See <a class="el" href="classipc_1_1transport_1_1sync__io_1_1Native__handle__sender.html" title="A documentation-only concept defining the behavior of an object that is the sync_io-pattern counterpa...">Native_handle_sender</a> counterpart. </td></tr>
    <tr><td class="paramname">on_done_func</td><td>See <a class="el" href="classipc_1_1transport_1_1sync__io_1_1Native__handle__sender.html" title="A documentation-only concept defining the behavior of an object that is the sync_io-pattern counterpa...">Native_handle_sender</a> counterpart. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="async__adapter__rcv_8hpp_source.html#l00414">414</a> of file <a class="el" href="async__adapter__rcv_8hpp_source.html">async_adapter_rcv.hpp</a>.</p>

</div>
</div>
<a id="a6cf425ab8e3258924e6d1db12da2fbf5" name="a6cf425ab8e3258924e6d1db12da2fbf5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6cf425ab8e3258924e6d1db12da2fbf5">&#9670;&nbsp;</a></span>async_receive_native_handle_impl()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Core_t &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classipc_1_1transport_1_1sync__io_1_1Async__adapter__receiver.html">ipc::transport::sync_io::Async_adapter_receiver</a>&lt; Core_t &gt;::async_receive_native_handle_impl </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespaceipc_1_1transport.html#a7ee4551983d9df16ec16a3139bac50e8">Native_handle</a> *&#160;</td>
          <td class="paramname"><em>target_hndl_or_null</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespaceipc_1_1util.html#a6cb62ae434900f3a8915b33ec5d61a96">util::Blob_mutable</a> &amp;&#160;</td>
          <td class="paramname"><em>target_meta_blob</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">flow::async::Task_asio_err_sz &amp;&amp;&#160;</td>
          <td class="paramname"><em>on_done_func</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Body of <a class="el" href="classipc_1_1transport_1_1sync__io_1_1Async__adapter__receiver.html#abcbc91de36b298c68e5461997a9a0263" title="See Native_handle_sender counterpart.">async_receive_native_handle()</a> and <a class="el" href="classipc_1_1transport_1_1sync__io_1_1Async__adapter__receiver.html#ade3098cb69a47a374cf0354677e2fb0b" title="See Blob_receiver counterpart.">async_receive_blob()</a>; with <code>target_hndl</code> null if and only if it's the latter as opposed to the former. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">target_hndl_or_null</td><td>See <a class="el" href="classipc_1_1transport_1_1sync__io_1_1Async__adapter__receiver.html#abcbc91de36b298c68e5461997a9a0263" title="See Native_handle_sender counterpart.">async_receive_native_handle()</a>; or null if it's the other API. If <code>!(Core::S_TRANSMIT_NATIVE_HANDLES)</code> this must be null. </td></tr>
    <tr><td class="paramname">target_meta_blob</td><td>See <a class="el" href="classipc_1_1transport_1_1sync__io_1_1Async__adapter__receiver.html#abcbc91de36b298c68e5461997a9a0263" title="See Native_handle_sender counterpart.">async_receive_native_handle()</a>. </td></tr>
    <tr><td class="paramname">on_done_func</td><td>See <a class="el" href="classipc_1_1transport_1_1sync__io_1_1Async__adapter__receiver.html#abcbc91de36b298c68e5461997a9a0263" title="See Native_handle_sender counterpart.">async_receive_native_handle()</a>. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="async__adapter__rcv_8hpp_source.html#l00435">435</a> of file <a class="el" href="async__adapter__rcv_8hpp_source.html">async_adapter_rcv.hpp</a>.</p>

<p class="reference">References <a class="el" href="namespaceipc_1_1transport_1_1error.html#adfef15ef4e76cc55d652fbd9c2797297aa667487757f9d6300f6888bac40bcc24">ipc::transport::error::S_SYNC_IO_WOULD_BLOCK</a>.</p>

</div>
</div>
<a id="a2067b525e54efd90bdc584cf77f7ae4b" name="a2067b525e54efd90bdc584cf77f7ae4b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2067b525e54efd90bdc584cf77f7ae4b">&#9670;&nbsp;</a></span>idle_timer_run()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Core_t &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classipc_1_1transport_1_1sync__io_1_1Async__adapter__receiver.html">ipc::transport::sync_io::Async_adapter_receiver</a>&lt; Core_t &gt;::idle_timer_run </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespaceipc_1_1util.html#ac66141280c3b7295a86b65209f31cc58">util::Fine_duration</a>&#160;</td>
          <td class="paramname"><em>timeout</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>See <a class="el" href="classipc_1_1transport_1_1sync__io_1_1Native__handle__receiver.html" title="A documentation-only concept defining the behavior of an object that is the sync_io-pattern counterpa...">Native_handle_receiver</a> counterpart. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">timeout</td><td>See <a class="el" href="classipc_1_1transport_1_1sync__io_1_1Native__handle__receiver.html" title="A documentation-only concept defining the behavior of an object that is the sync_io-pattern counterpa...">Native_handle_receiver</a> counterpart. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>See <a class="el" href="classipc_1_1transport_1_1sync__io_1_1Native__handle__receiver.html" title="A documentation-only concept defining the behavior of an object that is the sync_io-pattern counterpa...">Native_handle_receiver</a> counterpart. </dd></dl>

<p class="definition">Definition at line <a class="el" href="async__adapter__rcv_8hpp_source.html#l00758">758</a> of file <a class="el" href="async__adapter__rcv_8hpp_source.html">async_adapter_rcv.hpp</a>.</p>

</div>
</div>
<a id="a98d7b3caa0f0b00c75671278e7971017" name="a98d7b3caa0f0b00c75671278e7971017"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a98d7b3caa0f0b00c75671278e7971017">&#9670;&nbsp;</a></span>on_sync_io_rcv_done()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Core_t &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classipc_1_1transport_1_1sync__io_1_1Async__adapter__receiver.html">ipc::transport::sync_io::Async_adapter_receiver</a>&lt; Core_t &gt;::on_sync_io_rcv_done </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespaceipc.html#aa3192e586cc45d3e7c22463bf2760f89">Error_code</a> &amp;&#160;</td>
          <td class="paramname"><em>err_code</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>sz</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Invoked via active-event API, handles the async completion of <code>m_sync_io.async_receive_*()</code> operation. </p>
<p >Can be invoked from thread W only, and <a class="el" href="classipc_1_1transport_1_1sync__io_1_1Async__adapter__receiver.html#a113a43c175209f7e3293f75ab4bcd794" title="Protects m_user_request, m_pending_user_requests_q, and receive-ops data of m_sync_io.">m_mutex</a> must be locked. <a class="el" href="classipc_1_1transport_1_1sync__io_1_1Async__adapter__receiver.html#a76d81cb59e1b91c7f379064dd285aa93" title="The head slot containing the currently-being-serviced &quot;deficit&quot; async-receive request,...">m_user_request</a> must not be null.</p>
<p >This method iteratively, synchronously leverages <a class="el" href="classipc_1_1transport_1_1sync__io_1_1Async__adapter__receiver.html#af07534b8b9beb4e47b1af513d82d7460" title="The core Core engine, implementing the sync_io pattern (see util::sync_io doc header).">m_sync_io</a> to read as many in-messages available in the transport as possible, until: the request deficit is met (either by reading enough messages to satisfy <a class="el" href="classipc_1_1transport_1_1sync__io_1_1Async__adapter__receiver.html#a76d81cb59e1b91c7f379064dd285aa93" title="The head slot containing the currently-being-serviced &quot;deficit&quot; async-receive request,...">m_user_request</a> and <a class="el" href="classipc_1_1transport_1_1sync__io_1_1Async__adapter__receiver.html#a13a636ca275a188bd3727e2d7c247f0e" title="Queue storing deficit async-receive requests queued up due to m_user_request being not null while mor...">m_pending_user_requests_q</a>; or by encountering pipe-hosing error) or would-block. In the latter case another async-wait is initiated by this method synchronously.</p>
<p >The first action, before those potential further reads, is to <a class="el" href="classipc_1_1transport_1_1sync__io_1_1Async__adapter__receiver.html#afa5b0ab6ad54e0d3c93550226bfe2b33" title="Invoked from thread U/W (async_receive_native_handle_impl()) or thread W (active-event API),...">process_msg_or_error()</a> the just-received (or pipe-hosing would-be) message. Then for each further in-message <a class="el" href="classipc_1_1transport_1_1sync__io_1_1Async__adapter__receiver.html#afa5b0ab6ad54e0d3c93550226bfe2b33" title="Invoked from thread U/W (async_receive_native_handle_impl()) or thread W (active-event API),...">process_msg_or_error()</a> is again invoked.</p>
<p >For each request satisfied, a separate user handler is posted onto thread W to execute in order.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">err_code</td><td>Result to pass to user (if truthy, all pending requests; else to <a class="el" href="classipc_1_1transport_1_1sync__io_1_1Async__adapter__receiver.html#a76d81cb59e1b91c7f379064dd285aa93" title="The head slot containing the currently-being-serviced &quot;deficit&quot; async-receive request,...">m_user_request</a> only). </td></tr>
    <tr><td class="paramname">sz</td><td>Result to pass to user (ditto). </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="async__adapter__rcv_8hpp_source.html#l00672">672</a> of file <a class="el" href="async__adapter__rcv_8hpp_source.html">async_adapter_rcv.hpp</a>.</p>

<p class="reference">References <a class="el" href="namespaceipc_1_1transport_1_1error.html#adfef15ef4e76cc55d652fbd9c2797297aa667487757f9d6300f6888bac40bcc24">ipc::transport::error::S_SYNC_IO_WOULD_BLOCK</a>.</p>

</div>
</div>
<a id="afa5b0ab6ad54e0d3c93550226bfe2b33" name="afa5b0ab6ad54e0d3c93550226bfe2b33"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afa5b0ab6ad54e0d3c93550226bfe2b33">&#9670;&nbsp;</a></span>process_msg_or_error()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Core_t &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classipc_1_1transport_1_1sync__io_1_1Async__adapter__receiver.html">ipc::transport::sync_io::Async_adapter_receiver</a>&lt; Core_t &gt;::process_msg_or_error </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespaceipc.html#aa3192e586cc45d3e7c22463bf2760f89">Error_code</a> &amp;&#160;</td>
          <td class="paramname"><em>err_code</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>sz</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Invoked from thread U/W (<a class="el" href="classipc_1_1transport_1_1sync__io_1_1Async__adapter__receiver.html#a6cf425ab8e3258924e6d1db12da2fbf5" title="Body of async_receive_native_handle() and async_receive_blob(); with target_hndl null if and only if ...">async_receive_native_handle_impl()</a>) or thread W (active-event API), handles a completed <code>m_sync_io.async_receive_*()</code> &ndash; whose results are to be given as args &ndash; by (1) updating <a class="el" href="classipc_1_1transport_1_1sync__io_1_1Async__adapter__receiver.html#a76d81cb59e1b91c7f379064dd285aa93" title="The head slot containing the currently-being-serviced &quot;deficit&quot; async-receive request,...">m_user_request</a> and <a class="el" href="classipc_1_1transport_1_1sync__io_1_1Async__adapter__receiver.html#a13a636ca275a188bd3727e2d7c247f0e" title="Queue storing deficit async-receive requests queued up due to m_user_request being not null while mor...">m_pending_user_requests_q</a> and (2) posting any appropriate handlers onto thread W. </p>
<p >See notes for <a class="el" href="classipc_1_1transport_1_1sync__io_1_1Async__adapter__receiver.html#a98d7b3caa0f0b00c75671278e7971017" title="Invoked via active-event API, handles the async completion of m_sync_io.async_receive_*() operation.">on_sync_io_rcv_done()</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">err_code</td><td>See <a class="el" href="classipc_1_1transport_1_1sync__io_1_1Async__adapter__receiver.html#a98d7b3caa0f0b00c75671278e7971017" title="Invoked via active-event API, handles the async completion of m_sync_io.async_receive_*() operation.">on_sync_io_rcv_done()</a>. </td></tr>
    <tr><td class="paramname">sz</td><td>See <a class="el" href="classipc_1_1transport_1_1sync__io_1_1Async__adapter__receiver.html#a98d7b3caa0f0b00c75671278e7971017" title="Invoked via active-event API, handles the async completion of m_sync_io.async_receive_*() operation.">on_sync_io_rcv_done()</a>. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="async__adapter__rcv_8hpp_source.html#l00561">561</a> of file <a class="el" href="async__adapter__rcv_8hpp_source.html">async_adapter_rcv.hpp</a>.</p>

<p class="reference">References <a class="el" href="namespaceipc_1_1transport_1_1error.html#adfef15ef4e76cc55d652fbd9c2797297aa667487757f9d6300f6888bac40bcc24">ipc::transport::error::S_SYNC_IO_WOULD_BLOCK</a>.</p>

</div>
</div>
<h2 class="groupheader">Member Data Documentation</h2>
<a id="a5dd1bf37b817a3ebbb968d34f0d240b1" name="a5dd1bf37b817a3ebbb968d34f0d240b1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5dd1bf37b817a3ebbb968d34f0d240b1">&#9670;&nbsp;</a></span>m_log_pfx</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Core_t &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const std::string <a class="el" href="classipc_1_1transport_1_1sync__io_1_1Async__adapter__receiver.html">ipc::transport::sync_io::Async_adapter_receiver</a>&lt; Core_t &gt;::m_log_pfx</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>See <code>log_pfx</code> arg of ctor. </p>

<p class="definition">Definition at line <a class="el" href="async__adapter__rcv_8hpp_source.html#l00250">250</a> of file <a class="el" href="async__adapter__rcv_8hpp_source.html">async_adapter_rcv.hpp</a>.</p>

<p class="reference">Referenced by <a class="el" href="async__adapter__rcv_8hpp_source.html#l00303">ipc::transport::sync_io::Async_adapter_receiver&lt; Core_t &gt;::Async_adapter_receiver()</a>.</p>

</div>
</div>
<a id="a113a43c175209f7e3293f75ab4bcd794" name="a113a43c175209f7e3293f75ab4bcd794"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a113a43c175209f7e3293f75ab4bcd794">&#9670;&nbsp;</a></span>m_mutex</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Core_t &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">flow::util::Mutex_non_recursive <a class="el" href="classipc_1_1transport_1_1sync__io_1_1Async__adapter__receiver.html">ipc::transport::sync_io::Async_adapter_receiver</a>&lt; Core_t &gt;::m_mutex</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">mutable</span><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Protects <a class="el" href="classipc_1_1transport_1_1sync__io_1_1Async__adapter__receiver.html#a76d81cb59e1b91c7f379064dd285aa93" title="The head slot containing the currently-being-serviced &quot;deficit&quot; async-receive request,...">m_user_request</a>, <a class="el" href="classipc_1_1transport_1_1sync__io_1_1Async__adapter__receiver.html#a13a636ca275a188bd3727e2d7c247f0e" title="Queue storing deficit async-receive requests queued up due to m_user_request being not null while mor...">m_pending_user_requests_q</a>, and receive-ops data of <a class="el" href="classipc_1_1transport_1_1sync__io_1_1Async__adapter__receiver.html#af07534b8b9beb4e47b1af513d82d7460" title="The core Core engine, implementing the sync_io pattern (see util::sync_io doc header).">m_sync_io</a>. </p>

<p class="definition">Definition at line <a class="el" href="async__adapter__rcv_8hpp_source.html#l00282">282</a> of file <a class="el" href="async__adapter__rcv_8hpp_source.html">async_adapter_rcv.hpp</a>.</p>

<p class="reference">Referenced by <a class="el" href="async__adapter__rcv_8hpp_source.html#l00303">ipc::transport::sync_io::Async_adapter_receiver&lt; Core_t &gt;::Async_adapter_receiver()</a>.</p>

</div>
</div>
<a id="a13a636ca275a188bd3727e2d7c247f0e" name="a13a636ca275a188bd3727e2d7c247f0e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a13a636ca275a188bd3727e2d7c247f0e">&#9670;&nbsp;</a></span>m_pending_user_requests_q</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Core_t &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::queue&lt;typename <a class="el" href="structipc_1_1transport_1_1sync__io_1_1Async__adapter__receiver_1_1User__request.html#ad716a5458992596636d5e3e4f9d83e9b">User_request::Ptr</a>&gt; <a class="el" href="classipc_1_1transport_1_1sync__io_1_1Async__adapter__receiver.html">ipc::transport::sync_io::Async_adapter_receiver</a>&lt; Core_t &gt;::m_pending_user_requests_q</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Queue storing deficit async-receive requests queued up due to <a class="el" href="classipc_1_1transport_1_1sync__io_1_1Async__adapter__receiver.html#a76d81cb59e1b91c7f379064dd285aa93" title="The head slot containing the currently-being-serviced &quot;deficit&quot; async-receive request,...">m_user_request</a> being not null while more <code>async_receive_*()</code> invocations being made by user. </p>
<p >One can think of the "overall" queue as being <a class="el" href="classipc_1_1transport_1_1sync__io_1_1Async__adapter__receiver.html#a76d81cb59e1b91c7f379064dd285aa93" title="The head slot containing the currently-being-serviced &quot;deficit&quot; async-receive request,...">m_user_request</a> followed by the elements in this <a class="el" href="classipc_1_1transport_1_1sync__io_1_1Async__adapter__receiver.html#a13a636ca275a188bd3727e2d7c247f0e" title="Queue storing deficit async-receive requests queued up due to m_user_request being not null while mor...">m_pending_user_requests_q</a>. See class doc header for design discussion.</p>
<p >Protected by <a class="el" href="classipc_1_1transport_1_1sync__io_1_1Async__adapter__receiver.html#a113a43c175209f7e3293f75ab4bcd794" title="Protects m_user_request, m_pending_user_requests_q, and receive-ops data of m_sync_io.">m_mutex</a>.</p>
<h3>Rationale for not subsuming <a class="el" href="classipc_1_1transport_1_1sync__io_1_1Async__adapter__receiver.html#a76d81cb59e1b91c7f379064dd285aa93" title="The head slot containing the currently-being-serviced &quot;deficit&quot; async-receive request,...">m_user_request</a> directly into this queue</h3>
<p >It's the same amount of stuff; so the reason is stylistic in a subjective way. Basically a low-level async read-op will target the meta-blob <em>directly</em> inside the head <a class="el" href="structipc_1_1transport_1_1sync__io_1_1Async__adapter__receiver_1_1User__request.html" title="Data store representing a deficit user async-receive request: either one being currently handled by m...">User_request</a> in the "overall" queue but never any of the subsequently queued requests; in my (ygoldfel) view it is clearer to express it as always targeting <a class="el" href="classipc_1_1transport_1_1sync__io_1_1Async__adapter__receiver.html#a76d81cb59e1b91c7f379064dd285aa93" title="The head slot containing the currently-being-serviced &quot;deficit&quot; async-receive request,...">m_user_request</a> rather than <code>*(m_pending_user_requests_q.front())</code>. </p>

<p class="definition">Definition at line <a class="el" href="async__adapter__rcv_8hpp_source.html#l00279">279</a> of file <a class="el" href="async__adapter__rcv_8hpp_source.html">async_adapter_rcv.hpp</a>.</p>

</div>
</div>
<a id="af07534b8b9beb4e47b1af513d82d7460" name="af07534b8b9beb4e47b1af513d82d7460"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af07534b8b9beb4e47b1af513d82d7460">&#9670;&nbsp;</a></span>m_sync_io</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Core_t &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classipc_1_1transport_1_1sync__io_1_1Async__adapter__receiver.html#aeb37be595e9cfce9e0185acee7eeac80">Core</a>&amp; <a class="el" href="classipc_1_1transport_1_1sync__io_1_1Async__adapter__receiver.html">ipc::transport::sync_io::Async_adapter_receiver</a>&lt; Core_t &gt;::m_sync_io</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>The core <a class="el" href="classipc_1_1transport_1_1sync__io_1_1Async__adapter__receiver.html#aeb37be595e9cfce9e0185acee7eeac80" title="The sync_io::X type being adapted into async-I/O-pattern X.">Core</a> engine, implementing the <code><a class="el" href="namespaceipc_1_1transport_1_1sync__io.html" title="sync_io-pattern counterparts to async-I/O-pattern object types in parent namespace ipc::transport.">sync_io</a></code> pattern (see <a class="el" href="namespaceipc_1_1util_1_1sync__io.html" title="Contains common code, as well as important explanatory documentation in the following text,...">util::sync_io</a> doc header). </p>
<p >See our class doc header for overview of how we use it (the aforementioned <code><a class="el" href="namespaceipc_1_1transport_1_1sync__io.html" title="sync_io-pattern counterparts to async-I/O-pattern object types in parent namespace ipc::transport.">sync_io</a></code> doc header talks about the <code><a class="el" href="namespaceipc_1_1transport_1_1sync__io.html" title="sync_io-pattern counterparts to async-I/O-pattern object types in parent namespace ipc::transport.">sync_io</a></code> pattern generally).</p>
<p >Thus, <a class="el" href="classipc_1_1transport_1_1sync__io_1_1Async__adapter__receiver.html#af07534b8b9beb4e47b1af513d82d7460" title="The core Core engine, implementing the sync_io pattern (see util::sync_io doc header).">m_sync_io</a> is the synchronous engine that we use to perform our work in our asynchronous boost.asio loop running in thread W (<a class="el" href="classipc_1_1transport_1_1sync__io_1_1Async__adapter__receiver.html#a0df3c0d0291cb4d3ea7fbd8214a12cb8" title="Single-thread worker pool for all internal async work. Referred to as thread W in comments.">m_worker</a>) while collaborating with user thread(s) a/k/a thread U. (Recall that the user may choose to set up their own event loop/thread(s) &ndash; boost.asio-based or otherwise &ndash; and use their own equivalent of an <a class="el" href="classipc_1_1transport_1_1sync__io_1_1Async__adapter__receiver.html#af07534b8b9beb4e47b1af513d82d7460" title="The core Core engine, implementing the sync_io pattern (see util::sync_io doc header).">m_sync_io</a> instead.) </p>

<p class="definition">Definition at line <a class="el" href="async__adapter__rcv_8hpp_source.html#l00297">297</a> of file <a class="el" href="async__adapter__rcv_8hpp_source.html">async_adapter_rcv.hpp</a>.</p>

<p class="reference">Referenced by <a class="el" href="async__adapter__rcv_8hpp_source.html#l00303">ipc::transport::sync_io::Async_adapter_receiver&lt; Core_t &gt;::Async_adapter_receiver()</a>.</p>

</div>
</div>
<a id="a76d81cb59e1b91c7f379064dd285aa93" name="a76d81cb59e1b91c7f379064dd285aa93"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a76d81cb59e1b91c7f379064dd285aa93">&#9670;&nbsp;</a></span>m_user_request</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Core_t &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structipc_1_1transport_1_1sync__io_1_1Async__adapter__receiver_1_1User__request.html#ad716a5458992596636d5e3e4f9d83e9b">User_request::Ptr</a> <a class="el" href="classipc_1_1transport_1_1sync__io_1_1Async__adapter__receiver.html">ipc::transport::sync_io::Async_adapter_receiver</a>&lt; Core_t &gt;::m_user_request</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>The <em>head slot</em> containing the currently-being-serviced "deficit" async-receive request, with a meta-blob <em>potentially</em> being async-written to; null if there is no pending <a class="el" href="classipc_1_1transport_1_1sync__io_1_1Async__adapter__receiver.html#abcbc91de36b298c68e5461997a9a0263" title="See Native_handle_sender counterpart.">async_receive_native_handle()</a>. </p>
<p >It is the "fulcrum" of the consumer-producer state machine described in doc header impl section's design discussion: If null there is no deficit; if not null there is an <em>overall deficit</em>. In the former case, at steady state, <code>m_pending_user_requests_q.empty() == true</code>.</p>
<p >Protected by <a class="el" href="classipc_1_1transport_1_1sync__io_1_1Async__adapter__receiver.html#a113a43c175209f7e3293f75ab4bcd794" title="Protects m_user_request, m_pending_user_requests_q, and receive-ops data of m_sync_io.">m_mutex</a>.</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classipc_1_1transport_1_1sync__io_1_1Async__adapter__receiver.html#a13a636ca275a188bd3727e2d7c247f0e" title="Queue storing deficit async-receive requests queued up due to m_user_request being not null while mor...">m_pending_user_requests_q</a> </dd></dl>

<p class="definition">Definition at line <a class="el" href="async__adapter__rcv_8hpp_source.html#l00263">263</a> of file <a class="el" href="async__adapter__rcv_8hpp_source.html">async_adapter_rcv.hpp</a>.</p>

</div>
</div>
<a id="a0df3c0d0291cb4d3ea7fbd8214a12cb8" name="a0df3c0d0291cb4d3ea7fbd8214a12cb8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0df3c0d0291cb4d3ea7fbd8214a12cb8">&#9670;&nbsp;</a></span>m_worker</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Core_t &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">flow::async::Single_thread_task_loop&amp; <a class="el" href="classipc_1_1transport_1_1sync__io_1_1Async__adapter__receiver.html">ipc::transport::sync_io::Async_adapter_receiver</a>&lt; Core_t &gt;::m_worker</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Single-thread worker pool for all internal async work. Referred to as thread W in comments. </p>

<p class="definition">Definition at line <a class="el" href="async__adapter__rcv_8hpp_source.html#l00285">285</a> of file <a class="el" href="async__adapter__rcv_8hpp_source.html">async_adapter_rcv.hpp</a>.</p>

</div>
</div>
<hr/>The documentation for this class was generated from the following files:<ul>
<li>transport/detail/<a class="el" href="detail_2transport__fwd_8hpp_source.html">transport_fwd.hpp</a></li>
<li>transport/sync_io/detail/<a class="el" href="async__adapter__rcv_8hpp_source.html">async_adapter_rcv.hpp</a></li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Thu Feb 15 2024 03:11:50 for Flow-IPC by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.4
</small></address>
</body>
</html>
